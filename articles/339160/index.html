<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>t1ha = Fast Positive Hash</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Slightly less than the fastest, portable, 64-bit hash function, with decent quality. 
 Yes, and in the ladies, something like this. Read on? 
 Russian...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>t1ha = Fast Positive Hash</h1><div class="post__text post__text-html js-mediator-article"><p>  Slightly less than the fastest, portable, 64-bit hash function, with decent quality. <br>  Yes, and in the ladies, something like this.  Read on? <br>  <em><a href="https://habr.com/en/post/439156/">Russian version is here</a> .</em> </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Instead of Disclaimer</b> <div class="spoiler_text"><p>  We omit the definition of hash functions along with a detailed listing of the properties and requirements for their cryptographic application, assuming that the reader either owns the necessary minimums of knowledge or <a href="https://yandex.ru/">fills them up</a> .  We also agree that hereinafter we mean non-cryptographic (cryptographically unstable) hash functions, unless explicitly stated otherwise. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Banality</b> <div class="spoiler_text"><p>  Hashing is applied in the mass of algorithms, while almost always the most efficient (fast) data processing is required, along with a certain minimum level of hashing quality.  Moreover, the term ‚Äúquality‚Äù means, first of all, ‚Äúconditional randomness‚Äù (stochasticity) of the result with respect to the initial data.  Somewhat less often additional requirements are imposed: resistance to the deliberate generation of collisions or irreversibility. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">A little more bore</b> <div class="spoiler_text"><p>  For a slender presentation, it is necessary to define the concept of ‚Äúquality‚Äù hash functions and the rest of the requirements in a little more detail: </p><br><ul><li>  Baseline quality and <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D1%2584%25D1%2584%25D0%25B5%25D0%25BA%25D1%2582">avalanche effect</a> : Changing one or more arbitrary bits in an arbitrary set of source data causes each bit of the result to change with a probability of ¬Ω. </li><li>  Irreversibility (resistance to the restoration of the first pre-image): The impossibility of obtaining the original data or individual bits by the hash result. </li><li>  Resistance to selection for a given result (resistance to collisions of the first kind or to the search for the second preimage): The difficulty of finding / selecting the original data set in order to obtain a specified result or part of it, including when the initial data set is known. </li><li>  Resistance to the selection of messages (resistance to collisions of the second kind): The difficulty of finding / selecting two different data sets that would give the same result or the coincidence of the significant part. </li></ul></div></div><br><p>  Omitting citing evidence and other calculations, we can state: </p><br><ul><li>  Proper execution of all items, while ensuring performance, is quite a difficult task, the solution of which gives a good cryptographic hash function.  But we are not going to do it yet. </li><li>  Providing basic quality requires a sufficiently large number of ALU operations.  Simply put, quality always conflicts with speed. </li><li>  Obtaining a qualitative result with a bit depth greater than the bit depth of ALU operations requires more than a fold increase in the number of mixing, and therefore basic ALU operations. </li><li>  In general, the <em>creation of a fast hash function involves achieving a weighted compromise between speed, quality and bit depth of the result</em> . </li></ul><br><p>  So, we can say that <strong>t1ha</strong> appeared as a result of searching for a compromise between quality and speed, at the same time taking into account the capabilities of modern processors and the already found methods (arithmetic-logical combinations) of mixing and spreading dependencies (avalanche effect). </p><br><p>  The basic version of <strong>t1ha</strong> is the (most) fast portable hash function for constructing hash tables and other related applications.  Therefore, the basic version of <strong>t1ha is</strong> focused on 64-bit little-endian architectures, accepts a 64-bit primitive value (seed) and produces a 64-bit result, which includes a key-length gain and a seed.  It is worth noting that <strong>t1ha is</strong> intentionally designed to return 0 for zero input data (a key of zero size and zero seed). </p><br><div class="spoiler">  <b class="spoiler_title">Decided to take out responses to comments</b> <div class="spoiler_text"><p>  <strong>64-bit operations</strong> : It may be worthwhile to clarify that it is 64-bit operations that give speed and quality without selecting portability.  Actually, the wider the digit capacity of arithmetic operations, the more they produce an avalanche effect and better mix the data.  Well, data processing, all other things being equal, is certainly faster by 8 bytes than by 4. On the other hand, exactly 64-bit operations are natively available on many modern processors, and can be more or less tolerably translated into 32-bit ones.  All other options, including <a href="https://ru.wikipedia.org/wiki/SIMD">SIMD</a> operations, force us to greatly sacrifice portability and / or speed on non-native platforms. </p><br><p>  <strong>64-bit result</strong> : To construct hash tables, in many cases, a smaller width result is really enough.  Even 32 bits may be more than enough.  However, when using 64-bit operations, the 64-bit result is actually obtained by itself.  At the same time, a sufficiently high-quality 64-bit hash result allows you to quickly perform a comparison for non-equality, and with good accuracy to compare for equality. </p><br><p>  The above-mentioned "magic" of replacing comparisons can be incomprehensible and unclaimed, and can <strong>increase the speed of work by an order of magnitude</strong> only due to the locality of the data, i.e.  Smaller CPU cache flushing.  Simply put, you can build a hash table structure so that the calculated hash values ‚Äã‚Äãlie side by side (packed in cache lines).  And for real data the processor had to go only if the hash values ‚Äã‚Äãcoincided.  And in this case, the <em>64-bits from t1ha allow you to get the ultimate result</em> .  And 128 bits will not give a win anymore, but taking less from 64 bits is always possible. </p><br><p>  <strong>Comparison with HighwayHash</strong> : I have a twofold attitude to this <a href="https://github.com/google/highwayhash">unofficial project of Google employees</a> . </p><br><ol><li>  First: On the one hand, good code and excellent technical implementation.  On the other hand, <em>HighwayHash is</em> positioned as <em>possibly</em> cryptographically resistant (at least equal to <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> ).  Inside HighwayHash there are a lot of manipulations that suggest that the result will not be bad.  However, there is no evidence to rely on this.  This proof of "persistence" comes down to the results of statistical tests, but without the ability to reproduce them (somehow, I even <a href="https://github.com/google/highwayhash/issues/41">allowed myself to be superfluous</a> ). </li><li>  Secondly: HighwayHash is really fast only on x86_64 with AVX2 or SSE41.  Isn't it easier to use AES-NI or SHA acceleration? </li></ol><br><p>  If all goes well, then additional options will appear in the t1ha suite (primarily for the width of the result) and optimized for E2K.  On this topic comparison with <em>HighwayHash,</em> I would like to close. </p></div></div><br><hr><br><h2 id="kachestvo">  Quality </h2><br><p>  To evaluate the quality of the hash function in all aspects is quite difficult.  You can go analytically, or conduct various statistical tests.  Unfortunately, the analytical approach is not very effective for evaluating hash functions with a compromise between quality and speed.  Moreover, a comparative analytical evaluation of such functions tends to be subjective. </p><br><p>  In contrast, for statistical tests it is easy to obtain transparent quantitative estimates.  At the same time there are well-proven test packages, such as <a href="https://github.com/aappleby/smhasher">SMHasher</a> .  For <em>t1ha, the</em> results are simple - all <strong>t1ha</strong> variants pass all tests without any comments.  On the other hand, one should not assume that t1ha has any properties in excess of those that are necessary for the target application (building hash tables). </p><br><p>  The number of collisions at all levels of <strong>t1ha</strong> variants corresponds to <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25C2%25AB%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25C2%25BB">the birthday paradox</a> .  In a stricter formulation, the probability of collisions <strong>t1ha</strong> corresponds to the probability of coincidence of random discrete values ‚Äã‚Äãof the corresponding capacity. <br>  A similar probability of collisions for all more or less high-quality hash functions.  But this is exactly the probability, so a literal number of collisions can vary on a specific data set. </p><br><p> After the first publication of this article, <a href="https://github.com/demerphq/smhasher">Yves Orton discovered</a> that the first level <code>t1ha1()</code> variant does not always meet the <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D1%2584%25D1%2584%25D0%25B5%25D0%25BA%25D1%2582">strict avalanche criterion</a> .  This drawback is insignificant for the targeted applications of <code>t1ha1()</code> and imperceptible from a practical point of view.  However, this disadvantage is eliminated in the next <code>t1ha2()</code> level, which was originally planned to provide a slightly higher quality.  On new processors, with the use of current versions of compilers, <code>t1ha2()</code> on average, one cycle faster than <code>t1ha1()</code> , and in other cases it can be one cycle slower.  It is worth noting that <code>t1ha2()</code> additionally offers streaming hashing mode and a 128-bit result. </p><br><p>  Readers would certainly appreciate a thorough and in-depth analysis of the quality and / or stamina of <strong>t1ha</strong> .  However, based on the target <strong>t1ha</strong> application <strong>areas,</strong> this seems redundant.  Simply put, speed was more important to us, including for short keys.  Therefore, multi-round mixing was not considered.  The present <em>t1ha</em> saves on <del>  matches </del>  cycles and gives a 64-bit result - it is practically meaningless to measure the compromise found otherwise than statistically, and these results are simply good. </p><br><div class="spoiler">  <b class="spoiler_title">In fact</b> <div class="spoiler_text"><p>  I just take an example in statistical prove with <a href="https://arxiv.org/abs/1612.06257">colleagues from Google</a> ;) </p></div></div><br><hr><br><h2 id="benchmarki">  Benchmarks </h2><br><p>  It is necessary to clarify the presence of the phrase ‚Äú <em>the fastest</em> ‚Äù in the title.  Indeed, it is extremely unlikely that there is a hash function that will be useful and at the same time the fastest on all platforms / architectures.  Different sets of instructions are available on different processors, and similar instructions are executed with different efficiencies.  Obviously, the ‚Äú <em>universal fastest</em> ‚Äù function most likely cannot be created.  However, it seems acceptable to use the ‚Äúfastest‚Äù function that is portable and at the same time the fastest, at least on the most common platform (x86_64), while having little chance of losing on any modern processor with a decent optimizing compiler. </p><br><p>  The source code of the project includes a test that checks both the correctness of the result and measures the speed of each implemented version.  At the same time, on x86, depending on the capabilities of the processor (and compiler), additional variants of functions can be checked, and measurements are made in processor cycles. </p><br><p>  In addition, the project website contains tables with the results of performance measurements through a modified version of <a href="https://github.com/rurban/smhasher">SMHasher from Reini Urban</a> .  Accordingly, all figures can be double-checked and / or get results on a specific processor using a specific compiler. </p><br><p>  Here you can make a comparison with some closest competitors t1ha. </p><br><p>  <strong>Hashing short keys</strong> (average for 1..31 bytes). <br>  <em>We look at the right column "Cycles / Hash" (the smaller the value, the better)</em> : </p><br><table><thead><tr><th>  Function </th><th>  MiB / Second </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35.55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43.42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51.77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56.17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46.33 </td></tr></tbody></table><br><p>  <strong>Hashing long keys</strong> (256 Kb). <br>  <em>We look at the middle column ‚ÄúMiB / Second‚Äù (the higher the value, the better)</em> : </p><br><table><thead><tr><th>  Function </th><th>  MiB / Second </th><th>  Cycles / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35.55 </td></tr><tr><td>  FarmHash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51.77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56.17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60.39 </td></tr></tbody></table><br><hr><br><h2 id="varianty-t1ha">  Options t1ha </h2><br><p>  Development <strong>t1ha</strong> pursued purely practical purposes.  The first such goal was to obtain a fast portable and sufficiently high-quality function for constructing hash tables. </p><br><p>  Then the fastest version of the hash function was required, which would give a result of comparable quality, but was adapted to the target platform as much as possible.  For example, the basic <strong>t1ha</strong> version works with little-endian byte order, which is why on big-endian architectures conversion is necessary with inevitable loss of performance.  So why not get rid of unnecessary operations on a specific target platform?  In the same way, several more options were added: </p><br><ul><li>  Simplified version for 32-bit platforms, both little and big-endian. </li><li>  Option using AES-NI instructions, but without AVX. </li><li>  Two options using the AES-NI and AVX instructions. </li></ul><br><p>  A little later, it became clear that more options would be needed that were designed for various applications, including different results, the quality and durability requirements.  Such diversity required restoring order.  What was expressed in the change of the naming scheme, in which the numeric suffix denotes the ‚Äúlevel‚Äù of the function: </p><br><ul><li>  <code>t1ha0()</code> is the fastest option for the current processor. </li><li>  <code>t1ha1()</code> is the basic portable 64-bit version of t1ha. </li><li>  <code>t1ha2()</code> is a portable 64-bit version with a little more concern for quality. </li><li>  <code>t1ha3()</code> is a fast portable 128-bit version for fingerprinting. </li><li>  etc. </li></ul><br><p>  In this scheme, it is assumed that <code>t1ha0()</code> is a dispatcher that implements redirection depending on the platform and capabilities of the current processor.  In addition, the use of the suffixes "_le" and "_be" for an explicit choice between the little-endian and big-endian variants is not excluded.  Thus, under the ‚Äút1ha‚Äù signboard now there are several hash functions, and this family will be replenished, including with an eye on the domestic E2K ‚ÄúElbrus‚Äù. </p><br><p>  An idea of ‚Äã‚Äãthe current set of functions and their properties can be obtained from the output of the embedded test ( <code>make check</code> ).  It is worth noting that all functions pass all SMHasher tests, and the performance of the AES-NI variants varies greatly depending on the processor model: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre> <br><hr><br><div class="spoiler">  <b class="spoiler_title">Little about the internal structure</b> <div class="spoiler_text"><p>  If we talk in a little more detail, then <strong>t1ha is</strong> built according to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%259C%25D0%25B5%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B0_%25E2%2580%2594_%25D0%2594%25D0%25B0%25D0%25BC%25D0%25B3%25D0%25B0%25D1%2580%25D0%25B4%25D0%25B0">Merkle-Damg√•rd</a> scheme (in the ‚Äúwipe-pipe‚Äù version) with hardening of the data size and the suval value.  Inside the main compression cycle, a 256-bit state is used, with the same size of the input block.  Moreover, for each data operand there are two injection points with cross pollination.  Upon completion of the compression cycle, a 256-bit state is compressed to 128 bits. </p><br><p>  When performing the described actions, 64-bit operations are used, which are combined into mixers ARX (Add-Rotate-Xor) and MUX / MRX (Mul-Rotate-Xor).  It is important that all these calculations are built in such a way as to ensure the possibility of parallel execution of most operations and tight packing of u-ops both into a pipeline and into x86_64 performing devices.  Due to this, a sufficiently good quality is achieved with an almost maximum hash rate of long keys. </p><br><p>  It is worth noting that the compression cycle runs only for blocks of sufficient size.  If there is less data, then the intermediate 128-bit state will consist only of the key size and the priming value. </p><br><p>  Further, the remaining tail of the data in portions of 64 bits is mixed alternately to the halves of the 128-bit state.  Finally, the state is mixed at the same time with compression to a 64-bit result.  An important feature of t1ha here is the use of a mixer based on wide multiplication (128-bit product of two 64-bit multipliers).  This allows for qualitative mixing with a good avalanche effect in fewer operations.  Despite the fact that wide multiplication is a relatively expensive operation, fewer such operations allow t1ha to process short keys in a record-low number of processor cycles. </p><br><p>  It should be noted that the mixer used based on wide multiplication and exclusive OR is not perfect.  Although <em>t1ha</em> passes all <em>SMHasher</em> tests, the author has an idea of ‚Äã‚Äãthe consequences of <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%258A%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">non-injectivity</a> .  Nevertheless, the resulting quality seems to be rationally sufficient, and the development plans for the t1ha line already reflect the intention to provide a slightly better option. </p></div></div><br><p>  <a href="https://github.com/leo-yuriev/t1ha">The rest is here</a> . </p><br><p>  <em>Thanks for attention.</em>  <em>All good.</em> <br>  <em><a href="https://habr.com/en/post/439156/">Russian version is here</a> .</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339160/">https://habr.com/ru/post/339160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339150/index.html">Submit the cool project: your API-client from one configuration file</a></li>
<li><a href="../339152/index.html">‚ÄúThe role of the analyst in making important product decisions‚Äù: video recordings of reports from the meeting</a></li>
<li><a href="../339154/index.html">Motivated installations from the USA (Android) - review of options, statistics, opinion</a></li>
<li><a href="../339156/index.html">Two facets of teleportation</a></li>
<li><a href="../339158/index.html">Sometimes they come back. Mobile Banker BankBot again in Google Play</a></li>
<li><a href="../339162/index.html">Text translation from the open door of Kaspersky Lab - Open Day 2017</a></li>
<li><a href="../339164/index.html">How I passed certification at Xamarin University</a></li>
<li><a href="../339166/index.html">How to find the best flights in the interface of Google-table</a></li>
<li><a href="../339170/index.html">How to successfully implement the Help Desk? 12 examples (part 1)</a></li>
<li><a href="../339172/index.html">Online consultants: a test review of 7 popular systems. What do you get if you fold advertising?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>