<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DSL for regular expressions on Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 


 This article is about the implementation of one specific DSL ( domain specific language ) for regular expressions using Kotlin, but it may ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DSL for regular expressions on Kotlin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/562/990/79a/56299079a06e4ea299079be1eaae8829.png"><br><br><p>  Hello! </p><br><p>  This article is about the implementation of one specific DSL ( <a href="https://www.wikiwand.com/en/Domain-specific_language">domain specific language</a> ) for regular expressions using Kotlin, but it may well give a general idea of ‚Äã‚Äãhow to write your DSL on Kotlin and what it <em>usually</em> will do "under the hood "any other DSL using the same language features. </p><br><p>  Many have already used Kotlin, or at least tried to do it, and the rest could well have heard that Kotlin has to write elegant DSL, which has some brilliant examples - <a href="https://github.com/Kotlin/anko">Anko</a> and <a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html</a> . </p><br><p>  Of course, for regular expressions, this <a href="https://habrahabr.ru/post/308882/">has already been done</a> (and yet: <a href="https://github.com/chrba/regex">in Java</a> , <a href="http://imaginatio.github.io/REL/">in Scala</a> , <a href="http://osherove.com/blog/2008/5/6/introducing-linq-to-regex.html">in C #</a> - there are many implementations, it seems, this is a common entertainment).  But if you want to practice or try Kotlin's DSL-oriented language capabilities, then welcome to Cat. </p><a name="habracut"></a><br><h2 id="kak-obychno-vyglyadit-dsl-napisannyy-na-kotlin">  What does DSL usually look like written in Kotlin? </h2><br><img src="https://habrastorage.org/files/280/84a/f87/28084af87eb24943bd35006424d843be.png"><br><p>  <em>In the worst case, probably so.</em> </p><br><p>  Most Java DSLs suggest using call chains for their constructs, as in this example Java Regex DSL: </p><br><pre><code class="hljs pgsql">Regex regex = RegexBuilder.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>("#timestamp") .number("#hour").<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(":") .number("#min").<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(":") .number("#secs").<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(":") .number("#ms") .<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>() .build();</code> </pre> <br><p>  We could use this approach, but it has a number of disadvantages, among which we can immediately note two: </p><br><ul><li><p>  inconvenient implementation of nested constructs ( <code>group</code> and <code>end</code> above), due to which you will have to fight with the formatter, and there is no banal verification of the opening and closing elements, you can write an extra <code>.end()</code> ; </p><br></li><li>  poor possibilities for dynamic expression: if we want to execute arbitrary code before adding the next part to the query ‚Äî for example, checking the condition ‚Äî we will need to break the chain of calls and store the partially created expression in a variable. </li></ul><br><p>  With these shortcomings in Kotlin you can cope if you implement DSL in the style of <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">Type-Safe Groovy-Style Builder</a> (when explaining technical details, this article will largely repeat the documentation page by reference).  Then the code on it will look like this Anko example: </p><br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">verticalLayout { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = editText() button(<span class="hljs-string"><span class="hljs-string">"Say Hello"</span></span>) { onClick { toast(<span class="hljs-string"><span class="hljs-string">"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name.text}</span></span></span><span class="hljs-string">!"</span></span>) } } }</code> </pre> </div></div><br><p>  Or to this example kotlinx.html: </p><br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="hljs axapta">html { body { <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> { a(<span class="hljs-string"><span class="hljs-string">"http://kotlinlang.org"</span></span>) { target = ATarget.blank +<span class="hljs-string"><span class="hljs-string">"Main site"</span></span> } } } }</code> </pre> </div></div><br><p>  Looking ahead, I‚Äôll say that the resulting language will look something like this: </p><br><div class="spoiler">  <b class="spoiler_title">Show code:</b> <div class="spoiler_text"><pre> <code class="hljs cs">val r = regex { <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>(<span class="hljs-string"><span class="hljs-string">"prefix"</span></span>) { literally(<span class="hljs-string"><span class="hljs-string">"+"</span></span>) oneOrMore { digit(); letter() } } <span class="hljs-number"><span class="hljs-number">3</span></span> times { digit() } literally(<span class="hljs-string"><span class="hljs-string">";"</span></span>) matchGroup(<span class="hljs-string"><span class="hljs-string">"prefix"</span></span>) }</code> </pre> </div></div><br><h2 id="pristupim">  Let's get started </h2><br><p><img src="https://habrastorage.org/files/398/14b/096/39814b09614d48bf95cd1f1a9c200ac7.jpg"><br></p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexContext</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">regex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Regex { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NotImplementedError() }</code> </pre> <br><p>  What is written here?  The <code>regex</code> function returns the constructed <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/"><code> Regex</code></a> and takes a single argument ‚Äî another function of the type <code>RegexContext.() -&gt; Unit</code> .  If you are already familiar with Kotlin, feel free to skip a couple of paragraphs explaining what it is. </p><br><p>  <a href="https://kotlinlang.org/docs/reference/lambdas.html">The types of functions</a> in Kotlin are written something like this: <code>(Int, String) -&gt; Boolean</code> is a predicate of two arguments - or so: <code>SomeType.(Int) -&gt; Unit</code> is a <a href="https://kotlinlang.org/docs/reference/functions.html">function that returns a Unit</a> (analog of the void-function), and except the <code>Int</code> argument also accepts a <a href="https://kotlinlang.org/docs/reference/lambdas.html">receiver of</a> type <code>SomeType</code> . </p><br><p>  Functions that take a receiver help us a lot with building DSL due to the fact that you can pass a lambda expression as an argument of this type, and it will have an implicit <code>this</code> that is of the same type as the receiver.  A simple example is the library function <code>with</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; R): R = t.block() <span class="hljs-comment"><span class="hljs-comment">//  block       receiver //    ,      with(ArrayList&lt;Int&gt;()) { for(i in 1..10) { add(i) } //  add    receiver println(this) //    this --  ArrayList&lt;Int&gt; }</span></span></code> </pre> <br><p>  Great, now we can call <code>regex { ... }</code> and, inside the curly braces, work with some <code>RegexContext</code> instance as if <code>this</code> .  It remains just a little - to implement the members <code>RegexContext</code> .  :) </p><br><h2 id="zachem-nuzhen-regexcontext">  Why do I need a RegexContext? </h2><br><p>  Let's create a regular expression in parts - each statement of our DSL will simply append to the unfinished expression the next part.  These parts will be stored by <code>RegexContext</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regexParts = mutableListOf&lt;String&gt;() <span class="hljs-comment"><span class="hljs-comment">//    private fun addPart(part: String) { //       regexParts.append(part) } }</span></span></code> </pre> <br><p>  Accordingly, the <code>regex {...}</code> function will now look like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">regex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Regex { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context = RegexContext() context.block() <span class="hljs-comment"><span class="hljs-comment">//  block,  -   context val pattern = context.regexParts.toString() return Regex(pattern) //     -  Regex }</span></span></code> </pre> <br><p>  Next, we implement the <code>RegexContext</code> functions that add different parts to the regular expression. </p><br><p>  The following functions, unless explicitly stated otherwise, are also located in the body of the class. </p><br><h2 id="vsyo-ochen-prosto">  Everything is very simple </h2><br><img src="https://habrastorage.org/files/c5f/0c9/757/c5f0c97573be44a8b4c670164fd2a1f3.png"><br><p>  <em>Right?</em> </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyChar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"."</span></span>)</code> </pre> <br><p>  This call simply adds a point to the expression, which denotes a subexpression corresponding to any single character. </p><br><p>  Similarly, we implement the functions <code>digit()</code> , <code>letter()</code> , <code>alphaNumeric()</code> , <code>whitespace()</code> , <code>wordBoundary()</code> , <code>wordCharacter()</code> and even <code>startOfString()</code> and <code>endOfString()</code> - they all look about the same. </p><br><div class="spoiler">  <b class="spoiler_title">Namely:</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\d"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"[[:alpha:]]"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alphaNumeric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"[A-Za-z0-9]"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\s"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wordBoundary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\b"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wordCharacter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\w"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startOfString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"^"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endOfString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"$"</span></span>)</code> </pre> </div></div><br><p>  But to add an arbitrary string to a regular expression, you have to first convert it so that the characters present in the string are not interpreted as service characters.  The easiest way to do this is with the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/escape.html">Regex.escape (...)</a> function: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literally</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(Regex.escape(s))</code> </pre> <br><p>  For example, <code>literally(".:[test]:.")</code> will add a part of <code>\Q.:[test]:.\E</code> to the expression. </p><br><h2 id="idyom-glubzhe">  Go deeper </h2><br><p>  What about quantifiers?  Obvious observation: the quantifier is hung on a subexpression, which in itself is also a valid regex.  Let's add some nesting! </p><br><p><img src="https://habrastorage.org/files/e7c/156/53e/e7c15653ed4e42779800e5f917ffb1de.jpg"><br></p><br><p>  We want the nested block of code in curly braces to specify a subexpression of a quantifier, like this: </p><br><pre> <code class="hljs swift">val r = regex { oneOrMore { <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> { anyChar() } literally(<span class="hljs-string"><span class="hljs-string">"-"</span></span>) } literally(<span class="hljs-string"><span class="hljs-string">";"</span></span>) }</code> </pre> <br><p>  We will do this with the help of the <code>RegexContext</code> functions, which behave almost the same as <code>regex {...}</code> , but use the constructed subexpression themselves.  We first add auxiliary functions: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addWithModifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, modifier: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { addPart(<span class="hljs-string"><span class="hljs-string">"(?:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">)</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$modifier</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  non-capturing group   } private fun pattern(block: RegexContext.() -&gt; Unit): String { //      --     val innerContext = RegexContext() innerContext.block() // block    RegexContext return innerContext.regexParts.toString() //      }</span></span></code> </pre> <br><p>  And then we use them to implement our "quantifiers": </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"+"</span></span>)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And so on (plus, functions that allow you not to wrap literally into lambda</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"+"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = oneOrMore { literally(s) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = optional { literally(s) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeroOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"*"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeroOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = zeroOrMore { literally(s) }</code> </pre> </div></div><br><p>  Even in regexes, it is possible to set the number of expected entries precisely or using a range.  We want this too, right?  It is also a good reason to use <a href="https://kotlinlang.org/docs/reference/functions.html">infix functions</a> - functions of two arguments, one of which is receiver.  Calls to such functions will be as follows: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = regex { <span class="hljs-number"><span class="hljs-number">3</span></span> times { anyChar() } <span class="hljs-number"><span class="hljs-number">2</span></span> timesOrMore { whitespace() } <span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span> times { literally(<span class="hljs-string"><span class="hljs-string">"x"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// 3..5 --  IntRange }</span></span></code> </pre> <br><p>  And the functions themselves are declared as: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> IntRange.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${first}</span></span></span><span class="hljs-string">,</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${last}</span></span></span><span class="hljs-string">}"</span></span>)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And all together, again with functions for literal strings:</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> times { literally(s) } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> IntRange.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${first}</span></span></span><span class="hljs-string">,</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${last}</span></span></span><span class="hljs-string">}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> IntRange.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> times { literally(s) } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timesOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">,}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timesOrMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> timesOrMore { literally(s) } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timesOrLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addWithModifier(pattern(block), <span class="hljs-string"><span class="hljs-string">"{0,</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timesOrLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> timesOrLess { literally(s) }</code> </pre> </div></div><br><h2 id="sgruppiruytes">  Group up! </h2><br><p>  The tool for working with rehexes cannot be called such if it does not support groups, so let's support them, for example, in this form: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = regex { anyChar() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> separator = group { literally(<span class="hljs-string"><span class="hljs-string">"+"</span></span>); digit() } <span class="hljs-comment"><span class="hljs-comment">//    anyChar() matchGroup(separator) //    anyChar() }</span></span></code> </pre> <br><p>  However, the groups introduce new complexity into the regex structure: they are numbered "through and through" from left to right, ignoring the nesting of subexpressions.  This means that the calls of <code>group {...}</code> cannot be considered independent of each other, and even more: all of our nested subexpressions are now also linked to each other. </p><br><p>  To support the numbering of groups, slightly change the <code>RegexContext</code> : now it will remember how many groups it already has: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexContext</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastGroup: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre> <br><p>  And so that our nested contexts know how many groups were there before them and report how many were added inside them, change the function <code>pattern(...)</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pattern</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> innerContext = RegexContext(lastGroup) <span class="hljs-comment"><span class="hljs-comment">//   innerContext.block() lastGroup = innerContext.lastGroup //     return innerContext.regexParts.toString() }</span></span></code> </pre> <br><p>  Now nothing prevents us from correctly implementing the <code>group</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = ++lastGroup addPart(<span class="hljs-string"><span class="hljs-string">"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pattern(block)}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result }</code> </pre> <br><p>  Named group case: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = ++lastGroup addPart(<span class="hljs-string"><span class="hljs-string">"(?&lt;</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">&gt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pattern(block)}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result }</code> </pre> <br><p>  And matching groups, both indexed and named: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$index</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(<span class="hljs-string"><span class="hljs-string">"\\k&lt;</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">&gt;"</span></span>)</code> </pre> <br><h2 id="chto-to-eschyo">  Something else? </h2><br><p><img src="https://habrastorage.org/files/e54/96a/f67/e5496af67ed2425f874466315c615de4.jpg"><br></p><br><p>  Yes!  We almost forgot the important construct of regular expressions - alternatives.  For literals, alternatives are implemented trivially: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terms: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(terms.joinToString(<span class="hljs-string"><span class="hljs-string">"|"</span></span>, <span class="hljs-string"><span class="hljs-string">"(?:"</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>) { Regex.escape(it) }) <span class="hljs-comment"><span class="hljs-comment">//   terms    ,   , //     Regex.escape(...)</span></span></code> </pre> <br><p>  No more difficult implementation for nested expressions: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blocks: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RegexContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = addPart(blocks.joinToString(<span class="hljs-string"><span class="hljs-string">"|"</span></span>, <span class="hljs-string"><span class="hljs-string">"(?:"</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>) { pattern(it) })</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The same for character sets:</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> characters: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(characters.joinToString(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"["</span></span>, <span class="hljs-string"><span class="hljs-string">"]"</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"\\"</span></span>, <span class="hljs-string"><span class="hljs-string">"\\\\"</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"^"</span></span>, <span class="hljs-string"><span class="hljs-string">"\\^"</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ranges: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharRange</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = addPart(ranges.joinToString(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"["</span></span>, <span class="hljs-string"><span class="hljs-string">"]"</span></span>) { <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it.first}</span></span></span><span class="hljs-string">-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it.last}</span></span></span><span class="hljs-string">"</span></span> })</code> </pre> </div></div><br><p>  But wait, what if we want to use different things as alternatives in the same <code>anyOf(...)</code> - for example, both a string and a block with a code for a nested subexpression?  A slight disappointment awaits us here: in Kotlin, there are no union types (union types), and write the argument type <code>String | RegexContext.() -&gt; Unit | Char</code> <code>String | RegexContext.() -&gt; Unit | Char</code>  <code>String | RegexContext.() -&gt; Unit | Char</code> we can not.  I was only able to get around this with frightening-looking crutches, which still do not make DSL better, so I decided to leave everything as it was written above - in the end, both <code>String</code> and <code>Char</code> can be written in nested subexpressions using the appropriate overload <code>anyOf {...}</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Scary crutches</b> <div class="spoiler_text"><ul><li><p>  Use <code>anyOf(vararg parts: Any)</code> , where <code>Any</code> is the type to which any object belongs.  Check which type is inside, respectively, and throw a <code>IllegalArgumentException</code> to a careless user who has passed a bad argument, and he will be very pleased. </p><br></li><li><p>  Hardcore  In Kotlin, a class can <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">override the invoke operator ()</a> , and then objects of this class can be used as functions: <code>myObject(arg)</code> , and if the operator has several overloads, then the object will behave like several function overloads.  Then you can try currying the <code>anyOf(...)</code> function, but since it has an arbitrary number of arguments, we don‚Äôt know when they will end ‚Äî hence, each partial application should override the result of the previous one and then apply itself, as if its argument is the last . </p><br><p>  If this is done neatly, it will even work, but we unexpectedly come to a head on the unpleasant moment in the Kotlin grammar: you cannot use consecutive calls with curly braces in the <code>invoke</code> operator's call chain. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> anyOf { <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = anyOf <span class="hljs-comment"><span class="hljs-comment">//      operator fun invoke(r: RegexContext.() -&gt; Unit) = anyOf } anyOf("a")("b")("c") //   anyOf("123") { anyChar() } { digit() } //    ! anyOf("123")({ anyChar() })({ digit() }) //   ((anyOf("123")) { anyChar() }) { digit() } //  </span></span></code> </pre> <br><p>  Well, and we need it so? </p><br></li></ul></div></div><br><p>  In addition, it would be nice to reuse regular expressions, both built by our DSL, and come to us from somewhere else.  This is easy to do, the main thing is not to forget about the numbering of the groups.  From the regex, you can pull out the number of its groups: <code>Pattern.compile(pattern).matcher("").groupCount()</code> , and all that remains is to implement the corresponding <code>RegexContext</code> function: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">include</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(regex: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Regex</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pattern = regex.pattern addPart(pattern) lastGroup += Pattern.compile(pattern).matcher(<span class="hljs-string"><span class="hljs-string">""</span></span>).groupCount() }</code> </pre> <br><p>  And on this, perhaps, the mandatory features end. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Thank you for reading to the end!  What have we got?  It is a viable DSL for regexes that can be used: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> RegexContext.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = anyOf({ literally(<span class="hljs-string"><span class="hljs-string">"25"</span></span>); anyOf(<span class="hljs-string"><span class="hljs-string">'0'</span></span>..<span class="hljs-string"><span class="hljs-string">'5'</span></span>) }, { literally(<span class="hljs-string"><span class="hljs-string">"2"</span></span>); anyOf(<span class="hljs-string"><span class="hljs-string">'0'</span></span>..<span class="hljs-string"><span class="hljs-string">'4'</span></span>); digit() }, { anyOf(<span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); digit(); optional { digit() } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = regex { <span class="hljs-number"><span class="hljs-number">3</span></span> times { byte(); literally(<span class="hljs-string"><span class="hljs-string">"."</span></span>) } byte() }</code> </pre> <br><p>  <em>(Question: what is this regex for? Really, is it simple?)</em> </p><br><p>  More advantages: </p><br><ul><li>  It is difficult to break the regex: you don't even have to write brackets with your hands, if the code is compiled and the groups are correct, then the regex is valid. </li><li>  It turns out to visually form regex dynamically: it makes living code with any valid constructions like conditions, loops, and calls to third-party functions. </li><li>  If you use indexed groups, the index is dynamically assigned to the group, and even changing a large regex written in DSL will not break group indexes. </li><li>  Extensibility and reusability: in your code, you can write any extension function like <code>byte()</code> above and use it as an integral part of rehexes - <code>russianLetter()</code> , <code>ipAddress()</code> , <code>time()</code> ... </li></ul><br><p>  What did not work: </p><br><ul><li>  AnyOf <code>anyOf(...)</code> looks <code>anyOf(...)</code> , it was not possible to achieve better. </li><li>  The recording density is much inferior to the traditional form, the rehex into a half-screen length turns into a block into a half-screen height.  But, probably, readable. </li></ul><br><p>  Sources, tests, and dependencies ready to be added to a project are in the <a href="https://github.com/h0tk3y/regex-dsl/">repository on Github</a> . </p><br><p>  What do you think about domain-specific regular expression languages?  Have you ever used it?  And other DSL? </p><br><p>  I will be glad to discuss all that sounded. </p><br><p>  Good luck! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312776/">https://habr.com/ru/post/312776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312762/index.html">Everything collapses</a></li>
<li><a href="../312766/index.html">Xcode: probably the best way to work with storyboards</a></li>
<li><a href="../312770/index.html">Happy birthday, Aaron Schwartz</a></li>
<li><a href="../312772/index.html">On October 21, at 19.00 in Moscow, the founder Andy Tryba presents: How we created a non profit competitor Uber in 4 weeks</a></li>
<li><a href="../312774/index.html">Why do we need the Ho-Kashyap algorithm?</a></li>
<li><a href="../312778/index.html">OpenShift v 3 III. OpenShift Origin 1.3</a></li>
<li><a href="../312780/index.html">Joanna Hoffman - Steve Jobs's ‚ÄúGuardian Angel‚Äù</a></li>
<li><a href="../312782/index.html">Basics of Auto Layout - Concept, structure, application</a></li>
<li><a href="../312784/index.html">NPM module support in backend as a service Scorocode</a></li>
<li><a href="../312786/index.html">October 22 in Moscow - a jitter for Java seniors: meeting with the CEO and the Crossover team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>