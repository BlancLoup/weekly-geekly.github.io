<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing C # principal component method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. This week, in the course on machine learning, Professor Andrew Ng told the audience about the main component method with which you can reduce t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing C # principal component method</h1><div class="post__text post__text-html js-mediator-article">  Hello.  This week, in the course on <a href="http://class.coursera.org/ml">machine learning,</a> Professor Andrew Ng told the audience about <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582">the main component method</a> with which you can reduce the dimension of the feature space of your data.  But unfortunately, he did not talk about the method of calculating the eigenvectors and eigenvalues ‚Äã‚Äãof the matrix, he simply said that it was difficult and advised using the matlab / Octave function [USV] = svd (a). <br><br>  For my project, I needed the implementation of this method in c #, which I did today.  The method of the main components is very elegant and beautiful, and if you do not understand the mathematics that lies behind all this, then it can all be called shamanism.  The problem of calculating the eigenvectors of the matrix is ‚Äã‚Äãthat there is no <em>quick</em> way to calculate their exact values, so you have to get out.  I want to talk about one of these ways to get out, as well as the c # code that performs this procedure.  I ask under the cat. <br><a name="habracut"></a><br><br><h1>  Principal Component Method (No Code For Now) </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Part one: algorithm initialization.  The input to the algorithm is an array of data, as well as the dimension of the space to which it is necessary to reduce the data. <br><ol><li>  The <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0">covariance matrix is</a> calculated (this matrix has a remarkable property - it is symmetric, it will be very useful to us) </li><li>  Calculate the eigenvectors of the matrix </li><li>  The first en of eigenvectors are chosen, where en is the dimension to which the dimension of the feature space is to be reduced;  selected vectors can be written vertically and assembled into a matrix <img src="https://habrastorage.org/getpro/habr/post_images/dc0/af3/99b/dc0af399b71e55e8a6bae588732e7a76.gif"></li></ol><br><br>  Part Two: Reducing the dimension of the input vector.  At the input is a vector, dimensions as in the data array used in the initialization step;  at the output, a vector of smaller dimension (or the projection of the input vector on an orthonormal basis formed by sampling from eigenvectors). <br><ul><li>  By multiplying the scalar input vector by all the vectors from the sample of eigenvectors, we obtain a <em>smaller</em> vector: <img src="https://habrastorage.org/getpro/habr/post_images/fed/b11/42d/fedb1142d37c12ed803093b4e9a7b22e.gif"></li></ul><br><br>  Part three: recovery of the dimension of the vector (of course, with the loss of information).  The input is a vector of dimension equal to that to which we <em>reduced the</em> vectors;  output vector of the original dimension. <br><ul><li>  If you transpose the matrix <img src="https://habrastorage.org/getpro/habr/post_images/dc0/af3/99b/dc0af399b71e55e8a6bae588732e7a76.gif">  then there will be as many lines in it as the dimension of the input vector at the previous step, and the desired vector is restored by the formula: <img alt="Andrew Ng" src="https://habrastorage.org/getpro/habr/post_images/b6a/93d/fc8/b6a93dfc8d45aa5477b939a22182faab.gif"></li></ul><br><br>  As you can see, the entire computational complexity is in the initialization step when calculating the covariance matrix and eigenvectors.  I will not stop on the calculation of the covariance matrix, since  it is calculated naively by definition.  Having studied several algorithms for calculating the eigenvectors of the matrix, I stopped at the iterative QR decomposition method.  He has a significant limitation, he gives a less accurate result only for symmetric matrices, but we were lucky :), the covariance matrix is ‚Äã‚Äãjust that.  The second limitation of this algorithm is that the matrix must be <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25BD%25D0%25B3_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D1%258B">full-rank</a> . <br><br><h1>  QR decomposition </h1><br>  The iterative QR method for finding eigenvectors obviously uses <a href="http://ru.wikipedia.org/wiki/QR-%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">QR decomposition</a> , so first we have to implement this process.  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581_%25D0%2593%25D1%2580%25D0%25B0%25D0%25BC%25D0%25B0_%25E2%2580%2595_%25D0%25A8%25D0%25BC%25D0%25B8%25D0%25B4%25D1%2582%25D0%25B0">Gram-Schmidt</a> algorithm was chosen to implement this process. <br><br>  For this we need a function that calculates the projection of the vector <strong>a</strong> on the vector <strong>b</strong> : <img src="https://habrastorage.org/getpro/habr/post_images/b43/725/e61/b43725e61fe29240d08442234cdf013e.gif">  where &lt;&gt; - denotes the scalar product of vectors. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VectorProjection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> k = ScalarVectorProduct(a, b)/ScalarVectorProduct(b, b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScalarToVectorProduct(k, b); }</code> </pre> <br><br>  I will not dwell on even simpler functions, such as ScalarVectorProduct, so that the code size in the text does not exceed the critical limit. <br><br>  So the actual QR decomposition procedure itself <strong>IList &lt;double []&gt; DecompositionGS (double [] [] a)</strong> receives a matrix as input, and returns two matrices in response: <br><ol><li>  The first contains in its columns an orthonormal basis such that <img src="https://habrastorage.org/getpro/habr/post_images/961/a61/5ae/961a615ae4cc352fb5e52016f7d634a7.png">  ; </li><li>  the second matrix will be <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0">upper triangular</a> . </li></ol><br><br>  First, we divide the matrix into columns and write them into the <strong>av</strong> list: <br><pre> <code class="cs hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; av = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] vector </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecomposeMatrixToColumnVectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">))</span></span> { av.Add(vector); }</code> </pre><br><br>  We initialize two auxiliary lists: <br><pre> <code class="cs hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; u = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt;(); u.Add(av[<span class="hljs-number"><span class="hljs-number">0</span></span>]); List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt;(); e.Add(ScalarToVectorProduct(<span class="hljs-number"><span class="hljs-number">1</span></span> / NormOfVector(u[<span class="hljs-number"><span class="hljs-number">0</span></span>]), u[<span class="hljs-number"><span class="hljs-number">0</span></span>]));</code> </pre><br><br>  These are the same lists used in the algorithm scheme: <br><img src="https://habrastorage.org/getpro/habr/post_images/ba8/f85/908/ba8f85908271e4544e959c49395be47e.png"><br><br>  After initialization, the first <strong>u</strong> and <strong>e</strong> have been calculated, we continue in the loop to calculate the following values: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; a.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] projAcc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; projAcc.Length; j++) { projAcc[j] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; i; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] proj = VectorProjection(av[i], e[j]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; projAcc.Length; k++) { projAcc[k] += proj[k]; } } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] ui = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; ui.Length; j++) { ui[j] = a[j][i] - projAcc[j]; } u.Add(ui); e.Add(ScalarToVectorProduct(<span class="hljs-number"><span class="hljs-number">1</span></span>/NormOfVector(u[i]), u[i])); }</code> </pre><br><br>  Finally, we generate data in the output format: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q.Length; i++) { q[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; q[i].Length; j++) { q[i][j] = e[j][i]; } } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; r.Length; i++) { r[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[a.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; r[i].Length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) { r[i][j] = ScalarVectorProduct(e[j], av[i]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r[i][j] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } r = Transpose(r); List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt;(); res.Add(q); res.Add(r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res;</code> </pre><br><br>  Hooray!  Now you need a test for this: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test(Description = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Test of QRDecompositionGS"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QRDecompositionGSTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">-51</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">167</span></span>, <span class="hljs-number"><span class="hljs-number">-68</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">-41</span></span>} }; IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; res = LinearAlgebra.QRDecompositionGS(a); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] expQ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">6.0</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">-69.0</span></span>/<span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">-58.0</span></span>/<span class="hljs-number"><span class="hljs-number">175</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">3.0</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">158.0</span></span>/<span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>/<span class="hljs-number"><span class="hljs-number">175</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">-2.0</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>/<span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">-33.0</span></span>/<span class="hljs-number"><span class="hljs-number">35</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] expR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">-14</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">-70</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>} }; Assert.True(Helper.AreEqualMatrices(expQ, res[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0.0001</span></span>), <span class="hljs-string"><span class="hljs-string">"expQ != Q"</span></span>); Assert.True(Helper.AreEqualMatrices(expR, res[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0.0001</span></span>), <span class="hljs-string"><span class="hljs-string">"expR != R"</span></span>); }</code> </pre><br><br>  The <strong>Helper.AreEqualMatrices</strong> function compares element-wise matrices with the accuracy of the third parameter. <br><br><h1>  Iterative QR Method </h1><br>  The iterative QR method is based on the remarkable theorem, the essence of which is that if you initialize the matrix A zero as <img src="http://www.forkosh.com/mathtex.cgi?formdata=%5CLarge+A%5E%7B%280%29%7D+%3D+A">  and repeat the following process infinitely many times: <br><ol><li><img src="http://www.forkosh.com/mathtex.cgi?formdata=%5CLarge+Q%5E%7B%28k%29%7DR%5E%7B%28k%29%7D+%3D+A%5E%7B%28k-1%29%7D"></li><li><img src="http://www.forkosh.com/mathtex.cgi?formdata=%5CLarge+A%5E%7B%28k%29%7D+%3D+R%5E%7B%28k%29%7DQ%5E%7B%28k%29%7D"></li></ol><br>  and then multiply all obtained <strong>Q</strong> , then the result will be a matrix, in the columns of which will be the eigenvectors of the original matrix, the values ‚Äã‚Äãof which will be the more accurate, the longer the process was performed.  In other words, when the number of iterations tends to infinity, the product <img src="http://www.forkosh.com/mathtex.cgi?formdata=%5CLarge+%5Cprod_%7Bk%3D1%7D%5E%7B%5Cinfty%7D+Q%5E%7B%28k%29%7D">  will tend to the exact values ‚Äã‚Äãof the eigenvectors.  At the same time last <img src="http://www.forkosh.com/mathtex.cgi?formdata=%5CLarge+A%5E%7B%28k%29%7D">  will on the main diagonal contain eigenvalues ‚Äã‚Äãof the matrix, approximate of course.  I remind you that this algorithm works more or less precisely only for symmetric matrices. <br><br>  So, the QR iteration method <strong>IList &lt;double [] []&gt; EigenVectorValuesExtractionQRIterative (double [] [] a, double accuracy, int maxIterations)</strong> takes the input along the matrix itself, as well as several more parameters: <br><ul><li>  <strong>double accuracy</strong> - the accuracy of which we want to achieve, the algorithm will stop if the changes in the values ‚Äã‚Äãof the eigenvectors are no more than this value; </li><li>  <strong>int maxIterations</strong> - the maximum number of iterations. </li></ul><br>  At the output we get two matrices: <br><ol><li>  the first contains in its columns the eigenvectors of the matrix <strong>a</strong> ; </li><li>  The second matrix on its main diagonal contains the eigenvalues ‚Äã‚Äãof the matrix <strong>a</strong> . </li></ol><br><br>  So let's start writing an algorithm, first we will create matrices that will contain eigenvectors and eigenvalues ‚Äã‚Äãof the original matrix: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] aItr = a; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] q = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre><br><br>  And run the loop until the algorithm stops: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; maxIterations; i++) { IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; qr = QRDecompositionGS(aItr); aItr = MatricesProduct(qr[<span class="hljs-number"><span class="hljs-number">1</span></span>], qr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { q = qr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] qNew = MatricesProduct(q, qr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> accuracyAcheived = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; q.Length; n++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; q[n].Length; m++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(Math.Abs(qNew[n][m]) - Math.Abs(q[n][m])) &gt; accuracy) { accuracyAcheived = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!accuracyAcheived) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } q = qNew; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (accuracyAcheived) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><br>  Generate output: <br><pre> <code class="cs hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt;(); res.Add(q); res.Add(aItr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res;</code> </pre><br><br>  And of course the test: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test(Description = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Test of Eigen vectors extraction"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EigenVectorExtraction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>} }; IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; ev = LinearAlgebra.EigenVectorValuesExtractionQRIterative(a, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expEV00 = <span class="hljs-number"><span class="hljs-number">15.2964</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expEV11 = <span class="hljs-number"><span class="hljs-number">4.3487</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expEV22 = <span class="hljs-number"><span class="hljs-number">1.0523</span></span>; Assert.AreEqual(expEV00, Math.Round(Math.Abs(ev[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]), <span class="hljs-number"><span class="hljs-number">4</span></span>)); Assert.AreEqual(expEV11, Math.Round(Math.Abs(ev[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]), <span class="hljs-number"><span class="hljs-number">4</span></span>)); Assert.AreEqual(expEV22, Math.Round(Math.Abs(ev[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]), <span class="hljs-number"><span class="hljs-number">4</span></span>)); }</code> </pre><br><br>  It should be noted that the eigenvectors can change direction from iteration to iteration, which will be seen by the change of the signs of their coordinates, but it is obvious that this is not significant. <br><br><h1>  Implementation of the principal component method </h1><br>  Now everything is ready for the implementation of the article sabzh. <br><br>  The hidden parameter of the model (class) will be a certain subset of the eigenvectors of the covariance matrix of the original data: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; _eigenVectors = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre><br><br>  The constructor takes as input a dataset and dimension to which the feature space should be reduced, as well as parameters for QR decomposition.  Inside, the covariance matrix is ‚Äã‚Äãcalculated and the first few eigenvectors are taken.  In general, there is a way to choose the optimal number of eigenvectors for the desired information loss parameter, i.e.  to which dimension you can reduce the space, while losing no more than a fixed percentage of information, but I omit this step, you can listen to it in the lecture of Andrew Ng on the course website. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DimensionalityReductionPCA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]&gt; dataSet, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> accuracyQR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxIterationQR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> componentsNumber</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] cov = BasicStatFunctions.CovarianceMatrixOfData(dataSet); IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][]&gt; eigen = LinearAlgebra.EigenVectorValuesExtractionQRIterative(cov, accuracyQR, maxIterationQR); IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; eigenVectors = LinearAlgebra.DecomposeMatrixToColumnVectors(eigen[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (componentsNumber &gt; eigenVectors.Count) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"componentsNumber &gt; eigenVectors.Count"</span></span>); } _eigenVectors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; componentsNumber; i++) { _eigenVectors.Add(eigenVectors[i]); } }</code> </pre><br><br>  Then we implement the direct and inverse transformation using the formulas from the beginning of the article. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dataItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_eigenVectors[<span class="hljs-number"><span class="hljs-number">0</span></span>].Length != dataItem.Length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"_eigenVectors[0].Length != dataItem.Length"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[_eigenVectors.Count]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _eigenVectors.Count; i++) { res[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; dataItem.Length; j++) { res[i] += _eigenVectors[i][j]*dataItem[j]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] transformedDataItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_eigenVectors.Count != transformedDataItem.Length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"_eigenVectors.Count != transformedDataItem.Length"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[_eigenVectors[<span class="hljs-number"><span class="hljs-number">0</span></span>].Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; res.Length; i++) { res[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; _eigenVectors.Count; j++) { res[i] += _eigenVectors[j][i]*transformedDataItem[j]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br><br><h1>  Testing </h1><br>  To test, we will invent a small array of data, and checking the values ‚Äã‚Äãin the lab (using the code from PCA = home), we will write a class for testing: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture(Description = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Test of DimensionalityReductionPCA"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DimensionalityReductionPCATest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; _data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IDataTransformation&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt; _transformation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] _v = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; _data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[]&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">-6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">-9</span></span>} }; _transformation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DimensionalityReductionPCA(_data, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } [Test(Description = <span class="hljs-string"><span class="hljs-string">"Test of DimensionalityReductionPCA transform"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DimensionalityReductionPCATransformTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] reduced = _transformation.Transform(_v); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] expReduced = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">-2.75008</span></span>, <span class="hljs-number"><span class="hljs-number">0.19959</span></span>}; Assert.IsTrue(Helper.AreEqualVectors(expReduced, reduced, <span class="hljs-number"><span class="hljs-number">0.001</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] reconstructed = _transformation.Reconstruct(reduced); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] expReconstructed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">-0.21218</span></span>, <span class="hljs-number"><span class="hljs-number">-0.87852</span></span>, <span class="hljs-number"><span class="hljs-number">2.60499</span></span>}; Assert.IsTrue(Helper.AreEqualVectors(expReconstructed, reconstructed, <span class="hljs-number"><span class="hljs-number">0.001</span></span>)); }</code> </pre><br><br><h1>  Links </h1><br><ul><li>  course on <a href="http://class.coursera.org/ml">machine learning</a> </li><li>  an article that describes <a href="http://mathreview.uwaterloo.ca/archive/voli/1/panju.pdf">an iterative QR method</a> </li><li>  a bunch of links to wikipedia in the text of the article </li></ul></div><p>Source: <a href="https://habr.com/ru/post/146236/">https://habr.com/ru/post/146236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146230/index.html">Larry Ellison acquires the island in Hawaii</a></li>
<li><a href="../146231/index.html">Agreement within the team</a></li>
<li><a href="../146232/index.html">Skolkovo Foundation is looking for startups in Ukraine and Belarus</a></li>
<li><a href="../146234/index.html">GWT Grid</a></li>
<li><a href="../146235/index.html">Accounting - to the masses! Imposing optical budget</a></li>
<li><a href="../146237/index.html">Joint deployment of System Center 2012 (method and problems)</a></li>
<li><a href="../146238/index.html">+1 useful book: "Wiley Business Model Generation"</a></li>
<li><a href="../146240/index.html">The battle against redeployments reaches the clouds</a></li>
<li><a href="../146241/index.html">The whole discography of Choi, videos, photos and texts</a></li>
<li><a href="../146242/index.html">$ 80,000 to the best programmers for winning the robot competition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>