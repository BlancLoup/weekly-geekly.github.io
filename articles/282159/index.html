<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Profiling JS code from functions. Yandex experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For the last six months, the familiar Yandex Search Engine Result Page (SERP) interface has moved to a new architecture, with which the development of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Profiling JS code from functions. Yandex experience</h1><div class="post__text post__text-html js-mediator-article"><br><p>  For the last six months, the familiar <a href="https://yandex.ru/search/%3Ftext%3D%25D1%258F%25D0%25BD%25D0%25B4%25D0%25B5%25D0%25BA%25D1%2581">Yandex</a> Search Engine Result Page (SERP) <a href="https://yandex.ru/search/%3Ftext%3D%25D1%258F%25D0%25BD%25D0%25B4%25D0%25B5%25D0%25BA%25D1%2581">interface has</a> moved to a new architecture, with which the development of non-specific features becomes very fast, and the development of specific features is predictable.  For a large distributed team of 40 front-tenders, this is a great success.  When everything was almost ready and the new code began to run in production experiments, it turned out that the server-side JS template in the new architecture was noticeably slowed down. </p><br><p> <a href="https://habrahabr.ru/company/yandex/blog/282159/"><img src="https://habrastorage.org/files/f30/660/6d8/f306606d8f9b4ac3995045e3fddb308e.png"></a> </p><br><p>  The new code was easier and more logical to arrange, so the slowdown was not only undesirable, but also unexpected.  To get the "green light" for the new architecture, it was necessary to speed up the code so that it worked at least as fast as the old one. </p><br><p>  It was not possible to solve the problem by simply ‚Äúlooking at it‚Äù, it was necessary to understand it, it was necessary to profile it.  Read on to find out how this was done. </p><a name="habracut"></a><br><br><h2>  Our kitchen </h2><br><p>  SERP written in BEM.  Server templating is written in JS and consists of two parts: </p><br><ul><li>  the code that converts the backend data into a <a href="https://ru.bem.info/technology/bemjson/v2/bemjson/">BEMJSON</a> page (tree of blocks, elements, and modifiers) is PRIV-template; </li><li>  The code that turns BEMJSON into HTML is <a href="https://ru.bem.info/technology/bemhtml/v2/rationale/">BEMHTML templating</a> . </li></ul><br><p>  The second part we did not touch, the architecture was replaced in the first. </p><br><p>  Now in PRIV-templating, BEMJSON is generated for three platforms - desktops, tablets and phones.  The slowdown affected only the first two platforms. </p><br><p>  A PRIV code is a large number of functions in the global scope.  Functions are named after BEM and are in different files, and during the build process they are collected into one file. </p><br><p>  For example: </p><br><pre><code class="hljs lua">// - blocks[<span class="hljs-string"><span class="hljs-string">'my-block'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1, arg2)</span></span></span></span> { /* ... */ } // - ‚Äì     //      - blocks[<span class="hljs-string"><span class="hljs-string">'my-block__elem'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1, arg2)</span></span></span></span> { /* ... */ }</code> </pre> <br><p>  In the past, block functions were equal and were not included in any hierarchy.  Just some blocks were low-level and actually generated BEMJSON, while others were high-level - the blocks were called the lower level. </p><br><p>  In the new architecture, blocks have roles with a fixed interface.  The blocks began to merge into levels of abstraction, forming a pipeline for processing source data into the final BEMJSON. <br><br></p><br><h2>  Before the start </h2><br><p>  A quick search showed that there is no universal JS code profiler and the topic itself is covered a little.  I had to understand the methods on the go, simultaneously forming my own opinion about them. </p><br><p>  Let's talk about profiling server-side JS-code, sorting out methods from simple to complex.  Note: we worked exclusively on Node.JS 4.2.2. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><h2>  GUI-approach.  Chromium </h2><br><p>  The simplest and seemingly visual tool is the proflator built into the Chromium browsers, which can be used with the <a href="https://github.com/node-inspector/node-inspector">node-inspector module</a> . </p><br><p>  As a result of the work of the profiler, we get three views of the collected results: </p><br><ul><li>  Top-Down; </li><li>  Bottom-up; </li><li>  Chart. </li></ul><br><p>  All three are different ways of displaying the complete call tree of the executed code.  In the first case, the tree is built from top to bottom, in the second - from bottom to top, in the third - we will look at an example. </p><br><img src="https://habrastorage.org/files/3f5/aa4/c57/3f5aa4c57dad438984dd2fb56c0647ed.png"><br><br><p>  ‚Üë <strong>Top-Down</strong> allows you to track the execution time of only those function calls that are at a shallow depth of the call stack.  The problem is the lack of horizontal scrolling.  In our case, with a tree height of 182, we managed to reach calls at a depth of 37, the rest remained hidden behind the right edge of the screen. </p><br><img src="https://habrastorage.org/files/d75/a06/cec/d75a06cec9354ae282a50b18a2f8c10a.png"><br><br><p>  ‚Üë <strong>Bottom-Up</strong> does not require horizontal scrolling, as you can start browsing the tree "from any place."  If you started with a call to function F, climbed the tree to a call to function G and came up against the edge of the screen ‚Äî we find the separate call to G and continue moving.  The blessing is a search by function name.  But functions are not displayed here, the total execution time of which turned out to be less than some constant. </p><br><p>  If it was not possible to find the function in Bottom-Up, then it was executed in very little time, or, which also happens, it was zain-line when compiled. </p><br><img src="https://habrastorage.org/files/f3a/57e/1b2/f3a57e1b21ec4af79ee94108628dc990.png"><br><br><p>  ‚Üë <strong>Chart</strong> draws a call tree tied to the time axis with the possibility of changing the scale and only horizontal scrolling.  Here we saw calls at a depth of 32, the rest went to the bottom of the screen. <br><br></p><br><h2>  GUI-approach.  Webstorm </h2><br><p>  Chromium &amp; node-inspector is not the only option for a GUI profiler, for example, WebStorm offers similar functionality: </p><br><p>  Run ‚Üí Edit Configurations ... ‚Üí Node.js configuration ‚Üí V8 Profiling tab </p><br><p>  Here are four ways to display the call tree: </p><br><ul><li>  Top Calls; </li><li>  Flame chart; </li><li>  Bottom-up; </li><li>  Top-down. </li></ul><br><p>  We note immediately that here you can control the threshold for filtering functions by execution time (you can not filter at all). </p><br><p>  In our case, <strong>Top Calls</strong> did not show anything except the runtime of the shared libraries (bin / node, libsystem_kernel, libsystem_malloc, libsystem_c, and libstdc ++). </p><br><p>  <strong>Flame chart</strong> is similar to Charts from Chromium, only incomprehensible and seemingly useless.  Scale the image to see at least some of the challenges and their nesting, failed. <br><br></p><br><img src="https://habrastorage.org/files/366/f7b/b66/366f7bb665274856a1b07d1c06171945.png"><br><br><p>  ‚Üë <strong>Bottom-up</strong> resembles a similar mode from Chromium, only there is no search and the structure is slightly different.  Without a search by function name it is impossible to use it. </p><br><img src="https://habrastorage.org/files/ed3/91d/6fa/ed391d6fa4df44568f49a4ad4986755c.png"><br><br><p>  ‚Üë <strong>Top-down</strong> suffers the same lack of horizontal scrolling as Chromium in a similar situation.  See what functions were performed below the level of nesting 37, does not work.  And here the stack is more detailed, it includes not only JS-calls, but also the insides of the language (ArrayForEach, InnerArrayForEach, Module._compile, Module._load, and others). <br><br></p><br><h2>  GUI output </h2><br><p>  Of the GUI-profiling methods considered, the most convenient is data collection through node-inspector &amp; Chromium and their analysis in the form of a Bottom-Up view of a complete tree of calls with the ability to search. </p><br><p>  The remaining methods and solutions can be conveniently used with the height of the call tree no more than 30. </p><br><p>  However, all of these methods are not suitable for profiling server code.  It is not enough to run node-inspector, turn on the CPU profile entry, make a couple of requests and start analyzing the data.  We need a representative sample of characteristic queries and not only the total time for executing functions, but also other indicators ‚Äî average time, median, different percentiles.  Need a guided experiment. <br><br></p><br><h2>  Profiling theory </h2><br><p>  There are two basic approaches to profiling: instrumentation- and sampling-profiling. </p><br><p>  When instumentation-profiling, we change the code being profiled, supplementing it with logging of all function calls with the time they are executed.  This method collects detailed, but slightly distorted information, because as a result, it is not the source code that is profiled, but the modified one - with logging. </p><br><p>  When sampling profiling, the code being profiled does not change, but the executing system periodically pauses its execution and logs the current snapshot of the call stack.  The essence of this method will be discussed later with an example. <br><br></p><br><h2>  Operated experiment number 1. <br>  Instrumentation approach </h2><br><p>  This approach is very organically implemented in our case, when all the code is a set of functions.  Everything is done in a couple of steps. </p><br><p>  Helper to record time in nanoseconds using process.hrtime (Date milliseconds will not suffice): </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nano</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> = process.hrtime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">1e9</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><p>  A wrapper that starts the original function and logs its execution time: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> __profileWrap__(<span class="hljs-type"><span class="hljs-type">name</span></span>, callback, args) { var startTime = nano(), result = callback.apply(ctx, args), <span class="hljs-type"><span class="hljs-type">time</span></span> = nano() - startTime; logStream.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Actually wrapping code: </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(blocks).forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">funcName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> base = blocks[funcName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> base === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { blocks[funcName] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __profileWrap__(funcName, base, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; } });</code> </pre> <br><p>  It's simple. </p><br><p>  But in such an implementation, recursive calls were handled incorrectly.  For example, such a case of indirect recursion: </p><br><img src="https://habrastorage.org/files/861/987/8bb/8619878bb64a4cde9165ede43e17fe81.png"><br><p>  The total execution time of function X included its internal call twice: once as part of the time the external call was running, and a second time separately. </p><br><p>  For correct processing of recursive calls, editing was required: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> __profileWrap__(<span class="hljs-type"><span class="hljs-type">name</span></span>, callback, args) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">called</span></span>[<span class="hljs-type"><span class="hljs-type">name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback.apply(ctx, args); <span class="hljs-keyword"><span class="hljs-keyword">called</span></span>[<span class="hljs-type"><span class="hljs-type">name</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; //   var startTime = nano(), result = callback.apply(ctx, args), <span class="hljs-type"><span class="hljs-type">time</span></span> = nano() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">called</span></span>[<span class="hljs-type"><span class="hljs-type">name</span></span>]; logStream.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  In addition, they added to the profiled code an entry in the log of the marker, signifying the end of processing a single request.  The marker will help to match the log entries with specific queries in order to count different metrics of interest. </p><br><p>  To process the log for computing, for example, the medians of the execution time of functions, you need the following code: </p><br><pre> <code class="hljs lua">var requests = [], currentRequest = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMedians</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var funcTime = {}; requests.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span></span> { Object.keys(request).forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(funcName)</span></span></span></span> { //       (funcTime[funcName] = funcTime[funcName] || []).push(request[funcName]); }); }); Object.keys(funcTime).forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(funcName)</span></span></span></span> { var arr = funcTime[funcName], value; //  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (arr.length &lt; requests.length) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); //   value = median(arr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { //      funcTime[funcName] = value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    delete funcTime[funcName]; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> funcTime; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeResults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var funcMedians = getMedians(); //        //  : &lt; &gt; &lt;&gt; &lt;   &gt; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( Object .keys(funcMedians) .<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(funcNameA, funcNameB)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> funcMedians[funcNameB] - funcMedians[funcNameA]; }) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(funcName)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> funcName + <span class="hljs-string"><span class="hljs-string">'\t'</span></span> + nano2milli(funcMedians[funcName]); }) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsedLine, isItLast)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsedLine.isMarker) { requests.push(currentRequest); currentRequest = {}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //     GET- currentRequest[parsedLine.funcName] = (currentRequest[parsedLine.funcName] || <span class="hljs-number"><span class="hljs-number">0</span></span>) + parsedLine.<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isItLast) writeResults(); } //       processLine(...)   </code> </pre> <br><p>  Having fired at the server with thousands of requests, we identified the blocks that caused everything to slow down.  But this did not want to stop - the results needed to be confirmed by a different approach. <br><br></p><br><h2>  Towards a controlled experiment # 2. <br>  Sampling-profiling out of the box </h2><br><p>  It is known that Node.JS out of the box supports this kind of profiling.  It is enough to run the application with the necessary parameters, and the data will be collected in the specified file: </p><br><p> <code>node --prof ‚Äîlogfile=v8.log my_app.js</code> </p> <br><p>  <code>man node</code> - contains many more interesting options. </p><br><p>  The log looks like this: </p><br><img src="https://habrastorage.org/files/ae7/809/7f2/ae78097f21794f889117697b8183e1f0.png"><br><br><p>  We note immediately that logging is not synchronized; when profiling a multi-threaded code, we received ‚Äústitched‚Äù lines.  Having discovered this, we turned off the layer that organizes multithreaded PRIV code for the duration of the tests in our project. </p><br><p>  In the process of finding the answer to the question of how to read the log, we managed to find the <a href="https://github.com/v8/v8/wiki/V8%2520Profiler">node-tick-processor</a> module.  This module parses the log and displays into the console the already familiar full call tree of the spent program in two forms - <em>bottom-up</em> and <em>top-down</em> , only the execution time for each function is considered not in milliseconds, but in ticks. </p><br><p>  We wanted to know the details of the operation of the tick-processor algorithm and answer the questions: </p><br><ul><li>  How is the call tree built? </li><li>  What do tics mean? </li><li>  Why ticks, not milliseconds? </li></ul><br><p>  It was immediately established that the source files of the tick-processor are <a href="https://github.com/v8/v8/tree/master/tools">files from v8 / tools</a> . </p><br><p>  Parsing the log happens like this. </p><br><p>  The log is a csv file, each line is a command with parameters.  The main commands are: </p><br><ul><li>  commands binding code fragments to addresses (shared-library, code-creation, code-move); </li><li>  the tick command corresponding to the stack snapshot (the frequency of ticks is set by the option node ‚Äîcpu_profiler_sampling_interval, by default <del>  1 ms </del>  100 ms). </li></ul><br><p>  Code snippets are either C code snippets (static or shared) or JS code snippets (dynamic).  All fragments are stored in three splaytree structures, respectively. </p><br><p>  Tick ‚Äã‚Äãlines are arranged like this: </p><br><img src="https://habrastorage.org/files/758/b82/737/758b82737a154262a72c100bbef64e8c.png"><br><p>  <em>timestamp</em> corresponds to tick time, <em>vmState</em> is the state of the virtual machine (0 is JS execution), then comes the stack of addresses.  Using the splaytree structures, the function names in the stack are restored. </p><br><p>  All stacks thus obtained are glued together, making up a full tree of challenges: </p><br><img src="https://habrastorage.org/files/92f/ab5/551/92fab55513e24582853e68c855633396.png"><br><p>  Each calllist is assigned a hitCount value with the meaning ‚Äúhow many times a function was called like this‚Äù.  When profiling is completed, hitCount is calculated for all internal nodes from bottom to top.  The values ‚Äã‚Äãobtained are the tics that the tick-processor shows in its output. </p><br><p>  There is an obvious, but crude way to convert ticks to milliseconds: </p><br><p> <code>hitTime = (maxTimestamp - minTimestamp) / (timestamps.length - 1)</code> <br> <code>blockTime = hitCount * hitTime</code> </p> <br><p>  The time between ticks is not the same in reality, and the fact that we were inside function F at time T and at time T + 1 ms does not mean at all that the function was performed 2 ms.  It is possible that completely different functions were performed between these points in time, which such a method of profiling ‚Äúwill not notice‚Äù.  However, this is exactly how execution time is considered in Chromium - <a href="https://code.google.com/p/chromium/codesearch">https://code.google.com/p/chromium/code</a> search#chromium/ <a href="https://code.google.com/p/chromium/codesearch">src/</a> third_party/ <a href="https://code.google.com/p/chromium/codesearch">WebKit/</a> Source/ <a href="https://code.google.com/p/chromium/codesearch">devtools/</a> front_end/ <a href="https://code.google.com/p/chromium/codesearch">sdk/</a> CPUProfileDataModel.js&amp;sq= <a href="https://code.google.com/p/chromium/codesearch">package: chromium &amp; type = cs &amp; l = 31</a> </p><br><p>  In any case, we needed an alternative profiling method to validate the results of the instrumentation method. <br><br></p><br><h2>  Managed experiment number 2. <br>  Sampling approach </h2><br><p>  Fortunately, I didn‚Äôt have to dig into the node-tick-processor for a long time, as there was a <a href="https://github.com/node-inspector/v8-profiler">v8-profiler</a> module that works like this: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> profiler = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'v8-profiler'</span></span>); profiler.startProfiling(<span class="hljs-string"><span class="hljs-string">'profilingSession'</span></span>); doSomeWork(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(profiler.stopProfiling(<span class="hljs-string"><span class="hljs-string">'profilingSession'</span></span>));</code> </pre> <br><p>  In this case, an object of the following type is printed to the console: </p><br><img src="https://habrastorage.org/files/6e6/cbe/0f4/6e6cbe0f4e794a87a6086177445baaaf.png"><br><p>  Our profiling code when using v8-profiler looks like this: </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitTime; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkoutTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hits = node.hitCount || <span class="hljs-number"><span class="hljs-number">0</span></span>; node.children.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(childNode)</span></span></span><span class="hljs-function"> </span></span>{ hits += checkoutTime(childNode); }); logStream.write(node.functionName + <span class="hljs-string"><span class="hljs-string">','</span></span> + (hits * hitTime) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hits; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(profile)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timestamps = profile.timestamps, lastTimestampIndex = timestamps.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,      hitTime = 1000 * (timestamps[lastTimestampIndex] - timestamps[0]) / lastTimestampIndex; checkoutTime(profile.head); }</span></span></code> </pre> <br><p>  By analogy with instrumentation, editing is needed for correct recursion processing: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stackAlreadyHas(node, <span class="hljs-type"><span class="hljs-type">name</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node &amp;&amp; (node.functionName === <span class="hljs-type"><span class="hljs-type">name</span></span> || stackAlreadyHas(node.parent, <span class="hljs-type"><span class="hljs-type">name</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> checkoutTime(node) { var <span class="hljs-type"><span class="hljs-type">name</span></span> = node.functionName, hits = node.hitCount || <span class="hljs-number"><span class="hljs-number">0</span></span>; node.children.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(childNode) { //   childNode.parent = <span class="hljs-type"><span class="hljs-type">name</span></span>; hits += checkoutTime(childNode); }); //         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stackAlreadyHas(node.parent, <span class="hljs-type"><span class="hljs-type">name</span></span>)) { logStream.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + (hits * hitTime) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hits; }</code> </pre> <br><br><h2>  Guided experiments.  results </h2><br><p>  The median runtime for the <em>serp-item</em> block is the main block corresponding to one search results result (the page contains 10 such results): </p><br><table><thead><tr><th>  method </th><th>  desktop </th><th>  tablet </th></tr></thead><tbody><tr><td>  Instrumentation </td><td>  38.4 ms </td><td>  35.9 ms </td></tr><tr><td>  Sampling </td><td>  25.3 ms </td><td>  25.0 ms </td></tr></tbody></table><br><p>  Because of the fundamental differences in the methods, the absolute values ‚Äã‚Äãare expected to be different. </p><br><p>  In the next step, we tried to minimize the contribution of the profiling logic in the instrumentation method with the help of small optimizations.  In the sampling method, we shortened the time between ticks (setSamplingInterval method).  The picture has not changed.  Calls close to the root of the tree had similar indicators, but the farther away the calls were from the root, the more they differed. <br><br></p><br><h2>  findings </h2><br><p>  Deeper calls correspond to functions called many times.  For them, the measurement error is equal to the product of the method error and the number of calls, so small changes in the overall picture do not change. </p><br><p>  We can assume that the sampling method often underestimates the indicators.  Instrumentation method overstates performance by construction.  Probably, when profiling a code with a low call tree, both methods will show similar results, but in the general case you should not expect this. </p><br><p>  Despite the difference in absolute results, the relative values ‚Äã‚Äãfor specific blocks turned out to be close.  Both methods showed the same list of "braking" blocks.  ‚ÄúGuided experiments‚Äù were designed as ‚Äútools‚Äù for profiling our PRIV code. </p><br><p>  The optimization cycle in general looked like this: </p><br><ul><li>  Run the tool. </li><li>  If the required level of code performance is reached - the end. </li><li>  Find braking block functions. </li><li>  Optimize block functions. </li><li>  To the begining. </li></ul><br><p>  As a result, we optimized a number of blocks, and the updated code has ceased to yield to the speed of the old implementation. </p><br><p>  Here are the current numbers for the <em>serp-item</em> (recall, the indicator for the entire page of search results is obtained by multiplying by 10): </p><br><table><thead><tr><th>  method </th><th>  desktop </th><th>  tablet </th></tr></thead><tbody><tr><td>  Instrumentation </td><td>  35.1 ms (-3.3) </td><td>  34.8 ms (-1.1) </td></tr><tr><td>  Sampling </td><td>  24.9 ms (-0.4) </td><td>  24.8 ms (-0.2) </td></tr></tbody></table><br><h2>  Instead of conclusion </h2><br><p>  Strictly speaking, we had a simple case - profiling simple flat functions.  In the case of profiling code with objects and inheritance or asynchronous code, it will be much more difficult to understand dependencies and to draw conclusions about the contribution of individual parts to the total program execution time. </p><br><p>  If we have a task to profile more complex code, there will be an appropriate solution, which we will definitely describe here. </p></div><p>Source: <a href="https://habr.com/ru/post/282159/">https://habr.com/ru/post/282159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282149/index.html">Proper error handling in javascript</a></li>
<li><a href="../282151/index.html">DevConf-2016: waiting for applications for reports</a></li>
<li><a href="../282153/index.html">INTEL represents the release of the source code for the Arduino 101 firmware</a></li>
<li><a href="../282155/index.html">There is a question: why e-mail topics become longer, and what does it affect</a></li>
<li><a href="../282157/index.html">Network protocol for backing up data in networks with delay and packet loss</a></li>
<li><a href="../282161/index.html">GTD: write a thesis and stay alive</a></li>
<li><a href="../282163/index.html">Using arduino to automate device testing</a></li>
<li><a href="../282165/index.html">The results of the selection for the section Young School</a></li>
<li><a href="../282167/index.html">As I wrote the book 'Python Machine Learning'</a></li>
<li><a href="../282173/index.html">You Telegramma: SPARQL-injections and CSRF via Telegram-messages in the NeoQUEST-2016 task</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>