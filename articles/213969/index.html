<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Glibc library verification experiment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We conducted an experiment on checking the glibc library with PVS-Studio. The purpose of the experiment is to see how successfully the analyzer can te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Glibc library verification experiment</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/600/1c0/ff26001c02cc1841ad22c1b9549cac18.png" alt="glibc and PVS-Studio" align="left"><br>  We conducted an experiment on checking the glibc library with PVS-Studio.  The purpose of the experiment is to see how successfully the analyzer can test Linux projects.  While bad can.  There is a huge number of false positives due to the use of non-standard extensions.  However, I still managed to find something interesting. <br><a name="habracut"></a><br><h2>  glibc </h2><br>  <b><i>glibc</i></b> <i>- GNU C Library (GNU library).</i>  <i>Glibc is a C library that provides system calls and basic functions such as open, malloc, printf, etc.</i>  <i>The C library is used for all dynamically linked programs.</i>  <i>It is written by the Free Software Foundation for GNU operating systems.</i>  <i>glibc is released under the GNU LGPL license.</i> <br><br>  <i>Taken from Wikipedia: <a href="http://www.viva64.com/go.php%3Furl%3D1353"><i>glibc</i></a> .</i> <br><br>  Not so long ago, news appeared on the Internet that a new version of the glibc library was released.  This prompted us to check this library with the help of our <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer.  Namely, the version glibc-2-19-90 was tested.  Unfortunately, I was distracted for a couple of weeks, so I found the time to write an article just now.  I was busy comparing a few static analyzers.  This is a very important task for us, since they do not stop asking us what is better than Cppcheck and the static analyzer in Visual Studio 2013. Therefore, glibc had to wait a bit. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We did not expect to find something terrible and really did not find it.  The glibc library is very high quality and verifiable by many analyzers.  At a minimum, this: <ul><li>  Coverity; </li><li>  Clang; </li><li>  Cppcheck </li></ul>  So to find at least something, this is already a great achievement. <br><br><h2>  What is the complexity of the analysis </h2><br>  Unfamiliar with the internal kitchen of static analysis tools, they seem to be very simple utilities.  This is not true.  These are very complex programs. <br><br>  Such tools as <a href="http://www.viva64.com/go.php%3Furl%3D1354">RATS</a> can be <a href="http://www.viva64.com/go.php%3Furl%3D1354">confusing</a> .  If someone watched the RATS code, then I saw that it was just a search for certain function names in the files.  This tool is also called a static code analyzer.  However, it is very far from what real code analyzers do.  Static analysis is not a search using regular expressions at all [ <a href="http://www.viva64.com/ru/b/0087/">1</a> ]. <br><br>  Repeatedly, we repeated that the Linux version is not at all the same as a recompiled executable [ <a href="http://www.viva64.com/ru/b/0231/">2</a> ].  There is an abyss between the executable module and the software product.  One obstacle, support for specific extensions and the like. <br><br>  What it is for an outsider is completely incomprehensible.  Here from sees, in the program a function call of strcmp (): <br><pre><code class="cpp hljs">cmpres = <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (newp-&gt;from_string, root-&gt;from_string);</code> </pre> <br>  And he doesn‚Äôt even suspect the horror of this line after preprocessing and which non-standard extensions will be used.  Specifically in our case, the string turns into this: <br><pre> <code class="cpp hljs">cmpres = __extension__ ({ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> __s1_len, __s2_len; (__builtin_constant_p (newp-&gt;from_string) &amp;&amp; __builtin_constant_p (root-&gt;from_string) &amp;&amp; (__s1_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (newp-&gt;from_string), __s2_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (root-&gt;from_string), (!((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((newp-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(newp-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) || __s1_len &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (!((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((root-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(root-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) || __s2_len &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>)) ? __builtin_strcmp (newp-&gt;from_string, root-&gt;from_string) : (__builtin_constant_p (newp-&gt;from_string) &amp;&amp; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((newp-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(newp-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (__s1_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (newp-&gt;from_string), __s1_len &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) ? (__builtin_constant_p (root-&gt;from_string) &amp;&amp; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((root-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(root-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) ? __builtin_strcmp (newp-&gt;from_string, root-&gt;from_string) : (__extension__ ({ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *__s2 = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (root-&gt;from_string); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (newp-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">0</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s1_len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) { __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (newp-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">1</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s1_len &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) { __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (newp-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">2</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s1_len &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (newp-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">3</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">3</span></span>]); } } __result; }))) : (__builtin_constant_p (root-&gt;from_string) &amp;&amp; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((root-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(root-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (__s2_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (root-&gt;from_string), __s2_len &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) ? (__builtin_constant_p (newp-&gt;from_string) &amp;&amp; ((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((newp-&gt;from_string) + <span class="hljs-number"><span class="hljs-number">1</span></span>) - (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(newp-&gt;from_string) == <span class="hljs-number"><span class="hljs-number">1</span></span>) ? __builtin_strcmp (newp-&gt;from_string, root-&gt;from_string) : (- (__extension__ ({ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *__s2 = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (newp-&gt;from_string); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (root-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">0</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s2_len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) { __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (root-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">1</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s2_len &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) { __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (root-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">2</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__s2_len &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; __result == <span class="hljs-number"><span class="hljs-number">0</span></span>) __result = (((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (root-&gt;from_string))[<span class="hljs-number"><span class="hljs-number">3</span></span>] - __s2[<span class="hljs-number"><span class="hljs-number">3</span></span>]); } } __result; })))) : __builtin_strcmp (newp-&gt;from_string, root-&gt;from_string)))); });</code> </pre> <br>  The analyzer is not ready for such a turn of events and, at times, produces meaningless false messages on such constructions. <br><br>  I will explain about false messages on a simpler example.  Suppose we have a line of code: <br><pre> <code class="cpp hljs">assert(MAP_FAILED == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br>  The macro assert () is expanded into the following code: <br><pre> <code class="cpp hljs">((((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-number"><span class="hljs-number">-1</span></span>) == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-number"><span class="hljs-number">-1</span></span>) ? (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span>) : __assert_fail (<span class="hljs-string"><span class="hljs-string">"((void *) -1) == (void *) -1"</span></span>, <span class="hljs-string"><span class="hljs-string">"loadmsgcat.c"</span></span>, <span class="hljs-number"><span class="hljs-number">840</span></span>, __PRETTY_FUNCTION__));</code> </pre> <br>  The PVS-Studio analyzer gives a false warning regarding the comparison (((void *) -1) == (void *) -1): <br><br>  <i>V501 There are identical to the left and the right of the operator: = (operator: ((void *) - 1) == (void *) - 1 loadmsgcat.c 840</i> <br><br>  We are not surprised by this.  All this we have already passed, leading the development of programs collected using Visual C ++.  There are also many interesting and unusual things.  Much work needs to be done to teach the analyzer to understand what is what.  We need to teach him to understand that he is dealing with the macro ‚Äúassert‚Äù which is harmless and simply verifies that the macro MAP_FAILED is "(void *) -1".  All this has already been done for Visual C ++.  No for Linux. <br><br>  The ability to work correctly with such constructions and consists a huge part of the work on supporting other compilers.  Externally, this work is not visible.  But it requires studying the features of the compiler and standard libraries.  These features must be studied, supported and tested. <br><br>  I hope I opened a little crack, so you can look into hell.  In the future, I plan to write a series of articles that will show the complexity of developing static analysis tools.  I think it will be interesting. <br><br><h2>  Suspicious code fragments found </h2><br>  Although the glibc project is being tested by many tools, we managed to find something interesting.  Let's look at these sections of the code. <br><br><h3>  Strange expression </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCIGETTEXT</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* Make CATEGORYVALUE point to the next element of the list. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (categoryvalue[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; categoryvalue[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">':'</span></span>) ++categoryvalue; .... }</code> </pre> <br>  V590 Consider inspecting this expression.  The expression is misprint.  dcigettext.c 582 <br><br>  The condition can be simplified to: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (categoryvalue[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">':'</span></span>)</code> </pre> <br>  Perhaps this is not an error and the first part of the condition (categoryvalue [0]! = '\ 0') is simply superfluous.  However, suddenly it should be written like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (categoryvalue[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; categoryvalue[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">':'</span></span>)</code> </pre> <br><h3>  Pointer dereferencing before checking </h3><br>  Not necessarily, this place is dangerous.  Perhaps the pointer can never be zero.  But nonetheless: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> clnt_stat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clntraw_call</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h, proc, xargs, argsp, xresults, resultsp, timeout)</span></span></span><span class="hljs-function"> CLIENT *h</span></span>; u_long proc; <span class="hljs-keyword"><span class="hljs-keyword">xdrproc_t</span></span> xargs; <span class="hljs-keyword"><span class="hljs-keyword">caddr_t</span></span> argsp; <span class="hljs-keyword"><span class="hljs-keyword">xdrproc_t</span></span> xresults; <span class="hljs-keyword"><span class="hljs-keyword">caddr_t</span></span> resultsp; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clntraw_private_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clp</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clntraw_private</span></span></span><span class="hljs-class">;</span></span> XDR *xdrs = &amp;clp-&gt;xdr_stream; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RPC_FAILED; .... }</code> </pre> <br>  V595 The 'clp' pointer was used before it was verified against nullptr.  Check lines: 145, 150. clnt_raw.c 145 <br><br>  Next to this file you can see a similar defect: V595 The 'clp' pointer was used against nullptr.  Check lines: 232, 235. clnt_raw.c 232 <br><br>  Another example of dangerous code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __nss_getent_r (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res &amp;&amp; __res_maybe_init (&amp;_res, <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { *h_errnop = NETDB_INTERNAL; *result = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errno; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == NSS_STATUS_TRYAGAIN &amp;&amp; (h_errnop == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || *h_errnop == NETDB_INTERNAL) &amp;&amp; errno == ERANGE) }</code> </pre> <br>  V595 The 'h_errnop' pointer was used before it was verified against nullptr.  Check lines: 146, 172. getnssent_r.c 146 <br><br>  If the if (res &amp;&amp; __res_maybe_init (&amp; _res, 0) == -1) condition is met, the function returns error information.  However, it dereferences the 'h_errnop' and 'result' pointers.  However, these pointers may well be NULL.  This conclusion can be made by examining the code below. <br><br><h3>  Dangerous optimization (vulnerability) </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * __sha256_crypt_r (key, salt, buffer, buflen) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *key; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *salt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buflen; { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> temp_result[<span class="hljs-number"><span class="hljs-number">32</span></span>] .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (temp_result, <span class="hljs-string"><span class="hljs-string">'\0'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (temp_result)); .... .... <span class="hljs-comment"><span class="hljs-comment">// temp_result    }</span></span></code> </pre> <br>  V597 The compiler could delete the memset function call, which is used to flush the temp_result buffer.  The RtlSecureZeroMemory () function should be used to erase the private data.  sha256-crypt.c 385 <br><br>  The compiler has the right to remove a call to the memset () function when compiling the Release version.  More precisely, it is not only in the right, but it is also obliged to do this for the purpose of optimization.  The buffer 'temp_result' after calling the function memset () is not used anywhere, hence the function call itself is also superfluous. <br><br>  We are dealing with a vulnerability, since private data will not be cleared.  You should replace the memset () function with a more appropriate one.  The analyzer offers RtlSecureZeroMemory (), which of course is not in Linux.  But there are analogues. <br><br>  A similar situation: V597 The compiler could delete the memset function call, which is used to flush 'temp_result' buffer.  The RtlSecureZeroMemory () function should be used to erase the private data.  sha512-crypt.c 396 <br><br><h3>  Undefined behavior </h3><br>  It would seem that the library glibc should be written as portable as possible.  However, we find in it quite a few shear structures that cannot be called safe from the point of view of tolerance. <br><br>  Here is what the C language standard tells us about shifts: <br><br>  Integer promotions are performed on each of the operands.  The promoted left operand.  If you want to make it to the bottom of the water, you‚Äôre not sure. <br><br>  The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions;  vacated bits are filled with zeros.  E1 * 2, E2 * 2, E2 * 2 E2, E2 * 2 E2,  If E1 has a signed type and a non-negative value, and E1 * 2 pow E2 is a representation of the type, then that is the resulting value;  otherwise, the behavior is undefined. <br><br>  5 The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions.  The E1 / 2 pow E2 has an unsigned type.  If E1 has a signed value <br><br>  It follows from the standard that it is wrong to shift negative numbers.  However, this is a very common operation in the glibc library. <br><br>  <b>Shift left example:</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_cacheinfo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... count_mask = ~(<span class="hljs-number"><span class="hljs-number">-1</span></span> &lt;&lt; (count_mask + <span class="hljs-number"><span class="hljs-number">1</span></span>)); .... }</code> </pre> <br>  V610 Undefined behavior.  Check the shift operator '&lt;&lt;.  The left operand '-1' is negative.  cacheinfo.c 645 <br><br>  <b>Right shift example:</b> <br><pre> <code class="cpp hljs">utf8_encode (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) { .... *buf = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) (~<span class="hljs-number"><span class="hljs-number">0xff</span></span> &gt;&gt; step); .... }</code> </pre> <br>  The expression "~ 0xff" is of type 'int' and is equal to -256. <br><br>  Here is a list of all the places where you can observe incorrect shifts: <ul><li>  strxfrm_l.c 68 </li><li>  clock_nanosleep.c 38 </li><li>  ifaddrs.c 786 </li><li>  xdr_intXX_t.c 35 </li><li>  xdr_intXX_t.c 41 </li><li>  private.h 327 </li><li>  private.h 331 </li><li>  zic.c 696 </li><li>  zdump.c 212 </li><li>  zdump.c 216 </li><li>  timer_create.c 47 </li><li>  timer_create.c 49 </li><li>  loop.c 331 </li><li>  loop.c 437 </li><li>  mktime.c 207 </li><li>  mktime.c 208 </li><li>  mktime.c 211 </li><li>  mktime.c 212 </li><li>  mktime.c 230 </li><li>  mktime.c 298 </li><li>  mktime.c 298 </li><li>  ld-collate.c 298 </li></ul><br><br><h3>  Using an uninitialized variable </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_vc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> truncating, connreset, resplen, n; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STRING_ARCH_unaligned *anssizp2 = orig_anssizp - resplen; *ansp2 = *ansp + resplen; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> .... } V614 Uninitialized variable </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'resplen'</span></span></span><span class="hljs-meta"> used. res_send.c 790</span></span></code> </pre> <br><h3>  Incorrect formatting of strings </h3><br>  In some places, '% u' is used to print character variables.  In some other places, '% d' is used to print unsigned variables.  These are trifles, of course, but they are also worth mentioning. <br><br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__uid_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__uid_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uid_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2netname</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uid, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span> (netname, <span class="hljs-string"><span class="hljs-string">"%s.%d@%s"</span></span>, OPSYS, uid, dfltdom); .... }</code> </pre> <br>  V576 Incorrect format.  Consider checking the fourth argument of the 'sprintf' function.  The SIGNED integer type argument is expected.  netname.c 51 <br><br>  Other relevant messages: <ul><li>  Consider the second printf function.  The SIGNED integer type argument is expected.  locarchive.c 1741 </li><li>  Consider checking the fourth argument of the printf function.  The SIGNED integer type argument is expected.  locarchive.c 1741 </li><li>  Consider checking the fifth argument.  The SIGNED integer type argument is expected.  res_debug.c 236 </li><li>  Consider checking the sprintf function.  The UNSIGNED integer type argument is expected.  inet_net_ntop.c 134 </li><li>  Consider checking the fourth argument of the 'sprintf' function.  The SIGNED integer type argument is expected.  ns_print.c 500 </li><li>  Consider checking the sprintf function.  The SIGNED integer type argument is expected.  ns_print.c 500 </li><li>  Consider checking the sprintf function.  The SIGNED integer type argument is expected.  ns_print.c 572 </li><li>  Consider checking the fourth argument of the 'sprintf' function.  The SIGNED integer type argument is expected.  ns_print.c 572 </li><li>  Consider checking the sprintf function.  The SIGNED integer type argument is expected.  ns_print.c 572 </li><li>  Consider checking the sprintf function.  The UNSIGNED integer type argument is expected.  ns_print.c 628 </li><li>  Consider checking the fourth argument of the 'sprintf' function.  The UNSIGNED integer type argument is expected.  ns_print.c 628 </li><li>  Consider checking the sprintf function.  The UNSIGNED integer type argument is expected.  ns_print.c 628 </li><li>  Consider checking the sprintf function.  The SIGNED integer type argument is expected.  ns_print.c 645 </li><li>  Consider checking the sprintf function.  The UNSIGNED integer type argument is expected.  ns_print.c 685 </li><li>  Consider the second printf function.  The SIGNED integer type argument is expected.  nis_print.c 209 </li><li>  Consider the second printf function.  The SIGNED integer type argument is expected.  sprof.c 480 </li></ul><br><br><h2>  Conclusion </h2><br>  An unsuccessful project was chosen to begin checking code from the Linux world  It is too high quality.  :) It's hard to write an interesting article about errors.  But it does not matter.  A lot of other well-known and interesting projects in Linux are waiting for us, which we check to demonstrate the capabilities of the PVS-Studio analyzer. <br><br><h2>  Additional links </h2><br><ol><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0087/">Static analysis and regular expressions</a> . </li><li>  Dmitry Tkachenko.  <a href="http://www.viva64.com/ru/b/0231/">Interview with Andrei Karpov, technical director of PVS-Studio and CppCat projects</a> . </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Answers on questions</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected the answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio and CppCat, version 2014</a> . <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/213969/">https://habr.com/ru/post/213969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213955/index.html">So, you are trying to assess the reliability of your cloud service.</a></li>
<li><a href="../213959/index.html">Video course "Introduction to Logic" in Russian</a></li>
<li><a href="../213961/index.html">Mail.Ru rating: new features</a></li>
<li><a href="../213965/index.html">Brief Errors</a></li>
<li><a href="../213967/index.html">How we created Robot Pasha</a></li>
<li><a href="../213971/index.html">We use delegation together with inheritance to organize action controllers</a></li>
<li><a href="../213973/index.html">Explore Linux Botnet "BillGates"</a></li>
<li><a href="../213975/index.html">The results of a single rating of mobile-developers 2014</a></li>
<li><a href="../213977/index.html">Preview version of Visual Studio 2013 Update 2</a></li>
<li><a href="../213983/index.html">Force majeure, or how people lost their data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>