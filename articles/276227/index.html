<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>man! (C => D)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each C-programmer with experience accumulates familiar baggage of technicians and idioms. It is often difficult to understand how to do the same in a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>man! (C => D)</h1><div class="post__text post__text-html js-mediator-article"><p>  Each C-programmer with experience accumulates familiar baggage of technicians and idioms.  It is often difficult to understand how to do the same in a new language.  So, your attention is invited to a collection of common patterns in C and their equivalents in D. If you are going to transfer your program from C to D, or if you still doubt whether this should be done, then this article is for you. </p><a name="habracut"></a><br><h1 id="poluchaem-razmer-tipa-v-baytah">  Get type size in bytes </h1><br><p>  In C, we use a special operator: </p><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ) <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Foo )</code> </pre> <br><p>  In D, each type has a special property: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*).<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> Foo.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span></code> </pre> <br><h1 id="poluchaem-maksimalnoe-i-minimalnoe-znachenie-tipa">  We get the maximum and minimum value of the type </h1><br><p>  It was on C: </p><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">limits</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHAR_MAX</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHAR_MIN</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ULONG_MAX</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MIN</span></span></code> </pre> <br><p>  It became on D: </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">char</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> ulong.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> double.min_normal</code> </pre> <br><h1 id="tablica-sootvetstviya-tipov-c--d">  Type Conformity Table C =&gt; D </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> =&gt; byte <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> =&gt; ubyte <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> =&gt; ushort <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> =&gt; wchar <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> =&gt; uint <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> =&gt; uint <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> =&gt; ulong <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> =&gt; real <span class="hljs-keyword"><span class="hljs-keyword">_Imaginary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> =&gt; ireal <span class="hljs-keyword"><span class="hljs-keyword">_Complex</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> =&gt; creal</code> </pre> <br><h1 id="osobye-znacheniya-chisel-s-plavayuschey-tochkoy">  Special values ‚Äã‚Äãof floating point numbers </h1><br><p>  It was on C: </p><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">fp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">NAN</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INFINITY</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_DIG</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_EPSILON</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MANT_DIG</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MAX_10_EXP</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MAX_EXP</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MIN_10_EXP</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DBL_MIN_EXP</span></span></code> </pre> <br><p>  It became on D: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">infinity</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>.dig <span class="hljs-type"><span class="hljs-type">double</span></span>.epsilon <span class="hljs-type"><span class="hljs-type">double</span></span>.mant_dig <span class="hljs-type"><span class="hljs-type">double</span></span>.max_10_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.max_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.min_10_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.min_exp</code> </pre> <br><h1 id="ostatok-ot-deleniya-veschestvennyh-chisel">  The remainder of dividing real numbers </h1><br><p>  In C, we use a special function: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; float f = fmodf( x , y ); double d = fmod( x , y ); long double r = fmodl( x , y );</span></span></span></span></code> </pre> <br><p>  D has a special operator for this operation: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> f = x % y; <span class="hljs-type"><span class="hljs-type">double</span></span> d = x % y; <span class="hljs-type"><span class="hljs-type">real</span></span> r = x % y;</code> </pre> <br><h1 id="obrabotka-nan-znacheniy">  Processing NaN Values </h1><br><p>  In C, comparing with NaN is an indefinite behavior and different compilers react differently (from ignoring to throwing an exception), so you have to use special functions: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#include &lt;math.h&gt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">( isnan( x ) || isnan( y ) ) { result = FALSE; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { result = ( x &lt; y ); }</span></span></code> </pre> <br><p>  In D, the comparison with NaN always returns false: </p><br><pre> <code class="hljs pgsql">result = ( x &lt; y ); // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nan</span></span></code> </pre> <br><h1 id="aserty--poleznyy-mehanizm-vyyavleniya-oshibok">  Acerta - a useful error detection mechanism </h1><br><p>  In C, there is no built-in acert mechanism, but it supports the <strong>FILE</strong> , <strong>LINE</strong> pseudo-constants and macros with which you can implement acerts (in fact, these constants have no other practical application): </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;assert.h&gt; assert( e == 0 );</span></span></span></span></code> </pre> <br><p>  D supports asperts at the language level: </p><br><pre> <code class="hljs lisp">assert( <span class="hljs-name"><span class="hljs-name">e</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><h1 id="iterirovanie-po-massivu">  Array iteration </h1><br><p>  On C in, you specify the length of the array as a constant, and then run through the array with a cumbersome for-loop: </p><br><pre> <code class="hljs swift">#define <span class="hljs-type"><span class="hljs-type">ARRAY_LENGTH</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span> int array[ <span class="hljs-type"><span class="hljs-type">ARRAY_LENGTH</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-type"><span class="hljs-type">ARRAY_LENGTH</span></span> ; i++ ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( array[i] )</span></span></span></span>; }</code> </pre> <br><p>  You can also use a clumsy expression with sizeof (), but this does not change much: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> ) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] ) ; i++ ) { func( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] ); }</code> </pre> <br><p>  In D, arrays have a length property: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i ; <span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length ) { func( <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i] ); }</code> </pre> <br><p>  But, if possible, it is better to use iteration over the collection: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> ) { func( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ); }</code> </pre> <br><h1 id="inicializaciya-elementov-massiva">  Array elements initialization </h1><br><p>  On C, you had to go through the array in a loop (or use a macro again): </p><br><pre> <code class="hljs vbscript">#define ARRAY_LENGTH <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[ ARRAY_LENGTH ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; ARRAY_LENGTH ; i++ ) { <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = value; }</code> </pre> <br><p>  D has a special simple notation for this particular case: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>;</code> </pre> <br><h1 id="sozdanie-massivov-peremennoy-dliny">  Creating variable length arrays </h1><br><p>  C does not support such arrays, so you have to set up a separate variable for the length and manually manage memory allocation: </p><br><pre> <code class="hljs vbscript">#include &lt;stdlib.h&gt; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> array_length; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *newarray; newarray = (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> *) realloc( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> , ( array_length + <span class="hljs-number"><span class="hljs-number">1</span></span> ) * sizeof( <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !newarray ) <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>( <span class="hljs-string"><span class="hljs-string">"out of memory"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = newarray; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[ array_length++ ] = x;</code> </pre> <br><p>  D has built-in support for variable-length arrays and itself ensures proper memory handling: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[ <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = x;</code> </pre> <br><h1 id="soedinenie-strok">  String concatenation </h1><br><p>  C has to solve many problems like ‚Äúwhen memory can be freed‚Äù, ‚Äúhow to handle null pointers‚Äù, ‚Äúhow to know the length of a string‚Äù, ‚Äúhow much memory to allocate‚Äù and others: </p><br><pre> <code class="hljs lua">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.h&gt; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *s1; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *s2; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *s; // Concatenate s1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> put result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s free(s); s = malloc( ( s1 ? strlen( s1 ) : <span class="hljs-number"><span class="hljs-number">0</span></span> ) + ( s2 ? strlen( s2 ) : <span class="hljs-number"><span class="hljs-number">0</span></span> ) + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !s ) <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"out of memory"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s1 ) { strcpy( s, s1 ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *s = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s2 ) { strcpy( s + strlen( s ) , s2 ); } // Append <span class="hljs-string"><span class="hljs-string">"hello"</span></span> to s <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> hello[] = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *news; size_t lens = s ? strlen( s ) : <span class="hljs-number"><span class="hljs-number">0</span></span>; news = realloc( s , ( lens + strlen( hello ) + <span class="hljs-number"><span class="hljs-number">1</span></span> ) * sizeof( <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !news ) <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"out of memory"</span></span> ); s = news; memcpy( s + lens , hello , sizeof( hello ) );</code> </pre> <br><p>  In D, there are special overloaded operators ~ and ~ = designed to join lists: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s; s = s1 ~ s2; s ~= <span class="hljs-string"><span class="hljs-string">"hello"</span></span>;</code> </pre> <br><h1 id="formatirovannyy-vyvod">  Formatted output </h1><br><p>  In C, the main formatted output method is the printf () function: </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> printf( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Calling all cars %d times!\n"</span></span></span><span class="hljs-meta"> , ntimes );</span></span></code> </pre> <br><p>  What do we write in D?  Yes, almost the same: </p><br><pre> <code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> std.stdio;</span></span> writefln( <span class="hljs-string"><span class="hljs-string">"Calling all cars %s times!"</span></span> , ntimes );</code> </pre> <br><p>  But unlike printf, writef is type-safe, that is, the compiler checks the correspondence between the types of the passed parameters and the types in the template. </p><br><h1 id="obraschenie-k-funkciyam-do-obyavleniya">  Appeal to functions before the announcement </h1><br><p>  In C, the compiler does not allow accessing the function before it has met its declaration, so you have to either transfer the function itself, or, if the transfer is not possible, then insert a special declaration telling the compiler that the function will be declared later: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardfunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myfunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { forwardfunc(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardfunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... }</code> </pre> <br><p>  Compiler D analyzes the entire file, while ignoring the order of declarations in the source code: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myfunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { forwardfunc(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardfunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... }</code> </pre> <br><h1 id="funkcii-bez-argumentov">  Functions without Arguments </h1><br><p>  It was on C: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  It became on D: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... }</code> </pre> <br><h1 id="vyhod-iz-neskolkih-blokov-koda">  Exit from multiple code blocks </h1><br><p>  In C, the break and continue statements allow you to go up only one level.  To exit several blocks of code at once, you have to use goto: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> == <span class="hljs-number"><span class="hljs-number">3</span></span> ) goto Louter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span> ) goto L2; } L2:; } Louter:;</code> </pre> <br><p>  In D, you can mark a code block and then exit it from any nesting depth: </p><br><pre> <code class="hljs kotlin">Louter: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( j = <span class="hljs-number"><span class="hljs-number">0</span></span> ; j &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> Louter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> Louter; } } <span class="hljs-comment"><span class="hljs-comment">// break Louter goes here</span></span></code> </pre> <br><h1 id="prostranstvo-imyon-struktur">  Structure namespace </h1><br><p>  In C, it is somewhat annoying that structures have a separate namespace, which is why each time you have to specify the keyword struct before the name of the structure.  Therefore, a typical way to declare structures is: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ABC</span></span></span><span class="hljs-class"> {</span></span> ... } ABC;</code> </pre> <br><p>  In D, the struct struct is used to declare structures in the same namespace as all other declarations, so it is enough to write simply: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ABC</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><h1 id="vetvlenie-po-strokovym-znacheniyam-naprimer-obrabotka-argumentov-komandnoy-stroki">  Branching by string values ‚Äã‚Äã(for example, processing command line arguments) </h1><br><p>  On C, you have to start an array of strings for this, a list of constants that are synchronous with it, sequentially iterate over the array in search of the desired string, and then make a switch-case for these constants: </p><br><pre> <code class="hljs swift">#include &lt;string.h&gt; void dostring( char *s ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strings</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Hello</span></span>, <span class="hljs-type"><span class="hljs-type">Goodbye</span></span>, <span class="hljs-type"><span class="hljs-type">Maybe</span></span>, <span class="hljs-type"><span class="hljs-type">Max</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> char *table[] = { <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"goodbye"</span></span>, <span class="hljs-string"><span class="hljs-string">"maybe"</span></span> }; int i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-type"><span class="hljs-type">Max</span></span> ; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strcmp( s , table[i] ) == <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( i ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Goodbye</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ... } }</code> </pre> <br><p>  With a large number of options, it becomes difficult to maintain the synchronism of these three data structures, which leads to errors.  In addition, sequential enumeration of options is not very effective with a large number of them, which means that even more complex code is required to search non-linearly, but, for example, by a binary search or through a hash table. </p><br><p>  D, on the other hand, extends the switch functionality to strings, which simplifies the source code and allows the compiler to generate the most optimal machine code: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dostring</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( s ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"goodbye"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"maybe"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ... } }</code> </pre> <br><h1 id="vyravnivanie-poley-struktur">  Alignment of structure fields </h1><br><p>  In C, alignment control occurs through compiler arguments and affects the entire program right away and God forbid you not to recompile any module or library.  To solve this problem, preprocessor directives #pragma pack are used, but these directives are not portable and depend heavily on the compiler used: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(1) struct ABC { ... }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack()</span></span></code> </pre> <br><p>  In D, there is a special syntax with which you can fine tune how to align certain fields (By default, fields are aligned in a C compatible manner): </p><br><pre> <code class="hljs coffeescript">struct ABC { int z; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> aligned to the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> align(<span class="hljs-number"><span class="hljs-number">1</span></span>) int x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> byte aligned align(<span class="hljs-number"><span class="hljs-number">4</span></span>) { ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> declarations <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {} are dword aligned } align(<span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> to word alignment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> here <span class="hljs-literal"><span class="hljs-literal">on</span></span> int y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> word aligned }</code> </pre> <br><p>  However, the alignas keyword has already appeared in C11: </p><br><pre> <code class="hljs rust">#include &lt;stdalign.h&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> x; alignas(<span class="hljs-number"><span class="hljs-number">128</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> cacheline[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// over-aligned array of char, not array of over-aligned chars };</span></span></code> </pre> <br><h1 id="anonimnye-struktury-i-obedineniya">  Anonymous structures and associations </h1><br><p>  C to version 2011 requires all structures to give names, even if they are unnecessary: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Bar { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Abc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> y; } _abc; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p; } _bar; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> x _bar._abc.x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> y _bar._abc.y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> p _bar.p struct Foo f; fi; fx; fy; fp;</span></span></code> </pre> <br><p>  This code is not just cumbersome, but using macros to encapsulate the internal structure, which leads to the fact that the symbolic debugger does not understand what is happening here, and even these macros have a global scope, and are not limited to just the structure. </p><br><p>  D (as well as C11) supports anonymous structures, which allows nested entities to be expressed in a more natural way, while maintaining a flat front end: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> y; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p; } } Foo f; fi; fx; fy; fp;</code> </pre> <br><h1 id="opredelenie-struktur-i-peremennyh">  Defining structures and variables </h1><br><p>  In C, you can declare both a structure and a variable with one expression: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } foo;</code> </pre> <br><p>  Or separately: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; }; <span class="hljs-comment"><span class="hljs-comment">// note terminating ; struct Foo foo;</span></span></code> </pre> <br><p>  D always uses separate expressions: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-comment"><span class="hljs-comment">// note there is no terminating ; Foo foo;</span></span></code> </pre> <br><h1 id="poluchenie-smescheniya-polya-struktury">  Getting the offset field structure </h1><br><p>  In C, again, macros are used: </p><br><pre> <code class="hljs go">#include &lt;stddef&gt; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Foo { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; }; off = offsetof( Foo , y );</code> </pre> <br><p>  In D, each field has a special property: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Foo { <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> x; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> y; } <span class="hljs-attribute"><span class="hljs-attribute">off</span></span> = Foo.y.offsetof;</code> </pre> <br><h1 id="inicializaciya-obedineniy">  Initializing associations </h1><br><p>  In C, the first suitable field is initialized, which can lead to hidden bugs when changing their composition and order: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> U { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b; }; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> U x = { <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// initialize member 'a' to 5</span></span></code> </pre> <br><p>  In D, you need to explicitly indicate to which field you assign the value: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">union</span></span> U { <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> a; <span class="hljs-attribute"><span class="hljs-attribute">long</span></span> b; } <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> x = { <span class="hljs-attribute"><span class="hljs-attribute">a</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span> };</code> </pre> <br><h1 id="inicializaciya-struktur">  Initialization of structures </h1><br><p>  In C (up to the version of 1999), the fields are initialized in the order they are declared, which is not a problem for small structures, but becomes a real headache in the case of structures that are large, as well as in cases when it is necessary to change the sequence and composition of the fields: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> = {</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> , <span class="hljs-number"><span class="hljs-number">3</span></span> , <span class="hljs-number"><span class="hljs-number">2</span></span> , <span class="hljs-number"><span class="hljs-number">10</span></span> };</code> </pre> <br><p>  In D (and in C99) you can also initialize the fields in order, but it is better to explicitly specify the names of the fields being initialized: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> S { <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> a; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> b; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> c; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> d; } <span class="hljs-attribute"><span class="hljs-attribute">S</span></span> x = { <span class="hljs-attribute"><span class="hljs-attribute">b</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span> , a : <span class="hljs-number"><span class="hljs-number">5</span></span> , c : <span class="hljs-number"><span class="hljs-number">2</span></span> , d : <span class="hljs-number"><span class="hljs-number">10</span></span> };</code> </pre> <br><h1 id="inicializaciya-massivov">  Array initialization </h1><br><p>  In C, arrays are initialized in the order of the elements: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">3</span></span> , <span class="hljs-number"><span class="hljs-number">2</span></span> , <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br><p>  Nested arrays in C may not be surrounded by curly braces: </p><br><pre> <code class="hljs markdown">int b[<span class="hljs-string"><span class="hljs-string">3</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>] = { 2,3 , { 6 , 5 } , 3,4 };</code> </pre> <br><p>  In D, of course, the elements are also initialized in order, but you can explicitly specify offsets.  The following advertisements produce the same result: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] a = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] a = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// unsupplied initializers are 0, just like in C int[3] a = [ 2 : 0, 0 : 3, 1 : 2 ]; int[3] a = [ 2 : 0, 0 : 3, 2 ]; // if not supplied, the index is the previous one plus one.</span></span></code> </pre> <br><p>  Explicitly specifying indexes is very useful when you need to have a value from a set as offsets: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class"> </span></span>{ black, red, green } int[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = [ black : <span class="hljs-number"><span class="hljs-number">3</span></span>, green : <span class="hljs-number"><span class="hljs-number">2</span></span>, red : <span class="hljs-number"><span class="hljs-number">5</span></span> ];</code> </pre> <br><p>  Brackets for nested arrays are required: </p><br><pre> <code class="hljs markdown">int[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">3</span></span>] b = [<span class="hljs-string"><span class="hljs-string"> [ 2 , 3 </span></span>] , [<span class="hljs-string"><span class="hljs-string"> 6 , 5 </span></span>] , [<span class="hljs-string"><span class="hljs-string"> 3 , 4 </span></span>] ]; int[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">3</span></span>] b = [ [ 2 , 6 , 3 ] , [ 3 , 5 , 4 ] ]; // error</code> </pre> <br><h1 id="ekranirovanie-specsimvolov-v-strokah">  Escaping special characters in strings </h1><br><p>  In C, it is problematic to use the backslash character, since it means the beginning of a special sequence, so it must be duplicated: </p><br><pre> <code class="hljs tex">char file[] = "c:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>root<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>file.c"; // c:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span></span>.c char quoteString[] = "<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[^\\\\]</span></span></span></span>*(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.[^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>]*)*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>"; // /"[^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>]*(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.[^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>]*)*"/</code> </pre> <br><p>  In D, in addition to the usual lines with C-style shielding, there are also so-called ‚Äúraw lines‚Äù, where shielding does not work, and you get exactly what you entered: </p><br><pre> <code class="hljs python">string file = <span class="hljs-string"><span class="hljs-string">r"c:\root\file.c"</span></span>; // c:\root\file.c string quotedString = `<span class="hljs-string"><span class="hljs-string">"[^\\]*(\\.[^\\]*)*"</span></span>`; // <span class="hljs-string"><span class="hljs-string">"[^\\]*(\\.[^\\]*)*"</span></span></code> </pre> <br><h1 id="ascii-protiv-mnogobaytnyh-kodirovok">  ASCII versus multibyte encodings </h1><br><p>  C uses a separate type of characters wchar_t and a special prefix L for string literals with "wide characters": </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wchar.h&gt;</span></span></span><span class="hljs-meta"> char foo_ascii[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello"</span></span></span><span class="hljs-meta">; wchar_t foo_wchar[] = L</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello"</span></span></span><span class="hljs-meta">;</span></span></code> </pre> <br><p>  But because of this, there is a problem with writing universal code that is compatible with different types of characters, which is solved by special macros that add the necessary conversions: </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tchar.h&gt;</span></span></span><span class="hljs-meta"> tchar string[] = TEXT( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello"</span></span></span><span class="hljs-meta"> );</span></span></code> </pre> <br><p>  Compiler D removes constant types from the context of use, removing the burden on the programmer to specify the types of characters manually: </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> utf8 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> wstring utf16 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-16</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> dstring utf32 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-32</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code> </pre> <br><p>  However, there are special suffixes that indicate the type of characters for string constants: </p><br><pre> <code class="hljs lua">auto str = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> auto _utf8 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>c; // UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> auto _utf16 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>w; // UTF<span class="hljs-number"><span class="hljs-number">-16</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> auto _utf32 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>d; // UTF<span class="hljs-number"><span class="hljs-number">-32</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code> </pre> <br><h1 id="otobrazhenie-perechisleniya-na-massiv">  Display enumeration on an array </h1><br><p>  In C, you separately declare an enumeration, a separate array, which is rather difficult to maintain when the number of elements grows: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">COLORS</span></span></span><span class="hljs-class"> </span></span>{ red , blue , green , <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> }; char *cstring[ <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> ] = { <span class="hljs-string"><span class="hljs-string">"red"</span></span> , <span class="hljs-string"><span class="hljs-string">"blue"</span></span> , <span class="hljs-string"><span class="hljs-string">"green"</span></span> };</code> </pre> <br><p>  In D, such a mapping is given in key-value pairs, which is much easier to maintain: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">COLORS</span></span></span><span class="hljs-class"> </span></span>{ red, blue, green } string[ <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> ] cstring = [ <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.red : <span class="hljs-string"><span class="hljs-string">"red"</span></span>, <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.blue : <span class="hljs-string"><span class="hljs-string">"blue"</span></span>, <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.green : <span class="hljs-string"><span class="hljs-string">"green"</span></span>, ];</code> </pre> <br><h1 id="sozdanie-novyh-tipov">  Creating new types </h1><br><p>  In C, the typedef operator actually creates not a new type, but just an alias: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *Handle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Handle )</span></span></span></span>; Handle h; foo( h ); <span class="hljs-comment"><span class="hljs-comment">// coding bug not caught bar( h ); // ok</span></span></code> </pre> <br><p>  At the same time, to set the default value, you have to use macros: </p><br><pre> <code class="hljs swift">#define <span class="hljs-type"><span class="hljs-type">HANDLE_INIT</span></span> ( (<span class="hljs-type"><span class="hljs-type">Handle</span></span>) -<span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-type"><span class="hljs-type">Handle</span></span> h = <span class="hljs-type"><span class="hljs-type">HANDLE_INIT</span></span>; h = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( h != <span class="hljs-type"><span class="hljs-type">HANDLE_INIT</span></span> ) { ... }</code> </pre> <br><p>  To really create a new type in C, which will work with both type checking and function overloading, you need to create a structure: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle__</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *value; } <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle__</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Handle )</span></span></span></span>; Handle h; foo( h ); <span class="hljs-comment"><span class="hljs-comment">// syntax error bar( h ); // ok ``          : ```c struct Handle__ HANDLE_INIT; // call this function upon startup void init_handle() { HANDLE_INIT.value = (void *)-1; } Handle h = HANDLE_INIT; h = func(); if( memcmp( &amp;h , &amp;HANDLE_INIT , sizeof( Handle ) ) != 0 ) { ... }</span></span></code> </pre> <br><p>  D also has powerful metaprogramming capabilities that allow you to implement typedef yourself and connect from the library: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.typecons; alias Handle = Typedef!( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Handle )</span></span></span></span>; Handle h; foo( h ); <span class="hljs-comment"><span class="hljs-comment">// syntax error bar( h ); // ok</span></span></code> </pre> <br><p>  The second parameter of the Typedef template can specify the default value, which will fall into the standard property of all types - init: </p><br><pre> <code class="hljs swift">alias <span class="hljs-type"><span class="hljs-type">Handle</span></span> = <span class="hljs-type"><span class="hljs-type">Typedef!</span></span>( void* , cast( void* ) -<span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-type"><span class="hljs-type">Handle</span></span> h; h = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( h != <span class="hljs-type"><span class="hljs-type">Handle</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span> ) { ... }</code> </pre> <br><h1 id="sravnenie-struktur">  Comparison of structures </h1><br><p>  In C, there is no simple way to compare two structures, so you have to use a comparison of memory ranges: </p><br><pre> <code class="hljs rust">#include &lt;string.h&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span> x , y; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( memcmp( &amp;x , &amp;y , <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span> ) ) == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { ... }</code> </pre> <br><p>  Lack of type checking is not the most serious problem with this code.  The fact is that the structure fields are stored aligned to the boundaries of the machine word for performance reasons, but the C compiler does not guarantee that there will be no garbage left between the fields that were previously stored in the same data memory, which will result in identical structures would be recognized as different. </p><br><p>  In D, you simply compare the values, and the compiler takes care of everything (in D, memory is always initialized to zero by default, so under the hood you just use a quick comparison of memory ranges): </p><br><pre> <code class="hljs objectivec">A x , y; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x == y ) { ... }</code> </pre> <br><h1 id="sravnenie-strok">  String comparison </h1><br><p>  In C, a special function is used that sequentially compares bytes to the zero byte, with which all lines end: </p><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>[] = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strcmp( <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> , <span class="hljs-string"><span class="hljs-string">"betty"</span></span> ) == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">// do strings match? ... }</span></span></code> </pre> <br><p>  In D, you simply use the standard comparison operator: </p><br><pre> <code class="hljs axapta">string <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> == <span class="hljs-string"><span class="hljs-string">"betty"</span></span> ) { ... }</code> </pre> <br><p>  A string in D is nothing more than an array of characters in front of which its length is stored, which allows you to compare strings with much greater efficiency by comparing memory ranges.  Moreover D supports row relation operations: </p><br><pre> <code class="hljs axapta">string <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> &lt; <span class="hljs-string"><span class="hljs-string">"betty"</span></span> ) { ... }</code> </pre> <br><h1 id="sortirovka-massivov">  Sorting arrays </h1><br><p>  Although many C programmers bicyclic sorting from time to time, the right way is to use the library function qsort (): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p1 , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p2 )</span></span></span><span class="hljs-function"> </span></span>{ type *t1 = (type *) p1; type *t2 = (type *) p2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *t1 - *t2; } type <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; ... qsort( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> ) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] ), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] ), compare );</code> </pre> <br><p>  Unfortunately, the compare () function must be explicitly declared and be applicable to sortable types. </p><br><p>  D has a powerful library of algorithms that works with both built-in and custom types: </p><br><pre> <code class="hljs lua">import std.algorithm; <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>[] array; ... <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>( array ); // <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-place array.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>!<span class="hljs-string"><span class="hljs-string">"a&gt;b"</span></span> // using custom compare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array.sort</span></span></span><span class="hljs-function">!</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ( a , b )</span></span></span></span> =&gt; ( a &gt; b ) ) // same as above</code> </pre> <br><h1 id="strokovye-literaly">  String literals </h1><br><p>  C does not support multi-line string constants, however, using string escaping can be used to achieve their similarity: </p><br><pre> <code class="hljs tex">"This text <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>spans<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>multiple<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>lines<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>"</code> </pre> <br><p>  In D, only quotation marks need to be escaped, which allows you to insert text into the source code almost as it is: </p><br><pre> <code class="hljs pgsql">"This text \"spans\" multiple lines "</code> </pre> <br><h1 id="obhod-struktur-dannyh">  Crawling data structures </h1><br><p>  Consider a simple search function for strings in a binary tree.  In C, we are forced to create the auxiliary function membersearchx, which is used to directly traverse the tree.  So that she not only went, but did something useful, we give her a link to the context in the form of a special Paramblock structure: </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *id; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> *left; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> *right; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Paramblock</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *id; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> *sm; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void membersearchx( <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Paramblock</span></span></span></span> *p , <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> *s ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( s ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strcmp( p-&gt;id , s-&gt;id ) == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;sm ) error( <span class="hljs-string"><span class="hljs-string">"ambiguous member %s\n"</span></span> , p-&gt;id ); p-&gt;sm = s; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s-&gt;left ) { membersearchx(p,s-&gt;left); } s = s-&gt;right; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span></span> *symbol_membersearch( Symbol *table[] , int tablemax , <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *id ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Paramblock</span></span></span></span> pb; int i; pb.id = id; pb.sm = NULL; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; tablemax ; i++ ) { membersearchx( pb , table[i] ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pb.sm; }</code> </pre> <br><p>  In D, everything is much simpler - it is enough to declare an auxiliary function inside the implemented one, and the first will get access to the second variables, so we don‚Äôt have to pass an additional context into it through parameters: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Symbol { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>; Symbol left; Symbol right; } Symbol symbol_membersearch( Symbol[] table , <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ) { Symbol sm; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> membersearchx( Symbol s ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( s ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> == s.id ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sm ) error( <span class="hljs-string"><span class="hljs-string">"ambiguous member %s\n"</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ); sm = s; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s.left ) { membersearchx(s.left); } s = s.right; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; table.length ; i++ ) { membersearchx( table[i] ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sm; }</code> </pre> <br><h1 id="dinamicheskie-zamykaniya">  Dynamic closures </h1><br><p>  Consider a simple container type.  To be reusable, it needs to be able to apply some third-party code to each element.  In C, this is implemented by passing a function reference, which is called with each element as a parameter.  In most cases, in addition, it needs to transmit some context with the state.  For example, let's pass a function that calculates the maximum value of numbers from the list: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params"> , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dim , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*fp) ( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ) )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; dim ; i++ ) { fp( p , <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] ); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp_max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *pmax = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *) p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i &gt; *pmax ) { *pmax = i; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct Collection *c )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = INT_MIN; apply( &amp;max , c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> ) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] ) , comp_max ); }</code> </pre> <br><p>  In D, you can pass a so-called delegate ‚Äî a function bound to some context.  When you pass somewhere a reference to a function that depends on the context in which it is declared, it is actually the delegate that is passed. </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delegate( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ) fp )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>.length ; i++ ) { fp( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Collection c )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.min; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp_max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i &gt; max ) max = i; } c.apply( &amp;comp_max ); }</code> </pre> <br><p>  Or the option is simpler, with an anonymous delegate: </p><br><pre> <code class="hljs swift">void <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Collection </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">c</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span> { int <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = int.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.apply( ( int i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i &gt; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = i; } ); }</code> </pre> <br><h1 id="peremennoe-chislo-argumentov">  Variable number of arguments </h1><br><p>  A simple example of how to write a function in C that summarizes all the arguments passed to it, no matter how many: </p><br><pre> <code class="hljs vbscript">#include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> sum( <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> , ... ) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; va_list ap; va_start( ap , <span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> ; i++) { s += va_arg( ap , <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ); } va_end( ap ); return s; } <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i; i = sum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span> ); printf( <span class="hljs-string"><span class="hljs-string">"sum = %d\n"</span></span> , i ); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  As we see, we had to explicitly indicate in the call how many parameters we are going to pass to the function, which is not only redundant from the programmer‚Äôs point of view, but also a potential source of subtle bugs.  Well, where without the traditional problem - the check of the types transferred to the function lies entirely on the programmer‚Äôs conscience. </p><br><p>  In D, there is a special "..." construct that allows you to take several parameters as a single typed array: </p><br><pre> <code class="hljs perl">import std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ... ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> += <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = sum( <span class="hljs-number"><span class="hljs-number">8</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span> ); writefln( <span class="hljs-string"><span class="hljs-string">"sum = %d"</span></span>, i ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Conversely, you can pass an array to a function that accepts a variable number of parameters: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] ints = [ <span class="hljs-number"><span class="hljs-number">8</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = sum( ints ); writefln( <span class="hljs-string"><span class="hljs-string">"sum = %d"</span></span>, i ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  In this article, we looked at the predominantly low-level capabilities of the D language, in many respects being a small evolutionary step relative to the C language.  Stay in touch. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/276227/">https://habr.com/ru/post/276227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276213/index.html">OpenSSL eliminates a dangerous vulnerability that allowed an attacker to decrypt HTTPS traffic</a></li>
<li><a href="../276217/index.html">What actually virtual memory can do</a></li>
<li><a href="../276219/index.html">Researchers have found many critical vulnerabilities in payment protocols</a></li>
<li><a href="../276221/index.html">Typescript 1.8: a lot of new and useful</a></li>
<li><a href="../276223/index.html">UX as Kung Fu (a guide for trolling and staffing adjustments)</a></li>
<li><a href="../276229/index.html">Greetings from FOSDEM 2016</a></li>
<li><a href="../276235/index.html">How we stopped being afraid of UI tickets</a></li>
<li><a href="../276237/index.html">Analytics Instagram and GAE</a></li>
<li><a href="../276239/index.html">TotalView extends status monitoring for IP PBX 3CX Phone System</a></li>
<li><a href="../276247/index.html">Working with JSON in Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>