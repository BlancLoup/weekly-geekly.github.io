<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pending Ext JS 4: Data Package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: Your attention is invited to the second article from the series ‚ÄúWaiting for Ext JS 4‚Äù. In the previous article , the Ext JS deve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pending Ext JS 4: Data Package</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: Your attention is invited to the second article from the series ‚ÄúWaiting for Ext JS 4‚Äù.</i>  <i>In the <a href="http://habrahabr.ru/blogs/extjs/112802/">previous article</a> , the Ext JS developers talked about the new class system.</i> <br><br>  The data package is responsible for receiving, decoding, and using information in your application.  It is one of those parts of the library that had the most improvements and additions. <br><br>  The package has been completely rewritten for the fourth branch of the framework, but the overall concept has not changed since the previous versions.  Today we will learn more about this technology and look at its capabilities. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What's new </h4><br>  The data package in Ext JS 4 consists of 43 classes, but three of them are especially important in comparison with the others - these are <i>Model</i> (Model), <i>Storage</i> (Store) and <i>Proxy</i> (Proxy).  They are used in almost every application with satellite classes. <br><br><img src="https://habrastorage.org/storage/9b13f485/8c18dcb1/27373d2e/770d119c.png"><br><br><h4>  Models and Storages </h4><br><br>  The basic element of the package is the Ext.data.Model class, which is responsible for working with the model.  A model is a set of certain data in an application ‚Äî for example, in an electronic store there may be models for Users (Users), Products (Products) and Orders (Orders). <br><br>  In the most simplified version, the Model is a set of fields and their values.  Anyone who worked with Ext JS 3 probably used the Ext.data.Record class, the predecessor of Ext.data.Model.  Let's see how we create the model now: <br><br><pre><code class="hljs pgsql">Ext.regModel(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, { fields: [ {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-string"><span class="hljs-string">'int'</span></span>}, {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>} ] });</code> </pre> <br><br>  Typically, Models are used in conjunction with Storages ‚Äî sets of Model instances.  Declaring the Storage and loading data into it is simple: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ext</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.data</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Store</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">model</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, proxy: { type: <span class="hljs-string"><span class="hljs-string">'ajax'</span></span>, url : <span class="hljs-string"><span class="hljs-string">'users.json'</span></span>, reader: <span class="hljs-string"><span class="hljs-string">'json'</span></span> }, <span class="hljs-selector-tag"><span class="hljs-selector-tag">autoLoad</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span> });</code> </pre> <br><br>  That's all that should be done in order to download a set of instances of the Users model from the 'users.json' address.  We set up our Storage using AjaxProxy to read the data at the specified address and the Ext.data.Reader class for transcoding data.  In our case, the server returns a response in the JSON format, so we prepared the JsonReader to read the response. <br><br>  With the help of Storage you can sort, filter and group data both locally and remotely.  In the fourth version of Ext JS, there is no separate GroupingStore class, since the standard Storage is suitable for multiple sorting, filtering and grouping of records: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ext</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.data</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Store</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">model</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, sorters: [<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'id'</span></span>], filters: { property: <span class="hljs-string"><span class="hljs-string">'name'</span></span>, value : <span class="hljs-string"><span class="hljs-string">'Ed'</span></span> }, <span class="hljs-selector-tag"><span class="hljs-selector-tag">groupers</span></span>: { <span class="hljs-attribute"><span class="hljs-attribute">property </span></span>: <span class="hljs-string"><span class="hljs-string">'age'</span></span>, direction: <span class="hljs-string"><span class="hljs-string">'ASC'</span></span> } });</code> </pre> <br><br>  In the Storage we just created, the data will be sorted first by name (name field), and then by id field;  the records will be filtered so that only Users with the name 'Ed' would remain and are grouped by age (the age field).  If required, you can easily change the sorting, filtering or grouping options at any time using the Store API. <br><br><h4>  Proxy </h4><br>  Above, we saw how the Repository uses Proxy to load data and how Proxy can be configured to use Reader classes to parse the server‚Äôs response.  Compared with the third version, there is one structural change in Ext JS 4: The storage no longer contains references to the Reader and Writer classes, which are transferred to Proxy.  This approach provides us with an incredible advantage - the Proxy can now be specified directly in the Model: <br><br><pre> <code class="hljs pgsql">Ext.regModel(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, { fields: [<span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'age'</span></span>], proxy: { <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-string"><span class="hljs-string">'rest'</span></span>, url : <span class="hljs-string"><span class="hljs-string">'/users'</span></span>, reader: { <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-string"><span class="hljs-string">'json'</span></span>, root: <span class="hljs-string"><span class="hljs-string">'users'</span></span> } } }); //   <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Ext.data.Store({ model: <span class="hljs-string"><span class="hljs-string">'User'</span></span> });</code> </pre><br><br>  We have double winnings: firstly, it is very likely that every Vault that works with the Users model equally loads data - accordingly, we will not have to duplicate the Proxy descriptions for the Vaults.  Secondly, we can now load and save an instance of a model without a repository: <br><br><pre> <code class="hljs pgsql">//     (<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>) var <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = Ext.getModel(<span class="hljs-string"><span class="hljs-string">'User'</span></span>); var ed = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>({ <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Ed Spencer'</span></span>, age : <span class="hljs-number"><span class="hljs-number">25</span></span> }); //    ,      //       - RestProxy,   //  POST       /users ed.save({ success: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(ed) { console.log("Saved Ed! His ID is "+ ed.getId()); } }); //  <span class="hljs-number"><span class="hljs-number">123</span></span>  -    (   <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span>- /users/<span class="hljs-number"><span class="hljs-number">123</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(<span class="hljs-number"><span class="hljs-number">123</span></span>, { success: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) { console.log("Loaded user 123: " + <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>)); } });</code> </pre><br><br>  We also bring to your attention several new Proxy types that use the features of HTML 5 - LocalStorageProxy and SessionStorageProxy.  Although older browsers do not support the HTML 5 innovations, new Proxies are so useful that many applications will benefit from their use.  Even if we do not have a Proxy that meets your requirements, then you can simply create your own. <br><br><h4>  Connections </h4><br>  Proxy is not the only new feature added to Models.  You can now define relationships between Models using the new Associations API.  Most applications work with a serious number of different Models, and Models are usually interconnected at the level of applied logic.  A blog platform can have models for Users (Users), Posts (Posts) and Comments (Comments).  Each User publishes Records, and Record receives Comments.  We can describe the relationships between the models as follows: <br><br><pre> <code class="hljs cs">Ext.regModel(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, { fields: [<span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>], hasMany: <span class="hljs-string"><span class="hljs-string">'Posts'</span></span> }); Ext.regModel(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>, { fields: [<span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'user_id'</span></span>, <span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'body'</span></span>], belongsTo: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, hasMany: <span class="hljs-string"><span class="hljs-string">'Comments'</span></span> }); Ext.regModel(<span class="hljs-string"><span class="hljs-string">'Comment'</span></span>, { fields: [<span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'post_id'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>], belongsTo: <span class="hljs-string"><span class="hljs-string">'Post'</span></span> });</code> </pre> <br><br>  The task of describing relationships between different models is not too complicated.  Each model can contain descriptions of any number of links with other models, and the models themselves can be declared in any order.  After receiving an instance of the model, we can track the associated data - for example, if we want to receive a log of all Comments to the Records that a certain User left, then we can use the following construction: <br><br><pre> <code class="hljs pgsql">//   ID <span class="hljs-number"><span class="hljs-number">123</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(<span class="hljs-number"><span class="hljs-number">123</span></span>, { success: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) { console.log("User: " + <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.posts().<span class="hljs-keyword"><span class="hljs-keyword">each</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(post) { console.log("Comments for post: " + post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'title'</span></span>)); post.comments().<span class="hljs-keyword"><span class="hljs-keyword">each</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) { console.log(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'message'</span></span>)); }); }); } });</code> </pre><br><br>  Each of the many-to-one relationships (hasMany) turns into a new function that is added to the Model.  We indicate that each User has many Records.  This relationship is described in the user.posts () function, which we met in the previous code snippet.  Calling this function will return the Vault configured to work with the Records model.  In turn, the Records model has a comments () function, because a many-to-one relationship with the Comments model is set. <br><br>  Perhaps you were surprised by the fact that we set the 'success' handler to call User.load, but do not do this while accessing the User‚Äôs posts and comments.  It is believed that all data is loaded asynchronously from a remote server.  This fact implies the use of special success-handlers that are automatically called at the time of the final and successful data loading - as a function described above. <br><br><h4>  Loading related data </h4><br>  The library can automatically recognize and process related data in one request, based on the relationships described between the models.  Instead of first requesting data for the User, then about the Record, and another request for each Comment, we can return all the necessary information in one server response: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> name: <span class="hljs-string"><span class="hljs-string">'Ed'</span></span>, posts: [ { id : <span class="hljs-number"><span class="hljs-number">12</span></span>, title: <span class="hljs-string"><span class="hljs-string">'All about data in Ext JS 4'</span></span>, body : <span class="hljs-string"><span class="hljs-string">'One of the areas that has seen the most improvement in Ext JS 4...'</span></span>, comments: [ { id: <span class="hljs-number"><span class="hljs-number">123</span></span>, name: <span class="hljs-string"><span class="hljs-string">'S Jobs'</span></span>, message: <span class="hljs-string"><span class="hljs-string">'One more thing'</span></span> } ] } ] }</code> </pre> <br><br>  You can easily configure the Proxy model to receive data from any source, and Reader-classes will help to cope with the most intricate response formats.  Starting with Ext JS 3, Models and Storages are widely used by components inside the framework, especially Tables (Grids), Trees (Tress) and Forms. <br><br><h4>  Demonstration of opportunities </h4><br>  We have prepared for you a small <a href="http://dev.sencha.com/deploy/DataDemo/index.html">online demonstration</a> .  This application uses the same Models that were described in the article, but the code processes the test data.  You can also <a href="">download a demo with one archive</a> and experiment on your own.  The library itself is now in beta status, so errors can sometimes occur, but in general the data processing package is fairly stable. <br><br>  To find out more news from the world of Sencha Touch and Ext JS, I suggest you <a href="http://www.sencha.com/blog/2011/01/21/countdown-to-ext-js-4-data-package/">subscribe to our monthly newsletter</a> , which usually contains articles that you will not find anywhere else (even in our blog). </div><p>Source: <a href="https://habr.com/ru/post/113018/">https://habr.com/ru/post/113018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113011/index.html">Can HTML5 and Flash get along?</a></li>
<li><a href="../113013/index.html">Wheretheladies.at - find your love</a></li>
<li><a href="../113015/index.html">What to feed AI (end)</a></li>
<li><a href="../113016/index.html">Fon. Results of 2010</a></li>
<li><a href="../113017/index.html">A small study of spam sms</a></li>
<li><a href="../113019/index.html">Amazon will launch its own video service soon.</a></li>
<li><a href="../113020/index.html">Mamdani algorithm in fuzzy inference systems</a></li>
<li><a href="../113022/index.html">Programming and entrepreneurial fees Imagine Cup</a></li>
<li><a href="../113025/index.html">IBM celebrates 100 years of participation in technical progress.</a></li>
<li><a href="../113026/index.html">Data generation using C ++ templates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>