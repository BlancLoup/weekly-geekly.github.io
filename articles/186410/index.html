<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Evidence based planning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's note: the original article was written in 2007, however, in my opinion, it still remains relevant today. 
 Software developers do not lik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Evidence based planning</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Translator's note: the <a href="http://www.joelonsoftware.com/items/2007/10/26.html">original article</a> was written in 2007, however, in my opinion, it still remains relevant today. </blockquote><br>  Software developers do not like to plan work.  Usually they try to completely give it up  ‚ÄúI will finish when I finish!‚Äù, They say, expecting that this bold and cheerful act will cause approval from the boss, and planning will be successfully forgotten. <br><br>  Most of the schedules you meet will be heartless unsubscribes.  Completely forgotten, they are stored in some general directory.  After the release of the product late for a couple of years, a strange guy in whose office, they say, have seen the card index, will bring to discussion the reasons for the failure of the old printout, which everyone will laugh at.  ‚ÄúJust look!  We planned two weeks to rewrite the system from scratch to Ruby! ‚Äù <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage2/ceb/a04/0e1/ceba040e19ab4f8a8d04702ecb1dc879.jpg" align="right"><br>  Just scream!  If you are still afloat. <br><br>  You want to spend your time on things that will bring maximum returns.  And you can not understand what kind of profit you get, not knowing how long the work will take.  When you are forced to choose between an animated clip and an increase in the number of financial functions, it does not hurt to know how long it will take to complete each task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Why developers do not formally plan their activities?  There are two reasons for this.  First, it is a big hemorrhoids.  Secondly, no one believes that the plans will correspond to reality.  Why waste time scheduling, if they still break with reality. <br><br>  Over the past year, we at Fog Creek have developed a system with which even the dirtiest programmers have agreed to work.  And, as far as I can tell, it leads to very accurate schedules.  The system is called "Evidence Planning" or <b><abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr></b> .  The approach boils down to the fact that, based on the analysis of statistics of completed work, <i>evidence is</i> collected, which is then used to build a plan for the future.  As a result, you get not just the release date of the product, but also the confidence curve of the distribution of the probabilities of completing the work at any given time.  It looks like this. <br><br><img src="https://habrastorage.org/storage2/489/9d1/1cd/4899d11cd5fef518fe9c221c3efbf690.png"><br><br>  The steeper the curve, the more realistic the specific completion date of the project. <br>  Here is how it is done. <br><br><h4>  1. Separate ... </h4><br>  When I see a schedule, the individual works of which are measured in days or even weeks, I understand that there will be no sense from it.  It is necessary to divide the planned activity into very small tasks, measured by hours.  Maximum 16 hours. <br><br>  This will help you understand what you really want to do.  Write subroutine foo.  Create a dialog box.  Parse the Fizzbott file.  As a result, the time for a common task will be easy to estimate, because you have already written subroutines, created dialog boxes and performed file parsing. <br><br>  When you casually create three-week tasks (for example, ‚ÄúImplement an Ajax photo editor‚Äù), you have no idea what you really want to do.  In detail.  Step by step.  In the meantime, an exact plan of action has not been thought out, and you cannot know how long it will take. <br><br>  Setting a maximum task duration to 16 hours, you force yourself to think about this damn functionality.  But if you get off with a three-week job called ‚ÄúAjax Photo Editor‚Äù, then I have bad news: from this moment you are officially <i>doomed</i> .  Without considering the specific steps of the task, you will inevitably forget about many of them. <br><br><h4>  2. Consider the time spent </h4><br>  It is difficult to get an accurate estimate.  How can you take into account all kinds of incidents that may take you away from work, unpredictable errors, scheduled meetings, and the day of serving Windows service that comes a couple of times a year, when you have to reinstall everything from scratch on your work computer?  Well, how, without knowing all this, you can say for sure how long it will take to complete a specific task? <br><br>  In fact, no way. <br><br>  Therefore, keep a time sheet.  Keep track of how long you work on each task.  So that you can then look back and calculate how much time it took compared to the initial estimate.  For each developer, you need to collect data like this <br><br><img src="https://habrastorage.org/storage2/c44/276/07b/c4427607b7a4f1f1da6618799833ca64.png"><br><br>  Each point on the graph is one completed task with an estimated and real execution time.  If we divide the estimate by the real cost, we get the <i>speed</i> : how quickly the task was completed compared to the estimate.  Over time, you will gain speed history for each developer. <br><br><ul><li>  The mythical evaluator, which exists only in your imagination, will always accurately predict the execution time.  His speed history will look like {1, 1, 1, ...} </li><li>  A typical poor appraiser will demonstrate a very large variation in performance, for example {0.1, 0.5, 1.7, 0.2, 1.2, 0.9, 13.0} </li><li>  Most experts, of course, will be wrong, but on the whole their assessment will be good.  Work always requires more time than planned - it is very difficult to take into account the correction of errors, night meetings, coffee breaks and the madman who constantly distracts you.  This typical estimator will show fairly stable speeds, which, however, are less than one.  For example, {0.6, 0.5, 0.6, 0.6, 0.5, 0.6, 0.7, 0.6} </li></ul><br>  As experts gain experience, the quality of their assessments increases.  Therefore, it will be good practice to completely get rid of the accumulated statistics of speeds that are, say, six months older. <br><br>  If, however, a new evaluator comes to your team who does not yet have accumulated data, assume the worst - attribute a false story to it with a large speed variation until he can cope with half a dozen real tasks. <br><br><h4>  3. Model the future </h4><br>  Do not give in to the initial temptation to simply add up the obtained estimates in order to calculate the exact date of product release.  It only sounds right, but in reality is a completely wrong approach.  It is necessary to use the Monte Carlo method to simulate a variety of possible outcomes.  In the process of modeling, you can create hundreds of possible future scenarios.  Each of these outcomes will correspond to one percent probability, as a result you will have the opportunity to build a graph of the probabilities of project completion for each date in the future. <br><br>  To calculate the likely outcome for a given developer, you need to divide each assessment of the task by a <i>randomly selected rate</i> from the statistics of this developer, collected in step 2. For example <br><br><img src="https://habrastorage.org/storage2/eab/0e0/985/eab0e09850702c147176b1ab01723594.png"><br><br>  Do this a hundred times, each "Total" corresponds to one percent probability, which will allow you to calculate the probability that the project will be completed on a specific date. <br><br>  See what happens <br><br><ul><li>  For the case of the mythical ideal appraiser, all speeds are equal to one.  Dividing by speed, which is always equal to one, does not change anything.  Thus, all rounds of simulation give the same completion date, and this date has one hundred percent probability.  Just like in a fairy tale! </li><li>  The ratings of a bad expert are very scattered.  This can be both 0.1 and 13.0.  Each stage of the simulation leads to a very different result from the others.  The probability distribution curve will be extremely flat, showing equal chances to finish tomorrow or in the distant future.  By the way, this is quite useful information - it tells you that you can not be sure of the designated release date of the product. </li><li> The average typical evaluator will give a very close set of speeds to each other, for example, {0.6, 0.5, 0.6, 0.6, 0.5, 0.6, 0.7, 0.6}.  By dividing by these speeds, you will increase the time allotted for performing tasks, for example, an 8-hour task at one stage of modeling can turn into a 13-hour one, while during another it will take 15 hours.  This compensates for the ineradicable optimism of evaluators.  Moreover, the compensation will be made <i>accurately</i> , based on the <i>optimism</i> that is inherent <i>to this developer, proven and time-tested</i> .  And since the real speeds are quite close in values ‚Äã‚Äã(about 0.6), starting each simulation round, you will get similar numbers, and as a result you will have a fairly narrow range of possible project completion dates. </li></ul><br>  For each Monte Carlo simulation round, of course, you have to convert hourly information into calendar days, i.e.  It is necessary to take into account the work schedule of each programmer, holidays, weekends, etc.  You also have to accept the fact that each iteration of the project will be completed only when the most recent developer finishes his work - only this will mean the completion of the work of the whole team.  Such calculations need to be done very scrupulously, but, fortunately, scrupulous calculations - this is exactly what computers do well. <br><br><h5>  Obsessive compulsive disorder not required </h5><br>  What to do with the endless stories of his boss about his fishing trips?  Or with sales meetings that force you to attend for no apparent reason?  Coffee breaks?  Spent half the day to help the newcomer in setting up the workplace? <br><br>  When Brett and I developed this technique for Fog Creek, we were greatly disturbed by things that were a waste of time, but at the same time could not be predicted in advance.  Sometimes they took more time than direct coding.  Should this be taken into account in any way and be included in the task schedule? <br><br><img src="https://habrastorage.org/storage2/8e0/624/d8e/8e0624d8ebe21443bf749224869bc734.png"><br><br>  You can, of course, do just that if you want.  And evidence-based planning will continue to work. <br><br>  <i>But you do not have to</i> . <br><br>  It turns out that <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr> works great even in cases when you simply add the lost time to the time of the current task.  As strange as it may sound, the use of <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">PD</abbr> in this case will give even the best results. <br><br>  Consider a small example.  To make it as simple as possible, I‚Äôll come up with a very predictable programmer John, all of whose work boils down to writing single-line methods for accessing fields, which are often necessary when using some programming languages.  All he does every day is <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setWidth</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _width} { width = _width; }</span></span></span></span></code> </pre> <br>  I know, I know - this is an incredibly stupid example, but surely you have met programmers who are doing something similar. <br><br>  Whatever the case, the implementation of each access method takes him two hours.  Those.  his estimates of the time to complete the tasks are as follows: <br><br>  {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ...} <br><img src="https://habrastorage.org/storage2/d53/ceb/e20/d53cebe2033dc08f74a79fb9c48bfcee.jpg" align="right"><br>  Also this poor guy has a boss who constantly interrupts him with two-hour conversations about catching marlin.  John, of course, could add the task ‚ÄúTedious conversation about marlin‚Äù to his schedule, but this would be politically short-sighted.  Instead, John simply attributes the lost time to the current task.  As a result, its costs are as follows: <br><br>  {2, 2, 2, 2, 4, 2, 2, 2, 2, 4, 2, ...} <br><br>  and accordingly speed <br><br>  {1, 1, 1, 1, 0.5, 1, 1, 1, 1, 0.5, 1, ...} <br><br>  Now think about what is happening.  In a Monte Carlo simulation, the probability that each assessment will be divided by 0.5 exactly corresponds to the probability that John‚Äôs work will be interrupted by the boss.  Thus, the <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP will</abbr> produce the correct schedule! <br><br>  In fact, the <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr> is likely to take into account the interruptions of work much better than the most meticulous developer does.  <i>That‚Äôs why it works so well</i> .  This is how I explain it to people.  When a programmer is interrupted, he is faced with a choice. <br><br><ol><li>  make a big fuss, bringing all the interruptions to his work schedule, so that the management can see how much time he has to spend on fishing or </li><li>  make a lot of noise, refusing to make it to the work schedule, with the result that the current task will ‚Äúhang‚Äù in the air, and all because there is nothing to correct its <i>ideally accurate</i> estimates, only because of a silly conversation about fishing, to which he did <i>not</i> even <i>bother to invite</i> ... </li></ol><br>  ... and in any case, the <i><abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr> will give similar, completely accurate results</i> , regardless of what type of passive-aggressive developer you are dealing with. <br><br><h4>  4. Actively manage your project </h4><br>  Once you‚Äôve set everything up, take over the active management of the project to deliver it on time.  For example, sorting tasks according to their priority will help you plan your work in the future, allowing you to reject low priority functionality if necessary. <br><br><img src="https://habrastorage.org/storage2/4e5/af1/4b8/4e5af14b81eae7b0b94914a6f84cfd66.png"><br><br>  You can also see the distribution of possible completion dates for <i>each developer</i> : <br><br><img src="https://habrastorage.org/storage2/06e/8d1/4a0/06e8d14a062ae8b0a6cd83f342a8a6e0.png"><br><br>  Some developers (like Milton (Milton) in this figure) can be a source of problems due to the fact that their ending dates are so inaccurate: they need to learn to estimate costs for tasks better.  Other developers (like Jane) have an exact completion date, which, however, delays the delivery of the project - you need to think about transferring some of their tasks to other employees.  Some developers (me! Hurray!) Are not at all on the critical path - they can be left alone. <br><br><h5>  Project boundaries </h5><br>  <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr> works great when you have everything planned up to the smallest detail.  However, you probably will have to implement some unplanned things.  New ideas appear, sales managers promise things that are not there, and someone from the board of directors comes up with a bright idea to implement an application for a golf mobile with GPS support and the ability to observe the cardiogram of golfers moving across the field.  All this leads to delays that could not be predicted during the preparation of the original plan. <br><br>  Ideally, special buffers should be provided for all of this.  And really - add buffers to your plans for <br><br><ol><li>  New ideas on functionality </li><li>  Competitive response </li><li>  Integration (combining code written by different developers into one system) </li><li>  Time to debug </li><li>  Usability testing (and use of test results in the final product) </li><li>  Beta testing </li></ol><br>  Thus, when the time comes to implement an unplanned function, you can always cut a piece of the suitable buffer and use it for work. <br><br>  But what to do if a lot of new functionality was added, and all buffers are used?  Well, in this case, the date of delivery of the project, obtained using the <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">DP</abbr> , is shifted.  You should take a snapshot of the probability distribution for the completion date at the end of each working day to be able to track changes over time: <br><br><img src="https://habrastorage.org/storage2/9ba/62a/418/9ba62a418ec9553ce1cd1b8a6440727f.png"><br><br>  On the X axis, mark the date of calculation, Y - the date of completion of the project.  The figure shows three curves: the upper corresponds to the results with a 95% probability, the average is 50% and the lower is 5%.  The closer these curves are to each other, the narrower the range of possible project dates we have. <br><br>  If the completion date is constantly postponed (ascending curves), you are in trouble.  If everything is postponed more than a day a day, you add a new job faster than you finish the existing one - the project will never be completed.  If you see that the probability distribution becomes more dense (the curves converge), this means that you actually go out on a given date. <br><br><h5>  By the way </h5><br>  Here are a few things that I realized during the years of project planning. <br><br>  <b>1. Only the programmer who performs the work can estimate the time needed for it</b> .  Any system in which the management schedules tasks, not allowing developers to it, is doomed to failure.  Only a programmer who will implement a specific functionality can know what steps need to be taken to achieve the goal. <br>  <b>2. Correct errors as they are detected, and assign the elapsed time to the original task</b> .  You cannot plan to fix every error in advance, because you do not know what problems you will face.  If an error is found in the new code, attribute the time spent on correcting it to the original task, which was implemented incorrectly.  This will help the <abbr title="Evidence Based Planning (EBS - Evidence Based Scheduling)">PD to</abbr> predict the time to get <i>fully debugged,</i> not just <i>working</i> code. <br><img src="https://habrastorage.org/storage2/a66/bb1/a28/a66bb1a2825083bedbbf7a591870214d.jpg" align="right"><br>  <b>3. Do not allow managers to put pressure on developers to reduce estimates of terms.</b>  Often, insufficiently experienced software project managers think that they can ‚Äúmotivate‚Äù programmers to work faster, giving them good, ‚Äútight‚Äù (incredibly short) plans for completing tasks.  I think this type of motivation is completely brainless.  When I do not fit into the schedule, I feel doomed, depressed and devoid of any motivation.  When I go ahead of the official plan, I am inspired and productive.  Planning is not a place for psychological games. <br><br>  Why do managers do it? <br><br>  At the beginning of the project, technical managers meet with businessmen, getting a list of tasks that <i>they think</i> will take about three months, but in fact 12. When you decide to write a program without thinking through all the stages of its creation, it always seems that take n time, but in reality you have to spend more than 4n.  When you make a real work schedule, you add all the tasks to it and you understand that the project will take much longer than originally thought.  This upsets businessmen. <br><br>  Incompetent problem-solving managers are trying to find ways to make people work faster.  This approach has few points of contact with reality.  You can try to hire additional staff, but it will take time to pick up speed, during which it will work with 50 percent efficiency, simultaneously reducing the productivity of employees forced to train them. <br><br>  You can <i>temporarily</i> squeeze out a 10 percent increase in the speed of writing a raw code at the cost of a complete professional burnout of staff.  A small achievement, which rather resembles the consumption of its own stock of seeds.  Of course, when you force people to recycle, debugging time <i>doubles</i> and projects that lag behind are even more late.  From karma not to leave. <br><br>  You can‚Äôt get 4n from n, you can‚Äôt, and if you think you succeeded, send me a ticker of your company, and I‚Äôll cut it. <br><br><blockquote>  interpretation of the statement about the ticker from <a href="http://habrahabr.ru/users/vmarunin/" class="user_link">vmarunin</a> <br>  "... send me a ticker so that I can short it" <br>  Shorting (opening a short position) means borrowing stocks, selling them, and when they fall in price to buy stocks and return the debt. <br>  In other words, Joel is ready to put money on the fact that if a company can shorten the development period from 4n to n, then it will soon fall on the exchange. <br></blockquote><br><br>  <b>4. Schedule - a box with wooden blocks</b> .  Suppose you have several wooden blocks that you cannot place in a box, then there are two options: take a larger box or get rid of several blocks.  If you want to deliver the project in 6 months, and according to the work plan, it turns out to be 12, you need to either postpone the release date, or abandon some functions.  You can not just take and reduce the wooden block. <br><br>  I would like to especially note that one of the main advantages of realistic schedules is that it forces you to delete functions.  Why is it good? <br><br>  Imagine that you come up with two functions.  The first, very useful, can make your product really beautiful.  The other is extremely simple, and programmers can‚Äôt wait until they can encode it (‚ÄùLook! &lt;Blink&gt;!‚Äù), But it doesn‚Äôt have any real benefit. <br><img src="https://habrastorage.org/storage2/8bf/8e5/2b6/8bf8e52b6c794f12bfe90fdc88151274.jpg" align="right"><br>  If you do not make a project plan, programmers implement a simple and interesting function in the first place.  Then they will break the deadlines, and you will have no other conclusion than to move the date of delivery, in order to have time to realize a useful and important function. <br><br>  If the schedule is made before the start of implementation, you will immediately realize that you will have to sacrifice some functionality and get rid of a simple and fun task, having decided to do only useful and important.  By forcing yourself to discard some features of the application in advance, you are helping to create a better product with a better set of functions that will sell better. <br><br>  When I worked on Excel 5, our list of planned functionality was huge, which foreshadowed a very serious delay in the release schedule.  ‚ÄúMy God,‚Äù we thought, ‚ÄúThese are all very important things.  How are we going to live without a macro editing wizard? ‚Äù <br><br>  As it turned out, there was no choice, and we cut out everything except the things absolutely necessary for the implementation of the project.  This decision did not suit anyone.  In order to somehow calm down, we have convinced ourselves that we are not abandoning the dropped functions completely, but just transfer their implementation to Excel 6. <br><br>  When Excel 5 was nearing completion, Eric Michelman and I started working on the Excel 6 specification. We went through a list of functions that we didn‚Äôt have time to implement within Excel 5. And you know what?  It was one of the most vulgar lists of opportunities you can imagine.  <i>None</i> of the functions listed in it deserved implementation.  The process of truncating the functionality in order to fit into the schedule was the best service to the project that we could provide it.  If this were not done, the implementation of Excel 5 would take twice as long and half consist of useless crap, which would also have to be maintained for compatibility until the end of time. <br><br><h5>  Conclusion </h5><br>  Using evidence-based planning is fairly simple ‚Äî it will take you a day or two to prepare detailed assessments before each iteration, and a few more seconds each day to record when you started working on a specific task.  The benefit is huge: realistic project plans. <br><br>  A realistic work schedule is the key to creating good software.  It pushes you to implement the best features in the first place and helps you make the right decisions about what to include in the final assembly.  This will make your product better, your boss happier, delight the customer and, best of all, allow you to go home at exactly 5:00 pm. <br><img src="https://habrastorage.org/storage2/127/83a/4bf/12783a4bf1250a4c3c7bdfbd8ee969e6.jpg"><br><br><blockquote>  Thanks to <a href="http://habrahabr.ru/users/truezemez/" class="user_link">truezemez</a> for helping <a href="http://habrahabr.ru/users/truezemez/" class="user_link">me</a> translate the method name. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/186410/">https://habr.com/ru/post/186410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186392/index.html">Kim Dotcom (Mega, Megaupload) is going to launch a messenger and email protected from wiretapping</a></li>
<li><a href="../186396/index.html">How does the transistor work? Well, very accessible video explanation</a></li>
<li><a href="../186400/index.html">Interview with John Griffith, OpenStack Cinder Project Manager (Block Data Storage)</a></li>
<li><a href="../186402/index.html">OPA Amplifier style</a></li>
<li><a href="../186406/index.html">State and p2p</a></li>
<li><a href="../186412/index.html">Just5 Press Conference & Art. Lebedev Studio, July 17, 16:30 - ask questions!</a></li>
<li><a href="../186416/index.html">Why I do not climb in cryptography</a></li>
<li><a href="../186422/index.html">Social networks in Russia, summer 2013: numbers, trends, forecasts</a></li>
<li><a href="../186424/index.html">The pedal helicopter stayed in the air for 64 seconds</a></li>
<li><a href="../186428/index.html">Active users on VKontakte and Twitter: rating of Russian regions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>