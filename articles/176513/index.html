<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Take control of cryptography in the cloud storage MEGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After the launch of the scandalous MEGA service to some extent, the talk about its security began to wane and subside a little. Today, the service liv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Take control of cryptography in the cloud storage MEGA</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/f5b/2db/72c/f5b2db72c9de0dd1cc3718061439ef93.jpg">  After the launch of the scandalous MEGA service to some extent, the talk about its security began to wane and subside a little.  Today, the service lives its own life and no one even broke it.  Of all the conversations, for some reason, the term ‚ÄúUser Controlled Encryption‚Äù (UCE, or User Controlled Cryptography), which boasts MEGA, was missed.  By the word "missed", I mean the fact that we did not consider all the possibilities that the cryptographic engine running in JavaScript on the client side gives us. <br><br>  Of course, the MEGA service itself by this means only that the encryption keys are not stored on the server, and all <u>their</u> cryptography is performed in the context of the browser.  At the same time, after the launch of the service, there was a lot of talk about the fact that it uses unstable cryptographic algorithms <strike>and that in general everything is bad and we all die and our files are read by the FSB</strike> .  This prompted me to expand the concept of "UCE" and really take control of cryptography, namely, to replace or supplement some mechanisms to ensure the security of the service. <br><br>  In this article, I will partially sort out the magic that occurs in two megabytes of MEGA JavaScript code and show how you can redefine some methods in order to stop worrying and fall in love with cryptography.  As a result, we get a cloud-based file storage service with two-factor authentication and hardware-based encryption of critical information. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  MEGA, UCE and all-all-all </h1>  So, let's start by considering the technologies on which the client side of the service is built, how new users are registered, registered users are authenticated, the password is changed and files are downloaded / downloaded. <br><br><h2>  Javascript </h2>  As you may already know, the entire client part of the service is based on JavaScript, the SHA-256 checksums for all scripts and pages that are loaded by the browser are written in the code for the main page.  The download itself is as follows: all files are checked checksums, after which they are combined into one BLOB, which is given to the browser.  From the source code of js-files, you can see that they were written by different people and sometimes there are funny pearls, such as the effects of copy-paste, meaningless conditions and just weird variables. <br><br> <a href="http://instacod.es/70276"><img src="https://habrastorage.org/storage2/2af/4d9/9ce/2af4d99ce2a8cba221567abf361cd89f.png"></a> <br><br> <a href="http://instacod.es/67689"><img src="https://habrastorage.org/storage2/1a3/95a/e0d/1a395ae0d86e426a5ce2a32e7f42cecb.png"></a> <br><br> <a href="http://instacod.es/70307"><img src="https://habrastorage.org/storage2/86c/dc8/0a5/86cdc80a5be33f29f8b399f6b3880ccc.png"></a> <br><br>  In the process of studying the source code of the site, I also noticed that it is quite actively updated, the developers correct minor errors and optimize the already written code, which is good news.  The code itself is written in a very straightforward manner and without unnecessary cheating in the form of prototypes: the site costs three hundred global variables and more than 8,000 functions.  Understanding the architecture of the site and changing its code was very simple. <br><br>  From third-party frameworks, MEGA uses jQuery (nowhere without it), Ext JS and <a href="http://crypto.stanford.edu/sjcl/">SJCL</a> .  The latter implements a cryptographic core with AES encryption.  SJCL also provides an interesting format for storing keys and other byte arrays: instead of just driving bytes in a regular array, they are ‚Äúcompressed‚Äù into a format called a32.  Its essence is that the contents of any byte array is packed into 32-bit numbers and written into a smaller array.  That is, every 4 bytes of the array are converted into one trivial int.  There are functions in the site code that perform various transformations on the improvised set {a32 array, string, base64 string}. <br><br><h2>  Key information </h2>  Before proceeding to the description of the registration and authentication processes, it is worth considering the information that is to be encrypted, namely: <ul><li>  <b>The master key of the account</b> , which is created randomly at the time of user registration and has a length of 128 bits.  And in principle, the length of all keys used for symmetric encryption is 128 bits. </li><li>  <b>RSA private key</b> : created at the time of registration based on mouse movements and keyboard input.  In this article, I will not focus on asymmetric cryptography, since it is used for sharing access to downloaded files, and my task was to change the process of authentication and encryption of user data. </li><li>  <b>Individual keys of files and files themselves</b> uploaded to the service.  Keys are created randomly when a file is loaded, this key itself is used to encrypt the file data, and a key created based on the individual key of the file and its checksum is used to encrypt the attributes. </li></ul><br><h3>  Closer to the code </h3>  Now I propose to parse the registration and authentication processes, see how the master key is created and how it is encrypted. <br>  I tried to depict these processes on a piece of paper and in order to make you understand the whole essence of madness, I even made this picture: <br><br><img src="https://habrastorage.org/storage2/408/652/388/40865238884a8b9df7548702d35c12c5.png"><br><br><h4>  New User Registration </h4> The registration process itself is quite confusing, after the user has filled out the questionnaire, a powerful handful of functions are called, but we are interested in the <code>api_createuser</code> function: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      - function api_createuser(ctx, invitecode, invitename, uh) { var i; var ssc = Array(4); // session self challenge, will be used to verify password var req, res; if (!ctx.passwordkey) { ctx.passwordkey = Array(4); for (i = 4; i--;) ctx.passwordkey[i] = rand(0x100000000); } if (!u_k) api_create_u_k(); //   - u_k for (i = 4; i--;) ssc[i] = rand(0x100000000); //     if (d) console.log("api_createuser - masterkey: " + u_k + " passwordkey: " + ctx.passwordkey); //  -         ( k) //  ts    ssc     req = { a: 'up', k: a32_to_base64(encrypt_key(new sjcl.cipher.aes(ctx.passwordkey), u_k)), ts: base64urlencode(a32_to_str(ssc) + a32_to_str(encrypt_key(new sjcl.cipher.aes(u_k), ssc))) }; if (invitecode) { req.uh = uh; req.ic = invitecode; req.name = invitename; } if (d) console.log("Storing key: " + req.k); api_req([req], ctx); }</span></span></code> </pre><br>  In this function, we are interested in the following things: <ul><li>  <code>u_k</code> is the master key itself, a global variable.  Array of 4x 32-bit numbers, which is created by the function <code>api_create_uk</code> </li><li>  <code>ssc</code> is just a random array, which is encrypted on the master key, concatenated with its open value and sent to the server.  Later it will be used to verify the master key for authentication. </li><li>  <code>sjcl</code> - AES cryptographic library </li><li>  <code>rand()</code> is a local implementation of a pseudo-random number generator based on RC4 </li><li>  <code>encrypt_key()</code> is the cornerstone function of a symmetric service cryptography.  Receives a key-initialized <code>sjcl</code> object and an array to be encrypted.  The function code is given below and, I hope, needs no explanation. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// encrypt/decrypt 4- or 8-element 32-bit integer array function encrypt_key(cipher, a) { if (a.length == 4) return cipher.encrypt(a); var x = []; for (var i = 0; i &lt; a.length; i += 4) x = x.concat(cipher.encrypt([a[i], a[i + 1], a[i + 2], a[i + 3]])); return x; }</span></span></code> </pre><br>  In the end, after registering on the server are sent: <ul><li>  Master key encrypted on the key derived from the account password </li><li>  A string of the form <code>ssc||encrypt_AES-128(u_k, ssc)</code> </li></ul><br><h4>  User login </h4>  Now you can smoothly go to the authentication process.  In short, it is produced as follows: <ol><li>  User enters login / password </li><li>  If the first stage of authentication is passed, then an encrypted master key and an authentication sequence ( <code>ssc</code> ) created during registration comes from the server </li><li>  The master key is decrypted using the password entered by the user. </li><li>  On the master key, the authentication sequence is decrypted and compared with its open value - this verifies the correctness of the master key and password. </li></ol>  For all of the above, the callback function <code>api_getsid2</code> is <code>api_getsid2</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -      function api_getsid2(res, ctx) { var t, k; var r = false; if (typeof res == 'object') { //  sjcl-aes    var aes = new sjcl.cipher.aes(ctx.passwordkey); //       -... if (typeof res[0].k == 'string') { k = base64_to_a32(res[0].k); if (k.length == 4) { // ...    k = decrypt_key(aes, k); //  - sjcl-aes,  - aes = new sjcl.cipher.aes(k); //    ssc    if (typeof res[0].tsid == 'string') { t = base64urldecode(res[0].tsid); //           //    - ,          if (a32_to_str(encrypt_key(aes, str_to_a32(t.substr(0, 16)))) == t.substr(-16)) r = [k, res[0].tsid]; } //     RSA-,      else if (typeof res[0].csid == 'string') { var t = mpi2b(base64urldecode(res[0].csid)); var privk = a32_to_str(decrypt_key(aes, base64_to_a32(res[0].privk))); var rsa_privk = Array(4); // decompose private key for (var i = 0; i &lt; 4; i++) { var l = ((privk.charCodeAt(0) * 256 + privk.charCodeAt(1) + 7) &gt;&gt; 3) + 2; rsa_privk[i] = mpi2b(privk.substr(0, l)); if (typeof rsa_privk[i] == 'number') break; privk = privk.substr(l); } // check format if (i == 4 &amp;&amp; privk.length &lt; 16) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> check remaining padding for added early wrong password detection likelihood r = [k, base64urlencode(crypto_rsadecrypt(t, rsa_privk).substr(0, 43)), rsa_privk]; } } } } } ctx.result(ctx, r); }</span></span></code> </pre><br>  As a bonus to registration / authentication, you can look at the process of changing the password. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function changepw(currentpw, newpw, ctx) { var pw_aes = new sjcl.cipher.aes(prepare_key_pw(newpw)); api_req([{ a: 'up', currk: a32_to_base64(encrypt_key(new sjcl.cipher.aes(prepare_key_pw(currentpw)), u_k)), k: a32_to_base64(encrypt_key(pw_aes, u_k)), uh: stringhash(u_attr['email'].toLowerCase(), pw_aes) }], ctx); }</span></span></code> </pre><br>  The code for this function speaks for itself: we encrypt the master key on two keys obtained from the old and new passwords, and then send these values ‚Äã‚Äãto the server.  If the current password came up, it is replaced with a new one.  Here I wanted to pay more attention to the <code>prepare_key_pw</code> function, which was implicitly present in all previous operations.  Her task is to convert the string password to a32 array, and then perform the key derivation operation as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// convert user-supplied password array function prepare_key(a) { var i, j, r; var aes = []; var pkey = [0x93C467E3, 0x7DB0C7A4, 0xD1BE3F81, 0x0152CB56]; for (j = 0; j &lt; a.length; j += 4) { key = [0, 0, 0, 0]; for (i = 0; i &lt; 4; i++) if (i + j &lt; a.length) key[i] = a[i + j]; aes.push(new sjcl.cipher.aes(key)); } for (r = 65536; r--;) for (j = 0; j &lt; aes.length; j++) pkey = aes[j].encrypt(pkey); return pkey; }</span></span></code> </pre><br>  This function has caused many complaints, because it is based on a homegrown algorithm.  During the writing of the article, the creators of the service managed to change its code a little, but I did not notice any significant changes here.  Its essence lies in the fact that the transmitted password is encrypted 65,536 times on a constant key in order to obtain an indistinguishable from a random key.  Why the creators of the service did not use existing algorithms (for example, PBKDF2) remains a mystery. <br><br><h2>  Download and Encrypt Files </h2>  In short, this whole process can be represented as follows: <img src="http://habrastorage.org/storage2/a49/da1/ee5/a49da1ee596420333ed6f0810b75453f.jpg"><br><br>  I warn you, a long understanding of this picture is dangerous for the brain, so below I will tell you how it all happens. <br><br>  As I said before, when loading, each file creates its own random key array of 6 32-bit numbers.  The first four elements of this array are used to encrypt the contents of the file, and the last two are used as the initial values ‚Äã‚Äãof the counter, by means of which the checksum of the file is calculated.  This array is stored in the global variable <code>ul_key</code> .  Its contents are stored in the JSON-serialized string <code>ul_KeyNonce</code> . <br><br>  It goes beyond (races) encryption using the Web Worker (if the browser supports this technology) or just inside the main code of the page.  When a file is ready to be sent, to encrypt its attributes (for the moment, attributes are only the file name), a new key is <code>filekey</code> based on <code>ul_key</code> and the checksum of the file.  This key is then encrypted on the master key and sent to the server along with the file attributes.  The functions <code>initupload3</code> and <code>api_completeupload2</code> are responsible for all these actions.  Creating the key <code>filekey</code> occurs in the function <code>ul_chunkcomplete</code> , below I will give part of it. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   :         function initupload3() { // ...  =) //      // ul_key    , // ul_keyNonce   Web Worker    //         ul_key = Array(6); for (i = 6; i--;) ul_key[i] = rand(0x100000000); ul_keyNonce = JSON.stringify(ul_key); ul_macs = []; // ...     ,     ... //  sjcl-aes     ul_key ul_aes = new sjcl.cipher.aes([ul_key[0], ul_key[1], ul_key[2], ul_key[3]]); // ... //    : //    ,    onUploadStart(ul_queue_num); ul_dispatch_chain(); } //       function ul_chunkcomplete(slot,pos,response) { // ... var t = []; // ul_macs -     ,   worker' for (p in ul_macs) t.push(p); //     ,      -   t.sort(function(a,b) { return parseInt(a)-parseInt(b) }); for (var i = 0; i &lt; t.length; i++) t[i] = ul_macs[t[i]]; //  condenseMacs   //  ""       4  var mac = condenseMacs(t,ul_key); ul_settimeout(-1); //             //           var filekey = [ul_key[0]^ul_key[4],ul_key[1]^ul_key[5],ul_key[2]^mac[0]^mac[1],ul_key[3]^mac[2]^mac[3],ul_key[4],ul_key[5],mac[0]^mac[1],mac[2]^mac[3]]; // ... } //   :           function api_completeupload2(ctx, ut) { var p; if (ctx.path &amp;&amp; ctx.path != ctx.n &amp;&amp; (p = ctx.path.indexOf('/')) &gt; 0) { var pc = ctx.path.substr(0, p); ctx.path = ctx.path.substr(p + 1); fm_requestfolderid(ut, pc, ctx); } else { //     ,   ul_key    // ctx.k == filekey a = { n: ctx.n }; if (d) console.log(ctx.k); var ea = enc_attr(a, ctx.k); if (d) console.log(ea); //      -   var req = { a: 'p', t: ut, n: [{ h: ctx.t, t: 0, a: ab_to_base64(ea[0]), //  k: a32_to_base64(encrypt_key(u_k_aes, ctx.k)), // == AES_encrypt(u_k, filekey) fa: ctx.fa }] }; if (ut) { // a target has been supplied: encrypt to all relevant shares var sn = fm_getsharenodes(ut); if (sn.length) { req.cr = crypto_makecr([ctx.k], sn, false); req.cr[1][0] = ctx.t; } } api_req([req], ctx.ctx); } }</span></span></code> </pre><br><h2>  Downloading and decrypting files </h2>  Obviously, these processes should simply be inverse to encrypting the file.  The only thing that may be of interest is getting the key value <code>ul_key</code> from the encrypted <code>filekey</code> value that came from the server. <br><br>  At the time of downloading the file, the browser context already contains an object that stores the decrypted file keys.  Therefore, first it makes sense to consider the process that occurs immediately after the user is authenticated, namely, the download of the file manager.  After the user has been allowed to the service, he naturally wants to get access to his files (suppose that he already had them there).  For this we need to decrypt the keys of the files first, and then their attributes.  The next pack of functions deals with this, of which we are interested in <code>loadfm_callback</code> and <code>process_f_f</code> . <br><br>  In short, the process of obtaining file attributes can be described by the following algorithm: <ol><li>  Wait for the file manager to load ( <code>loadfm_callback</code> ), where to get the JSON with the description of all the downloaded files </li><li>  Create a <code>farray</code> array in which to put an array with information about files </li><li>  Run (recursively) for each file function <code>process_f_f</code> </li><li>  For each file that has a key, decrypt this key and attributes (the <code>crypto_processkey</code> function) and save them back into an array with information about files </li><li>  After that, save the decrypted values ‚Äã‚Äãto the <code>FileStore</code> variable (end of recursion in <code>process_f_f</code> ) </li></ol><br>  Below I will provide excerpts from the code illustrating this algorithm. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// callback  - function loadfm_callback(json, res) { // ... //  JSON     json = json[0]; if (d) console.log(json); if (d) console.log(json); if (json.u) process_u(json.u, false); if (json.ok) process_ok(json.ok); if (json.s) { for (i in json.s) { if (u_sharekeys[json.s[i].h]) { sharingData.push({ id: json.s[i].h + '_' + json.s[i].u, userid: json.s[i].u, folderid: json.s[i].h, rights: json.s[i].r, date: json.s[i].ts }); sharednodes[json.s[i].h] = true; } } } // ...   ... //          farray[fi] = new Object; farray[fi].f = json.f; //   , callback    //        process_f(fi, false, callback); fi++; } //  ,         //   process_f function process_f_f(fid) { //    -       farray if (!farray[fid].f[farray[fid].i]) { if (farray[fid].ap) FileStore.suspendEvents(); //    FileStore FileStore.loadData(farray[fid].mdata, true); if (farray[fid].ap) FileStore.resumeEvents(); if (d) console.log('call reqmissingkeys:'); crypto_reqmissingkeys(); if (farray[fid].callback) farray[fid].callback.fn(farray[fid].callback); return false; } var f = farray[fid].f[farray[fid].i]; f.attrs = fa; if (f.sk) u_sharekeys[fh] = crypto_process_sharekey(fh, f.sk); //        ,    if ((ft !== 2) &amp;&amp; (ft !== 3) &amp;&amp; (ft !== 4) &amp;&amp; (fk)) { crypto_processkey(u_handle, u_k_aes, f); //     u_nodekeys[fh] = f.key; if ((typeof f.name !== 'undefined') &amp;&amp; (fp == InboxID)) InboxCount++; } else { if (fa) { if (!missingkeys[fh]) { missingkeys[fh] = true; newmissingkeys = true; } } fk = ''; f.name = ''; } if (ft == 2) RootID = fh; else if (ft == 3) InboxID = fh; else if (ft == 4) TrashbinID = fh; else if ((ft &lt; 2) || (ft == 5)) { //      } else { //      FileStore farray[fid].mdata.push({ id: fhreplace(/[^az^AZ^0-9^_^-]/g, ""), name: f.name, size: fs, type: filetype(f.name, ft), icon: fileicon(f.name, icontype), parentid: fp, folder: ft, owner: fu, date: f.ts, attrs: f.attrs, key: f.key, r: fr, su: f.su, fa: f.fa, }); if (fp == TrashbinID) trashbinfull = true; if (((ft) &amp;&amp; (farray[fid].ap)) || (fp == InboxID)) refreshtree = true; } farray[fid].i++; //   (,   -    ) timeoutcount++; if (!(timeoutcount &amp; 63)) { //     63  -     setTimeout("process_f_f(" + fid + ")", 1); timeoutcount2++; } //  -     else process_f_f(fid); } //       function crypto_processkey(me, master_aes, file) { var id, key, k, n; if (!file.k) { if (!keycache[file.h]) return; file.k = keycache[file.h]; } id = me; // do I own the file? (user key is guaranteed to be first in .k) //     "&lt;file handle&gt;:&lt;key&gt;/&lt;share key&gt;" var p = file.k.indexOf(id + ':'); //  ,      if (p) { // I don't - do I have a suitable sharekey? for (id in u_sharekeys) { p = file.k.indexOf(id + ':'); if (p &gt;= 0 &amp;&amp; (!p || file.k.charAt(p - 1) == '/')) break; p = -1; } } //        if (p &gt;= 0) { delete keycache[file.h]; //  -    var pp = file.k.indexOf('/', p); if (pp &lt; 0) pp = file.k.length; p += id.length + 1; key = file.k.substr(p, pp - p); // we have found a suitable key: decrypt! if (key.length &lt; 46) { // short keys: AES k = base64_to_a32(key); // check for permitted key lengths (4 == folder, 8 == file) if (k.length == 4 || k.length == 8) { //     -,      k = decrypt_key(id == me ? master_aes : new sjcl.cipher.aes(u_sharekeys[id]), k); } else { if (d) console.log("Received invalid key length (" + k.length + "): " + file.h); return; } } else { // long keys: RSA if (u_privk) { var t = mpi2b(base64urldecode(key)); if (t) k = str_to_a32(crypto_rsadecrypt(t, u_privk).substr(0, file.t ? 16 : 32)); else { if (d) console.log("Corrupt key for node " + file.h); return; } } else { if (d) console.log("Received RSA key, but have no public key published: " + file.h); return; } } //    var ab = base64_to_ab(file.a); //          var o = dec_attr(ab, k); if (typeof o == 'object') { if (typeof on == 'string') { if (file.h) { u_nodekeys[file.h] = k; if (key.length &gt;= 46) rsa2aes[file.h] = a32_to_str(encrypt_key(u_k_aes, k)); } //        -      file.key = k; file.name = on; } } } else { if (d) console.log("Received no suitable key: " + file.h); if (!missingkeys[file.h]) { newmissingkeys = true; missingkeys[file.h] = true; } keycache[file.h] = file.k; } }</span></span></code> </pre><br>  After that we can get the value of the source key <code>ul_key</code> from the browser context as follows: <pre> <code class="javascript hljs">dl_keyNonce = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify([dl_key[<span class="hljs-number"><span class="hljs-number">0</span></span>]^dl_key[<span class="hljs-number"><span class="hljs-number">4</span></span>],dl_key[<span class="hljs-number"><span class="hljs-number">1</span></span>]^dl_key[<span class="hljs-number"><span class="hljs-number">5</span></span>],dl_key[<span class="hljs-number"><span class="hljs-number">2</span></span>]^dl_key[<span class="hljs-number"><span class="hljs-number">6</span></span>],dl_key[<span class="hljs-number"><span class="hljs-number">3</span></span>]^dl_key[<span class="hljs-number"><span class="hljs-number">7</span></span>],dl_key[<span class="hljs-number"><span class="hljs-number">4</span></span>],dl_key[<span class="hljs-number"><span class="hljs-number">5</span></span>]]);</code> </pre><br>  This conversion occurs in the <code>startdownload</code> function.  If we consider that the <code>dl_key == filekey</code> value <code>dl_key == filekey</code> from the <code>ul_chunkcomplete</code> function and perform simple modulo addition operations, we note that the <code>dl_keyNonce</code> variable will store the <code>ul_key</code> value generated when the file was loaded.  An illustration of this can be seen in the lower left corner of the board in the photo at the beginning of the section on file uploading. <br><br><h1>  "Overload" of cryptographic operations </h1>  Despite the fact that the above principles of protecting files and keys are very safe, someone may not like it, that we still depend on the implementation of the algorithms that the service provides.  In this case, we can develop our own browser extension, which will redefine some service functions, implementing additional encryption in them.  Namely, I decided to implement protection of key information (master key and file keys) using hardware encryption on a non-recoverable key using the algorithm of GOST 28147-89.  A bonus to this will also be the inclusion of two-factor authentication on the service. <br>  So, consider this use-case: <br><ul><li>  User registers on the service. </li><li>  It then installs the extension. </li><li>  It is used to perform hardware encryption of the master key on the non-recoverable key from the token </li><li>  The master key encrypted in this way is uploaded to the server. </li></ul><br>  After that, it will be impossible to obtain the master key value without having a token and its PIN code.  This will give: <ol><li>  Two-factor authentication on the service (without the correctly decrypted master key, the function <code>api_getsid2</code> ‚Äú <code>api_getsid2</code> ) </li><li>  Without a token, it will also be impossible to change the current account password </li></ol><br>  The next step is to encrypt the file encryption key (also <code>ul_key</code> ) with the help of the token and the file attribute key ( <code>filekey</code> ), which is stored on the server.  Thus, we get that each file will be encrypted on a key that never gets to the server, where the <code>filekey</code> encrypted by us from the function <code>api_completeupload2</code> .  File attributes will be encrypted in the open <code>filekey</code> value.  For clarity, I sketched the following diagram illustrating the process of downloading a file: <br><br><img src="http://habrastorage.org/storage2/88a/be7/c58/88abe7c587345dce1aad062c96108e5d.png"><br><br>  I want to note that here I used a very clever method.  In this case, it is important for us that the attacker could not decrypt the file, even if he intercepts the file key that came from the server and knows the user's master key.  Therefore, you can play on the features of the service architecture and use the value of the ul_keyNonce key (it is dl_keyNonce), obtained by encrypting the ul_key (or dl_key) key value on the token, for encrypting files. <br><br><h2>  Used technologies </h2>  To implement hardware encryption, the Rutoken EDS USB token will be used (Rutoken Web will also work) in conjunction with the Rutoken Web PKI Edition browser plug-in.  We have already given a detailed description of the plugin in the articles <a href="http://habrahabr.ru/company/aktiv-company/blog/155835/">Rutoken WEB PKI Edition</a> and <a href="http://habrahabr.ru/company/aktiv-company/blog/165887/">Shield and sword in RBS systems.</a>  <a href="http://habrahabr.ru/company/aktiv-company/blog/165887/">Applied solution</a> . <br><br>  From the moment of writing these articles, the possibility of hardware encryption according to the GOST 28147-89 algorithm has been added to our product.  Beta-version of the plug-in with the functionality of hardware encryption according to the GOST 28147-89 algorithm can be downloaded <a href="">here</a> .  This version of the plug-in has not yet been fully tested, so I warn you that there may be errors in it, about the presence of which I ask you to report to the PM. <br>  In the plug-in interface, symmetric encryption is implemented by the encrypt function, which has the following syntax: <br><pre> <code class="javascript hljs">encrypt(deviceId, keyLabel, data, resultCallback, errorCallback) ‚Üí {string}</code> </pre><br>  As input, the function accepts: <ul><li>  Device id <code>number</code> </li><li>  Key label for encryption, <code>number</code> (if there is no such key, it will be generated) </li><li>  Encrypted data, <code>string</code> (a string containing a byte array of the form <code>"aa:bb:cc:dd"</code> ) </li><li>  Callback functions for successful and unsuccessful completion of the encryption operation </li></ul><br>  Decryption is performed similarly using the <code>decrypt</code> function. <br>  Special attention should be paid to the key label, since it determines which key will be used for (rac) data encryption.  A label is an arbitrary string and basically serves to conveniently identify a key.  In this case, I use two key pairs: one for the (ra) encryption of the master key, and the other for encrypting the individual keys of the files.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key on which the master key is encrypted has a label equal to the user's password (I now had the idea to use the hash from the string </font></font><code>e-mail||</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, I will correct it soon). </font><font style="vertical-align: inherit;">To encrypt the keys of the downloaded files, use a key with a label equal to the string representation of the master key (here you should also use the hash from the master key).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Directly development </font></font></h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I just want to make a comment about my source code: it, in fact, is in the alpha version, although it implements the functionality described above. I did not check how much my rework turned out to be compatible with the other functions of the service, so I </font></font><a href="https://github.com/romanovskiy-k/mega-crypto"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all the source code </font><a href="https://github.com/romanovskiy-k/mega-crypto"><font style="vertical-align: inherit;">on github</font></a><font style="vertical-align: inherit;"> and will be happy with any help to refine this system. Therefore, I will not litter the article further with huge listings, but only describe the general scheme of the expansion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The finished extension can be downloaded </font></font><a href="http://crossrider.com/download/30754"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It was developed using the </font></font><a href="http://crossrider.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossrider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">, which provides extensions for three browsers (Chrome, Firefox and IE), but it's better to check its operation in Chrome or Firefox, and in the first one it works much more stable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The extension code to the banal is simple: it checks whether we are on the service page, and if so, it simply loads additional scripts. </font><font style="vertical-align: inherit;">These scripts modify the page code by adding a couple of dialogs and override the following service functions:</font></font><ul><li> <code>changepw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : is responsible for changing the password </font></font></li><li> <code>api_getsid2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : one of the login callbacks </font></font></li><li> <code>api_completeupload2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : callback file download complete </font></font></li><li> <code>loadfm_callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : file manager download callback </font></font></li><li> <code>processpacket</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : another callback decrypting the attributes of the file just uploaded </font></font></li><li> <code>parsepage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : responsible for drawing additional dialogs </font></font></li><li> <code>dologin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : enhances authentication </font></font></li><li> <code>initupload3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : responsible for creating the file encryption key </font></font></li><li> <code>startdownload</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : reverse file key analysis and download initialization </font></font></li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once again, I want to warn you that you should not drag an extension to your work account (if anyone else uses this service here), but rather get a test one. </font><font style="vertical-align: inherit;">In order to use the extension after its installation you will need:</font></font><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a start, it‚Äôs good to get Rutoken EDS (or Rutoken Web) and install </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a browser plugin</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Install extension </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Log in to the service with the extension disabled </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enable browser extension </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go to account page </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Click on the button ‚ÄúLink a token‚Äù </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter the current password and perform this operation. </font></font></li></ol><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instead of the extension, you can use the following bookmarklet (tested in Chrome, Safari, Firefox): </font></font><pre> <code class="javascript hljs">javascript:(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'cryptorutokenjs'</span></span>)){alert(<span class="hljs-string"><span class="hljs-string">'  '</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>}<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadRemoteScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> script=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);script.type=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>;script.src=url;<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script)}<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadRemoteStyle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'link'</span></span>);style.rel=<span class="hljs-string"><span class="hljs-string">'stylesheet'</span></span>;style.type=<span class="hljs-string"><span class="hljs-string">"text/css"</span></span>;style.href=url;<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(style)}loadRemoteStyle(<span class="hljs-string"><span class="hljs-string">"https://mega-crypto.googlecode.com/git/mega.css"</span></span>);loadRemoteScript(<span class="hljs-string"><span class="hljs-string">"https://mega-crypto.googlecode.com/git/util.js"</span></span>);loadRemoteScript(<span class="hljs-string"><span class="hljs-string">"https://mega-crypto.googlecode.com/git/rutoken-extra.js"</span></span>);loadRemoteScript(<span class="hljs-string"><span class="hljs-string">"https://mega-crypto.googlecode.com/git/rutoken-crypto.js"</span></span>);loadRemoteScript(<span class="hljs-string"><span class="hljs-string">"https://mega-crypto.googlecode.com/git/mega.js"</span></span>)})();</code> </pre><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstration of work </font></font></h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, let's connect our creation to the site. </font></font> For this: <ol><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Login to the service and open the file manager page </font></font></h3><br><img src="http://habrastorage.org/storage2/ae9/c26/a83/ae9c26a83f0cf6ca6907861d6ef743ca.png"><br></li><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We connect the extension or bookmarklet, after which we will need to enter the token PIN code </font></font></h3><br><img src="http://habrastorage.org/storage2/e3f/034/786/e3f034786ec79053b2241fb8ab7dd84d.png"><br></li><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go to the account page and bind the token to the account </font></font></h3><br><img src="http://habrastorage.org/storage2/f38/67b/21e/f3867b21e812f1cd1b3e385a9cde7275.png"><br></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then you can exit the service and try to log in again using two-factor authentication: </font></font><ol><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter the login password </font></font></h3></li><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter the PIN </font></font></h3><br><img src="http://habrastorage.org/storage2/264/113/e2c/264113e2cee26dcb6bdc4297874ab85a.png"><br></li><li><h3>  ... </h3></li><li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profit! </font></font></h3></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Authentication occurs as follows: </font></font><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Checking the login-password on the server </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the login password is correct, then an encrypted master key comes from the server. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By means of the plugin, the PIN is requested to the token </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the PIN is entered correctly, the master key is decrypted on the key from the token </font></font></li></ol><br><h1>  Instead of conclusion </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I just want to write ‚Äúto be continued ...‚Äù, because I didn‚Äôt cover the details of creating extensions and interesting ways of screwing the asynchronous encryption functions into the service, which in most cases uses synchronous calls. In conclusion of this article, I would like to once again turn to the idea of ‚Äã‚Äãimplementing client-side cryptography. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The approach to the implementation of additional cryptographic functions on the client side can be applied to any web service that does not matter what is stored on the server: whether it be file storage, mail, or simple chat. For example, you can implement secure mail based on any mail service using encryption of messages in the CMS format and key exchange mechanisms using the VKO GOST R 34.10-2001 algorithm. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for your attention, waiting for your questions and comments.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS: the first five who wish (from Moscow) to test the plugin, we can donate a token - write in a personal. </font></font></div><p>Source: <a href="https://habr.com/ru/post/176513/">https://habr.com/ru/post/176513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176503/index.html">Doorway, Plato and the quality of search in Yandex</a></li>
<li><a href="../176505/index.html">‚ÄúStrategy Pattern. Just a simple "or why I go to the interview" PHP Junior "for fun'a</a></li>
<li><a href="../176507/index.html">The notorious "experience"</a></li>
<li><a href="../176509/index.html">How we created "Hotel for this night!"</a></li>
<li><a href="../176511/index.html">New York police officers equipped with Android-smartphones with "police" applications for quick access to databases</a></li>
<li><a href="../176517/index.html">But I brought you a board game about space flights</a></li>
<li><a href="../176521/index.html">Zuckerberg will call us to live in the United States</a></li>
<li><a href="../176523/index.html">Microsoft advises to refrain from installing the update MS13-036</a></li>
<li><a href="../176525/index.html">CodingDead - Events, Technologies, and News from the Ruby / Rails / Javascript Community</a></li>
<li><a href="../176527/index.html">Do-it-yourself laser show. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>