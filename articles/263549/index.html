<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreaded SOCKS 4 server on Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time on the forums of the RuNet in the Qt branch there are questions related to the programming of network applications. One of the probl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreaded SOCKS 4 server on Qt</h1><div class="post__text post__text-html js-mediator-article">  From time to time on the forums of the RuNet in the Qt branch there are questions related to the programming of network applications.  One of the problems that torment these people is the approach to server organization.  Usually list three approaches: <br><ul><li>  single-line asynchronous; </li><li>  multi-threaded; create stream per connection; </li><li>  multi-threaded, with a thread pool on <a href="http://doc.qt.io/qt-5/qthreadpool.html">QThreadPool</a> and <a href="http://doc.qt.io/qt-5/qrunnable.html">QRunnable</a> . </li></ul><br>  When you talk about a fixed number of worker threads with your event-handling cycle, you are asked to give an example.  Below is an example of a server with a pool of threads, each of which has its own event-handling cycle. <br><a name="habracut"></a><br>  Characters: <br><ul><li>  class <b>Server</b> , joins connections and distributes tasks to workers; </li><li>  the <b>Worker</b> class, instances of which will create instances of the Client class in the workflows; </li><li>  <b>Client</b> class encapsulating client requests and implementing SOCKS 4 </li></ul><br>  The simplest of this trinity is the Worker, it is inherited from <b>QObject</b> and implements only one client creation function and is purely for the ‚Äúcorrect‚Äù <a href="http://habrahabr.ru/post/150274/">use of threads</a> : <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(qintptr socketDescriptor)</span></span></span></span>; };</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Worker::addClient(qintptr socketDescriptor) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client(socketDescriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  The server is just as simple: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QTcpServer { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Server(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> threads = <span class="hljs-number"><span class="hljs-number">4</span></span>, QObject * parent = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); ~Server(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incomingConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(qintptr socketDescriptor)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initThreads</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_threadCount; QVector&lt;QThread*&gt; m_threads; QVector&lt;Worker*&gt; m_workers; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_rrcounter; };</code> </pre><br><pre> <code class="cpp hljs">Server::Server(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> threads, QObject * parent) : QTcpServer(parent), m_threadCount(threads), m_rrcounter(<span class="hljs-number"><span class="hljs-number">0</span></span>) { initThreads(); } Server::~Server() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(QThread* thread: m_threads) { thread-&gt;quit(); thread-&gt;wait(); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Server::initThreads() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_threadCount; ++i) { QThread* thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QThread(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Worker* worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(); worker-&gt;moveToThread(thread); connect(thread, &amp;QThread::finished, worker, &amp;QObject::deleteLater); m_threads.push_back(thread); m_workers.push_back(worker); thread-&gt;start(); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Server::incomingConnection(qintptr socketDescriptor) { Worker* worker = m_workers[m_rrcounter % m_threadCount]; ++m_rrcounter; QMetaObject::invokeMethod(worker, <span class="hljs-string"><span class="hljs-string">"addClient"</span></span>, Qt::QueuedConnection, Q_ARG(qintptr, socketDescriptor)); }</code> </pre><br>  In the constructor, it creates threads, workers, and moves workers into threads.  Each new connection is passed to the worker.  He chooses a worker to ‚Äúhonor‚Äù, ‚Äã‚Äãthat is, according to <a href="https://ru.wikipedia.org/wiki/Round-robin_%2528%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%2529">Round-robin</a> . <br><br>  <a href="https://ru.wikipedia.org/wiki/SOCKS">SOCKS 4 is a</a> very simple protocol, you only need: <br><ol><li>  read IP address, port number; </li><li>  establish a connection with the "world"; </li><li>  send a message to the client that the request is confirmed; </li><li>  send data from one socket to another until someone closes the connection. </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Client</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Client(qintptr socketDescriptor, QObject* parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client2world</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">world2client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendSocksAnsver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClientDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWorldDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QTcpSocket m_client; QTcpSocket m_world; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) struct socks4request { uint8_t version; uint8_t command; uint16_t port; uint32_t address; uint8_t end; }; struct socks4ansver { uint8_t empty = 0; uint8_t status; uint16_t field1 = 0; uint32_t field2 = 0; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop) enum SocksStatus { Granted = 0x5a, Failed = 0x5b, Failed_no_identd = 0x5c, Failed_bad_user_id = 0x5d }; } Client::Client(qintptr socketDescriptor, QObject* parent) : QObject(parent) { m_client.setSocketDescriptor(socketDescriptor); connect(&amp;m_client, &amp;QTcpSocket::readyRead, this, &amp;Client::onRequest); connect(&amp;m_client,&amp;QTcpSocket::disconnected, this, &amp;Client::onClientDisconnected); connect(&amp;m_world, &amp;QTcpSocket::connected, this, &amp;Client::sendSocksAnsver); connect(&amp;m_world, &amp;QTcpSocket::readyRead, this, &amp;Client::world2client); connect(&amp;m_world,&amp;QTcpSocket::disconnected, this, &amp;Client::onWorldDisconnected); } void Client::onRequest() { QByteArray request = m_client.readAll(); socks4request* header = reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;socks4request*&gt;(request.data()); #if Q_BYTE_ORDER == Q_LITTLE_ENDIAN const QHostAddress address(qFromBigEndian(header-&gt;address)); #else const QHostAddress address(header-&gt;address); #endif #if Q_BYTE_ORDER == Q_LITTLE_ENDIAN const uint16_t port = qFromBigEndian(header-&gt;port); #else const uint16_t port = header-&gt;port; #endif //qDebug()&lt;&lt;"connection:"&lt;&lt;address&lt;&lt;"port:"&lt;&lt;port; m_world.connectToHost(address, port); disconnect(&amp;m_client, &amp;QTcpSocket::readyRead, this, &amp;Client::onRequest); connect(&amp;m_client, &amp;QTcpSocket::readyRead, this, &amp;Client::client2world); } void Client::sendSocksAnsver() { socks4ansver ans; ans.status = Granted; m_client.write(reinterpret_cast&lt;char*&gt;(&amp;ans), sizeof(ans)); m_client.flush(); } void Client::client2world() { m_world.write(m_client.readAll()); } void Client::world2client() { m_client.write(m_world.readAll()); } void Client::onClientDisconnected() { m_world.flush(); done(); } void Client::onWorldDisconnected() { m_client.flush(); done(); } void Client::done() { m_client.close(); m_world.close(); deleteLater(); }</span></span></span></span></code> </pre><br><h5>  <b>Epoll and Qt</b> </h5><br><blockquote>  A cry is like thunder: <br>  - Give people rum <br>  Need any <br>  People drink rum! <br></blockquote><br><br>  If we compile the previous code and run it through <b>strace -f</b> , we will see calls to poll.  There will definitely be someone who will say his weighty "fi", saying that with an epoll there will be "well, finally, a rocket." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Qt has a <a href="http://doc.qt.io/qt-5/qabstracteventdispatcher.html">QAbstractEventDispatcher</a> class that allows you to define your own event dispatcher.  Naturally, there were good people who made and posted dispatchers with different backends.  Here is a small list of them: <br><ul><li>  <a href="https://github.com/connectedtable/qeventdispatcher_epoll">connectedtable / qeventdispatcher_epoll</a> ; </li><li>  <a href="https://github.com/sjinks/qt_eventdispatcher_epoll">sjinks / qt_eventdispatcher_epoll</a> ; </li><li>  <a href="https://github.com/sjinks/qt_eventdispatcher_libev">sjinks / qt_eventdispatcher_libev</a> ; </li><li>  <a href="https://github.com/sjinks/qt_eventdispatcher_libevent">sjinks / qt_eventdispatcher_libevent</a> </li><li>  <a href="https://github.com/svalaskevicius/qt-event-dispatcher-libuv">svalaskevicius / qt-event-dispatcher-libuv</a> </li></ul><br>  When using our dispatcher, we register in main.cpp <br><pre> <code class="cpp hljs">QCoreApplication::setEventDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QEventDispatcherEpoll); <span class="hljs-function"><span class="hljs-function">QCoreApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span></code> </pre><br>  and the initThreads method on the server becomes: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Server::initThreads() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_threadCount; ++i) { QThread* thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QThread(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); thread-&gt;setEventDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QEventDispatcherEpoll); Worker* worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(); worker-&gt;moveToThread(thread); connect(thread, &amp;QThread::finished, worker, &amp;QObject::deleteLater); m_threads.push_back(thread); m_workers.push_back(worker); thread-&gt;start(); } }</code> </pre><br>  And if we run strace again, we will see the cherished function calls with the <b>epoll_</b> prefix. <br><br><h5>  <b>findings</b> </h5><br>  The conclusions are purely pragmatic. <br><br>  If you are an application programmer and you have no tasks from the category of ‚Äúbig‚Äù data or highload in Bunin, then write on what you want and how you can.  The task of the application programmer to produce a product of a certain quality, spending a certain amount of resources.  Otherwise, one only sockets with epoll will not do. <br><br>  PS <br><br>  Source codes are available on <a href="https://github.com/RPG-18/qtsocks">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/263549/">https://habr.com/ru/post/263549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263537/index.html">Chasing yourself, or a great way to start your day.</a></li>
<li><a href="../263539/index.html">Emmett Shire: How to Twitch Talk to Users</a></li>
<li><a href="../263541/index.html">PostgreSQL: Production Techniques</a></li>
<li><a href="../263545/index.html">nxweb - HTTP server for C applications</a></li>
<li><a href="../263547/index.html">Pseudo OOP in C</a></li>
<li><a href="../263551/index.html">Quick start with PHPixie 3</a></li>
<li><a href="../263555/index.html">Qucs project news: release candidate available with circuit simulation support in SPICE</a></li>
<li><a href="../263565/index.html">Magic of tensor algebra: Part 13 - SKA Maxima in problems of transforming tensor expressions. Angular velocity and acceleration in the parameters of Rodrigues-Hamilton</a></li>
<li><a href="../263569/index.html">With LINQ on "Life"</a></li>
<li><a href="../263571/index.html">SoC: we write framebuffer implementation for controller in FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>