<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a web service on Go (part two)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the article on how to write a small full-featured application on Go. 

 In the first part, we implemented the REST API and learned how to c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a web service on Go (part two)</h1><div class="post__text post__text-html js-mediator-article">  Continuing the article on how to write a small full-featured application on Go. <br><br>  In the <a href="http://habrahabr.ru/post/208680/">first part,</a> we implemented the REST API and learned how to collect incoming HTTP requests.  In this part, we will cover our application with tests, add a beautiful web interface based on AngularJS and Bootstrap, and introduce access restriction for different users. <br><a name="habracut"></a><br><br>  In this part, we are waiting for the following stages: <br><ol><li>  Step Four.  But what about the tests? </li><li>  Step five - decorations and a web interface; </li><li>  Step Six.  Add a little privacy. </li><li>  Step Seven.  We clear the unnecessary; </li><li>  Step Eight.  Use Redis for storage. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Step Four.  But what about the tests? </h4><br>  Any application should be covered with tests, no matter what size it is. Go has a large number of built-in tools for working with tests.  You can write as a normal unit tests (unit tests), and, for example, performance tests (benchmark tests).  Also, the toolkit allows you to view code coverage tests. <br><br>  The basic package for working with tests is <a href="http://golang.org/pkg/testing/">testing</a> .  The two main types here are <code>T</code> for normal unit tests and <code>B</code> for load tests.  Tests in Go are written in the same package as the main program, with the addition of the <code>_test</code> suffix.  Therefore, any private data structures available inside the package are also available inside the tests (it is also true that tests have a common global scope between them).  When compiling the main program, test files are ignored. <br><br>  In addition to the basic package of testing, there are a large number of third-party libraries that help simplify the writing of tests or allow writing in a particular style (even in the style of <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> ).  For example, here‚Äôs a <a href="http://blog.stretchr.com/2014/03/05/test-driven-development-specifically-in-golang/">good introductory article</a> on how to write TD in Go style. <br><br>  On GitHub, there is a benchmark for comparing test libraries, among which are monsters such as <a href="http://goconvey.co/">goconvey</a> , which also provides a web-based interface and interaction with the system, such as test notifications.  But, in order not to complicate things, for our project we will take a small <a href="https://github.com/stretchr/testify">testify</a> library that adds only a few primitives to check conditions and create mock objects. <br><br>  Download the code for the fourth step: <br><br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span></code> </pre><br>  Let's start by writing tests for models.  Create a file models_test.go.  To be detected by the go test utility, functions with tests must satisfy the following pattern: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.T)</span></span></span></span></code> </pre><br>  Let's write our first test that will check for the proper creation of a Bin object: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TestNewBin</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">testing</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.T</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">now </span></span>:= time.<span class="hljs-built_in"><span class="hljs-built_in">Now</span></span>().<span class="hljs-built_in"><span class="hljs-built_in">Unix</span></span>() bin := <span class="hljs-built_in"><span class="hljs-built_in">NewBin</span></span>() if assert.<span class="hljs-built_in"><span class="hljs-built_in">NotNil</span></span>(t, bin) { assert.<span class="hljs-built_in"><span class="hljs-built_in">Equal</span></span>(t, len(bin.Name), <span class="hljs-number"><span class="hljs-number">6</span></span>) assert.<span class="hljs-built_in"><span class="hljs-built_in">Equal</span></span>(t, bin.RequestCount, 0) assert.<span class="hljs-built_in"><span class="hljs-built_in">Equal</span></span>(t, bin.Created, bin.Updated) assert.<span class="hljs-built_in"><span class="hljs-built_in">True</span></span>(t, bin.Created &lt; (now+1)) assert.<span class="hljs-built_in"><span class="hljs-built_in">True</span></span>(t, bin.Created &gt; (now-1)) } }</code> </pre><br>  All testify methods in testify accept * testing.T object as the first parameter. <br>  Next, we test all the scenarios, not forgetting the erroneous paths and boundary values.  I will not give the code of all the tests in the article, as there are quite a lot of them, and you can read them in the repository, I‚Äôll only touch on the most interesting moments. <br><br>  Pay attention to the file api_test.go, in it we are testing our REST API.  In order not to depend on the implementations of our data storage, we add a <a href="http://ru.wikipedia.org/wiki/Mock-%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">mock object</a> that implements the behavior of the Storage interface.  We do this with the testify <a href="https://github.com/stretchr/testify">mock package</a> .  It provides a mechanism for easily writing mock objects, which can then be used instead of real objects when writing tests. <br><br>  Here is his code: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class"> struct{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">) error { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(0)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UpdateBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">) error { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called(bin)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(0)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) (*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called(name)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Get(0)</span></span></span><span class="hljs-class">.(*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(1)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupBins</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">names</span></span></span><span class="hljs-class"> []</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) ([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called(names)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Get(0)</span></span></span><span class="hljs-class">.([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(1)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) (*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Get(0)</span></span></span><span class="hljs-class">.(*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(1)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">) error { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called(bin)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(0)</span></span></span><span class="hljs-class"> } func (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MockedStorage</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupRequests</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) ([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Called</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Get(0)</span></span></span><span class="hljs-class">.([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error(1)</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Further, in the tests themselves, when creating the API, we inject our mock object: <br><br><pre> <code class="hljs lua"> req, _ := http.NewRequest(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/api/v1/bins/"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) api = GetApi() mockedStorage := &amp;MockedStorage{} api.MapTo(mockedStorage, (*Storage)(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) res = httptest.NewRecorder() mockedStorage.On(<span class="hljs-string"><span class="hljs-string">"LookupBins"</span></span>, []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{}).Return([]*Bin(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>), errors.New(<span class="hljs-string"><span class="hljs-string">"Storage error"</span></span>)) api.ServeHTTP(res, req) mockedStorage.AssertExpectations(t) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>.Equal(t, res.Code, <span class="hljs-number"><span class="hljs-number">500</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>.Contains(t, res.Body.String(), <span class="hljs-string"><span class="hljs-string">"Storage error"</span></span>) }</code> </pre><br>  In the test, we describe the expected requests to the mock object and the answers we need.  Therefore, when we call the <code>s.Mock.Called(names)</code> method inside the mock method of an object, it tries to match the specified parameters and method name, and when we return args.Get (0), the first argument returned is returned. , in this case realBin.  In addition to the Get method, which returns an object of type interface {}, there are helper methods Int, String, Bool, Error, which transform the interface into the type we need.  The mockedStorage.AssertExpectations (t) method checks if all expected methods were called by us during testing. <br><br>  The <a href="httptest/">ResponseRecorder</a> object created in httptest.NewRecorder is also interesting here, it implements the behavior of the ResponseWriter and allows us, without outputting the request data anywhere, to see what eventually returns (response code, headers and response body). <br><br>  To run the tests, run the command: <br><br><pre> <code class="hljs go">&gt; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test ./src/skimmer ok _/.../src/skimmer <span class="hljs-number"><span class="hljs-number">0.032s</span></span></code> </pre><br>  The test run team has a large number of flags, you can read them like this: <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; go help testflag</span></span></code> </pre><br>  You can play with them, but now we are interested in the following command (relevant for Go version 1.2): <br><br><pre> <code class="hljs vhdl">&gt; go test ./src/skimmer/ -coverprofile=c.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &amp;&amp; go tool <span class="hljs-keyword"><span class="hljs-keyword">cover</span></span> -html=c.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span></code> </pre><br>  If you didn‚Äôt work, you may need to first install the coverage tool. <br><br><pre> <code class="hljs go">&gt; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get code.google.com/p/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.tools/cmd/cover</code> </pre><br>  This command performs the tests and saves the test coverage profile to the c.out file, and then the <code>go tool</code> utility creates an html version that opens in the browser. <br><blockquote>  Coverage tests in Go, implemented quite interesting.  Before compiling the code, the source files are changed, the counters are inserted into the source code.  For example, this is the code: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"negative"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"zero"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"enormous"</span></span> }</code> </pre><br>  turns into this: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { GoCover.Count[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: GoCover.Count[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"negative"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span>: GoCover.Count[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"zero"</span></span> } GoCover.Count[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"enormous"</span></span> }</code> </pre><br>  It is also possible to show not just coverage, but how many times each section of code is being tested.  As always, you can read more in the <a href="http://blog.golang.org/cover">documentation</a> . </blockquote><br>  Now that we have a full-fledged REST API, and it is also covered with tests, we can start embellishing and building a web interface. <br><br><h4>  Step five - decorations and web interface. </h4><br>  Go comes a full-fledged library for working with <a href="http://golang.org/pkg/html/template/">html templates</a> , but we will make a so-called one-page application that works directly with the API via javascript.  Will help us in this <a href="http://angularjs.org/">AngularJS</a> . <br><br>  Update the code for the new step: <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; git checkout step-5</span></span></code> </pre><br>  As mentioned in the first chapter, Martini has a handler for distributing statics, by default it distributes static files from the public directory.  Put there the necessary js and css libraries.  I will describe the work of the frontend, since this is not the purpose of this article, you can look at the source files yourself, for people familiar with angular, everything is quite simple. <br><br>  To display the main page, we add a separate handler: <br><br><pre> <code class="hljs swift"> api.<span class="hljs-type"><span class="hljs-type">Get</span></span>(<span class="hljs-string"><span class="hljs-string">"**"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r render.Render)</span></span></span></span>{ r.<span class="hljs-type"><span class="hljs-type">HTML</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">"index"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) })</code> </pre><br><br>  Glob <code>**</code> characters say that an index.html file will be displayed for any address.  To work correctly with templates, we added options when creating a Renderer, indicating where to get templates.  Plus, to avoid conflicts with angular templates, reassigned {{}} to {[{}]}. <br><br><pre> <code class="hljs mel"> api.Use(<span class="hljs-keyword"><span class="hljs-keyword">render</span></span>.Renderer(<span class="hljs-keyword"><span class="hljs-keyword">render</span></span>.Options{ Directory: <span class="hljs-string"><span class="hljs-string">"public/static/views"</span></span>, Extensions: []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">".html"</span></span>}, Delims: <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>.Delims{<span class="hljs-string"><span class="hljs-string">"{[{"</span></span>, <span class="hljs-string"><span class="hljs-string">"}]}"</span></span>}, }))</code> </pre><br><br>  In addition, the colors (three bytes that store the RGB color value) and the Favicon (data uri picture, need colors) fields that were randomly generated when creating an object were added to the Bin model to distinguish different bin objects by color. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class"> struct { ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> [3]</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">byte</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class">:"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class">"` </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Favicon</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class">:"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">favicon</span></span></span><span class="hljs-class">"` } func </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewBin</span></span></span><span class="hljs-class">() *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class">:= </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RandomColor</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> := </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">{ ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Favicon</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Solid16x16gifDatauri(color)</span></span></span><span class="hljs-class">, } ... }</span></span></code> </pre><br>  Now we have an almost full-featured web application, we can run it: <br><br><pre> <code class="hljs go">&gt; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run ./src/main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre><br>  And open in browser ( <code><a href="http://127.0.0.1/"></a> 127.0.0.1:3000</code>  To play around. <br><br>  Unfortunately, the application still has two problems: after the program is completed, all data is lost and we have no separation by users, everyone sees the same thing.  Well, let's do it. <br><br><h5>  Step Six.  Add a little privacy. </h5><br>  Download the code for the sixth step: <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; git checkout step-6</span></span></code> </pre><br>  Separate users from each other, we will be using sessions.  To begin, choose where to store them.  Sessions in <a href="https://github.com/martini-contrib/sessions">martini-contrib</a> are based on <a href="http://www.gorillatoolkit.org/">gorilla</a> web library sessions. <br><blockquote>  Gorilla is a set of tools for implementing web frameworks.  All of these tools are weakly interconnected, which allows you to take any part and build it to yourself. </blockquote><br>  This allows us to use the repositories already implemented in gorilla.  Ours will be cookie based. <br><br>  Create a session repository: <br><br><pre> <code class="hljs lisp">func GetApi(<span class="hljs-name"><span class="hljs-name">config</span></span> *Config) *martini.ClassicMartini { ... store <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> sessions.NewCookieStore([]byte(<span class="hljs-name"><span class="hljs-name">config</span></span>.SessionSecret)) ...</code> </pre><br><blockquote>  The NewCookieStore function accepts a pair of keys as parameters, the first key in the pair is needed for authentication, and the second for encryption.  The second key can be skipped.  To be able to rotate keys without losing sessions, you can use several pairs of keys.  When creating a session, the keys of the first pair will be used, but when checking data, all keys are used in order, starting with the first pair. </blockquote><br>  Since we need different keys for applications, we will move this parameter to the Config object, which later will help us customize the application based on the environmental parameters or launch flags. <br><br>  Add an intermediate handler to our API that adds work with sessions: <br><br><pre> <code class="hljs sql">// Sessions is a Middleware that maps a session.Session service into the Martini <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> chain. // Sessions can <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> solutions <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the given store. func Sessions(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">store</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Store</span></span>) martini.Handler { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(res http.ResponseWriter, r *http.Request, c martini.Context, l *log.Logger) { // <span class="hljs-keyword"><span class="hljs-keyword">Map</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">Session</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> s := &amp;<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, r, l, <span class="hljs-keyword"><span class="hljs-keyword">store</span></span>, nil, <span class="hljs-literal"><span class="hljs-literal">false</span></span>} c.MapTo(s, (*<span class="hljs-keyword"><span class="hljs-keyword">Session</span></span>)(nil)) // <span class="hljs-keyword"><span class="hljs-keyword">Use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> hook <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">save</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> rw := res.(martini.ResponseWriter) rw.Before(func(martini.ResponseWriter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.Written() { <span class="hljs-keyword"><span class="hljs-keyword">check</span></span>(s.Session().Save(r, res), l) } }) ... c.Next() } }</code> </pre><br>  As can be seen from the code, a session is created for each request and added to the context of the request.  At the end of the request, just before the data from the buffer is written, the session data is saved if it has been changed. <br><br>  Now let's rewrite our history (which used to be just a slice), the history.go file: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> History <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { All() []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Add(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> SessionHistory <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { size <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> session sessions.Session data []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history *SessionHistory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">All</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> history.data == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { history.load() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> history.data } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history *SessionHistory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> history.data == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { history.load() } history.data = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(history.data, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(history.data[<span class="hljs-number"><span class="hljs-number">1</span></span>:], history.data) history.data[<span class="hljs-number"><span class="hljs-number">0</span></span>] = name history.save() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history *SessionHistory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { size := history.size <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(history.data){ size = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(history.data) } history.session.Set(history.name, history.data[:size]) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history *SessionHistory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { sessionValue := history.session.Get(history.name) history.data = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sessionValue != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> values, ok := sessionValue.([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>); ok { history.data = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(history.data, values...) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewSessionHistoryHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">martini</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c martini.Context, session sessions.Session)</span></span></span></span> { history := &amp;SessionHistory{size: size, name: name, session: session} c.MapTo(history, (*History)(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) } }</code> </pre><br>  In the NewSessionHistoryHandler method, we create a SessionHistory object that implements the History interface (describing the addition and query of all history objects), and then add it to the context of each query.  The SessionHistory object has load and save helper methods that load and save data into the session.  And loading data from the session is done only on demand.  Now, in all API methods where a history slice was used before, a new History type object will be used. <br><br>  From this point on, each user will have his own history of Bin objects displayed, but through a direct link we can still see any Bin.  Fix this by adding the ability to create private Bin objects. <br><br>  Create two new fields in Bin: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bin</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ... Private <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> `json:<span class="hljs-string"><span class="hljs-string">"private"</span></span>` SecretKey string `json:<span class="hljs-string"><span class="hljs-string">"-"</span></span>` }</code> </pre><br>  The key will be stored in the SecretKey field, giving access to private Bins (where the Private flag is true).  Add the same method that makes our object private: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bin *Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPrivate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bin.Private = <span class="hljs-literal"><span class="hljs-literal">true</span></span> bin.SecretKey = rs.Generate(<span class="hljs-number"><span class="hljs-number">32</span></span>) }</code> </pre><br>  In order to create private Bins, our frontend, when creating an object, will send a json object with the private flag.  To parse the incoming json, we wrote a small method DecodeJsonPayload, which reads the request body and unpacks it into the structure we need: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeJsonPayload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *http.Request, v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { content, err := ioutil.ReadAll(r.Body) r.Body.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } err = json.Unmarshal(content, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Change the API now to implement the new behavior: <br><br><pre> <code class="hljs pgsql"> api.Post("/api/v1/bins/", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>, history History, <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> sessions.<span class="hljs-keyword"><span class="hljs-keyword">Session</span></span>, req *http.Request){ payload := Bin{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := DecodeJsonPayload(req, &amp;payload); err != nil { r.JSON(<span class="hljs-number"><span class="hljs-number">400</span></span>, ErrorMsg{fmt.Sprintf("Decoding payload error: %s", err)}) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } bin := NewBin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payload.Private { bin.SetPrivate() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.CreateBin(bin); err == nil { history.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(bin.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin.Private { <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(fmt.Sprintf("pr_%s", bin.Name), bin.SecretKey) } r.JSON(http.StatusCreated, bin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusInternalServerError, ErrorMsg{err.Error()}) } })</code> </pre><br>  First, we create a payload object of type Bin, whose fields will be filled with values ‚Äã‚Äãin the DecodeJsonPayload function from the request body.  After that, if the ‚Äúprivate‚Äù option is set in the incoming data, we make our bin private.  Next, for private objects, we save the key value to the session session. <code>session.Set(fmt.Sprintf("pr_%s", bin.Name), bin.SecretKey)</code> .  Now we need to change other API methods so that they check for the existence of a key in a session for private Bin objects. <br><br>  This is done approximately like this: <br><br><pre> <code class="hljs pgsql"> api.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("/api/v1/bins/:bin", func(r render.Render, params martini.Params, <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> sessions.<span class="hljs-keyword"><span class="hljs-keyword">Session</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupBin(params["bin"]); err == nil{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin.Private &amp;&amp; bin.SecretKey != <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>(fmt.Sprintf("pr_%s", bin.Name)){ r.JSON(http.StatusForbidden, ErrorMsg{"The bin is private"}) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusOK, bin) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusNotFound, ErrorMsg{err.Error()}) } })</code> </pre><br>  By analogy done in other methods.  Some tests were also corrected to take into account the new behavior, specific changes can be viewed in the code. <br><br>  If you run our application now in different browsers or in incognito mode, you can make sure that the story is different, and only the browser in which it is created has access to private Bin objects. <br><br>  Everything is good, but now all the objects in our storage live almost forever, which is probably not correct, since there cannot be eternal memory, so we will try to limit the time of their life. <br><br><h4>  Step Seven.  We clear the unnecessary. </h4><br><br>  Download the code for the seventh step: <br><br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-7</span></span></code> </pre><br>  Add another field to the base storage structure: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStorage</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ... binLifetime int64 }</code> </pre><br>  It will store the maximum lifetime of the object Bin and its attendant requests.  Now let's rewrite our storage in memory - memory.go.  The main method to clean all binRecords that have not been updated more than binLifetime seconds: <br><br><pre> <code class="hljs pgsql">func (<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> *MemoryStorage) clean() { <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span>() defer <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.Unlock() now := <span class="hljs-type"><span class="hljs-type">time</span></span>.Now().Unix() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, binRecord := range <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.binRecords { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord.bin.Updated &lt; (now - <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.binLifetime) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.binRecords, <span class="hljs-type"><span class="hljs-type">name</span></span>) } } }</code> </pre><br>  We also add a timer and methods for working with it to the MemoryStorage type: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MemoryStorage <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ... cleanTimer *time.Timer } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartCleaning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ storage.cleanTimer = time.AfterFunc(time.Duration(timeout) * time.Second, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{storage.StartCleaning(timeout)}) }() storage.clean() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopCleaning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> storage.cleanTimer != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { storage.cleanTimer.Stop() } }</code> </pre><br><br>  The package method time AfterFunc starts the specified function in a separate gorutin (it must be without parameters, so we will use the closure to pass the timeout here) after a timeout, such as time.Duration, passed in the first argument. <br><br>  To scale our application horizontally, we will need to run it on different servers, so we will need a separate storage for our data.  Take for example - Redis. <br><br><h4>  Step Eight.  Use Redis for storage. </h4><br>  Official Redis documentation <a href="http://redis.io/clients">advises</a> us an extensive list of clients for Go.  At the time of this writing, the recommended are <a href="https://github.com/fzzy/radix">radix</a> and <a href="https://github.com/garyburd/redigo">redigo</a> .  We will choose redigo, as it is being actively developed and has a larger community. <br><br>  Let's go to the desired code: <br><br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span></code> </pre><br>  Let's look in the redis.go file, in it there will be our implementation of Storage for Redis.  The basic structure is quite simple: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisStorage</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseStorage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pool</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">redis</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prefix</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cleanTimer</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">time</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Timer</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  The pool of radish connections will be stored in the pool, in prefix - the common prefix for all keys.  To create a pool, take the code from the redigo examples: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, password </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pool *redis.Pool)</span></span></span></span> { pool = &amp;redis.Pool{ MaxIdle: <span class="hljs-number"><span class="hljs-number">3</span></span>, IdleTimeout: <span class="hljs-number"><span class="hljs-number">240</span></span> * time.Second, Dial: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(redis.Conn, error)</span></span></span></span> { c, err := redis.Dial(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, server) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> password != <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := c.Do(<span class="hljs-string"><span class="hljs-string">"AUTH"</span></span>, password); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { c.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c, err }, TestOnBorrow: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c redis.Conn, _ time.Time)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := c.Do(<span class="hljs-string"><span class="hljs-string">"PING"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pool }</code> </pre><br>  In the Dial, we pass a function that, after connecting to the Redis server, will try to log in if a password is specified.  After this, the established connection is returned.  The TestOnBorrow function is called when a connection is requested from the pool, in it you can check the connection for viability.  The second parameter is the time since the connection was returned to the pool.  We just send ping every time. <br><br>  Also in the package we have declared several constants: <br><br><pre> <code class="hljs lisp">const ( <span class="hljs-name"><span class="hljs-name">KEY_SEPARATOR</span></span> = <span class="hljs-string"><span class="hljs-string">"|"</span></span> //   BIN_KEY = <span class="hljs-string"><span class="hljs-string">"bins"</span></span> //     Bin REQUESTS_KEY = <span class="hljs-string"><span class="hljs-string">"rq"</span></span> //      REQUEST_HASH_KEY = <span class="hljs-string"><span class="hljs-string">"rhsh"</span></span> //        CLEANING_SET = <span class="hljs-string"><span class="hljs-string">"cln"</span></span> // ,      Bin   CLEANING_FACTOR = <span class="hljs-number"><span class="hljs-number">3</span></span> //      )</code> </pre><br>  The keys we get here are as follows: <br><br><pre> <code class="hljs perl">func (storage *RedisStorage) getKey(<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span> ...string) string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s%s%s"</span></span>, storage.prefix, KEY_SEPARATOR, strings.Join(<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>, KEY_SEPARATOR)) }</code> </pre><br><br>  To store our data in radish, they need to be serialized with something.  We will select the popular <a href="http://msgpack.org/">msgpack</a> format and use the popular <a href="https://github.com/ugorji/go">codec</a> library. <br><br>  We describe the methods that serialize everything that is possible into binary data and vice versa: <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( mh codec.MsgpackHandle h = &amp;mh ) err = codec.NewEncoderBytes(&amp;data, h).Encode(v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( mh codec.MsgpackHandle h = &amp;mh ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> codec.NewDecoderBytes(data, h).Decode(v) }</code> </pre><br>  We now describe other methods. <br><br><h5>  Creating a Bin Object </h5><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bin *Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { dumpedBin, err := storage.Dump(bin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } conn := storage.pool.Get() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> conn.Close() key := storage.getKey(BIN_KEY, bin.Name) conn.Send(<span class="hljs-string"><span class="hljs-string">"SET"</span></span>, key, dumpedBin) conn.Send(<span class="hljs-string"><span class="hljs-string">"EXPIRE"</span></span>, key, storage.binLifetime) conn.Flush() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bin *Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := storage.UpdateBin(bin); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  First we serialize the bin using the Dump method.  Then we take the radish compound from the pool (remembering to return it with the help of defer). <br><blockquote>  Redigo supports pipeline mode, we can add a command to the buffer via the Send method, send all data from the buffer using the Flush method and get the result in Receive.  The Do command combines all three commands into one.  You can also implement transactivity, read more in the redigo <a href="http://godoc.org/github.com/garyburd/redigo/redis">documentation</a> . </blockquote><br>  We send two commands, ‚ÄúSET‚Äù to save the Bin data by its name and Expire to set the lifetime of this record. <br><br><h5>  Getting a Bin Object </h5><br><pre> <code class="hljs pgsql">func (<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> *RedisStorage) LookupBin(<span class="hljs-type"><span class="hljs-type">name</span></span> string) (bin *Bin, err error) { conn := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.pool.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>() defer conn.<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>() reply, err := redis.Bytes(conn.<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span>("GET", <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.getKey(BIN_KEY, <span class="hljs-type"><span class="hljs-type">name</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == redis.ErrNil { err = errors.<span class="hljs-built_in"><span class="hljs-built_in">New</span></span>("Bin was not found") } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } err = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Load</span></span>(reply, &amp;bin) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br>  The helper method redis.Bytes attempts to read the response from conn.Do into an array of bytes.  If the object was not found, the radish will return a special type of error redis.ErrNil.  If everything went well, the data is loaded into the bin object, passed by reference to the Load method. <br><br><h5>  Get a list of Bin objects </h5><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupBins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(names []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Bin, error)</span></span></span></span> { bins := []*Bin{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(names) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bins, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } args := redis.Args{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, name := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> names { args = args.Add(storage.getKey(BIN_KEY, name)) } conn := storage.pool.Get() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> conn.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> values, err := redis.Values(conn.Do(<span class="hljs-string"><span class="hljs-string">"MGET"</span></span>, args...)); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { bytes := [][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = redis.ScanSlice(values, &amp;bytes); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, rawbin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bytes { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rawbin) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { bin := &amp;Bin{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := storage.Load(rawbin, bin); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { bins = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bins, bin) } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bins, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, almost everything is the same as in the previous method, except that the MGET command is used to obtain the data slice and the auxiliary method redis.ScanSlice to load the response into the slice of the desired type. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create Request Request </font></font></h5><br><pre> <code class="hljs pgsql">func (<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> *RedisStorage) CreateRequest(bin *Bin, req *Request) (err error) { data, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.Dump(req) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } conn := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.pool.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>() defer conn.<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>() key := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.getKey(REQUESTS_KEY, bin.Name) conn.Send("LPUSH", key, req.Id) conn.Send("EXPIRE", key, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.binLifetime) key = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.getKey(REQUEST_HASH_KEY, bin.Name) conn.Send("HSET", key, req.Id, data) conn.Send("EXPIRE", key, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.binLifetime) conn.Flush() requestCount, err := redis.Int(conn.Receive()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> requestCount &lt; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.maxRequests { bin.RequestCount = requestCount } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { bin.RequestCount = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.maxRequests } bin.Updated = <span class="hljs-type"><span class="hljs-type">time</span></span>.Now().Unix() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> requestCount &gt; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.maxRequests * CLEANING_FACTOR { conn.<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span>("SADD", <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.getKey(CLEANING_SET), bin.Name) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.UpdateBin(bin); err != nil { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we save the request ID to the request list for bin.Name, then save the serialized request to a hash table. </font><font style="vertical-align: inherit;">Do not forget in both cases add time to life. </font><font style="vertical-align: inherit;">The LPUSH command returns the number of entries in the requestCount list; if this number exceeds the maximum multiplied by a factor, then add this Bin to the candidates for the next cleanup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The receipt of the request and the list of requests are made by analogy with Bin objects.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cleaning </font></font></h5><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *RedisStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { conn := storage.pool.Get() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> conn.Close() binName, err := redis.String(conn.Do(<span class="hljs-string"><span class="hljs-string">"SPOP"</span></span>, storage.getKey(CLEANING_SET))) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } conn.Send(<span class="hljs-string"><span class="hljs-string">"LRANGE"</span></span>, storage.getKey(REQUESTS_KEY, binName), storage.maxRequests, <span class="hljs-number"><span class="hljs-number">-1</span></span>) conn.Send(<span class="hljs-string"><span class="hljs-string">"LTRIM"</span></span>, storage.getKey(REQUESTS_KEY, binName), <span class="hljs-number"><span class="hljs-number">0</span></span>, storage.maxRequests<span class="hljs-number"><span class="hljs-number">-1</span></span>) conn.Flush() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> values, error := redis.Values(conn.Receive()); error == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { ids := []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := redis.ScanSlice(values, &amp;ids); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { args := redis.Args{}.Add(storage.getKey(REQUEST_HASH_KEY, binName)).AddFlat(ids) conn.Do(<span class="hljs-string"><span class="hljs-string">"HDEL"</span></span>, args...) } } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike MemoryStorage, here we clear redundant requests, since the lifetime is limited by the radish command EXPIRE. First, we take an element from the list for purging, request identifiers of requests for it that are not included in the limit, and use the LTRIM command to compress the list to the size we need. We remove previously obtained identifiers from the hash table using the HDEL command, which accepts several keys at once. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have finished describing RedisStorage, next to it, in the redis_test.go file you will find the same tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, let's add the ability to select the storage when launching our application, in the api.go file:</font></font><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisConfig</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisAddr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisPassword</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisPrefix</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Config</span></span></span><span class="hljs-class"> struct { ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisConfig</span></span></span><span class="hljs-class"> } func </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetApi</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Config</span></span></span><span class="hljs-class">) *martini.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ClassicMartini</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">storage</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class">{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">redis</span></span></span><span class="hljs-class">": </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">redisStorage</span></span></span><span class="hljs-class"> := </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewRedisStorage</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisAddr</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisPassword</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RedisPassword</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MAX_REQUEST_COUNT</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BIN_LIFETIME</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">redisStorage</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StartCleaning(60)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">storage</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">redisStorage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memoryStorage</span></span></span><span class="hljs-class"> := </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewMemoryStorage</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MAX_REQUEST_COUNT</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BIN_LIFETIME</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memoryStorage</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StartCleaning(60)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">storage</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memoryStorage</span></span></span><span class="hljs-class"> } ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have added a new Storage field to our configuration structure and, depending on it, initialized with either RedisStorage or MemoryStorage. </font><font style="vertical-align: inherit;">Also added a RedisConfig configuration for specific radish options. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will also make changes in the main.go file launched:</font></font><br><pre> <code class="hljs lua">import ( <span class="hljs-string"><span class="hljs-string">"skimmer"</span></span> <span class="hljs-string"><span class="hljs-string">"flag"</span></span> ) var ( <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> = skimmer.Config{ SessionSecret: <span class="hljs-string"><span class="hljs-string">"secret123"</span></span>, RedisConfig: skimmer.RedisConfig{ RedisAddr: <span class="hljs-string"><span class="hljs-string">"127.0.0.1:6379"</span></span>, RedisPassword: <span class="hljs-string"><span class="hljs-string">""</span></span>, RedisPrefix: <span class="hljs-string"><span class="hljs-string">"skimmer"</span></span>, }, } ) func init() { flag.StringVar(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.Storage, <span class="hljs-string"><span class="hljs-string">"storage"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"available storages: redis, memory"</span></span>) flag.StringVar(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.SessionSecret, <span class="hljs-string"><span class="hljs-string">"sessionSecret"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.SessionSecret, <span class="hljs-string"><span class="hljs-string">""</span></span>) flag.StringVar(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisAddr, <span class="hljs-string"><span class="hljs-string">"redisAddr"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisAddr, <span class="hljs-string"><span class="hljs-string">"redis storage only"</span></span>) flag.StringVar(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisPassword, <span class="hljs-string"><span class="hljs-string">"redisPassword"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisPassword, <span class="hljs-string"><span class="hljs-string">"redis storage only"</span></span>) flag.StringVar(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisPrefix, <span class="hljs-string"><span class="hljs-string">"redisPrefix"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.RedisPrefix, <span class="hljs-string"><span class="hljs-string">"redis storage only"</span></span>) } func main() { flag.Parse() api := skimmer.GetApi(&amp;<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>) api.Run() }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use the </font></font><a href="http://golang.org/pkg/flag/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> package </font><font style="vertical-align: inherit;">, which makes it easy to add startup parameters for programs. </font><font style="vertical-align: inherit;">Add the ‚Äústorage‚Äù flag to the init function, which will store the value directly in our config in the Storage field. </font><font style="vertical-align: inherit;">Also add the launch options for radish.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The init function is special for Go, it is always executed when the package is loaded. </font><font style="vertical-align: inherit;">Learn more about </font></font><a href="http://golang.org/ref/spec"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">running programs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Go.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, by running our program with the --help parameter, we will see a list of available parameters: </font></font><br><br><pre> <code class="hljs mel">&gt; go run ./src/main.go --<span class="hljs-keyword"><span class="hljs-keyword">help</span></span> Usage of .../main: -redisAddr=<span class="hljs-string"><span class="hljs-string">"127.0.0.1:6379"</span></span>: redis storage only -redisPassword=<span class="hljs-string"><span class="hljs-string">""</span></span>: redis storage only -redisPrefix=<span class="hljs-string"><span class="hljs-string">"skimmer"</span></span>: redis storage only -sessionSecret=<span class="hljs-string"><span class="hljs-string">"secret123"</span></span>: -storage=<span class="hljs-string"><span class="hljs-string">"memory"</span></span>: available storages: redis, <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have an application, which is still quite raw, and not optimized, but already ready for work and launch on servers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the third part, we will talk about displaying and running the application in GAE, Cocaine and Heroku, as well as how to distribute it as a single executable file containing all the resources. </font><font style="vertical-align: inherit;">We will write performance tests, while at the same time doing optimization. </font><font style="vertical-align: inherit;">Let's learn how to proxy requests and respond to the right data. </font><font style="vertical-align: inherit;">And finally, let's build the groupcache distributed database right inside the application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would welcome any changes and suggestions on the article.</font></font></div><p>Source: <a href="https://habr.com/ru/post/214425/">https://habr.com/ru/post/214425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214409/index.html">How I Quest (now Dell) implemented Foglight</a></li>
<li><a href="../214411/index.html">My acquaintance with WM Awesome. Part 1</a></li>
<li><a href="../214417/index.html">Bitrix24 CRM - a powerful weapon in the battle of sales</a></li>
<li><a href="../214419/index.html">Runet in pictures XIII. Electronic wallets in RuNet</a></li>
<li><a href="../214421/index.html">The ideal IT company. How to assemble a team of programmers from geeks</a></li>
<li><a href="../214427/index.html">iStodo: cross-platform organizer for students</a></li>
<li><a href="../214431/index.html">Block free SD recording on Android 4.4 devices</a></li>
<li><a href="../214433/index.html">As a messenger Line can be used to promote mobile games</a></li>
<li><a href="../214435/index.html">Apply Apache POI, docx4j and springframework.jdbc</a></li>
<li><a href="../214439/index.html">Network Services Windows 2012 - DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>