<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distribution of static content - an account for milliseconds</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="8 years ago I wrote an article about accelerating the distribution of static content , it attracted some habrachiteli and remained relevant for a long...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distribution of static content - an account for milliseconds</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/65a/86c/957/65a86c957193f2c459fe6bb0cf54276b.jpg" alt="image" hspace="5"><br><br>  8 years ago I wrote an article about <a href="https://habrahabr.ru/post/108958/">accelerating the distribution of static content</a> , it attracted some habrachiteli and remained relevant for a long time. <br><br>  And so we decided to accelerate what works so fast and, at the same time, to share the experience of what happened in the end.  Of course, I will talk about rakes, about where <b>HTTP / 2 is not needed</b> , why we buy 7.6Tb <b>NVMe SSD</b> instead of <b>8x1Tb SATA SSD</b> and a lot of other highly specialized information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's immediately agree that the storage and distribution of content is 2 different tasks and we will only talk about distribution (advanced cache) <br><br>  Let's start with iron ... <br><a name="habracut"></a><br><h2>  NVMe SSD </h2><br>  As you already understood, we will keep up with progress and use modern 7.68 TB SSD HGST Ultrastar SN260 {HUSMR7676BHP3Y1} NVMe, HH-HL AIC to store the cache.  Screw tests show not such a beautiful picture as in marketing materials, but quite optimistic <br><br><pre><code class="bash hljs">[root@4 www]<span class="hljs-comment"><span class="hljs-comment"># hdparm -Tt --direct /dev/nvme1n1 /dev/nvme1n1: Timing O_DIRECT cached reads: 2688 MB in 2.00 seconds = 1345.24 MB/sec Timing O_DIRECT disk reads: 4672 MB in 3.00 seconds = 1557.00 MB/sec [root@4 www]# hdparm -Tt /dev/nvme1n1 /dev/nvme1n1: Timing cached reads: 18850 MB in 1.99 seconds = 9452.39 MB/sec Timing buffered disk reads: 4156 MB in 3.00 seconds = 1385.08 MB/sec</span></span></code> </pre> <br>  Of course, you choose the size and the manufacturer ‚Äúfor yourself‚Äù, you can also consider the SATA interface, but we write about what you should strive for :) <br><br>  If you still chose NVMe, for obtaining info about the screw, install the nvme-cli package and look at the characteristics of our ‚Äúworkhorse‚Äù <br><br><pre> <code class="bash hljs">[root@4 www]<span class="hljs-comment"><span class="hljs-comment"># nvme smart-log /dev/nvme1n1 Smart Log for NVME device:nvme1n1 namespace-id:ffffffff critical_warning : 0 temperature : 35 C available_spare : 100% available_spare_threshold : 10% percentage_used : 0% data_units_read : 158 231 244 data_units_written : 297 968 host_read_commands : 45 809 892 host_write_commands : 990 836 controller_busy_time : 337 power_cycles : 18 power_on_hours : 127 unsafe_shutdowns : 14 media_errors : 0 num_err_log_entries : 10 Warning Temperature Time : 0 Critical Composite Temperature Time : 0 Temperature Sensor 1 : 35 C Temperature Sensor 2 : 27 C Temperature Sensor 3 : 33 C Temperature Sensor 4 : 35 C</span></span></code> </pre><br>  As you can see, the screw feels great, looking ahead to say that under load the temperature condition is maintained within the same limits. <br><br>  During peak periods, we distribute about <b>4000 / photo per second</b> (photo size is about 10-100K), at half of such a load iostat does not rise more than <b>0.1%</b> , there is still RAM plays a big role, but I'll write about it) <br><br>  A few words about why we are now betting on expensive NVMe, instead of a bag of cheap SATA SSDs.  We conducted tests that show that with a similar server architecture, RAM and the same load, for example, the Ultrastar SN260 7.68TB NVMe works with 10 times less iowait than 8xSamsung SSD 850 PRO 1TB in Stripped RAID with Areca ARC-1882 Raid Controller PCI.  On servers there is a slight difference in the number of cores with NVMe 26, with ARC-1882 24 cores, the number of RAM 128G there and there.  Unfortunately, there is no way to compare the power consumption on these servers.  It was possible to measure the power consumption of the NVMe platform with a similarly designed system on AMD processors with software Stripped RAID from 8xINTEL SSDSC2BB480G4 480G and ARC-1680 Raid Controller PCI controller on 24 AMD Opteron (tm) Processor 6174 cores, with the same load, the new system eats 2.5 times less energy than 113 Watts against 274 Watts on AMD.  Well, the CPU load and iowait there are also an order of magnitude smaller (AMD does not have hardware encryption) <br><br><h2>  File system </h2><br>  8 years ago we used <b>btrfs</b> , tried XFS, but ext4 on a large parallel load behaves more lively, so our choice is ext4.  Correct tuning ext4, can further increase the already excellent performance of this fs. <br>  Optimization starts from the moment of formatting, for example, if you mainly distribute 1-5K files, you can slightly reduce the block size when formatting: <br><br><pre> <code class="bash hljs">mkfs.ext4 -b 2048 /dev/sda1</code> </pre><br>  or even <br><br><pre> <code class="bash hljs">mkfs.ext4 -b 1024 /dev/sda1</code> </pre><br>  To find out the current block size on the file system, use: <br><br><pre> <code class="bash hljs">tune2fs -l /dev/sda1 | grep Block</code> </pre><br>  or <br><br><pre> <code class="bash hljs">[root@4 www]<span class="hljs-comment"><span class="hljs-comment"># fdisk -l /dev/nvme1n1  /dev/nvme1n1: 7681,5 , 7681501126656 —ñ, 1875366486 —ñ —ñ = —ñ  1 * 4096 = 4096 —ñ —ñ  (—ñ/—ñ): 4096 —ñ / 4096 —ñ —ñ - (—ñ—ñ/): 4096 —ñ / 4096 —ñ  —ñ : dos –Ü—ñ : 0x00000000</span></span></code> </pre><br>  Since on our NVMe SSD sector size is 4k, the block size is less than optimal to do less than this value, formatting: <br><br><pre> <code class="bash hljs">mkfs.ext4 /dev/nvme1n1</code> </pre><br>  Please note that I did not partition the disk, but format it with a whole block device.  For OS, I use another SSD and there is a breakdown.  In the file system, you can mount it as <b>/ dev / nvme1n1</b> <br><br>  It is advisable to mount the disk in such a way as to squeeze the maximum speed out of it. To do this, disable all unnecessary, we will mount with the <b>‚Äúnoatime, barrier = 0‚Äù</b> option, if the <b>atime</b> attribute is important to you, in kernel 4 and above there is the <b>lazytime</b> option, it keeps the <b>atime</b> value in RAM and partially solves the problem of frequent access time updates while reading. <br><br><h2>  Ram </h2><br>  If your static is placed in RAM, forget about all the above and enjoy the distribution of files from RAM. <br><br>  When distributing from RAM, the OS itself often delays the requested files into its cache and you do not need to configure anything for this, but if the device on which files are stored is slow and there are a lot of files (hundreds of thousands), it can happen that the OS simultaneously requests many files from the file system and your storage device at the same time will begin to greatly ‚Äúslow down‚Äù.  You can try to solve this problem as follows, load the static onto the RAM disk and distribute it from it. <br><br>  An example of creating a RAM disk: <br><br><pre> <code class="bash hljs">mount -t tmpfs -o size=1G,mode=0700,noatime tmpfs /cache</code> </pre><br>  if you forgot with what parameters you mounted, then you can see with findmnt: <br><br><pre> <code class="bash hljs">findmnt --target /cache</code> </pre><br><br>  You can remount without rebooting: <br><br><pre> <code class="bash hljs">mount -o remount,size=4G,noatime /cache</code> </pre><br>  You can also combine the part in RAM (some often often requested thumbnails) the rest on the SSD. <br><br>  In nginx it will look something like this: <br><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/cache/ram; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> <span class="hljs-variable"><span class="hljs-variable">@cache1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@cache1</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/cache/ssd; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> <span class="hljs-variable"><span class="hljs-variable">@storage</span></span>; }</code> </pre><br>  If the content in the RAM does not fit, you have to trust the kernel, we put 128G RAM at the size of the active cache 3-5G and think about increasing to 256G. <br><br><h2>  CPU </h2><br>  There are no special requirements for the frequency of the processor, rather there is a requirement for functionality: if your traffic will need to be encrypted (for example, via the https protocol), it is important to choose a processor that will support AES-NI hardware encryption (Intel Advanced Encryption Standard). <br><br>  On Linux, you can verify that the processor supports AES-NI instructions with the command <br><br><pre> <code class="bash hljs">grep -m1 -o aes /proc/cpuinfo aes</code> </pre><br>  If there is no output "aes", then the processor does not support such instructions and encryption will devour the performance of the processor. <br><br><h2>  We configure nginx </h2><br>  General ideas are described in the <a href="https://habrahabr.ru/post/108958/">previous article</a> , but still there are a few points on optimization, I will tell about them now: <br><br><ul><li>  We avoid rewright at the top level of the server directive, we don‚Äôt welcome regular expressions in the location sections.  If without this, then at least try to wrap the regular season in a normal location, for example: <br><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /example/dir { <span class="hljs-attribute"><span class="hljs-attribute">rewrite</span></span><span class="hljs-regexp"><span class="hljs-regexp"> ^/example/dir(.*)</span></span> /newexample/<span class="hljs-variable"><span class="hljs-variable">$1</span></span>; }</code> </pre><br>  If this is not done, then the regular schedule will be applied for each request to the distribution system, and in our example the fitting of the regular redirect will occur only when the path to the photo starts at <b>/ example / dir</b> <br></li><li>  When storing content in the cache, follow the rule not to delete more than 255 files or folders in one folder (if you formatted a disk with ‚Äúdefault‚Äù settings with a 4K block size), 128 if 2K, etc. <br></li><li>  We put a new core, preferably not below 4.1.  In nginx, do not forget to <a href="https://habrahabr.ru/post/259403/">enable SO_REUSEPORT support.</a> This directive positively affects the parallel download of files from the distribution server. </li><li>  We place the server closer to your users, so we make happier users and know this and are appreciated by search engines. </li></ul><br><h2>  What about cdn </h2><br>  CDN is good, if you work for different countries, you have a lot of content and little traffic, but if there is a lot of traffic, there is little content, and you work for a specific country, then it makes sense to calculate everything and understand what is more profitable for you.  For example, we are working on the Ukrainian market, many world leaders providing the CDN service do not have servers in Ukraine, and distribution comes from Germany or Poland.  So we get instead of + 3-5ms - + 30-50ms to the answer on level ground.  <a href="https://www.colocall.net/ru/colocation/colocation-dedicated.html">Placing a 2U server in a good Ukrainian DC starts from $ 18</a> + payment per channel, for example, 100Mbps - $ 10 totaling $ 28.  The commercial price of distributing <a href="https://hostpro.ua/ua/cdn.html">CDN traffic in Ukraine is about $ 0.05 / G</a> , i.e.  if we distribute more than 560G / month, then we can already consider the option of self-distribution.  RIA.com services distribute several terabyte statics per day, and therefore we have long ago made decisions about self-distribution. <br><br><h2>  How to be friends with search engines </h2><br>  For many search engines, the important characteristics are TTFB (time to first byte) and how ‚Äúclose‚Äù the content is to the person who is looking for it, besides, texts in links to content, description in Exif tags, uniqueness, size of content, etc. are important. .d <br>  All about what I am writing here, mainly in order to protjunit TTFB and be closer to the user.  You can use the User-Agent trick to detect search bots and give them content from a separate server in order to eliminate ‚Äújams‚Äù or ‚Äúslowing down during peak periods‚Äù (usually bots give a uniform load), thus making the search engines happy not by the user .  We do not do that, besides there is a suspicion that Google Chrome and Yandex Browser trust the information that browsers provide them about the speed of loading your pages from the perspective of the client. <br><br>  It is also worth noting that the load from different bots can be so substantial that you have to spend almost half the resources on servicing these bots.  RIA.com projects serve about 10-15 million requests from bots per day (this includes not only static messages but also regular pages), which is not much less than the number of requests from real users. <br><br><h2>  Optimization for distributing static content </h2><br>  Well, if the distribution process is already set up - it's time to think about what can be done with the content itself, so that it is more accessible, loads faster, takes up less space, is attractive to search engines. <br><br><ul><li>  The first thing you should pay attention to is the photo format: it turns out that jpeg, which is very popular for many projects, is already inferior in size with comparable quality to newer formats on the Web, such as the WebP format that Google has been promoting since 2010.  According to various sources, we get 20-30% less size, with equal quality.  At the same time, you can also use a special tag on the client that allows you to describe several formats that the browser can display and if the browser does not support the WebP format, it will load, for example, jpeg <br>  Also a little about SEO requirements: <br><br><ul><li>  You have already done part of SEO optimization by placing the distribution server closer to the client and accelerating its return. </li><li>  A few words about exif-tags, many of them cut out when scaling a photo - in vain!  Google also analyzes this information, why not indicate for the photo what is depicted on the photo in the exif-tag ImageDescription, or in the exif-tag Copyright not to enter the copyright to your content, if of course it is yours :) </li><li>  Do not forget about HTTP headers, which indicate different useful meta-information about the content file.  For example, using the Expires header, you can specify the storage time of the content in the browser cache. </li></ul><br>  If your site works using the HTTP / 2 protocol, then it is worth experimenting with the following optimizations: <br><br><ul><li>  You can stop using css sprites, since multiplexing the transfer of small files over a single connection can compensate for the gain that is usually achieved with http / 1.1 using this optimization. </li><li>  Try <a href="http2-server-push/">web-push technology</a> , note that this method of optimizing downloads does not take into account the content of the browser in the cache, which is fired, but this is solved using cookies and simple nginx settings, as shown in the example <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl http2 default_server; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> ssl/certificate.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> ssl/key.pem; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; <span class="hljs-attribute"><span class="hljs-attribute">http2_push_preload</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> = /demo.html { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Set-Cookie <span class="hljs-string"><span class="hljs-string">"session=1"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Link <span class="hljs-variable"><span class="hljs-variable">$resources</span></span>; } } <span class="hljs-attribute"><span class="hljs-attribute">map</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_cookie</span></span> <span class="hljs-variable"><span class="hljs-variable">$resources</span></span> { "~*session=1" ""; <span class="hljs-attribute"><span class="hljs-attribute">default</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/style.css&gt;; as=style; rel=preload, &lt;/image1.jpg&gt;; as=image; rel=preload, &lt;/image2.jpg&gt;; as=style; rel=preload"</span></span>; }</code> </pre><br></li><li>  From our experience, distribution of content is best done with a domain name different from the main domain of the project. </li></ul><br><h2>  Mysterious HTTP / 2 </h2><br>  As you know HTTP / 2 multiplexes one connection, through which several files are transmitted, while prioritizing the sending of a file, header compression and other advantages of the new protocol are possible, but there are also disadvantages that few people write about.  I‚Äôll come from afar: maybe there are some older hackers who remember the Internet before the uTorrent era, many of you had to use flashget, download master, etc. rocking chairs. Do you remember how they worked?  They downloaded one file in 6 or 8 streams, opening 6-8 connections with the giving server.  Why did they do that?  After all, a channel with a distributing and receiving server should not depend on the number of connections between them, but in fact this dependence exists if the channel is bad, with packet loss and packet transmission errors.  It turns out that with such alignments, in several threads swings faster.  In addition, if a channel is used by several clients, then an increase in the number of connections from one client helps to get more bandwidth in the channel and drag the ‚Äúblanket of resources‚Äù to itself.  Of course, this is not always the case, but still there is a threat to get a ‚Äúcompeting‚Äù competitor in the form of a browser using the http / 1.1 protocol, which will open 6 connection points to one site, instead of 1 via http2.  In my practice, there was a case with a ‚Äúphoto hosting website wallpaper‚Äù type site, which refused http / 2, for the reason that the site on the http / 2 protocol slowed down noticeably, without visible load on the server itself, the guys stayed on https, but switched on http / 1.1 and the situation is resolved. <br><br>  I would experiment with getting content from different domains (but actually from the same server), this technique is called domain sharding, perhaps as one could get out of the situation without giving up http / 2 and forcing the browser to install as many connections as the site administrator needs. <br><br><h2>  Instead of conclusion </h2><br>  The moment when the site starts to slow down can not be called unpleasant, because you feel that traffic is growing, customers become more.  We never set ourselves the task of avoiding ‚Äúbrakes‚Äù, we learned to respond quickly to this growth.  Optimization of speed is an endless process, do not deny yourself the pleasure of competing with your competitors in the art of being fast! </li></ul></div><p>Source: <a href="https://habr.com/ru/post/353672/">https://habr.com/ru/post/353672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353660/index.html">Experience of implementing "Continent TLS VPN" in a cluster configuration</a></li>
<li><a href="../353662/index.html">How I passed the test task for the summer internship in Yandex</a></li>
<li><a href="../353664/index.html">Impose flex-calendar</a></li>
<li><a href="../353666/index.html">How we broke Glusterfs</a></li>
<li><a href="../353668/index.html">Interfaces: how to tell the user if ‚ÄúOops, something went wrong‚Äù</a></li>
<li><a href="../353674/index.html">Divorce as it is (or "confirmation confirmation discord!")</a></li>
<li><a href="../353676/index.html">Attention! S in Ethereum stands for Security. Part 4. Tools</a></li>
<li><a href="../353678/index.html">Reverse engineering "Kazakov 3", part of the network: create a local server</a></li>
<li><a href="../353680/index.html">Distributed control system based on SoC FPGA</a></li>
<li><a href="../353682/index.html">DevConf: Uber transition from PostgreSQL to MySQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>