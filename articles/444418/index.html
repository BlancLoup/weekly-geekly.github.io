<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Millions of binaries later. How to get stronger Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR . In this article, we explore hardening schemes that work out of the box in five popular Linux distributions. For each, we took the default ker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Millions of binaries later. How to get stronger Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/43f/b35/8ca/43fb358cac8e2bec978126698b7d2ece.png" align="left" width="340">  <b>TL; DR</b> .  In this article, we explore hardening schemes that work out of the box in five popular Linux distributions.  For each, we took the default kernel configuration, loaded all the packages, and analyzed the protection schemes in the nested binary files.  OpenSUSE 12.4, Debian 9, CentOS, RHEL 6.10 and 7 distributions, as well as Ubuntu 14.04, 12.04 and 18.04 LTS are considered. <br><br>  The results confirm that even basic schemes, such as stack canaries and position-independent code, are not yet used by everyone.  The situation is even worse for compilers when it comes to protecting against vulnerabilities like stack clash, which hit the spotlight in January after publishing <a href="https://capsule8.com/blog/exploiting-systemd-journald-part-1/">vulnerability information in systemd</a> .  But not everything is so hopeless.  In large part of the binaries, basic protection methods are implemented, and their number is growing from version to version. <br><br>  The audit showed that the largest number of protection methods is implemented in Ubuntu 18.04 at the OS and application level, followed by Debian 9. On the other hand, in OpenSUSE 12.4, CentOS 7 and RHEL 7 the basic protection schemes are also implemented, and stack collision protection is applied even more widely with a much tighter set of packages by default. <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  It is difficult to provide high quality software.  Despite the huge number of advanced tools for static code analysis and dynamic analysis at runtime, as well as significant progress in the development of compilers and programming languages, modern software still suffers from vulnerabilities that are constantly exploited by hackers.  The situation is even worse in ecosystems that include outdated code.  In such cases, we are not only confronted with the eternal problem of finding possible exploitable errors, but are also limited by rigid backward compatibility frameworks, which often require maintaining a limited, and even worse, vulnerable or buggy code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is where hardening comes into play.  We cannot prevent some types of errors, but we can make the attacker's life more difficult and partially solve the problem by preventing or preventing the <i>operation of</i> these errors.  Such protection is used in all modern operating systems, but the methods vary greatly in complexity, efficiency and performance: from stack canaries (stack canaries) and <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> to full-fledged protection <a href="https://en.wikipedia.org/wiki/Control-flow_integrity">CFI</a> and <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a> .  In this article, we will look at what protection methods are used in the most popular Linux distributions in the default configuration, and also examine the properties of binaries that are distributed through the package management systems of each distribution. <br><br><h3>  CVE and security </h3><br>  We all have seen articles with titles like ‚ÄúThe Most Vulnerable Applications of the Year‚Äù or ‚ÄúThe Most Vulnerable Operating Systems.‚Äù  Usually, statistics on the total number of records of vulnerabilities such as <a href="https://cve.mitre.org/">CVE (Common Vulnerability and Exposures)</a> obtained from the <a href="https://nvd.nist.gov/">National Vulnerability Database (NVD)</a> from <a href="https://www.nist.gov/">NIST</a> and other sources are given there.  Subsequently, these applications or operating systems are ranked by the number of CVEs.  Unfortunately, although CVE is very useful in tracking down problems and informing vendors and users, they say little about the real security of software. <br><br>  For example, consider the total number of CVEs over the past four years for the Linux kernel and the five most popular server distributions, namely, Ubuntu, Debian, Red Hat Enterprise Linux, and OpenSUSE. <br><br><img src="https://habrastorage.org/webt/3_/pt/md/3_ptmdzx313ayxw3xpi0udnlbdq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">one</font></i> <br><br>  What does this chart tell us?  Does a greater number of CVEs mean that one distribution is more vulnerable than another?  No answer.  For example, in this article you will see that Debian implements tougher protection mechanisms compared to, say, OpenSUSE or RedHat Linux, and yet Debian has more CVE.  However, they do not necessarily mean weakened security: even the presence of a CVE does not indicate whether the vulnerability is <i>exploitable</i> .  The severity scores give an idea of ‚Äã‚Äãhow <i>likely the</i> exploit is to exploit, but ultimately exploitation depends to a large extent on the protection present in the affected systems, as well as on the resources and capabilities of the intruders.  Moreover, the lack of CVE reports says nothing about other <i>unregistered or unknown</i> vulnerabilities.  The difference in CVE can be explained not by software quality, but by other factors, including the resources allocated for testing, or the size of the user base.  In our example, more CVE from Debian may simply indicate that Debian ships more software packages. <br><br>  Of course, the CVE system provides useful information that allows you to create appropriate protections.  The better we understand the causes of a program crash, the easier it is to identify possible methods of operation and develop appropriate <i>detection and response</i> mechanisms.  In fig.  2 shows the categories of vulnerabilities for all distributions over the past four years ( <a href="https://www.cvedetails.com/top-50-products.php">source</a> ).  It is immediately obvious that most CVEs fall into the following categories: denial of service (DoS), code execution, overflow, memory corruption, information leakage (exfiltration), and privilege escalation.  Although many CVEs are counted several times in different categories, in general, the same problems persist year after year.  In the next part of the article, we will evaluate the use of various protection schemes to prevent the exploitation of these vulnerabilities. <br><br><img src="https://habrastorage.org/webt/tr/92/pc/tr92pcngbl1y4qxt3shouu6wdi8.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2</font></i> <br><br><h3>  Tasks </h3><br>  In this article we intend to answer the following questions: <br><br><ul><li>  What is the security of various Linux distributions?  What security mechanisms exist in the kernel and user-space applications? <br></li><li>  How has the adoption of protection mechanisms for different distributions changed over time? <br></li><li>  What are the average dependencies of packages and libraries for each distribution? <br></li><li>  What protections are implemented for each binary? </li></ul><br><h3>  The choice of distros </h3><br>  It turns out that it is difficult to find accurate statistics on the installations of distributions, since in most cases the number of downloads does not indicate the number of real installations.  However, Unix variants constitute the majority of server systems (69.2% on web servers, according to <a href="https://w3techs.com/technologies/overview/operating_system/all">statistics from</a> W3techs and other sources), and their share is constantly growing.  Thus, for our research, we focused on the distributions available out of the box on the <a href="https://cloud.google.com/">Google Cloud</a> platform.  In particular, we have chosen the following OS: <br><br><table><tbody><tr><th>  Distribution / Version </th><th>  Core </th><th>  Bild </th></tr><tr><td>  OpenSUSE 12.4 </td><td>  4.12.14-95.3-default </td><td>  # 1 SMP Wed Dec 5 06:00:48 UTC 2018 (63a8d29) </td></tr><tr><td>  Debian 9 (stretch) </td><td>  4.9.0-8-amd64 </td><td>  # 1 SMP Debian 4.9.130-2 (2018-10-27) </td></tr><tr><td>  CentOS 6.10 </td><td>  2.6.32-754.10.1.el6.x86_64 </td><td>  # 1 SMP Tue Jan 15 17:07:28 UTC 2019 </td></tr><tr><td>  CentOS 7 </td><td>  3.10.0-957.5.1.el7.x86_64 </td><td>  # 1 SMP Fri Feb 1 14:54:57 UTC 2019 </td></tr><tr><td>  Red Hat Enterprise Linux Server 6.10 (Santiago) </td><td>  2.6.32-754.9.1.el6.x86_64 </td><td>  # 1 SMP Wed Nov 21 15:08:21 EST 2018 </td></tr><tr><td>  Red Hat Enterprise Linux Server 7.6 (Maipo) </td><td>  3.10.0-957.1.3.el7.x86_64 </td><td>  # 1 SMP Thu Nov 15 17:36:42 UTC 2018 </td></tr><tr><td>  Ubuntu 14.04 (Trusty Tahr) </td><td>  4.4.0‚Äì140-generic </td><td><br>  # 166 ~ 14.04.1-Ubuntu SMP Sat Nov 17 01:52:43 UTC 20 ... </td></tr><tr><td>  Ubuntu 16.04 (Xenial Xerus) </td><td>  4.15.0‚Äì1026-gcp </td><td>  # 27 ~ 16.04.1-Ubuntu SMP Fri Dec 7 09:59:47 UTC 2018 </td></tr><tr><td>  Ubuntu 18.04 (Bionic Beaver) </td><td>  4.15.0‚Äì1026-gcp </td><td>  # 27-Ubuntu SMP Thu Dec 6 18:27:01 UTC 2018 </td></tr></tbody></table>  <i><font color="gray">Table 1</font></i> <br><br><h1>  Analysis </h1><br>  Let us study the default kernel configuration, as well as the properties of the packages available through the package manager of each distribution kit out of the box.  Thus, we consider only packages from the default mirrors of each distribution, ignoring packages from unstable repositories (for example, 'testing' mirrors in Debian) and third-party packages (for example, Nvidia packages from standard mirrors).  In addition, we do not consider custom kernel compilations or configurations with enhanced security. <br><br><h3>  Kernel configuration analysis </h3><br>  We applied the analysis script based on the <a href="https://github.com/a13xp0p0v/kconfig-hardened-check">free kconfig checker</a> .  Consider the protection settings out of the box for the named distributions and compare them with the list from <a href="http://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings">the Kernel Self-Defense Project</a> (KSPP).  For each configuration parameter, table 2 describes the desired setting: there is a check mark for distributions that correspond to KSSP recommendations (for an explanation of the terms, see <a href="https://capsule8.com/blog/kernel-configuration-glossary/">here</a> ; in future articles we will describe how many of these protection methods appeared and how to hack the system in their absence). <br><br> <a href=""><img src="https://habrastorage.org/webt/dx/oh/o0/dxoho0z-lifjcybajszqb-aiirq.png"></a> <br><br><img src="https://habrastorage.org/webt/rm/or/h1/rmorh1jx8aswaj98ts0-7jptjmk.png"><br><br>  In general, the new kernels are more stringent settings out of the box.  For example, CentOS 6.10 and RHEL 6.10 on the 2.6.32 kernel do not have most of the critical functions implemented in new kernels, such as <a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention">SMAP</a> , strict RWX permissions, address randomization, or copy2usr protection.  It should be noted that many of the configuration options from the table are missing in older kernel versions and are not applicable in reality - in the table this is still indicated as a lack of adequate protection.  Similarly, if the configuration parameter is not present in this version, and for security, this parameter must be disabled, this is considered a reasonable configuration. <br><br>  Another point in interpreting the results: some kernel configurations that increase the attack surface can also be used for security.  Examples include uprobes and kprobes, kernel modules and BPF / eBPF.  Our recommendation is to use the above mechanisms to provide real protection, since they are non-trivial to use, and their operation assumes that the malicious actors are already entrenched in the system.  But if these options are enabled, the system administrator should actively monitor abuse. <br><br>  Studying further the entries in Table 2, we see that modern kernels provide several options for protecting exploitation of such vulnerabilities as information leakage and stack / heap overflow.  However, we notice that even the most recent popular distributions have not yet implemented more complex protection (for example, with <a href="https://grsecurity.net/">grsecurity</a> patches) or modern protection against code reuse attacks (for example, a <a href="http://www.cs.columbia.edu/~theofilos/files/slides/krx.pdf">combination of randomization with R ^ X schemes for code</a> ).  Worse, even these more advanced defenses do not protect against the full range of attacks.  Thus, it is extremely important for system administrators to complement intelligent configurations with solutions that offer detection and prevention of exploits at runtime. <br><br><h3>  Application analysis </h3><br>  Not surprisingly, different distributions have different package characteristics, compilation options, library dependencies, etc. Differences exist even for <a href="">related</a> distributions and packages with a small number of dependencies (for example, coreutils in Ubuntu or Debian).  To assess the differences, we downloaded all the available packages, extracted their contents, and analyzed the binary files and dependencies.  For each package, we tracked other packages on which it depends, and for each binaries we tracked its dependencies.  This section summarizes the findings. <br><br><h4>  Distributions </h4><br>  In total, we downloaded 361,556 packages for all distributions, extracting only packages from mirrors by default.  We ignored packages without ELF executable files, such as source codes, fonts, etc. After filtering, 129,569 packages remain, containing a total of 584,457 binary files.  Distribution of packages and files by distributions is shown in fig.  3 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9d/8fc/bbf/f9d8fcbbf2ac0887f4948e1e49446e9a.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3</font></i> <br><br>  It can be noted that the more modern the distribution kit is, the more packages and binary files it contains, which is logical.  At the same time, Ubuntu and Debian packages include much more binary files (both executable and dynamic modules and libraries) than CentOS, SUSE and RHEL, which potentially affects the attack surface of Ubuntu and Debian (it should be noted that the numbers reflect all binary versions of all package, that is, some files are analyzed several times).  This is especially important when considering the dependencies between packages.  Thus, the vulnerability in the binary of one package can affect many parts of the ecosystem, as a vulnerable library can affect all binary files importing it.  As a point of reference, we will look at the distribution of the number of dependencies among packages in different operating systems: <br><br> <a href=""><img src="https://habrastorage.org/webt/ii/e3/e5/iie3e5-ei26ezg5yvcyvtzqzl80.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">four</font></i> <br><br>  In almost all distributions, 60% of packages have at least 10 dependencies.  In addition, for some packages, the number of dependencies is much larger (more than 100).  The same applies to inverse dependencies of packages: as expected, several packages are used by many other packages in the distribution, therefore vulnerabilities in these few selected people are at high risk.  As an example, the following table lists the 20 packages with the maximum number of inverse dependencies in SLES, Centos 7, Debian 9, and Ubuntu 18.04 (each cell indicates the package and the number of inverse dependencies). <br><br><img src="https://habrastorage.org/webt/0g/hl/w0/0ghlw0dtmbb3vswp-xgtx1zs-lu.png"><br>  <i><font color="gray">Table 3</font></i> <br><br>  Interesting fact.  Although all analyzed OSs are built for x86_64 architecture, and for most packages, the architecture is defined as x86_64 and x86, but packages often contain binary files for other architectures, as shown in fig.  five. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4e/899/601/c4e899601e6fc711b224aba6b204c02a.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">five</font></i> <br><br>  In the next section, we delve into the characteristics of the binaries being analyzed. <br><br><h4>  Binary file protection statistics </h4><br>  As an absolute minimum, you need to examine the basic set of protection options for existing binary files.  Several Linux distributions come with scripts that perform such checks.  For example, in Debian / Ubuntu there is such a script.  Here is an example of his work: <br><br><pre><code class="bash hljs">$ hardening-check $(<span class="hljs-built_in"><span class="hljs-built_in">which</span></span> docker) /usr/bin/docker: Position Independent Executable: yes Stack protected: yes Fortify Source <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span>: no, only unprotected <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span> found! Read-only relocations: yes Immediate binding: yes</code> </pre> <br>  The script checks five <a href="http://manpages.ubuntu.com/manpages/trusty/man1/hardening-check.1.html">security functions</a> : <br><br><ul><li>  Position Independent Executable (PIE): indicates whether the text section of the program can be moved into memory to achieve randomization if ASLR is enabled in the kernel. <br></li><li>  Stack Protected: whether stack canaries are included to protect against stack collision attacks. <br></li><li>  Fortify Source: whether unsafe functions (for example, strcpy) are replaced by their more secure counterparts, and calls tested in runtime are replaced by their counterpartable ones (for example, memcpy instead of __memcpy_chk). <br></li><li>  Read-only relocations (RELRO): Whether the records in the relocation table are marked as read-only if they have worked before execution. <br></li><li>  Immediate binding: Does the runtime binder allow all moves before starting the program (this is equivalent to a full RELRO). </li></ul><br>  Are the above mechanisms sufficient?  Unfortunately not.  There are ways to circumvent all of the above defenses, but the more stringent the defense, the higher the bar for the attacker.  For example, <a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf">RELRO traversal methods are</a> more difficult to apply if PIE and immediate binding are in effect.  Similarly, a full ASLR requires additional work to create a working exploit.  However, sophisticated attackers are ready to meet such defenses: their absence will in fact speed up hacking.  Therefore, it is imperative that these measures are considered as a necessary <i>minimum</i> . <br><br>  We wanted to study how many binary files in the distributions in question are protected by these, as well as three more methods: <br><br><ul><li>  A non-executable bit ( <a href="https://en.wikipedia.org/wiki/Executable_space_protection">NX</a> ) prevents execution in any region that should not be executable, for example, on a stack heap, etc. </li><li>  <a href="https://en.wikipedia.org/wiki/Rpath">RPATH / RUNPATH</a> indicates the execution path used by the dynamic loader to search for relevant libraries.  The first is <i>mandatory</i> for any modern system: its absence allows attackers to write down the payload in memory and execute it as it is.  For the second, incorrect configurations of the execution path help in the introduction of an unreliable code, which can lead to a number of problems (for example, <a href="https://www.nth-dimension.org.uk/pub/BTL.pdf">escalation of privileges</a> , as well as <a href="https://wiki.debian.org/RpathIssue">other problems</a> ). </li><li>  Stack collision protection provides protection against attacks that cause the stack to overlap with other areas of memory (for example, a heap).  Given the recent exploits abusing <a href="https://capsule8.com/blog/exploiting-systemd-journald-part-1/">heap collision vulnerabilities in systemd</a> , we found it appropriate to include this mechanism in our data set. </li></ul><br>  So, without further ado, let's go over the numbers.  Tables 4 and 5 contain squeeze analysis of executable files and libraries of various distributions, respectively. <br><br><ul><li>  As you can see, NX protection is implemented everywhere, with rare exceptions.  In particular, it can be noted that its use is somewhat lower in Ubuntu and Debian distributions compared to CentOS, RHEL and OpenSUSE. <br></li><li>  Stacked canaries are absent in many places, especially in distributions with old kernels.  Some progress has been observed in the latest Centos, RHEL, Debian and Ubuntu distributions. <br></li><li>  With the exception of Debian and Ubuntu 18.04, most distros have poor PIE support. <br></li><li>  Stack collision protection is poorly implemented in OpenSUSE, Centos 7 and RHEL 7 and is almost absent from the rest. <br></li><li>  All distros with modern kernels have some support for RELRO, with Ubuntu 18.04 leading, and Debian ranks second. </li></ul><br>  As already mentioned, the metrics in this table are averages for all versions of a binary file.  If you only look at the latest versions of the files, the numbers will be different (for example, see <a href="http://outflux.net/debian/hardening/">Debian Progress using PIE</a> ).  Moreover, most distributions usually check the protection of only a few functions in binary code when calculating statistics, and our analysis shows the true percentage of fortified functions.  Therefore, if 5 out of 50 functions are protected in a binary, we will give it a grade of 0.1, which corresponds to 10% of fortified functions. <br><br><img src="https://habrastorage.org/webt/m-/fn/1l/m-fn1l_i9vp3-gh8sicmbnkintc.png"><br>  <i><font color="gray">Table 4. Protection characteristics for executable files shown in Fig.</font></i>  <i><font color="gray">3 (implementation of the relevant functions as a percentage of the total number of executable files)</font></i> <br><br><img src="https://habrastorage.org/webt/yt/y1/sa/yty1saotef9aqmxkik36r8iijus.png"><br>  <i><font color="gray">Table 5. Protection characteristics for the libraries shown in Fig.</font></i>  <i><font color="gray">3 (implementation of the corresponding functions as a percentage of the total number of libraries)</font></i> <br><br>  So is there any progress?  Definitely there: it can be seen from the statistics on individual distributions (for example, <a href="http://outflux.net/debian/hardening/">Debian</a> ), as well as from the tables above.  As an example in fig.  6 shows the introduction of defense mechanisms in three consecutive distributions of Ubuntu LTS 5 (we omitted the stack collision protection statistics).  We notice that from version to version more and more files support stack canaries, and also successively more and more binary files come with full RELRO protection. <br><br> <a href=""><img src="https://habrastorage.org/webt/d1/ni/or/d1niordj1hmiklmg2-w5rsk6dla.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">6</font></i> <br><br>  Unfortunately, a number of executable files in different distributions still do not have any of the above protection.  For example, looking at Ubuntu 18.04, you can see the ngetty binary (a replacement for getty), as well as the mksh and lksh shells, the picolisp interpreter, the nvidia-cuda-toolkit packages (a popular package for GPU-accelerated applications such as machine learning frameworks) and klibc -utils  Similarly, the mandos-client binary (an administrative tool that automatically restarts machines with encrypted file systems), as well as rsh-redone-client (re-implementation of rsh and rlogin) comes without NX protection, although they have SUID rights :(. In addition, several suid binaries do not have basic protection, such as stack canaries (for example, the Xorg.wrap binary file from the Xorg package). <br><br><h1>  Summary and Concluding Remarks </h1><br>  In this article, we have identified several security properties of modern Linux distributions.  The analysis showed that the latest Ubuntu LTS distribution (18.04) implemented on average the strongest protection of the OS level and applications among distributions with relatively new kernels, such as Ubuntu 14.04, 12.04 and Debian 9. However, the considered CentOS, RHEL and OpenSUSE distributions in our set Data defaults to a more dense set of packages, and in recent versions (CentOS and RHEL) have a higher percentage of stack collision protection implementations compared to competitors based on Debian (Debian and Ubuntu).  Comparing the versions of CentOS and RedHat, we notice big improvements in the implementation of stack canaries and RELRO from versions 6 to 7, but on average CentOS has more functions than RHEL.  In general, all distributions should pay particular attention to protecting PIE, which, with the exception of Debian 9 and Ubuntu 18.04, is implemented in less than 10% of the binary files from our data set. <br><br>  Finally, it should be noted: although we conducted a manual survey, there are many security tools (for example, <a href="https://cisofy.com/lynis/">Lynis</a> , <a href="https://www.nongnu.org/tiger/">Tiger</a> , <a href="https://github.com/hubblestack/hubble">Hubble</a> ) that perform the analysis and help avoid unsafe configurations.  Unfortunately, even strong protection in reasonable configurations does not guarantee the absence of exploits.  That is why we firmly believe that it is vital to ensure <a href="https://capsule8.com/">reliable monitoring and prevention of attacks in real time</a> , focusing on operating models and preventing them. </div><p>Source: <a href="https://habr.com/ru/post/444418/">https://habr.com/ru/post/444418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444406/index.html">Digital Italy. What and how it works</a></li>
<li><a href="../444408/index.html">Apple released a new iPad yesterday, and they have questions</a></li>
<li><a href="../444410/index.html">Network Maps. Overview of network mapping software</a></li>
<li><a href="../444414/index.html">Snapdragon 8cx: 7 nm PC Platform</a></li>
<li><a href="../444416/index.html">HyperX Alloy CORE - when the membrane can in games</a></li>
<li><a href="../444420/index.html">How to ride the two wheels to work</a></li>
<li><a href="../444422/index.html">As it was in 2018: Industrial FDM printing at Top 3D Expo</a></li>
<li><a href="../444426/index.html">Lyft and Uber go IPO. Why invest in Lyft?</a></li>
<li><a href="../444428/index.html">Mountain Car: solve the classic problem with the help of training with reinforcements</a></li>
<li><a href="../444430/index.html">Parsing: how to properly use Present Perfect in English</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>