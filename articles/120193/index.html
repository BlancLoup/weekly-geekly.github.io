<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics and Misconceptions About JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Objects, Classes, Constructors  ECMAScript, being a highly abstract object-oriented programming language, operates on objects. There are also primitiv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics and Misconceptions About JavaScript</h1><div class="post__text post__text-html js-mediator-article"><h4>  Objects, Classes, Constructors </h4><blockquote>  ECMAScript, being a highly abstract object-oriented programming language, operates on objects.  There are also primitives, but they, when required, are also converted into objects.  An object is a collection of properties that also has a prototype object associated with it.  The prototype is either an object, or null. </blockquote>  In JavaScript, there are no familiar classes, but there are constructor functions that spawn objects according to certain algorithms (see Operator new). <br><br><h4>  Prototype delegating inheritance </h4><br>  Classical inheritance is very similar to how people inherit the genes of their ancestors.  There are some basic features: people can walk, talk ... And there are characteristics for each person.  People are not able to change themselves - their class (but they can change their own properties) and grandmothers, grandfathers, moms and dads cannot dynamically influence the genes of children and grandchildren.  Everything is very terrestrial. <br><br>  Now let's imagine another planet on which there is no such gene inheritance as on Earth.  There are mutants with "telepathic inheritance" who are able to change the genes of their descendants. <br>  Let's look at an example.  The Father inherits the genes from Grandfather, and the Son inherits the genes from the Father, who inherits from Grandfather.  Each mutant can freely mutate, and can change the genes of its descendants.  For example, Grandpa had green skin color, Father inherited color, Son inherited color too.  Suddenly, the Grandfather decided: ‚ÄúI got tired of walking green ‚Äî I want to be taken off,‚Äù he embarrassed (changed the prototype of his class) and ‚Äútelepathically‚Äù spread this mutation to the Father and the Son, in general everything turned blue.  Then Father thought: ‚ÄúGrandfather in his old age moved at all‚Äù and changed his color in the genes back to green (changed the prototype of his class), and distributed his color ‚Äútelepathically‚Äù to his son.  Father and Son are green, grandfather is blue.  Now, no matter how much the grandfather tried, the Father and the son did not change the color, because now the Father prescribed a color in his prototype, and the Son will first of all inherit from the Father‚Äôs Prototype.  Now the Son decides: ‚ÄúLet me change my color to black, and let my offspring inherit color from the Father‚Äù and prescribe my own property that does not affect the offspring.  And so on. <br><a name="habracut"></a><br>  We describe everything in the code: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Grandfather = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//  Grandfather Grandfather.prototype.color = 'green'; var Father = function () {}; //  Father Father.prototype = new Grandfather(); //  ,        var Son = function () {}; //  Son Son.prototype = new Father(); //  var u = new Grandfather(); //  "" Grandfather var f = new Father(); //  "" Father var s = new Son(); //  "" Son //    console.log([u.color, f.color, s.color]); // ["green", "green", "green"] //         Grandfather.prototype.color = 'blue'; console.log([u.color, f.color, s.color]); // ["blue", "blue", "blue"] //          Father.prototype.color = 'green'; //     : // Grandfather.prototype.color = 'green'; console.log([u.color, f.color, s.color]); // ["blue", "green", "green"] //   Grandfather.prototype.color = 'blue'; console.log([u.color, f.color, s.color]); // ["blue", "green", "green"] //             s.color = 'black'; //   ,      console.log([u.color, f.color, s.color]); // ["blue", "green", "black"] var SonsSon = function () {}; //  SonsSon SonsSon.prototype = new Son(); //  var ss = new SonsSon(); //  "" SonsSon //      console.log([u.color, f.color, s.color, ss.color]); // ["blue", "green", "black", "green"]</span></span></code> </pre> <br>  Read: <br>  <a href="http://javascript.ru/tutorial/object/inheritance">OOP in Javascript: Inheritance</a> <br>  <a href="http://habrahabr.ru/blogs/javascript/108915/">Understanding prototype, __proto__, constructor and their chains in pictures</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Chain of prototypes, getting the property with the given name </h4><br><blockquote>  A prototype chain is a finite chain of objects that is used to organize inheritance and shared properties. </blockquote><br>  In JavaScript, each object has its own properties (Own Properties) and a reference to the prototype object, in turn, the prototype also has its own properties and a reference to the prototype, the prototype prototype also has its own properties and a reference to the prototype and so on, while the prototype link will not be null - this structure is called a chain of prototypes. <br>  When you try to access the property of the object (through a dot or parentheses), the pointer is searched by name: first, it is checked if there is a pointer with such a name with its list of its own properties (if it has it, it returns), if it does not, then it is searched in its own prototype (if there is, then it is returned), if it is not there, then a prototype prototype is searched, and so on, until the prototype prototype becomes null in this case it returns undefined. <br><br>  Some JavaScript implementations use the __proto__ property to represent the next object in the prototype chain. <br><br>  The search for a read property can be described by the following function: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, prop</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.hasOwnProperty(prop)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[prop] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.__proto__ !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProperty(obj.__proto__, prop) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> }</code> </pre> <br>  For example, consider a simple Point 2D class that contains 2 properties (x, y) and a print method.  Using the definitions above, we construct the object. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Point = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">print</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: Point}; <span class="hljs-comment"><span class="hljs-comment">//  'x'    : /* px */ getProperty(p, 'x'); // 10 //  'y'    __proto__  - Point /* py */ getProperty(p, 'y'); // 0 //  print    __proto__  - Point /* p.print() */ getProperty(p, 'print').call(p); // 10 0</span></span></code> </pre>  <i>Why I used <code>call</code> , but did not call the received function directly, is described below.</i> <br><br>  In fact, <code>Point</code> has another property, yes, this is our reference to the prototype of the parent <code>__proto__</code> , which in the case of <code>Point</code> points to <code>Object.prototype</code> . <br>  For example, this is how the whole chain of prototypes will look like in the very first example: <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/* SonsSon &lt;- Son &lt;---- Father &lt;- Grandfather &lt;-- Object &lt;-- null */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ss.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__ === <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><h4>  __proto__, prototype, operator new </h4><br>  Above was the "low-level code", now let's see how everything works in life: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Point this.x = x; this.y = y; } Point.prototype = { //   print: function () { console.log(this.x, this.y); } }; var p = new Point(10, 20); //    p.print(); // 10 20</span></span></code> </pre><br>  If in the previous code we at least knew what it was referring to, everything is somehow confusing. <br><br>  All the "magic" is in the new operator.  Brendan Eich (creator of JavaScript) wanted JavaScript to be similar to traditional OO languages, such as C ++, Java, so the new operator was added.  Let's see how it works. <br><br>  The new operator gets a function and function arguments ( <code>new F(arguments...)</code> ) and performs the following actions: <br><br>  1. Creates an empty object with a single <code>__proto__</code> property that refers to <code>F.prototype</code> <br>  2. Executes the <code>F</code> constructor in which <code>this</code> is the previously created object <br>  3. Returns an object <br>  Create a <code>New</code> function that emulates the behavior of the <code>new</code> operator: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">F, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*1*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = {<span class="hljs-string"><span class="hljs-string">'__proto__'</span></span>: F.prototype}; <span class="hljs-comment"><span class="hljs-comment">/*2*/</span></span> F.apply(n, args); <span class="hljs-comment"><span class="hljs-comment">/*3*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre> <br>  Let's change the previous example with Point: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Point this.x = x; this.y = y; } Point.prototype = { //   print: function () { console.log(this.x, this.y); } }; var p1 = new Point(10, 20); p1.print(); // 10 20 console.log(p1 instanceof Point); // true //  : var p2 = New(Point, [10, 20]); p2.print(); // 10 20 console.log(p2 instanceof Point); // true</span></span></code> </pre><br><h4>  Prototype Chaining </h4><br>  In the very first example, I built a prototype chain using the following construction <code>Father.prototype = new Grandfather()</code> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Grandfather = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//  Grandfather Grandfather.prototype.color = 'green'; var Father = function () {}; //  Father Father.prototype = new Grandfather(); //  ,        var Son = function () {}; //  Son Son.prototype = new Father(); // </span></span></code> </pre><br>  Now we know the behavior of the new operator and we can understand what is being done here - we will expand the <code>new Grandfather()</code> : <br><pre> <code class="javascript hljs">Father.prototype = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: { <span class="hljs-comment"><span class="hljs-comment">//  Grandfather color: 'green', __proto__: Object.prototype } };</span></span></code> </pre> <br>  Now, when we call <code>new Father()</code> we get the following object (we will immediately expand the object): <br><pre> <code class="javascript hljs">Son.prototype = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: { <span class="hljs-comment"><span class="hljs-comment">//  Father __proto__: { //  Grandfather color: 'green', __proto__: Object.prototype } } }</span></span></code> </pre> <br>  Let's see what we have at the end of the code in the s object (Son instance) <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'black'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//      __proto__: { //  Son __proto__: { //  Father color: 'green', //     __proto__: { //  Grandfather color: 'blue', //      __proto__: Object.prototype } } } }</span></span></code> </pre> <br>  Why is <code>Father.prototype = new Grandfather()</code> not the best way to build a chain of prototypes? <br>  Because we have to call the <code>Grandfather</code> constructor, which can mix extra properties and call extra methods, for example <code>alert</code> .  To work around this problem, use the fake constructor: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inherit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object, parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//   F.prototype = parent.prototype; //     object.prototype = new F(); //       return object; //     };</span></span></code> </pre> <br>  Example of use: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Grandfather = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//  Grandfather Grandfather.prototype.color = 'green'; var Father = function () {}; //  Father inherit(Father, Grandfather); //  </span></span></code> </pre> <br>  <code>Grandfather</code> Designer will not be executed.  If we all need to do the Grandfather constructor, then call it using call or appy. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Father = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Father Grandfather.call(this); };</span></span></code> </pre> <br><br><h4>  Instanceof operator </h4><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Point) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  The <code>instanceof</code> operator is very closely related to chained prototypes.  It uses exactly the prototype chain for rendering a verdict, and does not check whether the given object ‚Äúp‚Äù is generated by the ‚ÄúPoint‚Äù constructor.  In this moment there is often confusion. <br><br>  The <code>instanceof</code> operator operates on two objects ‚Äî obj and constructor: ( <code>obj instanceof constructor</code> ).  Starting from constructor.prototype, it runs through a chain of prototypes and tests the following equality <code>obj.__proto__ === constructor.prototype</code> , if it is true, then it returns true. <br><br>  We describe in the code: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isInstanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, constructor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>.prototype) return true; else if (obj.__proto__ !== null) return isInstanceOf(obj.__proto__, <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) else return false }</code> </pre> <br>  Consider the example above: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Point this.x = x; this.y = y; } Point.prototype = { //   print: function () { console.log(this.x, this.y); } }; var p = new Point(10, 20); //    /* {} instanceof Object */ console.log(isInstanceOf({}, Object)); // true /* p instanceof Point */ console.log(isInstanceOf(p, Point)); // true /* p instanceof Object */ console.log(isInstanceOf(p, Object)); // true ,  Object     (Point.__proto__ === Object.prototype) /* p instanceof Array */ console.log(isInstanceOf(p, Array)); // false ,  Array    </span></span></code> </pre><br><h4>  This property </h4><br>  this is one big misconception. <br><br><blockquote>  Many are used to the fact that the this keyword in programming languages ‚Äã‚Äãis closely related to object-oriented programming, that is, it points to the current object generated by the constructor.  In ECMAScript, this is not limited to the definition of the object being spawned. </blockquote>  In JavaScript, the value of this is determined by the caller on the form of the call.  The rule that determines what will be in this is (I will explain in simple terms): <br>  1. If the method is called directly (without <code>new, call, apply, bind, with, try catch</code> ), then the value of this will be the object that stands before the point to the left of the method name. <br>  2. If there is no point (the function is called directly), then this will be equal to undefined, null or window (global), depending on the environment and ‚Äúuse strict‚Äù. <br>  3. If the expression is not a link, but a value, then clause 2 applies. <br><br>  Example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = foo.bar; bar(); <span class="hljs-comment"><span class="hljs-comment">// this === global (2) foo.bar(); // this === foo (1) (foo.bar)(); // this === foo     (1) //       -  (foo.bar = foo.bar)(); // this === global (3) (false || foo.bar)(); // this === global (3) (foo.bar, foo.bar)(); // this === global (3) function foo() { function bar() { console.log(this); } bar(); // this === global (2) }</span></span></code> </pre> <br>  Recall the example of <code>getProperty(p, 'print').call(p)</code> because of this rule I manually specified the value of this.  Otherwise, the print function would receive as this - window. <br><br>  These operators and methods are capable of controlling the value of <code>this: new, call, apply, bind, with, try catch</code> (everything is more or less clear with them, I will not touch it). <br><br>  More about this: <br>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">Subtleties ECMA-262-3.</a>  <a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">Part 3: This</a> <br><br><h4>  undefined, null, void </h4><br>  null - a primitive value representing a null, empty, non-existent link <br>  undefined - a primitive value that each variable gets by default (when a variable has no value) <br>  void is an operator (i.e., when calling its parenthesis is not needed), it executes the expression and always returns undefined <br><br><h4>  Conclusion </h4><br>  1. There are no classes in JavaScript - there are constructors <br>  2. Chain of prototypes - the base on which all inheritance in JavaScript is based <br>  3. The property of the object is obtained using a chain of prototypes. <br>  4. __proto__ is the reference to the prototype of the constructor (prototype) <br>  5. The new operator creates an empty object with the only property __proto__, which refers to F.prototype, executes the F constructor in which this is the previously created object and returns the object <br>  6. The instanceof operator does not check whether the given ‚ÄúObject‚Äù object is generated by the ‚ÄúObjectsConstoructor‚Äù constructor; it uses a chain of prototypes for its verdict <br>  7. In JavaScript, the value of this is determined by the caller on the form of the call. <br>  8. void is an operator, not a function.  undefined, null - primitive values <br><br>  <b>Important</b> In some implementations of JavaScript, you cannot directly change <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/proto">__proto__</a> , besides, this property is not standard and already obsolete.  To get a reference to the prototype, use <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a> .  In the article, I used it (__proto__) to demonstrate the "insides" of ECMAScript. <br><br><h4>  The article was used materials </h4><br>  Articles from Dmitry Soshinkov <a href="http://dmitrysoshnikov.com/">blog</a> <a href="https://habrahabr.ru/users/dscode/" class="user_link">dsCode</a> <br>  <a href="http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html">How Prototypal Inheritance really works</a> (Christopher Chedeau) </div><p>Source: <a href="https://habr.com/ru/post/120193/">https://habr.com/ru/post/120193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120187/index.html">How not to develop on the Zend Framework</a></li>
<li><a href="../120188/index.html">RubyGems - detail</a></li>
<li><a href="../120189/index.html">On Friday, WordPress turned 8 years old. WordPress history in screenshots</a></li>
<li><a href="../120191/index.html">Proprietary provider modems 1/3</a></li>
<li><a href="../120192/index.html">JavaScript FAQ: Part 1</a></li>
<li><a href="../120194/index.html">Naive Bayes classifier in 25 lines of code</a></li>
<li><a href="../120197/index.html">The developer has created a tool for returning RSS to Twitter</a></li>
<li><a href="../120198/index.html">We learn bash-scripts, we write Sokoban</a></li>
<li><a href="../120200/index.html">Harvey Fineberg: Are you ready for neo-evolution?</a></li>
<li><a href="../120204/index.html">Virtual Machine Console</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>