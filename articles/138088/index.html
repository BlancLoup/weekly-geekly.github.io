<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lyan-Knuth algorithm for soft hyphenation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When working with text, it is often necessary to arrange hyphenation correctly. The task at first glance is not so obvious, you need to take into acco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lyan-Knuth algorithm for soft hyphenation</h1><div class="post__text post__text-html js-mediator-article">  When working with text, it is often necessary to arrange hyphenation correctly.  The task at first glance is not so obvious, you need to take into account the peculiarities of each language in order to decide where to break the word.  How to formalize such requirements correctly, and how then to apply them in the algorithm?  One of the most common decisions to this day was proposed by Franklin Mark Liang, a student of the famous professor Donald Knuth.  The algorithm is called ‚ÄúThe Lyan-Knuth Algorithm‚Äù, it is used in the <a href="http://ru.wikipedia.org/wiki/TeX">TeX</a> publishing system, the author of which is also D. Knut. <br><br>  The algorithm is based on comparing the source word with a set of rules (patterns).  The more rules and the better they are made, the better the spreads will be arranged.  In the TeX package, you can find ready-made free rule sets for many languages, you only need to carefully look at the terms of use and distribution. <br><a name="habracut"></a><br><h5>  Example rules: </h5><br><pre>  when  
 at 3v 
 2i1ve
 . </pre><br>  Each rule consists of letters and numbers between them, as well as numbers at the beginning and end.  The number 0 is usually omitted.  For example, the first rule should be understood as <em>0001</em> .  The sequence of letters is the part of the word for which the translation is determined, i.e.  This sequence must be present in the word.  The numbers are called "level", they set the priority between the rules and the possibility of transfer in the corresponding position.  Even numbers, including 0, prohibit the transfer.  Odd - allow.  A dot at the beginning of a rule means that the rule applies only if the sequence is at the beginning of a word.  Similarly, with a dot at the end - the word must end with this sequence.  If there is a point at the beginning and at the end, then the rule contains the entire word. <br><br><h5>  The main stages of the algorithm: </h5><br><ol><li>  Select all the rules that match the selected word and for each position in the word get a set of levels (as many rules fell on one position, so many levels we get). </li><li>  In each position, select the maximum level.  If it is even, it is impossible to transfer here, if odd is a valid transfer point. </li><li>  Trim obviously unacceptable hyphens (for example, one letter at the beginning or at the end). </li></ol><br><h5>  Let's look at the work of the algorithm on an example: </h5><br>  Source word: <em>algorithm</em> <br>  A set of rules (taken from TeX): <br><pre>     lgo1
     1g
     o1ri
     —ñ1
     u2tm
     tm2
</pre><br>  Match the word with all the rules and choose the highest levels: <br><img src="https://habrastorage.org/storage2/226/fc4/586/226fc45868392838003959079621f56c.gif"><br>  In positions with level 1, you can safely put the transfer.  We get the result <em>"al-rhythm"</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Implementation </h5><br>  Now we implement this algorithm in C ++.  I needed a working algorithm for use in iOS, so I did everything as a C-Shn interface.  The module is written without reference to any locale or platform, and can be used anywhere. <br>  The rule will be stored as follows: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pattern_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::basic_string&lt;unichar&gt; str; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; levels; };</code> </pre> <br>  We will convert each rule into the form ‚Äúpure sequence of characters‚Äù + ‚Äúlevel set‚Äù so that it is convenient to apply it in the future. <br>  Rule set: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pattern_list_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pattern_t</span></span>*&gt; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; };</code> </pre><br>  The code for pulling levels out of the rules is simple, it can be viewed in full source at the link at the end of the article. <br>  After we fill in the list of rules, it must be sorted in order to ensure the correct and efficient operation of the algorithm.  We write our function less and apply the standard sorting algorithm: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pattern_compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pattern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pattern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> first = a-&gt;str.size() &lt; b-&gt;str.size(); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> min_size = first ? a-&gt;str.size() : b-&gt;str.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; min_size; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a-&gt;str[i] &lt; b-&gt;str[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a-&gt;str[i] &gt; b-&gt;str[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_pattern_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pattern_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pattern_list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pattern_list) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(pattern_list-&gt;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.begin(), pattern_list-&gt;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end(), pattern_compare); }</code> </pre><br>  Now directly the algorithm for finding carries: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; levels; levels.assign(word_string.size(), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; word_string.size()<span class="hljs-number"><span class="hljs-number">-2</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pattern_t</span></span>*&gt;::const_iterator pattern_iter = pattern_list-&gt;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.begin(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; count &lt;= word_string.size()-i; ++count) { <span class="hljs-keyword"><span class="hljs-keyword">pattern_t</span></span> pattern_from_word; pattern_from_word.str = word_string.substr(i, count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern_compare(&amp;pattern_from_word, *pattern_iter)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pattern_iter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lower_bound(pattern_iter, pattern_list-&gt;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end(), &amp;pattern_from_word, pattern_compare); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern_iter == pattern_list-&gt;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.end()) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pattern_compare(&amp;pattern_from_word, *pattern_iter)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> level_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; level_i &lt; (*pattern_iter)-&gt;levels.size(); ++level_i) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> l = (*pattern_iter)-&gt;levels[level_i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &gt; levels[i+level_i]) levels[i+level_i] = l; } } } }</code> </pre><br>  In the string word_string we put the source word, with the added '.'  along the edges, so that rules are automatically selected containing instructions on their position in the word.  Now in the source word for each character <em>with i = 0 to N, we</em> iterate over all the substrings beginning with <em>i</em> and <em>from 1 to Ni</em> .  We <em>look</em> for each substring in the rules vector by the standard algorithm <em>std :: lower_bound</em> .  We presume that the rules are sorted in the way we need and there is no need to go through everything all over again at every step.  When we find a match, take a vector of levels and apply it to the current result, i.e.  if the level for the current position in the rule is higher, remember it instead of the old one. <br><br>  In vector levels, maximum levels of values ‚Äã‚Äãfor each position are accumulated.  It remains to check it for odd values. <br><pre> <code class="cpp hljs">mask_size = levels.size()<span class="hljs-number"><span class="hljs-number">-2</span></span>; mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[mask_size]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mask_size; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (levels[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] % <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; i) mask[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mask[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Examples of the algorithm for the rule set from TeX: <br><pre>  programmer
 cybernetics
 scream
 intuition
 Sight
 Hello </pre><br><br>  The ready C ++ code along with the above examples can be downloaded <a href="https://github.com/mysolution/hyphenator">here</a> .  A test example in the main.c file (encoding Windows-1251), rules in the file patterns.h. </div><p>Source: <a href="https://habr.com/ru/post/138088/">https://habr.com/ru/post/138088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138080/index.html">File storage system with deduplication between users</a></li>
<li><a href="../138081/index.html">Introducing the TCP stack for Microchip microcontrollers</a></li>
<li><a href="../138084/index.html">Yii 1.1.10</a></li>
<li><a href="../138085/index.html">Subtleties of the implementation of the library code. Part one</a></li>
<li><a href="../138087/index.html">Is it permissible to use CSS frameworks for web development?</a></li>
<li><a href="../138091/index.html">Genetic algorithms. From theory to practice</a></li>
<li><a href="../138092/index.html">Mailing questions: how to send UniSender letters</a></li>
<li><a href="../138093/index.html">Expensive roads: Wi-Fi for travelers</a></li>
<li><a href="../138094/index.html">HTML5 Comics</a></li>
<li><a href="../138095/index.html">Microsoft Research Summer School on Parallel Computing opens the registration of participants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>