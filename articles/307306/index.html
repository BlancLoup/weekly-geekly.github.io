<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer: from simple to complex. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first article dealt with what a SObjectizer is. In the second article, we began to talk about how agents might look, why, how, and where they evol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer: from simple to complex. Part II</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/304386/">The first article</a> dealt with what a SObjectizer is.  <a href="https://habrahabr.ru/post/306858/">In the second article,</a> we began to talk about how agents might look, why, how, and where they evolve.  Today we will continue this story, further complicating the implementation of demonstration agents.  At the same time check the reliability of asynchronous messaging. <br><br>  Last time we stopped on the fact that the operation of reading the contents of the file with the email should be left to a separate IO-agent.  Let's do it and see what happens. <br><a name="habracut"></a><br>  First, we need a <a href="">set of messages</a> that will be exchanged between the IO agent and email_analyzer: <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . struct load_email_request { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . string email_file_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . mbox_t reply_to_; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . struct load_email_succeed { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . string content_; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . struct load_email_failed { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . string what_; };</span></span></code> </pre> <br>  Secondly, we need to determine where the email_analyzer agent will send the load_email_request request message.  We could go the usual way: when registering an IO agent, save it direct_mbox, then pass this mbox as a parameter to the analyzer_anager agent constructor, then a parameter to the designer of each email_analyzer agent ... Basically, if we would need to have several different IO- agents, then so should be done.  But in our task one IO-agent is enough.  That allows us to demonstrate the named mboxes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A named mbox is created by invoking so_5 :: environment_t :: create_mbox (name).  If you call create_mbox several times with the same name, it will always return the same mbox created when you first call create_mbox with this name. <br><br>  An IO agent creates itself a named mbox and subscribes to it.  The email_analyzer agents receive the same mbox when they need to send a load_email_request message.  Thus, we get rid of the need to ‚Äúdrag‚Äù the mbox IO-agent through the analyzer_manager. <br><br>  Now that we have decided on the interface between the IO agent and email_manager, we can make a <a href="">new version of the agent email_analyzer</a> : <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  .   IO-  IO-. class email_analyzer : public agent_t { public : email_analyzer( context_t ctx, string email_file, mbox_t reply_to ) : agent_t(ctx), email_file_(move(email_file)), reply_to_(move(reply_to)) {} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . virtual void so_define_agent() override { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       IO-.  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . so_subscribe_self() .event( &amp;email_analyzer::on_load_succeed ) .event( &amp;email_analyzer::on_load_failed ); } virtual void so_evt_start() override { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       IO-   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  email . send&lt; load_email_request &gt;( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ mbox IO-    . so_environment().create_mbox( "io_agent" ), email_file_, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       mbox. so_direct_mbox() ); } private : const string email_file_; const mbox_t reply_to_; void on_load_succeed( const load_email_succeed &amp; msg ) { try { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . auto parsed_data = parse_email( msg.content_ ); auto status = check_headers( parsed_data-&gt;headers() ); if( check_status::safe == status ) status = check_body( parsed_data-&gt;body() ); if( check_status::safe == status ) status = check_attachments( parsed_data-&gt;attachments() ); send&lt; check_result &gt;( reply_to_, email_file_, status ); } catch( const exception &amp; ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    email-   . send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . so_deregister_agent_coop_normally(); } void on_load_failed( const load_email_failed &amp; ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    .    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); so_deregister_agent_coop_normally(); } };</span></span></code> </pre> <br>  Now email_analyzer agents delegate IO operations to another agent who knows how to do this effectively.  Accordingly, email_analyzer agents on their working threads will be engaged in either distributing tasks to an IO agent or processing email_analyzer responses.  This gives us the opportunity to change the view on how many email_analyzer agents we can create and how many worker threads they need. <br><br>  When each email_analyzer agent itself performed a synchronous IO operation, we needed to have as many worker threads in the pool as many parallel IO operations we wanted to allow.  There was no point in creating much more email_analyzer agents than the number of worker threads in the pool.  If there are 16 threads in the pool, and we allow 32 agents to exist at the same time, this will result in half of these agents just waiting for any of the worker threads to become free for them. <br><br>  Now, after the IO operations are moved to another working context, it is possible, first, to reduce the number of worker threads in the pool.  In their events, email_analyzer agents will perform mostly processor-intensive operations.  Therefore, it makes no sense to create more workflows than there are available cores.  So, if we have a 4-core processor, then we will need not 16 threads in the pool, but no more than 4. <br><br>  Secondly, if IO operations take longer than processing email content, then we are able to create more email_analyzer agents than threads in the pool.  It‚Äôs just that most of these agents will wait for the result of their IO operation.  Although, if the email load time is comparable to or less than analyzing its contents, this item will lose its relevance and we will be able to create only 1-2-3 email_analyzer agents more than the number of threads in the pool.  All these settings are easily made in one place - in the analyzer_manager agent.  It is enough to change just a couple of constants in its code and see how the changes affect the performance of our solution.  However, performance tuning is a separate big topic, to delve into which is now premature ... <br><br>  So, we have another version of the agent email_analyzer, which fixes the problems of previous versions.  Can we consider it acceptable? <br><br>  Not. <br><br>  The problem is that the resulting implementation cannot be considered reliable. <br><br>  This implementation is designed for an optimistic scenario in which messages sent by us are never lost and always reach the addressee, and when they reach the addressee they are always processed.  Then we always get the answer we need. <br><br>  The harsh truth of life, however, is that when a system is built on asynchronous messaging between individual actors / agents, this same asynchronous exchange cannot be considered an absolutely reliable thing.  <i>Messages may be lost.</i>  <i>And that's fine</i> . <br><br>  Loss of messages can occur for various reasons.  For example, the recipient agent just did not have time to subscribe to the message.  Or there is no recipient agent at the moment.  Or he has one, but his overload protection mechanism has worked (more on this in a later article).  Either the agent is there and the message has even reached him, but the agent is in a state in which this message is not processed.  Either the agent is there, the message reached him, he even began to process it, but during the processing some kind of application error occurred and the failed agent did not send anything back. <br><br>  In general, communication between agents via asynchronous messages is like the interaction of hosts through the UDP protocol.  In most cases, datagrams reach recipients.  But sometimes they get lost on the road or even during processing. <br><br>  The above means that load_email_request may not reach the IO agent.  Or, the load_email_successed / load_email_failed response messages may not reach the email_analyzer agent.  And what will we do in this case? <br><br>  We will receive an email_analyzer agent that is present on the system, but does nothing.  Does not work.  Not going to die.  And does not start email_analyzer to some other agent.  If we are unlucky, then we may be faced with a situation where all the email_analyzer agents created by analyzer_manager will turn into such half-corpses that do nothing.  After that, analyzer_manager will simply accumulate requests in its turn, and then throw them out after the timeout expires.  But no useful work will be done. <br><br>  How to get out of this situation? <br><br>  For example, by controlling timeouts.  We can either introduce control of the execution time of an IO operation by the email_analyzer agent (i.e., if there is no response for too long, then assume that the IO operation has failed).  Alternatively, enter control over the execution time of the entire email analysis operation in the analyzer_manager agent.  Either do both. <br><br>  For simplicity, we restrict ourselves to counting the timeout of an IO operation <a href="">in the email_analyzer agent</a> : <br><br><pre> <code class="hljs pgsql">//  .   -   IO-. <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> email_analyzer : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> agent_t { //     ,    //   IO-    . struct io_agent_response_timeout : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> signal_t {}; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> : email_analyzer( context_t ctx, string email_file, mbox_t reply_to ) : agent_t(ctx), email_file_(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(email_file)), reply_to_(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(reply_to)) {} virtual <span class="hljs-type"><span class="hljs-type">void</span></span> so_define_agent() override { so_subscribe_self() .event( &amp;email_analyzer::on_load_succeed ) .event( &amp;email_analyzer::on_load_failed ) //    -   IO-. .event&lt; io_agent_response_timeout &gt;( &amp;email_analyzer::on_io_timeout ); } virtual <span class="hljs-type"><span class="hljs-type">void</span></span> so_evt_start() override { //       IO-   //  email . send&lt; load_email_request &gt;( so_environment().create_mbox( "io_agent" ), email_file_, so_direct_mbox() ); //      -    IO-. send_delayed&lt; io_agent_response_timeout &gt;( *this, <span class="hljs-number"><span class="hljs-number">1500</span></span>ms ); } private : const string email_file_; const mbox_t reply_to_; <span class="hljs-type"><span class="hljs-type">void</span></span> on_load_succeed( const load_email_succeed &amp; msg ) { try { auto parsed_data = parse_email( msg.content_ ); auto status = check_headers( parsed_data-&gt;headers() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( check_status::safe == status ) status = check_body( parsed_data-&gt;body() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( check_status::safe == status ) status = check_attachments( parsed_data-&gt;attachments() ); send&lt; check_result &gt;( reply_to_, email_file_, status ); } catch( const <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; ) { send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); } so_deregister_agent_coop_normally(); } <span class="hljs-type"><span class="hljs-type">void</span></span> on_load_failed( const load_email_failed &amp; ) { send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); so_deregister_agent_coop_normally(); } <span class="hljs-type"><span class="hljs-type">void</span></span> on_io_timeout() { //     ,     -. send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); so_deregister_agent_coop_normally(); } };</code> </pre> <br>  This email_analyzer option can already be considered quite acceptable.  In its code, refactoring with the introduction of a couple of operations (send and so_deregister_agent_coop_normally) into a separate auxiliary method is suggested.  But this was not done on purpose, so that the code for each subsequent version of the email_analyzer agent was minimally different from the code of the previous version. <br><br>  And just to compare the two email_analyzer agent versions shown above, one particular feature that programmers who have been using SObjectizer for a long time in their daily work will become noticeable: the simplicity and clarity of the agent extension procedure.  Did the agent need to respond to another event?  So you need to add another subscription and another event handler.  And since subscriptions are usually made in the same places, it is immediately clear where exactly to go and what exactly to rule. <br><br>  SObjectizer does not impose any restrictions on where and how the agent writes its events, but following a simple agreement - subscriptions are made in so_define_agent (), or, in very simple cases, for final-classes of agents, in the constructor - which greatly simplifies life .  You look into the code of a foreign agent or even the code of your agent, but written a few years ago, and you immediately know what you need to look to understand the behavior of the agent.  Conveniently, though, to understand this convenience, you probably need to write and debug not one real agent, and not even two ... <br><br>  However, let us return to the topic of agent reliability, which was raised above and because of which the next, sixth, version of the agent email_analyzer appeared: <i>the asynchronous message exchange mechanism between agents is not reliable and you need to live with it</i> . <br><br>  Here you need to make an important remark: it is wrong to say that the message delivery mechanism in SObjectizer is very well full of holes and allows itself to lose any messages when it pleases. <br><br>  Messages in SObjectizer just do not get lost, every loss has its own reason.  If the agent sends a message to itself, and the send function has completed successfully, the message will reach the agent.  Unless the developer himself does not explicitly take any action instructing SObjectizer to throw out this message in a specific case (for example, the developer does not sign the agent to the message in one of the states or uses limit_then_drop to protect against overload). <br><br>  So, if the developer himself does not allow SObjectizer to throw out certain messages in certain situations, then the message that the agent sent to itself must reach the agent.  Therefore, in the code shown above, we quietly sent to ourselves the deferred messages without fear that these messages would be lost somewhere along the way. <br><br>  However, when a message is sent to another agent, the situation changes somewhat.  There are cases when we are confident in the success of delivery.  For example, if we ourselves implemented the recipient agent, and even included it in the same cooperation in which the sender agent lives. <br><br>  But if the recipient agent is not written by us, it is created and destroyed as part of someone else‚Äôs cooperation, if we do not control its behavior, if we do not know how the agent is protected from overloads, how it behaves in any given situation, then we have confidence is the same as when sending a datagram via the UDP protocol: if everything is normal, then most likely the datagram will reach the sender, and then we will receive a response.  If everything is fine.  But if not? <br><br>  We have come to an interesting point: developing software on actors / agents due to the relative unreliability of asynchronous messaging may look more laborious than using approaches based on the synchronous interaction of objects in a program. <br><br>  Sometimes it is.  But in the end, in our opinion, the software is more reliable, because  in the code, involuntarily, one has to handle a lot of emergency situations associated with both the loss of messages and variations in the times of message delivery and processing. <br><br>  Suppose email_analyzers access the io_agent via a synchronous request, not an asynchronous message, and io_agent informs about failures when performing an IO operation by throwing exceptions.  For a long time, everything will work fine: email_analyzer synchronously requests io_agent and receives, in response, either the contents of the email, or an exception.  But at one point, somewhere inside io_agent, a hidden bug manifests itself, and the synchronous call just hangs.  No answer, no exception, just a hang.  Accordingly, one email_analyzer hangs first, then one more, then another, etc.  As a result, the entire application is suspended. <br><br>  While asynchronous messaging agent io_agent can hang somewhere in the guts.  But this will not affect email_analyzer agents, who can easily track the expiration of the request timeout and send a negative result.  That is, even if there are failures in one part of the application, other parts of the application will be able to continue their work, even if this work consists in generating a stream of negative responses.  Indeed, the very fact of this flow can become an important symptom and prompt the observer that something went wrong in the application. <br><br>  Incidentally, on the topic of observing the work of an application written on agents. <br><br>  Over the years of working with SObjectizer, we have the conviction that the ability to see what is happening inside the application built on the actors / agents is very important.  In principle, this was shown even in this article.  If you take the fifth version of email_analyzer without timeout control and try to start it, you can see how the processing of requests slows down until it stops at all.  But how exactly to understand what is the matter? <br><br>  A good hint could be given by how many agents email_analyzer is created at the moment and what each of them is doing.  This requires the ability to monitor what is happening inside the application.  This is exactly why Erlang and its platform are so appreciated: there you can connect to a working Erlang VM, see a list of Erlang processes, their parameters, etc.  But in Erlang, this is possible due to the fact that the Erlang application is running under the control of Erlang VM. <br><br>  In the case of a native C ++ application, the situation is more complicated.  SObjectizer has added tools for monitoring what is happening inside the SObjectizer Environment (although these tools still provide only the most basic functionality).  So, with their help in the course of <a href="">our demo application,</a> you can get the following information: <br><br><pre>  mbox_repository / named_mbox.count -&gt; 1
 coop_repository / coop.reg.count -&gt; 20
 coop_repository / coop.dereg.count -&gt; 0
 coop_repository / agent.count -&gt; 20
 coop_repository / coop.final.dereg.count -&gt; 0
 timer_thread / single_shot.count -&gt; 0
 timer_thread / periodic.count -&gt; 1
 disp / ot / DEFAULT / agent.count -&gt; 3
 disp / ot / DEFAULT / wt-0 / demands.count -&gt; 8
 disp / tp / analyzers / threads.count -&gt; 4
 disp / tp / analyzers / agent.count -&gt; 16
 disp / tp / analyzers / cq / __ so5_au ... 109 __ / agent.count -&gt; 1
 disp / tp / analyzers / cq / __ so5_au ... 109 __ / demands.count -&gt; 0
 disp / tp / analyzers / cq / __ so5_au ... 124 __ / agent.count -&gt; 1
 disp / tp / analyzers / cq / __ so5_au ... 124 __ / demands.count -&gt; 0
 ...
 disp / tp / analyzers / cq / __ so5_au ..._ 94 __ / agent.count -&gt; 1
 disp / tp / analyzers / cq / __ so5_au ..._ 94 __ / demands.count -&gt; 0
 disp / ot / req_initiator / agent.count -&gt; 1
 disp / ot / req_initiator / wt-0 / demands.count -&gt; 0 </pre><br>  This exhaust monitoring information allows you to understand that there is a dispatcher with a thread pool called analyzers, which has 4 workflows.  It is on this dispatcher in the example that the agents email_analyzer work.  16 agents are tied to the dispatcher, each of which constitutes a separate cooperation.  And these agents have no applications.  That is, there are agents, but there is no work for them.  And this is a reason to understand why this happened. <br><br>  Obviously, not always the low-level information that the SObjectizer Environment has will be useful to the application programmer.  For example, in the example in question, a developer‚Äôs counter could be given by the number of agents for email_analyzer and the size of the list of requests in the analyzer_manager agent.  But this is the application data, SObjectizer has no idea about them.  Therefore, when developing an application on agents, the programmer will need to ensure that information outside the application is available that is most useful for assessing the health and viability of the application.  Although this is already a big topic for another conversation. <br><br>  Perhaps this is another article you can finish.  In the next article we will try to show what can be done if we try to parallelize email analysis operations even more.  For example, if you perform parallel operations analysis of the headers, body of the letter and attachments.  And then what will become the agent code email_analyzer. <br><br>  Source codes for the examples shown in the article can be found <a href="https://bitbucket.org/sobjectizerteam/habrhabr_article_2">in this repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/307306/">https://habr.com/ru/post/307306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307288/index.html">Such different asynchrony</a></li>
<li><a href="../307294/index.html">SQL and XPath vs RosRestra</a></li>
<li><a href="../307296/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ222 (August 1 - 7, 2016)</a></li>
<li><a href="../307298/index.html">Is Saas a service or license?</a></li>
<li><a href="../307300/index.html">Cambium cnPilot - inexpensive WiFi, which surprised us</a></li>
<li><a href="../307308/index.html">Designing identical forms in WPF using abstract classes</a></li>
<li><a href="../307310/index.html">How to quickly raise the management accounting system in an advertising agency from scratch and without a budget</a></li>
<li><a href="../307312/index.html">Mathematics for artificial neural networks for beginners, part 2 - gradient descent</a></li>
<li><a href="../307314/index.html">The relationship between the monetization of games and the behavior of gamers</a></li>
<li><a href="../307316/index.html">Storing the ssh config in an ansible project and solving the tunnel problem when using the relative path</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>