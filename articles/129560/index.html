<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How mod_rewrite actually works. A guide for continuing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article has grown out of the idea of ‚Äã‚Äãadvanced training for our technical support staff working with mod_rewrite. Practice has shown that after ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How mod_rewrite actually works. A guide for continuing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/97b/f26/310/97bf2631020994a1b712e30f9049599a.png" alt="image" align="right"><br>  This article has grown out of the idea of ‚Äã‚Äãadvanced training for our technical support staff working with mod_rewrite.  Practice has shown that after studying a large number of textbooks in Russian support, the solution of patterned problems is well given, but independent rule making is done by trial and a lot of errors.  The problem is that for a good understanding of the work of mod_rewrite requires the study of the original English-language documentation, after which - either additional clarification, or hours of experiments with RewriteLog. <br><br>  The article outlines the mod_rewrite working mechanism.  Understanding the principles of its work allows you to clearly understand the effect of each directive and clearly understand what is happening at one time or another inside mod_rewrite when processing directives. <br><br>  I assume that the reader is already familiar with what mod_rewrite is, and I will not describe its basics, which are easy to find on the Internet.  It should also be noted that the article highlights the work of mod_rewrite when using its directives in the .htaccess file.  Differences when working in the context of &lt;VirtualHost&gt; are outlined at the end of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, you studied mod_rewrite, made up a few RewriteRule and managed to face endless redirects, the case when the rule for some reason does not catch your request, as well as the unpredictable work of the rule group when the subsequent rule unexpectedly changes the request that the previous rules painstakingly prepared. <br><br>  Why it happens? <br><a name="habracut"></a><br><h2>  What does RewriteRule work with </h2><br><blockquote>  The first RewriteRule is passed the path from the place where the .htaccess is located to the requested file.  This line never starts with "/".  The subsequent RewriteRule is passed the result of previous conversions. <br></blockquote><br>  In order to thoroughly understand how a RewriteRule works, you must first determine <b>what it works with</b> .  Consider how Apache gets a string that is initially passed to a RewriteRule in .htaccess. <br><br>  When you first start working with mod_rewrite, it is logical to assume that it works with links.  However, this is not the case with mod_rewrite in .htaccess.  In fact, the <b>path to the requested file</b> is <b>not</b> transferred to the RewriteRule. <br><br>  Due to the internal Apache architecture, at the moment when .htaccess comes into play, mod_rewrite can only operate on the path to the file to be processed.  This is due to the fact that before the transfer to the mod_rewrite request, other modules could already be changed (for example, mod_alias), and the final path to the file on the site may not coincide with the original link.  If mod_rewrite worked with the original link, it would violate the action of the modules that modified the request before it. <br><br>  Therefore, the absolute path to the file to be processed is transferred to mod_rewrite.  Also, mod_rewrite knows the path to .htaccess, which contains the RewriteRule rules.  To make something like a link from the path to the file that the site developer plans to work with, mod_rewrite cuts a part from the absolute path to the .htaccess file. <br><br>  So, it is this path, from which the path to .htaccess is cut off, is transmitted to the first RewriteRule.  For example: <br><ul><li>  Request: http://example.com/templates/silver/images/logo.gif </li><li>  DocumentRoot: /var/www/example.com </li><li>  File path: /var/www/example.com/templates/silver/images/logo.gif </li><li>  .htaccess is at: /var/www/example.com/templates/.htaccess </li><li>  The first RewriteRule will be transmitted: <b>silver / images / logo.gif</b> </li><li>  Please note: "templates /" is also cut off. </li></ul><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/740/674/502/7406745022beddf6d45164727c2d5001.png" alt="How does the RewriteRule work?"></div><br>  The path to .htaccess is cut off with a slash.  From this there is a consequence: the line that is initially passed to the processing of the RewriteRule never starts with "/". <br><br>  It is important to remember that <b>it does not do</b> RewriteRule.  It does not process the name of the site, the arguments that are passed to the script, and the link does not process everything, if .htaccess is not located in the root of the site.  RewriteCond is doing all this, which will be briefly touched upon later.  So: <br><br><blockquote><code>#    -    / <br> RewriteRule ^/index.php$ /my-index.php <br> <br> #    -     RewriteRule <br> RewriteRule ^example.com/.* http://www.example.com <br> <br> #    -      RewriteRule <br> RewriteRule index.php\?newspage=([0-9]+) news.php?page=$1 <br> <br> #     .htaccess   ,    templates, <br> # ,   .  ,  .htaccess   templates/.htaccess ,  <br> #   ,   mod_rewrite    .htaccess    RewriteRule <br> #     "templates/" <br> RewriteRule ^templates/common/yandex-money.gif$ templates/shared/yad.gif</code> <br> </blockquote><br>  At the beginning of using mod_rewrite, I recommend working with it only in .htaccess in the root of the site.  This will somewhat simplify the monitoring of its work. <br><br>  With what RewriteRule works, we have understood.  Now let's see <b>how</b> it works. <br><br><h2>  How RewriteRule Works </h2><br><blockquote>  RewriteRule simply converts the string to regular expressions, that's all.  RewriteRule works with a string, not with a link or path to the file. <br></blockquote><br>  As we found out above, the path from .htaccess to the requested file falls into the input of the RewriteRule.  The most convenient way now is to abstract from the paths and references and treat what the RewriteRule works with <b>as a regular line</b> .  This line is passed from RewriteRule to RewriteRule, modifying if any of the RewriteRule worked. <br><br>  In general, if we exclude the difficulties of using flags (some of which will be discussed below) and the difficulty of constructing regular expressions (which we will hardly touch on in this article), RewriteRule works VERY simply. <br><ol><li>  They took a string. </li><li>  Compared with a regular expression in the first argument. </li><li>  If there is a match, replace the <b>entire line</b> with the value of the second argument. </li><li>  Transferred the string to the next RewriteRule. </li></ol>  Here, in general, and all.  To illustrate that the RewriteRule works <b>with a string</b> , consider the following fantastic example: <br><br><blockquote> <code># <b>: http://mysite.com/info.html</b> <br> #   RewriteRule  "info.html" <br> <br> #     . <br> RewriteRule ^info.html$ "I saw a turtle in the hole. And it was dancing rock-n-roll. And it was smiling. All in all, it was a very funny doll." <br> <br> # "info.html" -&gt; "I saw a turtle..." <br> <br> #      . <br> RewriteRule turtle https://example.com/information/index.html <br> <br> # "I saw a turtle..." -&gt; "https://example.com/information/index.html" <br> <br> #   ! <br> RewriteRule ^(.*)example.com(.*)$ $1example.org$2 <br> <br> # "https://example.com/information/index.html" -&gt; "https://example.org/information/index.html" <br> <br> #  ! <br> RewriteRule ^https:(.*)$ ftp:$1 <br> <br> # "https://example.org/information/index.html" -&gt; "ftp://example.org/information/index.html" <br> <br> #   . <br> RewriteRule ^(.*)/index.html$ $1/main.php <br> <br> # "ftp://example.org/information/index.html" -&gt; "ftp://example.org/information/main.php"</code> <br> </blockquote><br>  As you can see, the RewriteRule doesn't care what to work with - it simply converts the string according to the arguments given to it.  If you want, you can store any data arrays in the string, if you wish, perseverance and good knowledge of regular expressions, you can at least write tic-tac-toe on RewriteRule. <br><br>  Here it is necessary to make a remark: even though RewriteRule works with a clean line, it is still <em>oriented</em> to work with links.  Therefore, it will react in a special way to lines beginning with ‚Äúhttps: //‚Äù or analogs (remember that we wanted to make an external redirect) and to the ‚Äú?‚Äù  (consider the following characters as arguments that will need to be substituted for the request).  But now it doesn‚Äôt interest us - it‚Äôs important to understand that there‚Äôs no magic in the RewriteRule ‚Äî it just takes the string and changes it as you told it.  We will look at external redirects and arguments later in the article; there are also some things to talk about. <br><br>  After all conversions are performed and the last RewriteRule is executed, the RewriteBase takes effect. <br><br><h2>  What is RewriteBase for? </h2><br><blockquote>  If the query after the conversion is relative and different from the original one, the RewriteBase will add itself to it on the left.  It is necessary to specify RewriteBase in .htaccess.  Its value is the path from the site root to .htaccess. <br>  RewriteBase is performed only after all of the RewriteRule, and not between them. <br></blockquote><br>  We have already said above that in mod_rewrite, working in .htaccess, the absolute path to the requested file falls.  To pass it to the RewriteRule, mod_rewrite cuts the path to .htaccess.  Then the RewriteRule rules change the request one by one.  And after the request is changed, Apache should restore the absolute path to the file, which it should eventually process.  RewriteBase is actually a hack that helps restore the original path to the file. <br><br>  RewriteBase is executed after all conversions.  This means that it will not change the request between the RewriteRule, and will take effect only when all of the RewriteRule have worked. <br><br>  After all the transformations, the RewriteBase looks, the relative one turned out to be a path or an absolute one.  In the context of Apache, we mean a relative or absolute path, counting from the root of the site: <br><ul><li>  images / logo.gif - relative. </li><li>  /images/logo.gif - absolute (at the beginning of the slash). </li><li>  http://example.com/images/logo.gif is the most absolute of all. </li></ul>  If the path is absolute, RewriteBase does nothing.  And if relative - RewriteBase appends itself to the left.  This works for both internal and external redirects: <br><br><blockquote> <code># .htaccess   /images/ <br> # RewriteBase  /images/ <br> RewriteBase /images/ <br> <br> # <b> http://example.com/images/logo.gif</b> <br> #   RewriteRule  "logo.gif" <br> RewriteRule ^logo.gif$ logo-orange.gif <br> #  RewriteRule: "logo.gif" -&gt; "logo-orange.gif" <br> #  RewriteBase: "logo-orange.gif" -&gt; "/images/logo-orange.gif" <br> <br> # <b> http://example.com/images/header.png</b> <br> #   RewriteRule  "header.png" <br> RewriteRule ^header.png$ /templates/rebranding/header.png <br> #  RewriteRule: "header.png" -&gt; "/templates/rebranding/header.png" <br> #  RewriteBase:   ,       "/'. <br> <br> # <b> http://example.com/images/director.tiff</b> <br> #   RewriteRule  "director.tiff" <br> #  <em> </em>  <br> RewriteRule ^director.tiff$ staff/manager/director.tiff [R=301] <br> #  RewriteRule: "director.tiff" -&gt; "staff/manager/director.tiff" <br> # + mod_rewrite ,     <br> #  RewriteBase: "staff/manager/director.tiff" -&gt; "/images/staff/manager/director.tiff" <br> # mod_rewrite    : <br> # "/images/staff/manager/director.tiff" -&gt; http://example.com/images/staff/manager/director.tiff</code> <br> </blockquote><br>  Usually, after some familiarity with mod_rewrite, the following habit develops: 1) add ‚ÄúRewriteBase /‚Äù to each .htaccess, 2) start all redirections with a slash: ‚ÄúRewriteRule news.php /index.php?act=news‚Äù.  This helps get rid of the artifacts of RewriteBase, but doing so is wrong.  Now that we know what the RewriteBase is doing, we can <b>formulate the following correct rules:</b> <br><ol><li>  RewriteBase must match the path from the site root to .htaccess. </li><li>  Starting redirects with "/" is necessary only when you need to specify the absolute path from the root of the site to the file. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/e2f/9b5/95ae2f9b5762b9b26c15fead02533b5a.png" alt="how does rewritebase work"></div><br>  What happens if you do not specify RewriteBase?  By default, Apache makes it equal to the absolute path on the file system before .htaccess (for example, /var/www/example.com/templates/).  The incorrectness of this assumption Apache manifests itself in external relative redirects: <br><blockquote> <code># <b> http://example.com/index.php</b> <br> # DocumentRoot: /var/www/example.com/ <br> # .htaccess    ,      RewriteBase. <br> #    RewriteBase     .htaccess: /var/www/example.com/ <br> <br> #   RewriteRule - "index.php" <br> RewriteRule ^index.php main.php [R] <br> #  : "index.php" -&gt; "main.php" <br> # mod_rewrite ,     <br> <br> #  RewriteRule <br> # mod_rewrite    RewriteBase,        . <br> # : "main.php" -&gt; "/var/www/example.com/main.php" <br> <br> #  mod_rewrite ,    : <br> # "/var/www/example.com/main.php" -&gt; http://example.com/var/www/example.com/main.php <br> <br> #    ,    .</code> <br> </blockquote><br>  So, the request went through all the RewriteRule, after which a RewriteBase was added to it, if necessary.  Should Apache now give the file, which shows the resulting path?  <b>Not.</b>  <b>Now the resulting request will be processed again.</b> <br><br><h2>  How mod_rewrite works  Flag [L] </h2><br><blockquote>  mod_rewrite starts processing the request again and again, until it stops changing.  And the flag [L] cannot stop it. <br></blockquote><br>  When compiling more or less complex mod_rewrite configurations, it is important to understand that <b>changing the query does not end at the last RewriteRule</b> .  After the last rule of RewriteRule worked and the RewriteBase was added, mod_rewrite looks at whether the request has changed or not.  If the request is changed, its processing begins anew from the beginning of .htaccess. <br><br>  Apache does this because it could be redirected to another directory during the request change process.  It may have its own .htaccess, which was not involved in the previous processing of the request.  In the same new .htaccess there may be rules that affect the processing of a request - both the mod_rewrite rules and the rules of other modules.  To correctly handle this situation, Apache must restart the entire processing cycle. <br><br>  <i>- Wait, but there is a flag <b>[L]</b> that stops the processing of the request by mod_rewrite'om!</i> <br><br>  Not certainly in that way.  The [L] flag stops the <b>current iteration</b> of the request processing.  However, if the request was changed by those RewriteRule, which still managed to work out, Apache will start the request processing cycle again from the first RewriteRule. <br><blockquote> <code># <b>: http://example.com/a.html</b> <br> <br> RewriteBase / <br> <br> RewriteRule ^a.html$ b.html [L] <br> RewriteRule ^b.html$ a.html [L]</code> <br> </blockquote><br>  The example above will result in an endless loop of redirections and a ‚ÄúInternal Server Error‚Äù in the end.  In this example, the infinite loop is obvious, but in more complex configurations it may be necessary to delve into the rules to determine which queries loop around each other. <br><br>  To avoid such situations, it is recommended to use the [L] flag only when necessary.  Necessity can be of two types: <br><ol><li>  When external redirect is used - [L, R = 301] or [L, R = 302].  In the case of an external redirect, further processing of the request is undesirable (see below about the [R] flag), and it is better to stop it. </li><li>  When in .htaccess there is a looping that cannot be eliminated, and the processing of the request by mod_rewrite should be forcibly stopped.  In this case, a special design is used - see tips on this topic at the end of the article. </li></ol><br>  But the example below will not loop.  Try to determine why, and as a result, the file will be given to Apache. <br><blockquote> <code># <b>: http://example.com/a.html</b> <br> #  .htaccess <br> <br> RewriteBase / <br> RewriteRule ^a.html$ b.html <br> RewriteRule ^b.html$ a.html <br> <br> #  .htaccess</code> <br> </blockquote><br>  The answer: <font color="white">As a result of all RewriteRule execution, the request is changed in such a way that the final result is equal to the original one</font> .  <font color="white">Apache sees this and does not initiate repeated processing of the request</font> .  <font color="white">The a.html file will be returned</font> . <br><br><h2>  How mod_rewrite works  Flag [R] </h2><br><blockquote>  The [R] flag does not stop processing the request, immediately returning an external redirect.  Instead, it remembers the need for an external redirect, and the request processing continues with the following RewriteRule.  It is recommended to always use with the [L] flag. <br></blockquote><br>  The [R] flag tells Apache to execute external redirect, not internal.  What is the difference between external redirect from internal?  Internal redirect simply changes the path to the file that will be given to the user, while the user thinks that he receives the file that he originally requested.  When an external redirect Apache instead of the contents of the file returns to the user the status of the response 301 or 302 and reports the link on which the browser should refer to the file. <br><br>  It would seem that when processing the [R] flag, Apache should immediately stop processing the RewriteRule and return the external redirect to the user.  However, let's recall a fantastic example from the section ‚ÄúHow RewriteRule Works‚Äù.  In it, we first indicated the flag [R], denoting the need for an external redirect, and then continued to change the link following RewriteRule. <br><br>  This is exactly how Apache works when specifying an external redirect.  He simply "marks" himself that after the fulfillment of all the rules it is necessary to return the status 302 (by default), but he continues to perform all the RewriteRule further down the list.  We can continue to change the request as we need, the only thing that does not work out is to make the redirect back internal. <br><br>  However, it is unlikely that you want to change it after any external redirect.  Therefore <b>it is recommended when using the [R] flag to indicate it together with [L]:</b> <br><br><blockquote> <code># BlackJack     <br> RewriteRule ^bj/(.*) blackjack/$1 [R=301,L] <br> <br> #      <br> RewriteRule ^bj/(.*) http://blackjack.example.com/$1 [L]</code> <br> </blockquote><br>  Instead of using the [R] flag, you can simply specify an external link.  In this case, Apache itself will guess that it is necessary to make an external redirect.  Here, as with the case with the explicit indication of the flag [R], it is recommended to use the flag [L]. <br><ul><li>  If an external redirect leads to the same site, it is better to use the [R] flag without a full link (in other words, use a relative external redirect).  This will make the rule independent of the site. </li><li>  If an external redirect leads to another site, otherwise, as specifying a full external link, this will not work. </li></ul><br><h2>  How mod_rewrite works  Specifying Query Parameters and the [QSA] Flag </h2><br><blockquote>  Changing the request parameters in the RewriteRule does not change the row with which the next RewriteRule works.  However, when parameters are changed, the variable% {QUERY_STRING}, with which RewriteCond can work, changes. <br></blockquote><br>  Terminology used: ‚Äúparameters‚Äù - request parameters, ‚Äúarguments‚Äù - arguments RewriteRule. <br><br>  Using the RewriteRule, you can change not only the path to the file to be processed, but also the GET request parameters that will be passed to it.  This is often used to transfer CNC processing to a common script processor, for example: <br><blockquote> <code>RewriteBase / <br> <br> # <b>: http://example.com/news/2010/07/12/grand-opening.html</b> <br> #  : "news/2010/07/12/grand-opening.html" <br> RewriteRule ^news/(.*)$ index.php?act=news&amp;what=$1 <br> #  RewriteRule: "news/2010/07/12/grand-opening.html" -&gt; "index.php" <br> # %{QUERY_STRING}: "" -&gt; "act=news&amp;what=2010/07/12/grand-opening.html"</code> <br> </blockquote><br>  At the moment when the RewriteRule rule encounters a question mark in the second argument, it understands that there is a change in the parameters in the request.  The result is the following: <br><ol><li>  RewriteRule replaces the line it works with with part of the second argument <b>before the question mark</b> .  Please note that the new request parameters <b>do not fall</b> into the line with which the subsequent RewriteRule rules will work. </li><li>  The part of the second argument <b>after the question mark</b> is in the variable% {QUERY_STRING}.  If the [QSA] flag was specified, the query parameters will be added to the beginning of% {QUERY_STRING}.  If the flag is not specified,% {QUERY_STRING} is completely replaced by the request parameters from the RewriteRule. </li></ol>  A couple more examples: <br><blockquote> <code>RewriteBase / <br> <br> # <b>: http://example.com/news/2010/?page=2</b> <br> #   RewriteRule: "news/2010/" <br> RewriteRule ^news/(.*)$ index.php?act=news&amp;what=$1 <br> #  : "news/2010/" -&gt; "index.php" <br> #  %{QUERY_STRING}: "page=2" -&gt; "act=news&amp;what=2010/"</code> <br> </blockquote><br>  Most likely, the rule above works incorrectly, since the page argument is lost.  Fix this: <br><blockquote> <code>RewriteBase / <br> <br> # <b>: http://example.com/news/2010/?page=2</b> <br> #   RewriteRule: "news/2010/" <br> RewriteRule ^news/(.*)$ index.php?act=news&amp;what=$1 <b>[QSA]</b> <br> #  : "news/2010/" -&gt; "index.php" <br> #  %{QUERY_STRING}: "page=2" -&gt; "act=news&amp;what=2010/&amp;page=2"</code> <br> </blockquote><br>  We added only the [QSA] flag, and the rule began to work correctly. <br><br>  It is important to understand that <b>changing query parameters changes% {QUERY_STRING}</b> , which can be used later in RewriteCond.  This should be taken into account when drafting subsequent rules that check arguments. <br><br>  <i>- Of course, it changes, because the request goes to Apache for repeated processing!</i> <br><br>  No,% {QUERY_STRING} is <b>changed immediately</b> .  I will not give the proof - about the parameters it‚Äôs already written more than it‚Äôs interesting to read :) <br><br>  What to do to check in RewriteCond exactly those request parameters that the user submitted, and not modified by RewriteRules?  See tips at the end of the article. <br><br><h2>  RewriteCond and performance </h2><br><blockquote>  First, the matching of the request with the RewriteRule is checked, and only then the additional conditions of the RewriteCond are checked. <br></blockquote><br>  A few words should be said about the order in which mod_rewrite executes directives.  Since in .htaccess RewriteCond goes first, and then RewriteRule, it seems that mod_rewrite first checks all the conditions, and then proceeds to run the RewriteRule. <br><br>  In fact, everything happens the other way around.  First, mod_rewrite checks if the current value of the request matches the regular RewriteRule expression, and only then will check all the conditions listed in RewriteCond. <br><br>  So if you have a two-page regular expression in RewriteRule, and after thinking about performance, you decided to limit the execution of this rule to additional RewriteCond, you know - nothing happens.  In this case, it is better to use the RewriteRule <b>[C]</b> or <b>[S]</b> flags to skip the more complex rule, if the simpler checks did not work. <br><br><h2>  Variables and flags RewriteCond, other flags RewriteRule, etc. </h2><br><blockquote>  Read the documentation. <br></blockquote><br>  We got acquainted with the principles of operation of RewriteRule, RewriteBase, flags [L], [R] and [QSA], and also sorted out the query processing mechanism inside mod_rewrite.  From the unaffected left: other flags RewriteRule, directives RewriteCond and RewriteMap. <br><br>  Fortunately, these directives and flags do not contain any mysteries and work exactly as described in most textbooks.  For their understanding, it is enough to read the official documentation.  First of all, I recommend studying the list of variables that can be checked in RewriteCond -% {QUERY_STING},% {THE_REQUEST},% {REMOTE_ADDR},% {HTTP_HOST},% {HTTP: header}, etc.) <br><br><h2>  The difference in the operation of mod_rewrite in the context of .htaccess and in the context of VirtualHost </h2><br><blockquote>  In the context of &lt;VirtualHost&gt;, mod_rewrite works exactly the opposite. <br></blockquote><br>  As I said at the beginning of the article, everything described above concerns the use of mod_rewrite in the context of .htaccess.  If mod_rewrite is used in &lt;VirtualHost&gt;, it will work differently: <br><ul><li>  The &lt;VirtualHost&gt; in RewriteRule gets the entire request path starting from the first slash, ending with the beginning of the GET parameters: "http://example.com/some/news/category/post.html?comments_page=3" -&gt; "/ news / category / post.html ".  This line always starts with /. </li><li>  The second argument of RewriteRule also needs to be started with /, otherwise there will be a ‚ÄúBad Request‚Äù. </li><li>  RewriteBase does not make sense. </li><li>  Passage of rules occurs only once.  The [L] flag really ends processing all the rules described in &lt;VirtualHost&gt; without any subsequent iterations. </li></ul><br><h2>  Tips and solutions </h2><br>  Here are collected tips that could be cited in the course of the article, but which were excluded from the main text for the sake of brevity of presentation. <br><br><h3>  Regular expression compilation </h3><br>  Try to make regular expressions so that they most narrowly define exactly those requests that you want to modify - so that the RewriteRule rules do not accidentally work for another request.  For example: <br><blockquote> <code>#      "^" (  ) <br> #   "$" (  ): <br> RewriteRule ^news.php$ index.php <br> #       -      : <br> RewriteRule ^news/(.*)$ index.php <br> <br> #        -   . <br> #  -  ,   . <br> #         ,   . <br> #    "." (). <br> #       http://example.com/news/2009/07/28/b-effect.html <br> RewriteRule ^news/20[0-9]{2}/[0-9]{2}/[0-9]{2}/[^/]+\.html index.php</code> <br> </blockquote><br>  However, there is <a href="http://habrahabr.ru/blogs/regex/">a whole section</a> on regular expressions on one well-known site. <br><br><h3>  Changing external redirects </h3><br>  Despite the fact that mod_rewrite allows changing even external redirects, up to the protocol, with the help of RewriteRule, I highly recommend not to do this.  The article uses the example of changing external redirects only to get rid of such concepts as "links" and "files" and more clearly show that RewriteRule works with a simple line. <br><br>  I do not think that the developers of mod_rewrite assumed that someone would do that, so any artifacts are possible.  Do not do this, please. <br><br><h3>  How to stop an endless loop </h3><br>  Sometimes the logic of redirections on a site is such that without special actions mod_rewrite perceives them as an infinite loop of redirections.  Take the following example. <br><br>  The site was /info.html.  SEO specialist decided that search engines will better index this page if it will be called /information.html and asked to make an external redirect from info.html to information.html.  However, the developer of the site, for whatever reasons, cannot simply rename info.html into information.html and redirect it - it needs that the data be necessarily given directly from the info.html file.  He writes the following rule: <br><blockquote> <code>#    <br> RewriteRule ^info.html information.html [R,L] <br> #    /information.html    info.html <br> RewriteRule ^information.html info.html</code> <br> </blockquote><br>  ... and faces an endless loop.  Each request /information.html receives an external redirect again to /information.html. <br><br>  This problem can be solved in at least two ways.  On Habr√©, <a href="http://habrahabr.ru/blogs/webdev/75885/">one of them</a> was already described - you need to set an environment variable and, based on its value, stop redirections.  The code will look like this: <br><blockquote> <code>RewriteCond %{ENV:REDIRECT_FINISH} !^$ <br> RewriteRule ^ - [L] <br> <br> RewriteRule ^info.html$ information.html [R,L] <br> RewriteRule ^information.html$ info.html [E=FINISH:1]</code> <br> </blockquote><br>  Notice that mod_rewrite adds 'REDIRECT_' to the variable name. <br><br>  The second way is to check in THE_REQUEST what exactly was requested by the user: <br><blockquote> <code>#        info.html. <br> #   info.html -    ,    . <br> RewriteCond %{THE_REQUEST} "^(GET|POST|HEAD) /info.html HTTP/[0-9.]+$" <br> RewriteRule ^info.html$ information.html [R,L] <br> <br> RewriteRule ^information.html$ info.html</code> <br> </blockquote><br><br><h3>  Analysis of the original user request - the fight against the disclosure of links Apache </h3><br>  When processing a request, Apache reveals encoded (URL-encoded) characters from the original request.  In some cases, this may be undesirable - the developer wants to check the initial, unmodified user request.  You can do this by checking the variable% {THE_REQUEST} in RewriteCond: <br><blockquote> <code>RewriteCond %{THE_REQUEST} ^GET[\ ]+/tag/([^/]+)/[\ ]+HTTP.*$ <br> RewriteRule ^(.*)$ index.php?tag=%1 [L]</code> <br> </blockquote><br>  On Habr√© there is a <a href="http://habrahabr.ru/blogs/personal/49136/">discussion of one of these cases</a> , and the above example was taken from it. <br><br><h2>  Recommended Documentation </h2><br>  <a href="httpd.apache.org/docs/current/rewrite/">Official Apache documentation</a> and especially <a href="httpd.apache.org/docs/current/rewrite/tech.html">Technical details</a> .  Yes Yes. <br><br>  Thank you very much for your attention! </div><p>Source: <a href="https://habr.com/ru/post/129560/">https://habr.com/ru/post/129560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129551/index.html">Optimize Ubuntu (and other Linux) under SSD</a></li>
<li><a href="../129554/index.html">On-line + Off-line access to the working mailbox</a></li>
<li><a href="../129557/index.html">The life cycle of UIViewController</a></li>
<li><a href="../129558/index.html">Memory organization in Windows OS</a></li>
<li><a href="../129559/index.html">Ringed networks, or why do we need STP</a></li>
<li><a href="../129561/index.html">Principles of partnership in the startup MyClasses.org - the story beckoning to the Dominican Republic</a></li>
<li><a href="../129563/index.html">Added ‚Äúhelicopter mode‚Äù to Google Maps</a></li>
<li><a href="../129564/index.html">On the "top of the world" set the webcam</a></li>
<li><a href="../129566/index.html">New site onepicturetutorial.com - lessons in one picture</a></li>
<li><a href="../129568/index.html">Rendering of artificial objects in the photo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>