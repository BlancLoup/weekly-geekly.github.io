<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of cyclic dependencies during type initialization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some of the readers who have ever encountered the problem described in the title of the article probably remained at work until late and spent many ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of cyclic dependencies during type initialization</h1><div class="post__text post__text-html js-mediator-article">  Some of the readers who have ever encountered the problem described in the title of the article probably remained at work until late and spent many hours in the debugger.  For others, this may be nothing more than a play on words and slang words.  However, let's step aside from the jargon and reveal the concepts: <br><ul><li>  Type Initialization: This is the code that is executed to initialize all static class variables and execute a static constructor; </li><li>  Cyclic dependency: two pieces of code that depend on each other.  In our case, these are two classes, the initialization of types of which requires an already initialized type of another class. </li></ul><br>  Well, a small example to show what is at stake: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Test</span></span> {         <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>    {        Console.WriteLine(First.Beta);    } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">First</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Alpha = <span class="hljs-number"><span class="hljs-number">5</span></span>;     <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Beta = Second.Gamma; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Second</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gamma = First.Alpha; }</code> </pre> <br><br>  <b>The result of this code will be 0</b> <br><a name="habracut"></a><br>  Of course, if you do not look in the specification, then any expectations as it will work no more than assumptions.  Therefore, we will look at the specification (section 10.5.5.1 of the C # 4 version): <br><br><blockquote>  It‚Äôs not a problem.  If a static constructor (¬ß10.12) exists, the execution of the static field initializers occurs immediately prior to executing that static constructor.  Otherwise, the field of initialization of the static field of the field of implementation is dependent on the time of use. </blockquote><br>  Transfer: <br><blockquote>  The order of initialization of static fields of the class corresponds to the order of their location in the source text of the class.  If there is a static constructor in the class, the initialization code for the static fields of the class is located right before the static constructor call.  Otherwise, if the static constructor does not exist, the initialization of the static fields is performed in a location dependent on the specific implementation: this happens before the first use of the static field. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition to the language specification, an excerpt from the <code>CLI</code> specification, which reveals more details on type initialization, especially cyclic dependencies and multi-threading, can be cited.  However, I will not do this, but only write a couple of short excerpts: <br><ul><li>  Guaranteed thread safety during type initialization </li><li>  If <code>CLI</code> notices that type A needs to be initialized while it is also in the process of initialization in the same thread, <code>CLI</code> continues to work as if type A has already been initialized. </li></ul><br>  So, what would happen in your opinion: <br><br><ol><li>  Initialize <code>Test</code> : no further action required </li><li>  Start performing <code>Main</code> </li><li>  Start Initialization <code>First</code> (since we need <code>First.Beta</code> ) </li><li>  Set <code>First.Alpha</code> to 5 </li><li>  Start the initialization of <code>Second</code> (since we need <code>Second.Gamma</code> ) </li><li>  Install <code>Second.Gamma</code> to <code>First.Alpha</code> (5) </li><li>  Finish <code>Second</code> Initialization </li><li>  Install <code>First.Beta</code> to <code>Second.Gamma</code> (5) </li><li>  Finish Initialization <code>First</code> </li><li>  Type "5" </li></ol><br><br>  And here is described what is happening in reality - on my computer, with the .Net Framework 4.5 beta installed (I know that type initialization <a href="http://link:">was changed in .NET 4.</a> I don‚Äôt know if there were changes in .Net 4.5, but I don‚Äôt I will argue that it is not possible) <br><br><ol><li>  Initialize <code>Test</code> : no further action required </li><li>  Start performing <code>Main</code> </li><li>  Start Initialization <code>First</code> (since we need <code>First.Beta</code> ) </li><li>  Begin to initiate <code>Second</code> (we will need <code>Second.Gamma</code> ) </li><li>  Set <code>Second.Gamma</code> to <code>First.Alpha</code> (0) </li><li>  Finish <code>Second</code> Initialization </li><li>  Set <code>First.Alpha</code> to 5 </li><li>  Install <code>First.Beta</code> to <code>Second.Gamma</code> (0) </li><li>  Finish Initialization <code>First</code> </li><li>  Type 0 </li></ol><br><br>  Step <b>(5) is</b> very interesting.  We know that we need to initialize <code>First</code> order to get further <code>First.Alpha</code> .  However, this thread is already initializing <code>First</code> , so we skip initialization, hoping that everything is in order.  However, at this point, the initialization of the variable has not yet occurred.  Oops ... <br><br>  (There is one subtlety that will avoid all the problems described: the use of the keyword const) <br><br><h4>  Back to the real world </h4><br>  I hope my example has clarified for you why the use of cyclic dependencies during type initialization is a matter that will spoil your life a lot.  Such places are very difficult to catch and debug.  And in fact this is a classic <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25B9%25D0%25B7%25D0%25B5%25D0%25BD%25D0%25B1%25D0%25B0%25D0%25B3">Heisenbag</a> .  In our example, it is important to understand that if it so happens that the program initializes the first <code>Second</code> (for example, to access another variable), then we will get a completely different result.  And, in practice, you can get a situation where the launch of all unit tests will lead to the fact that all of them will be overwhelmed.  But if at the same time run them separately, they will work (it is quite possible, except for one). <br><br>  One way to avoid such situations is to refuse to initialize types altogether.  In most cases, this is exactly what you need.  However, we usually use well-known things.  Such as <code><b>Encoding.Utf8</b></code> , or <code><b>TimeZoneInfo.Utc</b></code> .  Notice that in both cases these are static properties, but it seems to me that they carry with them the use of static fields.  At first glance, it seems that using <code><code>public static readonly</code>   public static get-only</code> properties is the same, however, as we will see later, using properties gives its advantages. <br><br>  My library <b><a href="http://code.google.com/p/noda-time/">Noda Time</a></b> has several similarities to ours.  And all because many types of this library are <i>immutable</i> , i.e.  unchangeable.  It makes sense when you need to create your own <code>UTC</code> time zone, or the <code>ISO calendar system</code> .  Moreover, in addition to publicly visible values, we have a lot of static variables used inside the library (mainly for caching tasks).  All this makes the library more difficult and difficult to test, but the performance benefits in this case are very, very significant. <br><br>  Unfortunately, a huge number of these fields and properties have cyclical dependencies.  As I mentioned earlier, when we add a new static field, this can lead to the most various breakdowns in the program.  I can fix the immediate cause, but that leaves me with a sense of concern about the integrity of the code.  After all, if I have eliminated one problem, it does not give any guarantees that there are no others. <br><br><h4>  Type Initialization Testing </h4><br>  One of the main issues with type initialization is sensitivity to the order of initialization in combination with the guarantee that the type within the <code>AppDomain</code> will be initialized only once.  As I showed earlier, it is possible that with one initialization order this will cause an error, and with any other, no error will occur. <br><br>  For myself, I decided that when developing Noda Time, I want to be absolutely sure that cyclic dependencies will not create any problems for me.  So  I want to make sure that the initialization of types does not form loops, regardless of the order in which they are initialized.  Logically, we can define a cyclical dependency that starts with one type, starting with other types that are in the same cycle.  I am very anxious not to miss any extreme cases, and to go through all the options that are possible and not to let anything out of sight.  Because I used the method of brute force - a complete bust. <br><br>  Here is our rough plan: <br><ul><li>  We start with an empty list of dependencies; </li><li>  For each type of target assembly: <br><ul><li>  Create New AppDomain </li><li>  Download assembly there </li><li>  Initialize a type (perform an action on it to start the initialization process) </li><li>  View the stack trace from the beginning of each type initialization and record all dependencies. </li></ul></li><li>  View circular dependencies in the final list </li></ul><br>  Please note that we will never have a situation where we can determine cyclical dependency in one load of the application domain.  To do this, it is necessary to bypass all types and identify cycles, analyzing the results. <br><br>  The description of how the code works will be much larger than the code itself and in fact it is very easy to understand, so I will place it at the end of the article. <br><br>  This solution is not very good for several reasons: <br><ul><li>  Creating a new AppDomain and loading assemblies from a unit testing program into it may not be as simple as it could be.  My code does not work correctly in conjunction with <code>NCrunch</code> . And I'm sure that if I fix this, the rest of the unit-testing systems will still break my program. </li><li>  It is based on the fact that each type initializer will contain the necessary line of code for the system to work: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TypeInitializationChecking = NodaTime.Utility.TypeInitializationChecker.RecordInitializationStart();</code> </pre> </li><li>  It‚Äôs bad not only that you need to add a line of code to every type that interests us.  This is bad because this line will be called every time the type is initialized.  It will also select at least 4 bytes from the heap, which is very bad if the program is not running in test mode.  Of course, I could use preprocessor directives to remove this code from the version, not for testing.  But from this the code will look even dirtier; </li><li>  This method finds circular dependencies only for those versions of .Net on which tests were run.  If we consider that there are differences in different versions of the .Net Framework, I would not be sure that the tests will cover 100% of the situations.  Similarly, if we change the current CultureInfo, or any other seemingly permanent, environment variable, tests can work in a completely different way. </li><li>  Also in this implementation, I do not look at situations where the code is multithreaded.  For such situations, I am again not sure that this will work correctly. </li></ul><br>  And, considering all these reservations ... Is it worth using?  Definitely, yes.  This technique helped me find many bugs that were fixed. <br><br><h4>  Fix cyclic dependencies </h4><br>  In the past, I ‚Äúfixed‚Äù the type initialization order simply by moving the field code.  Cycles still existed, but I figured out how to make them harmless.  I can say that this approach is not scalable and costs much more effort than it seems.  The code becomes difficult ... And if you once get a cycle in more than two dependencies, it will be a problem for the mind how to make it safe.  At the moment I use a very simple technique to implement the deferred initialization of static variables. <br><br>  So instead of looking for what the <code>static readonly field</code> creates for you a cyclic dependency, you use the <code>static readonly property</code> , which returns an <code>internal static readonly field</code> , in a nested, private static class.  We still have thread-safe initialization with a single call guarantee, but the <code>nested</code> type will not be initialized until there is a need for it. <br>  So instead: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Requires Bar to be initialized - if Bar also requires Foo to be // initialized, we have a problem... public static readonly Foo SimpleFoo = new Foo(Bar.Zero);</span></span></code> </pre><br><br>  We will write: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Foo SimpleFoo { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Constants.SimpleFoo; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Constants</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TypeInitializationChecking = NodaTime.Utility.TypeInitializationChecker.RecordInitializationStart();     <span class="hljs-comment"><span class="hljs-comment">// This requires both Foo and Bar to be initialized, but that's okay    // so long as neither of them require Foo.Constants to be initialized.    // (The unit test would spot that.)    internal static readonly Foo SimpleFoo = new Foo(Bar.Zero); }</span></span></code> </pre><br><br>  At the moment I cannot determine whether to include static constructors in these classes in order to achieve lazy initialization or not.  If an initializer of type Foo calls an initializer of type Foo.Constants, we will return to the starting point.  But adding static constructors in each of the nested classes sounds awful. <br><br><h4>  Conclusion </h4><br>  I want to tell you that some part of me in reality does not like writing test code or doing workarounds and crutches.  And it is definitely worth considering whether it is possible to actually get rid of the initialization of types (or part of it), avoiding storage only in static fields.  It would be very nice if you could find all these dependencies avoiding running a program or unit tests.  So that it can be done using a static analyzer.  When I have a chance, I will try to find out if <code>NDepend</code> help me with this. <br><br>  However, while this approach looks like some kind of hacking, it is still better than the alternative ‚Äî a code full of errors.  And ... I am ashamed to say, but I do not think that in <code>Noda Time</code> I found all the cyclical dependencies.  It is worth trying it out on your own code - see where you may have hidden problems. <br><br><h4>  Application: Testing Code </h4><br><br><h5>  TypeInitializationChecker </h5><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeInitializationChecker</span></span> : <span class="hljs-title"><span class="hljs-title">MarshalByRefObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Dependency&gt; dependencies = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MethodInfo EntryMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TypeInitializationChecker).GetMethod(<span class="hljs-string"><span class="hljs-string">"FindDependencies"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecordInitializationStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependencies == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } Type previousType = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">var</span></span></span><span class="hljs-function"> frame </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StackTrace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFrames</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = frame.GetMethod(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method == EntryMethod) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declaringType = method.DeclaringType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method == declaringType.TypeInitializer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousType != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { dependencies.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dependency(declaringType, previousType)); } previousType = declaringType; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Invoked from the unit tests, this finds the dependency chain for a single type </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> by invoking its type initializer. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public Dependency[] FindDependencies(string name) { dependencies = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Dependency&gt;</span></span></span><span class="hljs-comment">(); Type type = typeof(TypeInitializationChecker).Assembly.GetType(name, true); RuntimeHelpers.RunClassConstructor(type.TypeHandle); return dependencies.ToArray(); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> A simple from/to tuple, which can be marshaled across AppDomains. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> internal sealed class Dependency : MarshalByRefObject { public string From { get; private set; } public string To { get; private set; } internal Dependency(Type from, Type to) { From = from.FullName; To = to.FullName; } } }</span></span></code> </pre><br><br><h5>  TypeInitializationTest </h5><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeInitializationTest</span></span> { [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildInitializerLoops</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Assembly assembly = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TypeInitializationChecker).Assembly; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dependencies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TypeInitializationChecker.Dependency&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Test each type in a new AppDomain - we want to see what happens where each type is initialized first. // Note: Namespace prefix check is present to get this to survive in test runners which // inject extra types. (Seen with JetBrains.Profiler.Core.Instrumentation.DataOnStack.) foreach (var type in assembly.GetTypes().Where(t =&gt; t.FullName.StartsWith("NodaTime"))) { // Note: this won't be enough to load the assembly in all test runners. In particular, it fails in // NCrunch at the moment. AppDomainSetup setup = new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }; AppDomain domain = AppDomain.CreateDomain("InitializationTest" + type.Name, AppDomain.CurrentDomain.Evidence, setup); var helper = (TypeInitializationChecker)domain.CreateInstanceAndUnwrap(assembly.FullName, typeof(TypeInitializationChecker).FullName); dependencies.AddRange(helper.FindDependencies(type.FullName)); } var lookup = dependencies.ToLookup(d =&gt; d.From, d =&gt; d.To); // This is less efficient than it might be, but I'm aiming for simplicity: starting at each type // which has a dependency, can we make a cycle? // See Tarjan's Algorithm in Wikipedia for ways this could be made more efficient. // http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm foreach (var group in lookup) { Stack&lt;string&gt; path = new Stack&lt;string&gt;(); CheckForCycles(group.Key, path, lookup); } } private static void CheckForCycles(string next, Stack&lt;string&gt; path, ILookup&lt;string, string&gt; dependencyLookup) { if (path.Contains(next)) { Assert.Fail("Type initializer cycle: {0}-{1}", string.Join("-", path.Reverse().ToArray()), next); } path.Push(next); foreach (var candidate in dependencyLookup[next].Distinct()) { CheckForCycles(candidate, path, dependencyLookup); } path.Pop(); } }</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/19d/045/afa19d045b2bce238895a5f2856f9174.gif"></div><p>Source: <a href="https://habr.com/ru/post/143936/">https://habr.com/ru/post/143936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143928/index.html">Grape multitouch</a></li>
<li><a href="../143931/index.html">A variety of Android devices</a></li>
<li><a href="../143932/index.html">The history of a single reengineering or RNAInSpace v.1.3. Demo</a></li>
<li><a href="../143934/index.html">Integrating TortoiseSVN into Total Commander</a></li>
<li><a href="../143935/index.html">How to backup data and MySQL in Amazon Web Services</a></li>
<li><a href="../143937/index.html">Upgrade by jump or difficult fate of the iPad line</a></li>
<li><a href="../143938/index.html">Demonstration of HTML5 applications on Tizen</a></li>
<li><a href="../143939/index.html">Runetology (147): founder of the Kavanga advertising network Sergey Zhuravlev</a></li>
<li><a href="../143941/index.html">Errors of technology transfer ‚Ññ4 / ‚ÄúErrors of authorship‚Äù + ‚Äã‚ÄãAPDATE</a></li>
<li><a href="../143942/index.html">Cashless business trip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>