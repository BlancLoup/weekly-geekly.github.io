<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood Redis: Hash table (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you know why after running `hset mySey foo bar` we will spend at least 296 bytes of RAM, why instagram engineers do not use string keys, why you sh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood Redis: Hash table (part 1)</h1><div class="post__text post__text-html js-mediator-article">  If you know why after running `hset mySey foo bar` we will spend at least 296 bytes of RAM, why instagram engineers do not use string keys, why you should always change <i>hash-max-ziplist-entries</i> / <i>hash-max-ziplist-val</i> and why the data type underlying the <i>hash</i> is and the list, sorted set, set part - do not read.  For the rest I will try to tell about it.  Understanding the structure and operation of hash tables in Redis is crucial when writing systems where memory savings are important. <br><br>  What is this article about - what expenses does Redis incur for storing the key itself, what is a <i>ziplist</i> and <i>dict</i> , when and for what purpose they are used, how much is occupied in memory.  When <i>hash</i> is stored in <i>ziplist</i> , when in <i>dicth</i> and what it gives us.  What tips from fashionable articles about Redis optimization should not be taken seriously and why. <a name="habracut"></a><br><blockquote>  I want to immediately apologize for breaking the material into two articles.  Having finished the part about the dictionary, I realized that the second part - about the ziplist, is a little less than the first.  As a result, after tests on colleagues, I decided to split it into two parts. </blockquote><br>  First, we need to understand how the individual structures that underlie <a href="http://redis.io/topics/data-types">Hashes work</a> .  Then we calculate the cost of storing data.  It will be easier for you to understand the material if you already know what redisObject is and how Redis <a href="http://habrahabr.ru/post/271487/">stores strings</a> . <br><blockquote>  There is some confusion that the hashes structure is perceived as a hash table.  Under the hood there is a separate type of dict, which is a real hash table.  The structure itself hashes a hybrid of dict and ziplist.  We need a <i>great</i> introduction on how the hash tables are organized and work.  By showing an article without this material to several of my colleagues, I became convinced that without it, everything becomes more confusing. <br></blockquote><br>  In Redis, you control which internal data type a particular hash key is represented.  The variable <i>hash-max-ziplist-entries</i> determines the maximum number of elements in a hash with a cat, you can use the encoding <i>REDIS_ENCODING_ZIPLIST</i> .  For example, with hash-max-ziplist-entries = 100 your hash will be represented as a ziplist, as long as it contains less than 100 items.  As soon as there are more items, it will be converted to <i>REDIS_ENCODING_HT</i> (dict).  <i>Hashh-max-ziplist-val</i> works in a similar way - as long as the length of any value of any individual field in a hash does not exceed the <i>hash-max-ziplist-val</i> , the ziplist will be used.  The parameters work in pairs - the internal representation from the ziplist in dict will happen as soon as any of them is exceeded.  By default, any hash always has a ziplist encoding. <br><br>  <i>Dictionaries (dict)</i> - the key structure of Redis.  Not only for hashes, but also for list, zset, set.  This is the main structure that Redis uses to store any data bundles of the key-value type.  Redis dictionaries are a classic hash table that supports insert, replace, delete, search, and get random entries.  The entire implementation of dictionaries can be found in dict.h and disc.c in the Redis sources. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Any hash table has a number of parameters that are critical for understanding its effectiveness and choosing the right implementation.  In addition to <i>algorithmic complexity</i> important for any data structure <i>,</i> it is also a number of factors that directly depend on the conditions of use.  In this vein, the <b>fill factor</b> and the <i>resizing strategy are</i> particularly interesting.  The latter is especially important in any system operating in real time, since any of the available theoretical implementations always puts you in front of a choice - to spend a lot of RAM or CPU time.  Redis uses the so-called <b>incremental resizing</b> .  Although there are suggestions to try and linear hashing, monotonic keys, consistent hashing, resizing by copying, depending on the specifics of the hash. <br><br>  The implementation of incremental resizing (functions <i>dictRehashMilliseconds</i> , <i>dictRehash</i> in dict.c), comes down to the fact that: <br><ol><li>  When resizing a table, we allocate a new hash table that is obviously larger than the existing one (and do not change the old one).  As with the rows, Redis will double the number of slots in the new table.  At the same time, any requested size (including the initial one) will always be aligned upward to the nearest power of two.  For example, you need 9 slots, it will be allocated - 16. The minimum limit for the new table is determined by the compile stage constant <i>DICT_HT_INITIAL_SIZE</i> (default 4, defined in dict.h). </li><li>  During each read / write operation we look in both tables. </li><li>  All insert operations are carried out only in a new table. </li><li>  For any operation, we move <b>n</b> elements from the old table to the new one. </li><li>  Delete the old table if all items are moved. </li></ol><br>  In the case of Redis, <b>n</b> is the number of keys that the server managed to transfer in 1 millisecond from steps 1000. In other words, 1 step of rehashing is at least 1000 items.  This is important because when using keys with long string values, such an operation can significantly exceed 1 ms, causing the server to hang.  An additional aspect is the large peak memory consumption when rehashing the table, which is acute in the hashes with a large number of ‚Äúlong‚Äù keys.  When calculating, we will consider tables outside of hashing, remembering, however, that if there is a large table in our Redis node, there is a high probability that we will refuse to serve if we cannot change its size.  For example, if you rent budget Redis on <a href="https://www.heroku.com/redis">heroku</a> (only 25 MB of memory). <br><br>  <i>The fill factor</i> (the constant <i>dict_force_resize_ratio</i> is equal to the default 5) determines the degree of sparsity in the dictionary and when Redis starts the process of doubling the size of the current dictionary.  The current value of the fill factor is defined as the ratio of the total number of elements in the hash table to the number of slots.  In other words, if we have only 4 slots and 24 elements (distributed between them), Redis will decide to double the size (24/4&gt; 5).  A similar check happens every time you access any dictionary key.  If the number of elements becomes equal or exceeds the number of slots - Redis will also try to double the number of slots. <br><br><img src="https://habrastorage.org/files/987/ffd/b7a/987ffdb7afc6411d8dd01eebf1b845cf.png"><br><div class="spoiler">  <b class="spoiler_title">Look at this structure in the source code.</b> <div class="spoiler_text"><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dict</span></span></span><span class="hljs-class"> {</span></span> dictType *type; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *privdata; dictht ht[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> rehashidx; <span class="hljs-comment"><span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterators; <span class="hljs-comment"><span class="hljs-comment">/* number of iterators currently running */</span></span> } dict; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictht</span></span></span><span class="hljs-class"> {</span></span> dictEntry **table; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sizemask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> used; } dictht; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *key; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> s64; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d; } v; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictEntry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> } dictEntry;</code> </pre> <br></div></div><br>  Each dictionary is built around the use of three structures - <i>dict</i> , <i>dictht</i> and <i>dictEntry</i> .  Dict is the root structure, in its <i>ht</i> field it is stored from 1 to 2 (during resheng) of the dictht tables with the list of slots.  In turn, <i>dictht</i> stores a linked list from <i>dictEntry</i> .  Each <i>dictEntry</i> stores a pointer to the key and value (as a pointer or double / uint64_t / int64_t).  If you use number as the value - <i>dictEntry</i> will store the number, store the string - the pointer to the <i>redisObject</i> with the sds string on board will be saved. <br><br>  When Redis accesses a specific key within the hash table: <br><ol><li>  With the help of the hashing function, the required slot is found (the hashing function <a href="https://ru.wikipedia.org/wiki/Murmur2">MurMur2</a> is currently used to search for the slot). </li><li>  All values ‚Äã‚Äãof the slot are sorted one by one (linked list), comparing the keys. </li><li>  The requested operation is performed on dictEntry (with key and value) </li></ol><br>  The help for <a href="http://redis.io/commands/hset">HSET</a> or <a href="http://redis.io/commands/hget">HGET</a> says that these are operations performed in <b>O (1)</b> .  Believe with caution: most of the time your hset will occupy <b>O (n)</b> .  In large tables (more than 1000 items) with an active hget record, it will also occupy <b>O (n)</b> . <br><blockquote>  The answer to the question how much memory will actually be used depends on the operating system, compiler, type of your process, and the allocator used (in redis, by default, jemalloc).  All further calculations I cite for redis 3.0.5 compiled on a 64 bit server running centos 7. <br></blockquote><br>  Now you can calculate how much memory is spent when you call `hset mySet foo bar`.  Overhead to create an empty dictionary: <br><ul><li>  <b>dictEntry</b> : 3 * size_of (pointer) <br></li><li>  <b>dictht</b> : 3 * size_of (unsigned longs) + size_of (pointer) = 24 + size_of (pointer) <br></li><li>  <b>dict</b> : 2 * size_of (dictht) + 2 * size_of (int) + 2 * size_of (pointer) = 56 + 4 * size_of (pointer) <br></li></ul><br>  If we put everything together, we get a formula for calculating the approximate overhead costs for storing n elements: <br><pre> <code class="bash hljs"> 56 + 2 * size_of(pointer) + 3 * next_power(n) * size_of(pointer) ------------------------- ------------------------------------- | | ` dict + dictht `dictEntry</code> </pre><br><br>  This formula does not include the cost of storing the key itself and the value.  The key is always the sds string in redisObject.  The value, depending on the type, can be the string sds or native numbers (integer or floating point).  Check for `hset mySet foo bar`, remembering that the minimum number of slots (dictEntry) in the new dictionary is equal to <i>DICT_HT_INITIAL_SIZE (4)</i> : <br><blockquote>  56 + 2 * 8 + 3 * 4 * 8 = 168 + 2 * 56 = 280 bytes (will be aligned to 296 bytes). <br></blockquote><br>  Checking: <br><pre> <code class="bash hljs">config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-entries 0 +OK config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-value 1 +OK hset mySet foo bar :1 debug object mySet +Value at:0x7f44894d6340 refcount:1 encoding:hashtable serializedlength:9 lru:5614464 lru_seconds_idle:6</code> </pre><br>  What does <i>info memory</i> show?  It will show you that 320 bytes are spent.  24 bytes more than we expected.  This memory is the alignment cost of allocating memory. <br><br>  How was the <b>mySet</b> key itself saved and how does Redis find our hash by that name?  At the very heart of Redis lies the <i>redisDb</i> structure (redis database representation, in redis.h).  It contains a single dict dictionary for all keys.  Exactly the same as described above.  This is important because it gives an idea of ‚Äã‚Äãthe cost of storing the key database and will give us a basis for understanding the tips that in one instance you should not store a lot of simple keys. <br><br>  Let's see what they say in the article <a href="http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value">storing hundreds of millions of simple keys</a> .  If you need to store many key-value pairs, do not use string keys, use a hash table. <br>  <a href="https://gist.github.com/mikeyk/1329319">A gist with a dough</a> from an instagram article, we will write to LUA so that it doesn‚Äôt require anything other than running Redis to check: <br><pre> <code class="bash hljs">flushall +OK info memory <span class="hljs-variable"><span class="hljs-variable">$225</span></span> <span class="hljs-comment"><span class="hljs-comment"># Memory used_memory:508408 eval "for i=0,1000000,1 do redis.call('set', i, i) end" 0 $-1 info memory $226 # Memory used_memory:88578952</span></span></code> </pre><br>  It took us a <b>little more than 88 MB</b> to store 1,000,000 integer keys.  Now we will save the same data in a hash table, evenly distributing keys between 2000 hash tables: <br><pre> <code class="bash hljs">flushall +OK info memory <span class="hljs-variable"><span class="hljs-variable">$227</span></span> <span class="hljs-comment"><span class="hljs-comment"># Memory used_memory:518496 eval "for i=0,1000000,1 do local bucket=math.floor(i/500); redis.call('hset', bucket, i, i) end" 0 $-1 info memory $229 # Memory used_memory:104407616</span></span></code> </pre><br>  To store the same data with integer fields, we spent a <b>little more than 103 MB</b> .  However, should we try to keep say 10,000,000 keys, the situation will change dramatically, namely <b>~ 970 mb</b> versus <b>~ 165 mb</b> (and all of them are in the overhead of storage in the system hash table of keys).  In general, the rule ‚Äúif you have hundreds of millions of keys, do not use string keys‚Äù is true. <br><br>  Let's look at another aspect.  Very often describing optimizations of this type, it is assumed that you have many keys of the form <i>entity: identifier</i> (for example, `set username: 4566 RedisMan`) and suggest switching to using hash tables <br>  <i>bucket: id id value</i> (for example `hset usernames: 300 4566 RedisMan`).  It is important to understand that a partial substitution of concepts takes place here - the sds string `username: 4566` is transformed into the key field 4566 with the encoding <i>REDIS_ENCODING_INT</i> .  This means that instead of sds the lines in redisObject began to use a number, thus the minimum 32 bytes on the sds line (after aligning jemalloc) turned into 4 bytes. <br><br>  Let's force the hash table encoding to the ziplist: <br><pre> <code class="bash hljs">config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-entries 1000 +OK config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-value 1000000 +OK flushall +OK <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> <span class="hljs-string"><span class="hljs-string">"for i=0,1000000,1 do local b=math.floor(i/500); redis.call('hset', 'usernames:' ..b, i, i) end"</span></span> 0 $-1 info memory <span class="hljs-variable"><span class="hljs-variable">$228</span></span> <span class="hljs-comment"><span class="hljs-comment"># Memory used_memory:16816432</span></span></code> </pre><br>  The storage of our data took only 16 mb or 72 mb of savings ( <b>5 times less</b> ) with my example of 1,000,000 keys.  Tempting?  We will proceed to the explanation in the second part of the article. <br><br>  In the intermediate conclusion it is worthwhile to formulate several important conclusions for a loaded system, which should save memory: <br><ul><li>  Use the numeric names of keys, values, fields in hash tables wherever possible.  Do not use prefixes / postfixes. </li><li>  When designing systems that actively use Redis, proceed from the principle: one set of data requirements - one Redis.  It is difficult to store heterogeneous data due to the settings of hash-max-ziplist-entries / hash-max-ziplist-value and the delimitation of keys without prefixes. </li><li>  Replacing simple keys with groups of hash tables, remember that your optimization works with the number of keys from a million and above. </li><li>  If there are millions and hundreds of millions of keys in your copy, you incur enormous expenses for storing them in the system dictionary and memory overspending on the system dictionary.  For example, for 100 million keys, this will be about 2.5 GB only for the system dict itself, without taking into account your data. </li><li>  If you pass under hash-max-ziplist-entries / hash-max-ziplist-value values ‚Äã‚Äãand your data is stored in a ziplist, instead of dict you can save memory, expressed in hundreds of percent.  And pay for it with high CPU usage.  About this further. <br></li></ul><br>  Table of contents: <br><ul><li>  <a href="http://habrahabr.ru/post/271487/">Under the hood Redis: Strings</a> <br></li><li>  Under the hood Redis: Hash table (part 1) <br></li><li>  <a href="http://habrahabr.ru/post/272089/">Under the hood Redis: Hash table (part 2) and List</a> <br></li></ul><br>  The materials used in writing the article: <br><ul><li>  <a href="http://redis.io/topics/memory-optimization">redis.io/topics/memory-optimization</a> <br></li><li>  <a href="http://openmymind.net/Back-To-Basics-Hasthables-Part-2/">Back To Basics: Hashtables Part 2</a> by <a href="https://twitter.com/karlseguin">Karl Seguin</a> <br></li><li>  <a href="https://en.m.wikipedia.org/wiki/Hash_table">en.m.wikipedia.org/wiki/Hash_table</a> </li><li>  <a href="http://blog.wjin.org/posts/redis-internal-data-structure--dictionary.html">Redis Internal Data Structure: Dictionary</a> by <a href="https://www.linkedin.com/in/wjin0">Wei Jin</a> </li><li>  <a href="https://github.com/antirez/redis/tree/3.0.5/src">Redis 3.0.5</a> sources </li><li>  <a href="http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633">Excellent answer to stackexchange</a> about speed and problems with collisions in different hashing algorithms </li><li>  <a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-Memory-Optimization">github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-Memory-Optimization</a> </li><li>  <a href="http://instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value">instagram-engineering.tumblr.com/post/12202313862/storing-hundreds-of-millions-of-simple-key-value</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/271205/">https://habr.com/ru/post/271205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271197/index.html">Nim Tutorial (Part 1)</a></li>
<li><a href="../271199/index.html">Main announcements of the Microsoft Connect conference () and the virtual conference Visual Studio Connect 2015 in Russia on December 4</a></li>
<li><a href="../2712/index.html">Diskettes will disappear from British stores</a></li>
<li><a href="../271201/index.html">Why constantly writing code is so important - how not to become a catfish</a></li>
<li><a href="../271203/index.html">Secure TLS connection using Boost.Asio and OpenSSL under Windows</a></li>
<li><a href="../271207/index.html">How does the video analytics</a></li>
<li><a href="../27121/index.html">iPhone 2</a></li>
<li><a href="../271211/index.html">Hackers invented a new money theft scheme, stealing 250 million rubles</a></li>
<li><a href="../271213/index.html">We invite you to the December Moscow mitap RuHaskell</a></li>
<li><a href="../271215/index.html">Protected social networks - myth or reality?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>