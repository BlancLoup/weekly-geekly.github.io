<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of cross-platform mobile development frameworks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 At work, I repeatedly had to deal with the choice of a suitable technology for mobile development. Below, I tried to build and classi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of cross-platform mobile development frameworks</h1><div class="post__text post__text-html js-mediator-article"><h1 id="vvedenie">  Introduction </h1><br><p>  At work, I repeatedly had to deal with the choice of a suitable technology for mobile development.  Below, I tried to build and classify the main frameworks according to the approaches used, advantages and disadvantages. </p><a name="habracut"></a><br><p>  If some of my information is incorrect or outdated - comments are welcome. </p><br><h1 id="obschie-minusy-kross-platformennoy-razrabotki">  Common disadvantages of cross-platform development </h1><br><h2 id="ogranichennaya-podderzhka-platformy">  Limited platform support </h2><br><p>  Any cross-platform framework is a layer of abstraction over the native platform and allows you to access only those capabilities that are directly supported by the framework. </p><br><p>  In most cases, it is possible to expand support for the platform's capabilities by writing native plug-ins to the framework, but in some cases this can significantly complicate the development.  A recent example from the acclaimed AirBnb article is React Native, which currently does not know how to work out of the box with 64-bit Android libraries. </p><br><p>  You also need to note that native plug-ins and the main code of the cross-platform application are usually executed in different processes and the interaction between them can cause performance problems.  To work with sensors, or SQLite, this is usually not a problem, but if you use, say, the OpenCV library as a native plugin and start throwing video between it and the main application, the slowdown can be significant. </p><br><h2 id="ogranichennoe-predlozhenie-na-rynke-truda">  Limited labor supply </h2><br><p>  First, the very presence of developers depends on the prevalence of the framework.  Finding people under React Native can even be easier than with native developers, and, for example, with Flutter is much more difficult. </p><br><p>  How much this factor needs to be taken into account depends on the tasks.  Most startups may not pay attention to it, since learning a new technology is more likely a bonus for existing and potential employees.  On the other hand, big business is forced to take into account the labor market. </p><br><h2 id="riski-podderzhki">  Support risks </h2><br><p>  It is believed that the likelihood that support for the cross-platform framework will end is much higher than the probability of the same event in relation to the mobile OS. </p><br><p>  In fact, the question is quite complicated.  The OS can be closed in the same way as frameworks (the example of Windows Phone is completely fresh).  In addition, within the native development, individual technologies can also be closed, and sometimes the code on cross-platform frameworks has a greater survivability. </p><br><p>  An example of this is in the field of games and multimedia - Apple is going to send the OpenGL technology back to its OS and everyone who wrote native 3D applications will have to rewrite them completely to release new versions.  At the same time, for those who used cross-platform game engines (for example, Unity), the update will not require any additional effort. </p><br><h1 id="osnovnye-napravleniya">  Main directions </h1><br><h2 id="gibridnaya-razrabotka-htmljavascript">  Hybrid Development, HTML + JavaScript </h2><br><p>  Technically, hybrid-type applications are an HTML page displayed in an embedded browser.  In general, the framework is not mandatory for this approach, but Cordova provides a set of plug-ins to access the capabilities of the platform, which is why they usually use it. </p><br><h3 id="osnovnye-plyusy">  The main advantages </h3><br><h4 id="minimalnaya-stoimost-razrabotki">  Minimum development cost </h4><br><p>  The hybrid approach allows you to reuse not only the skills of developers, but also code written for websites. </p><br><h4 id="vozmozhnost-integracii-veb-elementov">  The ability to integrate web elements </h4><br><p>  The number of libraries for HTML / JS significantly exceeds the number of those for native applications.  Of interest, this includes, for example, Google Analytics, or a rich selection of ad networks. </p><br><h3 id="osnovnye-minusy">  Main disadvantages </h3><br><h4 id="nevysokaya-proizvoditelnost">  Low productivity </h4><br><p>  By itself, modern JavaScript uses JIT compilation, is well optimized and works fast, but building an interface based on a DOM tree is not a very efficient process.  Using modern JS frameworks gives an additional level of load.  For weak phones and / or with the active use of interactive elements, this can be a problem. </p><br><h4 id="nenativnoe-oschuschenie">  ‚ÄúNative feeling‚Äù </h4><br><p>  This is a rather informal, but very important point.  The site in the browser responds to gestures and is displayed a little differently from the mobile app.  The most noticeable element of this sensation, the delay of 300ms when pressed, Cordova decides, but many other details remain. </p><br><h4 id="problema-brauzernoy-sovmestimosti">  Browser compatibility issue </h4><br><p>  On older versions of Android (prior to version 5), WebView was part of the platform and was not automatically updated.  Accordingly, the use of modern browser capabilities in hybrid applications on these devices will not work. </p><br><p>  As a result, hybrid applications either limit the minimum version of Android (leaving about 13% of devices currently), or include WebView in the application code (CrossWalk project), increasing the size of the application by several tens of megabytes. </p><br><h3 id="prednaznachenie">  Purpose </h3><br><p>  Fast creation of one-time applications.  With a substantial development budget, a hybrid approach is usually disdained. </p><br><h3 id="osnovnye-freymvorki">  Core frameworks </h3><br><p>  The basis of all the main hybrid frameworks is Cordova, which provides access to native plugins.  PhoneGap provides tools for building on top of Cordova, while Ionic is a framework and a set of components for building user interfaces in it. </p><br><h2 id="nativnyy-ui-obschiy-kod">  Native UI, common code </h2><br><p>  It is important to note that with this approach, the user interface and business logic are executed in different processes that interact through a bridge (‚Äúbridge‚Äù).  A number of drawbacks are associated with this. </p><br><p>  This approach has several implementation options. </p><br><h3 id="klassifikaciya-po-rabote-ispolnyaemogo-koda">  Classification by the work of executable code </h3><br><h4 id="kompiliruemyy-kod">  Compiled code </h4><br><p>  Xamarin uses C # language, compiling it into native platform code.  In general, this approach provides a fairly small size of the application and a fairly high speed of work. </p><br><h4 id="interpretiruemyy-yazyk-s-jit-kompilyaciey">  Interpreted language with JIT compilation </h4><br><p>  Most of the frameworks of this approach use javascript to handle business logic. </p><br><h3 id="klassifikaciya-po-sposobu-opisaniya-interfeysa">  Classification by way of interface description </h3><br><h4 id="nativnye-instrumenty">  Native tools </h4><br><p>  Xamarin not only uses native interface components, but also describes them in the format adopted for each platform. </p><br><h4 id="universalnye-elementy-interfeysa">  Universal interface elements </h4><br><p>  Xamarin Forms and Appcelerator use their own set of widgets, which is converted to the appropriate interface components of each platform. </p><br><h4 id="raznyy-interfeys-dlya-raznyh-platform-no-obschiy-podhod">  Different interface for different platforms, but a common approach </h4><br><p>  React Native uses wrappers around native interface components.  Accordingly, the interface is described for each platform separately, but the method of description is one. </p><br><h3 id="osnovnye-plyusy-1">  The main advantages </h3><br><h4 id="polnostyu-nativnyy-interfeys">  Fully native interface </h4><br><p>  First, the appearance and ‚Äúfeel‚Äù of the application fully coincide with the native applications. </p><br><p>  Secondly, it allows the use of native interfaces libraries in applications.  Using native ads (Native Ads), focused on mobile applications, in other approaches will not work.  True, for this approach, the set of relevant libraries is very limited.  I only know about the support of Facebook Native Ads in React Native. </p><br><h4 id="vozmozhnost-pereispolzovaniya-kvalifikacii-razrabotchikov">  Ability to reuse developer qualifications </h4><br><p>  Many of the frameworks of this group are designed so that developers from other areas can learn how to create mobile applications with minimal cost.  For React Native - this is React, for Xamarin - .NET, etc. </p><br><h3 id="osnovnye-minusy-1">  Main disadvantages </h3><br><h4 id="ogranichenie-vozmozhnostey-interfeysa-ili-dopolnitelnye-zatraty-na-razdelnuyu-razrabotku">  Restricting interface capabilities, or additional costs for separate development </h4><br><p>  The format of this minus depends on the classification of the framework by the way the interface is described: </p><br><p> Xamarin allows you to use almost all the capabilities of the platforms, but you have to spend a lot of time on the interfaces for each platform.  As a result, labor costs are not much less than with native development. </p><br><p>  Xamarin Forms and Appcelerator allow you to describe interfaces only once, but they work with a very limited subset of native functionality (no more than the minimum intersection of the capabilities sets of each platform, to be formal). </p><br><p>  React Native is in the middle, combining both shortcomings, but in a less pronounced form. <br>  Interface Interaction Performance <br>  This is where the factor of interface execution and business logic in different processes comes into play.  When it is necessary to exchange large amounts of information at a high speed across the bridge (complex animation with high frequency), this approach can cause difficulties. </p><br><h4 id="utechki-pamyati">  Memory leaks </h4><br><p>  Memory leaks can occur in any application, but garbage collectors do a great job with most standard situations. </p><br><p>  The problem with cross-platform native-interface applications is again that they are executed in two processes with separate garbage collectors.  If a business logic object refers to an interface object, this interface object is not garbage, because  there is a link to it from the bridge.  If the interface object refers back to the business logic object, they will not be considered garbage even if there are no more references to them. </p><br><p>  Chances to meet the problem and its scale directly depend on the application.  If it actively creates and deletes objects associated with the interface (as in endless scrolling), the probability of leakage increases.  If these objects are large (for example, images), the leakage effect will increase. </p><br><p>  Actually, this problem is also present when working with native plugins, which are also executed in a separate process.  But there, in most cases, either there is no such intensive manipulation of large objects, or the interaction proceeds in a strictly procedural approach, without cross-references. </p><br><h3 id="prednaznachenie-1">  Purpose </h3><br><p>  Applications with a completely native interface, especially if you have experts in related technologies. </p><br><h3 id="osnovnye-freymvorki-1">  Core frameworks </h3><br><h4 id="react-native">  React native </h4><br><p>  It has Facebook support and uses the approach of the most popular JS framework React, due to which it is very popular.  A recent article about the refusal of AirBnb from React Native made a lot of noise, but if you are aware of the risks, it can be a very effective solution. </p><br><h4 id="xamarin">  Xamarin </h4><br><p>  In addition to the main approach, it has the Xamarin.Forms library, which allows you to design simple interfaces efficiently and cross-platform.  Actively supported by Microsoft.  When working with ASP.NET on the server, you can also save a certain amount of work through the use of common business logic classes on the server and in the mobile application. </p><br><h4 id="nativescript">  NativeScript </h4><br><p>  It is modeled on React Native for developers owning other JS frameworks (Angular and Vue.js).  Less popular, but has a number of more modern solutions in architecture. </p><br><h2 id="sobstvennyy-ui-obschiy-kod">  Own UI, common code </h2><br><p>  Almost all game engines use this approach, but they are beyond the scope of this article. </p><br><p>  The principle of this approach is that the application uses its own code and its own user interface drawing. </p><br><h3 id="osnovnye-plyusy-2">  The main advantages </h3><br><h4 id="vysokaya-proizvoditelnost-interfeysov">  High performance interfaces </h4><br><p>  In fact, an application that independently draws its interface performs the same operations as the OS in the native interface.  In theory, it can be even faster, because  There is no switching between the process and the core, but in practice other factors affect the rendering speed of a particular interface, play a much larger role. </p><br><h4 id="dizaynerskie-interfeysy">  ‚ÄúDesigner Interfaces‚Äù </h4><br><p>  Native applications use ready-made interface components and have some limitations in what can be done with them.  In turn, applications that draw their own interface do not have such limitations and can freely mix ready-made elements with individual rendering. </p><br><h3 id="osnovnye-minusy-2">  Main disadvantages </h3><br><p>  These disadvantages are relevant only for applications that mimic the standard interface of the OS.  As already mentioned, this approach is optimal for design interfaces and games. </p><br><h4 id="razmer-prilozheniya">  Application size </h4><br><p>  Applications with this approach are forced to carry with them the code to draw all interface elements, including the conventionally standard ones.  This affects both the size of the application during installation, and the RAM at work. </p><br><p>  If the first problem can be minimized with an effective Tree Shaking (as the latest Flutter versions do), then these applications consistently lose their RAM by native memory.  However, this problem is typical for other cross-platform frameworks. </p><br><h4 id="nenativnyy-interfeys">  Non-native interface </h4><br><p>  By default, the application looks the same on all platforms, which can create discomfort for users.  Topics are used to solve these problems, but they cannot create a feeling of a completely native application. </p><br><p>  But there is a bigger disadvantage - with this approach, it is most difficult to use third-party interface elements created for native applications (including the previously mentioned Native Ads). </p><br><h3 id="prednaznachenie-2">  Purpose </h3><br><p>  Shared applications, especially with a designer interface. </p><br><h3 id="osnovnye-freymvorki-2">  Core frameworks </h3><br><h4 id="flutter">  Flutter </h4><br><p>  Flutter is being promoted by Google as the main cross-platform development framework and the basis for the interface of their future OS Fuscia.  While the framework is very young (in the Release Preview stage) and not very common, but it is quickly gaining popularity.  Uses the Dart language (compiled into native code). </p><br><p>  It has all the pros and cons of youth - a thoughtful architecture, taking into account the mistakes of predecessors, but a rather limited ecosystem. </p><br><h4 id="qt-mobile">  QT Mobile </h4><br><p>  It is popular with desktop QT developers.  JavaScript can be used in development.  Without the support of large companies is not very popular. </p><br><h4 id="kivy">  Kivy </h4><br><p>  Another not very popular framework, which is interesting, primarily because it is the only framework in the list that uses the Python language.  For developers who are familiar only with this language (and there are many of them in some areas of information technology), this can be crucial. </p><br><h1 id="materialy-po-teme">  Materials on the topic </h1><br><p>  <a href="https://habr.com/post/330854/">On the work of memory in Xamarin and similar frameworks</a> <br>  <a href="https://robots.thoughtbot.com/examining-performance-differences-between-native-flutter-and-react-native-mobile-development-take-two">Performance comparison of native applications, Flutter and React Native</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/421227/">https://habr.com/ru/post/421227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421215/index.html">How I hacked Steam. Twice</a></li>
<li><a href="../421217/index.html">Python support in Power BI</a></li>
<li><a href="../421221/index.html">Severe Therapy: Pale Anti-Fever for MacOS</a></li>
<li><a href="../421223/index.html">DevFest SPB 2018</a></li>
<li><a href="../421225/index.html">SENS-diagnostics. Biomarkers of mitochondrial dysfunction and oxidative stress</a></li>
<li><a href="../421229/index.html">Story of my headache</a></li>
<li><a href="../421235/index.html">Magic Leap One glasses - points for $ 2295 with maintainability 3 of 10</a></li>
<li><a href="../421241/index.html">The Central Bank asks for authority to block pre-trial malicious sites</a></li>
<li><a href="../421243/index.html">LLTR Part 2: Algorithm for determining the network topology from the collected statistics</a></li>
<li><a href="../421245/index.html">C #: one use case for any tasks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>