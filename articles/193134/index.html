<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PACS server do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, our company finished work on the implementation of a PACS server ( Picture Archiving and Communication System ) in one of our medical...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PACS server do it yourself</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, our company finished work on the implementation of a PACS server ( <i>Picture Archiving and Communication System</i> ) in one of our medical diagnostic centers.  Prior to that, there was an open source PACS server - <a href="http://www.dcm4che.org/confluence/display/ee2/Home">dcm4chee</a> , which did not shine with high speed, since it was written in Java.  In addition, one of the customer's requirements was to have access to the internal structure of the server.  Therefore, it was decided to write your own.  In addition, the company had experience of similar developments in both client and server parts of PACS systems, so a compromise solution was to create its own PACS archive that satisfies customer requirements.  Most of the implementation of the server core I had to deal with and during that time I had gained specific experience in this area, which I want to share with the Habra community.  But first things first. <br><a name="habracut"></a><br><h5>  Preamble </h5><br>  For a common understanding, consider the role of the PACS system in the diagnostic center.  Any diagnostic center has diagnostic equipment: MRI, CT scanners, ultrasound stations or ECG devices (any of these devices in terms of the DICOM protocol is called Modality) and diagnostic software (our doctors used <a href="http://www.osirix-viewer.com/">OsiriX</a> ).  Having received images on the tomograph, it is necessary to send them to the diagnostic station.  Obviously, this requires a kind of integrating link that collects images from tomographs, ultrasound stations, ECG devices, and is able to search for and transmit images over the network.  This link is the PACS server: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/d5e/06f/470/d5e06f47032144c9530aa97848bff4da.jpg"></div><br>  It is obvious that a single protocol is needed for the interaction of different-quality medical equipment.  And just such a protocol is <a href="http://medical.nema.org/">DICOM</a> ( <i>Digital Imaging and Communications in Medicine</i> ), which over the past 20 years has been seriously improved, making it easy to integrate medical equipment into a common information system.  Almost all manufacturers of medical equipment follow this protocol.  Therefore, DICOM protocol support was a natural requirement for a PACS server.  It was decided to implement a multi-threaded high-loaded PACS that can work in a cluster.  The server was developed in C ++ and the most adequate library to work with the DICOM protocol, written in C ++ - <a href="">DCMTK, was used today</a> .  Thanks to this library, it became possible to <i>quickly</i> implement high-load PACS-systems. <br><br><h5>  Design database </h5><br>  The database in the PACS system allows you to store information about the saved images and search for them.  Images also need to be able to transmit over the network, and with it, meta-information about the image (who is in the picture, at what clinic they were made, who did the research, etc.).  For these purposes, the DICOM protocol provides a special 4-level data model, which can be briefly found <a href="http://ru.wikipedia.org/wiki/DICOM">here</a> .  A complete list of various file attributes can be found on the official protocol site [1].  In the images obtained from different devices, the list of these attributes will be different, which is completely normal.  However, some attributes remain mandatory to support universal image search.  There are few of them - only ten of them, among them Patient Name, Patient ID, Patient Birthday, Modality Type (CT, MRI, ultrasound, etc.), Study Date (study date), etc. In addition to the required parameters, there are optional, quite a lot of them and support they are in the database as practice shows - is superfluous. <br><br>  The presence of a large number of optional parameters in image meta-information is one of the drawbacks of the DICOM protocol.  Some devices expose some parameters, some - others.  Therefore, maintaining them in the database for search is meaningless.  As a result, having worked several options, we stopped at this version of the database: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/8aa/4ac/258/8aa4ac258d2d9b0b776ea9097b3f1997.jpeg"></div><br>  As you can see, the database schema corresponds to the multi-level structure of DICOM files.  One patient can have many stages (read studies).  The study is a series of series defined by the study protocol.  The series stores many images. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  The main functions of the PACS system </h5><br>  Consider briefly the main functions (services) of a standard PACS system, almost all of which I have already mentioned.  Since any interaction of workstations with the PACS system is client-server, all operations are also implemented in two versions - client and server.  In DCMTK there are implementations of both options.  PACS implements the server side. <br>  The prefix 'C-' for operations means Composite, which implies that the operation is holistic and self-sufficient and is performed without being tied to other operations.  There are also operations with the prefix 'N -' (N-CREATE, N-SET, N-GET, etc.), which are performed as part of some more general operation (set statuses, inform about the start of the study, etc.).  These operations are not related to the topic of this article. <br><br>  <b>C-ECHO</b> is a command to find out whether a client is available on the network.  Similar to the ping command in Windows.  In the implementation, the command is very simple - you just need to send a response with the status STATUS_Success: <br><br><pre><code class="cpp hljs">DIMSE_sendEchoResponse(assoc, presID, request, STATUS_Success, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)</code> </pre> <br>  where assoc is the connection established by the client, request is the incoming request. <br><br>  <b>C-STORE</b> is a command that allows you to save images on a PACS server in DCM format. <br>  Here is a piece of code that does this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OFCondition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeSCP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T_DIMSE_C_StoreRQ* req = &amp;m_msg-&gt;msg.CStoreRQ; DcmDataset* dset = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; OFCondition cond = DIMSE_storeProvider(m_assoc, m_presID, req, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, OFTrue, &amp;dset,storeSCPCallback, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, DIMSE_BLOCKING, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond.bad()) Log::error(<span class="hljs-string"><span class="hljs-string">"C-STORE provider failed. Text: %s"</span></span>, cond.text()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cond; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeSCPCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*callbackData*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">, T_DIMSE_StoreProgress *progress, T_DIMSE_C_StoreRQ* </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*request*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*imageFileName*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">, DcmDataset **imageDataSet, T_DIMSE_C_StoreRSP* response, DcmDataset **statusDetail)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (progress-&gt;state == DIMSE_StoreEnd) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((imageDataSet != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; (*imageDataSet != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { <span class="hljs-function"><span class="hljs-function">DcmFileFormat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dcmff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*imageDataSet)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// some error if (!commandStore(&amp;dcmff)) response-&gt;DimseStatus = STATUS_STORE_Refused_OutOfResources; delete *imageDataSet; *imageDataSet = 0x0; } } delete *statusDetail; *statusDetail = 0x0; } bool ServerCoreImpl::commandStore(DcmFileFormat* file) { //  // 1.  ,  ()   PATIENT, STUDY, SERIES, OBJECT. // 2.      ,      // 3.    ,        ( //  ) //   true,    ,  false }</span></span></code> </pre><br>  Kolleback storeSCPCallback works on each package, not on each file.  The completion of the file download is indicated by the condition <code>progress-&gt;state == DIMSE_StoreEnd</code> , then we can save the file.  The only difficulty with the implementation of this command is the choice of the directory structure when saving the file.  In order not to store the path to the file in the OBJECTS table, we calculate it from the rest of the data.  We settled on the following directory structure: PATH_K_DOOR / STUDY.DATE (YEAR) /STUDY.DATE (MONTH) /STUDY.DATE (DAY) /STUDY.TIME (HOUR) /PATIENT.PID (first letter) / PATIENT.PID/STUDY .UID / {images}.  This hierarchical structure allows you to minimize the number of nested folders, which allows you to work with this directory structure without time lags. <br><br>  I would also like to say that the OBJECT table is filled very intensively.  One study on an MRI tomograph lasts an average of 20 minutes, during which time the tomograph produces 100-300 images, a CT scanner 500-700 images.  Total images per day can reach 1440/20 * 500 = 36000 images per day.  In our diagnostic center, there are practically no breaks in the work of tomographs day or night.  Therefore, the OBJECT table should store the minimum possible amount of data. <br><br>  <b>C-MOVE</b> is a command that allows you to transfer images from a PACS to a work station or a diagnostic station.  The command is transmitted by the calling station (source) to the PACS and it indicates which station (destination) the images should be uploaded to.  In the particular case, if source = destination, then just download files. <br><br>  The C-MOVE team is more versatile than the C-GET team, which only allows downloading images.  C-MOVE can download images not only for its own, but also for any other.  The command indicates the AETitle station to which you want to upload images.  AETitle is the name of the client, usually in capital letters (for example, CLIENT_SCU).  It is installed when you start dicom-listener (server). <br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/987/198/0e4/9871980e47c0b42776b3dbe639c3cc87.jpg"></div><br>  That is, the client initiating the C-MOVE command to the PACS server must run a mini-PACS in itself that allows only the C-STORE command to be received.  And the PACS server, in turn, with the C-MOVE team, should establish a new connection with the client, pick up images from the storage and, for each of the bottom, execute the client version of the C-STORE command back to the client.  By the way, only the C-MOVE command allows you to transfer both compressed images (JPEG) and uncompressed due to the establishment of a new connection. <br>  The C-GET team, however, is able to load images without establishing a new connection and, therefore, without having to raise the server on the client side.  In this case, the PACS also performs the client version of the C-STORE command, only through the connection established by the C-GET command. <br><br>  <b>C-FIND</b> is a command that allows you to search for images at different levels.  That is, in fact, there are four types of C-FIND command: C-FIND at the PATIENT level, at the STUDY level, at the SERIES level and at the IMAGE level. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HandlerFind::findSCPCallback ( <span class="hljs-comment"><span class="hljs-comment">/* in */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* callbackData, OFBool cancelled, T_DIMSE_C_FindRQ* request, DcmDataset* requestIdentifiers, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> responseCount, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> T_DIMSE_C_FindRSP *response, DcmDataset** responseDataSet, DcmDataset** statusDetail) { <span class="hljs-comment"><span class="hljs-comment">//   if (cancelled) { strcpy(response-&gt;AffectedSOPClassUID, request-&gt;AffectedSOPClassUID); response-&gt;MessageIDBeingRespondedTo = request-&gt;MessageID; response-&gt;DimseStatus = STATUS_FIND_Cancel_MatchingTerminatedDueToCancelRequest; response-&gt;DataSetType = DIMSE_DATASET_NULL; return; } if (responseCount == 1) { // //       . //          requestIdentifiers // } /*         responseDataSet     */ if (/*  */) { strcpy(response-&gt;AffectedSOPClassUID, request-&gt;AffectedSOPClassUID); response-&gt;MessageIDBeingRespondedTo = request-&gt;MessageID; response-&gt;DimseStatus = STATUS_Success; response-&gt;DataSetType = DIMSE_DATASET_NULL; return; } } OFCondition HandlerFind::find() { OFCondition cond = EC_Normal; T_DIMSE_C_FindRQ *req = &amp;m_msg-&gt;msg.CFindRQ; FindCallbackData cdata; cond = DIMSE_findProvider(m_assoc, m_presID, req, findSCPCallback, &amp;cdata, DIMSE_BLOCKING, 0); if (cond.bad()) Log::loggerDicom.error("C-FIND provider failed. Text: %s", cond.text()); return cond; }</span></span></code> </pre><br>  That is, in the callback, you need to fill in the response objects ‚Äî the response parameters and responseDataSet ‚Äî the patient information / stage / series / image you want to find.  The DIMSE_findProvider () function from DCMTK will take care of sending them back to the client. <br><br>  The C-FIND command is dangerous in that the client can specify a very general search criteria and the client will have to give a large amount of information.  For example, you can request all stages for the last year.  If you try to first load all the data on the server, the server is likely to hang.  Therefore, it is impossible to make large requests, you need to load data as the callbacks are triggered.  To do this, you need to implement a query to the database as an iterator and, as the callbacks are triggered, call next () and thus take the next object.  In addition, the search can be canceled only when a callback arrives, so if the search on PACS hangs for a while on a sample of the database, and the client causes the request to be canceled, then no response will occur on the client.  This is relevant for searching at the level of patients and stages.  This is irrelevant for searching at the series level, since we have not encountered any stages containing more than 15 series.  Similarly, for searching at the level of images - a series with more than 1000 images, we have not seen in practice. <br><br><h5>  Summarize </h5><br>  So, we reviewed the main functions of the PACS system and its role in the overall structure of the diagnostic center.  Practical aspects and various aspects of the implementation of medical industrial PACS systems are also covered.  However, as a rule, PACS systems are not limited to this functionality.  There is also a WADO (Web Access to DICOM Objects) service and a work task management service (Modality worklist), also included in the functions of PACS systems.  I hope for someone the article will be useful and save a lot of time. <br><br><h5>  Links </h5><br>  1. List of all DICOM tags (http://medical.nema.org/Dicom/2011/11_06pu.pdf, p. 8). <br>  2. The official page of the DICOM protocol - <a href="http://medical.nema.org/standard.html">medical.nema.org/standard.html</a> <br>  3. About PACS systems in Russian - <a href="http://ru.wikipedia.org/wiki/PACS">ru.wikipedia.org/wiki/PACS</a> <br>  4. About DICOM in Russian - <a href="http://ru.wikipedia.org/wiki/DICOM">en.wikipedia.org/wiki/DICOM</a> </div><p>Source: <a href="https://habr.com/ru/post/193134/">https://habr.com/ru/post/193134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193124/index.html">Kinect 3.0</a></li>
<li><a href="../193126/index.html">The future of our civilization: death or immortality?</a></li>
<li><a href="../193128/index.html">Downloading from mSATA on the ACER Aspire V7-482PG Ultrabook</a></li>
<li><a href="../193130/index.html">"Living" artificial intelligence, man and problems AI</a></li>
<li><a href="../193132/index.html">Visualization of patterns of used passwords</a></li>
<li><a href="../193136/index.html">Guide to designing relational databases (1-3 part of 15) [translation]</a></li>
<li><a href="../193138/index.html">Testing: 20 beginner principles</a></li>
<li><a href="../193140/index.html">Work with the scheduler in Java (Spring)</a></li>
<li><a href="../193142/index.html">Color temperature</a></li>
<li><a href="../193146/index.html">Welding of optical fibers. Part 1: cables and their cutting, optical tools, couplings and crosses, connectors and adapters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>