<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SOLID principles every developer should be aware of</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Object-oriented programming has brought new approaches to application design to software development. In particular, OOP allowed programmers to combin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SOLID principles every developer should be aware of</h1><div class="post__text post__text-html js-mediator-article">  Object-oriented programming has brought new approaches to application design to software development.  In particular, OOP allowed programmers to combine entities, united by some common goal or functionality, in separate classes designed for solving independent tasks and independent of other parts of the application.  However, the use of OOP does not mean that the developer is insured against the possibility of creating an incomprehensible, confusing code that is hard to maintain.  Robert Martin, in order to help anyone develop high-quality OOP applications, developed five principles of object-oriented programming and design, referring to which, with the suggestion of Michael Phasers, use the acronym SOLID. <br><br> <a href="https://habr.com/company/ruvds/blog/426413/"><img src="https://habrastorage.org/webt/46/xx/ol/46xxolpv46av7bknmyywp3ii9vs.jpeg"></a> <br><br>  The material, the translation of which we are publishing today, is devoted to the basics of SOLID and is intended for novice developers. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is SOLID?</font> </h2><br>  This is how the SOLID acronym stands for: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  S: Single Responsibility Principle. </li><li>  O: Open-Closed Principle (Open-Closed Principle). </li><li>  L: Liskov Substitution Principle (Barbara Liskov substitution principle). </li><li>  I: Interface Segregation Principle. </li><li>  D: Dependency Inversion Principle. </li></ul><br>  We will now look at these principles with schematic examples.  Note that the main purpose of the examples is to help the reader understand the principles of SOLID, learn how to apply them and how to follow them when designing applications.  The author of the material did not strive to get to the working code that could be used in real projects. <br><br><h2>  <font color="#3AC1EF">Principle of sole responsibility</font> </h2><br>  <i><font color="#999999">‚ÄúOne errand.</font></i>  <i><font color="#999999">Only one thing. ‚Äù- Loki tells Surcu in the film‚Äú Thor: Ragnarok ‚Äù</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Each class must solve only one problem.</font></i> <br><br>  The class should be responsible only for one thing.  If a class is responsible for solving several problems, its subsystems that implement the solution of these problems are connected with each other.  Changes in one such subsystem lead to changes in another. <br><br>  Please note that this principle applies not only to classes, but also to software components in a broader sense. <br><br>  For example, consider this code: <br><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {    constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }    getAnimalName() { }    saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  The <code>Animal</code> class presented here describes some kind of animal.  This class violates the principle of sole responsibility.  How exactly is this principle violated? <br><br>  In accordance with the principle of sole responsibility, a class must solve only one particular task.  It also solves two, working with the data store in the <code>saveAnimal</code> method and manipulating the properties of the object in the constructor and in the <code>getAnimalName</code> method. <br><br>  How can such a class structure lead to problems? <br><br>  If the order of work with the data storage used by the application changes, then it is necessary to make changes to all classes working with the storage.  Such an architecture is not very flexible; changes in some subsystems affect others, which resembles a domino effect. <br><br>  In order to bring the above code into line with the principle of sole responsibility, we will create another class whose only task is to work with the repository, in particular, to save the objects of the <code>Animal</code> class in it: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }   getAnimalName() { } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalDB</span></span></span><span class="hljs-class"> {   getAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { }   saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  This is what Steve Fenton says about this: ‚ÄúWhen designing classes, we must strive to integrate related components, that is, those in which changes occur for the same reasons.  We should try to separate the components, the changes in which are caused by different reasons. " <br><br>  The correct application of the principle of sole responsibility leads to a high degree of coherence of elements within the module, that is, to the fact that the tasks solved inside it correspond well to its main goal. <br><br><h2>  <font color="#3AC1EF">Principle of openness-closeness</font> </h2><br>  <i><font color="#999999">Software entities (classes, modules, functions) should be open for expansion, but not for modification.</font></i> <br><br>  We continue the work on the class <code>Animal</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name: string){ }   getAnimalName() { } }</code> </pre> <br>  We want to sort through the list of animals, each of which is represented by an object of the class <code>Animal</code> , and find out what sounds they make.  Imagine that we are solving this problem using the <code>AnimalSounds</code> function: <br><br><pre> <code class="hljs lua">//... const animals: Array&lt;Animal&gt; = [   new Animal(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   new Animal(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>) ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[i].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[i].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  The main problem of such an architecture is that the function determines what kind of sound a particular animal emits by analyzing specific objects.  The <code>AnimalSound</code> function <code>AnimalSound</code> not comply with the principle of openness-closeness, since, for example, when new types of animals appear, we will have to change it in order to recognize the sounds made by them. <br><br>  Add a new element to the array: <br><br><pre> <code class="hljs vhdl">//... const animals: <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;Animal&gt; = [   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(<span class="hljs-symbol"><span class="hljs-symbol">'lion</span></span>'),   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(<span class="hljs-symbol"><span class="hljs-symbol">'mouse</span></span>'),   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(<span class="hljs-symbol"><span class="hljs-symbol">'snake</span></span>') ] //...</code> </pre> <br>  After that we will have to change the code of the <code>AnimalSound</code> function: <br><br><pre> <code class="hljs lua">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[i].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[i].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[i].name == <span class="hljs-string"><span class="hljs-string">'snake'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  As you can see, when adding a new animal to the array, you will have to supplement the function code.  The example is very simple, but if such an architecture is used in a real project, the function will have to be constantly expanded, adding new <code>if</code> expressions to it. <br><br>  How to bring the <code>AnimalSound</code> function in accordance with the principle of openness-closeness?  For example - so: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {       makeSound();       //... } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Lion</span></span></span><span class="hljs-class"> extends </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   makeSound() {       return 'roar';   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Squirrel</span></span></span><span class="hljs-class"> extends </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   makeSound() {       return 'squeak';   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Snake</span></span></span><span class="hljs-class"> extends </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   makeSound() {       return 'hiss';   } } //... function </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalSound</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Array</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">&gt;) {   for(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> = 0; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> &lt;= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">++) {       a[i].makeSound();   } } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalSound</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">animals</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  You may notice that the <code>Animal</code> class now has a virtual method, <code>makeSound</code> .  With this approach, it is necessary that classes designed to describe specific animals expand the <code>Animal</code> class and implement this method. <br><br>  As a result, each class describing an animal will have its own <code>makeSound</code> method, and when <code>makeSound</code> through an array with animals in the <code>AnimalSound</code> function, <code>AnimalSound</code> will be enough to call this method for each element of the array. <br><br>  If we now add to the array an object that describes a new animal, <code>AnimalSound</code> will not have to change.  We have aligned it with the principle of openness-closeness. <br><br>  Consider another example. <br><br>  Imagine that we have a store.  We give customers a 20% discount using this class: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>   } }</code> </pre> <br>  Now it is decided to divide clients into two groups.  Favorite ( <code>fav</code> ) customers receive a 20% discount, and VIP customers ( <code>vip</code> ) receive a double discount, that is, 40%.  In order to implement this logic, it was decided to modify the class as follows: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'fav'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'vip'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.4</span></span>;       }   } }</code> </pre> <br>  Such an approach violates the principle of openness-closeness.  As you can see, here, if we need to give a certain group of clients a special discount, we have to add a new code to the class. <br><br>  In order to rework this code in accordance with the principle of openness-closeness, we will add a new class to the project, extending the <code>Discount</code> class.  In this new class, we are implementing a new mechanism: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Discount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  If you decide to give a discount of 80% "super-VIP" customers, it should look like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperVIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIPDiscount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  As you can see, the use of classes is used here, not their modification. <br><br><h2>  <font color="#3AC1EF">Barbara Liskov substitution principle</font> </h2><br>  <i><font color="#999999">Subclasses need to serve as a replacement for their superclasses.</font></i> <br><br>  The purpose of this principle is that the successor classes could be used instead of the parent classes from which they are derived, without disrupting the work of the program.  If it turns out that the class type is checked in the code, then the substitution principle is violated. <br><br>  Consider the application of this principle, returning to the example with the class <code>Animal</code> .  Write a function designed to return information about the quantities of limbs of an animal. <br><br><pre> <code class="hljs lua">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[i]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[i]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[i]);   } } AnimalLegCount(animals);</code> </pre> <br>  The function violates the principle of substitution (and the principle of openness-closeness).  This code should be aware of the types of all objects it processes and, depending on the type, refer to the corresponding function for counting the limbs of a particular animal.  As a result, when creating a new type of animal, the function will have to be rewritten: <br><br><pre> <code class="hljs lua">//... class Pigeon extends Animal {      } const animals[]: Array&lt;Animal&gt; = [   //...,   new Pigeon(); ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[i]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[i]);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[i]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[i] == Pigeon)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PigeonLegCount(a[i]);   } } AnimalLegCount(animals);</code> </pre> <br>  To ensure that this function does not violate the substitution principle, we will transform it using the requirements formulated by Steve Fenton.  They consist in the fact that methods that accept or return values ‚Äã‚Äãwith the type of a certain superclass ( <code>Animal</code> in our case) must also accept and return values ‚Äã‚Äãwhose types are its subclasses ( <code>Pigeon</code> ). <br><br>  Armed with these considerations, we can remake the <code>AnimalLegCount</code> function: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt;= a.length; i++)</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animals)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Now this function is not interested in the types of objects passed to it.  She just calls their <code>LegCount</code> methods.  All she knows about types is that the objects she processes should belong to the <code>Animal</code> class or its subclasses. <br><br>  Now the <code>LegCount</code> method should appear in the <code>Animal</code> class: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//...   LegCount(); }</span></span></code> </pre> <br>  And its subclasses need to implement this method: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class">{   //...   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LegCount</span></span></span><span class="hljs-class">() {       //...   } } //...</span></span></code> </pre> <br>  As a result, for example, when accessing the <code>LegCount</code> method for an instance of the <code>Lion</code> class, the method implemented in this class is called, and exactly what can be expected from calling this method is returned. <br><br>  Now, the <code>AnimalLegCount</code> function <code>AnimalLegCount</code> not need to know about the object of which subclass of the <code>Animal</code> class it processes in order to get information about the number of limbs in an animal represented by this object.  The function simply calls the <code>LegCount</code> method of the <code>Animal</code> class, since subclasses of this class must implement this method so that they can be used instead, without disrupting the correctness of the program. <br><br><h2>  <font color="#3AC1EF">Interface separation principle</font> </h2><br>  <i><font color="#999999">Create highly specialized customer-specific interfaces.</font></i>  <i><font color="#999999">Clients should not be dependent on interfaces that they do not use.</font></i> <br><br>  This principle aims to eliminate the disadvantages associated with the implementation of large interfaces. <br><br>  Consider the interface <code>Shape</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle(); }</code> </pre> <br>  It describes methods for drawing circles ( <code>drawCircle</code> ), squares ( <code>drawSquare</code> ) and rectangles ( <code>drawRectangle</code> ).  As a result, classes that implement this interface and represent separate geometric shapes, such as a circle (Circle), a square (Square), and a rectangle (Rectangle), must contain an implementation of all these methods.  It looks like this: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rectangle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } }</span></span></code> </pre> <br>  We got a strange code.  For example, the <code>Rectangle</code> class, representing a rectangle, implements methods ( <code>drawCircle</code> and <code>drawSquare</code> ), which it does not need at all.  The same can be noticed when analyzing the code of the two other classes. <br><br>  Suppose we decide to add another method to the <code>Shape</code> interface, <code>drawTriangle</code> , for drawing triangles: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle();   drawTriangle(); }</code> </pre> <br>  This will lead to the fact that classes representing concrete geometric shapes will also have to implement the <code>drawTriangle</code> method.  Otherwise, an error will occur. <br><br>  As you can see, with this approach it is impossible to create a class that implements a method for drawing a circle, but does not implement methods for displaying a square, a rectangle and a triangle.  Such methods can be implemented so that when they are output, an error would be thrown, indicating that such an operation cannot be performed. <br><br>  The interface separation principle warns us against creating interfaces like the <code>Shape</code> from our example.  Clients (we have the classes <code>Circle</code> , <code>Square</code> and <code>Rectangle</code> ) should not implement methods that they do not need to use.  In addition, this principle indicates that the interface should solve only one task (in this it is similar to the principle of sole responsibility), therefore everything that goes beyond the scope of this task should be transferred to another interface or interfaces. <br><br>  In our case, the <code>Shape</code> interface solves the problems for the solution of which it is necessary to create separate interfaces.  Following this idea, we will rework the code, creating separate interfaces for solving various highly specialized tasks: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{   draw(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISquare</span></span></span><span class="hljs-class"> </span></span>{   drawSquare(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IRectangle</span></span></span><span class="hljs-class"> </span></span>{   drawRectangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITriangle</span></span></span><span class="hljs-class"> </span></span>{   drawTriangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle() {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class Square implements ISquare {   drawSquare() {       //...   } } class Rectangle implements IRectangle {   drawRectangle() {       //...   } } class Triangle implements ITriangle {   drawTriangle() {       //...   } } class CustomShape implements Shape {  draw(){     //...  } }</span></span></code> </pre> <br>  Now the <code>ICircle</code> interface <code>ICircle</code> used only for drawing circles, as well as other specialized interfaces for drawing other shapes.  The <code>Shape</code> interface can be used as a universal interface. <br><br><h2>  <font color="#3AC1EF">Dependency Inversion Principle</font> </h2><br>  <i><font color="#999999">The object of the dependency should be an abstraction, not something concrete.</font></i> <br><br><ol><li>  The modules of the upper levels should not depend on the modules of the lower levels.  Both types of modules must depend on abstractions. </li><li>  Abstractions should not depend on the details.  Details must depend on abstractions. </li></ol><br>  In the process of software development, there is a moment when the functionality of the application ceases to fit within a single module.  When this happens, we have to solve the problem of module dependencies.  As a result, for example, it may turn out that high-level components depend on low-level components. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpRequestService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> xmlhttpService: <span class="hljs-type"><span class="hljs-type">XMLHttpService</span></span>) { }   get(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'GE</span></span>T');   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'POS</span></span>T');   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Here, the <code>Http</code> class is a high-level component, and <code>XMLHttpService</code> is a low-level component.  This architecture violates clause A of the principle of dependency inversion: ‚ÄúThe modules of the upper levels should not depend on the modules of the lower levels.  Both types of modules should depend on abstractions. ‚Äù <br><br>  The <code>Http</code> class is dependent on the <code>XMLHttpService</code> class.  If we decide to change the mechanism used by the <code>Http</code> class to interact with the network - say, it will be a Node.js service or, for example, a service stub used for testing purposes, we will have to edit all instances of the <code>Http</code> class by changing the corresponding code.  This violates the principle of openness-closeness. <br><br>  The <code>Http</code> class does not need to know exactly what is used for networking.  Therefore, we will create the <code>Connection</code> interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Connection</span></span> {   request(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, opts:any); }</code> </pre> <br>  The <code>Connection</code> interface contains the description of the <code>request</code> method and we pass an argument of type <code>Connection</code> <code>Http</code> class: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> httpConnection: Connection) { }   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'GET'</span></span>);   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'POST'</span></span>);   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Now, regardless of what exactly is used to organize interaction with the network, the <code>Http</code> class can use what it has been passed on without worrying about what is hidden behind the <code>Connection</code> interface. <br><br>  <code>XMLHttpService</code> class <code>XMLHttpService</code> such a way that it implements this interface: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   <span class="hljs-comment"><span class="hljs-comment">//...   request(url: string, opts:any) {       xhr.open();       xhr.send();   } }</span></span></code> </pre> <br>  As a result, we can create many classes that implement the <code>Connection</code> interface and are suitable for use in the <code>Http</code> class for organizing data exchange over the network: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   request(url: string, opts:any) {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class MockHttpService implements Connection {   request(url: string, opts:any) {       //...   } }</span></span></code> </pre> <br>  As you can see, here high-level and low-level modules depend on abstractions.  The class <code>Http</code> (high-level module) depends on the interface <code>Connection</code> (abstraction).  The <code>XMLHttpService</code> , <code>NodeHttpService</code> and <code>MockHttpService</code> (low-level modules) also depend on the <code>Connection</code> interface. <br><br>  In addition, it is worth noting that, following the principle of inversion of dependencies, we follow the principle of Barbara Liskov's substitution.  Namely, it turns out that the <code>XMLHttpService</code> , <code>NodeHttpService</code> and <code>MockHttpService</code> can serve as a replacement for the base <code>Connection</code> type. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Here we looked at five SOLID principles that every OOP developer should adhere to.  At first, this may not be easy, but if you strive towards this, reinforcing desires with practice, these principles become a natural part of the workflow, which has a huge positive impact on the quality of applications and greatly facilitates their support. <br><br>  <b>Dear readers!</b>  Do you use SOLID principles in your projects? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/426413/">https://habr.com/ru/post/426413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426403/index.html">My job begins if the report on the failure of the communication center "flew" to me ...</a></li>
<li><a href="../426405/index.html">Hackers in the framework of the laws of the Russian Federation</a></li>
<li><a href="../426407/index.html">How to make a trip to the conference as useless as possible</a></li>
<li><a href="../426409/index.html">Hacker Alexey, who protects MikroTik routers without the permission of the owners, became famous</a></li>
<li><a href="../426411/index.html">Developing C ++ / CLI Descriptor Classes</a></li>
<li><a href="../426415/index.html">Fintech-digest: control by digitalization by the Central Bank, salary in cryptocurrency, ‚ÄúWorld‚Äù map in the form of bracelets and keyrings</a></li>
<li><a href="../426417/index.html">Pavel 2.0: Reptiloid consultant on JS, node.js with sockets and telephony</a></li>
<li><a href="../426419/index.html">Overloading that is prohibited or bridge methods in Java</a></li>
<li><a href="../426421/index.html">EHCI in Russian</a></li>
<li><a href="../426423/index.html">mmWave in smartphones: how Qualcomm made the impossible possible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>