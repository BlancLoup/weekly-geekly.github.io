<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test aiohttp with a simple chat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 

- Introduction 
- Structure 
- Routes 
- Handlers, Request and Response 
- Configuration settings 
- Middlewares 
- Database 
- Te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test aiohttp with a simple chat</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <em>Introduction</em> </li><li>  <em>Structure</em> </li><li>  <em>Routes</em> </li><li>  <em>Handlers, Request and Response</em> </li><li>  <em>Configuration settings</em> </li><li>  <em>Middlewares</em> </li><li>  <em>Database</em> </li><li>  <em>Templates</em> </li><li>  <em>Sessions, authorization</em> </li><li>  <em>Static</em> </li><li>  <em>Websocket</em> </li><li>  <em>Upload to Heroku</em> </li></ul></div></div><br><hr><br><p>  <strong>Introduction</strong> </p><br><p>  Last fall, I was able to visit several python meetups in Kiev. <br>  At one of them, <a href="https://github.com/jettify">Nikolay Novik</a> spoke and talked about the new asynchronous framework <a href="http.readthedocs.org/en/stable/">aiohttp</a> , which runs on the library for asynchronous calls <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> in 3 versions of the python interpreter.  I was interested in this framework by the fact that it was created by core python developers and positioned as a python concept framework for the web. </p><br><p>  Now there is a huge number of different frameworks, each of which has its own philosophy, <br>  syntax and implementation of common web templates.  Hope over time, all this variety <br>  will be on the same basis - aiohttp. </p><a name="habracut"></a><br><p>  <strong>Structure</strong> </p><br><p>  In order to test the full potential of aiohttp to the maximum, I tried to develop a simple chat on web sockets.  The basis of aiohttp is an endless loop in which handlers are spinning.  Handler - the so-called coroutine, an object that does not block input / output (I / O).  This type of object appeared in python 3.4 in the asyncio library.  Until all the calculations in this object take place, he as if falls asleep, and at this time the interpreter can process other objects.  To make it clear, give an example.  Often, all server delays occur when it waits for a response from the database and until this response comes and is processed, other objects are waiting for their turn.  In this case, other objects will be processed until the answer comes from the database.  But to implement this, you need an asynchronous driver. <br>  Currently, <a href="https://github.com/aio-libs/">asynchronous drivers and wrappers are</a> implemented for aiohttp for most popular databases ( <a href="https://github.com/aio-libs/aiopg">postgresql</a> , <a href="https://github.com/aio-libs/aiomysql">mysql</a> , <a href="https://github.com/aio-libs/aioredis">redis</a> ) <br>  For mongodb there is <a href="http://motor.readthedocs.org/en/stable/">Motor</a> , which is used in chat. </p><br><p>  The chat entry point is <a href="http/blob/master/app.py"><strong>app.py.</strong></a>  It creates an app object. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> web loop = asyncio.get_event_loop() app = web.Application(loop=loop, middlewares=[ session_middleware(EncryptedCookieStorage(SECRET_KEY)), authorize, db_handler, ])</code> </pre> <br><p>  As you can see, upon initialization, the loop is passed to the app, as well as a list of middleware, which will be discussed later. </p><br><p>  <strong>Routes</strong> </p><br><p>  Unlike the flask that aiohttp is very similar to, routes are added to an already initialized app app. </p><br><pre> <code class="python hljs">app.router.add_route(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/{name}'</span></span>, handler)</code> </pre> <br><p>  By the way, the <a href="http://asvetlov.blogspot.com/2014/10/flask_20.html">explanation of</a> <a href="https://github.com/asvetlov">Andrei Svetlov</a> , why it is so implemented. </p><br><p>  Filling routes rendered in a separate file <a href="http/blob/master/routes.py">routes.py</a> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chat.views <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ChatList, WebSocket <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> auth.views <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Login, SignIn, SignOut routes = [ (<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, ChatList, <span class="hljs-string"><span class="hljs-string">'main'</span></span>), (<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, WebSocket, <span class="hljs-string"><span class="hljs-string">'chat'</span></span>), (<span class="hljs-string"><span class="hljs-string">'*'</span></span>, <span class="hljs-string"><span class="hljs-string">'/login'</span></span>, Login, <span class="hljs-string"><span class="hljs-string">'login'</span></span>), (<span class="hljs-string"><span class="hljs-string">'*'</span></span>, <span class="hljs-string"><span class="hljs-string">'/signin'</span></span>, SignIn, <span class="hljs-string"><span class="hljs-string">'signin'</span></span>), (<span class="hljs-string"><span class="hljs-string">'*'</span></span>, <span class="hljs-string"><span class="hljs-string">'/signout'</span></span>, SignOut, <span class="hljs-string"><span class="hljs-string">'signout'</span></span>), ]</code> </pre> <br><p>  The first element is the http method, then the url is located, the third in the tuple is the handler object, and finally the route name, so that it is convenient to call it in the code. </p><br><p>  Next, the routes list is imported into app.py and they are populated with a simple loop into the application. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> routes: app.router.add_route(route[<span class="hljs-number"><span class="hljs-number">0</span></span>], route[<span class="hljs-number"><span class="hljs-number">1</span></span>], route[<span class="hljs-number"><span class="hljs-number">2</span></span>], name=route[<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre> <br><p>  Everything is simple and logical </p><br><p>  <strong>Handlers, Request and Response</strong> </p><br><p>  I decided to do requests processing following the example of the Django framework.  The <a href="http/tree/master/auth">auth</a> folder contains everything related to users, authorization, the processing of creating a user and his login.  And in the <a href="http/tree/master/chat">chat</a> folder is the logic of the chat, respectively.  In aiohttp, you can implement a <a href="http.readthedocs.org/en/stable/web.html">handler</a> as both a function and a class. <br>  We select implementation through a class. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Login</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.View)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> session = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> get_session(self.request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> session.get(<span class="hljs-string"><span class="hljs-string">'user'</span></span>): url = request.app.router[<span class="hljs-string"><span class="hljs-string">'main'</span></span>].url() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> web.HTTPFound(url) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">b'Please enter login or email'</span></span></code> </pre> <br><p>  About the session will be written below, and everything else I think is clear and true.  I want to note that redirection occurs either by returning (return) or by throwing an exception in the form of the web.HTTPFound () object, to which the path is passed as a parameter.  Http methods in a class are implemented through asynchronous functions get, post, and so on.  There are some features if you need to work with query parameters. </p><br><pre> <code class="python hljs">data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.request.post()</code> </pre> <br><p>  <strong>Configuration settings</strong> </p><br><p>  All settings are stored in the <a href="http/blob/master/settings.py">settings.py</a> file.  I use <a href="https://github.com/rconradharris/envparse">envparse</a> to store sensitive data.  This utility allows you to read data from environment variables, as well as to parse a special file where these variables are stored. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(<span class="hljs-string"><span class="hljs-string">'.env'</span></span>): env.read_envfile(<span class="hljs-string"><span class="hljs-string">'.env'</span></span>)</code> </pre> <br><p>  Firstly, it was necessary to raise the project on Heroku, and secondly, it turned out to be also very convenient.  At first I used a local database, and then I tested it on a remote one, and the switch consisted of changing just one line in the .env file. </p><br><p>  <strong>Middlewares</strong> </p><br><p>  When you initialize the application, you can set the middleware.  Here they are in a separate <a href="http/blob/master/middlewares.py">file</a> .  The standard implementation is a decorator function in which you can do checks or any other actions with the request. </p><br><p>  <em>An example of an authorization check</em> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">middleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'/login'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/signin'</span></span>, <span class="hljs-string"><span class="hljs-string">'/signout'</span></span>, <span class="hljs-string"><span class="hljs-string">'/_debugtoolbar/'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.startswith(r): result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result session = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> get_session(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> session.get(<span class="hljs-string"><span class="hljs-string">"user"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> check_path(request.path): url = request.app.router[<span class="hljs-string"><span class="hljs-string">'login'</span></span>].url() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> web.HTTPFound(url) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> middleware</code> </pre> <br><p>  There is also a middleware for connecting the database. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">db_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">middleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/static/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> request.path.startswith(<span class="hljs-string"><span class="hljs-string">'/_debugtoolbar'</span></span>): response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response request.db = app.db response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> middleware</code> </pre> <br><p>  Connection details below. </p><br><p>  <strong>Database</strong> </p><br><p>  For chat use Mongodb and asynchronous driver Motor.  Connection to the database occurs when the application is initialized. </p><br><pre> <code class="python hljs">app.client = ma.AsyncIOMotorClient(MONGO_HOST) app.db = app.client[MONGO_DB_NAME]</code> </pre> <br><p>  And the connection is closed in the special function shutdown. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server, app, handler)</span></span></span><span class="hljs-function">:</span></span> server.close() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> server.wait_closed() app.client.close() <span class="hljs-comment"><span class="hljs-comment"># database connection close await app.shutdown() await handler.finish_connections(10.0) await app.cleanup()</span></span></code> </pre> <br><p>  I want to note that in the case of an asynchronous server, you need to correctly complete all parallel tasks. </p><br><p>  A little more about the creation of event loop. </p><br><pre> <code class="python hljs">loop = asyncio.get_event_loop() serv_generator, handler, app = loop.run_until_complete(init(loop)) serv = loop.run_until_complete(serv_generator) log.debug(<span class="hljs-string"><span class="hljs-string">'start server'</span></span>, serv.sockets[<span class="hljs-number"><span class="hljs-number">0</span></span>].getsockname()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: loop.run_forever() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: log.debug(<span class="hljs-string"><span class="hljs-string">' Stop server begin'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: loop.run_until_complete(shutdown(serv, app, handler)) loop.close() log.debug(<span class="hljs-string"><span class="hljs-string">'Stop server end'</span></span>)</code> </pre> <br><p>  The loop itself is created from asyncio. </p><br><pre> <code class="python hljs">serv_generator, handler, app = loop.run_until_complete(init(loop))</code> </pre> <br><p>  The run_until_complete method adds corutines to the loop.  In this case, it adds the function to <a href="http/blob/master/app.py">initialize the</a> application. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: loop.run_forever() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: log.debug(<span class="hljs-string"><span class="hljs-string">' Stop server begin'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: loop.run_until_complete(shutdown(serv, app, handler)) loop.close()</code> </pre> <br><p>  Actually the implementation of an infinite loop, which is interrupted in case of an exception.  Before closing, the shutdown function is called, which terminates all connections and correctly stops the server. </p><br><p>  Now we need to figure out how to query, retrieve and modify data. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, db, **kwargs)</span></span></span><span class="hljs-function">:</span></span> self.collection = db[MESSAGE_COLLECTION] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, msg, **kw)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.collection.insert({<span class="hljs-string"><span class="hljs-string">'user'</span></span>: user, <span class="hljs-string"><span class="hljs-string">'msg'</span></span>: msg, <span class="hljs-string"><span class="hljs-string">'time'</span></span>: datetime.now()}) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> messages = self.collection.find().sort([(<span class="hljs-string"><span class="hljs-string">'time'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> messages.to_list(length=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Although I‚Äôm not involved in ORM, it‚Äôs more convenient to do database queries in separate classes.  The <a href="http/blob/master/chat/models.py">files.py</a> file was created in the chat folder, where the Message class is located.  In the get_messages method, a query is created that retrieves all the stored messages, sorted by time.  The save method creates a request to save a message to the database. </p><br><p>  <strong>Templates</strong> </p><br><p>  For aiohttp several asynchronous wrappers are written for popular templating engines, in particular <a href="http_jinja2">aiohttp_jinja2</a> and <a href="http_mako">aiohttp_mako</a> .  For chat I use jinja2. </p><br><pre> <code class="python hljs">aiohttp_jinja2.setup(app, loader=jinja2.FileSystemLoader(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>))</code> </pre> <br><p>  This is how template support is initialized in the application. <br>  FileSystemLoader ('templates') tells jinja2 that our templates are in the <a href="http/tree/master/templates">templates</a> folder. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatList</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.View)</span></span></span><span class="hljs-class">:</span></span> @aiohttp_jinja2.template(<span class="hljs-string"><span class="hljs-string">'chat/index.html'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> message = Message(self.request.db) messages = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> message.get_messages() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'messages'</span></span>: messages}</code> </pre> <br><p>  Through the decorator, we specify which <a href="http/blob/master/templates/chat/index.html">template</a> we will use in views, and to fill the context, we return a dictionary with variables that we later work with in the template. </p><br><p>  <strong>Sessions, authorization</strong> </p><br><p>  To work with sessions there is <a href="http_session">aiohttp_session</a> library.  It is possible to store sessions in Redis or in cookies in encrypted form using cryptography.  The storage method is specified when the library is installed. </p><br><pre> <code class="python hljs">aiohttp_session[secure]</code> </pre> <br><p>  To initialize the session, add it to the middleware. </p><br><pre> <code class="python hljs">session_middleware(EncryptedCookieStorage(SECRET_KEY)),</code> </pre> <br><p>  To get or put values ‚Äã‚Äãinto a session, you must first extract it from the request. </p><br><pre> <code class="python hljs">session = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> get_session(request)</code> </pre> <br><p>  To authorize a user, add his id to the session, and then check its presence in middleware.  Of course, for security, more checks are needed, but for testing the concept, that will be enough. </p><br><p>  <strong>Static</strong> </p><br><p>  A folder with static content is connected to a separate route when the application is initialized. </p><br><pre> <code class="python hljs">app.router.add_static(<span class="hljs-string"><span class="hljs-string">'/static'</span></span>, <span class="hljs-string"><span class="hljs-string">'static'</span></span>, name=<span class="hljs-string"><span class="hljs-string">'static'</span></span>)</code> </pre> <br><p>  To use it in the template, you need to get it from the app. </p><br><pre> <code class="python hljs">&lt;script src=<span class="hljs-string"><span class="hljs-string">"{{ app.router.static.url(filename='js/main.js') }}"</span></span>&gt;&lt;/script&gt;</code> </pre> <br><p>  It's simple, nothing complicated. </p><br><p>  <strong>Websocket</strong> </p><br><p>  Finally we got to the most delicious part of aiohttp).  The implementation of socket is very simple.  In javascript I added the minimum necessary functionality for its work. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://'</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.host + <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'wss://'</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.host + <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// show message in div#subscribe function showMessage(message) { var messageElem = $('#subscribe'), height = 0, date = new Date(); options = {hour12: false}; messageElem.append($('&lt;p&gt;').html('[' + date.toLocaleTimeString('en-US', options) + '] ' + message + '\n')); messageElem.find('p').each(function(i, value){ height += parseInt($(this).height()); }); messageElem.animate({scrollTop: height}); } function sendMessage(){ var msg = $('#message'); sock.send(msg.val()); msg.val('').focus(); } sock.onopen = function(){ showMessage('Connection to server started') } // send message from form $('#submit').click(function() { sendMessage(); }); $('#message').keyup(function(e){ if(e.keyCode == 13){ sendMessage(); } }); // income message handler sock.onmessage = function(event) { showMessage(event.data); }; $('#signout').click(function(){ window.location.href = "signout" }); sock.onclose = function(event){ if(event.wasClean){ showMessage('Clean connection end') }else{ showMessage('Connection broken') } }; sock.onerror = function(error){ showMessage(error); }</span></span></code> </pre> <br><p>  To implement the server side, I use the class WebSocket </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocket</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.View)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ws = web.WebSocketResponse() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ws.prepare(self.request) session = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> get_session(self.request) user = User(self.request.db, {<span class="hljs-string"><span class="hljs-string">'id'</span></span>: session.get(<span class="hljs-string"><span class="hljs-string">'user'</span></span>)}) login = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.get_login() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ws <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.request.app[<span class="hljs-string"><span class="hljs-string">'websockets'</span></span>]: _ws.send_str(<span class="hljs-string"><span class="hljs-string">'%s joined'</span></span> % login) self.request.app[<span class="hljs-string"><span class="hljs-string">'websockets'</span></span>].append(ws) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ws: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.tp == MsgType.text: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.data == <span class="hljs-string"><span class="hljs-string">'close'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ws.close() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: message = Message(self.request.db) result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> message.save(user=login, msg=msg.data) log.debug(result) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ws <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.request.app[<span class="hljs-string"><span class="hljs-string">'websockets'</span></span>]: _ws.send_str(<span class="hljs-string"><span class="hljs-string">'(%s) %s'</span></span> % (login, msg.data)) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> msg.tp == MsgType.error: log.debug(<span class="hljs-string"><span class="hljs-string">'ws connection closed with exception %s'</span></span> % ws.exception()) self.request.app[<span class="hljs-string"><span class="hljs-string">'websockets'</span></span>].remove(ws) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ws <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.request.app[<span class="hljs-string"><span class="hljs-string">'websockets'</span></span>]: _ws.send_str(<span class="hljs-string"><span class="hljs-string">'%s disconected'</span></span> % login) log.debug(<span class="hljs-string"><span class="hljs-string">'websocket connection closed'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ws</code> </pre> <br><p>  The socket itself is created using the WebSocketResponse () function.  Be sure to use it before cooking.  The list of open sockets is stored in my application (so that when closing the server they can be correctly closed).  When a new user is connected, all participants receive a notification that the new participant has joined the chat.  Next we expect a message from the user.  If it is valid, we save it in a database and send it to other members of the chat. <br>  When the socket is closed, we remove it from the list and notify the chat that one of the participants has left it.  Very simple implementation, visually in synchronous style, without a large number of callbacks, as in Tornado for example.  Take it and use it). </p><br><p>  <strong>Upload to Heroku</strong> </p><br><p>  I posted the test chat on Heroku, for visual demonstration.  During installation, several problems arose, in particular, to use their internal mongodb database, it was necessary to enter credit card information, which I did not want to do, so I used the services of <a href="https://mlab.com/">MongoLab</a> and created a base there.  Then there were problems with installing the application itself.  To install cryptography, you had to explicitly specify it in requirements.txt.  Also, to specify the version of python, you need to create a <a href="http/blob/master/runtime.txt">runtime.txt</a> file in the project root. </p><br><p>  <strong>findings</strong> </p><br><p>  In general, creating a chat, learning aiohttp, analyzing the work of sockets and some other technologies that I haven‚Äôt worked with before, took me about 3 weeks of work in the evenings and rarely on weekends. <br>  The documentation in aiohttp is pretty good, many asynchronous drivers and wrappers are ready for testing. <br>  Perhaps for production, not everything is ready yet, but development is very active (in 3 weeks aiohttp was updated from version 0.19 to 0.21). <br>  If you need to add sockets to the project, this option is perfect, so as not to add a heavy Tornado depending. </p><br><p>  <strong>Links</strong> </p><br><ul><li><p>  <a href="http">Github</a> </p><br></li><li><p>  <a href="http.readthedocs.org/en/stable/">Aiohttp</a> </p><br></li><li><p>  <a href="https://github.com/aio-libs">Aiohttp libs</a> </p><br></li><li><p>  <a href="https://www.mongodb.org/">Mongodb</a> </p><br></li><li><p>  <a href="https://motor.readthedocs.org/en/stable/">Motor</a> </p><br></li><li><p>  <a href="https://github.com/rconradharris/envparse">envparse</a> </p><br></li><li>  <a href="https://habrahabr.ru/post/242541/">Writing a framework on asyncio, aiohttp and thinking about Python3 part one</a> </li></ul><br><p>  All errors and omissions please send in PM :) </p><br><p>  <strong>UPD</strong> </p><br><p>  Some time has passed since the article was released, unfortunately the application on Heroku has long been unavailable, so testing the demo will not work anymore.  There was some time to update the code and dependencies, but the article still has the old code. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/300942/">https://habr.com/ru/post/300942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../300928/index.html">Why is it worth hiring a junior</a></li>
<li><a href="../300930/index.html">How to make a quick web application or 8 tips to developers on code optimization</a></li>
<li><a href="../300934/index.html">Java code optimization in Android Marshmallow</a></li>
<li><a href="../300936/index.html">Banks need a mobile</a></li>
<li><a href="../300940/index.html">The very personal story of Evan Spiegel, the creator of the Snapchat service - an inside view</a></li>
<li><a href="../300944/index.html">What does the return of Megamind for companies in Habr√© mean</a></li>
<li><a href="../300946/index.html">Template language for the universal signature code analyzer</a></li>
<li><a href="../300948/index.html">‚ÄúI don‚Äôt remember those moments, I don‚Äôt even remember!‚Äù</a></li>
<li><a href="../300952/index.html">Multithreading in PHP: pthreads</a></li>
<li><a href="../300954/index.html">Writing a forum from scratch on Ruby on Rails and AngularJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>