<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL 10 partitioning and more</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of the PostgreSQL 10 version achievements have a registration in the Partitioning section. And this is true: it is obvious that in the transition...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL 10 partitioning and more</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ds/xr/zm/dsxrzmeibd6tinshar_d6zh9-gg.jpeg"></p><br><p>  <em>Many of the PostgreSQL 10 version achievements have a registration in the Partitioning section.</em>  <em>And this is true: it is obvious that in the transition from 9.6 to 10 there was a powerful technological leap.</em>  <em>In previous versions, sections were built and managed by them, by the means that already existed: the inheritance mechanism with all its limitations and inconveniences.</em> </p><br><p>  <em>In version 10, they moved to more specialized mechanisms and more familiar (including for Oracle users, and this has to be considered) syntax.</em>  <em>This jump in the transition from 10 to version 11 was supposed to be supported by important additions that should expand the functionality and improve the performance of operations using partitioning.</em>  <em>But from the results of the last komitfest (it ended on April 8) it is clear that not all of our plans were able to be brought to working condition, which means that not everything will fall into version 11.</em> </p><br><p> <em>In addition, over the past couple of years, the pg_pathman module has been developed in parallel in Postgres Professional.</em>  <em>Some important features intersected, some remained unique to PostgreSQL and <code>pg_pathman</code> (which works with the vanilla version, that is, PostgreSQL 10 + pg_pathman already gives quite an impressive amount of functionality).</em>  <em>This will be a separate article.</em>  <em>Comments related to version 11 and to pg_pathman are italicized for convenience.</em> </p><br><p>  <em>This article is a revised and updated part of the book Nouveaulit√©s de PostgreSQL 10. (c) Dalibo, translated from the French by Igor Levshin ( <a href="">original</a> ).</em>  <em>Examples from the book are checked, sometimes adapted and localized for greater clarity.</em> </p><a name="habracut"></a><br><h3 id="staryy-podhod-k-sekcionirovaniyu">  Old partitioning approach </h3><br><p>  Prior to version 10, partitioning in PostgreSQL was based on the mechanism of table inheritance.  Child tables are created as heirs of one - the parent.  In this case, a request to read the parent table means reading the data not only of the parent, but also of the child tables.  Subsequent additions in PostgreSQL made it so that reading child tables does not occur when integrity constraints ensure that these sections do not contain the data you are looking for.  Such selective reading is therefore determined by the optimizer. </p><br><p>  Recording happens differently.  Inserting into the parent table is not automatically redirected to the corresponding child tables: you must add a trigger that will cancel the insertion into the parent table, redirecting the data to the correct child table.  You cannot update values ‚Äã‚Äãin columns with a split key.  Finally, the deletion happens correctly automatically. </p><br><p>  All this requires a lot of work when creating sections.  Managing sections is not always easy.  It is necessary to ensure that the sections were created correctly from the very beginning so that the insert triggers could work correctly. </p><br><p>  Among other inconveniences mention problems with indexes.  It is not possible to create a global index (that is, an index on several tables), it is also impossible to create a global primary key on a partitioned table.  In essence, this means that it is impossible to limit uniqueness. </p><br><p>  In other words, this mechanism may be interesting in some very specific cases, and you need to have good guarantees that it will not create other problems, especially in performance.  In all other cases, it is better to do without such partitioning. </p><br><h3 id="novyy-podhod-k-sekcionirovaniyu">  New approach to partitioning </h3><br><p>  Version <em>10</em> introduced a new partitioning system, based on the infrastructure that already existed in PostgreSQL. </p><br><p>  The goal of the developers was to simplify the creation and administration of partitioned tables.  To existing SQL statements (for example, <code>CREATE TABLE</code> and <code>ALTER TABLE</code> ), special offers have been added for creating, attaching / detaching sections.  Here is a list of changes. </p><br><ul><li>  Creating and administering sections is simplified by integrating into the database engine. </li><li>  Triggers are no longer needed.  Now: <br><ul><li>  insertion speeds up </li><li>  automatic redirection of the inserted data to the correct section appeared </li><li>  an error is generated if sent to the wrong section </li></ul></li><li>  Now when working with sections: <br><ul><li>  can attach / detach sections </li><li>  there are obvious limitations to the integrity of the sections </li><li>  possible partitioning by expression in the partitioning key </li><li>  you can create subsections </li></ul></li><li>  Changes in the system directory: <br><ul><li>  new columns in <code>pg_class</code> </li><li>  new <code>pg_partitioned_table</code> directory </li></ul></li></ul><br><p>  It is easy to make sure that the creation of sections is simplified: it is no longer necessary to create special functions-triggers to control inserts and updates (an example where the old-style triggers are created is at the end of the article).  The data is now automatically routed by functions created when a section is defined.  In the case when a suitable section is not found for the input data, an error is simply generated.  Such automatic routing is not only convenient, it also speeds up the insertion. </p><br><p>  The <code>pg_class</code> directory <code>pg_class</code> been modified and now contains the following information: </p><br><ul><li>  is the table a section (if yes, then: <code>relispartition = 't'</code> ) </li><li>  is the table partitioned (if yes, then: <code>relkind = 'p'</code> ) or is it a regular table ( <code>relkind = 't'</code> ) </li><li>  internal representation of section boundaries ( <code>relpartbound</code> ) </li></ul><br><p>  The <code>pg_partitioned_table</code> directory contains the following columns: </p><br><table><thead><tr><th>  Column </th><th>  Content </th></tr></thead><tbody><tr><td>  partrelid </td><td>  The OID of the <code>pg_class</code> for this partitioned table </td></tr><tr><td>  partstrat </td><td>  Partitioning strategy: l = by list ( <code>BY LIST</code> ), r = by range ( <code>BY RANGE</code> ) </td></tr><tr><td>  partnatts </td><td>  The number of columns in the split key </td></tr><tr><td>  partattrs </td><td>  An array of partnatts length indicating which columns of the table are included in the partitioning key. *) </td></tr><tr><td>  partclass </td><td>  For each column in the partitioning key, this array contains the OID of the applicable operator classes. </td></tr><tr><td>  partcollation </td><td>  For each column in the partitioning key, this array contains the OID of the sorting rule **) </td></tr><tr><td>  partexprs </td><td>  Expression trees for parts of the partitioning key. ***) </td></tr></tbody></table><br><p>  *) For example, values ‚Äã‚Äã1 and 3 will mean that the partitioning key is the first and third columns of the table.  A zero in this array means that the corresponding part of the partitioning key is an expression, and not a reference to a single column. <br>  **) For partitioning or 0 if the data type of this column is not sortable. <br>  ***) Expression trees (in the nodeToString () view) for parts of the split key that are not simple column references.  This list contains one element for each zero value in partattrs.  The value can be NULL if all parts of the partitioning key are simple column indications. </p><br><p>  <strong>Types of sectioning</strong> </p><br><ul><li>  by the list </li><li>  by range </li><li>  by hash </li><li>  by expression </li><li>  by composite key </li><li>  with subsections </li></ul><br><p>  PostgreSQL 10 supports everything except the third.  We will now focus on the first two. </p><br><h3 id="sekcionirovanie-po-spisku-znacheniy">  Listing of values </h3><br><p>  Create the main table and its sections: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_1(c1 integer, c2 text) PARTITION BY LIST (c1); CREATE TABLE habr_10=# CREATE TABLE parti_1_a PARTITION OF parti_1 FOR VALUES IN (1, 2, 3); CREATE TABLE habr_10=# CREATE TABLE parti_1_b PARTITION OF parti_1 FOR VALUES IN (4, 5); CREATE TABLE</span></span></code> </pre> <br><p>  We can disconnect and connect sections: </p><br><p>  Disconnect: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># ALTER TABLE parti_1 DETACH PARTITION parti_1_a;</span></span></code> </pre> <br><p>  Now it is an independent table.  Attach it back: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># ALTER TABLE parti_1 ATTACH PARTITION parti_1_a FOR VALUES IN (1, 2, 3);</span></span></code> </pre> <br><p>  Fill it with data.  First try to enter a value not from the list.  If there is no partition corresponding to the partitioning key, an error is generated: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_1 VALUES (0); ERROR: no PARTITION OF relation "parti_1" found for row DETAIL: Partition key of the failing row contains (c1) = (0). habr_10=# INSERT INTO parti_1 VALUES (6); ERROR: no PARTITION OF relation "parti_1" found for row DETAIL: Partition key of the failing row contains (c1) = (6).</span></span></code> </pre> <br><p>  Now we enter the correct data: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_1 VALUES (1); INSERT 0 1 habr_10=# INSERT INTO parti_1 VALUES (2); INSERT 0 1 habr_10=# INSERT INTO parti_1 VALUES (5); INSERT 0 1 habr_10=# SELECT * FROM parti_1_a; c1 | c2 ----+---- 1 | 2 | (2 rows) habr_10=# SELECT * FROM parti_1_b; c1 | c2 ----+---- 5 | (1 row)</span></span></code> </pre> <br><p>  In the process of inserting data is correctly distributed into sections.  The parent partitioned table is empty: no data is stored in the parent partitioned table.  You can verify this by using the SELECT statement with an <code>ONLY</code> statement: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># SELECT * FROM ONLY parti_1; c1 | c2 ----+---- (0 rows)</span></span></code> </pre> <br><h3 id="sekcionirovanie-po-diapazonu">  Range Partitioning </h3><br><p>  Create the main table and one section: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_2(c1 integer, c2 text) PARTITION BY RANGE (c1); CREATE TABLE habr_10=# CREATE TABLE parti_2_1 PARTITION OF parti_2 FOR VALUES FROM (1) to (100); CREATE TABLE</span></span></code> </pre> <br><p>  Fill the data section: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_2 VALUES (0); ERROR: no PARTITION OF relation "parti_2" found for row DETAIL: Partition key of the failing row contains (c1) = (0). habr_10=# INSERT INTO parti_2 VALUES (1); INSERT 0 1 habr_10=# INSERT INTO parti_2 VALUES (2); INSERT 0 1 habr_10=# INSERT INTO parti_2 VALUES (5); INSERT 0 1 habr_10=# INSERT INTO parti_2 VALUES (101); ERROR: no PARTITION OF relation "parti_2" found for row DETAIL: Partition key of the failing row contains (c1) = (101).</span></span></code> </pre> <br><p>  If there is no partition corresponding to the partitioning key, an error is generated. </p><br><h3 id="sostavnoy-klyuch-razbieniya">  Composite partitioning key </h3><br><p>  The composite partitioning key only works when partitioned.  Create a main table with a composite key: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_3(c1 integer, c2 text, c3 date) PARTITION BY RANGE (c1, c3);</span></span></code> </pre> <br><p>  Add a section using the composite partitioning key: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_3_a PARTITION of parti_3 FOR VALUES FROM (1,'2017-08-10') TO (100, '2017-08-11');</span></span></code> </pre> <br><p>  We illustrate the sharing of different table spaces in the example below.  Start by creating tablespaces.  Recall that the tablespace directory must exist, be empty, and belong to the OS user running Postgres.  For example: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span><span class="hljs-comment"><span class="hljs-comment">#mkdir /tmp/tablespaces/ts0 test#sudo chown postgres /tmp/tablespaces/ts0</span></span></code> </pre> <br><p>  Now : </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLESPACE ts0 LOCATION '/tmp/tablespaces/ts0'; CREATE TABLESPACE habr_10=# CREATE TABLESPACE ts1 LOCATION '/tmp/tablespaces/ts1'; CREATE TABLESPACE habr_10=# CREATE TABLESPACE ts2 LOCATION '/tmp/tablespaces/ts2'; CREATE TABLESPACE habr_10=# CREATE TABLESPACE ts3 LOCATION '/tmp/tablespaces/ts3'; CREATE TABLESPACE</span></span></code> </pre> <br><p>  Create a partitioned table and two sections: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># DROP TABLE parti_3; DROP TABLE</span></span></code> </pre> <br><p>  (Sections are deleted in cascade) </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_3(c1 integer, c2 text, c3 date not null) PARTITION BY RANGE (c1, c3); CREATE TABLE habr_10=# CREATE TABLE parti_3_1 PARTITION OF parti_3 FOR VALUES FROM (1,'2017-08-10') TO (100, '2017-08-11') TABLESPACE ts1; CREATE TABLE habr_10=# CREATE TABLE parti_3_2 PARTITION OF parti_3 FOR VALUES FROM (100,'2017-08-11') TO (200, '2017-08-12') TABLESPACE ts2; CREATE TABLE</span></span></code> </pre> <br><p>  If the values ‚Äã‚Äãdo not exceed the boundaries of the sections: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_3 VALUES (1, 'test', '2017-08-10'); INSERT 0 1 habr_10=# INSERT INTO parti_3 VALUES (150, 'test2', '2017-08-11'); INSERT 0 1</span></span></code> </pre> <br><p>  If <code>c1</code> too small: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_3 VALUES (0, 'test', '2017-08-10'); ERROR: no partition of relation "parti_3" found for row DETAIL : Partition key of the failing row contains (c1, c3) = (0, 2017-08-10).</span></span></code> </pre> <br><p>  If the value of <code>c3</code> (column with date data type) precedes the lower boundary of the time range: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># INSERT INTO parti_3 VALUES (1, 'test', '2017-08-09'); ERROR: no partition of relation "parti_3" found for row DETAIL : Partition key of the failing row contains (c1, c3) = (1, 2017-08-09).</span></span></code> </pre> <br><p>  Special values ‚Äã‚ÄãMINVALUE and MAXVALUE allow not to specify the value of one of the boundaries.  For example, the parti_3_0 and parti_3_3 sections can be declared as shown below and successfully inserted the lines that caused the error message above. </p><br><p>  Note: some online articles that were published prior to the release of the beta3 version mention the special value UNBOUNDED, which was later replaced by MINVALUE and MAXVALUE. </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE TABLE parti_3_0 PARTITION OF parti_3 FOR VALUES FROM (MINVALUE, MINVALUE) TO (1,'2017-08-10') TABLESPACE ts0; habr_10=# CREATE TABLE parti_3_3 PARTITION OF parti_3 FOR VALUES FROM (200,'2017-08-12') TO (MAXVALUE, MAXVALUE) TABLESPACE ts3;</span></span></code> </pre> <br><p>  Finally, you can handle the <code>pg_class</code> table to make sure that the created sections of various types exist: </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># ANALYZE parti_3; ANALYZE habr_10=# SELECT relname,relispartition,relkind,reltuples FROM pg_class WHERE relname LIKE 'parti_3%'; relname | relispartition | relkind | reltuples -------------+----------------+---------+----------- parti_3 | f | p | 0 parti_3_1 | t | r | 1 parti_3_2 | t | r | 1 (5 rows)</span></span></code> </pre> <br><p>  <strong>Default sections and automatic section creation</strong> </p><br><p>  <em>It would be convenient to have a section where all the records that fall outside the bounds of the specified sections would fall in order not to stop each time due to an error.</em>  <em>This <a href="https://commitfest.postgresql.org/14/1198/">feature</a> will appear in version 11.</em> </p><br><p>  <em>In the pg_pathman module there are very convenient functions that allow you not to think about whether the value falls within the assigned range boundaries.</em>  <em>There you can <a href="https://postgrespro.ru/docs/enterprise/9.6/pg-pathman">set the</a> interval of values ‚Äã‚Äãfor the sections, and the module itself will create as many of them as needed to hold the entered values.</em>  <em>This will work on sections like BY RANGE.</em> </p><br><p>  <em>It should be borne in mind that PostgreSQL 10 does not have hash partitioning.</em>  <em>This serious flaw was corrected at 11: the corresponding patch passed the commit fest, so it remains to wait for the release of PostgreSQL 11. If hash partitioning is necessary or desirable right now, <code>pg_pathman</code> can be used.</em> </p><br><h3 id="proizvoditelnost-vstavki">  Insert performance </h3><br><p>  Table <em>no_parti</em> is a <em>non</em> -partitioned table.  We create it as follows: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> no_parti (c1 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, c2 <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> no_parti <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i, <span class="hljs-string"><span class="hljs-string">'something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9999999</span></span>) i; Time: 10097.098 ms (00:10.097)</code> </pre> <br><p>  Create the <em>parti_new</em> table using the new PostgreSQL 10 version functionality: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new (c1 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, c2 <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANGE</span></span> (c1); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_1 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">1000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_2 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">2000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_3 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">2000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">3000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_4 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">4000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_5 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">4000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">5000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_6 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">5000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">6000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_7 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">6000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">7000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_8 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">7000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">8000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_9 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">8000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ( <span class="hljs-number"><span class="hljs-number">9000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_new_0 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-number"><span class="hljs-number">9000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_new <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i, <span class="hljs-string"><span class="hljs-string">'something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9999999</span></span>) i; Time: 11448.867 ms (00:11.449)</code> </pre> <br><p>  Create the <em>parti_old</em> table using the old partitioning method: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old (c1 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, c2 <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_1 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_2 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_3 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">3000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_4 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">3000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">4000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_5 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">4000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_6 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">6000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_7 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">6000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">7000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_8 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">7000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">8000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_9 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">8000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">9000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> parti_old_0 (<span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> (c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">9000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span>)) INHERITS (parti_old); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> insert_into() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $FUNC$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> NEW.c1 <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_1 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 1000000 AND 2000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_2 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 2000000 AND 3000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_3 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 3000000 AND 4000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_4 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 4000000 AND 5000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_5 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 5000000 AND 6000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_6 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 6000000 AND 7000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_7 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 7000000 AND 8000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_8 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 8000000 AND 9000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_9 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF NEW.c1 BETWEEN 9000000 AND 10000000 THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old_0 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; RETURN NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $FUNC$; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> tr_insert_parti_old <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> parti_old <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> insert_into(); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> parti_old <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i, <span class="hljs-string"><span class="hljs-string">'something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9999999</span></span>) i; Time: 125351.918 ms (02:05.352)</code> </pre> <br><p>  We see that the insertion rate for the new approach to partitioning is much higher. </p><br><p>  <em>Version 11 has a <a href="https://commitfest.postgresql.org/17/1503/">patch</a> that significantly increases the insertion speed when the data in the partitioning key grow monotonously or almost monotonously.</em> </p><br><p>  <em>With regard to reading performance, at stage 10 -&gt; 11 fundamental changes have occurred: it has become possible to <a href="https://commitfest.postgresql.org/17/1272/">effectively exclude</a> from the plan a section in which there is obviously no data (partition pruning).</em>  <em>This can be <a href="https://commitfest.postgresql.org/17/1330/">done</a> at the stage of execution, when the condition of hitting a particular section is not known in advance.</em>  <em>This happens, for example, in cases of a subquery.</em> </p><br><p>  <em>So far, section exclusion (reliably) works <a href="http://www.postgresql-archive.org/pruning-disabled-for-array-enum-record-range-type-partition-keys-td6016025.html">only</a> in list sectioning.</em>  <em>In the case when there are a lot of sections (and in real projects there are thousands, or even tens of thousands), the exclusion of sections can seriously reduce the request execution time.</em>  <em>In <code>pg_pathman</code> exclusion of unnecessary sections has been implemented almost from the very beginning of the project.</em> </p><br><p><img src="https://habrastorage.org/webt/s9/u-/fa/s9u-fa8owhyhptiaitppvk_rghy.jpeg"></p><br><h2 id="sravnenie-starogo-i-novogo-sekcionirovaniya-na-primerah">  Comparing old and new sectioning with examples </h2><br><p>  We will understand the differences in the approach to partitioning in versions 9.6 and 10. </p><br><p>  Create a table of temperatures associated with the place and date.  We will create sections for each place and each month. </p><br><p>  Commands for creating such tables in 9.6: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo ( t_id <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span>, place <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, hour_mesure <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), temperature <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_moscow_201709 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_moscow_201710 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_sochi_201709 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Sochi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_sochi_201710 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Sochi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_magadan_201709 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Magadan'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_magadan_201710 ( <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( place = <span class="hljs-string"><span class="hljs-string">'Magadan'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span> ) ) INHERITS (meteo); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> meteo_insert_trigger() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> ( NEW.place = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> ( NEW.hour_mesure &gt;= <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> NEW.hour_mesure &lt; <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span> <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_moscow_201709 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF ( NEW.hour_mesure &gt;= TIMESTAMP '2017-10-01 00:00:00' AND NEW.hour_mesure &lt; TIMESTAMP '2017-11-01 00:00:00' ) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_moscow_201710 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSE RAISE EXCEPTION 'Date does not fit meteo_insert_trigger(Moscow)'; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; ELSIF ( NEW.place = 'Sochi' ) THEN IF ( NEW.hour_mesure &gt;= TIMESTAMP '2017-09-01 00:00:00' AND NEW.hour_mesure &lt; TIMESTAMP '2017-10-01 00:00:00' ) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_sochi_201709 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF ( NEW.hour_mesure &gt;= TIMESTAMP '2017-10-01 00:00:00' AND NEW.hour_mesure &lt; TIMESTAMP '2017-11-01 00:00:00' ) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_sochi_201710 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSE RAISE EXCEPTION 'Date does not fit meteo_insert_trigger(Sochi)'; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; ELSIF ( NEW.place = 'Magadan' ) THEN IF ( NEW.hour_mesure &gt;= TIMESTAMP '2017-09-01 00:00:00' AND NEW.hour_mesure &lt; TIMESTAMP '2017-10-01 00:00:00' ) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_magadan_201709 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSIF ( NEW.hour_mesure &gt;= TIMESTAMP '2017-10-01 00:00:00' AND NEW.hour_mesure &lt; TIMESTAMP '2017-11-01 00:00:00' ) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo_magadan_201710 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (NEW.*); ELSE RAISE EXCEPTION 'Date does not fit meteo_insert_trigger(Magadan)'; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; ELSE RAISE EXCEPTION 'Date does not fit meteo_insert_trigger() !'; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; RETURN NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ LANGUAGE plpgsql; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> insert_meteo_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> meteo_insert_trigger();</code> </pre> <br><p>  Commands for creating such tables in 10; </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo ( t_id <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, place <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, hour_mesure <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>(), temperature <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANGE</span></span> (place, hour_mesure); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_moscow_201709 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_moscow_201710 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_sochi_201709 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_sochi_201710 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_paris_201709 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_paris_201710 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-10-01 00:00:00'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-11-01 00:00:00'</span></span>);</code> </pre> <br><p>  Note that the declarative syntax of version 10 is much simpler than the syntax 9.6.  In it, as can be seen from the example, the most tedious part of the work is the creation of trigger functions. </p><br><p>  ( <em>In <code>pg_pathman</code> developers went even further. There are <a href="https://postgrespro.ru/docs/enterprise/9.6/pg-pathman">functions</a> available that cut the existing sections, merge neighboring ones and many others.</em> ) </p><br><p>  Here is an example of a function that creates random rows in a table: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> populate_meteo() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> placex <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] := <span class="hljs-string"><span class="hljs-string">'{}'</span></span>; v_place text; v_hour timestamp; v_temperature real; v_nb_insertions integer := 500000; v_insertion integer; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> placex[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>; placex[1]='Sochi'; placex[2]='Magadan'; FOR v_insertion IN 1 .. v_nb_insertions LOOP v_place=placex[floor((random()*3))::int]; v_hour='2017-09-01'::timestamp + make_interval(days =&gt; floor((random()*60))::int, secs =&gt; floor((random()*86400))::int); v_temperature:=round(((random()*14))::numeric+10,2); IF EXTRACT(MONTH FROM v_hour) = 10 THEN v_temperature:=v_temperature-4; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; IF EXTRACT(HOUR FROM v_hour) &lt;= 9 OR EXTRACT(HOUR FROM v_hour) &gt;= 20 THEN v_temperature:=v_temperature-5; ELSEIF EXTRACT(HOUR FROM v_hour) &gt;= 12 AND EXTRACT(HOUR FROM v_hour) &lt;= 17 THEN v_temperature:=v_temperature+5; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> meteo (place,hour_mesure,temperature) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (v_place,v_hour,v_temperature); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; RETURN v_nb_insertions||' mesures de temp√©rature ins√©r√©es'; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ LANGUAGE plpgsql;</code> </pre> <br><p>  Insert rows into the meteo tables from habr_9_6 and habr_10: </p><br><pre> <code class="sql hljs">habr_9_6=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN ANALYSE SELECT populate_meteo(); QUERY PLAN ------------------------------------------------------------------------------------------ Result (cost=0.00..0.26 rows=1 width=32) (actual time=33315.067..33315.068 rows=1 loops=1) Planning time: 0.034 ms Execution time: 33315.084 ms (3 rows) habr_10=# EXPLAIN ANALYSE SELECT populate_meteo(); QUERY PLAN --------------------------------------------------------------------------------------- Result (cost=0.00..0.26 rows=1 width=32) (actual time=14976.438..14976.438 rows=1 loops= 1) Planning time: 0.016 ms Execution time: 14976.499 ms (3 rows)</span></span></code> </pre> <br><p>  We see that in version 10 data is inserted twice as fast. </p><br><p>  <strong>Manage the entire section family at once</strong> </p><br><p>  For operations with sections created using inheritance mechanisms, their explicit listing is required. </p><br><pre> <code class="sql hljs">habr_9_6=<span class="hljs-comment"><span class="hljs-comment"># SELECT 'VACUUM ANALYZE '||relname AS operation FROM pg_stat_user_tables WHERE relname LIKE 'meteo_%'; operation ------------------------------------ VACUUM ANALYZE meteo_moscow_201709 VACUUM ANALYZE meteo_moscow_201710 VACUUM ANALYZE meteo_sochi_201709 VACUUM ANALYZE meteo_sochi_201710 VACUUM ANALYZE meteo_paris_201709 VACUUM ANALYZE meteo_paris_201710 (6 rows) habr_9_6=# \gexec VACUUM VACUUM VACUUM VACUUM VACUUM VACUUM</span></span></code> </pre> <br><p>   10  ,   VACUUM  ANALYSE  ,       : </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># VACUUM ANALYZE meteo; VACUUM habr_10=# SELECT now() AS date,relname,last_vacuum,last_analyze FROM pg_stat_user_tables WHERE relname LIKE 'meteo_sochi%'; -[ RECORD 1 ]+------------------------------ date | 2018-04-06 23:38:48.59511+03 relname | meteo_sochi_201709 last_vacuum | 2018-04-06 23:37:05.931573+03 last_analyze | 2018-04-06 23:37:05.958845+03 -[ RECORD 2 ]+------------------------------ date | 2018-04-06 23:38:48.59511+03 relname | meteo_sochi_201710 last_vacuum | 2018-04-06 23:37:05.973254+03 last_analyze | 2018-04-06 23:37:06.002487+03</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/eu/pk/ij/eupkijygzjl558q19r2p3rw74e0.jpeg"></p><br><h2 id="ogranicheniya-versii-10">   10 </h2><br><p> <strong>Index</strong> </p><br><p>   10      -  : </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX meteo_hour_mesure_idx ON meteo (hour_mesure); ERROR: cannot create index on partitioned table "meteo"</span></span></code> </pre> <br><p>    ,     ,   . </p><br><p>         ,        . </p><br><p>    ,     9.6,       : </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX meteo_moscow_201710_hour_idx ON meteo_moscow_201710 (hour_mesure); CREATE INDEX</span></span></code> </pre> <br><p> <em>  11   <a href="https://commitfest.postgresql.org/17/1452/"> </a> (         ).   ,              (FOREIGN KEY)</em> </p><br><p> <strong> </strong> </p><br><p>   10 <a href="https://postgrespro.ru/docs/postgresql/10/ddl-partitioning"></a>         <code>UPDATE</code> ,            . </p><br><pre> <code class="sql hljs">habr_10=<span class="hljs-comment"><span class="hljs-comment"># UPDATE meteo SET place='Sochi' WHERE place='Moscow'; ERROR: new row for relation "meteo_moscow_201709" violates partition constraint DETAIL : Failing row contains (5, Sochi, 2017-09-15 05:09:23, 9.43).</span></span></code> </pre> <br><p>   11      :  <a href="https://commitfest.postgresql.org/14/1023/"> </a>   . </p><br><p> <strong>     </strong> </p><br><p>     10    : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_moscow_ancienne <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">MINVALUE</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_sochi_ancienne <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">MINVALUE</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Sochi'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> meteo_paris_ancienne <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> meteo <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">MINVALUE</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'Magadan'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-09-01 00:00:00'</span></span>);</code> </pre> <br><p> <strong> </strong> </p><br><ul><li>       </li><li>           </li><li>     </li><li>  NULL       ,      ()  </li><li> ,     ,   (     FDW ‚Äî <code>CREATE FOREIGN TABLE ... PARTITION OF ...</code> ). </li><li>     <br><ul><li>     (    ) </li><li>      <code>CHECK</code> . </li></ul></li></ul><br><p> <em>      11.</em> </p><br><p>   PostgreSQL  , ,  ,   .         . </p><br><p> [ <em>postgres-  </em> ] </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353472/">https://habr.com/ru/post/353472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353462/index.html">How to get into Microsoft, Amazon or Twitter without a prestigious college diploma</a></li>
<li><a href="../353464/index.html">Online statistics in Telegram</a></li>
<li><a href="../353466/index.html">Uncountable: in search of a finite number</a></li>
<li><a href="../353468/index.html">What's new in AppCode 2018.1</a></li>
<li><a href="../353470/index.html">Migration from Check Point from R77.30 to R80.10</a></li>
<li><a href="../353476/index.html">Aitracking, Emotions and VR: Technology Convergence and Current Research</a></li>
<li><a href="../353478/index.html">Beautiful listing of files and directories in nginx</a></li>
<li><a href="../353480/index.html">Dangerous pickles - malicious serialization in Python</a></li>
<li><a href="../353482/index.html">4. Check Point for maximum. Checking Anti-Virus with Kali Linux</a></li>
<li><a href="../353484/index.html">Organizer catalog for Heroes III cards and more than 7,700 cards in addition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>