<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lightweight Tables or practical tips when designing a database ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this topic, I would like to talk about improving performance when working with tables. 

 The topic is not new, but it becomes especially relevant ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lightweight Tables or practical tips when designing a database ...</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dc9/8af/49f/dc98af49fc5b6cdf88d5006db5c570ff.png" align="left">  In this topic, I would like to talk about improving performance when working with tables. <br><br>  The topic is not new, but it becomes especially relevant when there is a constant growth of data in the database - the tables become large, and the search and selection for them is slow. <br><br>  As a rule, this is due to a poorly designed scheme - initially not designed for operating with large amounts of data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order for the growth of data in the tables not to lead to a drop in performance when working with them, it is recommended to adopt a few rules when designing a circuit. <br><a name="habracut"></a><br>  <b>The first and probably the most important.</b>  Data types in tables must have minimal redundancy. <br><br>  All data operated by <i>SQL Server</i> is stored on the so-called pages, which have a fixed size of 8 KB.  When writing and reading, the server operates with pages, not separate lines. <br><br>  Therefore, the more compact data types are used in the table, the fewer pages are required to store them.  Fewer pages - fewer disk operations. <br><br>  In addition to the obvious reduction in the load on the disk subsystem - in this case there is another advantage - when reading from a disk, any page is initially placed in a special memory area ( <i>Buffer Pool</i> ), and then used for its intended purpose - to read or modify data. <br><br>  When using compact data types, you can put more data on the same number of pages in the <i>Buffer Pool</i> - due to this we do not waste memory and reduce the number of logical operations. <br><br>  Now consider a small example - a table that stores information about the working days of each employee. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.WorkOut1 ( DateOut DATETIME , EmployeeID <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> , WorkShiftCD <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) , WorkHours <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) , <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_WorkOut1 PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (DateOut, EmployeeID) )</code> </pre> <br>  Are the data types selected correctly in this table?  Apparently not. <br><br>  For example, it is very doubtful how many employees in an enterprise (2 ^ 63-1) are, that the <i>BIGINT</i> data type was chosen to cover such a situation. <br><br>  Remove the redundancy and see if the query from such a table will be faster? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.WorkOut2 ( DateOut SMALLDATETIME , EmployeeID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> , WorkShiftCD <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) , WorkHours <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) , <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_WorkOut2 PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (DateOut, EmployeeID) )</code> </pre><br>  On the execution plan, you can see the difference in cost, which depends on the average line size and the expected number of lines that the query will return: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e0/f1e/6b8/9e0f1e6b82953e3bf1442dc1ad24b051.png"><br><br>  It is quite logical that the less data is required to read - the faster the query will be executed: <br><br>  <i>(3492294 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 1919 ms, elapsed time = 33606 ms.</i> <i><br><br></i>  <i>(3492294 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 1420 ms, elapsed time = 29694 ms.</i> <br><br>  As you can see, the use of less redundant data types often has a positive effect on query performance and can significantly reduce the size of problem tables. <br><br>  By the way, you can find out the size of the table by the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> table_name = SCHEMA_NAME(o.[schema_id]) + <span class="hljs-string"><span class="hljs-string">'.'</span></span> + o.name , data_size_mb = <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(do.pages * <span class="hljs-number"><span class="hljs-number">8.</span></span> / <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.objects o <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.[object_id] , total_rows = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(p.[<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>]) , total_pages = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(a.total_pages) , usedpages = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(a.used_pages) , pages = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> it.internal_type <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">202</span></span>, <span class="hljs-number"><span class="hljs-number">204</span></span>, <span class="hljs-number"><span class="hljs-number">207</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">212</span></span>, <span class="hljs-number"><span class="hljs-number">213</span></span>, <span class="hljs-number"><span class="hljs-number">214</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>, <span class="hljs-number"><span class="hljs-number">216</span></span>, <span class="hljs-number"><span class="hljs-number">221</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> a.[<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] != <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> p.index_id &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> a.used_pages <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> p.index_id &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> a.data_pages <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.partitions p <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.allocation_units a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.[partition_id] = a.container_id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sys.internal_tables it <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.[object_id] = it.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.[object_id] ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.[object_id] = do.[object_id] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> o.[<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] = <span class="hljs-string"><span class="hljs-string">'U'</span></span></code> </pre><br>  For the tables in question, the query will return the following results: <br><br><pre> <code class="sql hljs">table_name data_size_mb <span class="hljs-comment"><span class="hljs-comment">-------------------- ------------------------------- dbo.WorkOut1 167.2578 dbo.WorkOut2 97.1250</span></span></code> </pre><br>  <b>Rule two.</b>  Avoid duplication and apply data normalization. <br><br>  Actually, I recently analyzed a database of one <a href="http://sql-format.com/">free web service</a> for formatting <i>T-SQL</i> code.  The server part there is very simple and consisted of a single table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.format_history ( session_id <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> , format_date DATETIME , format_options <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> )</code> </pre><br>  Each time formatting, the current session id was saved, the server system time and settings with which the user formatted his SQL code.  The data was then used to identify the most popular formatting styles. <br><br>  With the growing popularity of the service, the number of rows in the table has increased, and the processing of formatting profiles took more and more time.  The reason was in the architecture of the service - with each insertion into the table the full set of settings was saved. <br><br>  The settings had the following XML structure: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FormatProfile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FormatOptions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Select_SelectList_IndentColumnList"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Select_SelectList_SingleLineColumns"</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Select_SelectList_StackColumns"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Select_SelectList_StackColumnsMode"</span></span></span><span class="hljs-tag">&gt;</span></span>1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Select_Into_LineBreakBeforeInto"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UnionExceptIntersect_LineBreakBeforeUnion"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UnionExceptIntersect_LineBreakAfterUnion"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UnionExceptIntersect_IndentKeyword"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UnionExceptIntersect_IndentSubquery"</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyValue</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FormatOptions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FormatProfile</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  A total of 450 formatting options - each such line in the table occupied approximately 33Kb.  A daily increase in data was more than 100MB.  Every day the base grew, and it became longer to do analytics on it. <br><br>  It was easy to correct the situation - all unique profiles were moved to a separate table, where for each set of options a hash was obtained.  Beginning with <i>SQL Server 2008</i> , you can use the <i>sys.fn_repl_hash_binary</i> function for this. <br><br>  As a result, the circuit was normalized: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.format_profile ( format_hash <span class="hljs-built_in"><span class="hljs-built_in">BINARY</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> , format_profile <span class="hljs-keyword"><span class="hljs-keyword">XML</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.format_history ( session_id <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> , format_date SMALLDATETIME , format_hash <span class="hljs-built_in"><span class="hljs-built_in">BINARY</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_format_history PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED (session_id, format_date) )</code> </pre><br>  And if the request for proofreading used to be this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fh.session_id, fh.format_date, fh.format_options <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> SQLF.dbo.format_history fh</code> </pre><br>  Then to get the same data in the new scheme, it was necessary to make a JOIN: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fh.session_id, fh.format_date, fp.format_profile <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> SQLF_v2.dbo.format_history fh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> SQLF_v2.dbo.format_profile fp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fh.format_hash = fp.format_hash</code> </pre><br>  If we compare the execution time of requests, we will not see a clear advantage from changing the scheme. <br><br>  <i>(3090 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 203 ms, elapsed time = 4698 ms.</i> <i><br><br></i>  <i>(3090 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 125 ms, elapsed time = 4479 ms.</i> <br><br>  But the goal in this case was pursued by another - to accelerate the analytics.  And if before you had to write a very clever request to get a list of the most popular formatting profiles: <br><br><pre> <code class="sql hljs">;<span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cte <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fh.format_options , hsh = sys.fn_repl_hash_binary(<span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(fh.format_options <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> VARBINARY(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>))) , rn = ROW_NUMBER() <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> SQLF.dbo.format_history fh ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c2.format_options, c1.cnt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP (<span class="hljs-number"><span class="hljs-number">10</span></span>) hsh, rn = <span class="hljs-keyword"><span class="hljs-keyword">MIN</span></span>(rn), cnt = <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cte <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> hsh <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> cnt <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) c1 <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cte c2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c1.rn = c2.rn <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c1.cnt <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre><br>  Then, due to data normalization, it became possible to significantly simplify not only the query itself: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> fp.format_profile , t.cnt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP (<span class="hljs-number"><span class="hljs-number">10</span></span>) fh.format_hash , cnt = <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> SQLF_v2.dbo.format_history fh <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> fh.format_hash <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> cnt <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) t <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> SQLF_v2.dbo.format_profile fp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t.format_hash = fp.format_hash</code> </pre><br>  But also to reduce the time of its implementation: <br><br>  <i>(10 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 2684 ms, elapsed time = 2774 ms.</i> <i><br><br></i>  <i>(10 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 15 ms, elapsed time = 379 ms.</i> <br><br>  A nice addition was also the reduction in the size of the database on disk: <br><br><pre> <code class="sql hljs">database_name row_size_mb <span class="hljs-comment"><span class="hljs-comment">---------------- --------------- SQLF 123.50 SQLF_v2 7.88</span></span></code> </pre><br>  You can return the size of the data file for the database by the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> database_name = DB_NAME(database_id) , row_size_mb = <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> type_desc = <span class="hljs-string"><span class="hljs-string">'ROWS'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) * <span class="hljs-number"><span class="hljs-number">8.</span></span> / <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.master_files <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> database_id <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (DB_ID(<span class="hljs-string"><span class="hljs-string">'SQLF'</span></span>), DB_ID(<span class="hljs-string"><span class="hljs-string">'SQLF_v2'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> database_id</code> </pre><br>  I hope, with this example, I was able to show the importance of normalizing data and minimizing redundancy in the database. <br><br>  <b>Third.</b>  Carefully select the columns included in the indexes. <br><br>  Indexes can significantly speed up the selection of the table.  As well as data from tables, indexes are stored on pages.  Appropriately.  the fewer pages needed to store an index, the faster it can be searched. <br><br>  It is very important to choose the fields that will be included in the cluster index.  Because all the clustered index columns are automatically included in each nonclustered (by pointer). <br><br>  <b>Fourth.</b>  Use intermediate and consolidated tables. <br><br>  Everything is quite simple here - why make a complex query every time from a large table, if you can make a simple query from a small one. <br><br>  For example, there is a request for data consolidation: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> WorkOutID , CE = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'CE'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , DE = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'DE'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , RE = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'RE'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , FD = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'FD'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , TR = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'TR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , FF = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'FF'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , PF = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'PF'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , QW = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'QW'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , FH = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'FH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , UH = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'UH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , NU = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'NU'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) , CS = <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> WorkKeyCD = <span class="hljs-string"><span class="hljs-string">'CS'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.WorkOutFactor <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> WorkOutID</code> </pre><br>  If the data in the table does not change too often, you can create a separate table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.WorkOutFactorCache</code> </pre><br>  And it is not surprising that reading from the consolidated table will be faster: <br><br>  <i>(185916 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 3448 ms, elapsed time = 3116 ms.</i> <i><br><br></i>  <i>(185916 row (s) affected)</i> <i><br><br></i>  <i>SQL Server Execution Times:</i> <i><br></i>  <i>CPU time = 1410 ms, elapsed time = 1202 ms.</i> <br><br>  <b>The fifth.</b>  Each rule has its exceptions. <br><br>  I have shown a couple of examples when changing data types to less redundant ones allows shortening query execution time.  But this is not always the case. <br><br>  For example, the <i>BIT</i> data type has one feature - <i>SQL Server</i> optimizes the storage of a group of similar type columns on a disk.  For example, if there are 8 or less <i>BIT</i> columns in a table, they are stored on the page as 1 byte, if there are up to 16 columns of <i>BIT</i> type, they are stored as 2 bytes, etc. <br><br>  The good news is that the table will take up significantly less space and will reduce the number of disk operations. <br><br>  The bad news is that when sampling data of this type, implicit decoding will occur, which is very demanding on processor resources. <br><br>  I will show it by example.  There are three identical tables that contain information about employee schedules (31 + 2 PK columns).  All of them differ only in the data type for consolidated values ‚Äã‚Äã(1 ‚Äî went to work, 0 ‚Äî was missing): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.E_51_INT <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.E_52_TINYINT <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.E_53_BIT</code> </pre><br>  When using less redundant data, the size of the table has noticeably decreased (especially the last table): <br><br><pre> <code class="sql hljs">table_name data_size_mb <span class="hljs-comment"><span class="hljs-comment">-------------------- -------------- dbo.E31_INT 150.2578 dbo.E32_TINYINT 50.4141 dbo.E33_BIT 24.1953</span></span></code> </pre><br>  But we will not get a significant gain in execution speed from using the <i>BIT</i> type: <br><br><pre> <code class="sql hljs">(1000000 row(s) affected) Table 'E31_INT'. Scan count 1, logical reads 19296, physical reads 1, read-ahead reads 19260, ... SQL Server Execution Times: CPU time = 1607 ms, elapsed time = 19962 ms. (1000000 row(s) affected) Table 'E32_TINYINT'. Scan count 1, logical reads 6471, physical reads 1, read-ahead reads 6477, ... SQL Server Execution Times: CPU time = 1029 ms, elapsed time = 16533 ms. (1000000 row(s) affected) Table 'E33_BIT'. Scan count 1, logical reads 3109, physical reads 1, read-ahead reads 3096, ... SQL Server Execution Times: CPU time = 1820 ms, elapsed time = 17121 ms.</code> </pre><br>  Although the implementation plan will suggest the opposite: <br><br><img src="//habrastorage.org/files/ab6/e98/afe/ab6e98afee914b11a4126c6f559d98bf.png"><br><br>  As a result of the observations, it was noticed that the negative effect of decoding will not appear if the table contains no more than 8 <i>BIT</i> columns. <br><br>  At the same time, it is worth noting that in the <i>SQL Server</i> metadata, the <i>BIT</i> data type is used very rarely - the <i>BINARY</i> type is used more often and a manual shift is made to get one or another value. <br><br>  <b>And the last thing to mention.</b>  Delete unnecessary data. <br><br>  Actually, why do this? <br><br>  When sampling data, SQL Server supports a performance optimization mechanism, called read-ahead, which attempts to predict exactly which data and index pages will be needed to execute a query, and places these pages in the buffer cache before the real need arises. <br><br>  Accordingly, if the table contains a lot of unnecessary data - this can lead to unnecessary disk operations. <br><br>  In addition, the removal of unnecessary data reduces the number of logical operations when reading data from the <i>Buffer Pool</i> - the search and retrieval of data will take place on a smaller amount of data. <br><br>  In conclusion, I can add more - carefully select the data types for the columns in your tables and try to take into account the future load on the database. <br><br>  If you want to share this article with an English-speaking audience, then please use the link to translate: <br>  <a href="http://blog.sqlauthority.com/2015/11/30/sql-server-practical-tips-to-reduce-sql-server-database-table-size-experts-opinion/">SQL Server Database Table Size</a> </div><p>Source: <a href="https://habr.com/ru/post/211885/">https://habr.com/ru/post/211885/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211869/index.html">Arista. Acquaintance</a></li>
<li><a href="../211871/index.html">Design and architecture in the OP. Introduction and Part 1</a></li>
<li><a href="../211877/index.html">Translation Code Club Scratch Curriculum, crowdsourcing</a></li>
<li><a href="../211879/index.html">Modification of UEFI BIOS, part two: useful modifications</a></li>
<li><a href="../211881/index.html">On solving an incomplete cubic equation</a></li>
<li><a href="../211889/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ95 (February 2 - 8, 2014)</a></li>
<li><a href="../211891/index.html">Unfulfilled hopes: what was planned and what happened in the program ‚ÄúSpace Shuttle‚Äù</a></li>
<li><a href="../211893/index.html">Homemade curtain drive</a></li>
<li><a href="../211899/index.html">Features of MVP implementation for Windows Forms</a></li>
<li><a href="../211903/index.html">This is our world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>