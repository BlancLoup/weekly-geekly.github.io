<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Principles of work of one Python-developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this publication, I would like to present to the court of a respected reader some of the principles that guide me in fulfilling my responsibilities...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Principles of work of one Python-developer</h1><div class="post__text post__text-html js-mediator-article">  In this publication, I would like to present to the court of a respected reader some of the principles that guide me in fulfilling my responsibilities as a Python developer. <br><br>  On the one hand, I wanted to share my accumulated experience, which can be useful for novice developers, and on the other hand, to get feedback from more experienced developers, managers and specialists in related fields. <br><br>  Principles are conditionally grouped into three groups: principles of decision making;  principles aimed at improving the quality of the code;  principles to improve code performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Making decisions <ul><li>  Any technical solution must be justified. </li><li>  Responsibility for the decision is always on the one or those who made the decision. </li><li>  When making technical decisions, it is necessary to consider their action in time and their compliance with business needs. </li><li>  One of the main criteria for making technical and other decisions should be their greatest effectiveness. </li><li>  Feel free to deviate from the rules, methodologies, patterns and other restrictions, if the effect of such a deviation exceeds the potential loss (although it‚Äôs practical) </li><li>  If necessary, make a working, but perhaps not the best, solution immediately, and later improve it (Now is better than never, </li><li>  If it is difficult to choose between two alternative technical solutions, then you need to choose any and move with it further, when more information appears, then it will be possible to do refactoring if the solution turned out to be non-optimal </li><li>  The flexibility of technical solutions is highly desirable, and versatility is not required </li></ul></li><li>  Source Code Quality <ul><li>  The quality of the code should be optimized on the basis of a formed system of criteria that is balanced against costs in the short and long term. </li><li>  Write the optimal code immediately, if it does not increase its complexity and development time (Beautiful is better than ugly) </li><li>  Self-documenting code takes precedence over well commented code (Beautiful is better than ugly) </li><li>  Write TODO and FIXME in code </li><li>  Give variables, functions, methods, classes and other source code objects names that accurately reflect their purpose, despite the increase in the length of the names (Explicit is better than implicit) </li><li>  Fewer lines and code size is preferable, while maintaining the same code readability (Simple is better than complex) </li><li>  Apply code review as a tool for detecting errors, leveling development style, getting to know someone else‚Äôs code, and learning in a team </li><li>  Reuse your own and someone else's code </li><li>  Use specialized libraries to solve specific problems, instead of developing their own similar code. </li></ul></li><li>  Performance <ul><li>  Code development performance overrides code execution performance. </li><li>  Optimization of the performance of code execution should be justified by the corresponding need. </li><li>  Optimization of code execution performance should be performed by eliminating the most serious bottlenecks. </li><li>  First of all, the most effective methods for optimizing the performance of code execution should be used. </li></ul></li></ul><br>  The following is a detailed explanation of each of these principles.  For some principles, the postulates of Zen of Python are indicated in parentheses, which in my opinion are related to these principles, or their parts. <a name="habracut"></a><br><br><h4>  <b>Making decisions</b> </h4><br><h5>  <b>Any technical solution must be justified.</b> </h5>  Any technical solution must be justified: from the syntax used in the code to the architectural solutions of the highest level.  For me, the validity of a technical solution means the existence of arguments confirming its advantage, the inevitability of such a decision, or other expediency of this decision.  Justification must be accompanied by the presence of knowledge about the shortcomings of this decision and a plan to overcome them, or justification of their irrelevance.  In addition, alternative solutions should be considered with justification for their lower attractiveness compared to the chosen solution.  The rationale should take into account both technical and organizational aspects associated with a specific technical solution.  If different arguments conflict with each other, then one should be guided by the economic effect of this or that decision for the business, taking into account the short-term and long-term perspectives. <br><br>  In non-technical, including organizational, issues this principle should be applied in a similar way. <br><br>  This principle is opposed to the pattern of decision-making, as well as the thoughtless adoption of the first available decision without a proper analysis of alternatives. <br><br><h5>  <b>Responsibility for the decision is always on the one or those who made the decision.</b> </h5>  This principle is aimed at improving the quality of decisions and contrasted with haphazard decision-making. <br><br><h5>  <b>When making technical decisions, it is necessary to consider their action in time and their compliance with business needs.</b> </h5>  One should take into account the impact of this or that decision in both the short and long term, as well as whether this technical solution is useful for business in these periods. <br><br>  This principle is opposed to one-sided decision making with a concentration of results only in the short term, or only in the long term, and without taking into account business needs and taking into account the impact on business of these decisions with concentration solely on the technical advantages of the solution. <br><br><h5>  <b>One of the main criteria for making technical and other decisions should be their greatest effectiveness.</b> </h5>  By efficiency in this matter, I mean the ratio of the value of the result for the business to the amount of expenses required for this. <br><br>  This principle is opposed to an approach that takes into account only the value of the result obtained, regardless of the cost required. <br><br><h5>  <b>Feel free to deviate from the rules, methodologies, patterns and other restrictions, if the effect of such a deviation exceeds the potential loss (although it‚Äôs practical)</b> </h5>  Rules, methodologies, templates and other restrictions are a generalization of previous experience in order to obtain a stable result of activity in certain conditions.  However, in specific cases, conditions may differ, therefore, it is necessary to consciously approach the use of accumulated experience and make its own adjustments if necessary. <br><br>  This principle is opposed to dogmatic adherence to the rules, methodologies, patterns and other accepted restrictions without taking into account the surrounding reality. <br><br><h5>  <b>If necessary, you should make a working, but perhaps not the best, solution right away, and later improve it (Now is better than never, although it is often better than * right * now)</b> </h5>  There are situations in which it is necessary to implement a certain functionality or fix a defect in a short time, while there are alternative solutions: quick and good.  From the quick effect can be obtained immediately, but in the long term, it can create difficulties and lead to additional costs.  A good decision to do is long and costly in the short term, but in the long term it will pay off and bring substantially more benefits than it has required.  In this case, the combination of both solutions will be effective, namely: we are making a quick decision now and routinely make a good decision.  In total, this will turn out to be a bit more expensive than the implementation of only one of the solutions, but the effect of their combination will pay for the costs. <br><br>  This principle is opposed to trying to do everything at once perfectly. <br><br><h5>  <b>If it is difficult to choose between two alternative technical solutions, then you need to choose any and move with it further, when more information appears, then it will be possible to do refactoring if the solution turned out to be non-optimal</b> </h5>  No comments <br><br><h5>  <b>The flexibility of technical solutions is highly desirable, and versatility is not required</b> </h5>  Flexibility is the ability to adapt a technical solution to new conditions that may appear in the future.  Versatility is the actual adaptation of a technical solution to the possibility of using for a set of conditions.  Often, ensuring universality requires more effort than flexibility, since it takes into account the greater number of conditions with which a technical solution must be compatible.  Also, ensuring universality may be ineffective, as it requires adaptation to conditions that have not yet come and may never come.  In addition, sometimes unification requires complex generalizations.  Therefore, the flexibility of technical solutions is highly desirable, and universality is not required. <br><br>  This principle is opposed to an attempt to immediately make universal decisions that later turn out to be unclaimed due to changes in external conditions. <br><br><h4>  <b>Source Code Quality</b> </h4><br><h5>  <b>The quality of the code should be optimized on the basis of a formed system of criteria that is balanced against costs in the short and long term.</b> </h5>  My basic prioritized list of optimization criteria is as follows (if necessary, should be adjusted for specific conditions): <ol><li>  High code readability - the easier it is to understand the code, the better (Readability counts) </li><li>  Low cyclomatic code complexity - the smaller the branches, cycles, conditional operations, function calls and methods, the better (Simple is better than complex. Flat is better than nested) </li><li>  High code flexibility - the easier it is to make changes to the code, the better (this optimization criterion increases development costs in the short run, but reduces them in the long run) </li><li>  Small code size - the smaller the code, the better (Simple is better than complex) </li><li>  Code Execution Performance - the faster the code, the better </li></ol><br>  The prioritization of the criteria is as follows: first, first of all, labor costs are spent on providing criteria with a higher priority;  secondly, if the criteria conflict with each other, then a solution is applied that matches the criterion with a higher priority. <br><br>  This principle is contrasted with the coat optimizing the quality of the code, as well as the use of uncoordinated among the members of the development team optimization criteria and their priorities. <br><br><h5>  <b>Write the optimal code immediately, if it does not increase its complexity and development time (Beautiful is better than ugly)</b> </h5> Sometimes there are several functionally equivalent code constructs, but with different performance.  As a rule, it is enough to find out once which construction has the greatest performance or memory requirements and use it in all similar cases.  However, it should be borne in mind that some such constructions may degrade the readability of the code and increase the development time both at the time of writing the code and with its support and modification in the future.  This should be taken into account in order not to face the disadvantages of premature optimization. <br><br><h5>  <b>Self-documenting code takes precedence over well commented code (Beautiful is better than ugly)</b> </h5>  Sometimes comments help to understand complex code, but at the same time they are an indicator of low code readability.  Therefore, in cases when there is a need to write a comment, you should think about what changes you can make to the code so that the need for comments disappears. <br><br>  Here are typical, in my opinion, cases where you can do without the commentary: <ul><li>  The commentary clarifies the meaning of the data contained in the variables ‚Äî corrects by renaming the variable (similarly applicable to the names of classes, methods, functions, constants, etc.) </li><li>  Selection of a block of code with the help of a comment - corrected by moving the block of code into a separate function or method </li><li>  The embrace of the action performed at the level of the semantics of the language - corrected by deleting the comment (an example of the comment that needs to be deleted: a = 10 # assign 10 to a) </li></ul><br>  Cases where comments should be written: <ul><li>  Public API Documentation </li><li>  Explanation of non-obvious reasons, the choice of alternative technical solutions </li><li>  Explanation of the optimized and, as a result, difficult for understanding code segment </li><li>  TODO and FIXME - micro-planning in the context of source code </li></ul><br>  Comments can not only help, but hinder the development because they require additional writing time, take up space, reduce the number of lines of code that are simultaneously visible on the screen, require synchronization when changing code, take up additional time to read.  Therefore, commenting should be reasonable. <br><br>  This principle is opposed to excessive use of comments. <br><br><h5>  <b>Write TODO and FIXME in code</b> </h5>  Not everything and not always makes sense to do at the time of writing a particular piece of code, especially this concerns refactoring and making changes, the relevance of which is a question.  In such cases, it is reasonable to write a TODO or FIXME comment in code that can be used at a more appropriate time.  It is advisable to immediately assign an approximate priority to this comment in order to simplify planning in the future. <br><br>  This principle is opposed to writing the ideal code without taking into account the real needs and costs of such code at a particular point in time. <br><br><h5>  <b>Give variables, functions, methods, classes and other source code objects names that accurately reflect their purpose, despite the increase in the length of the names (Explicit is better than implicit)</b> </h5>  Saving title length cannot be done at the expense of code clarity. <br><br><h5>  <b>Fewer lines and code size is preferable, while maintaining the same code readability (Simple is better than complex)</b> </h5>  There are studies from which it follows that the number of errors in the code on average is directly proportional to the length of the code and the number of lines of code in particular.  This is explained as follows: firstly, the smaller part of the code is placed simultaneously on the screen, the more effort is required to memorize invisible sections of the code that are currently invisible, and secondly, the longer the code, the more typos can be made in it and other human errors. <br><br><h5>  <b>Apply code review as a tool for detecting errors, leveling development style, getting to know someone else‚Äôs code, and learning in a team</b> </h5>  In addition to its intended purpose, the code inspection is excellent for leveling the style of development, getting to know someone else's code, and training in a team.  In the ideal case, only the code that passed the code inspection should fall into the general branch. <br><br><h5>  <b>Reuse your own and someone else's code</b> </h5>  This principle follows from the DRY-principle.  In order to successfully apply this principle, you must have a good knowledge of the code base, and the application of code inspection by all members of the development team helps in this. <br><br><h5>  <b>Use specialized libraries to solve specific problems, instead of developing their own similar code.</b> </h5>  If you need to solve any problem (for example, send an email via smtp), you should familiarize yourself with the availability of ready-made libraries for this task and explore the possibilities of using them.  Failure to use specialized solutions should be justified, since specialized solutions have several advantages over the new development. <br><br>  Specialized solutions have already been developed and tested.  This means saving time for developing, testing and correcting defects.  Sometimes it seems that it is easier to develop your own code that performs the necessary function, since to use a ready-made solution, it takes time to study and there is a risk that it will be wasted, because it turns out that the solution is not suitable.  However, this impression is often deceiving, firstly, because of the underestimation of the complexity of the task, and secondly, because of the presence of other advantages. <br><br>  The peculiarity of specialized solutions is that they are specifically designed to solve a specific problem.  This means that they take into account features that are difficult to take into account when solving a specific task along with the main one.  It should be understood that in addition to functionality, the solution must also meet non-functional requirements, such as requirements for performance, safety, ease of maintenance, compatibility and others.  All these features require global immersion in the task and, if developed, can be overlooked due to limited time. <br><br>  Often specialized solutions are public and therefore are used by many developers.  This means they have already identified and eliminated the shortcomings that they encountered during practical use.  Thus, specialized solutions allow you to use someone else's experience without additional labor costs. <br><br>  Public specialized solutions often have an open source code.  In fact, these are the majority of libraries in Python.  Such solutions are constantly being developed by the developer community, so it is possible to improve the quality of your software without additional labor costs by updating the versions used. <br><br>  Often, different public solutions are easily integrated with each other (for example, Spyne and SQLAlchemy), which significantly reduce development costs. <br><br>  There are a number of valid reasons for not using a specialized solution.  Examples of such reasons: <ul><li>  The specialized solution lacks the required functionality. </li><li>  A specialized solution is poorly documented, and access to the source code is impossible or limited, or the source code is very difficult to use instead of documentation. </li><li>  A specialized solution contains serious errors and is poorly supported, or there is no access to the source code or the possibility of self-correction of errors. </li><li>  Support for a specialized solution officially discontinued </li><li>  The current needs for the functionality of a specialized solution make up an extremely small fraction of all the functionality embedded in a specialized solution. </li></ul><br><h4>  <b>Performance</b> </h4><br><h5>  <b>Code development performance overrides code execution performance.</b> </h5>  In modern conditions, the cost of human resources is usually higher than the cost of hardware, so for me the code development performance (expressed in terms of the developed functionality per unit of time) takes precedence over the code execution performance. <br><br>  This principle is opposed to premature optimization of code execution performance. <br><br><h5>  <b>Optimization of the performance of code execution should be justified by the corresponding need.</b> </h5>  The reasoning is to formulate performance requirements that are based on the practical or planned scale of the use of the information system, and the subsequent identification of the inconsistency of the information system with these requirements. <br><br>  This principle is opposed to premature optimization of code execution performance. <br><br><h5>  <b>Optimization of code execution performance should be performed by eliminating the most serious bottlenecks.</b> </h5>  To do this, it is necessary to identify bottlenecks, evaluate the contribution of each bottleneck to the decrease in performance and optimize the bottleneck in the first place. <br><br>  This principle is opposed to the coat optimizing the performance of code execution. <br><br><h5>  <b>First of all, the most effective methods for optimizing the performance of code execution should be used.</b> </h5>  The effectiveness of optimization methods is the ratio of the share of productivity gains to the total cost of performing optimization work.  For me, the following prioritized list of optimization methods is basic: <ol><li>  Changing the data processing algorithm (can give an increase in productivity up to several orders of magnitude with relatively low development costs) </li><li>  The increase in hardware power (may give an increase in performance from tens of percent to several dozen times depending on the nature of performance degradation; this method may require making changes to the architecture of the information system to enable scalability) </li><li>  Updating the finished application and system software used in the information system (implies low costs, except in the case of paid software, but this rarely gives a significant performance gain, since application and system software is usually initially optimized) </li><li>  Changing the development language in terms of bottlenecks, or a complete transition to a more productive programming language (high development costs with an increase in productivity from tens of percent to several dozen times depending on the nature of the functionality of the information system and the programming languages ‚Äã‚Äãused) </li></ol><br>  The prioritization of methods is that first of all labor and other resources are spent on using higher priority methods, and the transition to the next method is carried out when optimization opportunities are exhausted, or the efficiency of the less priority method is higher. <br><br>  This principle is opposed to the coat optimizing the performance of code execution. <br><br><h4>  <b>Conclusion</b> </h4>  I deliberately excluded some of the principles from the publication, since they relate more to the management of people, communication between people and the construction of development processes, than directly to the writing of source code.  I simply couldn‚Äôt identify or formulate some principles, since the translation of unintelligible knowledge into conscious knowledge is a rather complicated process.  Therefore, I have high hopes that comments on the article will be no less interesting than the article itself, and will allow me to write a sequel, which will include missing information. </div><p>Source: <a href="https://habr.com/ru/post/233699/">https://habr.com/ru/post/233699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233687/index.html">Ministry of Communications wants to increase the number of programmers in Russia from 350 thousand to 1 million</a></li>
<li><a href="../233689/index.html">Scientists from Stanford have created an application that allows you to eavesdrop on an Android smartphone using a gyroscope</a></li>
<li><a href="../233691/index.html">Autodesk will not sell software to sanctioned companies</a></li>
<li><a href="../233693/index.html">Setting up a Cyclos cluster based on Jelastic Platform-as-Infrastructure</a></li>
<li><a href="../233695/index.html">The implementation of the tag system in the admin with the SonataAdminBundle bundle</a></li>
<li><a href="../233703/index.html">Autodesk tool for displaying 3d models on the web</a></li>
<li><a href="../233705/index.html">Real unit testing in AngularJS</a></li>
<li><a href="../233707/index.html">Linux book selling</a></li>
<li><a href="../233711/index.html">Sly Lamb Company Experience: Adapting an iOS App Design for Windows Phone</a></li>
<li><a href="../233713/index.html">Video of reports from the CodeFest 2014 conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>