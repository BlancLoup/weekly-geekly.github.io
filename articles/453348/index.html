<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's inside asyncio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I suggest the reader make a rather fascinating journey with me into the depths of asyncio with me in order to figure out how it imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's inside asyncio</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I suggest the reader make a <em><strong>rather</strong></em> fascinating journey with me into the depths of <em><strong>asyncio</strong></em> with me in order to figure out how it implements asynchronous code execution.  We will saddle the callbacks and sweep through the cycle of events through a couple of key abstractions right into the corute.  If on your python map there are no these sights yet, welcome under cat. </p><a name="habracut"></a><br><h2 id="dlya-zatravki--kratkaya-spravka-o-raskinuvsheysya-pered-nami-mestnosti">  For starters - a brief reference about the area stretched before us </h2><br><p>  <em><strong>asyncio</strong></em> is an asynchronous I / O library which, according to <a href="https://www.python.org/dev/peps/pep-3153/">pep3153</a> , was created to provide a standardized base for creating asynchronous frameworks.  <a href="https://www.python.org/dev/peps/pep-3156/">pep3156</a> also attributes to it the need to provide extremely simple integration into pre-existing asynchronous frameworks (Twisted, Tornado, Gevent).  As we can see now, these goals were successfully achieved - a new framework based on asyncio appeared: <a href="http">aiohttp</a> , in Tornado <a href="https://www.tornadoweb.org/en/stable/asyncio.html">AsyncioMainLoop</a> is the default event loop from version 5.0, in Twisted <a href="https://twistedmatrix.com/documents/19.2.0/api/twisted.internet.asyncioreactor.html">asyncioreactor</a> is available from version 16.5.0, and for Gevent there is a third-party aiogevent library . </p><br><p>  <em><strong>Asyncio</strong></em> is a hybrid library that uses two approaches at the same time to implement asynchronous code execution: classic on callbacks and, relatively new, (at least for python) on corutines.  It is based on three main abstractions, which are analogues of abstractions that exist in third-party frameworks: </p><br><ul><li>  <strong>Pluggable event loop</strong> <br>  Connected event loop.  A plug-in means that it can be replaced in two lines of code with another one that implements the same interface.  Now there is a cython implementation on top of libuv ( <a href="https://uvloop.readthedocs.io/">uvloop</a> ) <del>  and in Rust ( <a href="https://github.com/PyO3/tokio">asyncio-tokio</a> ) </del>  . </li><li>  <strong>Future</strong> <br>  The result of the operation, which will be available in the future.  It is necessary to get the result of the execution of callbacks in the quiches. </li><li>  <strong>Task</strong> <br>  A special subclass of the Future class for running corutin on an event loop. </li></ul><br><h2 id="poehali">  Go! </h2><br><p>  The cycle of events - the main component of the library, on the roads running through it, the data are delivered to any of its components.  It is large and complex, so first consider its trimmed version. </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py import collections import random class Loop: def __init__(self): #     self.ready = collections.deque() def call_soon(self, callback, *args): #          self.ready.append((callback, args)) def run_until_complete(self, callback, *args): #         self.call_soon(callback, *args) #    -   #       while self.ready: ntodo = len(self.ready) #      #          for _ in range(ntodo): #       #        callback, args = self.ready.popleft() callback(*args) def callback(loop): print('') loop.call_soon(print, '') loop = Loop() loop.run_until_complete(c, loop)</span></span></code> </pre> <br><p>  Having saddled our little callback, we hit the road through <strong>call_soon</strong> , get into the queue and after a brief wait we will be displayed on the screen. </p><br><h4 id="epizod-pro-plohie-kollbeki">  Episode about bad callbacks </h4><br><p>  It is worth mentioning that callbacks are dangerous horses - if they drop you in the middle of the road, the python interpreter will not be able to help you understand where it happened.  If you do not believe, go the same way on the maybe_print <strong>callback</strong> coming to the finish line in about half of the cases. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def maybe_print(msg): if random.randint(0, 1): raise Exception(msg) else: print(msg) def starting_point(loop): #   print('') loop.call_soon(maybe_print, '') def main(loop): loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) loop = Loop() loop.run_until_complete(main, loop)</span></span></code> </pre><br><p>  Below is a full trace run of the previous example.  Due to the fact that the <strong>maybe_print</strong> function was started by an event loop, and not directly from the <strong>starting_point</strong> , the traceback ends exactly on it, in the <strong>run_until_complete</strong> method.  For such a traceback, it is impossible to determine where the <strong>starting_point</strong> is in the code, which will make debugging much more difficult if the <strong>starting_point</strong> is located in several places in the code base. </p><br><pre> <code class="bash hljs">$: python3 base_loop.py &gt;&gt;  <span class="hljs-comment"><span class="hljs-comment">#    &gt;&gt;  #    &gt;&gt;  #    &gt;&gt; Traceback (most recent call last): &gt;&gt; File "base_loop.py", line 42, in &lt;module&gt; &gt;&gt; loop.run_until_complete(main, loop) &gt;&gt; File "base_loop.py", line 17, in run_until_complete &gt;&gt; callback(*args) &gt;&gt; File "base_loop.py", line 29, in maybe_print &gt;&gt; raise Exception(msg) &gt;&gt; Exception:  #    </span></span></code> </pre> <br><p>  A continuous call stack is needed not only to display the full traceback, but also to implement other features of the language.  For example, it is based on exception handling.  The example below will not work, because by the time the <strong>starting_point</strong> starts, the <strong>main</strong> function will already be executed: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): try: loop.call_soon(starting_point, loop) loop.call_soon(starting_point, loop) except: pass Loop().run_until_complete(main, loop)</span></span></code> </pre> <br><p>  The following example does not work either.  The context manager in the <strong>main</strong> function will open and close the file even before its processing is started. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/base_loop.py def main(loop): with open('file.txt', 'rb') as f: loop.call_soon(process_file, f) Loop().run_until_complete(main, loop) #       ,    =(</span></span></code> </pre> <br><p>  The lack of a continuous call stack limits the use of the usual features of the language.  For a partial workaround of this flaw, asyncio had to add a lot of additional code that was not directly related to the task it was solving.  This code, for the most part, is not in the examples - they are quite complex without it. </p><br><h4 id="iz-cikla-sobytiy-vo-vneshniy-mir-i-obratno">  From the cycle of events to the outside world and back </h4><br><p>  The event loop communicates with the outside world through the operating system through events.  Code that knows how to work with it is provided by a module of the standard library called <strong>selectors</strong> .  It allows you to tell the operating system that we are waiting for some event, and then ask if it has happened.  In the example below, the expected event will be the availability of the socket for reading. </p><br><div class="spoiler">  <b class="spoiler_title">Cycle of events</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/event_loop.py import selectors import socket import collections from future import Future from handle import Handle from task import Task class EventLoop: def __init__(self): self.ready = collections.deque() #   self.selector = selectors.DefaultSelector() def add_reader(self, sock, callback): #       # : # , #         #           self.selector.register( sock, socket.EVENT_READ, (self._accept_conn, sock, callback) ) def _accept_conn(self, sock, callback): #    conn, addr = sock.accept() conn.setblocking(False) #      self.selector.register( conn, socket.EVENT_READ, (callback, conn) ) def run_until_complete(self, callback, *args): self.call_soon(callback, *args) #           -  while self.ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self.ready.popleft() callback(*args) #       for key, events in self.selector.select(timeout=0): #          callback, *args = key.data #       self.call_soon(callback, *args) def call_soon(self, callback, *args): self.ready.append((callback, args)) def print_data(conn): print(conn.recv(1000)) def main(loop): #   sock = socket.socket() #     8086  sock.bind(('localhost', 8086)) sock.listen(100) sock.setblocking(False) #      loop.add_reader(sock, print_data) loop = EventLoop() #    loop.run_until_complete(main, loop)</span></span></code> </pre> </div></div><br><p>  The messenger from the outside world leaves his message or package in the selector, and the selector sends it to the recipient.  Now it is possible to read from the socket using the event loop.  If you run this code and connect using netcat, it will faithfully output everything that will be sent to it. </p><br><pre> <code class="bash hljs">$: nc localhost 8086 $: python3 event_loop.py <span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hi there!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Hello!"\n'</span></span> <span class="hljs-string"><span class="hljs-string">"Answer me, please!"</span></span> b<span class="hljs-string"><span class="hljs-string">'"Answer me, please!"\n'</span></span></code> </pre> <br><p>  At the beginning of the article it was said that asyncio is a hybrid library in which the korutins work on top of callbacks.  To implement this functionality, the two remaining main abstractions are used: <strong>Task</strong> and <strong>Future</strong> .  Next, the code of these abstractions will be shown, and then, how, using their event loop, the corutines are executed. </p><br><h4 id="future">  Future </h4><br><p>  Below is the code for the Future class.  It is needed so that in coroutine one could wait until the completion of the callback and get its result. </p><br><div class="spoiler">  <b class="spoiler_title">Future</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future.py import sys from asyncio import events, CancelledError class Future: #        _state = 'PENDING' # FINISHED, CANCELLED #          Future #          _source_traceback = None #            _callbacks = [] #           _exception = None #           _loop = None #     _result = None def __init__(self, loop): self._loop = loop self._source_traceback = events.extract_stack(sys._getframe(1)) def add_done_callback(self, callback): #        self._callbacks.append(callback) def _schedule_callbacks(self): #         for callback in self._callbacks: self._loop.call_soon(callback, self) self._callbacks[:] = [] #            Future #    -     def set_exception(self, exception): #       self._exception = exception #   self._state = 'FINISHED' #      self._schedule_callbacks() def set_result(self, result): #         self._result = result self._state = 'FINISHED' self._schedule_callbacks() def cancel(self): #       self._state = 'CANCELLED' self._schedule_callbacks() def result(self): #     #         if self._state == 'CANCELLED': raise CancelledError #         if self._exception is not None: raise self._exception #    return self._result def __await__(self): #  ,    await #        if self._state == 'PENDING': yield self #     return self.result()</span></span></code> </pre></div></div><br><h4 id="task">  Task </h4><br><p>  This is a special subclass of the <strong>Future</strong> class.  It is needed to run the quorus on the callback event loop. </p><br><div class="spoiler">  <b class="spoiler_title">Task</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/task.py from asyncio import futures from future import Future class Task(Future): def __init__(self, coro, *, loop=None): super().__init__(loop=loop) #    self._coro = coro def _step(self, exc=None): #    ,     try: if exc is None: #        None #        result = self._coro.send(None) else: #        self._coro.throw(exc) except StopIteration: result = None except Exception as exc: self.set_exception(exc) else: #   Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) #     step     elif result is None: self._loop.call_soon(self._step) def _wakeup(self, future): #     Future       Task #   try: future.result() except Exception as exc: self._step(exc) #        Future else: self._step()</span></span></code> </pre> </div></div><br><h4 id="cikl-sobytiy-umeyuschiy-rabotat-s-future">  The cycle of events, able to work with Future </h4><br><div class="spoiler">  <b class="spoiler_title">EventLoop with Futures</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ~/inside_asyncio/future_event_loop.py import selectors from selectors import EVENT_READ, EVENT_WRITE import socket import collections from future import Future from task import Task class EventLoop: def __init__(self): self._ready = collections.deque() self.selector = selectors.DefaultSelector() def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): callback, *args = key.data self.call_soon(callback, *args) def call_soon(self, callback, *args): self._ready.append((callback, args)) #      Future def sock_accept(self, sock, fut=None): #       #  Future     fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: #    #   Future    fut.set_result((conn, address)) self.selector.unregister(sock) return fut def sock_recv(self, sock, n, fut=None): #       #      , #     ,      fut = fut if fut else Future(loop=self) try: data = sock.recv(n) except (BlockingIOError, InterruptedError): self.selector.register( sock, EVENT_READ, (self.sock_recv, sock, n, fut) ) except Exception as exc: fut.set_exception(exc) self.selector.unregister(sock) else: fut.set_result(data) self.selector.unregister(sock) return fut async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    conn, addr = await loop.sock_accept(sock) #     result = await loop.sock_recv(conn, 1000) print(result) loop = EventLoop() #    Task task = Task(coro=main(loop), loop=loop) #         loop.run_until_complete(task._step)</span></span></code> </pre> </div></div><br><h4 id="dvinemsya-dalshe">  Move on </h4><br><p>  Now let's see how <strong>main</strong> corutin will be executed: </p><br><div class="spoiler">  <b class="spoiler_title">Performance</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">__________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): # task._step    self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #     callback(*args) # task._step() ___________________________________________________________________ clsss Task: def _step(self, exc=None): try: if exc is None: #  None   result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): #      #   sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #         conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): #   Future fut = fut if fut else Future(loop=self) try: #     conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): #     #      #   Future    self.selector.register( sock, EVENT_READ, (self.sock_accept, sock, fut) ) except Exception as exc: -------------------------------------------- self.selector.unregister(sock) #  Future   return fut ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __await__  Future conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): #   Future         if self._state == 'PENDING': yield self return self.result() ___________________________________________________________________ class Task(Future): def _step(self, exc=None): try: if exc is None: #           None result = self._coro.send(None) # result = fut -------------------------------- else: #  Future      # wakeup      if isinstance(result, Future): result.add_done_callback(self._wakeup) elif result is None: self._loop.call_soon(self._step) #      -    Task  Future #    #               ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() callback(*args) for key, events in self.selector.select(timeout=0): #    callback, *args = key.data self.call_soon(callback, *args) # loop.sock_accept(sock, fut) ___________________________________________________________________ class EventLoop: def sock_accept(self, sock, fut=None): fut = fut if fut else Future(loop=self) try: #    conn, address = sock.accept() conn.setblocking(False) except (BlockingIOError, InterruptedError): -------------------------------- else: #   Future fut.set_result((conn, address)) self.selector.unregister(sock) return fut ___________________________________________________________________ class Future: def set_result(self, result): #   self._result = result #   self._state = 'FINISHED' #      self._schedule_callbacks() def _schedule_callbacks(self): for callback in self._callbacks: #         task.wakeup self._loop.call_soon(callback, self) # (task.wakeup, fut) self._callbacks[:] = [] ___________________________________________________________________ class EventLoop: def run_until_complete(self, callback, *args): self.call_soon(callback, *args) while self._ready or self.selector.get_map(): ntodo = len(self._ready) for _ in range(ntodo): callback, args = self._ready.popleft() #      #    task.wakeup callback(*args) # task.wakeup(fut) ___________________________________________________________________ class Task(Future): def _wakeup(self, future): try: future.result() except Exception as exc: self._step(exc) else: #   Future      task._step self._step() def _step(self, exc=None): try: if exc is None: #       None result = self._coro.send(None) else: ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #   await   __awai__   conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result) ___________________________________________________________________ class Future: def __await__(self): if self._state == 'PENDING': yield self #   Future    return self.result() ___________________________________________________________________ async def main(loop): sock = socket.socket() sock.bind(('localhost', 8080)) sock.listen(100) sock.setblocking(False) #    Future    conn  addr conn, addr = await loop.sock_accept(sock) result = await loop.sock_recv(conn, 1000) print(result)</code> </pre> </div></div><br><p>  In such a simple way, asyncio performs cortutina. </p><br><h4 id="itogi">  Results </h4><br><p>  The goal of creating asyncio was successfully achieved.  She not only solved the problem of compatibility, but also caused a huge increase in interest in competitive programming in the community.  New articles and libraries began to appear like mushrooms after rain.  In addition, asyncio influenced the language itself: native cortutins and new <strong>async</strong> / <strong>await</strong> keywords were added to it.  The previous time a new keyword was added back in 2003, it was the keyword <strong>yield</strong> . </p><br><p>  One of the goals of creating asyncio was to provide extremely simple integration into pre-existing asynchronous frameworks (Twisted, Tornado, Gevent).  From this goal, the choice of tools follows logically: if there were no compatibility requirement, perhaps the main role would be given to the Corintins.  Due to the fact that when programming on callbacks it is impossible to keep a continuous stack of calls, an additional system had to be created on the border between them and Korutins that would support the capabilities of the language based on it. </p><br><p>  Now the main question.  Why does all this need to be known to a simple library user who follows recommendations from the documentation and uses only Korutin and a high-level API? <br>  Here is a piece of StreamWriter documentation </p><br><p><img src="https://habrastorage.org/webt/td/ou/jb/tdoujbeh0soadfwdveuowwbvvny.png"></p><br><p>  Its copy is returned by the <strong>asyncio.open_connection</strong> function and is the <strong>async</strong> / <strong>await</strong> API over the callback API.  And these callbacks stick out of it.  The <strong>write</strong> and <strong>writelines functions are</strong> synchronous, they try to write to the socket, and if they don‚Äôt, they drop the data into the underlying buffer and add callbacks to the record.  Korutina <strong>drain is</strong> needed in order to ensure that it is possible to wait until the amount of data in the buffer drops to the specified value. </p><br><p>  If you forget to call <strong>drain</strong> between <strong>write</strong> calls, the internal buffer can grow to indecent sizes.  However, if you keep this in mind, a couple of unpleasant moments remain.  The first is that if a callback on the record ‚Äúbreaks‚Äù, then the quorutine using this API will not know about it and, accordingly, will not be able to process it.  Secondly, if the korutin "breaks down", then the callback for recording will not know about it and will continue to write data from the buffer. </p><br><p>  Thus, even using only korutiny, be prepared for the fact that kollbeki remind themselves. </p><br><p>  You can read about how to work with databases from asynchronous code in <a href="http://blog.antidasoftware.com/2019/02/python-async-sql-database.html">this article of</a> our <a href="http://blog.antidasoftware.com/">corporate blog Antida software</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453348/">https://habr.com/ru/post/453348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453336/index.html">CNC Burning Machine Selection Guide</a></li>
<li><a href="../453338/index.html">Rust 1.35.0 release</a></li>
<li><a href="../453340/index.html">Perl 5.30 released</a></li>
<li><a href="../453342/index.html">Myths about remote employees that we destroyed ourselves</a></li>
<li><a href="../453346/index.html">Data Storage and Protection Technologies - Third Day at VMware EMPOWER 2019</a></li>
<li><a href="../45335/index.html">Garant-Park-Telecom (R01.RU) from November 19, 2008 registers domains in .COM, .ORG, .NET, .BIZ, .INFO, etc.</a></li>
<li><a href="../453350/index.html">Open broadcast of the main hall RIT ++ 2019</a></li>
<li><a href="../453352/index.html">How drones in Ghana deliver vital medicines</a></li>
<li><a href="../453354/index.html">The classification of land cover using eo-learn. Part 3</a></li>
<li><a href="../453356/index.html">Modern trends and recommendations for the development of large financial institutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>