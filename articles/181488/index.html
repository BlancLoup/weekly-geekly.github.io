<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimum parallelization of unit tests or 17,000 tests in 4 minutes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about the utility developed by us, which optimizes the testing of PHP code using PHPUnit and TeamCity. At the same time, you need t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimum parallelization of unit tests or 17,000 tests in 4 minutes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d60/278/0d2/d602780d288a8f53a3db7afa236710e9.png" align="left">  Today we will talk about the utility developed by us, which optimizes the testing of PHP code using PHPUnit and TeamCity.  At the same time, you need to understand that our project is not only a website, but also mobile applications, a wap site, a Facebook application, and much more, and development is carried out not only in PHP, but also in C, C ++, HTML5 and etc. <br><br>  The methods we describe perfectly adapt to any language, any testing system and any environment.  Therefore, our experience may be useful not only to developers of web sites in PHP, but also to representatives of other areas of development.  In addition, in the near future we plan to transfer our system to Open Source - without necessarily binding to TeamCity and PHPUnit - surely it will be useful to someone. <br><a name="habracut"></a><br><h4>  Why do you need it? </h4><br>  Unit testing is a mandatory ( <i>we actually believe in it!</i> ) Component of any serious project that dozens of people work on.  And the bigger the project, the more unit tests it has.  The more unit tests, the longer their execution time.  The more time to complete them, the more developers and testers decide to "gently ignore" their launch. <br><br><img src="https://habrastorage.org/storage2/1d5/8d8/4a6/1d58d84a6e7032743d5789c2f90a6fdf.png" align="right">  Naturally, this can not positively affect the quality and speed of testing tasks.  Tests are fully run just before the release, at the last minute, the clarification begins in the spirit of ‚ÄúWhy did this test fall?‚Äù, And often it all comes down to ‚ÄúLet's decompose this way, and then we will fix it!‚Äù.  And it's good if the problem is in the test.  Much worse if it is in the test code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>The best way</b> out of this situation is <b>to reduce the test time</b> .  But how?  When testing each task, it is possible to run only tests covering the code affected by it.  But even this is unlikely to give a 100% guarantee that everything is in order: after all, in a project consisting of many thousands of classes, it is sometimes difficult to trace the subtle connection between them ( <i>unit tests, if you believe the books, NEVER should go beyond the tested class, or even better, the test method. But have you seen many such tests?</i> ).  Therefore, it is necessary to run ALL tests in parallel, in several threads. <br><br>  <b>The simplest solution for non</b> - <b>lazy people</b> is, for example, to manually create several PHPUnit XML configuration files and run them as separate processes.  But it will be enough for a short time: the constant support of these configs will be needed and the likelihood of missing a test or a whole package will increase, and the execution time will be far from optimal. <br><br><img src="https://habrastorage.org/storage2/5fa/b17/9f0/5fab179f0a8475afb47bea0a8d3e1a2b.png" align="right">  <b>The easiest solution for the lazy</b> is to write a simple script that will divide the tests equally between the threads.  But at some point it will exhaust itself, because the number of tests is constantly growing, they all work at different speeds, from which there is a difference in the execution time among the threads.  Consequently, we need more effective and controlled methods of dealing with them. <br><br>  <b>Conclusion</b> : we need an easy-to-manage system that will automatically and uniformly distribute the tests across threads and independently control the code coverage of the tests. <br><br><h4>  Search </h4><br>  Since PHPUnit is a very common system, we thought that probably someone had already done something like this, and we began to search. <br><br>  The first results did not disappoint: there were many solutions of different degrees of readiness and level of functionality.  These were bash scripts, PHP scripts, wrappers around PHPUnit, and even quite complex and sweeping patches for the system itself.  We started trying some of them, digging through the code, trying to adapt to our project and faced with a huge amount of problems, ambiguities and logical errors.  It was surprising: is there still no one hundred percent proven solution? <br><br>  Most of the options were built on one of two schemes: <br><br><ul><li>  We are looking for all the necessary files and divide them equally between the threads; </li><li>  We run a number of threads, which sequentially process the common test queue and ‚Äúfeed‚Äù them with PHPUnit. </li></ul><br>  The disadvantage of the first method is obvious: the tests are not distributed in an optimal way, which, of course, increases their speed, but often some thread runs 3-4 times longer than the others. <br><br>  The disadvantage of the second method is no longer so obvious and is connected with interesting features of the internal structure of PHPUnit.  First, every start of the PHPUnit process is mated with a variety of actions: emulation of the test environment, collection of information on the number and structure of test classes, and so on.  Secondly, when running a large number of tests, PHPUnit collects all data providers for all tests in a tricky and smart way, minimizing the number of calls to disks and databases ( <i>again: there are no very, very correct unit tests!</i> ), But this is an advantage it is lost if one issues tests to the system one by one.  In our case, this method caused a huge amount of unexplained errors in the tests, catching and repeating which was incredibly difficult, because each time you start, the sequence of tests almost always changed. <br><br><img src="https://habrastorage.org/storage2/fda/be1/ae5/fdabe1ae593c3086bb32875e91a63aea.png" align="left">  We also found information that PHPUnit developers want to implement support for multi-threading "out of the box."  But the problem is that these promises have been for more than one year, comments on the development of the project are stingy and there are no even approximate forecasts, so it‚Äôs too early to count on this decision. <br><br>  Having spent several days studying all of these options, we came to the conclusion that not one of them solves the problem we have completely set and we need to write something of our own, as much as possible adapted to the realities of our project. <br><br><h4>  Flour of creativity </h4><br>  The very first idea lay on the surface.  We determined that most of the test classes work for approximately the same time, but there are those that run tens or hundreds of times longer.  Therefore, we decided to separate these two types of tests (by <i>determining these ‚Äúslow‚Äù tests on our own</i> ) and drive them away from each other.  For example, all the ‚Äúfast‚Äù tests are carried out in the first five streams, and all the ‚Äúslow‚Äù tests - in the other three.  The result turned out to be quite good, with the same number of streams, the tests passed approximately twice as fast as with the double-stream option, but the variation in the operation time of different streams was still quite noticeable.  Therefore, it is necessary to collect information on test runtime in order to distribute them as evenly as possible. <br><br>  The next thought that came to our mind was to save the test runtime after each run, and then use this information for the subsequent combination.  However, this idea also had flaws.  For example, in order for statistics to be accessible from everywhere, it had to be stored in an external repository ‚Äî for example, a database.  Hence, there are two problems: firstly, a tangible time for performing this operation, secondly, there would be conflicts when several users access this repository at the same time (of <i>course, they are solved using transactions, locks, etc., but we do all this for speed, and any conflict resolution slows down the process</i> ).  It would be possible to save data on some special condition or with a certain frequency, but these are all exclusively ‚Äúcrutches‚Äù. <br><br><img src="https://habrastorage.org/storage2/d5c/1d4/2cb/d5c1d42cba6f1e8706610ad822c71d83.jpg" align="left">  It followed from this that it was necessary to collect statistics in a certain isolated place, where everyone would turn only for reading, and the recording would be made by something separate.  It was at this moment that we remembered TeamCity, but about this a bit later. <br><br>  There is one more problem: the test runtime can always fluctuate both locally - for example, when the server performance drops dramatically, or globally - when the server load increases or decreases ( <i>we run tests on the same machines that are being developed and run the developer of any resource-intensive script noticeably affects the test run time</i> ).  This means that in order to maximally update the statistics, it needs to be accumulated and the average value used. <br><br>  How to configure this utility?  At the first implementation, all control was carried out by command line parameters.  That is, we ran the utility with parameters for PHPUnit, and it passed them to the processes being run and added its own ‚Äî for example, the complete list of tests run ( <i>and the amazing PHPUnit startup lines were thousands of characters long</i> ).  It is clear that this is inconvenient, makes you once again think about the transmitted parameters and contributes to the appearance of new errors.  After a lot of experiments, the simplest solution finally came: you can use standard PHPUnit XML configuration files, changing the settings in them and adding a few of your own XML tags to the structure.  Thus, using these configuration files, it will be possible to run both pure PHPUnit and our utility with the same result ( <i>not taking into account, of course, the increase in speed in our case</i> ). <br><br><h4>  Decision </h4><br>  So, after many hours of planning, developing, searching for serious bugs and catching minor ones, we came to the system that works now. <br><br>  Our Multithread Launcher (or, as we affectionately call it, ‚Äúlauncher‚Äù) consists of three isolated classes: <br><br><ul><li>  Class for collecting and saving statistics on test execution time; </li><li>  Class for obtaining these statistics and uniform distribution of tests; </li><li>  Class for generating PHPUnit configuration files and running its processes. </li></ul><br><br>  <b>The first class</b> works with TeamCity.  She regularly runs a build that, among other things, runs absolutely all tests, and then turns on our statistics collector.  This cooperation has both advantages and disadvantages.  On the one hand, TeamCity itself collects statistics on all running tests, on the other hand, the TeamCity API does not provide any means to work with this information ( <i>neither native nor even more advanced REST API</i> ), so we have to contact the database directly. she works. <br><br>  Here we have a little problem.  Our initial architecture provided a file with a test class as a unit of information for uniform distribution of tests across threads ( <i>since this is the most natural method for PHPUnit configuration files</i> ).  And TeamCity keeps statistics on individual tests, without linking them to the files.  Therefore, our collector reads test statistics from the database, relates tests to classes, classes to files, and stores the statistics already in this form. <br><br><img src="https://habrastorage.org/storage2/faf/eb4/613/fafeb4613f0ac1a86ee9389a71f19ab0.png"><br><br>  This may seem to be quite resource-intensive, but we wrote a simple system for caching matches "class =&gt; file", and hard work is done by the collector only in the case of the emergence of new classes, and their number at each launch is not so large. <br><br><img src="https://habrastorage.org/storage2/6de/c33/d3f/6dec33d3f1bfba6c6f558d646bdff439.png" align="right">  Statistics is stored in its own database in seven copies - for the last seven days.  Every day it is collected again, but when distributing files, data for the past week is used, and the newer the statistics, the higher its ‚Äúweight‚Äù when calculating the average time.  Thus, a single increase in test runtime does not have a significant effect on the statistics, and permanent changes are taken into account fairly quickly. <br><br>  <b>The second class</b> generates file lists for each stream as simple as possible.  It receives information from the database, sorts all files by runtime from the largest to the smallest, and distributes them according to the stream according to the principle ‚Äúevery next file is in the most free stream‚Äù.  Due to the fact that there are a lot of tests, and much more small ones than large ones, the expected operation time of all the threads differs only by a couple of seconds (the <i>real one, of course, is somewhat longer, but the difference is still not too significant</i> ). <br>  In the picture on the right, the bars are the streams, each ‚Äúbrick‚Äù is a separate test, the height of which is proportional to the passage time. <br><br>  <b>The third class</b> is engaged in the most interesting.  In the main mode, it accepts the standard PHPUnit configuration file, in which test directories and specific files are specified.  It is possible to mark the test as ‚Äúslow‚Äù ( <i>the running time of some tests <i>strongly</i> depends on external factors and should be carried out separately from the others</i> ) and ‚Äúisolated‚Äù ( <i>such tests are run in separate threads after all the others have completed</i> ).  Then the start-up generates its own PHPUnit config with all the necessary parameters like the required TestListener, and the test suites are lists of files to run in each stream.  Accordingly, after that it is enough to just run several PHPUnit processes with this config and an indication of the required test suite.  In addition to the main mode, there are opportunities for debugging tests: running with the latest or any other generated config, with the standard TestListener PHPUnit instead of ours, running the tests in a different order, etc. <br><br>  Speaking of our TestListeners ( <i>this is the standard PHPUnit interface used to display information about the tests performed</i> ).  Initially, the start-up displayed the information in the same form as PHPUnit by default.  But for more convenience, we wrote our own Listener, which allowed us to make the information more compact and readable, and also added new features such as STDOUT and STDERR. <br><br>  Plus, we have TestListener for displaying information in TeamCity in the form in which it expects it ( <i>so scary that the weight of the text report on one launch eventually reaches five megabytes</i> ). <br><br><img src="https://habrastorage.org/storage2/d75/1e2/22c/d751e222c931458ae0776ae48f192ee7.png"><br><br><h4>  Results </h4><br>  Now a few numbers. <br>  We carry out more than 17 thousand tests in 8 streams ( <i>plus three additional tests for ‚Äúslow‚Äù tests, which in a normal situation pass all together in a minute</i> ). <br>  In the best case ( <i>with the standard load of test servers</i> ), tests using the start-up pass in 3.5-4 minutes versus 40-50 minutes in one stream and 8-15 minutes in the distribution equally. <br>  When heavily loaded servers start-up quickly adapts to the situation and work out for 8-10 minutes.  When the tests were distributed equally, they worked for at least 20-25 minutes ... And we never even waited until the tests were completed in one stream. <br><br><img src="https://habrastorage.org/storage2/971/449/4e8/9714494e8b59c85b3e34c560dd6ee7b9.png"><br><br>  As a result, we got a system that independently adapts to changes in server load due to statistics received from TeamCity, automatically distributes tests across threads and is easily managed and configured. <br><br>  What gave us such an acceleration of test execution? <br><ul><li>  First, we increased the speed of testing tasks. </li><li>  Secondly, due to the frequent running of tests, the probability of catching fatal errors during the mass merge of task branches to the release branch significantly decreased. </li><li>  Thirdly, the TeamCity agents were significantly unloaded: tests are not run in a single build, and now they actually have free time for special tasks from QA engineers. </li><li>  Fourthly, it became possible to realize the automatic launch of tests when sending a task for testing, so the tester has some information about the performance of the task code when it is received. </li></ul><br><h4>  What's next? </h4><br>  We still have a lot of ideas and plans on how to improve the system.  There are several known problems: sometimes there are difficulties with the isolation of tests left over from the single-threaded launch, while launching cannot be transferred to another project with one click - so the field for work ahead is still very, very large, although the system has achieved quite impressive results now. <br><br>  In the near future (very much look forward to June), a total refactoring and revision of the system will be carried out so that it can be turned into an Open Source project. <br><br>  Utilities will also be built into the start-up, which will allow one test to be divided into several streams containing a large number of data providers, will be able to look for tests that break the environment and determine commits that broke one test or another, etc. <br><br>  In addition, the system architecture will change, so that developers have the opportunity to untie the TeamCity launch and tie it, for example, to Jenkins, or work exclusively locally without any problems. <br><br>  I do not want to say that our Multithread Launcher is some kind of revolution or new word in test automation, but in our project it showed itself from the best side and, even despite some shortcomings, it works much more efficiently than all other publicly available solutions. <br><br>  Ilya Kudinov, QA Engineer. </div><p>Source: <a href="https://habr.com/ru/post/181488/">https://habr.com/ru/post/181488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181472/index.html">How to build a cloud infrastructure from a designer</a></li>
<li><a href="../181474/index.html">Semantic Forms for MediaWiki</a></li>
<li><a href="../181476/index.html">The cost of upgrading the satellite system has increased 2.5 times</a></li>
<li><a href="../181478/index.html">There is a set of future leaders of Computer Science in AU and CSC</a></li>
<li><a href="../181486/index.html">Installing Debian Wheezy on Buffalo Linkstation Pro</a></li>
<li><a href="../181490/index.html">Investigation of the Slovak spam campaign</a></li>
<li><a href="../181494/index.html">Overview of the new Violin - flash storage system operating at a speed close to DRAM</a></li>
<li><a href="../181496/index.html">Overview of the smartphone on Android, which works for a week! Highscreen boost</a></li>
<li><a href="../181498/index.html">How we studied project management in the mountains</a></li>
<li><a href="../181502/index.html">Mobile art trends on the example of top-grossing games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>