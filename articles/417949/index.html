<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary of the previous parts 
 Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="We continue the adventure." width="300" height="350" align="left"><h3>  Summary of the previous parts </h3><br>  Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a desire to write our own implementation of the C ++ 11 standard library on top of the C ++ 98 / C ++ 03 library supplied with the compiler. <br><br>  Were implemented <b>static_assert</b> , <b>noexcept</b> , <b>countof</b> , as well as, after considering all the non-standard defines and features of the compilers, there was information about the functionality that is supported by the current compiler.  Included is its own implementation of <b>nullptr</b> , which is selected at compile time. <br><br>  The time has come for <b>type_traits</b> and all this ‚Äúspecial patterned magic‚Äù.  In the first part, we looked at my implementation of the simplest templates of the standard library, but now we will climb "deeper" into the templates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Link to GitHub with the result today for the impatient and non-readers: <br><br><blockquote>  <b><a href="https://github.com/oktonion/stdex">Commits and constructive criticism are welcome</a></b> </blockquote><br>  Continued immersion in the world of "template magic" C ++. <br><a name="habracut"></a><br><h4>  Table of contents </h4><br>  <a href="https://habr.com/post/417027/">Introduction</a> <br>  <a href="https://habr.com/post/417027/">Chapter 1. Viam supervadet vadens</a> <br>  <a href="https://habr.com/post/417099/">Chapter 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://habr.com/post/417295/">Chapter 3. Finding the perfect implementation of nullptr</a> <br>  <a href="https://habr.com/post/417547/">Chapter 4. C ++ Template "Magic"</a> <br>  .... <a href="https://habr.com/post/417547/">4.1 Starting small</a> <br>  .... <b>4.2 How many we get wonderful errors are compiled by the log</b> <br>  .... <a href="https://habr.com/post/418347/">4.3 Pointers and all-all-all</a> <br>  .... <a href="https://habr.com/post/420365/">4.4 What else is needed for the template library</a> <br>  Chapter 5 <br>  ... <br><br><h3>  Chapter 4. C ++ Template "Magic".  Continuation </h3><br><h4>  4.2 How many marvelous errors to us are prepared by compilations of the log </h4><br>  In the <a href="https://habr.com/post/417547/">first part of</a> this chapter, the basic <b>type_traits</b> templates were introduced, but a few more were missing for the complete set. <br><br>  For example, the <i>is_integral</i> and <i>is_floating_point templates</i> , which are actually very trivial defined, were simply necessary - through the template specialization for each built-in type.  The question here only arose with "big" types of <b>long long</b> .  The fact is that this type as built-in appears in the C ++ standard only from version 11.  And it would be logical to assume that it all comes down to checking the version of the C ++ standard (which <a href="https://habr.com/post/417099/">is definitely difficult to determine</a> ), but it was not there. <br><br><img src="https://habrastorage.org/webt/dx/16/xq/dx16xqz_rvfqcoffnocx80dae_w.jpeg" alt="image" width="320" height="190" align="left">  Because since 1999 there is a standard for the C language C99, in which the types <b>long long int</b> and <b>unsigned long long int were</b> already present (since 1999!), And since the C ++ language sought to maintain backward compatibility with pure C, many compilers (which were usually mixed C / C ++) just added it as a fundamental type even before the release of even the standard C ++ 03.  That is, it turned out that the built-in type is in fact (from C), but it is not described in the C ++ standard and should not be there.  And this brings a little more confusion to the implementation of the standard library.  But let's look at the code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;float&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;long double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> detail::_is_floating_point&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_cv&lt;_Tp&gt;::type&gt; { };</code> </pre> <br>  With the code above, everything is clear - we specialize the template into the necessary types with a floating point, and, after ‚Äúcleaning‚Äù from type modifiers, we say ‚Äúyes‚Äù or ‚Äúno‚Äù to the type transferred to us.  Next in line are the integer types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;bool&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;wchar_t&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned short int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned long int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> LLONG_MAX template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; struct _is_integral_impl&lt;unsigned long long int&gt; : public true_type {}; #endif template&lt;&gt; struct _is_integral_impl&lt;signed char&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;short int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;long int&gt; : public true_type {}; #ifdef LLONG_MAX template&lt;&gt; struct _is_integral_impl&lt;long long int&gt; : public true_type {}; #endif template &lt;class _Tp&gt; struct _is_integral : public _is_integral_impl&lt;_Tp&gt; {}; template&lt;&gt; struct _is_integral&lt;char16_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;char32_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;int64_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;uint64_t&gt; : public true_type {}; } template &lt;class _Tp&gt; struct is_integral : public detail::_is_integral&lt;typename remove_cv&lt;_Tp&gt;::type&gt; { };</span></span></span></span></code> </pre><br>  Here it is necessary to stop and think a little.  For ‚Äúold‚Äù integer types like <b>int</b> , <b>bool</b> , etc.  we do the same specialization as <i>is_floating_point</i> .  For the ‚Äúnew‚Äù types of <b>long long int</b> and its unsigned counterpart, we define overloads only when there is a define <b>LLONG_MAX</b> , which was defined in C ++ 11 (as the first C ++ standard that is compatible with C99), and should be defined in the <b>climits</b> header file as maximum a large number that fits in a <b>long long int</b> object.  There are also a few macro definitions in <b>climits</b> (for the minimum possible number and unsigned equivalents), but I decided to use this macro, which is not important.  The important thing is that, unlike boost, in this implementation the ‚Äúbig‚Äù types from C will not be defined as integer constants, although they are (possibly) present in the compiler.  What else is important is the types <b>char16_t</b> and <b>char32_t</b> , which were also introduced in C ++ 11, but they were not delivered in C99 (they appeared simultaneously with C ++ in C standard C11), and therefore in old standards their definition to be only through a type alias (for example, <b>typedef</b> <i>short char16_t</i> , but more on that later).  If so, then in order for the template specialization to handle situations correctly and when these types are separate (built-in) and when they are defined via <b>typedef</b> , another layer of the <i>detail</i> specialization is required for the <i>detail :: _ is_integral</i> . <br><br><blockquote>  The interesting fact is that in some older compilers, these C-shnye "big" types are not an <a href="http://eel.is/c%2B%2Bdraft/expr.const">integral constant</a> .  What can be understood and even forgive, since these types are non-standard for C ++ up to 11 standards, and generally they should not be there.  But what is difficult to understand is that these types in the newest C ++ creative compiler Embarcadero (Embarcadero C ++ Builder), which C ++ 11 supposedly supports, are still not an <b>integral constant</b> in their 32-bit builds (like 20 years ago , then it was Borland still true).  Apparently because of this, including, most of the standard C ++ 11 library is missing in these 32-bit assemblies (#include the ratio? Chrono? You <a href="https://community.embarcadero.com/forum/programming/9250-chrono-header-missing-c-builder-seattle%3F">will</a> manage).  Embarcadero seems to have decided to force the onset of the 64-bit era with the motto: ‚ÄúDo you want a C ++ 11 or newer standard?  Build a 64-bit program (and only clang, our compiler cannot)! ‚Äù. <br></blockquote><br>  Having finished the proceedings with the fundamental types of the language, we introduce some more simple patterns: <br><br><div class="spoiler">  <b class="spoiler_title">Simple templates</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">detail</span></span></span><span class="hljs-class">:</span></span>:void_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">&lt;true, _Tp&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class">&lt;_Tp, _Tp&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type<span class="hljs-comment"><span class="hljs-comment">//specialization { }; template &lt;class _Tp&gt; struct is_const : public false_type { }; template &lt;class _Tp&gt; struct is_const&lt;const _Tp&gt; : public true_type { }; template &lt;class _Tp&gt; struct is_const&lt;const volatile _Tp&gt; : public true_type { }; /// is_volatile template&lt;class&gt; struct is_volatile : public false_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;volatile _Tp&gt; : public true_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;const volatile _Tp&gt; : public true_type { };</span></span></code> </pre><br></div></div><br>  It deserves attention unless the fact that templates specialize for all type <b>modifiers</b> ( <b>volatile</b> and <b>const volatile</b> for example), since  some compilers tend to ‚Äúlose‚Äù one of the modifiers when a template is opened. <br><br>  Separately, I highlight the implementation of <i>is_signed</i> and <i>is_unsigned</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sign_unsign_chooser</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signed_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cat_base</span></span></span><span class="hljs-class"> :</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, Val&gt; { <span class="hljs-comment"><span class="hljs-comment">// base class for type predicates }; template&lt;&gt; struct _sign_unsign_chooser&lt;true&gt;//integral { template&lt;class _Tp&gt; struct _signed : public _cat_base&lt;_signed_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public _cat_base&lt;_unsigned_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; }; template&lt;&gt; struct _sign_unsign_chooser&lt;false&gt;//floating point { template&lt;class _Tp&gt; struct _signed : public is_floating_point&lt;_Tp&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public false_type { }; }; } template&lt;class T&gt; struct is_signed { // determine whether T is a signed type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _signed&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_signed::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; template&lt;class T&gt; struct is_unsigned { // determine whether T is an unsigned type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _unsigned&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_unsigned::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br>  When implementing this part, I entered into an unequal fight with Borland C ++ Builder 6.0, which did not want to make these two templates the successors of <i>integral_constant</i> , which in the end, after dozens of internal compiler error, resulted in an ‚Äúimitation‚Äù of the <i>integral_constant</i> behavior for these templates.  Here, it may be worthwhile to still struggle and come up with some kind of clever derivation of the type <i>is_ * un * signed: integral_constant</i> through templates, but for the time being I have postponed this task as not a priority.  Interestingly, in the above code section, it is determined at compile time that the type is unsigned / signed.  To begin with, all non-integer types are <i>thrown</i> away and for them the template goes into a separate specialized <i>_sign_unsign_chooser</i> branch with the template argument <b>false</b> , which in turn always returns <i>value ==</i> <b>false</b> for any types except standard floating point types (they are always signed for obvious reasons, so <i>_signed :: value</i> will be <b>true</b> ).  For integer types, simple but so interesting checks are performed.  Here we use the fact that for unsigned integer types, with decreasing and subsequent ‚Äúpassing‚Äù through a minimum (0 obviously) an overflow occurs and the number acquires its maximum possible value. <br><br>  This fact is well known, as well as the fact that for sign types overflow <a href="https://kristerw.blogspot.com/2016/02/how-undefined-signed-overflow-enables.html">is undefined behavior</a> and you need to follow this (according to the standard, you cannot reduce the <b>int</b> variable less than <b>INT_MIN</b> and hope that as a result of the overflow you will get <b>INT_MAX</b> , not 42 or formatted hard disk ). <br><br>  We write <i>_Tp (-1) &lt;_Tp (0)</i> to check for ‚Äúsignedness‚Äù of the type using this fact, then for unsigned types, -1 is ‚Äútransformed‚Äù through overflow to the maximum number of this type, whereas for sign-based ones, the comparison will be made without overflow, and will be compared to -1 with 0. <br><br>  And the last one for today, but not the last ‚Äútrick‚Äù in my library is the implementation of the <i>alignment_of</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_trick</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; _Tp t; _alignment_of_trick(); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A &lt; S ? A : S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;A, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;0, S&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> _MSC_VER &gt; 1400 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// // With MSVC both the build in __alignof operator // and following logic gets things wrong from time to time // Using a combination of the two seems to make the most of a bad job: // static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), __alignof(_Tp) &gt;::value); #else static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), sizeof(_Tp) &gt;::value); #endif typedef integral_constant&lt;std::size_t, std::size_t(_alignment_of_impl::value)&gt; type; private: typedef intern::type_traits_asserts check; typedef typename check::alignment_of_type_can_not_be_zero_assert&lt; _alignment_of_impl::value != 0 &gt;:: alignment_of_type_can_not_be_zero_assert_failed check1; // if you are there means aligment of type passed can not be calculated or compiler can not handle this situation (sorry, nothing can be done there) }; // borland compilers seem to be unable to handle long double correctly, so this will do the trick: struct _long_double_wrapper{ long double value; }; } template &lt;class _Tp&gt; struct alignment_of: public detail::_alignment_of_impl&lt;_Tp&gt;::type {}; template &lt;class _Tp&gt; struct alignment_of&lt;_Tp&amp;&gt;: public alignment_of&lt;_Tp*&gt; {}; template&lt;&gt; struct alignment_of&lt;long double&gt;: public alignment_of&lt;detail::_long_double_wrapper&gt; {};</span></span></span></span></code> </pre><br><blockquote>  Here Microsoft again excelled with their Visual Studio, which even with a built-in nonstandard <b>__alignof</b> build-in macro still produces incorrect results when using it. <br><br><div class="spoiler">  <b class="spoiler_title">Explanation from boost</b> <div class="spoiler_text">  Visual C ++ users should not note that MSVC has varying definitions of "alignment".  For example consider the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>; assert(boost::alignment_of&lt;<span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>&gt;::value % <span class="hljs-number"><span class="hljs-number">8</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a1; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a1 % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  In this code, even though the boost has been set up, it can be a 32-bit build because it is not aligned with the 8-byte alignment.  Note that we used the MSVC intrinsic __alignof in place of the boost :: we would still get the same result.  In fact, for MSVC alignment requirements and <br></div></div><br></blockquote><br>  Let me remind you what the <i>std :: alignment_of</i> template should do - return a value that represents the requirements for placing an element of this type in memory.  If we digress a little, then an element of each type has some kind of memory allocation, and if it is continuous for the array of elements, then, for example, classes may well have ‚Äúholes‚Äù between the class members ( <b>sizeof of the</b> class <b>struct</b> <i>{</i> <b>char</b> <i>a;}</i> is most likely not equal to 1, although there is 1 byte of everything inside, since the compiler aligns it to 1 + 3 bytes in the optimization process). <br><br>  And now let's look at the code again.  <i>Let's</i> declare the <i>_alignment_of_trick</i> structure, in which we will place an ‚Äúindent‚Äù from the memory of 1 byte element of the type being checked.  And check the alignment simply by subtracting the size of the type being checked from the size of the resulting structure.  In other words, if the compiler decides to ‚Äúinsert‚Äù the empty space between the element of the type being checked and the previous <b>char</b> , we will get the type alignment value in the structure. <br><br>  Also here, static assert is first encountered as a type.  They are declared as: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> intern { <span class="hljs-comment"><span class="hljs-comment">// since we have no static_assert in pre-C++11 we just compile-time assert this way: struct type_traits_asserts { template&lt;bool&gt; struct make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct not_allowed_arithmetic_type_assert; template&lt;bool&gt; struct alignment_of_type_can_not_be_zero_assert; }; template&lt;&gt; struct type_traits_asserts::make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::not_allowed_arithmetic_type_assert&lt;true&gt; { typedef bool not_allowed_arithmetic_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::alignment_of_type_can_not_be_zero_assert&lt;true&gt; { typedef bool alignment_of_type_can_not_be_zero_assert_failed; }; }</span></span></code> </pre><br>  In fact, these specialized templates are needed to replace the <b>static_assert</b> from C ++ 11, which is located inside the class definition.  Such assert are more lightweight and highly specialized than the general implementation of <b>STATIC_ASSERT</b> from <a href="https://habr.com/post/417099/">chapter 2</a> , and allow you not to pull the header file <b>core.h</b> into <b>type_traits</b> . <br><br><img src="https://habrastorage.org/webt/ky/ra/ey/kyraeyyd384lkegmbcap1xfwday.jpeg" alt="image" width="330" height="200" align="left">  Many templates?  Will be even more!  We‚Äôll stop on this for now, as the exciting story about combining template programming with the SFINAE technique will continue, as well as why I had to write a small code generator. <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/417949/">https://habr.com/ru/post/417949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417939/index.html">Optimizing the rendering of scenes from the Disney cartoon "Moana". Parts 4 and 5</a></li>
<li><a href="../417941/index.html">Where does the water in the kettle go?</a></li>
<li><a href="../417943/index.html">Serverless and React 2: sleight of hand and no fraud</a></li>
<li><a href="../417945/index.html">What tools does the Parker sun probe have?</a></li>
<li><a href="../417947/index.html">Data visualization for your web project</a></li>
<li><a href="../417951/index.html">Writing Java Friendly Kotlin Code</a></li>
<li><a href="../417953/index.html">Trends in FPGA Design. Transfer</a></li>
<li><a href="../417955/index.html">How to become an interface designer. Necessary skills and powerful tools that we are not told about</a></li>
<li><a href="../417957/index.html">Open webinar "Linux containerization mechanisms"</a></li>
<li><a href="../417959/index.html">10 interface design tips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>