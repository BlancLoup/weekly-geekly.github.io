<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The theory of "broken" warnings</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="" The theory of" broken "warnings " is a fictitious theory that claims that the team connives with respect to minor warnings, such as "inconsistency w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The theory of "broken" warnings</h1><div class="post__text post__text-html js-mediator-article">  " <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D1%2582%25D1%258B%25D1%2585_%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD">The theory of" broken "warnings</a> " is a fictitious theory that claims that the team connives with respect to minor warnings, such as "inconsistency with or without a sign", "operator before comma has no result", "non-standard extension used", etc. ., directly provokes developers to condone to similar or more serious warnings.  The psychological mechanism of such provocation at the household level is illustrated by the phrase: ‚ÄúIf others can, then why can't I?‚Äù - when the programmer sees that the warnings in the code of other developers are not repaired, he ceases to read the rules (and not only those whose violations he observed, but also any others) obligatory for myself.  At the same time, the conditional average level of the ‚Äúpermissible warning‚Äù in the team is constantly decreasing, sooner or later leading to an increase in the number of already serious bugs. <br><br>  Conversely, active work to prevent minor (even the most insignificant) warnings in the code and punish the authors of this code (the so-called zero tolerance) creates an atmosphere of intolerance for warnings in general, and the activity on suppressing minor warnings allows ‚Äúsimultaneously‚Äù to train and significantly limit in the possibilities of recidivists, usually neglecting the rules of the team. <br><a name="habracut"></a><br>  The preliminary version of <a href="https://blogs.msdn.microsoft.com/visualstudio/2017/12/07/visual-studio-2017-version-15-6-preview/">Visual Studio 2017 15.6 Preview 1</a> provides developers with tools to improve the quality of the code and cleanse it of warnings. <br><br><h2>  Description of the problem </h2><br>  Brushing jokes aside, it should be noted that not all warnings were created equal: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Some are accurate </li><li>  Others - by efficiency </li><li>  Third - relevance </li><li>  Fourth - high detection rate </li><li>  Fifth - low impact on existing code bases </li></ul><br>  Alas, almost no warning has all five characteristics at once.  Any diagnostics combines some of the features from this list, which gives rise to endless discussions about which problems you should notify the programmer, and which ones - no.  Of course, different criteria are used in different development teams, and compiler developers are trying to create an extended classification of diagnostics in order to cater to all these criteria.  Clang and GCC try to make a more subtle differentiation of warnings, combining them into families, and MSVC uses a coarser division into warning severity levels. <br><br>  In our survey on diagnostics improvement ( <a href="https://www.surveymonkey.com/results/SM-SNC5TMSN/">Diagnostics Improvements Survey</a> ), 15% of the 270 respondents stated that they collect code with the <i>/ Wall / WX</i> keys, which indicates their zero tolerance for any warnings.  Another 12% said they run the build with the <i>/ Wall</i> option, which includes the <i>/ W4</i> level plus all disabled warnings.  Another 30% collect code at the <i>/ W4</i> level.  These three non-overlapping groups make up 57% of users who approach code quality more strictly than provided by the default settings of Visual Studio (level <i>/ W3</i> ) or the compiler itself (level <i>/ W1</i> ).  The division of warnings into levels is to some extent arbitrary and in no way reflects our own approaches.  For example, the MSVC library team diligently cleans up code at the <i>/ W4</i> level. <br><br>  Despite the lack of consensus on what sets of warnings the developer should see, everyone agrees that, whatever set is adopted in a particular project, there should not be a single active warning at the end: they must all be either corrected or depressed.  On the one hand, with this approach, every new warning serves as a <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B3_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BB%25D0%25B8%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">threshold for distinguishing</a> from the notorious <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2592%25D0%25B5%25D0%25B1%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%25A4%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0">Weber-Fechner law</a> , and on the other hand, it is necessary in the cross-platform code, since the warnings issued to such code on one platform / compiler often turn into errors and more serious failures on the other, which has already been repeatedly <a href="https://www.bignerdranch.com/blog/a-bit-on-warnings/">reported</a> .  Zero tolerance for warnings is easy to graft with respect to the internal code, but it is almost impossible with the external code of third-party libraries whose authors can use a different set of issued / excluded warnings.  The requirement that all libraries be cleared of all known warnings is impractical (due to false positives and the lack of a standard notation for suppressing them), and is unattainable (as many warnings are continuously expanded).  The second is explained by the fact that ecosystems of compilers and libraries are developing together, and improvements in some cause the need for improvements - and therefore the need to keep a given pace - in others.  As a result, developers have to deal with compilers that are lagging behind libraries, then with libraries that are lagging behind compilers, and neither of them is under their control.  In such circumstances, programmers (assuming that they write in living and active languages ‚Äã‚Äãlike C ++) want to determine for themselves what warnings they would like to see in the code that is not controlled by them. <br><br><h2>  Proposed Solution </h2><br>  We are introducing a new group of compilation options <i>/ external: *</i> , which works with ‚Äúexternal‚Äù header files.  We have chosen the name " <i>external header files</i> " to the name " <i>system header files</i> " adopted in other compilers, since it better reflects the diversity of existing third-party libraries.  In addition, the C ++ standard already appeals to external header files in the [lex.header] section, so our choice is quite natural.  We have combined new keys into a group, instead of describing them separately, because it will be easier for users to <i>master them</i> : the full syntax of new keys can be foreseen by analogy with already known keys.  At the moment, the group consists of 5 parameters, divided into two categories (see the relevant sections below): <br><br><h4>  Parameters defining a set of external header files </h4><br><ul><li>  <i>/ external: I &lt;path&gt;</i> </li><li>  <i>/ external: anglebrackets</i> </li><li>  <i>/ external: env: &lt;var&gt;</i> </li></ul><br><h4>  Parameters defining diagnostic behavior for external header files </h4><br><ul><li>  <i>/ external: W &lt;n&gt;</i> </li><li>  <i>/ external: templates-</i> </li></ul><br>  The second group can be further expanded with parameters such as <i>/ external: w, / external: Wall, / external: Wv: &lt;version&gt;, / external: WX [-], / external: w &lt;n&gt; &lt;warning&gt;, / external: wd &lt;warning&gt;, / external: we &lt;warning&gt;, / external: wo &lt;warning&gt;</i> , etc.  They can be used as analogs <a href="https://docs.microsoft.com/ru-ru/cpp/build/reference/compiler-option-warning-level">of warning levels</a> or any other standard keys for external (as opposed to user) header files.  Note that, since this is an experimental function, you need to add the <i>/ experimental: external</i> parameter to enable it, until we debug it to the end.  Let's see what the new keys do. <br><br><h3>  External header files </h3><br>  Currently, library authors and users can specify the location of header files in four ways - they differ in the complexity of adding to build scripts, implementation, and degree of control. <br><br><ul><li>  <i>/ external: I &lt;path&gt;</i> is the ideological equivalent of -isystem, or simply -i (in lower case), in the GCC, Clang and EDG compilers, which is used to set the directory with external header files.  All recursive subdirectories in the path are also considered external, but only the path itself is added to the list of directories by which the included files are searched for; </li><li>  <i>/ external: env: &lt;var&gt;</i> - sets the name of the environment variable, which stores a list of directories with external header files, listed with a semicolon.  This method is useful when using building systems that rely on environment variables such as INCLUDE and CAExcludePath, which lists external include files and files that should not be checked with the <i>/ analyze</i> key, respectively.  The user can simply write <i>/ external: env: INCLUDE</i> and <i>/ external: env: CAExcludePath</i> and not transfer a long list of directories with the <i>/ external</i> parameter <i>: I</i> ; </li><li>  <i>/ external: anglebrackets</i> - allows to interpret all header files included with the <i>#include &lt;&gt;</i> command (as opposed to <i>#include ""</i> ) as external ones; </li><li>  <i>#pragma system_header</i> - an embedded label of header files - allows authors of libraries to mark certain header files as external. </li></ul><br><h3>  Warning levels for external header files </h3><br>  The <i>/ external: W &lt;n&gt;</i> option allows the user to set the default warning level for external header files.  We include such inclusions in the analogue of the construction: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta"> (push, n) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   n    #pragma warning (pop)</span></span></span></span></code> </pre> <br>  Using this key in combination with the preferred way of specifying external header files, you can completely disable any warnings issued to these files. <br><br><h4>  Example: </h4><br>  External header file: some_lib_dir / some_hdr.hpp <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T value = <span class="hljs-number"><span class="hljs-number">-7</span></span>; <span class="hljs-comment"><span class="hljs-comment">// W4: warning C4245: 'initializing': // conversion from 'int' to // 'unsigned int', signed/unsigned // mismatch };</span></span></code> </pre> <br>  User code: my_prog.cpp <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_hdr.hpp"</span></span></span><span class="hljs-meta"> int main() { return some_struct</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unsigned int&gt;().value; }</span></span></span></span></code> </pre> <br>  If you compile this code like this: <br><br>  <i>cl.exe / I some_lib_dir / W4 my_prog.cpp</i> <br><br>  The header file will display a Level 4 warning C4245, referred to in the comment.  Compilation with parameters: <br><br>  <i>cl.exe / experimental: external / external: W0</i> <i>/ I some_lib_dir / W4 my_prog.cpp</i> <br><br>  will not have any effect, since we have not specified external header files.  Compilation with parameters: <br><br>  <i>cl.exe / experimental: external / external: I some_lib_dir / W4 my_prog.cpp</i> <br><br>  also will not have any effect, since the level of warnings for external header files is not set and by default it corresponds to the level specified in the / W parameter (in our case 4).  To suppress the warning in external header files, we must specify both the path to these files and the level of warnings for them: <br><br>  <i>cl.exe / experimental: external / external: I some_lib_dir / external: W0 / W4 my_prog.cpp</i> <br><br>  This command will get rid of all warnings on the file some_hdr.hpp, leaving only warnings on the file my_prog.cpp. <br><br><h3>  Warnings affecting both internal and external code </h3><br>  It would be great if you could just set the warning level for external header files, but this is how we risk weeding out some messages that are also relevant for internal, user files.  If you use the pragma push / pop directives alone in conjunction with include, many useful warnings may disappear when instantiating patterns in custom code.  Such warnings can indicate the presence of a problem on the user's side, and it manifests itself when only certain types are substituted into the template (for example, when they forgot to apply a type conversion from &lt;type_traits&gt; that removes const or &amp;), and then this problem should be reported.  Prior to this version, the level of warnings that was in effect at the time of issuing a message was determined solely on the basis of lexical analysis, while the problem area may be in a different scope.  Apparently, it makes sense to compare alert levels at template instantiation points to determine which warnings should be issued and which should not. <br><br>  In order not to accidentally silence warnings in templates that are defined in external header files, we allowed users to exclude templates from the simplified logic described above ‚Äî this can be done by passing the <i>/ external: templates-</i> option along with <i>/ external: W &lt;n&gt;</i> .  In doing so, we look not only at the current warning level at the point where the template definition is contained and the warning is issued, but also at the warning levels at all points in the template instantiation sequence.  Our warning levels form a grid in relation to the entire set of messages at all levels (however, it is not perfect, because sometimes we issue warnings at several levels at once).  A superset defining warnings that must be admitted at a given program point with respect to this grid would be the result of combining the messages allowed at each program point through a chain of instantiations.  This is exactly what the <i>/ external: template-</i> key serves for, allowing you to display warnings on templates stored in external header files and implemented in user (that is, internal) code. <br><br>  <i>cl.exe / experimental: external / external: I some_lib_dir / external: W0 / external: templates- / W4 my_prog.cpp</i> <br><br>  This command allows you to display a warning even though it is set to warning level 0 in the external header file. <br><br><h3>  Suppress and force warnings </h3><br>  The mechanism described above does not include and does not turn off warnings by itself - it only sets the default level for the specified set of files, and then the standard mechanisms for turning on, turning off and suppressing warnings come into play: <br><br><ul><li>  <i>/ wdNNNN, / w1NNNN, / weNNNN, /Wv:XX.YY.ZZZZ etc.</i> </li><li>  <i>#pragma warning (disable: 4507 34; once: 4385; error: 4164)</i> </li><li>  <i>#pragma warning (push [, n]) / #pragma warning (pop)</i> </li></ul><br>  Also, by using <i>/ external: templates-,</i> you can suppress a warning at the point of instantiation.  In the example discussed earlier, the user can explicitly suppress a warning issued because of the <i>/ external</i> key <i>: templates-</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( suppress : 4245) return some_struct</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unsigned int&gt;().value; }</span></span></span></span></code> </pre> <br>  Library authors working on the other side can use these same mechanisms to force some or all warnings of a certain level to be turned on if they consider that these warnings are critical enough and should not be suppressed with the <i>/ external</i> key <i>: W &lt;n&gt;</i> . <br><br><h4>  Example: </h4><br>  External header file: some_lib_dir / some_hdr.hpp <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( push, 4 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> : 4245 ) template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt; struct some_struct { static const T value = -7; // W4: warning C4245: 'initializing': // conversion from 'int' to // 'unsigned int', signed/unsigned // mismatch }; #pragma warning( pop )</span></span></span></span></code> </pre> <br>  By changing the library header file as shown above, the author of the library can be sure that this file will be checked with level 4, regardless of what level the user specified in the <i>/ external</i> parameter <i>: W &lt;n&gt;</i> , the compiler will still issue all level 4 warnings and higher.  Moreover, as shown there, it is possible to forcibly configure one or another warning so that it will always be considered an error, be turned off, suppressed, or be issued once for a given header file - and, again, the user will not be able to bypass this setting. <br><br><h2>  Restrictions </h2><br>  In the current version, it is possible to trigger warnings on external header files in cases when they are issued by the compiler optimizer (and not by the scanner).  Such warnings are usually in the C47XX format, but not all C47XX messages are issued by the optimizer.  As a rule, if a data flow or control analysis is required to detect some warning, then most likely it comes from the optimizer in our implementation and cannot yet be suppressed with the help of a new mechanism.  We know about this problem, but the solution is unlikely to appear until the next major update of Visual Studio, since it involves major changes in the presentation of the intermediate code.  However, such warnings can still be disabled in the standard way - using the / wd47XX switch. <br><br>  In addition, this experimental functionality has not yet been integrated into <i>/ analyze</i> warnings, since we want to first examine user feedback.  Warnings <i>/ analyze is</i> not divided into levels, so we are also looking for the best way to combine them with the current logic. <br><br>  We cannot yet tell how this feature will work with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/sdl-enable-additional-security-checks">SDL</a> alerts, but we will keep in touch with the SDL team and let you know as soon as we know. <br><br><h2>  Conclusion </h2><br>  Returning to the analogy with the theory of broken windows, it should be noted that we ambiguously assess the impact of our innovation on the library ecosystem as a whole.  On the one hand, it can harm them, since users will no longer consider errors in libraries as their problems, and therefore, they will be less likely to report them or correct them on their own.  On the other hand, users will get more control over their own code and will be able to impose more stringent requirements on it.  Previously, this was hampered by libraries that were not controlled by them, but now they can be pacified. <br><br>  Although we recognize the possibility of this side effect, correcting errors in third-party code is still not the main task of a programmer, since he has his own code on which he should work and which should be cleaned of errors, while warnings to third-party libraries prevent this process, because it cannot enable the / wx option only for its files.  But, more importantly, we are confident that the negative impact on libraries is compensated by another useful outcome. <br><br>  By allowing developers to hide warnings to third-party libraries, we encourage them to pay more attention to their own code, improve it, or even completely clear warnings at the highest possible level for them.  The authors of third-party libraries are the same developers, another link in this chain, and therefore, giving them the opportunity not to be distracted by dependencies in third-party code, we also encourage them to monitor the quality of their own code more carefully and to achieve compilability at the maximum possible warning level. .  And so on.  Why is it important?  The fact is that <b><i>with the current software development process, the number of warnings grows like an avalanche as you move along a chain of dependencies</i></b> , and the further you are in this chain, the more difficult it becomes to cope with warnings;  developers "break" under their weight and stop any attempts to correct the situation.  When it is possible to separate your code from someone else‚Äôs, <i>each developer in the chain has at his disposal the means to stop (blocking the consequences) this avalanche of warnings;</i>  <i>he has an incentive to minimize its influence on his section, and thus on the whole chain as a whole</i> .  This, of course, is a speculative conclusion, but we believe that this effect is no less likely than a negative impact on libraries. <br><br>  In conclusion, we invite you to experience the new functionality yourself and share your impressions with us.  We kindly request: tell us not only about what you liked, but about what you did not like, otherwise the active minority will decide for you.  The new mechanism is available in a preliminary version of <a href="https://blogs.msdn.microsoft.com/visualstudio/2017/12/07/visual-studio-2017-version-15-6-preview/">Visual Studio 15.6 Preview 1</a> .  As usual, you can contact us by leaving a comment below or by writing us an e-mail to <a href="">visualcpp@microsoft.com</a> ;  You can send feedback using the Help -&gt; <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio-2017">Report A Problem in the product</a> menu command or leave it in <a href="https://developercommunity.visualstudio.com/topics/C%252B%252B.html">the developer community</a> .  <a href="https://twitter.com/visualc">Follow</a> us on Twitter ( <a href="https://twitter.com/visualc">@VisualC</a> ) and Facebook ( <a href="https://www.facebook.com/msftvisualcpp">msftvisualcpp</a> ). <br><br>  PS Special thanks to <a href="https://github.com/ras0219-msft">Robert Schumacher</a> - he pointed out the similarity of our theory with the <a href="https://en.wikipedia.org/wiki/Broken_windows_theory">theory of broken windows</a> ! <br><br><h2>  Translator's notes </h2><br><ol><li>  The article is published with the consent of the author.  The original article was published in the Visual C ++ Team Blog in English: <a href="https://blogs.msdn.microsoft.com/vcblog/2017/12/13/broken-warnings-theory/">Broken Warnings Theory</a> . </li><li>  Author's profile on GitHub: <a href="https://github.com/solodon4">solodon4</a> . </li><li>  <a href="https://www.reddit.com/r/cpp/comments/7jnw4r/broken_warnings_theory/">Discussion of the article</a> on the Reddit website. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/347686/">https://habr.com/ru/post/347686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347674/index.html">"Supercomputer" digest: 4 news from the world of high-performance computing</a></li>
<li><a href="../347676/index.html">Static analysis and property-based testing: together we are powerful</a></li>
<li><a href="../347678/index.html">Creating cognitive connections with players</a></li>
<li><a href="../347680/index.html">Interview with Jasi2169</a></li>
<li><a href="../347684/index.html">Telephony for hotels: review of the hotel module PBX 3CX</a></li>
<li><a href="../347688/index.html">Performance comparison of C and C ++ using the example of Huffman compression</a></li>
<li><a href="../347692/index.html">The digest of interesting materials for the mobile developer # 238 (January 22 - January 28)</a></li>
<li><a href="../347694/index.html">What indie developers can learn from indie writers</a></li>
<li><a href="../347696/index.html">Apply CatBoost models inside ClickHouse. Yandex lecture</a></li>
<li><a href="../347698/index.html">Programmer Unknown's BattleGround: an open area for programmer battles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>