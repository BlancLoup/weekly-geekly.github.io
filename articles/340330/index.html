<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development for Sailfish OS: Work with Bluetooth</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! This article is a continuation of a series of articles devoted to the development of the mobile platform Sailfish OS. This time it will be abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development for Sailfish OS: Work with Bluetooth</h1><div class="post__text post__text-html js-mediator-article">  Hello!  This article is a continuation of a series of articles devoted to the development of the mobile platform Sailfish OS.  This time it will be about using Bluetooth to establish a connection between two devices and transfer data. <br><a name="habracut"></a><br><h3>  Bluetooth </h3><br>  Bluetooth technology allows you to create a wireless connection, thanks to which absolutely any data can be transferred.  There are a number of tasks for which Bluetooth is a common solution, for example, transferring files from one device to another, connecting to Bluetooth headsets, or remotely controlling scanners and printers. <br><br><h3>  Sample application </h3><br>  We will consider the use of Bluetooth technology on the example of the implementation of the application for the exchange of lines.  Let's call it <i>bluetooth messenger</i> .  The application will work in two modes: server and client.  The server will register the Bluetooth service and respond to the client connection.  The client will search for the created service, connect to it and transfer data.  As a result, you need two devices running Sailfish OS. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e6/0e/59e60e931de80773144218.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e6/0e/59e60e932bccd409214641.png"></div></td></tr></tbody></table><br>  As a result, the application will work as follows: <br><br><ol><li>  The client is looking for a server with a registered service. </li><li>  To the server found it passes the string. </li><li>  The server accepts the string, displays it on the screen. </li><li>  The accepted string is expanded and sent back to the client. </li><li>  The client displays an expanded line on the screen and disconnects from the server. </li></ol><br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e6/0e/59e60e938deff948143072.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e6/0e/59e60e93b5b82499502541.png"></div></td></tr></tbody></table><br>  The implementation of this application will fully illuminate the necessary tools to establish communication between two devices and exchange data between them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Granting elevated privileges to the application </h3><br>  To interact with Bluetooth, an application sometimes requires elevated privileges (to search for services, change visibility settings, to pair devices).  In the absence of elevated privileges, some of the functionality will be unavailable, so we recommend issuing them to an application that works with Bluetooth. <br><br>  To debug, you need to run the application using <i>devel-su</i> with the <i>-p</i> flag.  This allows you to run the application with elevated privileges, and debugging output will be available in the console. <br><br><pre><code class="bash hljs">devel-su -p /usr/bin/bluetooth-messenger</code> </pre> <br>  In order to start the application with elevated privileges by clicking on the icon, you need to make some settings in the source files of the project.  First, the application executable file must be launched using <i>invoker</i> .  <i>Invoker</i> finds the main function of the application and launches it with the arguments passed to it.  This is configured in the <i>.desktop</i> project file with the following line: <br><br><pre> <code class="hljs pgsql">Exec=<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span> <span class="hljs-comment"><span class="hljs-comment">--type=silica-qt5 -s /usr/bin/bluetooth-messenger</span></span></code> </pre><br>  Secondly, you need to create a file with the name corresponding to the name of the executable file in the <i>/usr/share/mapplauncherd/privileges.d/</i> directory and put the line there: <br><br><pre> <code class="hljs">/usr/bin/bluetooth-messenger,</code> </pre><br>  A comma at the end of the line is definitely needed.  Thus, when you click on the application icon, the user will launch it with elevated privileges. <br><br><h3>  Bluetooth state management </h3><br>  First you need to understand how it is possible to manage the state of Bluetooth.  To do this, use the D-Bus system, the interaction with which was described in <a href="https://habrahabr.ru/post/316462/">a previous article</a> .  With this system, we have the ability to turn on and off the power of Bluetooth and adjust the visibility for other devices. <br><br>  To enable Bluetooth, you must use the <i>net.connman</i> service.  On the <i>net.connman</i> interface <i>,</i> on the path <i>/ net / connman / technology / bluetooth,</i> there is the <i>SetProperty</i> method, with which it is possible to set the value of the <i>Powered</i> property, which is responsible for whether Bluetooth is on or not.  The property is set as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QDBusInterface </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bluetoothInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"net.connman"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/net/connman/technology/bluetooth"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"net.connman.Technology"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QDBusConnection::systemBus(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; bluetoothInterface.call(<span class="hljs-string"><span class="hljs-string">"SetProperty"</span></span>, <span class="hljs-string"><span class="hljs-string">"Powered"</span></span>, QVariant::fromValue(QDBusVariant(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)));</code> </pre><br>  Create an instance of <i>QDBusInterface</i> using the previously listed service, path, and interface.  Then on the interface we call the <i>SetProperty</i> method with two arguments: the name of the property and the value. <br><br>  After turning on Bluetooth, it will be useful to configure visibility for other devices.  For this we use the service <i>org.bluez</i> .  First, you need to get the path corresponding to the current device.  To do this, by the root path on the <i>org.bluez.Manager</i> interface, <i>we</i> call the <i>DefaultAdapter</i> method, which in the output arguments contains the path to the current adapter, which we will later use to set the visibility. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QDBusInterface </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapterListInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"org.bluez"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"org.bluez.Manager"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QDBusConnection::systemBus(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QVariant adapterPath = adapterListInterface.call(<span class="hljs-string"><span class="hljs-string">"DefaultAdapter"</span></span>).arguments().at(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  After obtaining the path for setting visibility, you must use the <i>SetProperty</i> method on the <i>org.bluez.Adapter</i> interface to set the following properties: <br><br><ul><li>  <i>DiscoverableTimeout</i> - time in seconds ( <i>unsigned int</i> ), during which the device will be possible to detect after detection is enabled.  If set to 0, then detection starts without a timer. </li><li>  <i>Discoverable</i> ‚Äî depending on the <i>true</i> or <i>false</i> value, enables or disables detection. </li></ul><br>  Unlimited time detection includes the following lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QDBusInterface </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bluetoothAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"org.bluez"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, adapterPath.value&lt;QDBusObjectPath&gt;().path(), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"org.bluez.Adapter"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QDBusConnection::systemBus(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; bluetoothAdapter.call(<span class="hljs-string"><span class="hljs-string">"SetProperty"</span></span>, <span class="hljs-string"><span class="hljs-string">"DiscoverableTimeout"</span></span>, QVariant::fromValue(QDBusVariant(<span class="hljs-number"><span class="hljs-number">0U</span></span>))); bluetoothAdapter.call(<span class="hljs-string"><span class="hljs-string">"SetProperty"</span></span>, <span class="hljs-string"><span class="hljs-string">"Discoverable"</span></span>, QVariant::fromValue(QDBusVariant(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)));</code> </pre><br>  It should be noted that to configure visibility options, it is necessary that the application be launched with elevated privileges. <br><br><h3>  Registering a Bluetooth service </h3><br>  First we need to create a server and register a service on it.  This service will receive messages from customers and respond to them.  To solve this problem, we will create a class <i>MessengerServer</i> , whose header file will contain the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessengerServer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessengerServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *parent = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ~MessengerServer(); <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">messageReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString message)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QBluetoothServer *bluetoothServer; QBluetoothServiceInfo serviceInfo; QBluetoothSocket *socket; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString SERVICE_UUID = <span class="hljs-string"><span class="hljs-string">"1f2d6c5b-6a86-4b30-8b4e-3990043d73f1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clientConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clientDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Now let's take a closer look at the components and contents of the methods of this class. <br><br>  The device can notify other devices that search for Bluetooth by registering a service.  To do this, use the <a href="http://doc.qt.io/qt-5/qbluetoothserver.html"><i>QBluetoothServer</i></a> class.  With it, you can create a Bluetooth server and register on it a service that will inform the devices what it is. <br><br>  <i>QBluetoothServer</i> contains a set of methods for installing the server on the device and registering the service.  In particular, of interest: <br><br><ul><li>  The <i>QBluetoothServer</i> constructor <i>(QBluetoothServiceInfo :: Protocol serverType, QObject * parent)</i> - serves to initialize the server, takes the protocol and the parent <i>QObject</i> as arguments.  In our example, we will use the RFCOMM protocol. </li><li>  The <i>listen</i> method <i>(const QBluetoothAddress &amp; address, quint16 port)</i> - starts listening for incoming connections to the transmitted address and port. </li><li>  The <i>error</i> signal <i>(QBluetoothServer :: Error error)</i> is called when a server error occurs (Bluetooth is turned off, the service is already registered, etc.), where the error itself is available as an argument. </li><li>  The signal <i>newConnection ()</i> is called upon a new connection request. </li></ul><br>  The remaining methods are used to stop the server, get the current address or port, check the status and others.  They are not so interesting, and you can read about them in the official documentation. <br><br>  After we raised the server, you must register the service.  A service is a description of a service that performs certain duties.  Describes the service using the <i><a href="http://doc.qt.io/qt-5/qbluetoothserviceinfo.html">QBluetoothServiceInfo</a></i> object by setting attributes using selected methods.  To solve the above problem, we use the <i>startServer ()</i> method: <br><br><pre> <code class="cpp hljs">bluetoothServer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QBluetoothServer(QBluetoothServiceInfo::RfcommProtocol, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); connect(bluetoothServer, &amp;QBluetoothServer::newConnection, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MessengerServer::clientConnected); QBluetoothAddress bluetoothAddress = QBluetoothLocalDevice().address(); bluetoothServer-&gt;listen(bluetoothAddress);</code> </pre><br>  The first line we create is a server that uses RFCOMM as the protocol.  Then we connect the signal about the new connection with the slot of our class.  After that, we enable listening on our address, for which we create an instance of the current device, from which we retrieve its address and pass it to the <i>listen ()</i> method.  So we install the server. <br><br>  Registering a service requires more code to specify all the parameters required for its operation: <br><br><pre> <code class="cpp hljs">serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceName, <span class="hljs-string"><span class="hljs-string">"BT message sender"</span></span>); serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceDescription, <span class="hljs-string"><span class="hljs-string">"Example message sender"</span></span>); serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceProvider, <span class="hljs-string"><span class="hljs-string">"fruct.org"</span></span>); serviceInfo.setServiceUuid(QBluetoothUuid(SERVICE_UUID));</code> </pre><br>  Here we set the service name, description, service provider (for example, company name) and unique identifier (in this application it is contained in a constant as a string and is given in the format <i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i> , where <i>x</i> is a hexadecimal number).  The first three attributes allow you to get a basic idea of ‚Äã‚Äãthe found service while the fourth one can be used by devices to search for a specific service. <br><br><pre> <code class="cpp hljs">QBluetoothServiceInfo::Sequence classId; classId &lt;&lt; QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::SerialPort)); serviceInfo.setAttribute(QBluetoothServiceInfo::BluetoothProfileDescriptorList, classId); classId.prepend(QVariant::fromValue(QBluetoothUuid(SERVICE_UUID))); serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceClassIds, classId);</code> </pre><br>  This kind of construct uses a sequence ( <i>QBluetoothServiceInfo :: Sequence</i> ) to set other attributes.  In this case, we set a unique identifier for the service.  Thus, the server lets you know what services it provides. <br><br><pre> <code class="cpp hljs">QBluetoothServiceInfo::Sequence publicBrowse; publicBrowse &lt;&lt; QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::PublicBrowseGroup)); serviceInfo.setAttribute(QBluetoothServiceInfo::BrowseGroupList, publicBrowse);</code> </pre><br>  These lines set the group of public search that will allow devices to freely find this service.  Otherwise, the service will not be found. <br><br><pre> <code class="cpp hljs">QBluetoothServiceInfo::Sequence protocol; QBluetoothServiceInfo::Sequence protocolDescriptorList; protocol &lt;&lt; QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::Rfcomm)) &lt;&lt; QVariant::fromValue(quint8(bluetoothServer-&gt;serverPort())); protocolDescriptorList.append(QVariant::fromValue(protocol)); serviceInfo.setAttribute(QBluetoothServiceInfo::ProtocolDescriptorList, protocolDescriptorList);</code> </pre><br>  Here, to access the service, we install the RFCOMM protocol, similar to that used by the server. <br><br><pre> <code class="cpp hljs">serviceInfo.registerService(bluetoothAddress);</code> </pre><br>  Finally, we perform the registration of the created service on the address obtained earlier and used by the server.  From this point on, the service will be visible when searching via Bluetooth with other devices. <br><br><h3>  Work with incoming connections </h3><br>  Now that the service is registered and the application is ready to accept incoming connections, it is necessary to process them.  As mentioned earlier, the application server must receive the string from the client, expand it and send it back. <br><br>  When the client connects to the server, we create a socket, represented as an instance of <i><a href="http://doc.qt.io/qt-5/qbluetoothsocket.html">QBluetoothSocket</a></i> , which can be obtained by calling the <i>nextPendingConnection ()</i> method on an instance of the <i>QBluetoothServer</i> class.  A socket has a whole set of signals to track its state, the most useful of which are: <br><br><ul><li>  <i>connected ()</i> - called when creating a socket connection. </li><li>  <i>disconnected ()</i> - called when the connection is broken. </li><li>  <i>error (QBluetoothSocket :: SocketError error)</i> - called when an error occurs, its type is passed as an argument. </li><li>  <i>readyRead ()</i> is called when new data is available in the socket for reading. </li></ul><br>  We use them to process incoming connections.  Earlier, we attached a <i>newConnection ()</i> signal to the <i>clientConnected ()</i> slot, consider its implementation. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerServer::clientConnected() { <span class="hljs-comment"><span class="hljs-comment">//... socket = bluetoothServer-&gt;nextPendingConnection(); connect(socket, &amp;QBluetoothSocket::readyRead, this, &amp;MessengerServer::readSocket); connect(socket, &amp;QBluetoothSocket::disconnected, this, &amp;MessengerServer::clientDisconnected); }</span></span></code> </pre><br>  The <i>QBluetoothSocket</i> object is a <i><a href="http://doc.qt.io/qt-5/qiodevice.html">QIODevice</a></i> descendant; as a result, methods are available for reading a line, a character, a selected number of characters, and so on.  Methods for reading (as well as methods for writing) use <i><a href="http://doc.qt.io/qt-5/qbytearray.html">QByteArray</a></i> , which allows you to transfer not only strings, but also any other data as a set of bytes.  Thus it is possible to transfer any type of data, regardless of content. <br><br>  In our example, for processing incoming messages, we connected the <i>readyRead ()</i> signal with the <i>readSocket ()</i> method, whose code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerServer::readSocket() { <span class="hljs-comment"><span class="hljs-comment">//... const QString message = QString::fromUtf8(socket-&gt;readLine().trimmed()); emit messageReceived(message); QString reversedMessage; for (int i = message.size() - 1; i &gt;= 0; i--) { reversedMessage.append(message.at(i)); } socket-&gt;write(reversedMessage.toUtf8()); }</span></span></code> </pre><br>  To read the data as an array of bytes, we use the <i>readLine ()</i> method, then we convert the line read into a string, expand it, and send it back using the <i>write ()</i> method, converting it back to an array of bytes.  Thus, the server implemented by us is able to receive the string from any other device via Bluetooth and return it back in expanded form. <br><br><h3>  Search service </h3><br>  Now, when the server is implemented, running and waiting for incoming connections, you need to connect to it.  How is it possible to find a device that provides the necessary service?  First, you need to search for services available on visible Bluetooth devices and only then connect to it. <br><br>  The client header file has the following contents: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessengerClient</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessengerClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *parent = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ~MessengerClient(); <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDiscovery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;messageToSend)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopDiscovery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString SERVICE_UUID = <span class="hljs-string"><span class="hljs-string">"1f2d6c5b-6a86-4b30-8b4e-3990043d73f1"</span></span>; QString message; QBluetoothSocket *socket = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; QBluetoothDeviceDiscoveryAgent* discoveryAgent; QBluetoothDeviceInfo device; QBluetoothLocalDevice localDevice; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestPairing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QBluetoothAddress &amp;address)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QBluetoothAddress &amp;address)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">messageReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString message)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clientStatusChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString text)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deviceDiscovered</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QBluetoothDeviceInfo &amp;deviceInfo)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairingFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QBluetoothAddress &amp;address, QBluetoothLocalDevice::Pairing pairing)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairingError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QBluetoothLocalDevice::Error error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socketConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deviceSearchFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Consider the components that are necessary to implement the search service and send messages. <br><br>  Qt provides the <i><a href="http://doc.qt.io/qt-5/qbluetoothservicediscoveryagent.html">QBluetoothServiceDiscoveryAgent</a></i> class for searching services.  It allows you to automatically check all devices for the presence of a certain service, which we are looking for by the UUID.  Later, when a service is found, an object of this class initiates the corresponding signal, with which we can process the search result.  It should be noted that the use of this class requires that the application be launched with elevated privileges.  The class contains the following methods of interest: <br><br><ul><li>  <i>setUuidFilter (const QBluetoothUuid &amp; uuid)</i> - sets the UUID, the service with which you want to find.  There is also a similar method for setting multiple UUIDs. </li><li>  <i>setRemoteAddress (const QBluetoothAddress &amp; address)</i> - sets the address of the device where the service is to be found.  It can be used if you know the exact address of the device you want to find. </li><li>  <i>start ()</i> - starts searching for services. </li><li>  <i>stop ()</i> stops the search for services. </li><li>  <i>discoveredServices ()</i> - returns a list of found services. </li><li>  <i>clear ()</i> - clears the list of found services. </li></ul><br>  Signals are useful for processing the result: <br><br><ul><li>  <i>serviceDiscovered (const QBluetoothServiceInfo &amp; info)</i> - called when a service is detected, information about it is passed with an argument. </li><li>  <i>finished ()</i> - called when the search is completed. </li><li>  <i>error (QBluetoothServiceDiscoveryAgent :: Error error)</i> - called when errors occur. </li></ul><br>  To search for our specific service, you must set the <i>setUuidFilter ()</i> method to filter by UUID, which we specified when registering the service and using the <i>start ()</i> method to <i>start the</i> search.  After that, when our service is <i>detected, the serviceDiscovered ()</i> signal will be triggered.  An instance of <i><a href="http://doc.qt.io/qt-5/qbluetoothserviceinfo.html">QBluetoothServiceInfo</a></i> contains information about the found service (name, UUID, information about the device on which it is registered, etc.).  We will use the instance of this class to connect to the service, which will be mentioned later. <br><br>  Specifically, in our example, we will consider another class that does not require elevated privileges - <i><a href="http://doc.qt.io/qt-5/qbluetoothdevicediscoveryagent.html">QBluetoothDeviceDiscoveryAgent</a></i> .  With it, you can search for devices, not services, and it does not require elevated privileges.  For each device found, we will browse the services registered on the device, and if our service is in the list, then we consider the service found and in the future we will connect to it. <br><br>  <i>QBluetoothDeviceDiscoveryAgent</i> consists of a small number of methods for finding devices.  The most useful are the following: <br><br><ul><li>  <i>start ()</i> - starts searching for devices. </li><li>  <i>stop ()</i> - stops searching devices. </li><li>  <i>discoveredDevices ()</i> - returns a list of all found devices. </li><li>  <i>error ()</i> - returns the type of the last error encountered while searching.  There is also a signal that will be triggered immediately after an error occurs with the type of error as an argument. </li><li>  <i>errorText ()</i> - returns the text of the last error that occurred. </li></ul><br>  Also, if the device is <i>found, the deviceDiscovered</i> signal <i>(const QBluetoothDeviceInfo &amp; info)</i> will be immediately triggered, which can serve to process the result. <br><br>  Information about found devices is represented as a <i><a href="http://doc.qt.io/qt-5/qbluetoothdeviceinfo.html">QDeviceInfo</a></i> object.  From this object, you can extract data using special methods.  The most interesting are the following: <br><br><ul><li>  <i>address ()</i> is the mac address of the device found.  Used when searching for devices other than macOS and iOS. </li><li>  <i>deviceUuid ()</i> is a unique identifier for the device found.  Used only when searching for devices on macOS and iOS. </li><li>  <i>name ()</i> is the name of the device found. </li><li>  <i>serviceUuids ()</i> is a list of unique identifiers for registered services. </li></ul><br>  Now that we know how to search for services on Bluetooth devices, let's try to find our own service.  In the constructor, initialize the object to search for devices: <br><br><pre> <code class="cpp hljs">MessengerClient::MessengerClient(QObject *parent) : QObject(parent) { <span class="hljs-comment"><span class="hljs-comment">//... discoveryAgent = new QBluetoothDeviceDiscoveryAgent(localDevice.address()); connect(discoveryAgent, &amp;QBluetoothDeviceDiscoveryAgent::deviceDiscovered, this, &amp;MessengerClient::deviceDiscovered); connect(discoveryAgent, &amp;QBluetoothDeviceDiscoveryAgent::finished, this, &amp;MessengerClient::deviceSearchFinished); //... }</span></span></code> </pre><br>  First, we create an instance of <i>QBluetoothDeviceDiscoveryAgent</i> , to which we pass the address of the current Bluetooth device as an argument.  Then we attach two object signals to our current: <i>deviceDiscovered ()</i> to process the newly found device and <i>finished ()</i> to handle the completion of the search. <br><br>  The method to start the search contains the following lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::startDiscovery(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;messageToSend) { <span class="hljs-comment"><span class="hljs-comment">//... this-&gt;message = messageToSend; discoveryAgent-&gt;start(); //... }</span></span></code> </pre><br>  Here we save the message that needs to be transmitted and begin the search for devices. <br><br>  For processing the devices found, the <i>deviceDiscovered ()</i> slot is used, to which we have previously connected a signal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::deviceDiscovered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QBluetoothDeviceInfo &amp;deviceInfo) { <span class="hljs-comment"><span class="hljs-comment">//... if (deviceInfo.serviceUuids().contains(QBluetoothUuid(SERVICE_UUID))) { emit clientStatusChanged(QStringLiteral("Device found")); discoveryAgent-&gt;stop(); requestPairing(deviceInfo.address()); } }</span></span></code> </pre><br>  As mentioned earlier, we are looking at the list of unique service identifiers for searching our registered one in it.  When the device that provides the required service is found for the first time, we complete the search and call the method for establishing pairing between devices. <br><br><h3>  Pairing devices </h3><br>  Pairing devices is an important aspect in the interaction of devices using Bluetooth.  This implies that two devices establish trusting relationships with each other and a wider range of interaction possibilities (for example, remote control) is available to them.  Specifically, in our example, pairing is not required, but we will install it to make out how it is done in the general case.  Pairing installation requires elevated privileges. <br><br>  To pair devices, use the <i><a href="http://doc.qt.io/qt-5/qbluetoothlocaldevice.html">QBluetoothLocalDevice</a></i> class.  We have already used it earlier in the server-side code to get the address of the current device.  It is also used for pairing devices.  We are interested in methods: <br><br><ul><li>  <i>pairingStatus (const QBluetoothAddress &amp; address)</i> - allows you to get the pairing status between the current device and the device at the address.  Returns one of the values: </li><li>  <i>requestPairing (const QBluetoothAddress &amp; address, Pairing pairing)</i> - requests changes in the status of pairing with the device (the second argument is Paired for setting pairing or Unpaired for breaking). </li></ul><br>  and signals: <br><br><ul><li>  pairingFinished (const QBluetoothAddress &amp; address, QBluetoothLocalDevice :: Pairing pairing) - returned when the pairing status is successfully changed. </li><li>  error (QBluetoothLocalDevice :: Error error) - returned when an error has occurred changing the pairing status (including the cancellation of the pairing proposal on one of the devices). </li></ul><br>  We can get the address of the remote device by calling the <i>address ()</i> method on the <i>QBluetoothDeviceInfo</i> instance, in the future we will use it when setting the pairing and connecting to the service.  Now we will try to establish a pairing between the two devices.  First, let's add a connection to the signals in the client class constructor: <br><br><pre> <code class="cpp hljs">connect(&amp;localDevice, &amp;QBluetoothLocalDevice::pairingFinished, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MessengerClient::pairingFinished); connect(&amp;localDevice, &amp;QBluetoothLocalDevice::error, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MessengerClient::pairingError);</code> </pre><br>  The <i>QBluetoothLocalDevice</i> instance in this case is a class field.  The <i>pairingFinished ()</i> slot contains a line that starts the <i>startClient (address)</i> client, and <i>pairingError () contains a</i> debug output. <br><br>  To set the pairing, we implemented the <i>requestPairing ()</i> method with the following content: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::requestPairing(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QBluetoothAddress &amp;address) { <span class="hljs-comment"><span class="hljs-comment">//... if (localDevice.pairingStatus(address) == QBluetoothLocalDevice::Paired) { startClient(address); } else { localDevice.requestPairing(address, QBluetoothLocalDevice::Paired); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the devices are already paired, then we simply initiate a connection to the server, otherwise we request pairing. As a result, when pairing is successfully established, a connection to the server is also initiated, and in case of an error, we notify the user about the problem.</font></font><br><br><h3>  Connect to server </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An instance of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothDeviceInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">corresponding to the device found contains a method for obtaining an address that is sufficient to connect to the service. </font></font><i><a href="http://doc.qt.io/qt-5/qbluetoothsocket.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothSocket is</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used for this </font><i><a href="http://doc.qt.io/qt-5/qbluetoothsocket.html"><font style="vertical-align: inherit;">purpose</font></a></i><font style="vertical-align: inherit;"> ; it is enough to create an instance of this class using the constructor, passing it the RFCOMM protocol and calling the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connectToService ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, which is passed the address from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothDeviceInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instance </font><font style="vertical-align: inherit;">and the port on which you want to connect </font><font style="vertical-align: inherit;">as arguments </font><font style="vertical-align: inherit;">. To establish a connection with the service, you need to specify port 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now consider the process of establishing a connection, transmitting and receiving data using a socket. The client uses the same </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothSocket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as on the server, which allows us to use the signals discussed earlier to implement handlers and methods to write data to the socket. The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">startClient ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">establishes a connection with a device providing a service using a socket:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::startClient(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QBluetoothDeviceInfo &amp;deviceInfo) { <span class="hljs-comment"><span class="hljs-comment">//... socket = new QBluetoothSocket(QBluetoothServiceInfo::RfcommProtocol, this); connect(socket, &amp;QBluetoothSocket::connected, this, &amp;MessengerClient::socketConnected); connect(socket, &amp;QBluetoothSocket::readyRead, this, &amp;MessengerClient::readSocket); socket-&gt;connectToService(deviceInfo.address(), 1); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We create an instance of a socket with the RFCOMM protocol and connect its signals to the slots of our class. Then, by calling the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connectToService ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method, we </font><font style="vertical-align: inherit;">connect to another device. It should be noted that if we used the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothServiceInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, which allows you to get information about the found services as instances of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QBluetoothServiceInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then it would be enough to call the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connectToService ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">with one argument that accepts the service information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socketConnected ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">is called when a connection is established via a socket, inside it we send data to the server:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::socketConnected() { <span class="hljs-comment"><span class="hljs-comment">//... socket-&gt;write(message.toUtf8()); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It uses the same socket class as the server, so we can transfer any data as an array of bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we remember, the server code allows you to get a string, expand it and return it to us, to process the incoming message, we connected the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readSocket ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slot </font><font style="vertical-align: inherit;">with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readyRead ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signal </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This slot looks like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessengerClient::readSocket() { <span class="hljs-comment"><span class="hljs-comment">//... QString receivedMessage = QString::fromUtf8(socket-&gt;readLine().trimmed()); emit messageReceived(receivedMessage); }</span></span></code> </pre><br><h3>  Result </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we have covered most of the functionality required to implement a server and a client for transferring data of any kind with between them. </font><font style="vertical-align: inherit;">Also reviewed the procedure for finding devices. </font><font style="vertical-align: inherit;">The material mentioned in the article is enough to realize the transfer of any data between two devices. </font><font style="vertical-align: inherit;">Sample application code is available on </font></font><a href="https://github.com/ExAnimoso/bluetooth-messenger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Technical issues can also be discussed on <a href="https://t.me/sailfishos">the Sailfish OS Russian-speaking community channel in a Telegram</a> or <a href="https://vk.com/merproject">VKontakte group</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Author: Sergey Averkiev </font></font></div><p>Source: <a href="https://habr.com/ru/post/340330/">https://habr.com/ru/post/340330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340318/index.html">Behind the scene of TOP-1 supercomputer</a></li>
<li><a href="../340320/index.html">Free YouTube broadcast DevOps conference DevOops 2017</a></li>
<li><a href="../340322/index.html">How I passed the practice in the university and set up Nextcloud</a></li>
<li><a href="../340324/index.html">Invitation to Meetup on computer vision in Avito, October 28</a></li>
<li><a href="../340326/index.html">So iron and so nameless</a></li>
<li><a href="../340332/index.html">Theoretical informational approach to the analysis of sales funnel in contextual advertising</a></li>
<li><a href="../340336/index.html">HR-hack - a joint hackathon from Alfa-Bank, Unilever, Leroy Merlin, CRIC and Beeline</a></li>
<li><a href="../340338/index.html">Magento Dare to Share. Autumn - season Magento mitapov</a></li>
<li><a href="../340340/index.html">IPSec between Cisco ISR and RUH2 3G router using dynamically allocated IP</a></li>
<li><a href="../340342/index.html">How to create an electronic voting system on the blockchain?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>