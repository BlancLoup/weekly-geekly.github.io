<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extending Ansible with plugins: part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are actively using Ansible in D2C . With it, we create virtual machines with cloud providers, install software, as well as manage Docker-containers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extending Ansible with plugins: part 1</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/webt/ti/6d/fz/ti6dfzt_wksiiposord9cnscw7c.jpeg"><br><p>  <a href="https://d2c.io/">We</a> are actively using Ansible <a href="https://d2c.io/">in D2C</a> .  With it, we create virtual machines with cloud providers, install software, as well as manage Docker-containers with client applications.  In the last article I talked about <a href="https://habrahabr.ru/company/d2cio/blog/343368/">how to make Ansible work faster</a> , now I will talk about how to extend its functionality. </p><a name="habracut"></a><br><p>  Ansible is an extraordinarily flexible tool.  It is written in Python and mainly consists of replaceable "cubes" - plug-ins and modules.  Plug-ins affect the work flow of Ansible on the management machine, modules are executed on remote hosts and return the result to the management machine.  Therefore, if the Ansible functionality ‚Äúout of the box‚Äù is not enough for you, it is enough to write your own plugin or module, and then add it to the system.  An additional convenience is that plug-ins and modules do not need to be specially installed on the control machine and can be distributed directly with their own playbooks. </p><br><p>  Consider an example: </p><br><pre><code class="hljs objectivec">--- - hosts: localhost vars: foo: - a - b - c tasks: - <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>: content: <span class="hljs-string"><span class="hljs-string">"{{ foo | shuffle }}"</span></span> dest: /tmp/test</code> </pre> <br><p>  In this case, <code>copy</code> is a module.  It will be executed on the target machine;  <code>shuffle</code> - Jinja2 filter loaded by plugin.  Plugins in Ansible perform not only visible, but also hidden from the work. </p><br><p>  <strong>Important:</strong> All plug-ins in Ansible run in the context of the local host (i.e., the management machine).  One of the common mistakes is to try to read the environment variables on the target host using the <code>env</code> lookup plugin: </p><br><pre> <code class="hljs sql">- name: <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> shell: echo {{ lookup(<span class="hljs-string"><span class="hljs-string">'env'</span></span>,<span class="hljs-string"><span class="hljs-string">'USER'</span></span>) }}</code> </pre> <br><p>  In this case, it does not matter on which server the task is executed, the <code>USER</code> variable will be equal to the value that is set by the <code>ansible</code> process on the management machine.  Similar to all other plugins. </p><br><h1 id="vidy-plaginov">  Types of plugins </h1><br><p>  I will list the types of plugins in alphabetical order, for Ansible 2.3.x: </p><br><h3 id="action">  Action </h3><br><p>  Action plugins are used as wrappers for modules.  They are executed immediately before sending the modules for execution to the target hosts.  Usually they are used for preliminary data preparation or for post-processing the results of module execution. </p><br><p>  In general, the task execution for <code>mymodule</code> looks like this: </p><br><ul><li>  The action plugin <code>mymodule</code> launched on the local computer; </li><li>  Inside the plugin, preparatory operations are performed; </li><li>  A command is given to launch the module. </li><li>  The <code>mymodule</code> module is started on the remote computer; </li><li>  The result is returned to the local computer. </li><li>  Control returns to the action plugin <code>mymodule</code> ; </li><li>  Post-processing the results </li></ul><br><p>  If the action plugin <code>mymodule</code> does not exist, the base class of the plugin is used. </p><br><h3 id="cache">  Cache </h3><br><p>  Cache plugins are used to organize the repository (backends) of facts.  The default is the <code>memory</code> backend, so the facts are saved only during the playlist execution.  Alternative out-of-box <code>jsonfile</code> : <code>jsonfile</code> , <code>memcached</code> , <code>pickle</code> , <code>redis</code> , <code>yaml</code> . </p><br><p>  The fact cache is used if you need to work with many remote hosts and it takes a long time to collect facts.  In such a situation, it is possible to update the cache on a schedule, and in the playbooks themselves, the collection of facts cannot be performed or, in rare cases, by a forced command. </p><br><h3 id="callback">  Callback </h3><br><p>  Callback plugins provide the ability to respond to events that Ansible generates during the playlist execution.  For example, the output of the Ansible job log to the screen is done by the <code>default</code> callback plugin, which responds to many events and displays what is happening on the screen.  You can turn on the <code>slack</code> callback plugin and get information about the progress of the playbook in the channel in Slack. </p><br><h3 id="connection">  Connection </h3><br><p>  Connection plugins provide various ways to connect to target hosts ‚Äî for example, <code>ssh</code> ‚Äî for Unix, <code>winrm</code> ‚Äî for Windows, <code>docker</code> ‚Äî to run modules inside containers.  The most common are <code>ssh</code> (default) and <code>local</code> , which is used to run commands locally on the management machine. </p><br><h3 id="filter">  Filter </h3><br><p>  Filter plugins add new Jinja2 filters.  Since for working with variables in Ansible <a href="http://jinja.pocoo.org/">Jinja2</a> template engine is used, almost all of its features are available in playbooks, including <a href="http://jinja.pocoo.org/docs/2.9/templates/">built-in</a> and <a href="http://docs.ansible.com/ansible/latest/playbooks_filters.html">additional</a> filters.  If non-standard filters are required, you can add them with your own plugins. </p><br><h3 id="lookup">  Lookup </h3><br><p>  Lookup plugins are used to search or download data from external sources, as well as to create loops. </p><br><p>  For example, you can use <code>{{ lookup('etcd', 'foo') }}</code> to load values ‚Äã‚Äãfrom <code>etcd</code> . </p><br><p>  To make a loop on the lines of the command output, you can use the <code>lines</code> plugin: </p><br><pre> <code class="hljs pgsql">- <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>: msg: "{{ item }}" with_lines: cat /etc/passwd</code> </pre> <br><p>  In this task, the <code>cat /etc/passwd</code> command will be executed (on the local computer) and a <code>debug</code> pop up for each of the output lines. </p><br><p>  To create a loop, you can use any lookup plugin in the <code>with_&lt;plugin-name&gt;:</code> construct.  When you do the most primitive <code>with_items</code> , the <code>items</code> lookup plugin is called. </p><br><p>  The list of available plug-ins is most convenient to look in the <a href="https://github.com/ansible/ansible/tree/stable-2.3/lib/ansible/plugins/lookup">repository</a> (pay attention to the version - this link is for the 2.3.x branch). </p><br><h3 id="shell">  Shell </h3><br><p>  Shell plug-ins allow you to take into account the nuances of the different behavior of shells on target devices.  For example, <code>bash</code> or <code>csh</code> .  For Windows, the <code>powershell</code> plugin is used. </p><br><h3 id="strategy">  Strategy </h3><br><p>  Strategy plug-ins determine the progress of tasks on target hosts.  Out of the box there are three plugins available: </p><br><ul><li>  <code>linear</code> (enabled by default) - Ansible performs the current task on all hosts in turn, only after its execution on all hosts moves to the next task </li><li>  <code>free</code> - tasks are performed on each of the hosts as quickly as possible, and not waiting for all hosts </li><li>  <code>debug</code> - modification of <code>linear</code> - in case of an error, an interactive shell is enabled, which allows you to view the current variables, make changes to the parameters of the task and rerun it ( <a href="http://docs.ansible.com/ansible/latest/playbooks_debugger.html">documentation</a> ) </li></ul><br><h3 id="terminal">  Terminal </h3><br><p>  Terminal-plugins allow you to take into account varieties of interactive environments.  These plugins are used for network devices such as switches and routers, since working with the shell on these devices is significantly different from the operation of a full-featured shell on a computer. </p><br><h3 id="test">  Test </h3><br><p>  Test plugins add Jinja2 tests that are used in conditional constructs.  Similar to filters, there are <a href="http://jinja.pocoo.org/docs/2.9/templates/">built-in</a> and <a href="http://docs.ansible.com/ansible/latest/playbooks_tests.html">additional</a> tests. </p><br><h3 id="vars">  Vars </h3><br><p>  Vars-plugins are used to manipulate host variables (host vars, group vars) - extremely rare. </p><br><h1 id="pishem-svoi-plaginy">  We write our plugins </h1><br><p>  I will give a few examples of plugins in order of increasing complexity. </p><br><h3 id="test-1">  Test </h3><br><p>  For example, we often work with lists of EC2 servers and you need to select those that work from the list of instances.  You can use the expression: </p><br><p> <code>{{ ec2.instances | selectattr('state','equalto','running') | list }}</code> </p> <br><p>  Or write your test plugin (put in ./test_plugins/ec2.py): </p><br><pre> <code class="hljs python"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestModule</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'ec2_running'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> i: i[<span class="hljs-string"><span class="hljs-string">'state'</span></span>] == <span class="hljs-string"><span class="hljs-string">'running'</span></span> }</code> </pre> <br><p>  And already use: </p><br><p> <code>{{ ec2.instances | select('ec2_running') | list }}</code> </p> <br><p>  Obviously, I have simplified the example a little, and if we need to check several statuses at the same time, then we would have to make a chain from the set <code>selectattr</code> .  In our own test, we can describe any logic and at the same time keep the playbook code concise and well readable. </p><br><p>  Similarly, you can use your tests inside <code>when</code> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span>: my_instance | ec2_running</code> </pre> <br><p>  The task will be executed if <code>my_instance</code> in the <code>running</code> state. </p><br><p>  You can create tests with a parameter.  An example is the standard test <a href="http://jinja.pocoo.org/docs/2.9/templates/">divisibleby</a> , which checks whether it is divisible into something else. </p><br><h3 id="filter-1">  Filter </h3><br><p>  Filters are used to modify variables.  For example, in Ansible for a very long time there were no mechanisms for working with a date.  If you need to make decisions based on time values ‚Äã‚Äãin playbooks, you can use this filter (put in ./filter_plugins/add_date.py): </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterModule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'add_time'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> dt, **kwargs: dt + datetime.timedelta(**kwargs) }</code> </pre> <br><p>  Now in playbooks you can ‚Äúlook into‚Äù the future: </p><br><pre> <code class="hljs perl">- debug: msg: <span class="hljs-string"><span class="hljs-string">"Current time +20 mins {{ ansible_date_time.iso8601[:19] | to_datetime(fmt) | add_time(minutes=20) }}"</span></span> vars: fmt: <span class="hljs-string"><span class="hljs-string">"%Y-%m-%dT%H:%M:%S"</span></span></code> </pre> <br><h3 id="action-1">  Action </h3><br><p>  Action plug-ins are useful when you need to slightly modify the data coming into or out of the modules, or when you need to perform some task always locally on the management server.  An example is the <code>debug</code> module for displaying information, in fact it is not a module since it is never copied to a remote host, but exists only in the form of an action plugin. </p><br><p>  To show how action-plugins work, we modify the behavior of the <a href="http://docs.ansible.com/ansible/latest/setup_module.html">setup</a> module, which is used to collect facts.  It is convenient to use it as an <code>ad-hoc</code> command to view information about servers: </p><br><p> <code>ansible all -i myinventory -m setup</code> </p> <br><p>  This module has a <code>filter</code> parameter that can filter the result.  But he has one feature - it applies only to top-level keys.  If we only need to check the time zone on the servers, we cannot specify <code>tz</code> .  Or if we need to see all ipv4 addresses, we cannot make a filter for all such fields. </p><br><p>  Add a wrapper in the form of an action plugin (put in ./action_plugins/setup.py): </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ansible.plugins.action <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ActionBase <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionModule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ActionBase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tmp=None, task_vars=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj, filter)</span></span></span><span class="hljs-function">:</span></span> res = dict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj.items(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> k: res[k] = v <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(v, dict): val = filter_dict(v, filter) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> val != dict(): res[k] = val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res result = super(ActionModule, self).run(tmp, task_vars) query = self._task.args.get(<span class="hljs-string"><span class="hljs-string">'query'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) module_args = self._task.args.copy() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> query: module_args.pop(<span class="hljs-string"><span class="hljs-string">'query'</span></span>) module_return = self._execute_module(module_name=<span class="hljs-string"><span class="hljs-string">'setup'</span></span>, module_args=module_args, task_vars=task_vars, tmp=tmp) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> module_return.get(<span class="hljs-string"><span class="hljs-string">'failed'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dict(ansible_facts=filter_dict(module_return[<span class="hljs-string"><span class="hljs-string">'ansible_facts'</span></span>], query)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> module_return</code> </pre> <br><p>  The minimum necessary implementation of the plugin is the inheritance from <code>ActionBase</code> and the description of the <code>run</code> method. </p><br><p>  In our example, we: </p><br><ul><li>  We defined the auxiliary function <code>filter_dict</code> , which takes an object (dictionary) as input, looks for keys in it according to our filter and returns the object only with those keys that satisfy the filter (no matter what level of nesting they met); </li><li>  <code>run</code> parent class's <code>run</code> method; </li><li>  We tried to get the value of our new <code>query</code> parameter: if it exists, remember it and <strong>remove it</strong> from the list of parameters that we will pass on to the module - otherwise Ansible will say that the <code>setup</code> module does not know anything about the <code>query</code> parameter and will generate an error; </li><li>  Transferred control to the <code>setup</code> module; </li><li>  If the module has successfully completed its work and the <code>query</code> parameter has been set - we filter the result with our <code>filter_dict</code> function, otherwise we return the result without names; </li></ul><br><p>  Now we have added a new functionality to the existing module and at the same time did not touch its code.  With the release of new versions of Ansible, the <code>setup</code> module can learn to do something else, but our plugin will still work on top of these features. </p><br><h3 id="callback-1">  Callback </h3><br><p>  Callback plugins are used to monitor the events that occur inside Ansible during the playlist and somehow respond to them.  One of the most frequent uses of such plugins is logging, logging and alerting. </p><br><p>  A list of callback plugins available out of the box can be viewed <a href="https://github.com/ansible/ansible/tree/stable-2.3/lib/ansible/plugins/callback">in the repository</a> . </p><br><p>  For notifications, for example, are available: <code>mail</code> , <code>slack</code> , <code>hipchat</code> . </p><br><p>  To modify the logging, for example: <code>minimal</code> , <code>json</code> .  To set the standard output plug-in, you can use the setting: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">defaults</span></span>] stdout_callback = json</code> </pre> <br><p>  Now Ansible will not display a human-readable protocol in the course of execution, but at the very end of the execution, the playbook will issue a huge JSON with all the information.  It can be used to automatically analyze the results in <code>cron</code> tasks or on your <code>CI</code> / <code>CD</code> server. </p><br><p>  For example, you can start the playbook and count the number of hosts in which there were changes: </p><br><p> <code>ANSIBLE_STDOUT_CALLBACK=json ansible-playbook myplaybook.yml | jq '.stats | map(select(.changed &gt; 0)) | length'</code> </p> <br><p>  As an example of a callback plug-in, I‚Äôll give a notification about the playbook execution, which displays a notification in your graphic shell about the playlist execution results (put in ./callback_plugins/notify_me.py): </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ansible.plugins.callback <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CallbackBase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> platform <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> get_system_name <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CallbackModule(CallbackBase): CALLBACK_VERSION = <span class="hljs-number"><span class="hljs-number">2.0</span></span> CALLBACK_TYPE = <span class="hljs-string"><span class="hljs-string">'notification'</span></span> CALLBACK_NAME = <span class="hljs-string"><span class="hljs-string">'notify_me'</span></span> CALLBACK_NEEDS_WHITELIST = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> def v2_playbook_on_stats(self, stats): def <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span>(msg,is_error=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>): sys_name = get_system_name() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys_name == <span class="hljs-string"><span class="hljs-string">'Darwin'</span></span>: sound = "Basso" <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_error <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> "default" <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(["osascript", "-e", <span class="hljs-string"><span class="hljs-string">'display notification "{}" with title "Ansible" sound name "{}"'</span></span>. format(msg,sound)]) elif sys_name == <span class="hljs-string"><span class="hljs-string">'Linux'</span></span>: icon = "dialog-warning" <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_error <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> "dialog-info" rc = <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(["notify-send", "-i", icon, "Ansible", msg]) print "error code {}".format(rc) hosts = stats.processed.keys() failed_hosts = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> h <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hosts: t = stats.summarize(h) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t[<span class="hljs-string"><span class="hljs-string">'unreachable'</span></span>] + t[<span class="hljs-string"><span class="hljs-string">'failures'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: failed_hosts.append(h) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(failed_hosts) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span>("Failed hosts: {}".format(" ".<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(failed_hosts)),<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span>("Job's done!")</code> </pre> <br><p>  The plugin provides some kind of cross-platform attempt :) </p><br><p>  We inherit from the <code>CallbackBase</code> class and override the <code>v2_playbook_on_stats</code> method, which is called when the final performance report is ready.  A standard logging plugin using this method forms the <code>PLAY RECAP</code> table. </p><br><p>  We need the auxiliary function <code>notify</code> , which, depending on the platform, tries to send an alert to the user. </p><br><p>  In the main body of our method, we check if there are any hosts with errors: if there is, send a bad notification with the list of hosts; if not, send a good notification. <code>Job's done!</code>  . </p><br><p>  Pay <strong>attention</strong> to <code>CALLBACK_NEEDS_WHITELIST = True</code> .  This parameter tells Ansible that this plugin requires forced inclusion.  That is, despite the willingness of the plug-in to work, it will be included only when it is added to the whitelist.  This is done so that when working with playbooks, the screen does not litter, but you can easily put such a notification for ‚Äúlong-playing‚Äù playbooks that you run in the background and go to do another thing.  You can check the work like this: </p><br><p> <code>ANSIBLE_CALLBACK_WHITELIST=notify_me ansible-playbook test.yml</code> </p> <br><p>  The full list of methods (events) that can be overridden in callback plugins is best seen in the <a href="https://github.com/ansible/ansible/blob/stable-2.3/lib/ansible/plugins/callback/__init__.py">source code</a> . </p><br><p>  - </p><br><p>  Feel free to experiment with examples from the article.  A few more types of plug-ins will be discussed in the next section.  Stay tuned! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/344046/">https://habr.com/ru/post/344046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344036/index.html">Fresh utilities, plugins and productivity tools for the designer. First release</a></li>
<li><a href="../344038/index.html">How to transfer email from cPanel to Zimbra Collaboration 8.0</a></li>
<li><a href="../344040/index.html">Preparing your UI interface for Zabbix API using React component</a></li>
<li><a href="../344042/index.html">English phrases that should not be literally translated</a></li>
<li><a href="../344044/index.html">OpenDataScience and Mail.Ru Group open course materials on machine learning and new launch</a></li>
<li><a href="../344048/index.html">What is virtualization and how does a virtual server work?</a></li>
<li><a href="../344050/index.html">What's new in WebStorm 2017.3</a></li>
<li><a href="../344052/index.html">Short shoulder match</a></li>
<li><a href="../344054/index.html">Practical use of multiple bounds generic in Java</a></li>
<li><a href="../344056/index.html">Recover Huffman Tables in Intel ME 11.x</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>