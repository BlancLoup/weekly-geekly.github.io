<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wi-Fi networks: penetration and protection. 3) WPA. OpenCL / CUDA. Pick statistics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Basta karapuziki, ended dancing. 

 In the previous part, we examined in detail the ‚Äúcheat‚Äù methods of circumventing ‚Äúprotection‚Äù (hiding SSID, MAC fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wi-Fi networks: penetration and protection. 3) WPA. OpenCL / CUDA. Pick statistics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fff/44e/851/fff44e8510a0569e06809746219fd2c2.jpg" height="250"><br><br>  <s>Basta karapuziki, ended dancing.</s> <br><br>  In the <a href="http://habrahabr.ru/post/225483/">previous part,</a> we examined in detail the ‚Äúcheat‚Äù methods of circumventing ‚Äúprotection‚Äù (hiding SSID, MAC filtering) and protection (WPS) of wireless networks.  And although it works in half the cases, and sometimes more often, once the games end and you have to take on heavy artillery.  It is here between your personal life and the hacker that‚Äôs the weakest link: the password from the WPA network. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article will show the interception of the client-access handshake, the search of passwords using both the CPU and the GP, and in addition, summary statistics on speeds on ordinary single systems, EC2 clusters and data on various types of modern GPUs.  Almost all of them are supported by my own experiences. <br><br>  By the end of the article, you will understand why a lazy 20-digit password from <b>az</b> letters is more resistant to a pair of suns than a furious 8-digit, <i>even using all 256 range values</i> . <br><br>  <b>Table of contents:</b> <br>  <b>1)</b> <a href="http://habrahabr.ru/post/224955/">materiel</a> <br>  <b>2)</b> <a href="http://habrahabr.ru/post/225483/">Kali.</a>  <a href="http://habrahabr.ru/post/225483/">Hiding SSID.</a>  <a href="http://habrahabr.ru/post/225483/">MAC filtering.</a>  <a href="http://habrahabr.ru/post/225483/">WPS</a> <br>  <b>3)</b> WPA.  OpenCL / CUDA.  Pick statistics <br><a name="habracut"></a><br><br><h4>  PMK, PTK, <s>RPG</s> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/3ba/2b2/e1b/3ba2b2e1bf5b70862d77fbe44da8ef73.jpg" height="250"><br><br>  As always, let's start with the theory.  Strictly speaking, we do not need it to pick up passwords, and who are too lazy - they can skip this section <a href="https://habr.com/ru/post/226431/">to practice</a> .  However, in my opinion, knowing how client authentication and data encryption occur is very useful and will explain all the difficulties that we, as an attacker, experience when trying to hack this protocol.  A more detailed description in plain English with analysis of the formats of all authorization packages can be found <a href="http://etutorials.org/Networking/802.11%2Bsecurity.%2Bwi-fi%2Bprotected%2Baccess%2Band%2B802.11i/Part%2BII%2BThe%2BDesign%2Bof%2BWi-Fi%2BSecurity/Chapter%2B10.%2BWPA%2Band%2BRSN%2BKey%2BHierarchy/Details%2Bof%2BKey%2BDerivation%2Bfor%2BWPA/">here</a> . <br><br>  WPA and WPA2 (the first is based on the IEEE draft, the second on the final version, but in our case, both can be considered synonymous) use a rather clever key exchange scheme.  Rather, their <i>nemena</i> .  As we remember in the <a href="http://habrahabr.ru/post/224955/">first part</a> , the weakest point in any protection is the transfer of keys, even encrypted ones - after all, a hacker can intercept these values ‚Äã‚Äãand try to select the initial key using them in offline mode, that is, in no way communicating with the access point or client. .  WPA developers have eliminated any exchange of encrypted and open passwords.  How it all works will be described below. <br><br>  Let's start from the end.  Suppose we want to send an encrypted data packet.  To do this, we need the data itself and the key, according to which an algorithm like AES (namely, it is used in the CCMP) transforms it into <s>something indigestible</s> encrypted form.  You can decrypt the data back by passing the encrypted string and the key that was used for encryption to the same algorithm. <br><br>  The easiest way is to use the password from the wireless network as a key.  However, this is fraught with serious problems: <br><br><ul><li>  <b>Too fast calculations</b> - if we know the initial bytes of the original data (and almost always it is, because at the beginning there is some standard header), then we can try to decrypt the intercepted packet, replacing different passwords and looking at the output - if it contains a similar header, then most likely we have found the original password. </li><li>  <b>Guarantee for life</b> - if somehow we know the password, we can decipher everything that was transmitted earlier and will be transmitted later, until the administrator changes the network key.  And as practice shows, even when changing a router, people usually put an old password on it, so hoping for their prudence is not, <i>um</i> , prudent. </li><li>  <b>Lack of protection from a curious neighbor</b> - if we can log in to the network, then nothing will prevent us from reading the packets of other clients and even arbitrarily replacing them, since the <s>slippers are one for all the</s> password used to encrypt our data is used for all other clients within this network </li></ul><br>  It is as if there were many, many doors between us and the end goal, each of which leads inwards.  The doors are the clients of the network, the ‚Äúinside‚Äù is the network itself.  If the same key fits all the doors, we can go through the next door and see what is happening there. <br><br>  The second and third problems are easily eliminated by adding a random value to the key, which changes every time a secure connection is launched and even during its operation.  The first is a very long key.  But then the question arises: <s>who will remember him</s> if it is not a person who enters it, how to get this long key from a short key (from the user), and not even subject to a brute force attack? <br><br>  There are two standard solutions for this: either imposing restrictions on the number of login attempts, or multiple encryption to slow down the process of obtaining the final string.  The first option is not suitable, as it is suitable for online attacks (usually on the login form on websites) and is useless when the hash itself is already ‚Äúleaked‚Äù.  But the second - just our case. <br><br>  However, there is a problem here: if we simply run a certain algorithm 10,000 times on our source line with a password, then the option is possible when the hacker creates a dictionary, having previously run the same algorithm on all possible combinations of passwords, and then all that remains is grab a handshake and see the hash in it on the table, which he has already managed to calculate.  If there is such a hash in the table, it means that there is also the source row from which it was calculated, and it is known to it.  And then the same table can be used to decrypt other data.  Such a table is called a rainbow table.  The technique gained particular popularity when selecting passwords in the stolen databases of old forum and other PHP engines. <br><br>  This is solved by adding a "salt" - a random or more or less unique string, which, even if the passwords themselves coincide, will make the calculated hashes be different. <br><br>  Let's see how the authors of the WPA standard have coped with these tasks: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b93/906/2bf/b939062bfde54745945d21cc6afce545.png" alt="Handshake encryption scheme"></div><br>  The diagram above reflects the processes occurring in parallel on both sides (the client and the access point), and not what is transmitted over the radio channel - this is important and more on that below.  Even before the start of the calculations, both the client and the TD already have the following data: <br><br><ul><li>  <b>The network password</b> , as specified by the administrator, is on scheme <b>12345678</b> ( <s>ay-ay-ay, what an irresponsible administrator</s> ) </li><li>  <b>Network name (SSID)</b> - similarly specified by the administrator - on the <b>mynet</b> scheme </li><li>  <b>The client's MAC address</b> is on the <b>FF: EE: DD: ...</b> </li><li>  <b>The MAC address of the access point (BSSID)</b> is on the <b>map 11:22:33: ...</b> </li></ul><br>  It all starts with the fact that the ‚Äúshort password‚Äù (from the user) is converted into a longer key with the addition of the <s>secret ingredient of the</s> name of the wireless network - PBKDF is used for this, which can be equated to calculating the hash using SHA-1 4096 times in a row (if you think that this is a lot, then tell Microsoft about it - Word 2007 does it 50,000 times).  As a result, we get a 256-bit string, that is, 32 bytes.  Note that it is unique to different networks with the same password, if they have different names.  <b>An important conclusion:</b> always change the default network name and do not leave <i>ASUS, dlink, SKY, linksys</i> and other non-original names.  This will prevent attack on rainbow tables, making it difficult to iterate over 4096 iterations of SHA-1, which is a <i>lot</i> .  (To be fair, I have not heard of the use of such an attack on WPA, but why give a hacker an extra chance?) <br><br>  The string obtained above is called <b>PMK</b> (Pairwise Master Key).  It is static, that is, we should not encrypt data with its help, because it, like the password, does not change if the network name does not change - which means there is no difference in encryption for PMK and the password itself (this was mentioned in the problem the beginning).  Accordingly, in the same way as with a password, we should not ‚Äúshine‚Äù and PMK. <br><br>  Therefore, then we need to get a temporary, very long and very unique key that we would use specifically for this data session.  That is a temporary key.  That is, <b>PTK</b> (Pairwise Transient Key - short-term pair key).  For this, the same PBKDF algorithm is used, but 5 values ‚Äã‚Äãare passed to its input: <br><br><ol><li>  <b>PMK</b> - already calculated based on password and network name </li><li>  <b>A-Nonce</b> is just a random string sent by the access point to the client's request for connection (the very first packet during authorization) </li><li>  <b>S-Nonce</b> is another random string, but transmitted by the client to the TD in the next packet. </li><li>  <b>Access Point BSSID (MAC Address)</b> </li><li>  <b>Client MAC address</b> </li></ol><br>  So, having connected 5 values ‚Äã‚Äãin line and having driven them 4096 times through SHA-1 we received 256-bit PTK.  It will be used to encrypt all data from the client to the TD and vice versa. <br><br>  The last step is to check that the client actually has the correct password to the network, because of which everything is started.  You did not forget that the described manipulations occur on both sides independently and without interaction with each other, except for sending two nonce?  In this case, having different source data, the parties will receive different PTKs, and if, say, the client encrypts its traffic and sends it to the access point, it will not be able to decrypt it because its PTK is different from the key that the client has encrypted .  Different ‚Äúinitial data‚Äù here is, of course, first of all a password from the network, as it comes from an unstable element - a person, whereas MAC-addresses, a network name, etc. comes from ‚Äúhardware‚Äù, which is usually negotiated without problems. <br><br>  To check the transmitted data packet, a <b>MIC</b> is added to it - the Message Integrity Code, or the message integrity code.  In WPA, HMAC-MD5 (a kind of well-known MD5) is used to calculate it.  By the way, everyone is familiar with CRC32 - this is another algorithm for such purposes, it is often used to check files in the archive.  The resulting code is also called the <i>hash sum</i> . <br><br>  The idea is that by submitting a hash function (MD5, CRC, SHA and others) to the input of any data stream of arbitrary length, we get a certain output line that will be unique to this data stream.  Naturally, 100% uniqueness is impossible - if the output string is 4 bytes, then, with all the desire, it will not be able to accommodate all possible input combinations.  However, the algorithm is designed in such a way that we can‚Äôt find out what other lines can produce exactly the same hash (in fact, for weak algorithms like CRC this isn‚Äôt so; they are used to check data for accidental damage, and not intentional fabrication ). <br><br>  Accordingly, let us imagine that we need to send line <code>12345</code> and at the same time allow the receiving party to check that the line has not changed during the transfer.  To do this, we add its own hash to it: <br><br><pre> <code class="bash hljs">input = 1 2 3 4 5 sha1(1 2 3 4 5) = 8cb2237d0679ca88db6464eac60da96345513964 output = 1 2 3 4 5 | 8c b2 23 7d 06 79 ca 88 db 64 64 ea c6 0d a9 63 45 51 39 64</code> </pre><br>  When receiving the device cuts off the hash from the received message (after the "|"), calculates the hash sum for what was left, and compares both parts.  We agreed - it means that no clever pens to the data did not touch. <br><br>  ... But, of course, it's not that simple.  It is easy to see that knowing the algorithm for calculating the hash sum, an attacker can change the message, calculate its new amount and replace the old one with a new one.  What to do?  <s>And burn it all with a blue flame!</s>  And we will add ‚Äúsalt‚Äù again - a value that the receiving party knows, but the hacker does not know.  Then it will not be able to calculate the new hash. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b93/906/2bf/b939062bfde54745945d21cc6afce545.png" alt="Handshake encryption scheme"></div><br>  Let's look at this scheme again, this time we are interested in the last line.  <b>The MIC</b> is composed of <b>PTK</b> and the byte stream of the message itself.  <b>PTK</b> is our ‚Äúsalt‚Äù (as we remember, <b>PTK is</b> used to encrypt the stream itself, and now also to calculate its hash sum, that is, <b>MIC</b> ).  Stream and <b>PTK</b> are transmitted to HMAC-MD5 and the resulting hash is called <b>MIC</b> .  It is transmitted along with the message to the receiving side, which decodes the packet, calculates its <b>MIC</b> and if this <b>MIC</b> is different from the one found in the packet itself - it considers that someone got into the transmission process or simply was not flying weather, and discards this package. <br><br>  And now attention: how can we understand that the client has the correct password to the network and, as a result, has calculated the correct PTK, without transferring this PTK itself?  Simple: try to encrypt the first message on one side and see if it can be decrypted on the other.  If identical PTKs were used, then the received MIC will coincide with the transmitted when decrypting.  If different - MIC does not converge, as a result, PTK were different, as a result, PMK were different, and, as a result, the initial passwords were also different. <br><br>  Finally, to consolidate - a simplified scheme of what, in fact, is transmitted in open form over the radio channel during a handshake. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/e2c/f30/112e2cf303934ee9ed529c07245613a5.png"></div><br>  As you can see, of all the more or less private data, the tricky guys in IEEE have managed to transfer one MIC, which is also transmitted already encrypted using PTK. <br><br>  <s><b>Caramba!</b></s> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d9/64b/8bf/4d964b8bf8c5d9d7f605e87540be6f11.jpg"><br>  ( <a href="http://www.3dtotal.com/index_gallery_detailed2.php%3Fid%3D4810">Original art</a> .) <br><br><h4>  What to do, Semyonitch? </h4><br>  I hope my brief review has shed some light on what black magic tools like <b>aircrack-ng</b> and <b>hashcat use</b> when trying to determine the password in a handshake.  As we now know, they need to unwind the whole chain, having only the hash sum of one of the packages (MIC) in their hands.  Namely, do the following: <br><br><ol><li>  The first step is to calculate the network master key - <b>PMK</b> .  To do this, take the password and network name.  The last one is taken from the intercepted packets of a handshake (see below), and the first one can be taken from the dictionary one by one or go through all the available key space ‚Äúhead on‚Äù, <s>but only if you are a Jedi and have special street magic in the form of a pair of GPUs</s> . </li><li>  Next, the <b>PTK</b> is calculated - the hash sum from the received PMK (above), the client's MAC addresses and APs, and random nonce strings from them (taken from the intercepted packets). </li><li>  Finally, for a packet transmitted from the MIC, the MIC is calculated based on the PTK received above, the transmitted MIC is ignored (since it depends on the entire message, including the MIC itself, this field is set to 0 before the calculations, otherwise it is impossible to calculate amount, without knowing the MIC, to calculate which you need to know this amount). </li><li>  Both MICs are <b>compared</b> - if they match - the password is found (PTK is correct&gt; PMK is correct&gt; the password is correct), if not, <i>go to line 1</i> </li></ol><br>  Thus, each iteration requires at least 8192 calculations of SHA-1, which is 3 times slower than MD5.  This is a very costly process.  And what do we get in the end? <br><br>  But in the end - only the original password and PTK of that hapless client, whose authentication we intercepted.  This means that we will not be able to read the flows of other clients - they have different PTKs.  We will not be able to read the data that this client transmitted before it connected - it also had another PTK.  We will not even be able to read what he will transmit after the next time he connects - the PTK will change again! <br><br>  This is a very important conclusion, which in the fourth article of the cycle will be very useful for us when intercepting packets in Wireshark.  There, we will have to not only get the password from the network, as described in this article, but also intercept the handshakes of all the clients we want to listen to (or use ARP spoofing, but this is an attack on another level).  That is still a job. <br><br>  By the way, the experience with PTK is the son of difficult errors in WEP, where the same key has always been used to encrypt all client flows. <br><br><a name="lazy"></a><br><h4>  To arms! </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/fce/81f/0e3/fce81f0e3068d5e2f3282516b37fde94.jpg"><br><br>  With theory everything, I promise.  Now only practice - from here to lunch. <br><br>  So, once again: our task is to intercept the first 4 packets exchanged between the client and the access point (2 on each side) when establishing a connection.  In sum, they are called handshake.  After them, an already encrypted data transfer begins, from which nothing can be pulled out of us.  By the way, these packets are part of the EAP protocol (or EAPOL), and under this name they appear in Wireshark (see the next article in the series). <br><br>  Having intercepted them, we can save them to ourselves and then conduct a offline attack ‚Äî that is, try to pick up the original password to the network, alternately trying different passwords to generate PMK&gt; PTK&gt; MIC and comparing the latter with the one that was actually transmitted has been described above. <br><br>  Interception is done using <b>airodump-ng</b> , with which we are <a href="http://habrahabr.ru/post/225483/">already familiar</a> with the second part.  You can play with the parameters, it was written about them there, but in general, the call looks like this: <br><pre> <code class="bash hljs">airodump-ng mon0 -c 5 --bssid AP_BSSID -w caps</code> </pre><br>  Before that, you need to transfer your card to the ‚Äúhacker mode‚Äù (monitor mode) and do all other manipulations (changing the MAC, txpower, etc. - see the <a href="http://habrahabr.ru/post/225483/">second part</a> ). <br><br>  In the command above, we use the interface under the identifier <code>mon0</code> to collect packets of the attacked network on channel 5, which has the MAC specified after <code>--bssid</code> , saving the packets to the <code>caps-NN.cap</code> (by default, the standard <b>libpcap</b> format is used, which is supported by very many libraries on all OS, including Wireshark).  <b>NN</b> will be replaced with a unique number, so when you restart <b>airodump-ng</b> with the same parameters, the old files will not be overwritten, but will have names like <code>cap-01.cap</code> and on. <br><br>  Assume that the network attacked by us has a BSSID <code>4F:B1:A4:05:5C:21</code> and is on channel 11. Then we do this: <br><pre> <code class="bash hljs">airodump-ng mon0 -c 11 --bssid 4F:B1:A4:05:5C:21 -w caps</code> </pre><br>  After launch, the familiar console window with two tables will open.  Let's leave it hanging until someone connects to our network ... <br><br>  But we can speed up this process!  The reader remembers the fact that we can disable existing clients and force them to re-send authentication data - very useful for uncomplicated hackers like us.  <a href="http://habrahabr.ru/post/225483/">Already familiar</a> <b>aireplay-ng</b> will be happy to help us: <br><pre> <code class="bash hljs">aireplay-ng mon0 -0 5 -a 4F:B1:A4:05:5C:21 -c 5B:23:15:00:C8:57</code> </pre><br>  <code>5B:23:15:00:C8:57</code> - the MAC address of the client, which we learned from the table previously run <b>airodump-ng</b> . <br><br>  If everything is done correctly, <b>aireplay-ng</b> will display 5 lines of the form <code>Sending directed deauth</code> , and in the window with <b>airodump-ng</b> we should observe a rapidly increasing number of ‚Äúlost‚Äù packets (in the <b>Lost</b> column).  It can go to thousands. <br><br>  After that, our dear client, if he was within range of our transmitter and if it was active (sometimes the device remains connected to the network, but does not use it, and disconnecting does not force it to reconnect), will immediately start authorization again and we will catch these packets , in the upper right corner, <b>airodump-ng</b> will triumphantly say <code>[ WPA handshake: 4F:B1:A4:05:5C:21 ]</code> (the MAC address of the network whose handshake was intercepted). <br><br>  If that happens - the attack is successful, <b>airodump-ng</b> can be closed, copy the resulting <code>caps-01.cap</code> to a USB flash drive <s>and unwind</s> .  You know, we have keys in our hands ... <br><br>  Encrypted. <br><br><h5>  Password selection </h5><br>  The first part with the interception of a handshake is usually the easiest, especially in networks with many active clients.  We received packages with <b>MIC</b> and other authorization data.  Now we need to find out which of our keys will fit this lock? <br><br>  Selection requires large computing power and for their sake you can rent an EC2 cluster or even build your ATI farm.  And you can simply drive the packages through the dictionary of the most common passwords on a regular CPU with the hope that the GSSB user.  The latter, by the way, may very well be - on the 11 networks I tested, one used the password "12345678", the second one - "123456789", and five others - passwords of 8 digits, which are cracked per day on the average system.  At the same time, of the remaining 4, three were hacked for another two days via WPS (see the <a href="http://habrahabr.ru/post/225483/">second part</a> ).  <s>And the last one was mine</s> (actually, no, but I never managed to find her password.) <br><br>  Do not repeat such mistakes. <br><br>  Another common option is a phone number (digits only).  Especially important for networks of companies, shops, cafes.  Typically, such a "password" hangs right at the entrance to the institution.  Generate all numbers, if the code is known, it is possible through <code>crunch 10 10 -t 063%%%%%%%</code> ( <a href="https://habrahabr.ru/users/rasta/" class="user_link">RaSta</a> ). <br><br><h6>  <b>aircrack-ng</b> </h6><br>  The easiest way to search.  <b>aircrack-ng</b> uses only the CPU, but perfectly supports multithreading.  She enumerates dictionary values ‚Äã‚Äãfor WPA networks (she also knows how to hack WEP). <br><br>  Kali comes with a set of dictionaries in <code>/usr/share/wordlists/</code> , but if you wish, you can easily find them on the Internet of any size - from megabytes to tens of gigabytes.  Pretty good compilation - <code>WPA-PSK Wordlist 3 Final</code> , as well as a generated dictionary of all combinations of 8-digit numeric passwords, which is obtained with the help of <code>crunch 8 8 1234567890</code> <br><br><pre> <code class="bash hljs">aircrack-ng -w /usr/share/wordlists/fasttrack.txt caps-01.cap</code> </pre><br>  <code>/usr/share/wordlists/fasttrack.txt</code> (included with Kali) - the path to the dictionary file with passwords, one password per line.  Lines shorter than 8 characters will be ignored, as this is the minimum length for WPA. <br><br>  On my i7 3840QM 4x3.8 GHz <b>aircrack-ng</b> squeezes ~ 4700 passwords per second.  Thus, we can calculate how much time is required to complete a search of all possible combinations of 8 digits: <br><pre> <code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">8</span></span>) / (<span class="hljs-number"><span class="hljs-number">4700</span></span> * 3600) = 5,91 </code> </pre><br>  Check the speed of selection without proper selection (benchmark), you can: <br><pre> <code class="bash hljs">aircrack-ng -S <span class="hljs-comment"><span class="hljs-comment"># 4713 k/s</span></span></code> </pre><br>  And so you can see how many nuclei will be used in the selection: <br><pre> <code class="bash hljs">aircrack-ng -u <span class="hljs-comment"><span class="hljs-comment"># No CPU detected: 8 (SSE2 available)</span></span></code> </pre><br>  In total, in 6 hours you can sort out 10 million passwords on a high-end mobile CPU.  A digital password of such length should not be considered as a serious protection, and not even so - using GP (GPU), which gives tens and hundreds of times greater speed, such a password will break in minutes.  About this below. <br><br>  If the attack is successful, that is, <b>aircrack-ng has</b> found the password, then it will finish its work and the joyful <code>KEY FOUND! [ ... ]</code> will be displayed on the screen <code>KEY FOUND! [ ... ]</code>  <code>KEY FOUND! [ ... ]</code> - write it down and use it to enter the network.  You can also write the found password to the file via <b>-l pass.txt</b> , which is useful when running a search in the background as <code>aircrack-ng ... -l pass.txt &amp;</code> <br><br>  Explanation of the formula above: <br><br><ul><li>  <b>10 ^ 8</b> - 10 to the power of 8, the number of possible combinations;  computed as <code>__ ^ _</code> .  For example, for a 6-digit password from lowercase Latin characters would be 26 <sup>6</sup> = 308 915 776 combinations.  By the way, this clearly shows that the password length is much more important than the possible number of characters in it: remembering " <code>this weirdo voodoo</code> " is much simpler than " <code>0.o@&amp;z%_</code> " - whereas the combinations of the first 10 <sup>25</sup> more (ten and 24 zero). </li><li>  <b>4700</b> - number of password comparisons per second (brute force) </li><li>  <b>3600</b> - bringing the result of division from passwords per second to passwords per hour (60 seconds * 60 minutes) </li></ul><br>  More calculations to compare: <br><pre> <code class="hljs markdown"> (26^8) / (4700 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24) = 514    8-   az (10^10) / (4700 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24) = 24,6   10-   (26^10) / (4700 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 952   10-   az (10^12) / (4700 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 6,7   12-   (10^14) / (4700 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 * 365) = 674,6   14-  </code> </pre><br>  Statistics for longer lines it makes no sense to calculate, if we are talking only about the CPU.  But before drawing conclusions, wait until we get acquainted with ATI goliaths. <br><br><h5>  The world went crazy or GPGPU - "GP of general purpose" </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/702/7ea/765/7027ea7657aab04214a92240a4ec0c2d.jpg"><br><br>  The times when the games were warm and tube-based, and the graphics processors <s>had 4 MB of memory</s> used for their intended purpose, are long gone.  Today they seem to be used for anything, but not for games.  At least I have not seen gamers with the 8-rzyu R290X in one system, but the "miners", "folders" and other geeks <a href="http://youtu.be/wFuTeDWXiLw">with whole racks</a> - more than enough.  Why is that? <br><br>  Graphics chips are fundamentally different in their design features from the CPU architecture.  If we are talking about 4, 8, 16 cores with the CPU (we don‚Äôt take a server), then in the case of a GP we are talking about thousands of independent cores.  When processing graphics, you need to quickly perform operations on large arrays - matrices.  And it is precisely such operations that are needed in cryptography.  Therefore, GP can be used to calculate hashes - or the production of cryptocurrencies. <br><br>  GP can be assembled together within one system, and systems into clusters, creating ‚Äúfarms‚Äù.  With a huge performance gap from conventional CPUs, it is much more efficient to build a farm of 10 systems with 4 GPs than of 10 systems with 4 CPUs. <br><br>  Only ASIC and FPGAs ‚Äî special devices that can be programmed to perform certain calculations ‚Äî can give greater performance, but you need to mess with and write separate software, and the GP and SDK for them have been around for a long time and start writing for them relatively easily.  ATI-shny cards look especially attractive, which, due to their architecture, are an order of magnitude superior to nVidia cards specifically for these tasks, and at the same time much cheaper.  <s>No other way than AMD engineers themselves indulge with LTC.</s> <br><br>  In the context of our task, the selection of passwords using GPs can be done by two wonderful programs: <b>hashcat</b> and <b>pyrit</b> . <br><br>  <b><a href="http://hashcat.net/oclhashcat/">hashcat</a></b> is a closed, free utility for lightning-fast computation of hashes of various forms, using various algorithms (MD5, SHA, WPA and a couple more dozen), applying rules to vocabulary words and even adding salt.  In my opinion this is the best that exists today.  A little upsetting the closeness of the project, but the author can be understood - this is a big job. <br><br>  <code>hashcat</code> consists of three programs: <b>hashcat</b> (it doesn‚Äôt use GP and is comparable in speed to my tests with <b>pyrit</b> and a little slower than <b>aircrack-ng</b> , which is generally the fastest on the CPU);  <b>oclhashcat</b> for OpenCL (SDK from ATI) and <b>cudaHashcat</b> (nVidia).  The last two are identical in capabilities, but must match the manufacturer of your GP.  Before their work, you need to install the driver and the SDK, since without them the GPU cores will not be recognized. <br><br>  <b><a href="https://code.google.com/p/pyrit/">pyrit</a></b> is an open source tool for picking WPA keys in Python.  In general, a pleasant program, fits perfectly for its purposes.  It also has versions for the CPU and both GPU manufacturers, however it only works with WPA.  Unlike oclhashcat, pyrit uses both the CPU and the GP, while oclhashcat uses only the GP.  The author of the latter explains this by the fact that the gain is minimal and there are a lot of programming costs. <br><br><h5>  Driver installation </h5><br>  So, let's see how we use this toolkit.  The mechanism described below was discovered after many hours of dealing with Kali, CUDA and the Pyrit source codes, so I hope that it will save this time for you.  Everything was successfully tested on <code>Kali 1.0.7 x64</code> version <code>Kali 1.0.7 x64</code> and versions <code>cuda_6.0.37_linux_64</code> and <code>NVIDIA-Linux-x86_64-331.67</code> .  The laptop uses Optimus (technology from nVidia to switch between the integrated GP from Intel).  The Kali documentation has a <a href="http://docs.kali.org/general-use/install-nvidia-drivers-on-kali-linux">page about installing nVidia drivers</a> - it can also come in handy. <br><br>  Initially, Kali does not have software installed for working with GP, as today there are two competing standards (OpenCL from AMD and CUDA from nVidia), and in addition, CUDA uses closed drivers, not standard <b>nouveau</b> .  So you have to install everything yourself. <br><br>  First, let's install the Linux kernel source headers: <br><pre> <code class="bash hljs">apt-get install linux-headers-`uname -r`</code> </pre><br>  Next, download the drivers for nVidia and SDK for CUDA.  Take links to RUN-files from <a href="http://www.nvidia.com/Download/index.aspx%3Flang%3Den-us">the nVidia website</a> and from <a href="https://developer.nvidia.com/cuda-downloads">the CUDA section</a> . <br><pre> <code class="bash hljs">wget http://.../NVIDIA-Linux-x86_64-331.67.run wget http://.../cuda_6.0.37_linux_64.run</code> </pre><br>  Next we need to exit the window manager (X).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this mysterious phrase (in the manuals - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shutdown the X server / session</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) literally means the following:</font></font><br><pre> <code class="bash hljs">shutdown 0</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will transfer the system to maintenance / single user mode. </font><font style="vertical-align: inherit;">Kali will ask for a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">root</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> password </font><font style="vertical-align: inherit;">or press </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ctrl + D</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the latter will restart GNOME, which we do not need at all. </font><font style="vertical-align: inherit;">Enter the password, which is the default </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and get into the console. </font><font style="vertical-align: inherit;">There we perform:</font></font><br><pre> <code class="bash hljs">modprobe -r nouveau chmod +x *.run ./NVIDIA-Linux-x86_64-331.67.run ./cuda_6.0.37_linux_64.run</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case, when installing drivers (the penultimate command): </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We select </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when the installer tells us that we should be in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runlevel 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><font style="vertical-align: inherit;">I did not manage </font><font style="vertical-align: inherit;">to go to it through </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telinit 3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as he was still cursing, but it didn‚Äôt affect further normal operation)</font></font></li><li>  <b>No</b>     32-  ( 64- ) </li><li>        nVidia    (  <b>nouveau</b> ) ‚Äî     X         ,   <b>No</b> </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the CUDA installer, we answer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when he wants to install the nVidia driver (the second question after accepting the license) - I don‚Äôt understand this moment, but installing the driver through it always ends with installation </font></font><code>Installation failed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, while putting the same drivers through the previously downloaded The first installer succeeds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All other questions of the CUDA installer are answered with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Samples can be set, you can not (occupy about 230 MB). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To check the performance of the delivered CUDA, you can run </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nvcc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (located in </font></font><code>/usr/local/cuda/bin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - if it passed without errors, then everything works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If during the installation the wired network interface is disconnected (sometimes) - it can be raised like this:</font></font><br><pre> <code class="bash hljs">ifconfig eth0 up dhclient eth0</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, if something is wrong with the installation and you want to return the old driver to reopen GNOME, first load </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> back </font><font style="vertical-align: inherit;">and then press </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ctrl + D</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .:</font></font><br><pre> <code class="bash hljs">modprobe nouveau</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I recommend carrying out all the driver manipulations after loading the OS into read only (see the second part), since damaging the driver is very easy and then losing the normal desktop and you have to get by with the console in search of a problem. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installing </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpyrit_cuda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oclhashcat</font></font></b> </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can install the actual utilities themselves. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashcat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is put through </font></font><code>apt-get install -y oclhashcat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for both versions of OpenCL / CUDA), and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is built from source (note: use the latest version in </font></font><code>trunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since there is a bug in the current stable version that may fail to compile on some nVidia, as it was with my card). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Install </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (if you have OpenCL - see the documentation on </font></font><a href="https://code.google.com/p/pyrit/wiki/Installation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the project site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><pre> <code class="bash hljs">apt-get install -y libpcap-dev python-scapy svn checkout http://pyrit.googlecode.com/svn/trunk/ psrc <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> psrc/pyrit sudo python setup.py build sudo python setup.py install <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../cpyrit_cuda sudo python setup.py build sudo python setup.py install</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The build is complete. </font><font style="vertical-align: inherit;">See if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> found </font><font style="vertical-align: inherit;">our cards:</font></font><br><pre> <code class="bash hljs">pyrit list_cores</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If successful, it will be displayed </font></font><code>#0 GPU ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- one line for each core, plus one line for each CPU core (though, on my system, one processor core was ‚Äúeaten up‚Äù by the GPU ‚Äî perhaps </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not support more than 8 threads). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we can run the test and in 10-20 seconds find out the approximate speed of the search using the capabilities of the GP:</font></font><br><pre> <code class="bash hljs">pyrit benchmark</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On my system, both </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashcat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> give out 10,500 (GP) + 4,000 (CPU) passwords per second, which once again confirms the unsuitability of nVidia for such calculations (I have a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce GTX 675MX</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">A similar mobile card from ATI issues about 40,000 p / s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, let's run brute force on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><pre> <code class="bash hljs">pyrit -r caps-01.cap -e MYNET -i /usr/share/wordlist/fasttrack.txt attack_passthrough</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters are similar to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aircrack-ng</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When the match is found, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will exit and the key will be visible on the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If at start of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashcat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> warnings about ACPI appear - they can be ignored if calculations go normally. I have them for 10-15 pieces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we want to go through all the digital passwords of a certain length - this can be done in two ways: on the fly or by generating a dictionary on the disk. Kali has several utilities for generating dictionaries, one of them is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crunch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><pre> <code class="bash hljs">crunch 8 10 0123456789 | pyrit -r caps.cap -e MYNET -i - attack_passthrough</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i -</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> says </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pyrit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to read passwords from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stdin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 10</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the minimum and maximum lengths of the generated </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crunch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> words, consisting of characters </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0123456789</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It does not make sense to generate a dictionary with saving to disk, since the file will be 112 GB and can be saved, since the generation will not affect the speed of the search on the fly.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Running hashcat </font></font></h5><br><img src="https://habrastorage.org/getpro/habr/post_images/86b/da7/16a/86bda716ab2640215ad977567f4b3388.jpg" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashcat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a more universal utility, the syntax of its parameters is more complicated, and besides, it takes as input not a standard </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libpcap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">(which we previously saved via </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">airodump-ng</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), but our own </font></font><code>*.hccap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process of converting from .cap to .hccap is described in the </font></font><a href="http://hashcat.net/wiki/doku.php%3Fid%3Dcracking_wpawpa2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is done simply: first, we remove all packages from the file except handshakes, and then convert the remaining ones to .hccap: The site also has an </font></font><a href="http://hashcat.net/cap2hccap/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online converter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that accepts files up to 5 MB in size - if you are not very concerned about privacy, you can use and them (he does the same thing as described below).</font></font><br><br><pre> <code class="bash hljs">wpaclean clean.cap caps-01.cap aircrack-ng clean.cap -J hashcat</code> </pre><br>    <code>hashcat.hccap</code>   <code>hashcat</code> , <code>oclhashcat</code>  <code>cudahashcat</code> . , wpaclean (   Kali)      ,      <a href="http://www.exploresecurity.com/%3Fp%3D14"> </a> .      ,      (    ,  <code>aircrack</code> , <code>hashcat</code> , <code>pyrit</code>  .    ,    ,        ). <br><br>     <b>hashcat</b>     <code>oclhashcat -h</code>   <a href="http://hashcat.net/wiki/">  </a> .  ‚Äî   . <br><br>        ( <b>-m2500</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicates the selection of the key in the WPA handshake, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-a3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sets the selection mode for the mask, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? d ...</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the mask for generating words ( </font></font><code>?d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denotes characters 0-9, and eight </font></font><code>?d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a row denote 8 digits one by one):</font></font><br><pre> <code class="bash hljs">oclhashcat -m2500 -a3 caps.hccap ?d?d?d?d?d?d?d?d</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, but brute force by dictionary ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-a0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be omitted):</font></font><br><pre> <code class="bash hljs">oclhashcat -m2500 -a0 caps.hccap /usr/share/wordlists/fasttrack.txt</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so we run a simple search in a row ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-a3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) passwords for hashes in the file </font></font><code>~/hashes.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculated by the algorithm </font></font><code>sha1(+)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-m110</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and the six-digit passwords are in the form </font></font><code>[AZ] [A-Z0-9] [A-Z0-9] [A-Z0-9] [A-Z0-9] [0-9]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="bash hljs">oclhashcat -m110 -a3 -1?d?l ~/hashes.txt ?u?1?1?1?1?d</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, you can run a speed test this way: </font></font><br><pre> <code class="bash hljs">oclhashcat -b</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Found passwords will be displayed on the screen, as well as recorded in a file </font></font><code>/usr/share/hashcat/hashcat.pot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or for GP versions - c </font></font><code>/usr/share/oclhashcat/hashcat.pot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While the utility is working, in the terminal you can press </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to display the current status (speed, remaining% and others). </font><font style="vertical-align: inherit;">If you click on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the program will stop, save the state, and continue from the same place using the same command line with the added </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-s 1234</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where the number indicates the session number (it is displayed at the moment of exit from the utility).</font></font><br><br><h5>  Amazon EC2 </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/ddd/5fe/0e3/ddd5fe0e3e17d727cf6a502c2e9f916f.png" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For interest, I drove the selection of WPA-keys on the two most powerful AWS clusters: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cc2.8xlarge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (32 CPU cores) and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g2.2xlarge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1 nVidia Tesla and 8 CPU cores):</font></font><br><br><pre> <code class="hljs apache"><span class="hljs-attribute"><span class="hljs-attribute">g2</span></span>.2xlarge = 22000 k/s<span class="hljs-meta"><span class="hljs-meta"> [pyrit+cuda] cc2.8xlarge = 14000 k/s [aircrack-ng] 13500 k/s [pyrit]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, even the ultra-expensive card from nVidia does not cope with the task of calculating hashes in the same way as the average GPs from ATI. In fact, Tesla gives even lower speed than regular GTX. It is understandable - it has a completely different purpose. And that is why ATI fit so well in this business - an interesting question ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, of course, 32 server cores are not able to contend even with Tesla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why AMD is so superior to similar solutions nVidia? The point is more stream processors (cores), as a result, faster operations on integer values ‚Äã‚Äã(not floating-point numbers that are not needed in cryptography) and in particular - thanks to special instructions that can be used for encryption ( </font></font><code>BIT_SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>BFI_INT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who wants to try it yourself is installed</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aircrack-ng</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on EC2 with Debian or Ubuntu like this:</font></font><br><pre> <code class="bash hljs">sudo yum install gcc libnl-devel openssl-devel wget http://download.aircrack-ng.org/aircrack-ng-1.2-beta3.tar.gz tar xf aircrack-ng-1.2-beta3.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> aircrack-ng-1.2-beta3 sudo make install</code> </pre><br><h4>  Statistics </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, looking at how the CPU and the GP cope with the brute force of passwords, you can draw conclusions. Below are statistics on some modern video cards for today (June 2014). The data was obtained for several of my systems, from comrade </font></font><a href="https://habrahabr.ru/users/chem_ua/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chem_ua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and open sources ( </font></font><a href="http://www.golubev.com/gpuest.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">golubev.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://hashcat.net/oclhashcat/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pages oclhashcat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://hashcat.net/forum"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). You can compare the capabilities of different cards relative to each other on the </font></font><a href="https://litecoin.info/Mining_hardware_comparison"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extensive table on the Litecoin wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and similar ones in </font></font><a href="https://en.bitcoin.it/wiki/Mining_hardware_comparison"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitcoin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers are approximate, depending on the system configuration, OS, temperature / cooling and overclocking. If you have your data - share in the comments or in </font></font><a href="http://habrahabr.ru/conversations/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">person</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I will add them to the table. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kh / s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of calculations and comparisons of passwords per second in thousands (10 kh / s = 10 000 passwords per second). </font></font><br><br><pre> <code class="hljs markdown">nVidia 670 24 kh/s nVidia 675MX 11 kh/s nVidia 780M 42 kh/s nVidia 580 47 kh/s nVidia Tesla K20 85 kh/s nVidia 750 Ti 55 kh/s nVidia Titan Black 108 kh/s AMD 280X 160 kh/s AMD 290X 190 kh/s AMD 295X<span class="hljs-emphasis"><span class="hljs-emphasis">*2 203*</span></span>2 kh/s AMD 5870 101 kh/s AMD 5870 153 kh/s AMD 6870 72 kh/s AMD 6990 181 kh/s AMD 7970 128 kh/s AMD 7990 220 kh/s</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> although the numbers go off-scale even when comparing a low-cost GP (for example, 5870 for $ 90) with the results of the CPU, remember that, unlike the latter, graphics processors, and especially from AMD, consume ten times more electricity (for example, have a power supply of 0.75-1 kW for only two 290X). </font><font style="vertical-align: inherit;">So, before buying such a ‚Äúgenerator‚Äù, first calculate how much a monthly electricity bill will cost you, especially if you plan to overclock them. </font><font style="vertical-align: inherit;">Or look at the </font></font><a href="http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-750-ti/specifications"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750 Ti</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for which you need only 300 watts.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dry residue </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Familiarity with calculating hashes using GP allows us to understand </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how sad everything is,</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what the real price is for short and ‚Äúcomplex‚Äù passwords. </font><font style="vertical-align: inherit;">This applies not only to WPA - just PBKDF is subject to this less because of its resource intensity. </font><font style="vertical-align: inherit;">If we take the top bar for a single system today - 8 AMD 290X, which is about $ 3000 - it turns out 1.5 million WPA-hashes per second, or 94 billion MD5-hashes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the above-mentioned time-over figures for WPA look like this:</font></font><br><pre> <code class="hljs markdown"> (26^8) / (1500000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600) = 38,7    8-   az ( 514 ) (10^10) / (1500000 *</span></span> 3600) = 2   10-   ( 25 ) (26^10) / (1500000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 3   10-   az ( 952 ) (10^12) / (1500000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24) = 7,7   12-   ( 7 ) (10^14) / (1500000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 2,1   14-   ( 674 )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the numbers have changed dramatically. </font><font style="vertical-align: inherit;">Moreover, if we look at the strength of passwords with MD5 (which is calculated 61,000 times faster, and this is without rainbow-tables, which, however, are useless for long passwords because of their size):</font></font><br><br><pre> <code class="hljs 1c"> (<span class="hljs-number"><span class="hljs-number">26</span></span>^<span class="hljs-number"><span class="hljs-number">8</span></span>) / (<span class="hljs-number"><span class="hljs-number">94000000000</span></span>) = <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">8</span></span>-   az (<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">10</span></span>) / (<span class="hljs-number"><span class="hljs-number">94000000000</span></span>) = <span class="hljs-number"><span class="hljs-number">100</span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>-   (<span class="hljs-number"><span class="hljs-number">26</span></span>^<span class="hljs-number"><span class="hljs-number">10</span></span>) / (<span class="hljs-number"><span class="hljs-number">94000000000</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>) = <span class="hljs-number"><span class="hljs-number">25</span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>-   az (<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">12</span></span>) / (<span class="hljs-number"><span class="hljs-number">94000000000</span></span>) = <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>-   (<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">14</span></span>) / (<span class="hljs-number"><span class="hljs-number">94000000000</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>) = <span class="hljs-number"><span class="hljs-number">17</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>-  </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MD5 and SHA1 (which is only three times slower than the first) are still used by many sites to hash users' passwords, often without adding salt, although they do not change the situation too much. </font><font style="vertical-align: inherit;">Since we cannot vouch for the reliability of all sites where we register (especially with an example of a large website, Adobe), using digital passwords with a length of less than 20 characters (see below) or letters with a length of less than 14 is at least reckless. </font><font style="vertical-align: inherit;">And it's not even about adding parentheses and periods (which some sites are generally prohibited in passwords for some reason) - as you can see, the difference between 10-digit numeric and alphabetic passwords will extend the last of the latter for about half an hour.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So what to do? </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As they say, saving the father of Russian democracy is the work of democracy itself. </font><font style="vertical-align: inherit;">Let's see what happens if we add 4 characters to the password length:</font></font><br><br><pre> <code class="hljs markdown">(26^10) / (1500000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 3    10-   az (26^12) / (1500000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 2 017    12-   az (10^16) / (1500000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 211   16-   (10^18) / (1500000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 21 140   18-  </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And for MD5: </font></font><br><br><pre> <code class="hljs markdown">(26^12) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24) = 11,6    12-   az (10^16) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24) = 1   16-   (10^18) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24) = 123   18-   (26^16) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 14 710    16-   az (26^14) / (94000000000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 21,7    14-   az (26^16) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 <span class="hljs-bullet"><span class="hljs-bullet">* 365) = 14 710    16-   az (10^20) / (94000000000 *</span></span> 3600 <span class="hljs-bullet"><span class="hljs-bullet">* 24 *</span></span> 365) = 34   20-   (10^22) / (94000000000 <span class="hljs-bullet"><span class="hljs-bullet">* 3600 *</span></span> 24 * 365) = 3 373   22-  </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, even ‚Äúfast‚Äù MD5 with a length of 16 alphabetic characters does not make sense to break anymore. </font><font style="vertical-align: inherit;">Especially in the absence of "vocabulary" words of such length - if only we do not speak about </font></font><code>qwertyuiopasdfghjk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This idea - the importance of the length of the password, and not its content - is not new. </font><font style="vertical-align: inherit;">Three years ago, XKCD drew </font></font><a href="https://xkcd.com/936/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its historical strip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/81f/e91/efd81fe9129e3c2a631e314095ae023d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(‚ÄúAfter 20 years of constant effort, we finally succeeded in teaching people to invent difficult-to-remember passwords that are easily matched by a computer.‚Äù)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And in April, Stanford published </font></font><a href="http://habrahabr.ru/post/220949/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new requirements for passwords</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that come down to the fact that passwords are From 20, there are no requirements for the alphabet (it is not necessary to have numbers, letters in upper case, and so on).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/acd/d15/b54acdd152364e470722d43adf06d598.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With all this, the requirements of such organizations as Alfa-Bank look sad, where the password length is limited to 16 characters without allowing most of the special characters to appear. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is immediately clear why such passwords are needed. </font></font></s> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : in order not to leave the attacker a chance to pick a password for WPA, it is worthwhile to come up with a 12-character alphabetic password and if in the coming years a quantum computer will not be accessible to the masses, there is nothing to fear. Well, 16 characters are enough for passwords for websites and if they do not store them in clear text - whatever you think of, it will remain a secret. Until the next coming of computers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(A notable and unexpected example of a site that stores passwords in clear text is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ixbt.ru</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forum </font><font style="vertical-align: inherit;">: ‚Äú</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please keep in mind that your password will not be encrypted and can be viewed by the conference administrator. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"- so be vigilant!) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this the excursion into the jungle of calculations is over. </font><font style="vertical-align: inherit;">The next, probably the last article in the series is about listening to wireless network traffic after you entered it. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Did you like the article? </font><font style="vertical-align: inherit;">Was the handshake process clearly understood? </font><font style="vertical-align: inherit;">Were there any errors / inaccuracies in the description (for experts)? </font><font style="vertical-align: inherit;">Have something to share? </font><font style="vertical-align: inherit;">Waiting for your comments, which also speed up the writing of the next part!</font></font></i> <br><br>  <b>Table of contents:</b> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) </font></font></b> <a href="http://habrahabr.ru/post/224955/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">materiel </font></font></a> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) </font></font></b> <a href="http://habrahabr.ru/post/225483/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kali. </font><font style="vertical-align: inherit;">Hiding SSID. </font><font style="vertical-align: inherit;">MAC filtering. </font><font style="vertical-align: inherit;">WPS </font></font></a> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WPA. </font><font style="vertical-align: inherit;">OpenCL / CUDA. </font><font style="vertical-align: inherit;">Pick statistics</font></font></div><p>Source: <a href="https://habr.com/ru/post/226431/">https://habr.com/ru/post/226431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226421/index.html">Shadow rendering using Parallel-Split Shadow Mapping</a></li>
<li><a href="../226423/index.html">Launch Internet Explorer Developer Channel</a></li>
<li><a href="../226425/index.html">About encryption of referrers in Yandex</a></li>
<li><a href="../226427/index.html">The evolution of Microsoft web frameworks. ASP.NET vNext</a></li>
<li><a href="../226429/index.html">Amateur astronomy: a view from the inside of the community on hobbies and newcomers' rakes</a></li>
<li><a href="../226433/index.html">The digest of interesting news and materials from the world of PHP No. 42 (June 1 - 16, 2014)</a></li>
<li><a href="../226437/index.html">Nissan and BMW will join Tesla's plans to develop electric stations</a></li>
<li><a href="../226439/index.html">Creating audio plugin, part 6</a></li>
<li><a href="../226441/index.html">Service Locator and Branch By Abstraction - a super potion</a></li>
<li><a href="../226443/index.html">Paypal comes to Belarus and Moldova</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>