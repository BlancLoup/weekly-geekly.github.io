<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>It is not Android. Features of the development under Wear OS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On March 18, Google renamed the operating system for Android Wear wearable electronics and began distributing it under the name Wear OS to attract a n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>It is not Android. Features of the development under Wear OS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/fx/tg/jo/fxtgjom5ydqtwulfbhoahfynac0.png"><br><br>  On March 18, Google renamed the operating system for Android Wear wearable electronics and began distributing it under the name Wear OS to attract a new audience.  The company has published new <a href="https://designguidelines.withgoogle.com/wearos/">design guidelines</a> and updated <a href="https://developer.android.com/training/wearables/apps/index.html">documentation</a> .  When I started developing an application for watches, I did not find a single Russian-language publication on this topic.  Therefore, I want to share my experience and tell more about Wear OS, what it consists of and how to work with it.  All those who are not indifferent to mobile technologies, please under the cat. </p><a name="habracut"></a><br><p>  Starting from the version of Android Wear 2.0, the system has learned to work with Standalone Apps - completely independent wearable applications.  The user can set them from native Google Play directly to the clock.  Wear OS is a virtually independent system that still continues to work within the framework of the Google Services infrastructure, complementing it but not becoming attached to it. </p><br><h2 id="android-no-ne-ochen">  Android but not much </h2><br><p>  No matter how Google has positioned Wear OS, the platform is based on Android with all its features, charms and flaws.  Therefore, if you are already familiar with Android-development, then difficulties with Wear OS should not arise.  Wear OS hardly differs from its ‚Äúbig brother‚Äù, except for the absence of some packages: </p><br><ul><li>  android.webkit </li><li>  android.print </li><li>  android.app.backup </li><li>  android.appwidget </li><li>  android.hardware.usb </li></ul><br><p>  Yes, we will not be able to see the browser on the clock in the near future due to the lack of Webkit.  But surfing the clock will still be uncomfortable.  We still have a great and terrible Android Framework with the Support Library and Google Services.  Structural and architectural differences will also be small. </p><br><h2 id="struktura-prilozheniya">  Application structure </h2><br><p>  Suppose we decide to make a wearable application.  Opened Android Studio, clicked "New project" and ticked off "Wear".  We will immediately find out that two modules have appeared in the package of our application: wear and mobile. </p><br><img alt="Simplified original layout" src="https://habrastorage.org/webt/h_/ih/38/h_ih38ughp2sjzu3dendf4krovo.png"><br><p><br>  These two modules will be assembled in two different .apk files.  But they must have the same package name, and when publishing must be signed with one release certificate.  This is only necessary so that applications can interact with each other through Google Services.  We will return to this later.  In principle, nothing prevents us from building an application only on the Wear OS, tilting the mobile platform aside. </p><br><h2 id="clean-architecture">  Clean architecture? </h2><br><p>  Why not?  This is the same Android application, so architectural approaches for it may be similar to Android. </p><br><img alt="Simplified original layout" src="https://habrastorage.org/webt/8b/ni/1m/8bni1mysvv_etlelhqrrvrxgy7y.png"><br><p><br>  I used the same technology stack that we use in Android applications: </p><br><ul><li>  Kotlin </li><li>  <a href="https://habrahabr.ru/company/mobileup/blog/335382/">Clean architecture</a> </li><li>  <a href="https://habrahabr.ru/company/mobileup/blog/342850/">RxPM</a> (as presentation pattern) </li><li>  <a href="https://github.com/Ekito/koin">Koin</a> (for implementing DI) </li><li>  RxJava (just a matter of taste) </li></ul><br><p>  We have two modules in the project, and the data models are likely to be the same for both platforms.  Therefore, part of the logic and models can be put into another module ‚Äúcommon‚Äù.  Then connect it to the mobile and wearable packages so as not to duplicate the code. </p><br><h2 id="ui">  Ui </h2><br><p>  One of the main features of Android development is the abundance of devices of different sizes and with different screen resolutions.  In Wear OS, also a different form of the screen: round, square and round with a cut edge. <br>  If we try to lay out a layout and display it on different screens, we will most likely see a nightmare like this: </p><br><img alt="go layout" src="https://habrastorage.org/webt/3k/ie/e6/3kiee6p1sczflrto-rntyrt7sko.png"><br><p><br>  In the second version of the system, Google kindly solved part of the UI-problems by including new adaptive view components in the Support wearable library.  Run through the most curious of them. </p><br><h3 id="boxinsetlayout">  BoxInsetLayout </h3><br><p>  BoxInsetLayout is a FrameLayout that can adapt child elements to a round display.  He places them in a rectangular area inscribed in the circumference of the screen.  For square displays, such transformations, of course, are ignored. </p><br><img alt="BoxInsetLayout" src="https://habrastorage.org/webt/pe/fo/9q/pefo9q5b6jcskd2bbtqi05ndbs8.png"><br><p><br>  Thus, the same layout will look about the same for all forms of watch screens. </p><br><img alt="Correct layout" src="https://habrastorage.org/webt/fn/pc/0c/fnpc0csycvnkdqsk2v75a8bbekc.png"><br><p><br>  Looks better, isn't it? </p><br><h3 id="wearablerecyclerview">  WearableRecyclerView </h3><br><p>  Lists are a convenient pattern that is actively used in mobile (and not only) UX.  Wear-interfaces were no exception.  But due to the rounding of the corners of the display, the top View of the list may be clipped.  WearableRecyclerView helps to correct such misunderstandings. <br>  For example, there is the isEdgeItemsCenteringEnabled parameter, which allows you to specify the layout of the elements on the screen curvature and expand the central element, making the list more convenient to read on a small screen. <br>  There is a WearableLinearLayoutManager, which allows you to scroll through the list with a mechanical dial on the clock and scroll the extreme elements to the middle of the screen, which is very convenient on round interfaces. </p><br><img alt="Wearable RecyclerView" src="https://habrastorage.org/webt/u_/t2/lx/u_t2lxw7jyl1a0zqhr5fqlrajcq.png"><br><p><br>  Now the Wear support library includes a couple of dozen adaptive View.  They are all different, and all can be read in detail in the <a href="https://developer.android.com/training/wearables/ui/index.html">documentation</a> . </p><br><p>  Drawing data on the screen is fun, but you need to get this data from somewhere.  In the case of a mobile client, we often use the REST API on top of the usual network protocols (HTTP / TCP).  In Wear OS, this approach is also acceptable, but Google does not recommend it. <br>  Energy efficiency plays a big role in wearable electronics.  And an active Internet connection will quickly set up the battery, and disconnections can occur regularly.  Wearable devices also require active synchronization, which also needs to be implemented. <br>  All of these problems for us kindly solves the data exchange mechanism in Google Services called "Data Layer".  Classes for working with him have found their place in the package com.google.android.gms.wearable. </p><br><h2 id="data-layer">  Data layer </h2><br><p>  Data Layer helps to synchronize data between all wearable devices tied to one Google user account.  It selects the most optimal route for data exchange (bluetooth, network) and implements a stable transmission.  This ensures that the message reaches the desired device. </p><br><img alt="Data layer" src="https://habrastorage.org/webt/ci/b_/xi/cib_xim_2ne_ndi4agmw09ammls.png"><br><p><br>  Data Layer consists of five main elements: </p><br><ul><li>  Data Items </li><li>  Assets </li><li>  Messages </li><li>  Channels </li><li>  Capabilities </li></ul><br><h3 id="data-item">  Data Item </h3><br><p>  Data Item is a component that is designed to synchronize small amounts of data between devices in the wearable infrastructure.  You can work with them through the Data Client.  All synchronization is implemented through Google services. </p><br><p>  DataItem consists of three parts: </p><br><ul><li>  payload is a 100kb payload, represented as a ByteArray.  It looks a bit abstract, so Google itself recommends putting there some kind of key-value structure like Bundle or Map &lt;String, Any&gt;. </li><li>  patch is an identifying path by which we can identify our DataItem.  The fact is that the Data Client stores all DataItem's in a linear structure, which is not suitable for all cases.  If we need to reflect some kind of data hierarchy, we will have to do it ourselves, distinguishing objects by URI. </li><li>  Assets is a separate structure that is not stored in the DataItem itself, but it may have a link to it.  We will talk about it later. </li></ul><br><p>  Let's try creating and saving a DataItem.  To do this, use PutDataRequest, which will pass all the necessary parameters.  Then put PutDataRequest to DataClient in the putDataItem () method. </p><br><p>  For convenience, there is a DataMapItem in which the serialization problem has already been solved.  With it, we can work with data as with a bundle-object, in which primitives can be stored. </p><br><pre><code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataClient = <span class="hljs-type"><span class="hljs-type">Wearable</span></span>.getDataClient(context) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataRequest = <span class="hljs-type"><span class="hljs-type">PutDataMapRequest</span></span>.create(<span class="hljs-type"><span class="hljs-type">PATCH_COFFEE</span></span>).apply { dataMap.putString(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_SPECIEES</span></span>, <span class="hljs-string"><span class="hljs-string">"Arabica"</span></span>) dataMap.putString(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_TYPE</span></span>, <span class="hljs-string"><span class="hljs-string">"Latte"</span></span>) dataMap.putInt(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_SPOONS_OF_SUGAR</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> putDataRequest = dataRequest.asPutDataRequest() dataClient.putDataItem(putDataRequest)</code> </pre> <br><p>  Now our DataItem is stored in the DataClient, and we can access it from all Wearable devices. <br>  Now we can take from the DataClient a list of all Item's, find the one that interests us, and parse it: </p><br><pre> <code class="hljs pgsql">dataClient.dataItems.addOnSuccessListener { dataItems -&gt; dataItems.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { item -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.uri.path == PATCH_COFFEE) { val mapItem = DataMapItem.fromDataItem(item) val coffee = Coffee( mapItem.dataMap.getString(KEY_COFFEE_SPECIES), mapItem.dataMap.getString(KEY_COFFEE_TYPE), mapItem.dataMap.getInt(KEY_COFFEE_SPOONS_OF_SUGAR) ) coffeeReceived(coffee) } } }</code> </pre><br><h3 id="assets">  Assets </h3><br><p>  And now let's imagine that we suddenly needed to send a photo, audio or some other file to the clock.  DataItem with such a load can not cope, because it is designed for fast synchronization, but Asset can.  Asset synchronization mechanism is designed to save files larger than 100kb in the wearable infrastructure and is tightly connected to the DataClient. <br>  As mentioned earlier, the DataItem may have a link to the Asset, but the data itself is saved separately.  A scenario is possible when the Item is preserved faster than Asset, and the file is still loading. </p><br><p>  You can create an Asset using Asset.createFrom [Uri / Bytes / Ref / Fd], and then pass it to the DataItem: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataClient = <span class="hljs-type"><span class="hljs-type">Wearable</span></span>.getDataClient(context) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataRequest = <span class="hljs-type"><span class="hljs-type">PutDataMapRequest</span></span>.create(<span class="hljs-type"><span class="hljs-type">PATCH_COFFEE</span></span>).apply { dataMap.putString(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_SPECIES</span></span>, <span class="hljs-string"><span class="hljs-string">"Arabica"</span></span>) dataMap.putString(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_TYPE</span></span>, <span class="hljs-string"><span class="hljs-string">"Latte"</span></span>) dataMap.putInt(<span class="hljs-type"><span class="hljs-type">KEY_COFFEE_SPOONS_OF_SUGAR</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   val asset = Asset.createFromUri(Uri.parse(COFFEE_PHOTO_PATCH)) dataMap.putAsset(KEY_COFFEE_PHOTO, asset) } val putDataRequest = dataRequest.asPutDataRequest() dataClient.putDataItem(putDataRequest)</span></span></code> </pre><br><p>  To load the Asset on the other side, open inputStream, get the byte array itself, and then present it in the form we need: </p><br><pre> <code class="hljs pgsql">dataClient.dataItems.addOnSuccessListener { dataItems -&gt; dataItems.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { item -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.uri.path == PATCH_COFFEE) { val mapItem = DataMapItem.fromDataItem(item) val asset = mapItem.dataMap.getAsset(KEY_COFFEE_PHOTO) val coffee = Coffee( mapItem.dataMap.getString(KEY_COFFEE_SPECIES), mapItem.dataMap.getString(KEY_COFFEE_TYPE), mapItem.dataMap.getInt(KEY_COFFEE_SPOONS_OF_SUGAR), //    Asset saveFileFromAsset(asset, COFFEE_PHOTO_PATCH) ) coffeeReceived(coffee) } } } private fun saveFileFromAsset(asset: Asset, <span class="hljs-type"><span class="hljs-type">name</span></span>: String): String { val imageFile = File(context.filesDir, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!imageFile.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>()) { Tasks.await(dataClient.getFdForAsset(asset)).inputStream.use { inputStream -&gt; val bitmap = BitmapFactory.decodeStream(inputStream) bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="hljs-number"><span class="hljs-number">100</span></span>, imageFile.outputStream()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> imageFile.absolutePath }</code> </pre><br><h3 id="capabilities">  Capabilities </h3><br><p>  The network of wearable devices can be much wider than two devices connected via Bluetooth and include dozens of devices.  Imagine a situation where you need to send a message not to all devices, but for some specific hours.  Need a way to identify devices on this network.  The method is - this is the Capabilities mechanism.  Its meaning is very simple - any device participating in the network with the help of CapabilitiesClient can find out how many nodes support a particular function, and send a message to one of these nodes. <br>  In order to add Capabilities to our wearable application, you need to create the file res / values ‚Äã‚Äã/ wear.xml and write there an array of strings, which will denote our Capabilities.  Sounds pretty simple.  In practice, too, nothing complicated: </p><br><p>  <strong>wear.xml:</strong> </p><br><pre> <code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string-array</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android_wear_capabilities"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span>capability_coffee<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string-array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  <strong>On the side of another device:</strong> </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCoffeeNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capabilityReceiver: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">nodes</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Node</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> capabilityClient = Wearable.getCapabilityClient(context) capabilityClient .getCapability(CAPABILITY_COFFEE, CapabilityClient.FILTER_REACHABLE) .addOnSuccessListener { nodes -&gt; capabilityReceiver.invoke(nodes.nodes) } }</code> </pre><br><p>  If you, like me, have developed Rx of the brain, then from yourself I will recommend an extension for the Task object.  This object quite often appears in frameworks from Google (including Firebase): </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any?&gt;</span></span></span><span class="hljs-function"> Task</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSingle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fromCompleteListener: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Single&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Single.create&lt;T&gt; { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCompleteListener) { addOnCompleteListener { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.exception != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onError(it.exception!!) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onSuccess(it.result) } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { addOnSuccessListener { emitter.onSuccess(it) } addOnFailureListener { emitter.onError(it) } } } }</code> </pre><br><p>  Then the chain for Nodes will look more beautiful: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCoffeeNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Single&lt;Set&lt;Node&gt;&gt; = Wearable.getCapabilityClient(context) .getCapability(CAPABILITY_COFFEE, CapabilityClient.FILTER_REACHABLE) .toSingle() .map { it.nodes }</code> </pre><br><h3 id="messages">  Messages </h3><br><p>  All previous Data Layer components assumed data caching.  Message helps to send messages without synchronization in the format of "sent and zab (s | and) whether."  Moreover, you can send a message only to a specific node or to a specific set of nodes that you must first obtain through the CapabilitiesClient: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, node: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Node</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> messageClient = Wearable.getMessageClient(context) messageClient.sendMessage(node.id, PATCH_COFFEE_MESSAGE, message) .addOnSuccessListener { <span class="hljs-comment"><span class="hljs-comment">// Success :) } .addOnFailureListener { // Error :( } }</span></span></code> </pre><br><p>  The potential recipient of the message, in turn, must subscribe to receive messages, and find the right one by its URI: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> messageClient = <span class="hljs-type"><span class="hljs-type">Wearable</span></span>.getMessageClient(context) messageClient.addListener { messageEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (messageEvent.path == <span class="hljs-type"><span class="hljs-type">PATCH_COFFEE_MESSAGE</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> coffee processing } }</span></span></code> </pre> <br><h3 id="channels">  Channels </h3><br><p>  Channels are used to transmit streaming data in real time without caching.  For example, if we need to send a voice message from the clock to the phone, the channels will be a very convenient tool.  The client for channels can be obtained through Wearable.getChannelClient (), and further open the input or output data stream (one channel can work in both directions). </p><br><p>  Google is actively developing the Data Layer, and it is likely that in six months, these customers will again ‚Äúmove‚Äù somewhere, or their API will change again. <br>  Of course, Data Layer is not the only way to communicate with the outside world, no one will forbid us to open the tcp-socket in the old-fashioned way and discharge the user's device. </p><br><img src="https://habrastorage.org/webt/lm/ah/js/lmahjs6wpuea2l0fjo1wilxkewc.png" height="150"><br><p><br></p><br><h2 id="v-zaklyuchenie">  Finally </h2><br><p>  It was just a brief overview of the current technical capabilities of the platform.  Wear OS is developing rapidly.  There are more devices, and perhaps soon it will not be just a clock.  Support Wearable Library is also not standing still and is changing with the platform, delighting us with new UI components and the wonders of synchronization. <br>  Like any other system, there are subtleties and interesting points about which you can talk for a long time.  Many details were not fully disclosed, so write in the comments, what you would like to talk about in more detail, and we will tell about it in the next article.  Share your wearable development experience in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353748/">https://habr.com/ru/post/353748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353736/index.html">Digest news from the world of PostgreSQL. Issue number 5</a></li>
<li><a href="../353738/index.html">Secure SOCKS5 proxy for Telegram for 1 Euro and 10 minutes</a></li>
<li><a href="../353740/index.html">Global lighting using voxel cone tracing</a></li>
<li><a href="../353744/index.html">Red Hat is heading for a hybrid cloud with Enterprise Linux 7.5: what does it mean</a></li>
<li><a href="../353746/index.html">How Sberbank Online applications work: Workflow API and frameworks</a></li>
<li><a href="../353750/index.html">How fraudsters trick cryptocurrency users, and how to protect digital assets: 3 practical tips</a></li>
<li><a href="../353758/index.html">Raise SOCKS proxy for Telegram</a></li>
<li><a href="../353760/index.html">Personalize it. Report with Avito Data Science Meetup: Personalization</a></li>
<li><a href="../353762/index.html">Small laptop for system administrator</a></li>
<li><a href="../353764/index.html">The evolution of advertising on TechMedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>