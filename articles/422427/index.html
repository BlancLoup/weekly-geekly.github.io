<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Out of the Fog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All this is Queen Mab's rogue. 
 She in the stables mane braids 
 And knocks her hair with a pimple ... 

 William Shakespeare 

 It was a long releas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Out of the Fog</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>All this is Queen Mab's rogue.</i></b> <b><i><br></i></b>  <b><i>She in the stables mane braids</i></b> <b><i><br></i></b>  <b><i>And knocks her hair with a pimple ...</i></b> <b><i><br><br></i></b>  <b><i>William Shakespeare</i></b> <br><br>  It was a long <a href="https://glukkazan.github.io/">release</a> , but a lot was done.  A <a href="">session-manager appeared</a> , allowing you to roll back erroneously made moves.  Somewhere where sound design was added.  And also, I came up with a cool <a href="https://glukkazan.github.io/custodian/reversi.htm">way</a> to push several alternative options for the initial placement into one game.  And most importantly - I finally got to the games with incomplete information. <br><a name="habracut"></a><br>  I will explain what is at stake.  In board games we are used to, such as <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Checkers</a> , players, at any time of the game, have complete information about the location of the pieces (their own and the opponent), the rules of their movement, the goals of the game, etc.  Such games are quite well studied and belong to the category of " <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B3%25D1%2580%25D0%25B0_%25D1%2581_%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B5%25D0%25B9">games with complete information</a> ."  Now imagine that some of this information may be hidden from the player. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/hd/xl/1hhdxlqk7btnosi-jpow5azj-xy.png"></div><br>  The Fog of War is a great illustration of the theme.  According to the rules of " <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B_%25D0%25B2%25D1%2582%25D1%2591%25D0%25BC%25D0%25BD%25D1%2583%25D1%258E">Chess in the Dark</a> ", players can see not all the opponent's pieces, but only those that are placed on the fields, which can be reached with one move of any of their pieces.  I made two additions to this rule: <br><br><ol><li>  Of course, the player always sees <b>his</b> pieces, but by the way they are displayed - in a normal or translucent form, he can judge whether the opponent sees them. </li><li>  Solely for decorative purposes, I have placed ‚Äúclouds‚Äù on areas that are currently invisible. </li></ol><br>  Having mastered the general <a href="">principle</a> , I got a little carried away and made a huge number of games with the "fog of war."  In addition to <a href="https://glukkazan.github.io/checkmate/dark-chess.htm">Chess itself</a> , I have ‚Äúdark‚Äù options for <a href="https://glukkazan.github.io/xiangqi/dark-xiangqi.htm">Syantsy</a> , <a href="https://glukkazan.github.io/xiangqi/dark-janggi.htm">Changi</a> , <a href="https://glukkazan.github.io/checkmate/dark-shatranj-1.htm">Shatrange</a> , <a href="https://glukkazan.github.io/checkmate/dark-sittuyin.htm">Sittuyin</a> and many other games.  There are even " <a href="https://glukkazan.github.io/elimination/dark-cannon.htm">Guns in the dark</a> "!  All these games have one thing in common: <br><br><div class="spoiler">  <b class="spoiler_title">Computer cheats!</b> <div class="spoiler_text">  I did not even try to make changes to the algorithms of the bots for these games, because I relied on the fact that unequal conditions at least partially compensate for their extremely weak game compared to humans.  As I <a href="https://habr.com/post/353116/">wrote</a> earlier, the development of high-quality AI for board games is a very difficult task.  Of course, the rules have exceptions.  Even with a very weak game of the bot, it will be difficult for a person to play an unfamiliar <a href="https://glukkazan.github.io/xiangqi/passive-chess.htm">game</a> , literally stuffed with traps.  What can we say about her "dark" <a href="https://glukkazan.github.io/xiangqi/dark-passive-chess.htm">version</a> <br></div></div><br>  However, in general, this is not a very correct approach.  I want to see a bot who knows how to manage exactly the data that is available to his opponent - a man.  Why is it important?  Everything is very simple - by the way a bot plays, sometimes it is very easy to guess whether it has access to hidden information (spies) or not.  And, of course, it is much more interesting for a person to play with the bot that <b>does not</b> spy (it is even more interesting to play with another person, but this is a separate story). <br><br>  And here it is worth picking up a game that is a little different from Chess (since I am not ready to engage in developing an "honest" Chess-playing bot "in the dark").  There are a lot of such games and it‚Äôs impossible to say that they are simpler than Chess or Checkers.  They are just different and require an individual approach. <br><br><div class="spoiler">  <b class="spoiler_title">for example</b> <div class="spoiler_text">  There is one children's game, with the development of the bot for which I have not yet managed.  It is called ‚ÄúJungle‚Äù or <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B6%25D1%2583%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8_(%25D0%25BD%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Dou Shou Qi</a> .  The goal of the game is to penetrate enemy territory.  Each of the players has a "lair" - the central field on the first line.  If any of the enemy figures enters the lair, he won (it is impossible to occupy the lair with your own figures). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/rz/cb/l_rzcbk0dmvj5ul8m1e4wdefrny.png"></div><br>  The figures are ordered by seniority.  The elephant beats all the figures, followed by: Leo, Tiger, Leopard, Dog, Wolf, Cat and Rat.  A rat can only beat an elephant and another rat, in addition, it is the only figure that can move in the water (there are two reservoirs in the middle of the board).  A tiger and a lion can jump over water, but only if the rat does not block the path through the water.  With the exception of jumps, all the figures move in the same way - one adjacent field vertically or horizontally.  The lair is surrounded by traps.  A trapped figure is vulnerable to <b>any</b> opponent piece. <br><br>  As you can see, the rules are pretty simple.  What prevents to develop a bot for this game?  First of all - low speed figures.  If there are threats, I can appreciate the benefits of exchanges, but most of the game pieces simply run after each other over fairly long distances.  I cannot afford to watch the game for a large number of moves ahead (due to restrictions on the duration of the stroke calculation), as a result of which exchanges fall behind the viewing horizon and all the moves become equal for me. <br></div></div><br>  To begin with, I decided to stop at <a href="https://en.wikipedia.org/wiki/Banqi">BanQi</a> - Chinese "Blind Chess".  This is a very original game with hidden information, akin to "Jungle".  For me it is important that the developments, in connection with the creation of a bot for this game, can be used in other games, such as <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B6%25D1%2583%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8_(%25D0%25BD%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Dou Shou Qi</a> , <a href="https://en.wikipedia.org/wiki/Luzhanqi">Luzhan Qi</a> , <a href="https://en.wikipedia.org/wiki/Stratego">Stratego,</a> or even (possibly) <a href="https://en.wikipedia.org/wiki/Tafl_games">Tafl</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bG11at_PKxA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  I'll tell you about the rules.  The game takes place on the half board for "Chinese chess" ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%258F%25D0%25BD%25D1%2586%25D0%25B8">Xiang Qi</a> ), while the original layout of the board does not play any role.  The figures are placed inside the cells (as in traditional), and not at the intersections of the lines (as in Chinese chess).  At the beginning of the game, all the figures are carefully mixed and placed on the board face down (since the traditional figures of Xiangqi are sort of barrels, and their number coincides with the number of fields on the half of the board, this does not cause difficulties). <br><br>  Next, the players alternate their moves.  When making a move, the player can turn over any of the closed figures, or move the previously opened figure of his own color.  The colors of the players are determined by the very first move.  If the black piece is opened first, the player who opened it will play black.  All the figures in the game go the same way (except for the ‚ÄúGuns‚Äù in the Taiwanese version, which I will talk about later) - one adjacent cell vertically or horizontally.  The possibility of taking is determined by the order of precedence of the figures: <br><br>  <b>General&gt; Counselor&gt; Elephant&gt; Wagon&gt; Horse&gt; Cannon&gt; Soldier</b> <br><br>  The senior figures beat the younger or equal to them, with one exception: the soldier beats the general (a kind of " <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D0%25BC%25D0%25B5%25D0%25BD%25D1%258C,_%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25B8%25D1%2586%25D1%258B,_%25D0%25B1%25D1%2583%25D0%25BC%25D0%25B0%25D0%25B3%25D0%25B0">Rock-Paper-Scissors</a> ").  It remains to say a few words about the Taiwan BanQi: <br><br><ol><li>  Unlike the Chinese version, in Taiwan BanQi, a general <b>can</b> not beat a soldier. </li><li>  The gun moves according to the rules of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%258F%25D0%25BD%25D1%2586%25D0%25B8">XiangQi</a> , that is, to any number of fields orthogonal in a quiet way (like a chariot) or hits any opponent's piece, with a jump through the "carriage", when performing an attacking turn. </li></ol><br>  There is also a Hong Kong version, but it is practically no different from the Chinese, except that the order of the precedence of the figures has been changed.  I decided to focus on the Taiwanese version of the rules, as the most interesting, in tactical terms. <br><br><div class="spoiler">  <b class="spoiler_title">What should I look for when developing a bot?</b> <div class="spoiler_text"> Firstly, the game looks very simple, but it is not.  Even if you do not consider the nuances associated with Taiwanese cannons, the cost of the figures is counterintuitive.  Although the Counselor can beat fewer pieces than the General, he is the main character in the game.  First, the player has two advisers.  In addition, each adviser is outnumbered by only one enemy general, while the generals can attack as many as five soldiers!  For the same reason, the cost of a soldier, in the game, is higher than the cost of a general.  In the end, he can beat the strongest piece!  The second important consideration is suggested by one of the ‚ÄúCanterbury‚Äù puzzles of Henry Dewdeni. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkmate/catch-pigs.htm"><img src="https://habrastorage.org/webt/v9/jd/ax/v9jdaxvmdjxuvp-gw6sr9h7_i8a.png"></a> </div><br>  This is more a joke than a complete puzzle.  All figures can walk on one adjacent field vertically or horizontally.  White goes first, while White and Black always make two moves (in different pieces)!  Under these conditions, the left jester will never be able to catch the left donkey, and the right jester will never be able to catch the right donkey (you can check it yourself).  Of course, the right jester can catch the left donkey without any difficulty.  It's all about parity! <br><br>  This problem prompted me to some thoughts.  First, the bot's task, in games such as BanQi or DouShouQi, is, above all, finding the shortest path.  From each of the active figures (your own or your opponent) you need to build a chain of moves to all possible goals (including your own figures, to calculate possible exchanges).  After this, the chains need to be evaluated and the following options are possible here. <br><br><ol><li>  The attacking figure hits the attacked - a profitable (bonus) chain estimated by the value of the attacked figure (minus the attacking figure, if the latter is under protection), taking into account the length of the chain. </li><li>  The attacking figure beats the attacked - not advantageous (penalty) chain, estimated by the value of the attacking figure. </li><li>  The figures beat each other (for example, they are equal) - everything depends on the parity, odd chains are beneficial, and even ones should be considered as penalties (if there were no other figures on the field, the parity would completely determine the result of the game). </li></ol><br>  Of course, everything is not so simple.  At a minimum, one should keep in mind the specific progress of the cannons in the Taiwan BanQi (As for the "Jungle", there are even more special cases), but this is where to begin.  Having a full set of priced chains, you can evaluate the moves.  The cost of a move must consist of the value of chains (both bonus and penalty), the length of which it reduces. <br></div></div><br>  First of all, it is important to understand that effectively using <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D1%258C%25D1%2584%25D0%25B0-%25D0%25B1%25D0%25B5%25D1%2582%25D0%25B0-%25D0%25BE%25D1%2582%25D1%2581%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">minimax</a> algorithms is unlikely to succeed here.  Moves that reveal previously hidden pieces, too radically change the assessment of the position.  Without information about hidden figures, it is almost impossible to view a position for many moves ahead.  But every cloud has a silver lining, but we can use much more complex (computationally) heuristics to evaluate the moves themselves! <br><br>  I already <a href="">have a</a> bot evaluating the moves according to their heuristics (needed for one amusing <a href="https://glukkazan.github.io/pasang/pasang-01.htm">game</a> ).  This is a very simple algorithm.  All moves are sorted in descending order of heuristics (moves with a negative value of heuristics are generally discarded), after which they are viewed in order.  If the next move leads to the position from which there is no response of the enemy, leading to immediate victory, the bot considers it the best.  Using this algorithm, you can not bother with the assessment of the position, but you will have to sweat on <a href="">heuristics</a> . <br><br><div class="spoiler">  <b class="spoiler_title">First of all, we build chains</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.chains)) { board.chains = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pieces = getGoals(design, board); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targets = getTargets(design, board, pieces); _.each(pieces.positions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> goals = pieces; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (piece.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { goals = targets; f = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> group = [ pos ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level = []; level[pos] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; group.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(goals.positions, group[i]) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ... } if ((i &gt; 0) &amp;&amp; (board.getPiece(group[i]) !== null)) continue; _.each(design.allDirections(), function(dir) { p = design.navigate(board.player, group[i], dir); while (p !== null) { if (_.indexOf(group, p) &gt;= 0) break; group.push(p); level[p] = level[ group[i] ] + 1; if (f || (board.getPiece(p) !== null)) break; p = design.navigate(board.player, p, dir); } }); } }); } return board.chains; }</span></span></code> </pre> </div></div><br>  Of course, I cache all the intermediate data in the game state, so as not to count them several times.  In addition, one trick is used here, which is very useful in calculating connected areas.  I iterate through the <b>group</b> array, enclosing additional elements inside the loop, as needed.  All difficulties are connected with guns.  For them, the targets of the chains are not the figures themselves, but the fields from which the latter can be attacked. <br><br><div class="spoiler">  <b class="spoiler_title">Chains are valued exactly as I said</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getChainPrice = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, attacker, attacking, len</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacker == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (attacking === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player == attacking.player) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacking = isAttacker(design, attacker.type, attacking.type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacked = isAttacker(design, attacking.type, attacker.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (attacker.type == <span class="hljs-number"><span class="hljs-number">12</span></span>)) { isAttacking = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; isAttacked = (attacking.type == attacker.type) &amp;&amp; (len == <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = (len % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attacker.player != player) f = !f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacking) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = f ? (len - design.price[attacker.type]) : (design.price[attacking.type] - len); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { price = design.price[attacking.type] - len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) price = (price / <span class="hljs-number"><span class="hljs-number">2</span></span>) | <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked) { price = len - design.price[attacker.type]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre></div></div><br>  ... depending on the length and parity of the chain, as well as the cost of attacking and attacking figures.  But this is only half the battle!  It is necessary to evaluate each of the possible moves using the constructed chains.  I am introducing another intermediate structure - wishes to aggregate the available data.  Assessment of the course consists of assessments of wishes, which it satisfies: <br><br><div class="spoiler">  <b class="spoiler_title">Something like that</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board, comment, price, src, dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src])) { board.wish[src] = []; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(dst)) dst = src; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish[src][dst])) { board.wish[src][dst] = price; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.wish[src][dst] += price; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getWish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.wish)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.wish; } Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wish = getWish(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.isSimpleMove() &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]) &amp;&amp; !_.isUndefined(wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wish[ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ][ move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] ]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  As for the <b>getWish</b> function <b>itself</b> , magic begins here (and this is the place where I most likely plowed and more than once).  First of all, I share the assessment of moves based on open information and the introduction of new pieces into the game.  This is not entirely correct, but for the time being I just don‚Äôt know how to reconcile such diverse assessments.  If, based on open information, no wishes have been formed, the bot tries to discover new figures (there are also some tricks here). <br><br><ol><li>  If an enemy cannon is open, surrounded by closed figures, it makes sense to open one of the figures next to it, since it is likely that it will be able to attack the cannon, and the cannon cannot beat it anyway. </li><li>  If the figure is different from the cannon, you can try to open the figure located through the "carriage" from it, because there is a chance that it will be a gun. </li><li>  In the presence of an attacking chain from the side of the enemy, you can open one of the figures, next to the chain, to intercept the attack. </li><li>  If you cannot protect the figure, you can open the figure next to it, trying to reduce the situation to exchange. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Of course, the probability of opening a particular figure is useful to evaluate</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getShadow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.getValue(board.player); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.shadow)) { board.shadow = []; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.type &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = piece.type + <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { value = -value; } board.shadow.push(value); } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.shadow; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isFriend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isPiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == y; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAttacker = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x == <span class="hljs-number"><span class="hljs-number">13</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">7</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp;&amp; (enemy == <span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!chinese &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt;= enemy; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isDefender = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, x, enemy, friend</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isAttacker(design, x, enemy)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> design.price[friend] &lt;= design.price[enemy]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> estimate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, p, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadow = getShadow(design, board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shadow.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(shadow, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(design, x, y, z)) r++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span> * r) / shadow.length; }</code> </pre></div></div><br>  The player can estimate probabilities by keeping records of the figures who have left the game.  In principle, the bot can do the same, but there is a simpler way - to view the still not open figures in a crowd and, based on the collected information, evaluate the probability of finding the desired one.  At the same time, the success of the chosen move is not guaranteed, but if the probability of a favorable outcome is low, the move will not be chosen at all. <br><br><div class="spoiler">  <b class="spoiler_title">In principle, the approach justified itself, but there is still a lot of work to be done.</b> <div class="spoiler_text">  So far, not very good defensive moves.  Some figures bravely go to meet a stronger enemy, instead of fleeing from it (although it‚Äôs usually useless to run away in their case).  Also, there are difficulties in coordinating the actions of various figures (this may be useful in order to "drive out" the remnants of the enemy figures).  The approach itself looks very promising, but heurists still have to think about it. <br><br>  Heuristics based on "chains" of moves can be useful not only in BanQi, but also in many other games, with the prevalence of "slow moving" figures (if not as a decisive criterion, then for preliminary assessment of the quality of moves in more complex algorithms, least).  This approach is especially in demand in those games for which the use of minimax algorithms is difficult or even impossible (such as <a href="https://en.wikipedia.org/wiki/Yonin_shogi">Yonin Shogi</a> , for example). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k_/x3/dq/k_x3dqvxu3swinw7qkgmvo__6km.png"></div><br>  Of course, I'm going to continue working on games with incomplete information.  The picture shows the Philippine " <a href="https://en.wikipedia.org/wiki/Game_of_the_Generals">Game of Generals</a> ", not yet finished.  This is the simplest game from the large family, which includes games like <a href="https://en.wikipedia.org/wiki/Luzhanqi">LuzhanQi</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25BE">Stratego</a> .  And of course, I still expect to make a working bot for the " <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B6%25D1%2583%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8_(%25D0%25BD%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Jungle</a> "! <br></div></div><br>  And for those who are still reading me, I can offer another funny puzzle game with hidden information: <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/fox-hunting.htm"><img src="https://habrastorage.org/webt/bm/aa/4p/bmaa4p2ctbqb_9k_oz1wjoulx9c.png"></a> </div><br>  I played it in my childhood, on a programmable calculator, called Fox Hunting.  On the field, 8 foxes are randomly hidden, which must be found using the ‚Äúspear method‚Äù.  When you select an empty area, the total number of foxes in all eight directions is displayed.  It is impossible to lose, but you can compete for the minimum number of clicks.  And if you play in headphones, turn down the sound.  Maybe I overdid it with sound effects. <br></div><p>Source: <a href="https://habr.com/ru/post/422427/">https://habr.com/ru/post/422427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422417/index.html">Slavik and GMT + 3 or benefits for people</a></li>
<li><a href="../422419/index.html">Don't panic in Go</a></li>
<li><a href="../422421/index.html">Microsoft is going to drastically improve Skype</a></li>
<li><a href="../422423/index.html">Python and DataScience: exploring the capabilities of the universal library Numpy</a></li>
<li><a href="../422425/index.html">Review of post-processing methods for FDM 3D-printed models</a></li>
<li><a href="../422429/index.html">Accelerate the process of developing complex projects. Without chaos and nerves</a></li>
<li><a href="../422431/index.html">Japanese fairies show the work of a master-slave trigger in a new manga for digital electronics</a></li>
<li><a href="../422433/index.html">Solar panels and asphalt roads. Symbiosis of technology</a></li>
<li><a href="../422435/index.html">Timer - start</a></li>
<li><a href="../422437/index.html">User Perception Games and Website and Application Speed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>