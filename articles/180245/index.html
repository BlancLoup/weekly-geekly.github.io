<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sphere from two triangles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of this demo is this: once a friend of mine made a map generator for his game of planets and wanted the maps created in this way to be shown...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sphere from two triangles</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/dcd/357/b3c/dcd357b3c575e6e22c0d999ab7dc68db.png" align="left">  The story of this demo is this: once a friend of mine made a map generator for his game of planets and wanted the maps created in this way to be shown as a rotating sphere.  However, at the same time, he did not want to use 3D graphics, but instead generated a lot of frames with this very sphere, which was rotated at different angles.  The amount of memory used was ... let's say, redundant, well, and the speed of frame generation (as well as the quality of their execution) suffered greatly.  A little thought, I was able to help him optimize this process, but in general I had a fair feeling that this was a task for OpenGL, and not for 2D graphics at all. <br><br>  And so, once, when insomnia tormented me, I decided to try to combine these two approaches: draw a rotating sphere (with a map of the planet stretched on it) through OpenGL, but at the same time leaving it flat. <br><a name="habracut"></a><br>  And I must say that I did it.  But first things first. <br><br><h4>  Process math </h4><br>  To begin with, we will define our own task.  For each point on the screen, we have two screen coordinates in the Cartesian coordinate system, and we need to find for it spherical coordinates (in fact, latitude and longitude), which in fact are the texture coordinates for the map of the planet. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So.  The transition from a spherical coordinate system to a Cartesian one is given by a system of equations (taken from <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2584%25D0%25B5%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582">Wikipedia</a> ): <br><img src="https://habrastorage.org/storage2/048/6de/23f/0486de23f72f91ad82301ab6d17349cf.png"><br><br>  and the reverse transition - such equations: <br><img src="https://habrastorage.org/storage2/b6c/795/928/b6c7959282582ffe28e86583d33bf6ad.png"><br><br>  We can easily get the <i>Z</i> coordinate from <i>X</i> and <i>Y</i> , knowing the radius, and we can take the radius to be one. <br>  In the future, we will agree that we will slightly change the above equations by swapping the concepts of <i>Y</i> (we will have a screen vertical) and <i>Z</i> (this will be the depth of the scene). <br><br><h4>  Technical part </h4><br>  The implementation of the idea will require us to use quad (I already <a href="http://habrahabr.ru/post/144831/">wrote</a> about how to use it, so I will not repeat, especially since the link to the full source code of the project is given below), as well as two textures: the actual map of the planet (I used the texture of Earth 2048x1024) and texture coordinates maps.  The code for generating the second texture accurately repeats the math conversion from Cartesian coordinates to spherical: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> texSize = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> r = texSize * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[texSize * texSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>, idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; row &lt; texSize; row++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = (r - row) / r; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sin_theta = Math.sqrt(<span class="hljs-number"><span class="hljs-number">1</span></span> - y*y); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> theta = Math.acos(y); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> v = Math.round(<span class="hljs-number"><span class="hljs-number">255</span></span> * theta / Math.PI); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; col &lt; texSize; col++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = (r - col) / r; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>, a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= -sin_theta &amp;&amp; x &lt;= sin_theta) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z = Math.sqrt(<span class="hljs-number"><span class="hljs-number">1</span></span> - y*y - x*x); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phi = Math.atan2(z, x); u = Math.round(<span class="hljs-number"><span class="hljs-number">255</span></span> * phi / (<span class="hljs-number"><span class="hljs-number">2</span></span> * Math.PI)); a = Math.round(<span class="hljs-number"><span class="hljs-number">255</span></span> * z); } pixels[idx++] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((a &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) + (v &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + u); } } GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, genbuf, <span class="hljs-number"><span class="hljs-number">0</span></span>); offsetTex = genbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offsetTex != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, offsetTex); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_NONE); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_NONE); GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GLES20.GL_RGBA, texSize, texSize, <span class="hljs-number"><span class="hljs-number">0</span></span>, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, IntBuffer.wrap(pixels)); }</code> </pre> <br>  Note that the <i>X</i> and <i>Y</i> coordinates are moved from the range [0..texSize] to the range [-1..1], and the texture coordinates <i>U</i> and <i>V are</i> transferred from the radians to the range [0..255], and then written down in red and the green components of a 32-bit texture.  The alpha channel is used to preserve the ‚Äúdepth‚Äù ( <i>Z</i> coordinates), while the blue remains unused.  Disabling bilinear filtering is also not accidental: at this stage, it does not give any effect (neighboring points have the same values ‚Äã‚Äãanyway, with rather sharp jumps), but in what I'm going to show next, it will be is harmful.  But more on that below. <br><br> <a href=""><img src="http://habrastorage.org/storage2/21a/1e1/65f/21a1e165f7c496cec533b28f24277b3e.png" align="left"></a>  Both textures are fed to the input of a simple pixel shader (hereinafter, the images are clickable): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 vTex = texture2D(uTexture0, TexCoord0.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vCol = texture2D(uTexture1, vTex.xy).rgb;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = vec4(vCol, (vTex.w &gt; 0.0 ? 1.0 : 0.0));\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>;</code> </pre><br>  The scene rendering code I do not cite, because  everything is quite trivial in it (and, again, it can be viewed in its full source), and the shader itself is rather primitive.  The most curious thing in it, perhaps, is that the alpha channel is only being tested for positivity, whereas it would be possible to use it for the lighting effect. <br><br>  It turned out pretty well, but somehow flat, plus I would like to add the actual rotation of the planet around its axis. <br><br> <a href=""><img src="http://habrastorage.org/storage2/ac2/fb4/70b/ac2fb470bfd7a498ab60e40dd97878e1.png" align="right"></a>  We include one more parameter in the shader (we will change it depending on the time in the range [0..1]), plus add ‚Äúdepth‚Äù (multiply the color by the value from the alpha channel): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform float uOffset;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 vTex = texture2D(uTexture0, TexCoord0.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vTex.x += uOffset;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vCol = texture2D(uTexture1, vTex.xy).rgb;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = vec4(vCol * vTex.w, (vTex.w &gt; 0.0 ? 1.0 : 0.0));\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>;</code> </pre><br>  Well, there are no complaints to the sphere itself, but the picture looks somehow ... eight-bit or something.  And no wonder: we wrote texture coordinates in the range [0..255] (the maximum available to us in normal color components), which means our texture can be no more than 256 points in height (and 512 in width, taking into account the rotation).  Not enough, you need at least 10-bit precision. <br><br><h4>  Increase resolution </h4><br>  Immediately I warn you: the code described here can work crookedly on any devices, although I managed to achieve normal rendering on all devices that I could hold in my hands.  In any case, the one described here is the usual hack. <br><br>  So, we still have two of the three color components, i.e.  16 bits out of 24. Well, let's pack the data in such a way that each texture coordinate has a size of 12 bits, which allows us to work with textures up to 4096 pixels in height!  To do this, change literally three lines in the program: <br><br><pre> <code class="java hljs">... <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> v = Math.round(<span class="hljs-number"><span class="hljs-number">4095</span></span> * theta / Math.PI); ... u = Math.round(<span class="hljs-number"><span class="hljs-number">4095</span></span> * phi / (<span class="hljs-number"><span class="hljs-number">2</span></span> * Math.PI)); ... pixels[idx++] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((a &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) + (v &lt;&lt; <span class="hljs-number"><span class="hljs-number">12</span></span>) + ((u &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + (u &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)); ...</code> </pre><br>  and write a new shader that takes into account the 12-bit addressing scheme (it is in this place that bilinear filtering is disabled!): <br> <a href=""><img src="http://habrastorage.org/storage2/372/582/903/372582903622b0690f7735f7ad959995.png" align="left"></a> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform float uOffset;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 vTex = texture2D(uTexture0, TexCoord0.xy);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vOff = vTex.xyz * 255.0 + vec3(0.5, 0.5, 0.5);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float hiY = floor(vOff.y / 16.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float loY = vOff.y - 16.0 * hiY;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec2 vCoord = vec2(\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" (vOff.x * 16.0 + loY) / 4095.0 + uOffset,\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" (vOff.z * 16.0 + hiY) / 4095.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vCol = texture2D(uTexture1, vCoord).rgb;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = vec4(vCol * vTex.w, (vTex.w &gt; 0.0 ? 1.0 : 0.0));\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>;</code> </pre><br>  Well, it's a completely different thing!  With minor changes (adding scaling by pinching and rotating with a finger), I showed this program to my friends and colleagues, and at the same time asked how many, in their opinion, there are triangles in this scene.  The results varied, and the question itself was suspicious of a trick (in this case, the respondents joked "one", which was not far from the truth), but the correct answer was consistently surprising.  And all, as one, they asked: why can the sphere be twisted around one axis, but not tilted? .. Hmm. <br><br><h4>  Incline </h4><br>  And the fact is that the slope in this scheme is much more difficult to implement.  In fact, the task is not intractable, and I even coped with it, but it was not without nuances. <br><br>  In essence, the task is to take the offset coordinate <i>V</i> , whereas the <i>U</i> coordinate does not change: this is because we add rotation around the <i>X</i> axis.  The plan is as follows: convert the texture coordinates to screen ones (in the range [-1..1]), apply the rotation matrix around the horizontal axis to them (for this we write the sine and cosine of the tilt angle to the new <i>uTilt</i> constant), and then use the new <i>Y</i> coordinate for sampling in our patterned texture.  The ‚Äúrotated‚Äù <i>Z</i> coordinate is also useful to us, with its help we will mirror the longitude for the back side of the ball).  The screen coordinate <i>Z</i> will have to be calculated explicitly, in order not to make two texture samples from one texture, at the same time this will increase its accuracy. <br><br> <a href=""><img src="http://habrastorage.org/storage2/007/1f2/56b/0071f256b2171580d0e473a0d51f8728.png" align="right"></a> <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String quadFS = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform sampler2D uTexture1;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform float uOffset;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec2 uTilt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"varying vec4 TexCoord0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"void main() {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float sx = 2.0 * TexCoord0.x - 1.0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float sy = 2.0 * TexCoord0.y - 1.0;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float z2 = 1.0 - sx * sx - sy * sy;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (z2 &gt; 0.0) {;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float sz = sqrt(z2);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float y = (sy * uTilt.y - sz * uTilt.x + 1.0) * 0.5;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float z = (sy * uTilt.x + sz * uTilt.y);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 vTex = texture2D(uTexture0, vec2(TexCoord0.x, y));\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vOff = vTex.xyz * 255.0 + vec3(0.5, 0.5, 0.5);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float hiY = floor(vOff.y / 16.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float loY = vOff.y - 16.0 * hiY;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec2 vCoord = vec2(\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" (vOff.x * 16.0 + loY) / 4095.0,\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" (vOff.z * 16.0 + hiY) / 4095.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (z &lt; 0.0) { vCoord.x = 1.0 - vCoord.x; }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vCoord.x += uOffset;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vCol = texture2D(uTexture1, vCoord).rgb;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = vec4(vCol * sz, 1.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" } else {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>;</code> </pre><br>  Hooray, the slope was a success!  That's just a strange noise on the border of the hemispheres a little confused.  Obviously, the problem lies in the lack of accuracy of addressing at the boundary points (the points on the circle itself correspond to a too large range of coordinates, one texel spreads out to a rather noticeable interval).  In the end, I managed to defeat it using two generated textures instead of one. <br><br>  As a result, you can zoom in and turn the ball almost the same as in Google Earth.  With the difference that here - only two triangles. <br><br>  And finally, the promised.  The source code for the project is available on <a href="https://github.com/ginkage/Planet">GitHub</a> . <br>  You can also download the finished <a href="">.apk file</a> . <br><br>  By the way, the source for my past posts are available <a href="https://github.com/ginkage/Postcard">there</a> . <br><br>  <b>Update:</b> It seems that I still managed to achieve accurate texturing on all devices, it required a bit to change the order of bits, and also slightly correct the rounding of the colors of the template texture.  Now even forcibly compressed textures should work more or less normally.  The code on GitHub is updated, new .apk-files are uploaded. <br><br>  <b>Update 2:</b> Still, the artifact on the border of the hemispheres was defeated.  Sources and ready .apk updated. <br>  In addition, I added another bonus: the WebGL version of this demo is available <a href="http://ginkage.ucoz.ru/earth.html">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/180245/">https://habr.com/ru/post/180245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180229/index.html">8 years after launch, 100 hours of video is uploaded to YouTube every minute.</a></li>
<li><a href="../180231/index.html">Video interview from Silicon Valley. Alex Debelov is a graduate of YCombinator, leader and co-founder of Virool, an online video promotion service.</a></li>
<li><a href="../180233/index.html">A former employee of Google confirmed the fact of fraud company with taxes in Britain</a></li>
<li><a href="../180235/index.html">Selection of court decisions. Such different domain disputes</a></li>
<li><a href="../180241/index.html">Vaccination against reality: pink glasses for the browser</a></li>
<li><a href="../180249/index.html">Two-day free access to Code School courses</a></li>
<li><a href="../180251/index.html">Save body movements!</a></li>
<li><a href="../180255/index.html">Is there life in the world of PostPC? Part 4: Clouds, White Mane Horses</a></li>
<li><a href="../180257/index.html">Panorama at 9600 km in 15 minutes</a></li>
<li><a href="../180259/index.html">Unknown mathematician made a breakthrough in the theory of twin prime numbers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>