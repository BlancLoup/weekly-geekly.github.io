<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Steam Protocol v2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The final article of the cycle, the most interesting and most voluminous: 



- Steam Protocol 2 and Steam Files - Introduction 
- Steam Files. Part 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Steam Protocol v2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/000/dca/198/000dca198a459957c5d705d59a8bc514.png" alt="Steam Logo"><br><br>  The final article of the cycle, the most interesting and most voluminous: <br><br><ul><li>  <a href="http://habrahabr.ru/post/223961/">Steam Protocol 2 and Steam Files - Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/224027/">Steam Files.</a>  <a href="http://habrahabr.ru/post/224027/">Part 1 - GCF / NCF</a> </li><li>  <a href="http://habrahabr.ru/post/268921/">Steam Files.</a>  <a href="http://habrahabr.ru/post/268921/">Part 2 - BLOB, CDR, VDF, PAK, VPK</a> </li></ul><br>  The article will discuss the protocols for exchanging Steam client data with various servers: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/269061/">General Direcrory Server</a> ; </li><li>  <a href="https://habr.com/ru/post/269061/">Config Server</a> ; </li><li>  <a href="https://habr.com/ru/post/269061/">Authentication Server</a> ; </li><li>  <a href="https://habr.com/ru/post/269061/">Content Lists Server</a> ; </li><li>  <a href="https://habr.com/ru/post/269061/">Content Server</a> . </li></ul><br>  Once again, let me remind you that the protocols in question are outdated and are not currently used (with the exception of GDS and Config - for compatibility). <br><br>  All algorithms are presented in my <a href="https://github.com/andreili/steam_libs">repository</a> . <br><a name="habracut"></a><br>  The entire protocol is based on Sockets, so WireShark was enough to parse it almost everywhere.  The entire protocol description will be viewed by the client (in Delphi).  Mostly there will be sections of server code in C ++. <br><br><div class="spoiler">  <b class="spoiler_title">Almost all requests have a common algorithm.</b> <div class="spoiler_text"><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSteamNetwork</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConectToServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Addr: TSockAddr; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QUERY; QSize: uint32; Command: pByte; CSize: uint32; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReplySize: uint32; IsConfigServer: boolean = false)</span></span></span><span class="hljs-function">:</span></span> pByte; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Accept: boolean; DestIP: uint32; Sock: CSocket; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; Sock:=CSocket.Create(SOCKET_IP); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Connect(Addr) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">{if (Sock=nil) or (not Sock.Connect(Addr)) then Exit; }</span></span> Sock.SetTimeOut(<span class="hljs-number"><span class="hljs-number">3000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(QUERY, QSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.recv(Accept, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsConfigServer <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.recv(DestIP, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Accept <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; CSize:=htonl(CSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.send(CSize, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; CSize:=htonl(CSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.send(Command^, CSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Sock.OnLoadingProc:=OnLoadingProc; result:=Sock.RecvFromLen(ReplySize); Sock.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div><br>  This protocol is used when querying all list servers (GD, Config, ContentList).  In the QUERY parameter, a pointer is passed to an array of bytes representing the type of request, and in QSize, the size of this array.  In the Command parameter, a pointer is passed to the byte array with the command itself, and to CSize, the size of this array.  The variable ReplySize contains the size of the requested response and after the call will be equal to the actually received amount of data.  The above code can be represented by the following pseudocode: <br><br><pre> <code class="hljs 1c">   <span class="hljs-built_in"><span class="hljs-built_in"></span></span>           IP-, <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-type"><span class="hljs-type"></span></span>  Config Server'    ,            </code> </pre><br>  In some cases, RSA-signature is used, obtained by the following algorithm: <br><br><div class="spoiler">  <b class="spoiler_title">Signature of the data block for Steam</b> <div class="spoiler_text"><pre> <code class="hljs mel">char *RSASign(RSA *key, char *Mess, UINT32 <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, UINT32 sign_size) { char *<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span> = new char[sign_size]; memset(<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sign_size); <span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\x00'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\x01'</span></span>; memset(&amp;<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0xff</span></span>, sign_size<span class="hljs-number"><span class="hljs-number">-38</span></span>); memcpy(&amp;<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>[sign_size<span class="hljs-number"><span class="hljs-number">-36</span></span>], <span class="hljs-string"><span class="hljs-string">"\x00\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14"</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>); void *hash = HashSHA1(Mess, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>); memcpy((void*)&amp;<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>[sign_size<span class="hljs-number"><span class="hljs-number">-20</span></span>], hash, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> hash; RSA_public_encrypt(sign_size, (UCHAR*)<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>, (UCHAR*)<span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>, key, RSA_NO_PADDING); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sign</span></span>; } char *RSASignMessage(RSA *key, char *Mess, UINT32 <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RSASign(key, Mess, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>); } char *RSASignMessage1024(RSA *key, char *Mess, UINT32 <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RSASign(key, Mess, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>); }</code> </pre> <br></div></div><br><a name="NetworkKey"></a><br><div class="spoiler">  <b class="spoiler_title">Previously used keys for signing</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">// <span class="hljs-type"><span class="hljs-type">MainKeySign</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">MainKeySign_n</span></span> <span class="hljs-comment"><span class="hljs-comment">"86724794f8a0fcb0c129b979e7af2e1e309303a7042503d835708873b1df8a9e307c228b9c0862f8f5dbe6f81579233db8a4fe6ba14551679ad72c01973b5ee4ecf8ca2c21524b125bb06cfa0047e2d202c2a70b7f71ad7d1c3665e557a7387bbc43fe52244e58d91a14c660a84b6ae6fdc857b3f595376a8e484cb6b90cc992f5c57cccb1a1197ee90814186b046968f872b84297dad46ed4119ae0f402803108ad95777615c827de8372487a22902cb288bcbad7bc4a842e03a33bd26e052386cbc088c3932bdd1ec4fee1f734fe5eeec55d51c91e1d9e5eae46cf7aac15b2654af8e6c9443b41e92568cce79c08ab6fa61601e4eed791f0436fdc296bb373"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">MainKeySign_e</span></span> <span class="hljs-comment"><span class="hljs-comment">"07e89acc87188755b1027452770a4e01c69f3c733c7aa5df8aac44430a768faef3cb11174569e7b44ab2951da6e90212b0822d1563d6e6abbdd06c0017f46efe684adeb74d4113798cec42a54b4f85d01e47af79259d4670c56c9c950527f443838b876e3e5ef62ae36aa241ebc83376ffde9bbf4aae6cabea407cfbb08848179e466bcb046b0a857d821c5888fcd95b2aae1b92aa64f3a6037295144aa45d0dbebce075023523bce4243ae194258026fc879656560c109ea9547a002db38b89caac90d75758e74c5616ed9816f3ed130ff6926a1597380b6fc98b5eeefc5104502d9bee9da296ca26b32d9094452ab1eb9cf970acabeecde6b1ffae57b56401"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">MainKeySign_d</span></span> <span class="hljs-comment"><span class="hljs-comment">"11"</span></span> // <span class="hljs-type"><span class="hljs-type">NetworkKey</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NetworkKey_n</span></span> <span class="hljs-comment"><span class="hljs-comment">"bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NetworkKey_e</span></span> <span class="hljs-comment"><span class="hljs-comment">"11"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NetworkKey_d</span></span> <span class="hljs-comment"><span class="hljs-comment">"4ee3ec697bb34d5e999cb2d3a3f5766210e5ce961de7334b6f7c6361f18682825b2cfa95b8b7894c124ada7ea105ec1eaeb3c5f1d17dfaa55d099a0f5fa366913b171af767fe67fb89f5393efdb69634f74cb41cb7b3501025c4e8fef1ff434307c7200f197b74044e93dbcf50dcc407cbf347b4b817383471cd1de7b5964a9d"</span></span></code> </pre> <br></div></div><br><a name="GDS"></a><h4>  <b>General Direcrory Server</b> </h4><br>  It is the root of the entire infrastructure and only stores the addresses of other servers.  Request type is 0x02000000 (used when calling ConectToServer).  The answer is a list of server IP addresses as requested: <br><br><ul><li>  4 bytes list length; </li><li>  N list items of the form IP: port (4 + 2 bytes). </li></ul><br>  Known queries and their commands: <br><br><ul><li>  The list of configuration servers is \ x00; </li><li>  The list of authentication servers is \ x00 \ xC4 \ x1D \ x1A \ x00; </li><li>  The list of root content servers is \ x06; </li><li>  The list of CSER servers is \ x14. </li></ul><br>  What a CSER server - I did not understand, so nowhere else is it mentioned about them. <br><br><a name="Conf"></a><h4>  <b>Config server</b> </h4><br>  Type of request - 0x03000000.  Known queries: <br><br><ul><li>  <a href="http://habrahabr.ru/post/268921/">CDR</a> ; </li><li>  Client version; </li><li>  Network keys; </li><li>  Unknown request. </li></ul><br>  CDRs and versions are given as <a href="http://habrahabr.ru/post/268921/">BLOB</a> files. <br><br><h5>  <b>Cdr</b> </h5><br>  The command is 0x02 to get the file or 0x09 to check for its update.  In the case of an update, the request is followed by 20 bytes of the SHA-1 hash for the existing file (or 0x00 if it is not).  The answer is a ‚Äúraw‚Äù CDR file, which is simply saved to disk and later used by the client. <br><br><h5>  <b>Client version</b> </h5><br>  Team - 0x01. <br><br><div class="spoiler">  <b class="spoiler_title">Formation BLOB'a server side</b> <div class="spoiler_text"><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">ACTION_GET_VERSIONS_BLOB</span></span>: #ifdef <span class="hljs-type"><span class="hljs-type">LOG</span></span> <span class="hljs-type"><span class="hljs-type">Log</span></span>(<span class="hljs-type"><span class="hljs-type">Client</span></span>-&gt;<span class="hljs-type"><span class="hljs-type">ServerName</span></span>, <span class="hljs-string"><span class="hljs-string">"Client %s - Sending Versions Blob"</span></span>, <span class="hljs-type"><span class="hljs-type">ClientAddr</span></span>); #endif blob = new <span class="hljs-type"><span class="hljs-type">CBLOBFile</span></span>(); rootNode = blob-&gt;<span class="hljs-type"><span class="hljs-type">RootNode</span></span>(); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x00\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddData</span></span>(<span class="hljs-string"><span class="hljs-string">"\x01\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, (char*)&amp;<span class="hljs-type"><span class="hljs-type">SteamVersion</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddData</span></span>(<span class="hljs-string"><span class="hljs-string">"\x02\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, (char*)&amp;<span class="hljs-type"><span class="hljs-type">SteamUIVersion</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x03\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x04\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x14\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x05\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x17\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x06\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x0e\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x07\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"boo\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); //rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x08\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x5c\x01\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x09\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"foo\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0a\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x11\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0b\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"bar\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0c\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x12\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0d\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"foo\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0e\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); rootNode-&gt;<span class="hljs-type"><span class="hljs-type">AddString</span></span>(<span class="hljs-string"><span class="hljs-string">"\x0f\x00\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"\x50\x01\x00\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-type"><span class="hljs-type">ReplySize</span></span> = blob-&gt;<span class="hljs-type"><span class="hljs-type">SaveToMem</span></span>(&amp;reply, false); delete blob; <span class="hljs-type"><span class="hljs-type">Socket</span></span>-&gt;<span class="hljs-type"><span class="hljs-type">SendInt32</span></span>(<span class="hljs-type"><span class="hljs-type">ReplySize</span></span>, true); <span class="hljs-type"><span class="hljs-type">Socket</span></span>-&gt;<span class="hljs-type"><span class="hljs-type">Send</span></span>(reply, <span class="hljs-type"><span class="hljs-type">ReplySize</span></span>); break;</code> </pre> <br></div></div><br>  As can be seen from this code, the record contains a lot of service data, the purpose of which is not clear, but they were constant over a long period of time.  Strings with the latest version of the client itself and the UI package for it are transferred from the variables. <br><br><h5>  <b>Network keys</b> </h5><br>  Team - 0x04.  It has several non-standard data exchange protocol - the size of the response from the server is 2 bytes in size instead of 4 for the remaining answers.  Server response contains: <br><br><ul><li>  Title - \ x30 \ x81 \ x9d \ x30 \ x0d \ x06 \ x09 \ x2a \ x86 \ x48 \ x86 \ xf7 \ x0d \ x01 \ x01 \ x01 \ x05 \ x00 \ x03 \ x81 \ x8b \ x00 \ x30 \ x81 \ x87 \ x02 \ x81 \ x81 \ x00; </li><li>  The normal part is <a href="https://habr.com/ru/post/269061/">NetworkKey</a> ; </li><li>  Data \ x02 \ x01 \ x11 (the last byte of which, apparently, is the exponential part of the <a href="https://habr.com/ru/post/269061/">NetworkKey</a> ; </li><li>  256 bytes of RSA signature using <a href="https://habr.com/ru/post/269061/">MainKeySign</a> .  <b>Signature size is not included and package size!</b> </li></ul><br><h5>  <b>Unknown request</b> </h5><br>  Team 0x07.  The server response contains the constant 9 bytes - \ x00 \ x01 \ x31 \ x2d \ x00 \ x00 \ x00 \ x01 \ x2c. <br><br><a name="Auth"></a><h4>  <b>Authentication Server</b> </h4><br>  The most interesting and difficult to open the protocol server.  The main feature is the use of a very non-standard time measurement system - <i><b>in nanoseconds from <abbr title="Nativity">PX</abbr></b></i> .  Initial data: <br><br><ul><li>  Username; </li><li>  User Password. </li></ul><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25BA%25D0%25B8%25D0%25BD%25D1%2581%25D0%25B0">Jenkins‚Äôs hash function</a> is compiled by user name: <br><br><div class="spoiler">  <b class="spoiler_title">Function source code</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, b, c: uint32)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(a, b); dec(a, c); a:=a xor (c <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>); dec(b, c); dec(b, a); b:=b xor (a <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); dec(c, a); dec(c, b); c:=c xor (b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>); dec(a, b); dec(a, c); a:=a xor (c <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>); dec(b, c); dec(b, a); b:=b xor (a <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>); dec(c, a); dec(c, b); c:=c xor (b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>); dec(a, b); dec(a, c); a:=a xor (c <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>); dec(b, c); dec(b, a); b:=b xor (a <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>); dec(c, a); dec(c, b); c:=c xor (b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jenkinsLookupHash2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data: pByte; Length: integer; InitVal: uint32)</span></span></span><span class="hljs-function">:</span></span> uint32; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, c, len: uint32; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> len:=Length; a:=$<span class="hljs-number"><span class="hljs-number">9</span></span>e3779b9; b:=a; c:=InitVal; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (len&gt;=<span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> inc(a, Data[<span class="hljs-number"><span class="hljs-number">0</span></span>] + (Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>)); inc(b, Data[<span class="hljs-number"><span class="hljs-number">4</span></span>] + (Data[<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>)); inc(c, Data[<span class="hljs-number"><span class="hljs-number">8</span></span>] + (Data[<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>) + (Data[<span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>)); mix(a, b, c); Data:=pByte(@Data[<span class="hljs-number"><span class="hljs-number">12</span></span>]); dec(len, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c, length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(c, Data[<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(c, Data[<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(c, Data[<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(b, Data[<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(b, Data[<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(b, Data[<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(b, Data[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(a, Data[<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(a, Data[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(a, Data[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> inc(a, Data[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mix(a, b, c); result:=c; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>  General algorithm of interaction with the server: <br><br><ul><li>  We send an authentication request - 5 bytes \ x00 \ x00 \ x00 \ x00 \ x04; </li><li>  We send the local IP address; </li><li>  We send username hash; </li><li>  Accept connection confirmation flag.  It will be false if the user with such a hash name is not in the server database; </li><li>  We accept the external IP-address of the client; </li><li>  We send the package with the user name (the composition will be discussed below); </li><li>  Accept "salt" for encryption (8 bytes); </li><li>  We form the authentication package (we will consider further); </li><li>  Accept authentication byte; </li><li>  We take 8 bytes of server time (remember nanoseconds with PX!); </li><li>  We accept 8 bytes of packet lifetime. </li></ul><br>  The authentication confirmation byte can take the following states: <br><br>  0x00 - input successfully completed; <br>  0x01 - account does not exist; <br>  0x02 - the account does not exist or the password is incorrect; <br>  0x03 - too big difference in client and server time; <br>  0x04 - account is blocked. <br><br>  <b>If the login was made</b> , then a packet with user data is received from the server (we will consider further).  The package with the user name consists of the following fields: <br><br><ul><li>  Packet size (4 bytes); </li><li>  1 byte 0x02; </li><li>  Name length (2 bytes); </li><li>  Username; </li><li>  Name length (2 bytes); </li><li>  Username. </li></ul><br>  Data preparation for authentication package: <br><br><ol><li>  Calculate the hash for the data block represented by the first 4 bytes of the salt, the user password, and the last 4 bytes of the salt; </li><li>  Calculate the hash for a block of data from the external and local IP addresses of the client; </li><li>  We form a data block from the current time (ns with PX !!!), local IP-address and 4 bytes \ x04 \ x04 \ x04 \ x04; </li><li>  The first 8 bytes of the packet with p.3 xor'im with the data from p.2; </li><li>  We encrypt the data block from step 4 with the AES-CBC algorithm using the key (data from item 1) and the initialization vector (any data). </li></ol><br>  Authentication Package: <br><br><ul><li>  Package size - constant, 0x00000036; </li><li>  Initialization vector (when generating data); </li><li>  4 bytes of constant - \ x00 \ x0C \ x00 \ x10.  Judging by the values, these are 16-bit data sizes (IV and encrypted part); </li><li>  Encrypted data. </li></ul><br>  The server response with these users has the following format: <br><br><ul><li>  Header TTicket_SubHeader; </li><li>  Header TTicketHeader; </li><li>  Initialization vector <b>firstIV</b> ; </li><li>  A block of data in the size of TTicketHeader.SZ2; </li><li>  The second header is TTicketHeader (2); </li><li>  The second block of data in the size of TTicketHeader (2) .SZ2; </li><li>  Header TTicket_TestData; </li><li>  <b>TicketSign</b> data; </li><li>  Header TTicket_BLOBHeader; </li><li>  The <b>BLOB</b> itself is TTicket_BLOBHeader.Len2-20-sizeof (TTicket_BLOBHeader); </li><li>  Package Signature. </li></ul><br>  Consider the structures used and their fields. <br><br><pre> <code class="delphi hljs">TTicket_SubHeader = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> nullData1: uint16; outerIV: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; nullData2: uint16; nullData3: uint16; EncrData: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">63</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; TicketLen: uint16; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The <b>EncrData</b> field contains the data that needs to be decrypted using the AES-CBC algorithm using the key (claim 1 of the preparation of authentication data) and the TTicket_SubHeader.outerIV initialization vector.  At the output, we get a header <b>UserHeader</b> type TTicket_UserHeader. <br><br><pre> <code class="delphi hljs">TTicket_UserHeader = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> InnerKey: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; Dummy1: uint16; SteamID: uint64; Servers: <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> IP1: uint32; Port1: uint16; IP2: uint32; Port2: uint16; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; CurrentTime: uint64; ExpiredTime: uint64; Dummy2: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The purpose of all the fields is clear from the title, but incomprehensible to me and most incomprehensible.  In the end, most of these data is purely intuitively named, based on their further use.  The <b>InnerKey</b> field will be used later. <br><br><pre> <code class="delphi hljs">TTicketHeader = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> SZ1, SZ2: uint16; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><pre> <code class="delphi hljs">TTicket_TestData = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> len: uint16; <span class="hljs-comment"><span class="hljs-comment">//always $1000 SteamID: uint64; ExternalIP: uint32; end;</span></span></code> </pre> <br><pre> <code class="delphi hljs">TTicket_BLOBHeader = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> NodeHeader: uint16; Len2: uint32; ZerosSize: uint32; BLOBLen: uint32; InnerIV: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  As mentioned earlier, after this header is a block of data with an encrypted BLOB file.  It is encrypted with the AES-CBC algorithm using the <b>UserHeader.InnerKey</b> key and the <b>TTicket_BLOBHeader.InnerIV</b> initialization <b>vector</b> . <br><br><a name="CLS"></a><h4>  <b>Content Lists Server</b> </h4><br>  Stores lists of content servers for various files.  Type of request - 0x0200000000.  Has 2 requests.  Differing only in the second and third bytes of the command: <br><br><ul><li>  The list of servers for the archive - 0x0000; </li><li>  The list of servers for service archives is 0x0100. </li></ul><br>  The general command format for this server is: <br><br><ul><li>  1 byte - 0x00; </li><li>  2 bytes of command refinement (\ x00 \ x00 or \ x0100); </li><li>  4 bytes - ID of the requested archive; </li><li>  4 bytes - version of the requested archive; </li><li>  2 bytes - the maximum number of servers in the response; </li><li>  4 bytes - region; </li><li>  4 bytes - 0xFF. </li></ul><br>  The server response contains a list of the following items: <br><br><pre> <code class="delphi hljs">TContentListEntry = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ID: uint32; <span class="hljs-comment"><span class="hljs-comment">//   ??? ClientUpdateIP: uint32; ClientUpdatePort: uint16; ContentServerIP: uint32; ContentServerPort: uint16; end;</span></span></code> </pre> <br>  The <b>ID</b> field changed for the same servers, from which I concluded that this is the load on this server.  This is followed by two pairs of IP: port, which are almost always the same.  Why 2 pairs - no idea. <br><br><a name="Content"></a><h4>  <b>Content Server</b> </h4><br>  The most difficult to interact server that stores directly the content of the games and the files of Steam itself.  It has its own protocol and handles 2 requests: <br><br><ul><li>  Service archive download (client files); </li><li>  Download game archive. </li></ul><br>  Consider the download of the service archive: <br><br><ul><li>  Send the command - \ x03 \ x00 \ x00 \ x00; </li><li>  Accept connection flag; </li><li>  Accept the requested file; </li><li>  Accept rsa file signature. </li></ul><br>  The file request and the signature are made by the file name (for the signature it is obtained "&lt;file name&gt; _rsa_signature"): <br><br><ul><li>  4 bytes - packet size (length of the file name + 16); </li><li>  4 bytes - the command \ x00 \ x00 \ x00 \ x00; </li><li>  4 bytes - \ x00 \ x00 \ x00 \ x00; </li><li>  4 bytes - the length of the file name; </li><li>  The file name itself. </li></ul><br>  The answer to each such request is the requested file. <br><br><div class="spoiler">  <b class="spoiler_title">The source code of the described algorithm</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSteamNetwork</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Content_DownloadPackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: AnsiString; FileName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> ENetWorkResult; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Accepted: boolean; Sock: CSocket; PacketSize, Request, MessSize: uint32; Data, Mess: pByte; str: TStream; Addr: TSockAddr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcPackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N, FN: AnsiString)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PacketSize:=htonl(<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>+Length(N)+<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(PacketSize, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(CS_PACKAGE_GET_FILE, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Request:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(Request, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Request:=htonl(Length(N)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(Request, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(N[<span class="hljs-number"><span class="hljs-number">1</span></span>], Length(N)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Request:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(Request, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(PacketSize, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Data:=Sock.RecvFromLen(PacketSize); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=eConnectionError; Addr:=ContentList_GetContentServer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Addr.sin_addr.S_addr=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Sock:=CSocket.Create(SOCKET_IP); Sock.SetTimeOut(<span class="hljs-number"><span class="hljs-number">3000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sock=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Connect(Addr)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Send(CS_PACKAGE_QUERY, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(Accepted, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Accepted <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=eServerReset; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ProcPackage(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>, Wide2Ansi(FileName)); MessSize:=PacketSize; Mess:=Data; ProcPackage(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>+<span class="hljs-string"><span class="hljs-string">'_rsa_signature'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); Sock.Free; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RSACheckSign(NetWorkKeySign, Data, Mess, MessSize, <span class="hljs-number"><span class="hljs-number">128</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> str:=TStream.CreateWriteFileStream(FileName); str.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(Mess^, MessSize); str.Free; result:=eOK; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result:=eSignError; FreeMem(Mess, MessSize); FreeMem(Data, <span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>  Downloading the game archive is much more complicated and goes through many stages: <br><br><ul><li>  Send the command \ x07 \ x00 \ x00 \ x00; </li><li>  Accept connection flag; </li><li>  We send 5 bytes of the command for receiving a banner - \ x00 \ x00 \ x00 \ x00 \ x00; </li><li>  We get a confirmation flag; </li><li>  Accept the length of the string; </li><li>  Accept a string with a link; </li><li>  Send the archive opening command - \ x09; </li><li>  We send 8 bytes \ x00; </li><li>  We send 4 bytes ID of the requested archive; </li><li>  We send 4 bytes of the version of the requested archive; </li><li>  Accept 4 bytes of <b>connection ID</b> ; </li><li>  Accept 4 bytes <b>MessageID</b> ; </li><li>  Accept confirmation flag; </li><li>  Accept 4 bytes <b>CacheID</b> ; </li><li>  Accept 4 bytes <b>ManifestCheck</b> ; </li><li>  Send the manifest retrieval command - \ x04; </li><li>  We send 4 bytes <b>CacheID</b> ; </li><li>  We send 4 bytes <b>MessageID</b> ; </li><li>  Accept data block with manifest (part of <a href="http://habrahabr.ru/post/224027/">GCF / NCF archive</a> headers); </li><li>  Send command to get checksums - \ x06; </li><li>  We send 4 bytes <b>CacheID</b> ; </li><li>  We send 4 bytes <b>MessageID</b> ; </li><li>  Accept data block with checksums (part of <a href="http://habrahabr.ru/post/224027/">GCF / NCF archive</a> headers); </li><li>  Send the command to get the file - \ x07; </li><li>  We send 4 bytes <b>CacheID</b> ; </li><li>  We send 4 bytes <b>MessageID</b> ; </li><li>  We send 4 bytes - the file index in the archive (starts from 0); </li><li>  We send 4 bytes - the number of the first required part (the size of 1 part is equal to 0x00002000 - in accordance with <a href="http://habrahabr.ru/post/224027/">the sector size described earlier</a> ); </li><li>  We send 4 bytes - the number of requested parts; </li><li>  Accept 4 bytes <b>CacheID</b> ; </li><li>  Accept 4 bytes <b>MessageID</b> ; </li><li>  Accept confirmation flag; </li><li>  Accept the number of parts sent to the user; </li><li>  Accept the specified number of parts (we consider below); </li><li>  Send the command to close the file - \ x03; </li><li>  Accept 4 bytes <b>CacheID</b> ; </li><li>  Accept 4 bytes <b>MessageID</b> ; </li><li>  Accept confirmation flag; </li><li>  Close the connection. </li></ul><br>  Receive 1 part file: <br><br><ol><li>  Accept 4 bytes <b>CacheID</b> ; </li><li>  Accept 4 bytes <b>MessageID</b> ; </li><li>  Accept 4 bytes of the size of the part; </li><li>  Accept 4 bytes <b>CacheID</b> ; </li><li>  Accept 4 bytes <b>MessageID</b> ; </li><li>  Accept 4 bytes of block size; </li><li>  Accept a block of the specified size; </li><li>  We turn to step 4, while the size of the received blocks is less than the size of the part. </li></ol><br><div class="spoiler">  <b class="spoiler_title">The source code of the described algorithm</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSteamNetwork</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Content_DownloadGCF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppID, Version: uint32)</span></span></span><span class="hljs-function">:</span></span> ENetWorkResult; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Accepted: boolean; Sock: CSocket; i: integer; ConnID, MessageID, MsgID, BlockSize, CacheID, ManifestCheck: uint32; ManifestSize, ChecksumSize, PS: uint32; Manifest, Checksum: pByte; UpdateList: puint32; str: TStream; GCF: TGCFFile; q: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..HL_GCF_CHECKSUM_LENGTH*<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> byte; Addr: TSockAddr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RecvPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Size: uint32)</span></span></span><span class="hljs-function">:</span></span> pByte; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Pos, recived: uint32; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(CacheID, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(MsgID, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(Accepted, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Accepted <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(Size, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(CacheID, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv( MsgID, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(BlockSize, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Pos:=<span class="hljs-number"><span class="hljs-number">0</span></span>; Size:=htonl(Size); BlockSize:=htonl(BlockSize); GetMem(result, Size); <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> recived:=Sock.Recvi(pByte(result+Pos)^, BlockSize); inc(Pos, recived); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> (Pos&gt;=Size) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (recived=<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBannerURL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> URL: pAnsiChar; Len: uint16; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:=false; FillChar(Q[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Q[<span class="hljs-number"><span class="hljs-number">0</span></span>]:=CS_STORAGE_BANNER_URL; Sock.SendFromLen(<span class="hljs-number"><span class="hljs-number">5</span></span>, @Q[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Sock.Recv(Accepted, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; URL:=pAnsiChar(Sock.RecvFromLenShort(Len)); <span class="hljs-comment"><span class="hljs-comment">//URL:=pAnsiChar(URL+#0); Writeln('Banner URL: "'+URL+'"'); FreeMem(URL, Len); result:=true; end; function Open(): boolean; begin result:=false; AppID:=htonl(AppID); Version:=htonl(Version); FillChar(Q[0], 17, 0); Q[0]:=CS_STORAGE_OPEN; Move(ConnID, Q[1], 4); Move(MessageID, Q[5], 4); Move(AppID, Q[9], 4); Move(Version, Q[13], 4); if not Sock.SendFromLen(17, @Q[0]) then Exit; if not Sock.Recv(ConnID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(Accepted, 1) then Exit; if Accepted then Exit; if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(ManifestCheck, 4) then Exit; AppID:=htonl(AppID); Version:=htonl(Version); result:=true; end; function OpenEx(): boolean; begin //result:=false; result:=true; end; function GetManifest(): boolean; begin result:=false; FillChar(Q[0], 9, 0); Q[0]:=CS_STORAGE_GET_MANIFEST; Move(CacheID, Q[1], 4); Move(MessageID, Q[5], 4); if not Sock.SendFromLen(9, @Q[0]) then Exit; Manifest:=RecvPacket(ManifestSize); result:=(Manifest&lt;&gt;nil); inc(MessageID); end; function GetChecksum(): boolean; begin result:=false; FillChar(Q[0], 9, 0); Q[0]:=CS_STORAGE_GET_CHECKSUM; Move(CacheID, Q[1], 4); Move(MessageID, Q[5], 4); if not Sock.SendFromLen(9, @Q[0]) then Exit; Checksum:=RecvPacket(ChecksumSize); result:=(Checksum&lt;&gt;nil); inc(MessageID); end; function GetListUpdateFiles(): boolean; var r: byte; Count: uint32; begin result:=false; FillChar(Q[0], 13, 0); Q[0]:=CS_STORAGE_GET_LIST_UPDATE_FILES; Move(CacheID, Q[1], 4); Move(MessageID, Q[5], 4); Move(#0#0#0#0, Q[9], 4); Sock.SendFromLen(13, @Q[0]); if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(r, 1) then Exit; if not Sock.Recv(Count, 4) then Exit; if Count=0 then Exit; if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; UpdateList:=puint32(Sock.RecvFromLen(PS)); str:=TStream.CreateWriteFileStream('.\package\7.diff'); str.Write(UpdateList^, PS); str.Free; result:=true; inc(MessageID); end; function RecvChunk(var Size: uint32): pByte; //inline; var len, recvd: uint32; begin result:=nil; Size:=0; if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(Size, 4) then Exit; Size:=htonl(Size); len:=0; GetMem(result, Size); repeat if not Sock.Recv( CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(BlockSize, 4) then Exit; BlockSize:=htonl(BlockSize); write(BlockSize); recvd:=0; repeat inc(recvd, Sock.Recvi(pByte(result+len)^, BlockSize)); until recvd=BlockSize; if recvd=uint32(SOCKET_ERROR) then break; inc(len, recvd); until len&gt;=Size; inc(MessageID); end; function GetFile(Idx: uint32): ENetWorkResult; var Start, Count, i: integer; FileIdx, IsCompressed, ChunkSize, UncSize: uint32; Chunk: pByte; begin result:=eConnectionError; str:=GCF.OpenFile(Idx, ACCES_WRITE); Start:=0; Count:=GCF.ItemSize[Idx].Size div HL_GCF_CHECKSUM_LENGTH; //    = HL_GCF_CHECKSUM_LENGTH if GCF.ItemSize[Idx].Size mod HL_GCF_CHECKSUM_LENGTH&gt;0 then inc(Count); FileIdx:=htonl(GCF.CheckIdx(Idx)); Start:=htonl(Start); Count:=htonl(Count); FillChar(Q[0], 22, 0); Q[0]:=CS_STORAGE_GET_FILE; Move(CacheID, Q[1], 4); Move(MessageID, Q[5], 4); Move(FileIdx, Q[9], 4); Move(Start, Q[13], 4); Move(Count, Q[17], 4); Q[21]:=$00; if not Sock.SendFromLen(22, @Q[0]) then Exit; if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(Accepted, 1) then Exit; if Accepted then Exit; if not Sock.Recv(Count, 4) then Exit; if not Sock.Recv(IsCompressed, 4) then Exit; Count:=htonl(Count); IsCompressed:=htonl(IsCompressed); result:=eOK; for i:=0 to Count-1 do begin Chunk:=RecvChunk(ChunkSize); UncSize:=HL_GCF_CHECKSUM_LENGTH; if (IsCompressed=1) then begin // zipped if uncompress(@q[0], UncSize, Chunk, ChunkSize)&lt;&gt;0 then begin result:=eZLibError; break; end; str.Write(q[0], UncSize); end else if (IsCompressed=2) then begin writeln(HL_GCF_CHECKSUM_LENGTH-ChunkSize); str.Write(Chunk^, ChunkSize); FillChar(q[0], HL_GCF_CHECKSUM_LENGTH, 0); str.Write(q[0], HL_GCF_CHECKSUM_LENGTH-ChunkSize); end else str.Write(Chunk^, ChunkSize); FreeMem(Chunk, ChunkSize); {$IFDEF DEBUG_CS_SLEEP} sleep(300); {$ENDIF} end; if (IsCompressed=2) and (CDR&lt;&gt;nil) then begin // encrypted (and zipped?) //GCF.DecryptItem(Idx, CDR.AppRecord[AppID].DecryptKey(Version)); end; str.Free; end; function Close(): boolean; begin result:=false; FillChar(Q[0], 9, 0); Q[0]:=CS_STORAGE_CLOSE; Move(CacheID, Q[1], 4); Move(MessageID, Q[5], 4); Sock.SendFromLen(9, @Q[0]); if not Sock.Recv(CacheID, 4) then Exit; if not Sock.Recv(MsgID, 4) then Exit; if not Sock.Recv(Accepted, 1) then Exit; result:=true; end; begin result:=eConnectionError; Addr:=ContentList_GetContentServer(AppID, Version, REGION_Rest_World); if Addr.sin_addr.S_addr=0 then Exit; Sock:=CSocket.Create(SOCKET_IP); Sock.SetTimeOut(3000); if (Sock=nil) or (not Sock.Connect(Addr)) then Exit; if not Sock.Send(CS_STORAGE_QUERY, 4) then Exit; if not Sock.Recv(Accepted, 1) then Exit; if not Accepted then begin result:=eServerReset; Exit; end; ConnID:=0; MessageID:=0; writeln('Get banner URL'); if not GetBannerURL() then begin Sock.Free; Exit; end; writeln('Open'); if not Open() then begin Sock.Free; Exit; end; writeln('Get manifest'); if not GetManifest() then begin Sock.Free; Exit; end; writeln('Get checksums'); if not GetChecksum() then begin Sock.Free; Exit; end; //RSASignMessage(NetWorkKeySign, Checksum, ChecksumSize-128); {if not GetListUpdateFiles() then begin closesocket(Sock); Exit; end;} GCF:=TGCFFile.Create('.\storage\common\'+Int2Str(AppID)); GCF.LoadFromMem(Manifest, Checksum, ManifestSize, ChecksumSize, false); GCF.SaveToFile('.\storage\'+Int2Str(AppID)+'.ncf'); for i:=0 to GCF.ItemsCount-1 do if (GCF.IsFile(i)) and (GCF.GetCompletion(i)&lt;1) then begin Writeln(GCF.ItemPath[i]); {$IFDEF DEBUG_CS_SLEEP} sleep(100); {$ENDIF} if GetFile(i)&lt;&gt;eOK then break; end; GCF.Free; Close(); Sock.Free; str:=TStream.CreateWriteFileStream('.\storage\'+Int2Str(AppID)+'.manifest'); str.Write(Manifest^, ManifestSize); str.Free; FreeMem(Manifest, ManifestSize); str:=TStream.CreateWriteFileStream('.\storage\'+Int2Str(AppID)+'.checksum'); str.Write(Checksum^, ChecksumSize); str.Free; FreeMem(Checksum, ChecksumSize); result:=eOK; end;</span></span></code> </pre><br></div></div><br><h4>  Conclusion </h4><br>  That came to an end the cycle of articles on the outdated part of Steam  The only thing that is still actively used is VDF-archives. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next article I can touch on more relevant information - SteamAPI (steam.dll) and SteamClienAPI (steamclient.dll). </font><font style="vertical-align: inherit;">And if the second is considered from the side of receiving information about the user within the limits of the permitted, then the first will be considered from the side of the simplest emulator of this API. </font><font style="vertical-align: inherit;">The decision whether or not to write about it is to the community.</font></font></div><p>Source: <a href="https://habr.com/ru/post/269061/">https://habr.com/ru/post/269061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269041/index.html">Solving common problems when building an Xcode project generated by Unity3D</a></li>
<li><a href="../269045/index.html">Phone numbers in email clients</a></li>
<li><a href="../269049/index.html">Serge - the solution for continuous localization from Evernote</a></li>
<li><a href="../269055/index.html">Pulling information from the URL, in the style of Slack and Twitter</a></li>
<li><a href="../269057/index.html">Very handy abstract adapter for RecyclerView do it yourself</a></li>
<li><a href="../269065/index.html">Big data, Beeline and Coco</a></li>
<li><a href="../269067/index.html">Hackers attack, what to do?</a></li>
<li><a href="../269069/index.html">TypeScript 1.6 release: not just React</a></li>
<li><a href="../269073/index.html">RedHat Acquires Ansible</a></li>
<li><a href="../269075/index.html">Web Camp 2015: how it was</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>