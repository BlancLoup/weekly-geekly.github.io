<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to visit Korean University using the Network File System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 


 A long time ago in the early 2000s, many were entertained by regularly ‚Äúscanning‚Äù their provider's networks, and sometimes even farther t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to visit Korean University using the Network File System</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/yv/yo/g3/yvyog3c-gz4kkanb5hdlhenybg8.png"></p><br><h2 id="predislovie">  Foreword </h2><br><p>  A long time ago in the early 2000s, many were entertained by regularly ‚Äúscanning‚Äù their provider's networks, and sometimes even farther targets for detecting Windows machines and resources for them (SMB) available for reading (writing).  The search process was primitive: a range of IP addresses or a network mask was specified, and using various tools ‚Äî LANguard Network Scanner, xIntruder, and the like ‚Äî addresses were scanned and servers were located.  Often, on the detected machines, various network resources (disks, printers, directories) were available for reading, less often for writing.  Through an anonymous session, using IPC $ and the ‚ÄúGuest‚Äù user, it was possible to transfer resources on the machine, sometimes there were ‚ÄúAdministrators‚Äù members without passwords, and sometimes, after a more ‚Äúactive‚Äù impact on the detected machines, it was possible to find servers running Windows NT 4.0 or Windows 2000 Server.  If luck deigned to detect machines with Windows 98 then common, it became easier - at that time, the specified OS contained many different vulnerabilities, including in the implementation of working with SMB, brute force to gain access to the resource was carried out in a matter of minutes even on dial-up connections.  For those who want to plunge into the old days here it is written in detail about the "access" to Windows 9x - <a href="https://cdn.ttgtmedia.com/searchSecurity/downloads/Hacking_exposed_chapter4.pdf">Hacking Exposed: Network Security Secrets &amp; Solutions.</a>  <a href="https://cdn.ttgtmedia.com/searchSecurity/downloads/Hacking_exposed_chapter4.pdf">Chapter 4: Hacking Windows 95/98 and Me</a> .  But later in the article it's not about that. </p><a name="habracut"></a><br><p>  I would never have thought that in 2019 such ‚Äúentertainment‚Äù was possible.  The similarity lies in the ease of finding other people's available resources for all curious.  The following discussion will focus not on the trend popular in the past 2 years - the search for open access databases of MongoDB or Elasticsearch - but a somewhat more mundane service. </p><br><p>  <em>Further, I suggest not to evaluate the whole procedure of actions, their ethical standards, I note that this post is not a call for actions that can be attributed to some articles of the Criminal Code of the Russian Federation or similar norms from the laws of other states.</em> </p><br><h2 id="network-file-system-nfs">  Network File System (NFS) </h2><br><p>  <a href="https://en.wikipedia.org/wiki/Network_File_System" title="Wikipedia">Network File System (NFS)</a> is a network file access protocol that allows you to connect (mount) remote file systems through a network, provides users with access to files, and allows them to work with these files in the same way as with local ones. </p><br><p>  Most Network-attached storage (NAS) on the market, of course, support NFS, and provide access to local resources as well as on any server with an operating system where it is possible to deploy the NFS service. </p><br><p>  The settings for access to server resources with some Ubuntu OS and IP address 192.168.1.1 are contained in the / etc / exports file and are records of the form: </p><br><ul><li>  / data / place1 192.168.1.0/255.255.255.0(rw, no_subtree_check,nohide,async) 192.168.101.0/255.255.255.0(rw,no_subtree_check,nohide,async) </li><li>  data / place2 192.168.1.0/255.255.255.0(rw,no_subtree_check,nohide,async) 192.168.101.0/255.255.255.0(rw,no_subtree_check,nohide,async) </li></ul><br><p>  In this case, NFS access to the server and its resource / data / place1 is possible for clients with IP addresses from networks 192.168.1.0/255.255.255.0, 192.168.101.0/255.255.255.0. </p><br><p> Mount a remote resource to a local directory, for example, / home / user / example, if the client is on an allowed subnet and the client for NFS is installed, possibly via the (Ubuntu) command: <br> <code>mount -t nfs 192.168.1.1:/data/place1 /home/user/example</code> </p> <br><p>  If instead of IP addresses, * or (everyone) is specified, then, often, any client can mount the remote resource into his system. </p><br><p>  The user (for example, under Ubuntu) just dial in the terminal: showmount -e ip-target and get information about available resources on the server (server's export list). </p><br><p>  For example: <br> <code>showmount -e 81.24..</code> <br> <code>Export list for 81.24..:</code> <br> <code>/home/admin 192.168.52.1/24</code> </p> <br><p>  Thus, the following scenario is formed: to detect servers with a running NFS service, determine available resources on servers, consolidate the result into a single output form, and continue to act on the situation. </p><br><p>  What can be on the resources - obviously, anything: </p><br><ul><li>  personal files of Internet users, for example, in cases of "open" NAS devices; </li><li>  directories with files of entire enterprises, databases, database archives; </li><li>  often directories with / home / * addresses (sometimes with keys in .ssh and available for writing); </li><li>  directories with CCTV files; </li><li>  other ... </li></ul><br><h2 id="poluchenie-ip-adresov">  Getting IPs </h2><br><p>  Regarding the discovery of servers with the NFS service on the global Internet, there are two possible ways: independently, using various tools, and out-of-the-box third-party scan results, databases and services.  In fact, it all comes down to getting a list of IP addresses.  In the local network, I think the option is obvious - to act independently. </p><br><p>  Evidence of the operation of the NFS service can be open TCP ports 111, 2049. <br>  To obtain a list of server IP addresses yourself, just scan the range of addresses or the entire subnet for the presence of the specified open ports.  Any tool will do for this: nmap, masscan, and so on. </p><br><p>  For example, <code>masscan -p111,2049 200.26.1XX.0/24 ‚Äîrate=10000</code> command <code>masscan -p111,2049 200.26.1XX.0/24 ‚Äîrate=10000</code> network 200.26.1XX.0 / 24 will be scanned in a few seconds for open ports 111, 2049: <br> <code>Scanning 256 hosts [2 ports/host]</code> <br> <code>Discovered open port 2049/tcp on 200.26.1XX.28</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.15</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.20</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.28</code> <br>  Further to each of the detected IP addresses it is possible to apply the command: <br> <code>showmount --no-headers -e 200.26.1XX.28</code> <br>  Result: <br> <code>/usr/common *</code> <br>  Obviously, it is possible to scan millions of IP addresses on the Internet itself, but this is not the fastest way and then the excellent service <a href="https://www.shodan.io/">Shodan</a> can be a subtask solution, there are of course others, but this one with a very convenient <a href="https://developer.shodan.io/">syntax</a> and <a href="https://developer.shodan.io/api">API</a> .  To delve into the description of the capabilities of the service is not the purpose of the article.  In short - the service provides an advanced search for devices connected to the Internet.  Search criteria can be network identifiers and other metadata: certificate serial numbers and the like.  In Shodan, there are many target search capabilities, but I did not find a separate NFS search, for example, by the product criterion with the product name indicated: mongodb, elastic or apache.  Therefore, through the Web NFS it is possible to search for the following queries: nfs, tcp 2049, tcp 111, <a href="https://www.shodan.io/search%3Fquery%3DPortmap%253A2049">Portmap: 2049,</a> and so on, as you like. </p><br><p><img src="https://habrastorage.org/webt/am/n2/hq/amn2hqii1_gsemlxivnffoawgek.png"></p><br><p>  Or install the Shodan client (CLI), initialize your API KEY to the service and call the search from the command line, for example: </p><br><ol><li>  shodan search --fields ip_str, port Portmap: 2049 </li><li>  shodan search --fields ip_str, port --separator, nfs <br>  Result: <br>  139.196.154.23,111, <br>  198.27.116.37,111, <br>  95.211.192.96,111, <br>  80.23.66.122,111, <br>  210.116.82.97,111, <br>  192.198.82.3,111, <br>  165.227.67.242,111, <br>  116.12.48.9,111, <br>  85.34.250.102,111, <br>  182.75.249.197,111, <br>  192.151.212.175,111, <br>  119.216.107.127,111, <br>  217.59.68.2,111, <br>  178.159.12.97,111, <br>  ... </li></ol><br><p>  So, how to get the lists of IP addresses of devices with a valid NFS service is understandable. </p><br><h2 id="poluchenie-informacii-o-dostupnyh-resursah-sluzhby-nfs-na-konkretnyh-serverah">  Get information about available NFS service resources on specific servers. </h2><br><p>  There are many ways to solve this task en masse: write bash-scripts, organize a cunning pipeline from a chain of commands with the showmount call, and other options - what do you like? </p><br><p>  In my research, I solved this problem in Python, and in two different ways.  The first is to connect via ssh to your personal Ubuntu server with an NFS client and then invoke the showmount command on it with the desired pool of IP addresses.  The second solution is pure Python. </p><br><p>  I suppose the question may arise: why is it so difficult, why in Python? </p><br><p>  Because, like in my previous article on Habr, I will use the tool Lampyre, to which an <a href="https://lampyre.io/python-api-doc/">API was</a> published on February 26 that allows you to write your own modules for the platform in Python. </p><br><div class="spoiler">  <b class="spoiler_title">Lampyre</b> <div class="spoiler_text"><p>  <em>Briefly about Lampyre - a software platform for OSINT and data analysis with a ‚Äúfat‚Äù client under Windows, an analogue of the well-known and popular tool for the same purposes - Maltego.</em>  <em>As in Maltego, a set of requests for various services is provided out of the box in Lampyre.</em>  <em>Requests are conceptually analogous to the transformations from a better known product.</em>  <em>If something is missing, it is now possible to write your own requests.</em>  <em>The queries that come with Lampyre are executed on the platform infrastructure, written independently - on the machine.</em>  <em>That is, the user must have Python installed and all the necessary libraries used in the code.</em> </p></div></div><br><p>  I decided to test the capabilities of the API.  The key point is that there are already several ‚Äúrequests‚Äù to Shodan in Lampyre, especially since you do not need to have your API KEY from the service.  Thus, in one request you can get lists of IP addresses with a raised NFS service, and with the second request, the module I wrote will check the available resources and visualize the result with the characteristics of the resources on the same graph. </p><br><h2 id="prichem-tut-koreya">  And here Korea </h2><br><p>  During the search from Shodan and testing of the module, it became interesting to see the situation with the quality and quantity of results of scanning by the Shodan service in Asian countries, how things are with unprotected resources.  The choice fell on the Republic of Korea, I think there is no need to say that South Korea is a very technologically advanced country, and I suggested that something interesting could be found in its networks. </p><br><p>  Search by Shodan, in Query: <strong>nfs</strong> , in Country: Republic of Korea code, <strong>kr</strong> </p><br><p><img src="https://habrastorage.org/webt/o0/e8/fy/o0e8fya-deqqydh5uaetrbgsvqe.png"></p><br><p>  The result was not long in coming (in the image below, only part of the overall scheme). </p><br><p><img src="https://habrastorage.org/webt/z1/-4/ir/z1-4ir1uwvo7buc3ie46qfcuuo0.png"></p><br><p>  List of hosts: </p><br><ul><li>  psi.kaist.ac.kr </li><li>  hulk.kaist.ac.kr </li><li>  messi.kaist.ac.kr </li><li>  marvel.kaist.ac.kr </li><li>  kaist.ac.kr </li><li>  ai1.kaist.ac.kr </li><li>  jarvis3.kaist.ac.kr </li><li>  baraddur.kaist.ac.kr </li><li>  rho.kaist.ac.kr </li><li>  jarvis.kaist.ac.kr </li></ul><br><p>  All of them, as can be seen on the graph, and by name - are listed as AS1781 - <a href="https://www.kaist.ac.kr/" title="KAIST">Korea Advanced Institute of Science and Technology</a> </p><br><p><img src="https://habrastorage.org/webt/ci/ez/nd/ciezndaw7a3brrrrxmcbe1wppak.png"></p><br><p>  <a href="https://en.wikipedia.org/wiki/KAIST" title="Wikipedia">The Korea Advanced Technology Institute</a> is the leading educational and research university in South Korea, located in Daejeon, located on the second line of the national ranking in South Korea.  The university is consistently included in 5% of top educational institutions in South Korea. </p><br><p>  These IP addresses are used as input arguments to the written module ‚ÄúExplore: NFS (SSH)‚Äù and as a result: </p><br><p><img src="https://habrastorage.org/webt/u2/dm/ur/u2dmurykafqs9yqdor1s06hg0wc.png"></p><br><p>  I quickly made such a scheme for displaying the results of a table in a graph (on the schemes and principles for constructing graphs further down the text of the article). </p><br><p><img src="https://habrastorage.org/webt/ev/v4/44/evv444hbsakygnttrnhxuinlmq0.png"></p><br><p>  The result of combining with the scheme Shodan </p><br><p><img src="https://habrastorage.org/webt/ys/pk/ij/yspkijyrvwhazpwjrzvfr5daabs.png"></p><br><p>  When analyzing the vertices and connections of the graph, it becomes obvious at what addresses the resource / home is located, accessible to all (*). </p><br><p>  For better visual perception, we change the properties of graph objects and other settings of the scheme: </p><br><p><img src="https://habrastorage.org/webt/nl/j5/9z/nlj59zv9p321nvnavqgin6krc1q.png"></p><br><p>  Of course, I in turn mounted some of the resources on one of my servers and began to study.  Everywhere it was almost the same - user directories: asm, hoo, hyshin, jay, jiwon, jkhee110, jokangjin, kmh603, ksm782, lee, linus, lost + found, marvel_guest, pie, qwe, scloud, seokmin, sgim, thrlek, yoosj, ysha, zinnia7. </p><br><p>  Almost all file directories were readable and writable.  Some users in .ssh had available the authorized_keys files with the ability to write to them. </p><br><p>  I generated my key, copied it to the authorized_keys of one of the users and connected to the server via ssh on port 2222, I got the port number from the data from Shodan. </p><br><p>  <em>Users, network settings:</em> </p><br><p><img src="https://habrastorage.org/webt/i4/gr/i5/i4gri5enls82hjdxe6hwtq-xqpq.png"></p><br><p>  <em>Hosts Online:</em> </p><br><p><img src="https://habrastorage.org/webt/bz/sg/y3/bzsgy3oti0hescz1uxmcud7krpa.png"></p><br><p>  <em>File / etc / exports and drives:</em> </p><br><p><img src="https://habrastorage.org/webt/1v/sk/7e/1vsk7eluqu93suzw5gxo65kbzg8.png"></p><br><p>  <em>File / etc / fstab and OS:</em> </p><br><p><img src="https://habrastorage.org/webt/uh/iv/cp/uhivcpdgcfzx1pezrbi_aguvgz4.png"></p><br><p>  I believe that this is a network of some department for graduate students or students, and on the servers they make some kind of calculations, because there are many different sources in Python, something related to the GPU and the Anaconda distribution, and so on.  I did not study everything and began to think what to do with all this, of course, I could ‚Äúwalk‚Äù for the most part <em>(it could be something more exotic)</em> , but it didn‚Äôt cause much interest for me.  And I thought of the following: once the institute is scientific and advanced, there should be directions in information security.  Indeed, even the whole lab: <a href="https://softsec.kaist.ac.kr/" title="softsec.kaist.ac.kr">Software Security Lab</a> and its head <a href="https://softsec.kaist.ac.kr/~sangkilc/">Sang Kil Cha</a> <br>  I decided to write him a letter, so they say, so it‚Äôs very possible to allow everyone on the Internet to connect NFS resources with read and write rights, it‚Äôs very likely that you need to fix something, attached screenshots and sent them. </p><br><div class="spoiler">  <b class="spoiler_title">Letter 1</b> <div class="spoiler_text"><blockquote>  <strong><em>Dear Sang Kil Cha,</em></strong> <strong><em><br></em></strong>  <strong><em>I‚Äôm writing how to use it.</em></strong> <strong><em><br></em></strong>  <strong><em>The following servers were detected:</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.131 - psi.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.4 - jarvis3.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.169</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.223</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.235</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.251 - marvel.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.239 - jarvis.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.194 - hulk.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.2.23</em></strong> <strong><em><br></em></strong>  <strong><em>All these servers have the NFS (Network File System) service up and running.</em></strong> <strong><em><br></em></strong>  <strong><em>This server is incredibly low.</em></strong> <strong><em><br></em></strong>  <strong><em>It can be accessed by anyone using the Internet.</em></strong> <strong><em><br></em></strong>  <strong><em>For example, settings nfs - / etc / exports 143.248.247.251 -&gt; / home <em>or for 143.248.247.239</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>showmount -e 143.248.247.239</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>Export list for 143.248.247.239:</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>/ data</em></em></strong> <strong><em><br></em></strong>  <strong><em>/ home <em>/ appl</em></em></strong> <strong><em><br></em></strong>  <strong><em>For example, the access control keys are not available.</em></strong> <strong><em><br></em></strong>  <strong><em>KAIST subnets.</em></strong> <strong><em><br></em></strong>  <strong><em>No modifications, no modifications, no modifications made, no data, no changes, no data, no corrections,</em></strong> <strong><em><br></em></strong>  <strong><em>Please note</em></strong> <strong><em><br></em></strong>  <strong><em>I recommend your network security level.</em></strong> </blockquote></div></div><br><p>  Soon I was told a free translation: thank you, we will send it to anyone. </p><br><div class="spoiler">  <b class="spoiler_title">Answer 1</b> <div class="spoiler_text"><blockquote>  <strong><em>Thanks for letting me know!</em></strong>  <strong><em>I will forward this email to someone in charge of our network and security.</em></strong>  <strong><em>Best, Sang Kil</em></strong> </blockquote></div></div><br><p>  Before publishing this article, I decided to check, see what has changed: </p><br><p><img src="https://habrastorage.org/webt/ia/w5/tv/iaw5tvajx2s5sw8l5rmed42cs2m.png"></p><br><p>  Indeed, access to resources was allowed only from machines on the internal network, but what about the server 143.248.247.251.  According to the entries in the table to the host resources in the NFS settings, it still remains *.  I sketched another version of the "mapping" of the table in the graph: </p><br><p><img src="https://habrastorage.org/webt/p0/fy/xu/p0fyxuck0k1mza0y-ebciyk9tik.png"></p><br><p>  What are the changes in "mapping": NFS objects are now "glued together" with 2 identical attributes - IP and NFS path.  The Status object is created only when the Value attribute, which contains the contents of the raw record column, contains the value " <strong>*</strong> " <br>  And the graph on the table appears in a new form: </p><br><p><img src="https://habrastorage.org/webt/zb/ht/k0/zbhtk0swvgaxzkogph-tlqn88_g.png"></p><br><p>  Now, by the way, the addressing of the internal network has become clearly visible, and on the server 143.248.247.251 it is also possible to edit the contents of user directories and files;  in principle, the possibilities remain the same as before. </p><br><p>  And here I am writing a second letter to Mr. Sang Kil Cha, with similar first content, noting that some of the events will be presented in an article on the popular resource habr.com: </p><br><div class="spoiler">  <b class="spoiler_title">Letter 2</b> <div class="spoiler_text"><blockquote>  <strong><em>Dear Sang Kil Cha, good day to you.</em></strong> <strong><em><br></em></strong>  <strong><em>I‚Äôve decided to take a look at it if I‚Äôve got it.</em></strong>  <strong><em>143.248.247.251 ip address stayed the same.</em></strong>  <strong><em>No strangers could access it.</em></strong> <strong><em><br></em></strong>  <strong><em>I‚Äôm writing an article on <a href="https://habr.com/">https://habr.com</a> .</em></strong>  <strong><em>This is a very popular website in Russia.</em></strong>  <strong><em>There will be a number of ways to manage your server.</em></strong>  <strong><em>When it's posted.</em></strong> </blockquote></div></div><br><h2 id="kak-ispolzovat-api-lampyre-i-napisat-svoy-modul">  How to use the Lampyre API and write your own module </h2><br><p>  The module will be required to accept a list of IP addresses or a list of subnets as 192.168.0 / 24 - at this stage, it will be necessary in the code to validate the input data on the involvement of strings to IP addresses, in the case of a subnet - convert to IP list. </p><br><p>  The next step, via the <a href="https://docs.paramiko.org/">paramiko</a> Python <a href="https://docs.paramiko.org/">library,</a> will be to access the personal ssh server and sequential (an asynchronous attempt is present in the module concept code) to invoke the command: <br> <code>timeout {timeouts} showmount --no-headers -e {ip}</code> <br>  The output of the result will be understood by means of Python code in the output structure, the table: a list of dictionaries in Python. <br>  Keys in the dictionary: </p><br><ul><li>  current_day - date of user request </li><li>  host_query - IP in relation to which we receive information </li><li>  shared_path - NFS resource </li><li>  status_ip - information about access to the resource, if IP addresses are listed through ‚Äú,‚Äù, the dictionary line is duplicated within the list. </li></ul><br><p>  Further, as conceived by the concept, a primitive attempt is made to parse the value of the status_ip key to the subject: IP address, host entry, ‚Äú*‚Äù or ‚Äúeveryone‚Äù values </p><br><p>  According to the <a href="https://lampyre.io/python-api-doc/api_explained/headers.html">API</a> documentation and explanations from support Lampyre.io - each module must return data to a table, one or more, but the table must be described within the framework of the API (Task headers, table header).  In fact - this is the main result of the module. <br>  Thus, the final result, taking into account the keys of the dictionary, will be the table: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFSHeader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=Header)</span></span></span><span class="hljs-class">:</span></span> display_name = <span class="hljs-string"><span class="hljs-string">'Search data from NFS services'</span></span> current_day = Field(<span class="hljs-string"><span class="hljs-string">'Date'</span></span>, ValueType.Datetime) host_query = Field(<span class="hljs-string"><span class="hljs-string">'Search ip'</span></span>, ValueType.String) shared_path = Field(<span class="hljs-string"><span class="hljs-string">'NFS path'</span></span>, ValueType.String) ip = Field(<span class="hljs-string"><span class="hljs-string">'ip address'</span></span>, ValueType.String) network = Field(<span class="hljs-string"><span class="hljs-string">'network address'</span></span>, ValueType.String) host = Field(<span class="hljs-string"><span class="hljs-string">'host'</span></span>, ValueType.String) status = Field(<span class="hljs-string"><span class="hljs-string">'raw record'</span></span>, ValueType.String)</code> </pre> <br><p>  The values ‚Äã‚Äã(slightly modified) from parsing the result of the showmount command on the server will be written to the table.  The names of the class fields speak for themselves, the raw record column will store information about the access to the resource.  Such analysis of data on NFS resources can be considered in some sense as OSINT, information about possible access from different IP addresses gives some idea about the owners of the resource or the addressing inside the network of the resource.  For example, the IP address of the server with the NFS service is located in Ukraine, and the IP address allowed for access is in Germany: </p><br><p><img src="https://habrastorage.org/webt/hp/mf/mr/hpmfmro1juiiepv15asjt1-wjuo.png"></p><br><p>  And if you expand the study of this example, then immediately there is a confirmation of the connection of servers not only through NFS, but also through one certificate at the addresses: 77.120.103.9, 138.201.202.135 and the domain * .aniart.com.ua: </p><br><p><img src="https://habrastorage.org/webt/1u/vv/cx/1uvvcxp71ezvhzbvjplr57agbtm.png"></p><br><p>  How to transfer data to the module and write to the table: <br>  create own class SearchDataNFS from class Task: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchDataNFS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span></span></code> </pre> <br><p>  In the <code>get_id</code> method, <code>get_id</code> return a unique random UUID: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'bf51fd57-3fec-4416-9d07-905935a484b4'</span></span></code> </pre> <br><p>  In the <code>get_display_name</code> method, <code>get_display_name</code> specify how the Task will be called, and in the <code>get_description</code> method, according to the name, the Task description: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_display_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Explore: NFS(SSH)'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Explore NFS resourses'</span></span></code> </pre> <br><p>  In the <code>get_headers</code> method, <code>get_headers</code> specify which tables we will use: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_headers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NFSHeader</code> </pre> <br><p>  The <a href="https://lampyre.io/python-api-doc/api_explained/params.html">get_enter_params</a> method will determine the appearance of the input data window.  It is obvious from the code that a list of strings is supplied to the input, which later on will be automatically converted into IP addresses: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_enter_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ep_coll = EnterParamCollection() ep_coll.add_enter_param(<span class="hljs-string"><span class="hljs-string">'ips'</span></span>, <span class="hljs-string"><span class="hljs-string">'IP'</span></span>, ValueType.String, is_array=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, value_sources=[Attributes.System.IPAddress], description=<span class="hljs-string"><span class="hljs-string">'IPs, networks'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ep_coll</code> </pre> <br><p>  In the <a href="https://lampyre.io/python-api-doc/api_explained/execution_process.html">execute</a> method, the main execution of the task takes place: </p><br><pre> <code class="python hljs">ips = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input_ip <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> z: z.strip(), enter_params.ips)): ips.extend(reparse_ip_hosts(input_ip))</code> </pre> <br><p>  Input parameters are accessed via enter_params.ips.  In the <code>reparse_ip_hosts</code> method, a self-implemented validation of strings into IP addresses occurs. </p><br><pre> <code class="python hljs">targets = ((ip, port) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ips <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ports) lines = thread_async_nfs_one_client(targets) info = reparse_result_rows(lines) fields_table = NFSHeader.get_fields() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> info: tmp = NFSHeader.create_empty() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fields_table: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data_id: tmp[fields_table[field]] = data_id[field] result_writer.write_line(tmp, header_class=NFSHeader)</code> </pre> <br><p>  The <code>thread_async_nfs_one_client</code> function connects to the server with ssh (IP address, login and password are set to hardcode) and runs showmount, as previously indicated, the result is parsed, then it is modified again in the <code>reparse_result_rows</code> function.  It is important to note, info is a list of dictionaries, in each dictionary the keys are named as fields of the NFSHeader class.  That is, the dictionary looks like this: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">'current_day'</span></span>: datetime.datetime(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>), <span class="hljs-string"><span class="hljs-string">'host_query'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.1.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'shared_path'</span></span>: <span class="hljs-string"><span class="hljs-string">'/volume1/workspace'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.10.10'</span></span>, <span class="hljs-string"><span class="hljs-string">'network'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'host'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'status'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.10.10'</span></span> }</code> </pre> <br><p>  It is important to observe the data types in the dictionary, they should be the same as in the table description. <br>  Later in the loop, iteration occurs over the elements of the list and write them through the API method ( <a href="https://lampyre.io/python-api-doc/autodocs/lighthouse_api.html">result_writer.write_line</a> ) into a specific NFSHeader table. <br>  For a more detailed description, you must read the documentation. <br>  In principle, the module is already ready to be added to Lampyre. </p><br><h2 id="ispolzovanie-svoego-modulya-v-lampyre">  Using your module in Lampyre </h2><br><p>  Due to the fact that using ssh and executing the showmount command, of course, you need to have access to your server via ssh.  For my tests, this role was played by the virtual machine in Virtualbox with Ubuntu and the NFS client installed on it. </p><br><p>  To work with its own modules on the user's machine, Python 3.6 is required, the path to the interpreter must be in the system variables, or the path to it is specified in the <code>Lampyre\config\appSettings.config</code> .  By default, the pythonPath key in the settings is commented out. </p><br><p>  The module is loaded into Lampyre in the following steps: </p><br><ol><li>  In the Scripts window, download the Lampyre file \ user_tasks \ ontology.py (supplied with the application) </li><li>  In the same window load your module, in this case nfs_via_ssh.py.  If something went wrong, the <em>Details</em> button should help. </li><li>  After loading, the <em>Local tasks</em> section appears in the <em>List of requests</em> window (in the module code it could be called differently), in it the name <em>Explore: NFS (SSH)</em> : <br><br><img src="https://habrastorage.org/webt/5j/q2/6w/5jq26wc0brfodioawferz1_mu-8.png"><br>  Updated List of requests window: <br><br><img src="https://habrastorage.org/webt/gv/gs/tb/gvgstbglshazcckwnl6wevpjlla.png"></li><li>  IP addresses of servers with NFS, as I said earlier, it is better to get after running the query <em>Shodan search</em> with the parameters <em>Query: tcp 2049</em> (you can simply specify <em>nfs</em> ).  The <em>Page or range</em> parameter set to 1 by default means that 1 page of responses from the Shodan service will be returned, on a page usually 100 results (lines). <br>  Result of execution Shodan: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/zb/ui/uw/zbuiuww94uf18wbzhh9pm2aomoe.png"></li><li>  Copy IP addresses from the table or from the scheme to the clipboard and paste it into the IP Explore: NFS (SSH) window.  Run and wait for the result: <br><br><img src="https://habrastorage.org/webt/t8/2h/vz/t82hvzwegvfjmbjcfch662vx7nk.png"></li></ol><br><p>  Of course, it is necessary to take into account the bandwidth from one's own and someone else's servers, and the timeout, which are strictly specified in the module code. </p><br><p>  The result is obtained in the form of a table, but you can continue and combine the result of the table with the results graph from the execution of Shodan search.  It will be somewhat difficult to understand at first. </p><br><h2 id="vizualizaciya-tablicy-s-rezultatom">  Visualization of the table with the result </h2><br><p>  Let's get started  There is a table with a set of columns with values ‚Äã‚Äãfrom the execution of the user module.  But if you pay attention to the Requests window Schema button - it is inactive.  Because it is not set to display the table in the graph and it must be set. </p><br><p>  <em><strong>Scheme 1 (not the best)</strong></em> <br>  With an open table from the result of the module in the bottom right corner there is an interface element ‚ÄúAdd creation template‚Äù, clicking on which the ‚ÄúCreation template‚Äù window appears.  In it, you can also set the mapping of the rows of the table to the objects of the graph, I will not describe the process in detail within the article, the link on <a href="https://youtu.be/d0AtN5yyBHA%3Ft%3D152" title="Lampyre tutorial - Financial analytics">the platform‚Äôs channel</a> on Youtube shows how to do this, I‚Äôm going to limit myself to images of what should happen: </p><br><p><img src="https://habrastorage.org/webt/qj/vd/ju/qjvdjurktmgvg17ymyrv_flbohu.png"></p><br><p>  Template for the graph: </p><br><p><img src="https://habrastorage.org/webt/am/n_/od/amn_odxussgaxfxuw_yzwwyu5ee.png"></p><br><p>  It is important to note that IP, Domain objects are in Lampyre, and I created NFS and Network objects.     ,    ¬´¬ª  . ,      ,    ‚Äî     ¬´¬ª   ‚Äî ,  ‚Äî    - ,          . ,   NFS ‚Äì  2 , NFS path  Status,   ‚Äî NFS path.      ‚Äî     .   ¬´¬ª        ‚Äî    <em>Schema</em>  . <br>  : </p><br><p><img src="https://habrastorage.org/webt/vy/al/oj/vyaloj8xba0pbjl7iiobalahaqy.png"></p><br><p>      : </p><br><p><img src="https://habrastorage.org/webt/ix/3u/jr/ix3ujruec1bbtfbbbi3i6ru_3mu.png"></p><br><p>      ¬´¬ª               ‚Äî <a href="https://www.ibm.com/ru-ru/marketplace/analysts-notebook">i2 (IBM i2 Analyst's Notebook)</a> : </p><br><p><img src="https://habrastorage.org/webt/w7/sr/dn/w7srdn9y0ko8jwqi2viop0uj4l8.png"></p><br><p>      ¬´¬ª  ,     :   IP-   IP-  ,    ,    NFS  ,          IP.     (      ). </p><br><p> <em><strong> 2</strong></em> </p><br><p><img src="https://habrastorage.org/webt/iy/y7/wt/iyy7wtjyjeb4onmq0vcjjxb50gu.png"></p><br><p>  .      ‚Äî     ,    IP-    : </p><br><p><img src="https://habrastorage.org/webt/n5/zw/sb/n5zwsbgrorkn2-vucszn1hulsgk.png"></p><br><p>           ,         ,       (csv)  .   ,     ¬´¬ª      .    ¬´¬ª         ,         . </p><br><p>       Shodan  NFS    Shodan search,   add to active tab          ‚Äî  : </p><br><p><img src="https://habrastorage.org/webt/qq/e-/3p/qqe-3p5p8bdbogvruzlqs8pypze.png"></p><br><p>  : </p><br><p><img src="https://habrastorage.org/webt/8w/uj/az/8wujazcvenzdsalorp1nh5mfas8.png"></p><br><p>    Lampyre <a href="https://github.com/Insurgent2018/Lampyre-requests"></a> ,          ssh. </p><br><p>   ‚Äî ,      NFS   . </p></div><p>Source: <a href="https://habr.com/ru/post/444382/">https://habr.com/ru/post/444382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444372/index.html">Machine orientation over long distances with automated reinforcement learning</a></li>
<li><a href="../444374/index.html">Hipster effect: why nonconformists often look the same</a></li>
<li><a href="../444376/index.html">Attention economy is almost dead</a></li>
<li><a href="../444378/index.html">USPACE - a single space for manned and unmanned aircraft</a></li>
<li><a href="../444380/index.html">Yandex and Hyundai will make a drone of the 5th level of autonomy</a></li>
<li><a href="../444384/index.html">The book "Applied analysis of textual data in Python"</a></li>
<li><a href="../444386/index.html">Lunar mission "Bereshit" - the fourth maneuver is completed successfully, preparations are under way to enter the lunar orbit</a></li>
<li><a href="../444388/index.html">Legendary modems of the past: the best connection holders in the conditions of domestic PBX</a></li>
<li><a href="../444390/index.html">DeviceLock 8.3 DLP system: a year has passed, Billy, but you haven't changed at all</a></li>
<li><a href="../444394/index.html">A new foundation for DevOps projects from the Linux Foundation began with Jenkins and Spinnaker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>