<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to sequels and macros on Scheme</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have not heard of call / cc, then you should definitely get acquainted with this powerful tool! Let's talk about the continuation (call / cc) ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to sequels and macros on Scheme</h1><div class="post__text post__text-html js-mediator-article">  If you have not heard of call / cc, then you should definitely get acquainted with this powerful tool!  Let's talk about the continuation <b>(call / cc)</b> , a simple but difficult to understand construction, which has tremendous power <i>in the right hands</i> .  We implement with them the mechanism of <b>yield / next / for ... in</b> , similar to that in Python.  Wrap the inside with a <b>macro</b> , another interesting <b>Scheme</b> mechanism. <br><br>  The article is aimed at <i>novice programmers</i> .  Lispery is unlikely to get something new, but I will be grateful for the errors found. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/files/78e/2bf/431/78e2bf4310ce4a0baee67be78a66b70d.png" alt="image"></div><br><a name="habracut"></a><br><h1>  What and why </h1><br>  Every programmer periodically encounters insufficient expressiveness of his code, when a simple beautiful idea requires writing hundreds of lines.  This has always pushed for the creation of new, more expressive tools such as the <abbr title="functional programming">OP</abbr> , with a much greater <i>density of meaning</i> per unit of program text. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Continuation <b>(continuation)</b> - is one of the mechanisms that allow the programmer to create such tools on the go.  The history of call / cc (call-with-current-continuation, a syntactic construct reflecting the idea of ‚Äã‚Äãcontinuations) is closely connected with <b>Scheme</b> , not the most popular language, which, however, has been a source of inspiration for programmers for several decades.  Therefore, the narration will be carried out in the Scheme language, and all the code samples are designed to be interpreted using <b>Guile</b> (I am sure that with almost zero effort, I‚Äôll get Racket, Chicken and, probably, one hundred other interpreters of this Lisp dialect). <br><br><h1>  Part I. Continuations </h1><br><h2>  Start (the essence of the sequels) </h2><br>  The sequel is GoTo's strongest brother, an operator <s>that cannot be used</s> .  Continuation allows: <br><br><ul><li>  Get (capture) the status of the program at the moment </li><li>  Save this state (there are other options) </li><li>  Return to this state later, whenever you want </li></ul><br>  But why go back to the past? <br><br><ul><li>  To go forward again, having organized a cycle.  This is a rather naive application (in fact, using GoTo). </li><li>  To understand the real power of continuations, you need to find out what the ‚Äústate of the program‚Äù mentioned above means.  In fact, the current function call stack is saved, that is, the <b>current context</b> .  But the next function, which should return the value of the previous one (that is, the one that we actually wrap with the <b>call / cc</b> construct - see below), is not preserved.  Later, it can be replaced by another code (in particular, some constant).  Imagine that you can return to yourself from the future and pass on to your past any knowledge / material objects / directions for further action! </li></ul><br><img width="300" align="left" src="https://habrastorage.org/files/0c9/c24/897/0c9c2489788c4bbc82a553a3c42226ad.png">  Let us explain what has been said in practice: <br><br>  Imagine a piece of the program.  Function 1 calls function 2, it calls function 3 from some other variables.  Before calling, say, function 2, save the state (called the <b>current context</b> ).  Subsequently, at any moment we can return to this context, <i>replacing the</i> result of the function chain <code>(func2 (func3 abc))</code> value we need, for example, d. <br><br>  Let's check that everything works really well. <br><br><h2>  First example </h2><br>  Let's create some spherical example in vacuum.  Define the <code>test-func</code> function: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;     (define test-func (if (&gt; 3 5) "true " "false ")) (display test-func) (newline)</span></span></code> </pre><br>  Result (obvious): <br><br><pre> <code class="bash hljs">&gt;&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br>  Now save the context before evaluating the condition in the if.  Let's see how to do it: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">Some</span></span> actions)))</code> </pre><br>  The appearance of <b>call / cc</b> requires the interpreter to take the current context and pass it to the lambda function defined by us inside.  The lambda function takes one argument (hereinafter in the texts of the programs we will call it <b>cc</b> - abbreviated from "current continuation").  We can keep this context: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> *env* #f) (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">begin</span></span> (<span class="hljs-name"><span class="hljs-name">set!</span></span> *env* cc) <span class="hljs-comment"><span class="hljs-comment">;   cc,      *env* (Some actions))))</span></span></code> </pre><br>  Now we will make magic.  Take the saved context, and move on to it.  We wrapped the <b>call / cc</b> construct with a condition in the if block, so when we call the context, we need to pass the value that should be returned instead of the calculation <code>(&gt; 3 5)</code> . <br><br>  This is done like this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">*env*</span></span> Any_value)</code> </pre><br>  Here, ‚ÄúAny value‚Äù can be placed on any code that returns some value, or this value itself. <br><br>  Now, if we write: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">*env*</span></span> #t)</code> </pre><br>  we will return to the point where the context was received, and everything will look to the code external to the block <code>(call/cc ...)</code> as if the function inside this block (if condition) returned #t! <br><br><h2>  So the result </h2><br><h4>  <b>UPDATE</b> : </h4>  Comments gave an understanding that the code <code>(display (*env* #t))</code> can confuse you.  The construction (display ..) in this line will never print anything, because as soon as the interpreter reaches <code>(*env* #t)</code> , an irretrievable transition to another state will be made (more details in the comments).  Thus, the operation of the following code <strong>does</strong> not change from the replacement <code>(display (*env* #t))</code> to <code>(*env* #t)</code> . <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> test-func (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">begin</span></span> (<span class="hljs-name"><span class="hljs-name">set!</span></span> *env* cc) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>)) )) <span class="hljs-string"><span class="hljs-string">"true "</span></span> <span class="hljs-string"><span class="hljs-string">"false "</span></span>)) (<span class="hljs-name"><span class="hljs-name">display</span></span> test-func) (<span class="hljs-name"><span class="hljs-name">display</span></span> (<span class="hljs-name"><span class="hljs-name">*env*</span></span> #t)) (<span class="hljs-name"><span class="hljs-name">newline</span></span>)</code> </pre><br><pre> <code class="bash hljs">&gt;&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...</code> </pre><br>  Everything works as we wanted, but ... an endless cycle ?!  Calmly, all in agreement with the theory.  Let's look at how this example works. <br><br><div style="text-align:center;"><img width="800" src="https://habrastorage.org/files/a03/ea8/181/a03ea8181b874bbf9e7d8dab154732c3.png"></div><br><br>  We return to the program state somewhere inside the call stack generated (display ...).  There we substitute the #t that is pleasing to us (affecting the result), a safe exit from (display ...) is made, (* env * #t) is called, and in a new way ... <br><br><h2>  We make our own generator </h2><br>  The first acquaintance with call / cc evokes an understanding of the power of this tool, but it is far from immediately obvious how to use it and what can be realized.  The classic list of things implemented using call / cc includes <i>loops, loop exit or recursion, loop exit or recursion with return, coroutines, and co-operative multitasking</i> .  Thus, continuations can change the flow of program execution in all imaginable ways. <br><br>  Let's try to use this feature to implement in Scheme the equivalent of generators in Python.  We require that the result be as follows: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;    (define-generator (generator-func arg1 arg2 ...) (... (yield result) ;    ...)) ;   .  my-gen ‚Äî : (define my-gen (generator-func 10 30 ...)) (display my-gen) ;    (display my-gen) ;    ;   ,   (for item in (generator-func 100 70 ...) (display item))</span></span></code> </pre><br>  Perhaps not as concise as in Python, but Scheme is still limited by its syntax (which does not prevent it from being extremely simple and incredibly versatile). <br><br><h2>  First blanks </h2><br>  The implementation of the <code>yield</code> function is almost obvious.  You need to save the current context (to continue with it later), then make a jump to where the generator was called from and replace the generator with the value returned by the yield: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">yield</span></span> value) (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> *env* cc) <span class="hljs-comment"><span class="hljs-comment">;   (*return* value)))) ;    ,  ,   value</span></span></code> </pre><br><ul><li>  It is immediately clear that each generator (there may be several of them in the program) must have its own <code>*env*</code> and <code>*return*</code> , stored within a certain local scope. </li><li>  From the first it follows that <code>yield</code> cannot be global, which means that it needs to be passed to the function that calls <code>yield</code> </li></ul><br>  We realize this by writing an example of a square number generator from 1 to n: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">create-generator</span></span> func) (<span class="hljs-name"><span class="hljs-name">define</span></span> *env* (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">func</span></span> yield))) (<span class="hljs-name"><span class="hljs-name">define</span></span> *return* #f) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">yield</span></span> value) (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> *env* cc) (<span class="hljs-name"><span class="hljs-name">*return*</span></span> value)))) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (   ))) <span class="hljs-comment"><span class="hljs-comment">;    (define (squares-gen n) (lambda (yield) (let loop ((n (+ n 1)) (kn)) (if (&gt; k 0) (begin (yield (expt (- nk) 2)) (loop n (- k 1)))))))</span></span></code> </pre><br><h2>  Almost done </h2><br>  The case is left for small: you need to write something in the variable <code>*return*</code> .  In order for the generator, once called, to return the value, you need to save the context at the very beginning of the generator, in order to later replace its internal part with the return value.  This is what the picture from the beginning of the post says: <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/files/78e/2bf/431/78e2bf4310ce4a0baee67be78a66b70d.png" alt="image"></div><br><br>  We are in some part of the program and we want to go further, forward.  But for this you need to get the next value from the generator (box c).  We go into the generator (save the state and go up the stairs), select the box and "teleport" back (back to the saved state), but already with the box!  In fact, you need to add a couple of lines: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">create-generator</span></span> func) (<span class="hljs-name"><span class="hljs-name">define</span></span> ...) ... (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> *return* cc) (<span class="hljs-name"><span class="hljs-name">*env*</span></span>))))) <span class="hljs-comment"><span class="hljs-comment">;      func,     , ;  (yield smth)   func... !</span></span></code> </pre><br><h2>  Result </h2><br>  Putting it all together: <br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">create-generator</span></span> func) (<span class="hljs-name"><span class="hljs-name">define</span></span> *env* (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">func</span></span> yield))) (<span class="hljs-name"><span class="hljs-name">define</span></span> *return* #f) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">yield</span></span> value) (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> *env* cc) (<span class="hljs-name"><span class="hljs-name">*return*</span></span> value)))) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">cc</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> *return* cc) (<span class="hljs-name"><span class="hljs-name">*env*</span></span>))))) <span class="hljs-comment"><span class="hljs-comment">;    (define (squares-gen n) (lambda (yield) (let loop ((n (+ n 1)) (kn)) (if (&gt; k 0) (begin (yield (expt (- nk) 2)) (loop n (- k 1))))))) (define my-gen (create-generator (squares-gen 10)))</span></span></code> </pre> </div></div><br>  Checking: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;  my-gen 7  (let loop ((n 7)) (if (&gt; n 0) (begin (display (my-gen)) (display " ") (loop (- n 1)))))</span></span></code> </pre><br><br><pre> <code class="bash hljs">&gt;&gt; 1 4 9 16 25 36 49</code> </pre> <br>  <strong>Hooray!</strong>  <strong>Works!</strong> <br><br><h2>  Comment </h2><br>  I hope you noticed one obvious mistake.  If we call the received generator more than 10 times, we will enter an infinite loop.  Calling <code>(*env*)</code> , we completely return to the state in which we were at the last iteration, because we do not save the new, because we do not reach <code>yield</code> in the code of the generator function.  You can do this, for example, as follows: if the generator cannot produce the next value, it returns a stub value, for example, <b>‚ÄúStop Iteration‚Äù</b> . <br><br>  How to do it?  Check yourself for understanding, invent yourself (welcome to the comments).  Just add one line of code inside <code>(define (create-generator func) ...)</code> . <br><br><h1>  Part II.  Macros </h1><br><h2>  What for? </h2><br>  We have achieved the behavior we need.  But the syntax is not the same.  To create a generator function, we need to wrap it with a lambda function, make a lot of unnecessary gestures ... fortunately, Scheme has a powerful <b>macro</b> mechanism.  Macros, as always, are evil, if you cram them everywhere, but if you write once and for a long time, why not make your life easier with beautiful syntactic sugar? <br><br><h2>  Short description </h2><br>  <strong>Macros are covered on the Internet much better than the sequels, so only briefly leave them (the second reason is the unexpectedly large size of the article; if the community considers it necessary to have a detailed description of macros in Scheme, I will write the second article).</strong> <br><br><ul><li>  The macros in Scheme are similar to the preprocessor in C. Macros are expanded before being translated into bytecode. </li><li>  Macros convert syntactic constructs, and only them.  We write some lines of code, others are output. </li><li>  <code>define-syntax</code> and others like it determine the rules by which the designated conversion occurs. </li></ul><br>  <strong>Probably</strong> , it would be wrong to essentially duplicate what was said more than once, including on Habr√©. <br>  The basics of macros in Scheme (search on page: ‚ÄúMacros‚Äù): <a href="https://habrahabr.ru/company/tcsbank/blog/267113/">habrahabr.ru/company/tcsbank/blog/267113</a> <br><br>  Here we consider the subtlety that will play a significant role. <br><br>  Let's write an example of a macro that defines a function that simply summarizes the elements of the list (for this, the macro is, of course, not needed; an example, as always, from the air, but necessary for understanding): <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;    (sum (list 5 9 1 ...)) (define-syntax sum (syntax-rules () ((_ args-list) (let loop ((res 0) (left-list args-list)) (if (not (null? left-list)) (loop (+ res (car left-list)) (cdr left-list)) res))))) (display (sum (list 3 4 5 1))) (newline)</span></span></code> </pre><br><pre> <code class="bash hljs">&gt;&gt; 13</code> </pre> <br>  Everything is working. <br><br>  And now let's do this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> loop (<span class="hljs-name"><span class="hljs-name">list</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">display</span></span> (<span class="hljs-name"><span class="hljs-name">sum</span></span> loop))</code> </pre><br>  Can you imagine in what mess this macro will unfold (due to the coincidence of the names - loop, inside the macro and outside)?  Eh, compilation errors will be sprinkled now ... Run ... <br><br><pre> <code class="bash hljs">&gt;&gt; 13</code> </pre><br>  Oh really?!  How could this work?  In fact, in Scheme, a macro is not as straightforward as it seems.  In our case, the macro will unfold in: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">let</span></span> loop-1 ((<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">left-list</span></span> loop)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span>? left-list)) (<span class="hljs-name"><span class="hljs-name">loop-1</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> res (<span class="hljs-name"><span class="hljs-name">car</span></span> left-list)) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> left-list)) res))</code> </pre><br>  Macros can define name conflicts outside and inside, so the internal variable <code>loop</code> has a different name, <code>loop-1</code> . <br><br><h2>  Syntax-case, with-syntax, datum-&gt; syntax </h2><br>  In our case, unfortunately, such intelligence of the macro only interferes.  Inside the macro, we will certainly use <code>yield</code> , which will certainly translate to <code>yield-1</code> . <br><br>  To make the macro work the way we need it, there is a more powerful construct, <code>syntax-case</code> . <br><br>  The article and so it turned out too big, so a detailed description of this tool will be in the next publication (if necessary). <br><br>  The syntax is similar to <code>syntax-rules</code> , the difference in the wrapper is from the lambda function and the way the value is returned, via <code>(syntax something)</code> is a function that returns a syntax structure built from ‚Äúsomething‚Äù. <br><br>  There is an abbreviation for <code>(syntax ...)</code> : <code>#'</code> in Scheme. <br>  The previous example will be rewritten as follows (and the code below is equivalent in all senses to code using <code>syntax-rules</code> ): <br><br><div class="spoiler">  <b class="spoiler_title">sum via syntax-case</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> sum (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">syntax-case</span></span> x () ((<span class="hljs-name"><span class="hljs-name">_</span></span> args-list) #'(let loop ((res <span class="hljs-number"><span class="hljs-number">0</span></span>) (left-list args-list)) (if (not (null? left-list)) (loop (+ res (car left-list)) (cdr left-list)) res))))))</code> </pre><br></div></div><br>  You can enter the object identifier from the scope that is external to the macro (from the usual Scheme, so to speak) into the internal scope of the macro using <code>datum-&gt;syntax</code> . <br><br>  For example, to ensure that <code>yield</code> does not turn into <code>yield-1</code> inside <code>(syntax ...)</code> , you can do this: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> sum (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">syntax-case</span></span> x () ((<span class="hljs-name"><span class="hljs-name">pattern</span></span>) (<span class="hljs-name"><span class="hljs-name">syntax-case</span></span> (<span class="hljs-name"><span class="hljs-name">datum-&gt;syntax</span></span> x 'yield) () (<span class="hljs-name"><span class="hljs-name">yield</span></span> (<span class="hljs-name"><span class="hljs-name">syntax</span></span> ... yield ...)))))))</code> </pre><br>  Scheme offers some syntactic sugar to make this code look nicer: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> sum (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">syntax-case</span></span> x () ((<span class="hljs-name"><span class="hljs-name">pattern</span></span>) (<span class="hljs-name"><span class="hljs-name">with-syntax</span></span> (<span class="hljs-name"><span class="hljs-name">yield</span></span> (<span class="hljs-name"><span class="hljs-name">datum-&gt;syntax</span></span> x 'yield)) (<span class="hljs-name"><span class="hljs-name">yield</span></span> (<span class="hljs-name"><span class="hljs-name">syntax</span></span> ... yield ...)))))))</code> </pre><br>  As a result, we used <code>syntax-case</code> to, in fact, create a simple macro in which we can use <code>yield</code> without any problems, and everything will work as we expect. <br><br><h2>  Finally, use macros in </h2><br>  Recall the syntax we sought: <br><br><div class="spoiler">  <b class="spoiler_title">Syntax</b> <div class="spoiler_text"><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;    (define-generator (generator-func arg1 arg2 ...) (... (yield result) ;    ...)) ;   .  my-gen -- : (define my-gen (generator-func 10 30 ...)) (display my-gen) ;    (display my-gen) ;   </span></span></code> </pre><br></div></div><br>  Create a macro define-generator, which creates a function of the arguments arg1, arg2 ..., which returns the generator.  The code is similar to what we have already written: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   : (define-syntax define-generator (lambda (x) ;   syntax-case (syntax-case x () ((_ (name . args) body) (with-syntax ((yield (datum-&gt;syntax x 'yield))) ;    yield     (syntax (define (name . args) ;   ,     ,    (define *env* (lambda () (body))) ;     ,    (define *return* #f) (define (yield value) (call/cc (lambda (cc) (set! *env* cc) (*return* value)))) (lambda () (call/cc (lambda (cc) (set! *return* cc) (*env*))))))))))) (define-generator (squares-gen n) (let loop ((n (+ n 1)) (kn)) (if (&gt; k 0) (begin (yield (expt (- nk) 2)) (loop n (- k 1)))))) (define my-gen (squares-gen 10)) (let loop ((n 7)) (if (&gt; n 0) (begin (display (my-gen)) (display " ") (loop (- n 1)))))</span></span></code> </pre> <br><pre> <code class="bash hljs">&gt;&gt; 1 4 9 16 25 36 49</code> </pre> <br>  <strong>Hooray again!</strong>  <strong>Works!</strong> <br><br><h2>  Afterword </h2><br>  If suddenly you knew a little about the sequels and macros, and I managed to convey to you what is written above, then you can easily write the implementation <code>for ... in ...</code> by analogy <code>for ... in ...</code> Do not forget the error intentionally left in the code. <br><br>  Thank you, if you have read to the end.  I hope that now Scheme will give someone else some inspiration in our favorite business. </div><p>Source: <a href="https://habr.com/ru/post/302186/">https://habr.com/ru/post/302186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302172/index.html">Hosting provider RUVDS joins ISIC student discount program partners</a></li>
<li><a href="../302174/index.html">Cloud computing economics</a></li>
<li><a href="../302176/index.html">FileChangesWatcher</a></li>
<li><a href="../302178/index.html">Fiery number system, or why 1 + 10 = 100</a></li>
<li><a href="../302180/index.html">Introduction to the DLMS / COSEM stack for the MS Instruments MSP430 family of Texas Instruments</a></li>
<li><a href="../302188/index.html">DevConf :: JavaScript - support your favorite JS framework</a></li>
<li><a href="../302192/index.html">Workshops to identify requirements for IT-projects: how and why to carry them out?</a></li>
<li><a href="../302194/index.html">Smart Transport: New Information Security Challenges</a></li>
<li><a href="../302196/index.html">Lasers for Guidance and Geodesy: Innovations from ITMO University</a></li>
<li><a href="../302198/index.html">Analysis of VoIP calls in Wireshark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>