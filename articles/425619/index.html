<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multi-armed gang problem - compare epsilon-greedy strategy and Thompson sampling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article Solving multiarmed bandits: A comparison of epsilon-greedy and Thompson sampling ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multi-armed gang problem - compare epsilon-greedy strategy and Thompson sampling</h1><div class="post__text post__text-html js-mediator-article">  <i>Hi, Habr!</i>  <i>I present to your attention the translation of the article <a href="https://towardsdatascience.com/solving-multiarmed-bandits-a-comparison-of-epsilon-greedy-and-thompson-sampling-d97167ca9a50">Solving multiarmed bandits: A comparison of epsilon-greedy and Thompson sampling</a> .</i> <br><br><h1>  The task of the multi-armed gang </h1><br><p>  The multi-armed gang problem is one of the most basic tasks in the science of solutions.  Namely, this is the problem of optimal allocation of resources under uncertainty conditions.  The name "multi-armed gangster" came from the old slot machines, which were controlled with pens.  These guns were nicknamed ‚Äúbandits,‚Äù because after talking with them, people usually felt robbed.  Now imagine that there are several such machines and the chance to win against different machines is different.  Since we started to play with these machines, we want to determine which chance is higher and to use (exploit) this machine more often than others. </p><br><p>  The problem is this: how is it most effective for us to understand which machine is best suited, and at the same time try out many possibilities in real time?  This is not a theoretical problem, it is a problem that a business faces all the time.  For example, a company has several options for messages that should be shown to users (messages include, for example, advertising, websites, images) so that the selected messages maximize a certain business task (conversion, clickability, etc.) </p><br><a name="habracut"></a><p>  A typical way to solve this problem is to run <a href="https://ru.wikipedia.org/wiki/A/B-%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">A / B tests</a> many times.  Ie some weeks to show each of the options equally often, and then, based on statistical tests, decide which option is better.  This method is suitable when there are few options, say 2 or 4. But when there are many options, this approach becomes ineffective - both for lost time and lost profits. </p><br><p>  Where the lost time comes from should be easily understood.  More options - more A / B tests are needed - more time is needed to make a decision.  The loss of profits is not so obvious.  Opportunity (opportunity cost) - the costs associated with the fact that instead of one action we did another, that is, to put it simply, this is what we lost by investing in A instead of B. Investing in B - and there is a loss of investment gain in A. Same with checking options.  A / B tests should not be interrupted until they are over.  This means that the experimenter does not know which option is better until testing has ended.  However, it is still assumed that one option will be better than the other.  This means that by extending the A / B tests, we do not show the best options to a sufficiently large number of visitors (although we don‚Äôt know which options are not the best), thereby losing our profit.  This is the loss of profits from A / B testing.  If there is only one A / B test, then perhaps the loss of profit is not great at all.  A large number of A / V tests means that we have to show clients a lot of not the best options for a long time.  It would be better if it were possible to quickly discard bad options in real time, and only then, when there are few options, use A / B tests for them. </p><br><p>  Samplers or agents are ways to quickly test and optimize the distribution of variants.  In this article, I will introduce you to <i>Thompson sampling</i> and its properties.  I will also compare Thompson sampling with the epsilon-greedy algorithm ‚Äî another popular option for the multiarmed gangster problem.  Everything will be implemented in Python from scratch - all the code can be found <a href="https://github.com/conormm/bandit_algorithms/blob/master/bandits_post_code.py">here</a> . </p><br><h2>  A brief dictionary of concepts </h2><br><p></p><ul><li>  Agent, sampler, gangster ( <i>agent, sampler, bandit</i> ) - an algorithm that makes decisions about which option to show. </li><li>  Option ( <i>variant</i> ) - a different version of the message that the visitor sees. </li><li>  Action ( <i>action</i> ) - the action that the algorithm chose (which option to show). </li><li>  Use ( <i>exploit</i> ) - to make a choice in order to maximize the total reward based on the available data. </li><li>  Explore, try ( <i>explore</i> ) - make a choice to better understand the return on investment for each option. </li><li>  Reward points ( <i>score, reward</i> ) - a business task, for example, conversion or clickability.  For simplicity, we assume that it is distributed binomially and is either 1 or 0 - clicked or not. </li><li>  Environment - the context in which the agent works - options and their ‚Äúpayback‚Äù hidden for the user. </li><li>  Payback <i>rate</i> , success rate ( <i>payout rate</i> ) is a hidden variable equal to the probability of getting a score = 1, for each option it has its own.  But the user does not see it. </li><li>  Trial ( <i>trial</i> ) - the user visits the page. </li><li>  Regret is the difference between what would be the best result of all the available options and what was the result of the option available on the current attempt.  The less regret for actions already done, the better. </li><li>  Message ( <i>message</i> ) - a banner, a variant of the page, etc., the different versions of which we want to try. </li><li>  Sampling - the generation of a sample of a given distribution. </li></ul><br><h2>  Explore and exploit </h2><br><p>  Agents are algorithms that look for an approach to choosing real-time solutions in order to achieve a balance between exploring the space of options and using the most optimal option.  This balance is very important.  The space of options must be explored in order to have an idea of ‚Äã‚Äãwhich option is the best.  If we first find this very optimal option, and then use it all the time, we maximize the total reward that is available to us from the environment.  On the other hand, we also want to explore other possible options - what if they turn out to be better in the future, but we just don't know that yet?  In other words, we want to insure against possible losses by trying to experiment a little with suboptimal options in order to clarify for themselves their payback.  If their payback is actually higher, they can be shown more often.  Another advantage of exploring options is that we can better understand not only the average payback, but also how roughly the payback is distributed, that is, we can better estimate the uncertainty. <br>  The main problem, therefore, is to solve it - how best to get out of the dilemma between exploration and exploitation (exploration-exploitation tradeoff). </p><br><h2>  Epsilon-greedy algorithm (epsilon-greedy algorithm) </h2><br><p>  A typical way to get out of this dilemma is the epsilon-greedy algorithm.  ‚ÄúGreedy‚Äù means exactly what you think.  After a certain initial period, when we accidentally make attempts - say, 1000 times, the algorithm greedily chooses the best variant k in <i>e</i> percent of attempts.  For example, if <i>e</i> = 0.05, the algorithm chooses the best option 95% of the time, and selects random attempts in the remaining 5% of the time.  In fact, this is a fairly efficient algorithm, however, it may not sufficiently explore the space of options, and therefore, it is not good enough to evaluate which option is the best, to get stuck on a suboptimal version.  Let's show in the code how this algorithm works. </p><br><p>  But first, some dependencies.  We need to define the environment.  This is the context in which the algorithms will run.  In this case, the context is very simple.  He calls the agent so that the agent decides which action to choose, then the context then starts the action and returns the points received for it back to the agent (which somehow updates its state). </p><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Environment</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, variants, payouts, n_trials, variance=False)</span></span></span><span class="hljs-function">:</span></span> self.variants = variants <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> variance: self.payouts = np.clip(payouts + np.random.normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>, size=len(variants)), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.payouts = payouts <span class="hljs-comment"><span class="hljs-comment">#self.payouts[5] = self.payouts[5] if i &lt; n_trials/2 else 0.1 self.n_trials = n_trials self.total_reward = 0 self.n_k = len(variants) self.shape = (self.n_k, n_trials) def run(self, agent): """Run the simulation with the agent. agent must be a class with choose_k and update methods.""" for i in range(self.n_trials): # agent makes a choice x_chosen = agent.choose_k() # Environment returns reward reward = np.random.binomial(1, p=self.payouts[x_chosen]) # agent learns of reward agent.reward = reward # agent updates parameters based on the data agent.update() self.total_reward += reward agent.collect_data() return self.total_reward</span></span></code> </pre> <br>  Points are distributed binomially with probability p, depending on the number of the action (just as they could be distributed and continuously, the essence would not have changed).  I will also define the BaseSampler class ‚Äî I just need it to store logs and various attributes. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseSampler</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, env, n_samples=None, n_learning=None, e=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.05</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.env = env self.shape = (env.n_k, n_samples) self.variants = env.variants self.n_trials = env.n_trials self.payouts = env.payouts self.ad_i = np.zeros(env.n_trials) self.r_i = np.zeros(env.n_trials) self.thetas = np.zeros(self.n_trials) self.regret_i = np.zeros(env.n_trials) self.thetaregret = np.zeros(self.n_trials) self.a = np.ones(env.n_k) self.b = np.ones(env.n_k) self.theta = np.zeros(env.n_k) self.data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.reward = <span class="hljs-number"><span class="hljs-number">0</span></span> self.total_reward = <span class="hljs-number"><span class="hljs-number">0</span></span> self.k = <span class="hljs-number"><span class="hljs-number">0</span></span> self.i = <span class="hljs-number"><span class="hljs-number">0</span></span> self.n_samples = n_samples self.n_learning = n_learning self.e = e self.ep = np.random.uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, size=env.n_trials) self.exploit = (<span class="hljs-number"><span class="hljs-number">1</span></span> - e) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collect_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.data = pd.DataFrame(dict(ad=self.ad_i, reward=self.r_i, regret=self.regret_i))</code> </pre> <br>  Below we define 10 options and payback for each.  The best option is option 9 with a payback of 0.11%. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="python hljs">variants = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] payouts = [<span class="hljs-number"><span class="hljs-number">0.023</span></span>, <span class="hljs-number"><span class="hljs-number">0.03</span></span>, <span class="hljs-number"><span class="hljs-number">0.029</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>, <span class="hljs-number"><span class="hljs-number">0.0234</span></span>, <span class="hljs-number"><span class="hljs-number">0.035</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">0.11</span></span>]</code> </pre> <br>  In order to make a start, we also define the class RandomSampler.  This class is needed as a baseline model.  He simply chooses an option on every attempt and does not update his parameters. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomSampler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseSampler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, env)</span></span></span><span class="hljs-function">:</span></span> super().__init__(env) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choose_k</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.k = np.random.choice(self.variants) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.k <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># nothing to update #self.thetaregret[self.i] = self.thetaregret[self.i] #self.regret_i[self.i] = np.max(self.thetaregret) - self.theta[self.k] #self.thetas[self.i] = self.theta[self.k] self.thetaregret[self.i] = np.max(self.theta) - self.theta[self.k] self.a[self.k] += self.reward self.b[self.k] += 1 self.theta = self.a/self.b self.ad_i[self.i] = self.k self.r_i[self.i] = self.reward self.i += 1</span></span></code> </pre> <br><p>  Other models have the following structure.  All have methods choose_k and update.  choose_k implements the method by which the agent chooses an option.  update updates the parameters of the agent - this method describes how the ability of the agent to select an option changes (for RandomSampler this possibility does not change at all).  We run the agent in the environment using the following pattern. </p><br><pre> <code class="python hljs">en0 = Environment(machines, payouts, n_trials=<span class="hljs-number"><span class="hljs-number">10000</span></span>) rs = RandomSampler(env=en0) en0.run(agent=rs)</code> </pre> <br><p>  The essence of the epsilon-greedy algorithm is as follows. <br><br></p><ol><li>  Randomly select k for n attempts. </li><li>  For each attempt to evaluate the gain for each option. </li><li>  After all n attempts: </li><li>  With a probability of 1‚Äì <i>e,</i> choose the k with the highest gain; </li><li>  With probability <i>e,</i> choose K randomly. </li></ol><br>  Epsilon Greedy Code: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eGreedy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseSampler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, env, n_learning, e)</span></span></span><span class="hljs-function">:</span></span> super().__init__(env, n_learning, e) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choose_k</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># e% of the time take a random draw from machines # random k for n learning trials, then the machine with highest theta self.k = np.random.choice(self.variants) if self.i &lt; self.n_learning else np.argmax(self.theta) # with 1 - e probability take a random sample (explore) otherwise exploit self.k = np.random.choice(self.variants) if self.ep[self.i] &gt; self.exploit else self.k return self.k # every 100 trials update the successes # update the count of successes for the chosen machine def update(self): # update the probability of payout for each machine self.a[self.k] += self.reward self.b[self.k] += 1 self.theta = self.a/self.b #self.total_reward += self.reward #self.regret_i[self.i] = np.max(self.theta) - self.theta[self.k] #self.thetaregret[self.i] = self.thetaregret[self.i] self.thetas[self.i] = self.theta[self.k] self.thetaregret[self.i] = np.max(self.thetas) - self.theta[self.k] self.ad_i[self.i] = self.k self.r_i[self.i] = self.reward self.i += 1</span></span></code> </pre> <br><br><p>  Below on the graph you can see the results of a purely random sampling, that is, in other words, there is no model here.  The graph shows what choice the algorithm made on each attempt, if there were 10 thousand attempts.  The algorithm only tries, but does not learn.  He scored 418 points in total. <br> <a href=""><img src="https://habrastorage.org/webt/sn/ql/2r/snql2roqbdiruuskxsathithz8i.jpeg"></a> </p><br><p>  Let's see how the epsilon-greedy algorithm behaves in the same environment.  Let's run the algorithm for 10 thousand attempts with <i>e</i> = 0.1 and n_learning = 500 (the agent simply tries the first 500 attempts, then tries it with probability <i>e</i> = 0.1).  We will evaluate the algorithm according to the total number of points it collects in the environment. </p><br><pre> <code class="python hljs">en1 = Environment(machines, payouts, n_trials) eg = eGreedy(env=en1, n_learning=<span class="hljs-number"><span class="hljs-number">500</span></span>, e=<span class="hljs-number"><span class="hljs-number">0.1</span></span>) en1.run(agent=eg)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/-f/zf/14/-fzf14djbqtdl5-0vyrapuhcp5c.jpeg"></a> <br><p>  Epsilon-greedy algorithm scored 788 points, almost 2 times better than a random algorithm - super!  The second graph explains this algorithm quite well.  We see that for the first 500 steps, the actions are distributed approximately evenly and K is chosen randomly.  However, then it begins to exploit strongly option 5 - this is a pretty strong option, but not the best.  We also see that the agent still chooses randomly 10% of the time. </p><br><p>  This is pretty cool - we wrote just a few lines of code, and now we already have a fairly powerful algorithm that can explore the space of options and make it close to the optimal solution.  On the other hand, the algorithm did not find the best option.  Yes, we can increase the number of steps for training, but in this way we will spend even more time on a random search, further worsening the final result.  Also, randomness is sewn into this process by default - the best algorithm may never be found. </p><br><p>  Later, I will run each of the algorithms many times so that we can compare them relative to each other.  But for now, let's deal with Thompson sampling and test it in the same environment. </p><br><h2>  Thompson sampling </h2><br><p>  Thompson sampling is fundamentally different from the epsilon-greedy algorithm in three main points: <br><br></p><ol><li>  It is not greedy. </li><li>  It makes attempts in a more intricate way. </li><li>  It is Bayesian. </li></ol><br>  The main point is point 3, points 1 and 2 follow from it. <br><p>  The essence of the algorithm is as follows: <br><br></p><ol><li>  Set the initial Beta distribution between 0 and 1 for the payback of each option. </li><li>  To sample the options from this distribution, select the maximum parameter Theta. </li><li>  Choose a variant of k, which would be associated with the biggest theta. </li><li>  See how many points scored, update the distribution parameters. </li></ol><br>  You can read more about beta distribution <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B5%25D1%2582%25D0%25B0-%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">here</a> . <br>  And about its use in Python - <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html">here</a> . <br><p>  Algorithm code: <br><br></p><pre> <code class="python hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseSampler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, env)</span></span></span><span class="hljs-function">:</span></span> super().__init__(env) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choose_k</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># sample from posterior (this is the thompson sampling approach) # this leads to more exploration because machines with &gt; uncertainty can then be selected as the machine self.theta = np.random.beta(self.a, self.b) # select machine with highest posterior p of payout self.k = self.variants[np.argmax(self.theta)] #self.k = np.argmax(self.a/(self.a + self.b)) return self.k def update(self): #update dist (a, b) = (a, b) + (r, 1 - r) self.a[self.k] += self.reward self.b[self.k] += 1 - self.reward # ie only increment b when it's a swing and a miss. 1 - 0 = 1, 1 - 1 = 0 #self.thetaregret[self.i] = self.thetaregret[self.i] #self.regret_i[self.i] = np.max(self.theta) - self.theta[self.k] self.thetas[self.i] = self.theta[self.k] self.thetaregret[self.i] = np.max(self.thetas) - self.theta[self.k] self.ad_i[self.i] = self.k self.r_i[self.i] = self.reward self.i += 1</span></span></code> </pre> <br>  The formal writing of the algorithm is as follows. <br> <a href=""><img src="https://habrastorage.org/webt/5f/n6/xe/5fn6xew2i7v1jjh_10h9jqkjdzu.png"></a> <br><p>  Let's program this algorithm.  Like other agents, ThompsonSampler inherits from BaseSampler and defines its own choose_k and update methods.  Now let's launch our new agent. </p><br><pre> <code class="python hljs"> en2 = Environment(machines, payouts, n_trials) tsa = ThompsonSampler(env=en2) en2.run(agent=tsa)</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/ml/kj/1p/mlkj1pvs8xnpxtkqmehmm_3xhgo.jpeg"></a> <br><p>  As you can see, he scored more than the epsilon-greedy algorithm.  Super!  Let's look at the schedule for the selection of attempts.  It shows two interesting things.  First, the agent correctly discovered the best option (option 9) and used it to its fullest.  Secondly, the agent used other options, but in a more cunning way - after about 1000 attempts, the agent, besides the main option, mainly used the strongest options among the rest.  In other words, he chose not at random, but more competently. </p><br><p>  Why does this work?  Everything is simple - the uncertainty in the posterior distribution of the expected benefits for each option means that each option is chosen with a probability approximately proportional to its form, determined by the alpha and beta parameters.  In other words, at each attempt, Thompson sampling triggers a variant according to the posterior probability that the maximum benefit is from him.  Roughly speaking, having an uncertainty information distribution, the agent decides when to explore the environment and when to use the information.  For example, a weak version with high posterior ambiguity can pay off most for a given attempt.  But for the majority of attempts, the stronger his posterior distribution, the greater his average and the smaller his standard deviation, and therefore, the greater the chances of choosing it. </p><br><p>  Another remarkable property of the Thompson algorithm is: since it is Bayesian, we can estimate its parameters by estimating the uncertainty in the estimated payback for each option.  The graph below shows posterior distributions at 6 different points and in 20,000 attempts.  You see, as the distributions gradually begin to converge to the option with the best payback. </p><br> <a href=""><img src="https://habrastorage.org/webt/bb/ka/fb/bbkafb4nv1pajwkygxy2brtmowy.jpeg"></a> <br><p>  Now compare all 3 agents on 100 simulations.  Simulation 1 is an agent launch on 10,000 attempts. </p><br> <a href=""><img src="https://habrastorage.org/webt/j6/v1/sm/j6v1smcrwkwyhlo27ffhly13pwk.jpeg"></a> <br><p>  As can be seen from the graph, both the epsilon-greedy strategy and Thompson sampling work much better than random sampling.  You may be surprised that epsilon-greedy strategy and Thompson sampling are actually comparable in terms of their performance.  Epsilon-greedy strategy can be very effective, but it is more risky, because it can get stuck on a suboptimal version - this can be seen on the failures in the graph.  And Thompson sampling cannot, because it makes the choice in the space of options in a more complicated way. </p><br><h2>  Regret </h2><br><p>  Another way to evaluate how well the algorithm works is to evaluate regret (regret).  Roughly speaking, the smaller it is, in relation to actions already done, the better.  Below is a graph of total regret and regret for the mistake.  Once again - the less regret, the better. </p><br> <a href=""><img src="https://habrastorage.org/webt/8p/kd/o3/8pkdo3bilrde28bwsimdnbesqwg.jpeg"></a> <br><p>  In the upper graph, we see a cumulative regret, and in the bottom a regret at the attempt.  As can be seen from the graphs, the Thompson sampling converges to minimal regret much faster than the epsilon-greedy strategy.  And it converges to a lower level.  With Thomson sampling, the agent regrets less because he can better discover the best option and better try the most promising options - so Thomson sampling is particularly well suited to more advanced use cases, such as statistical models or neural network to select k. </p><br><h2>  findings </h2><br><p>  This is a fairly long technical post.  To summarize, we can use quite complex sampling methods, if we have a lot of options that we want to test in real time.  One of Thompson's very good sampling features is that it balances usage and research in a rather tricky way.  That is, we can allow it to optimize the distribution of solution options in real time.  These are cool algorithms, and they should be more useful for business than A / B tests. </p><br><p>  <b>Important!</b>  <b>Thompson sampling does not mean that you do not need to do A / B tests.</b>  <b>Usually, with its help, the best options are found, and then A / B tests are done on them.</b> </p></div><p>Source: <a href="https://habr.com/ru/post/425619/">https://habr.com/ru/post/425619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425605/index.html">Acceptance of payments from the card without jur. faces on Yandex.Money</a></li>
<li><a href="../425607/index.html">Identify fraud using Enron dataset. Part 2, the search for the optimal model</a></li>
<li><a href="../425609/index.html">Game Theory: Decision Making with Kotlin Examples</a></li>
<li><a href="../425611/index.html">Upper-level architecture frontend. Yandex lecture</a></li>
<li><a href="../425613/index.html">How I combined the Tempo plug-in data for the Jira Server and the Jira Cloud and migrated it back to the Jira Cloud</a></li>
<li><a href="../425621/index.html">A company that recycles atmospheric carbon dioxide starts methane production.</a></li>
<li><a href="../425623/index.html">Photo tour of the "Key" coworking</a></li>
<li><a href="../425625/index.html">Spent, or why localizers fucking translate games</a></li>
<li><a href="../425627/index.html">IaaS for developing services: who and why switched to virtual infrastructure</a></li>
<li><a href="../425629/index.html">How we made a board game with a remote control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>