<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Escape analysis and scalarization: let GC rest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time we decided to diversify the flow of technical interviews with real hardness and prepared a material based on the report of Ruslan cheremin C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Escape analysis and scalarization: let GC rest</h1><div class="post__text post__text-html js-mediator-article">  This time we decided to diversify the flow of technical interviews with real hardness and prepared a material based on the report of Ruslan <a href="https://habrahabr.ru/users/cheremin/" class="user_link">cheremin</a> Cheremin (Deutsche Bank) about the analysis of the work of the pair Escape Analysis and Scalar Replacement, made by him at JPoint 2016 last April. <br><br>  Video of the report in front of you: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K6c3W6vhQOA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And under the cut, we have laid out the full text decoding with separate slides. <br><a name="habracut"></a><br>  Let's start with a small lyrical digression concerning terminology. <br><br><h2>  Escape analysis and its place in optimization </h2><br>  Escape analysis is a code analysis technique that allows you to statically (at compile time) determine the reachable area for an object to reference.  Roughly speaking, there is an instruction that allocates an object, and in the course of the analysis we are trying to figure out whether another instruction can somehow get a link to the created object. <br><br>  Escape analysis is not an optimization in itself, it is just an analysis, but its results can be used for subsequent optimizations.  Usually, of course, we are interested in reachability not up to the instruction, but something like ‚Äúwhether an object created in some method is reachable is outside this method‚Äù.  And as part of the optimization task, we are most interested in situations where the answer is ‚Äúno, outside the method the object is not reachable‚Äù. <br><br>  Scalarization (Scalar Replacement).  Scalarization is the replacement of an object that exists only within a method with local variables.  We take an object (in fact it is not there yet - it will be created when the program is executed) and we say that we do not need to create it: we can put all its fields into local variables, transform the code so that it accesses these fields, and from the code to erase. <br><br>  I like the metaphor that EA / SR is such a <i>static</i> garbage collector.  Normal (dynamic) GC runs in runtime, scans the object graph and performs reachability analysis ‚Äî it finds the objects that are no longer reachable and frees the memory they use.  The ‚Äúescape analysis - scalarization‚Äù pair does the same thing during the JIT compilation.  Escape-analysis also looks at the code and says: ‚ÄúThe object created here after this instruction is no longer reachable, therefore, under certain conditions, we can not create it at all‚Äù. <br><br>  A pair of Escape Analysis and Scalar Replacement appeared in Java for quite some time, in 2009, first as an experimental option, and from 2010 it was enabled by default. <br>  Are there any results?  In the narrow circles at Deutsche Bank, a real fragment of the garbage collector loading schedule, made in 2010, runs.  The picture illustrates that sometimes for optimization you can do nothing at all, but just wait for the next Java update. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/ff4/ba3/45bff4ba3515ae31128d839bb42cff8d.jpg"><br>  <i>Source: <a href="http://dolzhenko.blogspot.ru/2011/01/lock-coarsening-biased-locking-escape.html">dolzhenko.blogspot.ru</a></i> <br><br>  Of course, this is very rare, this is an exceptional case.  In more realistic examples, according to different data in an average application, escape analysis is able to eliminate about 15% of allocations, well, and if you are very lucky, then up to 70%. <br><br>  When this tool was released in 2010, I was, frankly, very inspired by it.  I then just finished the project, where there were many pseudoscientific calculations, in particular, we actively juggled with all sorts of vectors.  And we had a lot of objects that live from the previous instructions to the next.  When I looked at it, I had a seditious thought in my head that it would be better on C here.  And after reading about this optimization, I realized that she could solve such problems.  However, Sun in the release had a very modest example of its work, so I waited for some more extensive description (in which situations it works, in which it does not; what is needed for this to work).  And I waited for quite a long time. <br><br>  Unfortunately, in 7 years I have only mentioned three cases of use, one of which was an example of the Sun itself.  The problem with all the examples was that the articles cited a piece of code with a comment: ‚Äúthis is how it works.‚Äù  And if I rearrange the instructions, does the scalarization break it?  And if instead of ArrayList I take LinkedList, will it work?  It was not clear to me.  In the end, I decided that I would not wait for someone else's research, i.e.  This work will have to do yourself. <br><br><h2>  Experiment Path </h2><br>  What did I want to get?  First of all, I wanted some kind of intuitive understanding.  Clearly, JIT compilation in general is a very complex thing, and it depends on many things.  To understand it in detail, you need to work in Oracle.  I had no such task.  I need some kind of intuitive understanding so that I look at the code and appreciate that here, almost certainly yes, and here, almost certainly not, but here it is possible (it is necessary to investigate, it can be possible to make this particular allocation scalarize ).  And for this you need a set of examples on which you can see when it works, when it does not work.  And a framework to make it easy to write these examples. <br><br><blockquote> My task was experimental: let's say I have a JDK on my computer - what information about the principles of the work of the escape analysis can I pull out without addressing questions to the authorities?  That is, it is such a natural science approach: we have an almost black box in which we ‚Äúpoke‚Äù and watch how it will work. </blockquote><br>  Before we proceed to the experiments themselves, there is still a small theoretical digression.  It is important to understand that escape analysis and scalarization are only part of a large set of optimizations that are in the server compiler.  In very general terms, the C2 optimization process is presented in the figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a4/0e8/e0c/4a40e8e0cd5fcae283409ddf97fceda3.png"><br><br>  The important thing is that even before the escape analysis, other optimization tools take over.  For example, inlining, devirtualization, folding constants and allocating frequent or non-frequent routes (in fact, there are much more of them, but here I have indicated those that most often affect the escape analysis).  And so that, according to the results of the escape analysis, some objects would be scalarized, it is necessary that all previous links of the chain, previous optimizations, should work well before the escape analysis and scalarization.  And something can break, it can not happen at any stage, but, as we will see, most often something breaks just <i>before the</i> escape analysis.  And only in some cases, it is the very escape analysis that does not cope with the task. <br><h4>  Tools </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/b87/465/e2bb87465e9e1ad415b623e0868ac3d0.png"><br><br>  A few years ago, trying to experiment with scalarization, I mainly relied on <code>GarbageCollectorMXBean.getCollectionCount()</code> .  This is a rather rough metric.  But now we have a clearer Meric - <code>ThreadMBean.getThreadAllocatedBytes(threadId)</code> , which directly on the thread ID tells how many bytes were allocated by this particular thread.  For experimentation, nothing more is needed, but I used the first, old metric at first to verify the results.  Another way to control is to disable scalarization with the corresponding key ( <code>-XX:-EliminateAllocations</code> ) and see if the observed effect is really determined by the escape analysis. <br><br>  If the test result surprises us, there are the keys PrintCompilation and PrintInlining, which allow us to get more information.  There is also a third key, LogCompilation, which gives all the same, only much more, and in the xml format - you can feed its output to the JITWatch utility, which will present you everything in a beautiful UI. <br><br>  The logical question is: why not use JMH?  JMH can really do this.  It has a profiler, <code>-prof gc</code> , which displays the same allocations, and even normalized to one iteration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/500/b76/a6f/500b76a6fad2c8df32e39259ae34b80b.png"><br><br>  And at first I tried to come in from this side.  But the fact is that JMH is primarily focused on a performance that doesn‚Äôt really interest me.  I don't care how much time it took for me to iterate;  I‚Äôm wondering if a specific optimization worked there, in other words, I need a trigger response.  And there is a lot of information that I did not immediately find how to remove.  And in the end I decided for myself that if I want to get the result within half an hour today, it‚Äôs easier to write myself.  Therefore, I have my own "bicycle".  But if someone wants to continue these experiments or make some of their own, I highly recommend taking the standard tool, as the standard is usually better. <br><br><h2>  Part 1. Basics </h2><br><h4>  Example 1.1.  Basic </h4><br>  Let's start with a simple test: similar to the example in the Sun release. <br><br><h4><img src="https://habrastorage.org/getpro/habr/post_images/9b4/d6d/d5a/9b4d6dd5abd61bdde0bdbcb8a7461992.png"></h4><br>  We have a simple Vector2D class.  We create three random vectors with randomness and perform some operation with them (we add and calculate the scalar product).  If we run this in a modern JVM, how many objects will be created here? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/992/1ff/9f09921ff786b852c9c5e20c24be0420.png"><br><br>  As a result, at the beginning something is allocated (not yet compiled), well, then everything is very clean - 0 bytes per call. <br>  This is a canonical example, so it‚Äôs not surprising that it works. <br>  To control, we add a key that turns off erasing of allocations - and we get 128 bytes per call.  These are just four Vector2D objects: three were clearly created, and another appeared in the course of addition. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/215/9e7/276/2159e72767cc232a2a7bc19c66c46215.png"><br><br><h4>  Example 1.2.  Loop accumulate </h4><br>  Add a loop to the previous example. <br>  We start a battery vector, to which we will add vectors inside the cycle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee8/e80/ca7/ee8e80ca7aa66474d7e90fd9c77c46d6.png"><br><br>  In this scenario, everything is fine too (for any <code>SIZE</code> value that I researched). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/992/892/1f9/9928921f90a0dd4341d3bd2d4755fbf6.png"><br><br><h4>  Example 1.3.  Replace in loop </h4><br>  This time, we will do the multiplication by a constant - by double, and write the result to the same variable.  In fact, this is the same battery, only here we multiply the vector by some number. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/820/f8c/29b/820f8c29bd16aa29feac7089def90390.png"><br>  Unexpectedly, but the scalarization did not work here (2080 bytes = 32 * (SIZE + 1)). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fea/1bd/a77/fea1bda77923eb459033227cd4c30159.png"><br><br>  Before finding out why, consider a couple of examples. <br><br><h4>  Example 1.4.  Control flow </h4><br>  A simpler example: we do not have a cycle, there is a conditional transition.  We randomly select a coordinate and create a Vector2D. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d62/55b/68b/d6255b68b70c78a41f2b5cebb72ff062.png"><br><br>  And here scalarization does not help: one vector is created all the time - the same 32 bytes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dba/4ca/75e/dba4ca75e07a9cb9634d85da4aa7c377.png"><br><br><h4>  Example 1.5.  Control flow </h4><br>  Let's try to change this example a little.  I will simply bring the creation of the vector into both branches: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ff/a15/659/3ffa1565937a45e78e693d2ec5981857.png"><br><br>  And here everything is perfectly scalarized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe8/314/45b/fe831445b65fab5dc8f0fe1dc2d2d03e.png"><br><br>  The picture begins to emerge - what is happening here? <br><br><h4>  "Merge points" </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/8fb/db7/e68/8fbdb7e682f8432041f35888482d3871.png"><br><br>  Imagine that we have a flow of execution in the program.  There is one branch in which we created an object v1, and a second branch in which we created an object v2.  In the third variable, v3, we write the link either to the first object, or to the second, depending on which route we followed.  At the end we return some field via the link v3.  Suppose that a scalarization has occurred and the fields v1.x, v1.y, v2.x, v2.y have become local variables, for example, v1 $ x, v1 $ y, v2 $ x, v2 $ y.  And what to do with the link v3?  Or rather: what should the appeal to the field v3.x turn into? <br><br>  This is a question.  In some simple examples, like here, or in example 1.4, the solution is intuitively clear: if this code is all we have, then you just need to return the return conditions inside, there will be two return ones, one for each branch , and each will return its value.  But the cases are more complex, and as a result, the JVM developers decided that they simply would not optimize this scenario, because  In the general case, to do this ‚Äî to figure out which object field should be used ‚Äî turned out to be too difficult (see, for example, bug JDK-6853701, or the corresponding comments in the source code of the JVM). <br><br>  Summing up this example, there will be no scalarization if: <br><ul><li>  the reference variable can point to more than one object; <br></li><li>  even if this can happen in different execution scenarios. <br></li></ul><br>  If you want to increase the chances of scalarization, then one link should point to one object.  Even if it always points to the same object, but <i>in different execution scenarios it can be different objects</i> - even this is confusing escape analysis. <br><br><h2>  Part 2. EqualsBuilder </h2><br>  This is a class from commons.lang, the idea of ‚Äã‚Äãwhich is that you can generate equals in this way by adding the fields of your class in Builder.  Honestly, I don‚Äôt use it myself, I just needed an example of some Builder, and it came to hand.  A real example is usually better than a synthetic one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/bb8/028/2f4bb802895232bfe62dc101b1d60ed1.png"><br><br>  Of course, it would be nice if this thing would be scalarized, because creating objects for each equals call is not a good idea. <br><br><h4>  Example 2.1.  Equalsbuilder </h4><br>  I wrote a simple piece of code - only two ints that were written out explicitly (but even if there were fields there, it wouldn‚Äôt change the essence). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e11/fad/019/e11fad01972bcf9836cee3aace32d134.png"><br><br>  Quite expectedly, this situation will be scalar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/926/f19/158/926f19158cf6d1358c6b97dfff39d0ce.png"><br><br><h4>  Example 2.2.  Equalsbuilder </h4><br>  Let's slightly change the example: instead of two ints we put two lines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b18/c89/085/b18c89085329ac0c29212e023d58fbf3.png"><br><br>  As a result, scalarization does not work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1d/0eb/014/a1d0eb014b9f47508b520e12898106cf.png"><br><br>  Let's not climb into the .append (...) method for now.  For a start, we have keys that at least briefly tell what happens in the compiler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/79d/1f9/cc679d1f979366dbbcc272fca4771ab0.png"><br><br>  It turns out that the append method did not zalinilitsya, respectively, the escape analysis can not understand: here is the link to the builder, which went into the .append () method like this - what happens to it, inside the method?  This is unknown (because the compiler does not look inside the .append method - JIT does not do inter-procedural optimization).  Maybe it was assigned to a global variable there.  And in such situations, escape analysis is dealt. <br><br>  What does the ‚Äúhot method too big‚Äù diagnosis mean?  It means that the method is hot, i.e.  it was called quite a few times, and the size of its bytecode is larger than a certain limit, the inlining threshold (the limit is for frequent methods).  This limit is set by the key FreqInlineSize, and by default it is 325. And in the diagnostics we see 327 - that is, we missed only 2 bytes. <br>  Here is the contents of the method - it is easy to believe that there are 327 bytes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f62/f83/509/f62f8350993576b4e1be7b1179eb862f.png"><br><br>  How can we test our hypothesis?  We can add the key FreqInlineSize, and increase the inline threshold, say, to 328: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/241/e65/c6d241e653ff1aaaa26121cf96267a81.png"><br><br>  In the compilation profile, we see that .append () is now inline, and everything is well scalarized: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae1/8e3/50c/ae18e350cec83cf35cfaff1aabbde81f.png"><br><br>  I will clarify: when I change the JVM flags here, and the JIT compilation options, I do this not to correct the situation, but to test the hypothesis.  I would not recommend playing with JIT compilation options, since they are selected by specially trained people.  Of course, you can try, but the effect is difficult to predict - each such parameter affects not one specific method in which you want to scalar something, but the entire program as a whole. <br><br><h4>  Conclusion 2. </h4><br><ul><li>  Inline is the best friend of adaptive runtimes. <br></li><li>  shortness helps him a lot. <br></li></ul><br>  Write short methods.  In particular, in the example with .append () there is a large sheet that works with arrays - trying to make a comparison of arrays.  If you simply put it into a separate method, then everything is perfectly inline and scalarized (I tried).  This is such a black (although it may be white) move for this heuristic of inlining: the method of 328 bytes is not inline, but it‚Äôs broken into two methods of 200 bytes ‚Äî it is perfectly inline because each method separately crawls under the threshold. <br><br><h2>  Part 3. Multi-values ‚Äã‚Äãreturn </h2><br>  Consider returning a tuple from a tuple method ‚Äî several values ‚Äã‚Äãat a time. <br>  Take some simple object, such as Pair, and a completely trivial example: we return a couple of rows randomly selected from some pre-filled pool.  To prevent the compiler from throwing out this code at all, I will bring in some side effect: I will count something with these type lines, and return the result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cd/a67/f4a/9cda67f4aaf69b2170ce8c66a1fc12b5.png"><br><br>  This script is scalarized.  And this is quite a working example, you can use it: if the method is hot and inline, such multi-value return will be perfectly scalarized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/146/172/cb8/146172cb85019893ad84c775e7e9df89.png"><br><br><h4>  Example 3.1.  value or null </h4><br>  Let's slightly change the example: under some circumstances, return null. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbb/763/4e5/fbb7634e54f7d6f4d5a091a512b00d75.png"><br><br>  As you can see, the allocation will remain (the average number of bytes per call is not integer, because sometimes null is returned, which costs nothing). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05d/32b/4bc/05d32b4bc6dc1371bd587bd121593f54.png"><br><br><h4>  Example 3.2.  Mixed types? </h4><br>  A more complicated example: we have an interface-pair and 2 implementations of this interface.  Depending on the artificial condition, we return either that implementation or another. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/09a/f2d/32b/09af2d32b9beff37427022b49d01662e.png"><br><br>  Here, too, is the allocation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2a/8fc/d0c/c2a8fcd0c5bc00bce46e4c8c573bae56.png"><br><br>  Honestly, initially I was sure that it was precisely in different types, and I believed in it for a long time, until I made the following example with the same types, which also does not scalar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/68b/c01/61c68bc0173fa1817bfe903ada992ace.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/337/968/a18/337968a189733f7e27d3833379528738.png"><br><br>  What's going on here?  Well, if we try using handles to inline all the methods, we will see the same scenario with merge points (= the link can come in two ways) as in our very first experiment: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/886/5da/4a3/8865da4a3f220741161445609ca97bfb.png"><br><br><h4>  Conclusion 3: </h4><br>  Keep it simple: fewer branches - less likely to confuse escape analysis <br><br><h2>  Example 4. Iterators </h2><br>  Another frequent pattern and very often an intermediate object, the creation of which I would like to avoid. <br><br>  Here is a very simple scenario with iteration through the collection.  We create a collection once, we do not re-create it for each iteration, but we re-create an iterator: at each method start we run through the collection as an iterator, we consider some side effect (just so that the compiler does not throw out this piece). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b68/fd2/7e8/b68fd27e8a10043f36001019d5887b6f.png"><br>  Consider this scenario for different collections.  Suppose first for ArrayList <br><br><h4>  Example 4.1.  ArrayList.iterator </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad9/fe6/ec0/ad9fe6ec0ea4121f3024e95fbf705fd4.png"><br><br>  For ArrayList, the iterator really scalars (the size of SIZE here is conditional: as a rule, it works stably for a wide range of SIZE).  For LinkedList this also works.  I will not go through all the options for a long time - here is a summary table of those collections that I tried: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/acd/7b2/61cacd7b26cb20380f06b082791cc523.png"><br><br>  In Java 8, all these iterators (at least in simple scripts) are scalarized. <br>  But in the freshest update Java 7 all smarter.  Let's take a closer look at it (everyone knows that 1.7 is already the end of life, 1.7.0_80 is the last update that is). <br><br>  For LinkedList with size 2, everything is fine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/787/a0c/a20/787a0ca2045dd29544d5646b699fe9cd.png"><br><br>  But for LinkedList with a size of 65 - no. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/942/a91/e6a942a9178c1d531afa6d1efbbee4c6.png"><br><br>  What's happening? <br>  We take the magic keys, and for size 2 we get such a piece of inline log: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/545/ae0/ae0/545ae0ae0291c8073a0a638be68eebc8.png"><br><br>  And for size 65: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/689/6cb/4606896cbdd85c9a23b4f9cc9946dfc9.png"><br><br>  Closer to the beginning of the same log you can find another such additional fragment of the picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57c/ccf/0d6/57cccf0d6e7ee3844d672f257829357d.png"><br><br>  The following happens: at the very beginning the method we are profiling went to compile - JIT put it in a queue.  JIT works asynchronously, i.e.  it has a queue, compilation tasks are dropped there, and it in a separate stream (or even several streams) with some speed scoops them out of the queue, and compiles.  That is, between the moment when he was assigned the task, and the moment when the new code will be optimized, some time passes. <br><br>  And now our <code>iterate()</code> method went to compile for the first time, during which it was discovered that the <code>LinkedList.listIterator()</code> method inside it was still too little to execute.  I didn‚Äôt yet work to make it zainlaynit ( <code>MinInliningThreshold</code> = 250 calls).  When, some time later, the call to <code>iterate()</code> went to <i>recompilation</i> , it turned out that the compiled (machine) code <code>LinkedList.listIterator()</code> too large. <br><br>  Yes, but what exactly do diagnostics mean: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e4/fd4/343/0e4fd4343ce6b323c7c52f5095ded055.png"><br><br>  They mean that, estimating the size of <i>already compiled</i> methods, we look at their machine code, and not byte code (since this is a more adequate metric).  And these two heuristics - in terms of bytecode and machine code - are not necessarily consistent.  A method of just five bytecodes can invoke several other methods that will be pasted in and increase the size of its machine code above thresholds.  With this mismatch, nothing can be done cardinally, just adjusting more or less the thresholds of different heuristics, and hopefully, on average, everything will be more or less good. <br><br>  Thresholds - in particular, InlineSmallCode - differ in different versions.  InlineKmallCode is 8 times larger in an 8-key, so this script works successfully in Java 8: the methods inline and the iterator scalars - and in 7-ke it does not. <br><br>  In this example, it is important that it is unstable.  You must be (un) lucky so that the compilation tasks go in that order.  If at the time of the second recompilation, the <code>LinkedList.listIterator()</code> method would not have been compiled independently, it would have no machine code, and it would pass by the bytecode size criterion and successfully zainlinilitsya.  That is why the result depends on the size of the list ‚Äî how quickly different methods will be sent for compilation depends on the number of iterations inside the loop. <br><br>  We can test this hypothesis of ours: play around with thresholds.  Indeed, when fitted, the scalarization starts to work: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d95/7bb/27d/d957bb27d4c6cf9a34a25bfac672000f.png"><br><br><h4>  Conclusion 4: </h4><br><ul><li>  JVM first freshness is better than no first freshness; <br></li><li>  -XX: + PrintInlining - a very good diagnosis, one of the main ones, which allows you to understand what is happening with scalarization; <br></li><li>  Test on real data - I mean, you don‚Äôt need to test on size 2 if you expect 150. Test it on 150 and you can see the differences; <br></li><li>  ArrayList again furnished LinkedList! <br></li></ul><br><blockquote>  Dynamic runtime is a roulette.  JIT compilation is non-deterministic, inevitable.  In the newer versions (8-ke), the parameters of the heuristics are slightly better coordinated with each other, but this does not cancel non-determinism, it is just harder to catch. </blockquote><br><br><h4>  Example 4.4.  Arrays.asList () </h4><br>  There is a separate interesting collection option - a wrapper around an array, Arrays.asList ().  I would like this wrapper to be worth nothing so that JIT would scalar it. <br><br>  I will start here with a rather strange scenario - I will make a list from an array, and then go through the list, as if by an array, with an index: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/987/ff8/f25/987ff8f25ba690ddc2888f3c226a8ad6.png"><br><br>  Everything here works, the creation of the wrapper is scalarized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8f6/01f/6a78f601fd26ba68ac7f0e71d2c11fdd.png"><br><br>  And now let's go back to the iterator - there is no special sense to wrap an array in a list, then to go through the list, like in an array: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/da3/899/1d3da3899daca40688c0b7d0f6596b60.png"><br><br>  Alas, even in the latest version of java, the location remains. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/bd6/531/d9dbd653192a52e1670b8e0180332e7b.png"><br><br>  At the same time, we don‚Äôt see anything special in PrintInlining. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed4/ba1/de5/ed4ba1de530b7da4798e028e1b143373.png"><br><br>  But if you look more closely, you will notice that the iterator in Arrays $ ArrayList is not your own - its implementation is inherited entirely from AbstractList: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/637/e42/086/637e42086949f3b577f6f33f0a6a1c84.png"><br><br>  And AbstractList $ Itr is an inner class, a non-static inner class.  And the fact that it is non-static - for some reason, prevents scalarization.  If you rewrite the iterator class (i.e., copy the whole Arrays $ ArrayList class to yourself and modify it), make the iterator untied, an array is passed to the iterator, and the iterator no longer contains a reference to the list object ‚Äî then in this scenario it will successfully scalar as allocate the iterator and the allocation of the Arrays $ ArrayList wrapper itself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/402/cb4/1a9/402cb41a9c4d5e1c6f62b566759e6d07.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b00/a18/2f1/b00a182f1b674d2f1022f699d9b8b79f.png"><br><br>  This is a rather mysterious case, and it seems that this is a <a href="https://bugs.openjdk.java.net/browse/JDK-8155769">bug in the JIT</a> , but to this day the moral is this: nested objects confuse scalarization. <br><br><h4>  Example 4.4.  Collections. * </h4><br>  We still have some of these singleton collections, and all of them, and their iterators, are successfully scalarized both in the current and in the previous java versions, except for the above-mentioned Arrays.asList. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/90f/d63/1c390fd63483d18b2a7a8f4c7b6eeaa6.png"><br><br><h4>  Conclusion 4.4. </h4><br>  Nested objects do not scalar very well. <br><ul><li>  iteration over wrappers from Collections. * scalars <br></li><li>  ... In addition to Arrays.asList (); <br></li><li>  nested objects are not scalarized (including inner classes); <br></li><li>  -XX: + PrintInlining continues to help in trouble. <br></li></ul><br><h2>  Example 5. Constant size arrays </h2><br>  I‚Äôll clarify right away that you don‚Äôt even hope for the scalarization of arrays of variable size (that is, a size that JIT cannot predict).  We work with arrays of constant length. <br><br><h4>  Example 5.1.  Variable index </h4><br>  Consider this example: we take an array, write something there in cells, then read something from there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31b/e25/1e1/31be251e152acbf0cc79ab630e479ff7.png"><br><br>  For size 1, everything is fine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b16/edb/1ec/b16edb1ec3a7419f2866100c8a9bb2d4.png"><br><br>  And for size 2 - nothing happens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/500/184/504/500184504508b49e8a48607ebd939573.png"><br><br><h4>  Example 5.2.  Constant index </h4><br>  Let's try a slightly different access: take the same size 2 and just simply unroll the loop with the handles - take and turn on the explicit index: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/009/1f4/a24/0091f4a247427d8db334c10f56739e3f.png"><br><br>  In this case, oddly enough, the scalarization will work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a8/63a/df9/9a863adf92be77cc914604292b139959.png"><br><br>  I will not argue long - below is the summary table.  This case with a manually deployed cycle will be scalar up to size 64. If there is any variable index, sizes 1 and 2 will be more scalarized, then no. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/3a7/4cb/c093a74cb2a2d816612a63f6bb486eb1.png"><br><br>  As someone wrote to me in a blog, in ‚ÄúJVM for everything there is a key‚Äù.  This upper threshold (-XX: EliminateAllocationArraySizeLimit = 64) can also be set, although it seems to me that this does not make sense.  In the limiting case there will be 64 additional local variables, which is too much. <br><br><h4>  Example 5.3.  Primitive arrays </h4><br>  Exactly the same code, only with an array of primitive types - int-th, short-th ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/517/8ec/f14/5178ecf143e95a46913946c3a44a48ed.png"><br><br>  Everything works exactly in the same cases as for objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c0/373/4fa/2c03734face8d6f0124cb386050520db.png"><br><br>  Why is it impossible to scalarize an array that we loop through?  Because it is not clear which index is hiding behind i.  If you have an array [2] type in the code, then JIT can turn this into a local variable of type array $ 2.  And what does array [i] turn into?  You need to know what exactly i is.  In some special cases, in the case of short arrays, JIT can ‚Äúguess‚Äù this, in general - no. <br><br><h4>  Example 5.4.  Preconditions </h4><br>  In the guava library, there is such a wonderful method, like <code>checkArguments(expression, errorMessageTemplate, args...)</code> , which checks expression, and throws an exception with a formatted message if expression == false.     ‚Äî vararg,    ,     .        ,    <code>checkArguments</code>   expressions == false,   . <br>    ,  expression  .  :     vararg     ,    expression  false? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/989/87a/166/98987a166a0fb7e10efbd89eaef95f27.png"><br><br>      ‚Äî 10 <sup>-7</sup> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b6/cd9/916/3b6cd99165731c8e4dfab62136b3e7e8.png"><br><br>     . <br><br>     10 <sup>-9</sup> ,  , ,    ,   -  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f9/9a5/70f/9f99a570f6f159dc1acda7c65db6a444.png"><br><br>     ,  -   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0b/e21/5d9/f0be215d92f4ba6d5f407a3556dc1b0f.png"><br> ‚Ä¶   . <br><br> ,    ‚Äî  checkArguments,   vararg ‚Äî  ,    ,      ,  expression    false.    checkArguments,  expression  false,   - ,     -    .      , ,      ,  false   ,      vararg       ,    . <br><br><h2>  Total </h2><br><ul><li>    ,    (     ); <br></li><li>   ,     (..       ,   ,   :   -   ,   );   <br></li><li>   JVM   . <br></li></ul><br>    :        (   JVM).     ,       ,    .         .          - ,    . <br><br>  ‚Äî   : <br><br><ul><li>   JVM; <br></li><li>   ( ); <br></li><li>    (   ,        1; 2-3 ‚Äî  , ,  ,  ); <br></li><li>      ; <br></li><li>   null ‚Äî     ; <br></li><li>     ‚Äî , ,  ,     ; <br></li><li>    . <br></li></ul><br><hr><br>          ‚Äì     <a href="https://jpoint.ru/">JPoint 2017</a> (7-8 )    <a href="https://2017.jbreak.ru/">JBreak 2017</a> (4 )  .      ,    ‚Äì    ,  . </div><p>Source: <a href="https://habr.com/ru/post/322348/">https://habr.com/ru/post/322348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322334/index.html">Captain Slopek reports: ReactOS 0.4.4 has been released</a></li>
<li><a href="../322336/index.html">Hi, SaaS | Russian SaaS 2016 - results</a></li>
<li><a href="../322340/index.html">Determine the best place to live in the United States with your own application on IBM Bluemix</a></li>
<li><a href="../322344/index.html">Salyut-EL24D1: debug board on the Russian processor 1892BM14Ya for harsh operating conditions</a></li>
<li><a href="../322346/index.html">Heuristic network - analogue of the recurrent neural network for chat bot program</a></li>
<li><a href="../322350/index.html">Personal experience: TeamCity and character server integration</a></li>
<li><a href="../322352/index.html">As I made the fastest resize of images. Part 1, general optimizations</a></li>
<li><a href="../322354/index.html">Manage application state with Vuex</a></li>
<li><a href="../322360/index.html">Interesting features of Python, which you could not guess</a></li>
<li><a href="../322362/index.html">Red Hat acquires 3scale, which develops API management systems, and intends to open source code of products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>