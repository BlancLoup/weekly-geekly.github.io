<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We parse ACID in NoSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivation 
 It is not a secret for anyone that if there is a formulated heuristic rule called CAP. Theorem, as opposed to the usual RDBMS system, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We parse ACID in NoSQL</h1><div class="post__text post__text-html js-mediator-article"><h4>  Motivation </h4><br>  It is not a secret for anyone that if there is a formulated heuristic rule called <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">CAP. Theorem,</a> as opposed to the usual <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25A1%25D0%25A3%25D0%2591%25D0%2594">RDBMS system, the</a> class of NoSQL solutions cannot provide full support for <a href="http://ru.wikipedia.org/wiki/ACID">ACID</a> .  It must be said that for a number of tasks there is no need for this and the support of one of the elements leads to a compromise in resolving the rest, as a result - a large variety of existing <a href="http://ru.wikipedia.org/wiki/NoSQL">solutions</a> .  In this article, I would like to consider various architectural approaches to solving problems of partially meeting the requirements for a transaction system. <br><a name="habracut"></a><br><h4>  "A" Atomicity </h4><br>  <i>Atomicity guarantees that no transaction will be partially fixed in the system.</i>  <i>All its suboperations will be executed or none</i> <br><br>  NoSQL systems usually choose high performance not in favor of transactional semantics, since its compliance adds additional processing costs.  Many systems still provide a guarantee at the key or line level (Google BigTable) or provide api for atomic operations (Amazon DynamoDB), in which only one stream can modify the record if you, for example, want to have a user visit counter distributed across the cluster .  Most systems adhere to non-blocking read-modify-write cycles.  The cycle consists of three stages - read the value, modify, write.  As you can see, in a multithreaded environment there are many things that can go wrong, for example, that if someone changes the record between the read and write phases.  The main mechanism for resolving such conflicts is to use the <a href="http://en.wikipedia.org/wiki/Compare-and-swap">Compare and Swap</a> algorithm ‚Äî if someone changed the record during the cycle ‚Äî we need to understand that the record has changed and repeat the cycle until our value is established, this algorithm looks preferable to completely a write-blocking mechanism.  The number of such cycles can be very large, so we need some timeout for the operation, after which the operation will be rejected. <br><br><h4>  "C" consistency </h4><br>  <i>A transaction reaching its normal completion and, thereby, fixing its results, preserves the consistency of the database.</i>  <i>Considering the specifics of NoSQL to the distribution of information across servers - this means whether all replicas containing a copy of data always contain the same version of data</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Due to the specifics, modern NoSQL is required to choose high availability and the ability to scale the cluster horizontally - it turns out that the system cannot ensure complete data consistency and makes some assumptions in the definition of the concept of consistency.  There are two approaches: <br><br><h5>  Strict consistency </h5><br>  Such systems ensure that replicas are always able to come to an agreement on one version of the data returned to the user.  Some replicas will not contain this value, but when the system processes the request for a value by key, the machine will always be able to decide which value to return ‚Äî it will simply not always be the last.  How it works - for example, we have <i>N</i> replicas of the same key.  When a request comes to update the key value, the system will not give the result to the user until <i>W</i> replicas reply that they received the update.  When a user requests a value, the system returns a response to the user when at least <i>R</i> replicas return the same value.  Then we consider the system to be strictly consistent if the condition <i>R + W&gt; N</i> is met.  The choice of the values ‚Äã‚Äãof <i>R</i> and <i>W</i> affects how many machines have to answer before the answer is returned to the user, usually the condition <i>R + W = N + 1</i> is chosen - the minimum necessary condition for ensuring strict consistency. <br><br><h5>  Possible consistency </h5><br>  Some systems ( <i>Voldemort, Cassandra, Riak</i> ) allow you to select <i>R</i> and <i>W</i> for which <i>R + W &lt;N</i> .  When a user requests information, there may be times when the system cannot resolve the conflict between versions of key values.  To resolve conflicts, a type of versioning called vector clock is used.  This is the vector associated with each key that contains change counters for each replica.  Let servers <i>A</i> , <i>B,</i> and <i>C</i> be replicas of the same key, a vector will contain three values <i>(N_A, N_B, N_C)</i> , initially initialized to <i>(0,0,0)</i> .  Each time a replica changes the key value, it increments its counter value in the vector.  If B changes the value of the key that previously had version <i>(39, 1, 5)</i> - the vector will change its value to <i>(39, 2, 5)</i> .  When another replica, say <i>C</i> , gets an update from replica <i>B,</i> it compares the value of the vector with its own.  As long as all of their vector counters are smaller than those that came from <i>B</i> , the value that has come has a stable version and you can overwrite your own copy.  If there are vectors on <i>B</i> and <i>C</i> in which some counters are larger and some less, for example, <i>(39, 2, 5)</i> and <i>(39, 1, 6)</i> , then the system identifies the conflict. <br><br>  Resolving this conflict varies across systems; Voldemort returns multiple copies of the value, resolving the conflict at the mercy of the user.  Two versions of the user basket on the site can be merged without losing information, while merging two versions of one edited document requires user intervention.  Cassandra, which stores the timestamp of each record, returns the latest if a conflict is detected, this approach does not allow merging the two versions without losing information, but it simplifies the client part. <br><br><h4>  "I" Isolation </h4><br>  <i>During the execution of a transaction, parallel transactions should not affect its result.</i>  <i>The concept <a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25B8_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B9">of transaction isolation levels</a> also matters here.</i> <br><br>  Cassandra, starting with version 1.1 ensures that if you are doing an update: <br><br> <code>UPDATE Users <br> SET login='login' AND password='password' <br> WHERE key='key' <br></code> <br><br>  then no competitive read will see a partial update of the data (login has changed, but the password has not), and this is true only at the level of rows that are within a single <i><a href="http://en.wikipedia.org/wiki/Column_family">column family</a></i> and having a common key.  This may correspond to the isolation level of the <i>read uncommitted</i> transaction, at which <i>lost update</i> conflicts are resolved.  But <i>Cassandra</i> does not provide a rollback mechanism at the cluster level, for example, it is possible that the login and password will be saved on some number of nodes, but not enough <i>W</i> to give the user the correct result, while the user is forced to resolve this conflict .  The isolation mechanism is that an invisible, client-isolated version is created for each record that is changed, which subsequently automatically replaces the old version using the Compare and Swap mechanisms described above. <br><br><h4>  "D" Reliability </h4><br>  <i>Regardless of the problems at the lower levels (for example, system de-energization or equipment failures), changes made by a successfully completed transaction should remain saved after the system returns to work.</i>  <i>In other words, if the user has received confirmation from the system that the transaction has been completed, he can be sure that the changes he has made will not be undone due to some kind of failure.</i> <br><br>  The most predictable failure scenario can be a power outage or server restart.  Fully reliable system in this case should not return the answer to the user until he writes all the changes from memory to the hard disk.  Writing to disk is too long and many NoSQL systems compromise for performance. <br><br><h5>  Ensuring reliability in a single server </h5><br>  A standard disk can handle 70-150 operations per second, which amounts to a bandwidth of up to 150 Mb / s, ssd - 700 Mb / s, DDR - 6000 - 17000 Mb / s.  Therefore, ensuring reliability within a single server while ensuring high performance is a reduction in the number of recordings with random access and an increase in sequential recording.  Ideally, the system should minimize the number of records between calls to <a href="http://linux.die.net/man/2/fsync"><i>fsync</i></a> (data synchronization in memory and on disk).  To do this, apply several techniques. <br><br><h6>  Fsync frequency control </h6><br>  Redis offers several ways to configure when to call <i>fsync</i> .  You can configure it to be called after each record change, which is the slowest and safest choice.  To improve performance, you can cause a flush to disk every <i>N</i> seconds, in the worst case, you will lose data in <i>N</i> last seconds, which may be quite acceptable for some users.  If reliability is not critical at all, then you can disable fsync and rely on the fact that the system itself at some point synchronizes the memory with the disk. <br><br><h6>  Increase sequential write through logging </h6><br>  For efficient data retrieval, NoSQL systems often use additional structures, for example, B-trees for building indexes, working with it causes multiple random disk accesses.  To reduce this, some systems ( <i>Cassandra, HBase, Riak</i> ) add update operations to a sequential-writeable file called <i>redo log</i> .  While some structures are rarely written to disk, the log is often written.  After the fall, the missing entries can be restored using the log. <br><br><h6>  Increase bandwidth by grouping records </h6><br>  <i>Cassandra</i> groups several simultaneous changes during a short window, which can be combined into one <i>fsync</i> .  This approach, called <i>group commit</i> , increases the response time for a single user, because  he has to wait for several other transactions to commit his own.  The advantage here is obtained by increasing the overall throughput, since  multiple random entries can be combined. <br><br><h5>  Ensuring reliability within a server cluster </h5><br>  Due to the possibility of unforeseen failures of disks and servers, it is necessary to distribute information across several machines. <br>  <i>Redis</i> is a classic <i>master-slave</i> architecture for data replication.  All operations associated with the master go down to the replicas in the form of a log. <br>  <i>MongoDB</i> is a structure in which a given number of servers stores each document, and it is possible to specify the number of servers <i>W &lt;N</i> described above, which is minimally necessary for recording and returning control to the user. <br>  <i>HBase</i> achieves multi-server reliability through the use of <i>HDFS</i> distributed file system. <br><br>  In general, you can notice a certain tendency of modern NoSQL-tools in the direction of providing greater data consistency.  But still, while SQL and NoSQL tools can exist and develop in parallel and solve completely different tasks. </div><p>Source: <a href="https://habr.com/ru/post/228327/">https://habr.com/ru/post/228327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228315/index.html">How I overcame DDoS in 15 minutes</a></li>
<li><a href="../228317/index.html">How to patch 11 different firmware and do not go crazy with diversity</a></li>
<li><a href="../228321/index.html">Samsung has introduced a high-capacity, productive SSD with a vertical structure of memory cells.</a></li>
<li><a href="../228323/index.html">Sony SmartWatch 2 Review</a></li>
<li><a href="../228325/index.html">FnDelay awaiting function</a></li>
<li><a href="../228331/index.html">Building your own communication network over I2P</a></li>
<li><a href="../228335/index.html">Installing the Eucalyptus 4.0 cloud system</a></li>
<li><a href="../228337/index.html">Jekyll 2 is coming on Github!</a></li>
<li><a href="../228339/index.html">Configuring ModSecurity</a></li>
<li><a href="../228341/index.html">Substitution of the parent page on the example of ask.fm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>