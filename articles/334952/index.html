<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Server side rendering on Vue.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More recently, Vue.js has gained full support for server rendering. There is quite a bit of information on the Internet on how to prepare it correctly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Server side rendering on Vue.js</h1><div class="post__text post__text-html js-mediator-article"><p>  More recently, Vue.js has gained full support for server rendering.  There is quite a bit of information on the Internet on how to prepare it correctly, so I decided to describe in detail the process of creating the necessary environment for developing an application with SSR on Vue.js. </p><br><p>  Everything that will be discussed is implemented in the <a href="https://github.com/mrTimofey/vue-ssr-starter">repository on github</a> .  I will often refer to its sources and, in fact, try to explain what is happening and why it is necessary :) </p><br><p>  The article will describe approaches <em>that</em> are quite common for SSR ( <em>if you just need something ready for use, then you can look in the direction of <a href="https://nuxtjs.org/">Nuxt.js</a></em> ), so it‚Äôs quite likely that what‚Äôs said below can be partially or fully applied to other frameworks / libraries like Angular and React. </p><a name="habracut"></a><br><p>  <em>I did not set a goal to make a free retelling of <a href="https://ssr.vuejs.org/">official documentation</a> , therefore for a full understanding of the process it is better to get acquainted at least superficially.</em> </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  The main idea of ‚Äã‚Äãany application with SSR is that it should generate the same HTML markup when running on the server and on the client. </p><br><p>  Data that is substituted in HTML must be pulled out by an API located on the same or on a different server / domain.  Setting up and developing an API server is beyond the scope of this article, but you can take <a href="https://github.com/axios/axios">axios</a> or any other isomorphic http client as a client for it. </p><br><p>  You also need to remember that there is no DOM on the server, so all manipulations with document, window and other navigators should either not be used at all, or should be run only on the client, that is, in hooks beforeMount, mounted, etc. </p><br><p>  <em>Below there will be a lot of letters where I try to clarify what happens in the code.</em>  <em>Therefore, if the letters seem difficult to read to you, I recommend looking directly at the code :) Links to the relevant parts of the repository will be given in each section.</em> </p><br><h2 id="konfiguraciya-webpack">  Webpack configuration </h2><br><p>  <a href="https://github.com/mrTimofey/vue-ssr-starter/tree/master/build/webpack">Code</a> </p><br><p>  The assembly is divided into 3 main configurations of webpack - general, assembly for the server and assembly for the client.  After the build, we should receive 2 independent bundles with a set of files for the client and only one js file for the server. </p><br><p>  For each bundle, obviously, you will need to create a separate entry, but more on that later. </p><br><p>  <strong>The general assembly (base.js)</strong> includes loaders for all statics, templates, JavaScript sources, and vue components.  Styles can also be included here theoretically, but for obvious reasons they are not needed on the server, so they will be registered only for the client. </p><br><p>  <strong>The client build (client.js)</strong> adds to the total what we need in the browser.  In the rules are written loaders for css, stylus, sass, postcss, etc. <br>  You can also add output to split the bundle into several files, extract css, uglify, etc.  In general, everything is as usual :) <br>  Here we also add the generation of a common HTML template using the html-webpack-plugin.  On it I will separately stop a little lower. </p><br><p> <strong>The</strong> build <strong>for SSR (server.js)</strong> should create a single js-file for running on the server.  We do not care about the file size, since no one will download it via http, so everything that is usually written in the configs for optimization does not make sense here. <br>  You must also specify <code>target: node</code> , null-loader for styles and externals.  All packages from package.json are specified in externals so that the webpack does not include installed packages in the assembly, since they will be connected from the node_modules on the server. </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'node'</span></span>, <span class="hljs-attr"><span class="hljs-attr">externals</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../package.json'</span></span>).dependencies) }</code> </pre> <br><h2 id="obschiy-shablon-prilozheniya">  General Application Template </h2><br><p>  <a href="">Code</a> </p><br><p>  A generic template is simply generic HTML markup into which rendered Vue application code will be inserted.  It is important to understand here that a server without specially trained libraries knows nothing about the DOM.  Therefore, in the template you need to enter a certain string, which will be a simple replacement for the substring replaced by the markup of the application.  In the example, this is just <code>&lt;!--APP--&gt;</code> (or <code>//APP</code> in pug), but it can be any other. </p><br><p>  With the scripts, styles and tags in the head a little easier - we will insert them using the same replacement in front of <code>&lt;/body&gt;</code> / <code>&lt;/head&gt;</code> . </p><br><h2 id="sborka-i-server">  Build and server </h2><br><p>  SSR requires a server (express in the example) on Node.js, which will also build the project on the fly during development.  There is a lot of code, so it will be easier to see examples of <a href="">server launch points</a> and <a href="">server configurations for development</a> . </p><br><p>  A few subtleties: </p><br><ul><li>  You need to prepare a general template so that the vue-meta plugin on the client understands that the markup is ready and does not duplicate the meta tags.  To do this, simply insert the special attribute <code>data-vue-meta-server-rendered</code> with no value in the <code>&lt;html&gt;</code> .  The attribute name is <a href="https://github.com/declandewet/vue-meta">customizable</a> , so in your project it may be different (for example, I decided to replace it with <code>data-meta-ssr</code> , since this is shorter). </li><li>  Also in the template you need to substitute everything you need from the vue-meta plugin: attributes for html and body, meta tags, link, noscript, etc ... In the simplest version, it goes <a href="https://github.com/declandewet/vue-meta">something like this</a> : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... const { title, htmlAttrs, bodyAttrs, link, style, script, noscript, meta } = context.meta.inject() res.write(` &lt;!doctype html&gt; &lt;html data-vue-meta-server-rendered ${htmlAttrs.text()}&gt; &lt;head&gt; ${meta.text()} ${title.text()} ${link.text()} ${style.text()} ${script.text()} ${noscript.text()} &lt;/head&gt; &lt;body ${bodyAttrs.text()}&gt; ... `) // ...</span></span></code> </pre> <br><ul><li>  For correct processing of the server bundle (which was previously compiled using a webpack), you need to use vue-server-renderer, which needs to specify the bundle file and its encoding.  <a href="https://ssr.vuejs.org/en/api.html">More information</a> about the parameters can be found in the official documentation.  There is at least one interesting parameter runInNewContext that will make it possible to optimize rendering quite well, but if certain rules are observed (as discussed below, in the section on entry points). </li><li>  Since all the data from the API is loaded during rendering, there is no need to reload it on the client.  But the client, obviously, cannot simply take them out of the markup, so it is necessary to transfer data to it <em>along</em> with the markup.  This task is solved as simply as possible: a script is added to the markup, where all the necessary data is written to variables.  The data itself is processed by <code>JSON.stringify</code> or, even better, using <a href="https://github.com/yahoo/serialize-javascript">serialize-javascript</a> . </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serialize = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'serialize-javascript'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ... res.write(`&lt;script&gt; window.__INITIAL_VUEX_STATE__=${serialize(context.initialVuexState)} &lt;/script&gt;`); res.write(`&lt;script&gt; window.__INITIAL_COMP_STATE__=${serialize(context.initialComponentStates)} &lt;/script&gt;`);</span></span></code> </pre> <br><h2 id="rezhim-razrabotki">  Development mode </h2><br><p>  In the case of starting the server in development mode, the server itself will work about the same.  Only 2 things differ - in another way, errors that occurred during rendering are handled, and the renderer and the layout of the general template are replaced with new ones when the application code changes. </p><br><p>  In addition to the server itself, you need to run <code>webpack(clientConfig).watch</code> to generate the assembly on the fly as the source changes.  Before this, the webpack is initialized with all the plug-ins of the HotModuleReplacementPlugin type necessary for development. </p><br><p>  You also need to inform the customer about new builds of the bundle.  This will require webpack-dev-middleware and webpack-hot-middleware.  They are responsible for delivering the changed code to the client when new assemblies appear (that is, each time the source code of the application changes). </p><br><p>  Separately, <code>webpack(serverConfig).watch</code> and the server bundle is replaced with a new one when it changes.  In my case, we report that it has changed using a simple callback (line 50 in <code>build/setup-dev-server.js</code> , line 73 in <code>index.js</code> ). </p><br><h2 id="tochki-vhoda-dlya-prilozheniya">  Application Entry Points </h2><br><p>  <a href="https://github.com/mrTimofey/vue-ssr-starter/tree/master/src/entry">Code</a> </p><br><p>  As I mentioned above, you need to create 2 separate entry points (entry in the webpack) of the application for the SSR and for the client.  Actually, here is the same as in the webpack configs - 3 files with common, server and client code. </p><br><p>  <strong>The common code (app.js)</strong> includes a common initialization of the application, that is, it connects Vue-plugins, creates a vuex store, a router and a new root component.  Global components, filters and directives are also registered here. </p><br><p>  Here, the root component needs to mix the vue file with the template and logic of the application itself, so that the main component of the application and the root component become one. <br>  It is important that for vue-server-renderer there is a runInNewContext option, which can be turned off, while obtaining a good performance boost.  But to use it, you need to initialize the application each time, so in app.js I return the function that performs the initialization, not the finished object of the Vue component.  The code that is executed directly in this file will be executed only once when the server is started, which must be remembered.  Here you can register common moments that are not dependent on the data obtained in runtime - register components, filters, directives, retrieve environment variables, etc.  etc. </p><br><p>  <strong>Client entry point (client.js)</strong> .  Here, an application is created using the function from app.js, then it loads and everything necessary for correct work in the browser is executed. <br>  It also replaces the data object for the component that should be shown on this page and the status of the vuex store. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__INITIAL_VUEX_STATE__) { <span class="hljs-comment"><span class="hljs-comment">//   state    app.$store.replaceState(window.__INITIAL_VUEX_STATE__); delete window.__INITIAL_VUEX_STATE__; } if (window.__INITIAL_COMP_STATE__) { app.$router.onReady(() =&gt; { //   ,      // (    ,   )... const comps = app.$router.getMatchedComponents() // ...  ,       .filter(comp =&gt; typeof comp.prefetch === 'function'); for (let i in comps) if (window.__INITIAL_COMP_STATE__[i]) // ,    data // (  $data     ,     ) comps[i].prefetchedData = window.__INITIAL_COMP_STATE__[i]; delete window.__INITIAL_COMP_STATE__; }); }</span></span></code> </pre> <br><p>  We end the code by taking the root component and calling <code>$mount</code> from it in the root element of the application.  This element will be automatically given the <code>data-server-rendered</code> , so you can do this: <code>app.$mount(document.body.querySelector('[data-server-rendered]'))</code> . </p><br><p>  <strong>Entry point for SSR (server.js)</strong> .  Here, a function is simply created that will accept the context of the request (that is, the request object from express) and initialize the application.  The function should return a promise that will be executed at the moment when all the necessary data is loaded from the API, and the application is ready to be sent to the client. <br>  The procedure for this function may be as follows ( <a href="">code</a> ): </p><br><ol><li>  Create an application from app.js. </li><li>  We configure baseUrl in axios so that it can access the API server locally (if necessary).  Here you just need to remember that there is no browser, and therefore there is no location object from which you can at least take a domain and protocol, so you will need to register it manually. </li><li>  We set the handler for vue-router ready ( <code>app.$router.onReady(...)</code> ), which will be executed when a match is found between the components and the URL: <br><ol><li>  We take all the asynchronous components for this page and perform their functions for pulling asynchronous data.  We collect the returned promises in an array. </li><li>  We are waiting for all promises in <code>Promise.all</code> . </li><li>  Rezolvim, adding to the context of information from vue-meta, vuex state, as well as write to the components and in the context of the data obtained as a result of asynchronous operations. </li></ol></li><li>  We tell the router that it's time to process the URL from the context ( <code>app.$router.push(context.url)</code> ). </li></ol><br><p>  Further, all received data will be processed by the http server, the components will give up their markup, the data with the markup will be written to the template, the resulting HTML will be sent to the client. </p><br><h2 id="komponenty-i-routing">  Components and routing </h2><br><p>  <a href="">Code</a> for registering the router and components for it. </p><br><p>  To develop an application with SSR, you need to assume that <strong>only the</strong> root component or components that are bound to routs have the ability to load data asynchronously before rendering.  For these components, in a special way, you need to handle changes to the route and record the data that the server returned after rendering.  For these purposes, a good solution would be to create mixin, which automatically connects to each component when the router is initialized.  <a href="">Sample code</a> like mixin. </p><br><p>  In prefetch-mixin you need to add something like the following: </p><br><ul><li>  The created hook that will take the prefetchData field (when the application is initialized, the component's data is written to this field, which comes from the server after rendering or simply recorded directly during the server rendering) and completely replace the values ‚Äã‚Äãof <code>this.$data</code> fields with the values ‚Äã‚Äãfrom <code>this.constructor.extendOptions.prefetchData</code> , but only <strong>before the</strong> application is fully initialized, what can we find out from the <code>this.$root._isMounted</code> . </li><li>  beforeMount-hook will call prefetch only on the client after loading the page in the event that a switch to another route has occurred. </li><li>  BeforeRouteUpdate-hook will call prefetch only on the client when changing the parameters of the route. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vm, next, route</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!route) route = vm.$route; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = vm.$options.prefetch({ <span class="hljs-attr"><span class="hljs-attr">store</span></span>: vm.$store, <span class="hljs-attr"><span class="hljs-attr">props</span></span>: route.params, route }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!promise) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next ? next() : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; promise .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(vm.$data, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next) next(); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> next &amp;&amp; next(err)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mixin = { <span class="hljs-comment"><span class="hljs-comment">//        created() { if (this.$root._isMounted || !this.constructor.extendOptions.prefetchedData) return; Object.assign(this.$data, this.constructor.extendOptions.prefetchedData); }, //  prefetch    (   ,      created) beforeMount() { if (this.$root._isMounted &amp;&amp; this.$options.prefetch) update(this); } //  prefetch,     //        ,   beforeMount    beforeRouteUpdate(to, from, next) { if (this.$options.prefetch &amp;&amp; to.path !== from.path) update(this, next, to); else next(); }, };</span></span></code> </pre> <br><h2 id="dalneyshaya-razrabotka">  Further development </h2><br><p>  SSR imposes almost no restrictions on application development.  It is enough just to remember that you cannot use the browser API where the code is executed on the server, in other cases it is necessary to make the code in the client hooks beforeMount / mounted. </p><br><p>  Also, an application created for working with SSR will work correctly without SSR, so this approach can be used for regular SPAs so that when SEO requirements appear suddenly, do not rack your brains and write crutches to optimize your websites. </p><br><p>  There may be problems with directives, whose role is often reduced to manipulating the DOM, but they can be easily solved by giving an alternative implementation (empty?) Instead of the directive on the server ( <a href="">docs</a> ). </p><br><p>  In general, this is all that needs to be considered before starting the development of the application itself.  Then you simply create components, connect the page components to the corresponding routes and, if everything is done correctly, you will receive a rendered page from the server and a correctly working application on the client. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334952/">https://habr.com/ru/post/334952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334940/index.html">Oil price fluctuations: is algorithmic trading to blame?</a></li>
<li><a href="../334942/index.html">Android Architecture Components. Part 4. ViewModel</a></li>
<li><a href="../334944/index.html">37 reasons why your neural network is not working</a></li>
<li><a href="../334948/index.html">Look up from the bottom or Ubuntu Server for the developer of electronics. Part 1</a></li>
<li><a href="../334950/index.html">Linux processes in Bash man</a></li>
<li><a href="../334954/index.html">Dream job hunt</a></li>
<li><a href="../334956/index.html">How to start young mobile game developers from Russia in the current realities</a></li>
<li><a href="../334958/index.html">The digest of interesting materials for the mobile developer # 215 (July 31 - August 5)</a></li>
<li><a href="../334960/index.html">OpenDataScience and Mail.Ru Group will conduct an open machine learning course</a></li>
<li><a href="../334964/index.html">Javascript as thoughtvirus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>