<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Debugging Shaders in Java + Groovy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Shader syntax highlighting. The relationship between shaders and external data structures. Unit tests for shaders, debugging, refactoring, static code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Debugging Shaders in Java + Groovy</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/602/ce8/00a/602ce800a93f4c2bb090f0b42a12259a.png"><br><br>  Shader syntax highlighting.  The relationship between shaders and external data structures.  Unit tests for shaders, debugging, refactoring, static code analysis, and generally full support for IDE.  How to get all this, what is the catch, and what to register in maven ... <br><a name="habracut"></a><br>  Create a project. <br><br><pre><code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/kravchik/senjin</code> </pre> <br>  We copy native libraries in a root of the project. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">$ mvn nativedependencies:copy</code> </pre><br>  This will allow us to run files that have the ‚Äúmain‚Äù method on Ctrl + Shift + F10 (in IDEA) directly from the editor window, without worrying about the classpath. <br><br>  The library works like this: the shader code is written in Groovy, then translated into plain glsl code.  The shader in Groovy is written as regular code that can be called from Java.  The shader uses the same fields and classes as the main program.  This allows the IDE to understand how the shader and the rest of the code are interconnected; for her, they are the usual Groovy and Java classes.  As a result, we have the following amenities: <br><br><ul><li>  IDE support (refactorings, lights) </li><li>  static analysis is simple and not very errors </li><li>  shader debugging </li><li>  unit tests for shaders </li><li>  relationship between buffer and shader structures </li></ul><br>  But even if you use other languages, you can still keep the shader in Groovy and Java.  You will not get a link to the rest of the project, but unit tests, debug, IDE support will be available.  Then the main project will simply use auto-generated files with glsl code. <br><br><h2>  Specific example </h2><br><img src="https://habrastorage.org/files/e5c/eed/34c/e5ceed34c0ce4451ada8d7cba6009e67.png" height="200" width="200" align="left"><br>  I will show the main points on the example of a specular shader (rendering of ‚Äúplastic material‚Äù) - it is quite simple, but it uses varying, uniform, attributes, textures, there is math, in general, you can touch technology. <br><br><h3>  Pixel shader </h3><br>  This is the usual Groovy class with the main method.  The standard opengl functions are inherited by the shader.  Uniform variables are declared as shader fields.  The shader code is in the main function, but its declaration is different from glsl - it explicitly indicates what goes into the shader input (SpecularFi), and where the result should be written (StandardFrame).  We also had to abandon the names of the form vec3, vec4, because Groovy could not make friends with the names of classes starting with a small letter. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularF</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FragmentShaderParent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularFi</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Sampler2D txt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sampler2D() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shininess = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec3f ambient = Vec3f(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vec3f lightDir def </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SpecularFi i, StandardFrame o)</span></span></span><span class="hljs-function"> </span></span>{ Vec3f color = texture(txt, i.uv).xyz; Vec3f matSpec = Vec3f(<span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>); Vec3f lightColor = Vec3f(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vec3f diffuse = color * max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(i.normal, lightDir)) * lightColor; Vec3f r = normalize(reflect(normalize(i.csLightDir), normalize(i.csNormal))); Vec3f specular = lightColor * matSpec * pow(max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(r, normalize(i.csEyeDir))), shininess); o.gl_FragColor = Vec4f(ambient + diffuse + specular, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Here you can already see the merits of the approach.  We make a small mistake in the name and the IDE immediately reports this. <br><br><img src="https://habrastorage.org/files/12e/b5e/2a1/12eb5e2a187d460cb4873625b4169c6e.png"><br><br>  We look that gets to an input of a pixel shader (ctrl + space). <br><br><img src="https://habrastorage.org/files/81d/985/9ae/81d9859aece145b082134bb921305c9d.png"><br><br>  Run the unit test and look at the calculations in the debug. <br><br><img src="https://habrastorage.org/files/bee/c27/75a/beec2775afbe4fb59ba8361c9819cf6f.png"><br><br><h3>  Input data for pixel shader </h3><br>  SpecularFi (fragment input).  A class containing data that is outgoing for a vertex shader and incoming for a pixel shader. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularFi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseVSOutput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec3f normal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec3f csNormal;<span class="hljs-comment"><span class="hljs-comment">//cam space normal public Vec3f csEyeDir; public Vec2f uv; public Vec3f csLightDir;//cam space light dir }</span></span></code> </pre><br><h3>  Vertex Shader </h3><br>  Like the pixel shader, this is a Groovy class, with uniform variables in the fields and the main method with explicit indication of the classes of incoming and outgoing data. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularV</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexShaderParent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularVi</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularFi</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix3 normalMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4 modelViewProjectionMatrix; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vec3f lightDir </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SpecularVi i, SpecularFi o)</span></span></span><span class="hljs-function"> </span></span>{ o.normal = i.normal o.csNormal = normalMatrix * i.normal o.gl_Position = modelViewProjectionMatrix * Vec4f(i.pos, <span class="hljs-number"><span class="hljs-number">1</span></span>) o.csEyeDir = o.gl_Position.xyz o.uv = i.uv o.csLightDir = normalMatrix * lightDir } }</code> </pre><br><h3>  Vertex Shader Input </h3><br>  SpecularVi (vertex input).  The class of the vertex shader falling into the input.  It can also be used to fill the data buffer, the code of which, without the participation of the programmer, agrees with the shader code (goodbye glGetAttribLocation, glBindBuffer, glVertexAttribPointer and other offal). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecularVi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec3f normal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec3f pos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vec2f uv; }</code> </pre><br>  Creating a vertex and pixel shader and combining them into a program: <br><br><pre> <code class="java hljs">SpecularF fragmentShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularF(); SpecularV vertexShader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularV(); GShader shaderProgram = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GShader(vertexShader, fragmentShader);</code> </pre><br>  As you can see, their creation is the usual instantiation of classes.  We leave the shader in variables in order to later transfer the data to them (degree of brilliance, direction of light, etc.) <br><br>  Next, a buffer is created with the data.  It uses the same class that the vertex shader entered. <br><br><pre> <code class="java hljs">ReflectionVBO vbo1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectionVBO(); vbo1.bindToShader(shaderProgram); vbo1.setData(al( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularVi(v3(-<span class="hljs-number"><span class="hljs-number">5</span></span>, -<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), v3(-<span class="hljs-number"><span class="hljs-number">1</span></span>,-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).normalized(), v2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularVi(v3( <span class="hljs-number"><span class="hljs-number">5</span></span>, -<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), v3( <span class="hljs-number"><span class="hljs-number">1</span></span>,-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).normalized(), v2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularVi(v3( <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), v3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).normalized(), v2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpecularVi(v3(-<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), v3(-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).normalized(), v2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); vbo1.upload();</code> </pre><br>  Filling in the input data for shaders.  Parameter passing is simply setting the field values ‚Äã‚Äãin the Groovy objects of the shaders (which were prudently available as variables). <br><br><pre> <code class="java hljs">fragmentShader.shininess = <span class="hljs-number"><span class="hljs-number">100</span></span>; vertexShader.lightDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).normalized(); <span class="hljs-comment"><span class="hljs-comment">//enable texture texture.enable(0); fragmentShader.txt.set(texture); //give data to shader shaderProgram.currentVBO = vbo1;</span></span></code> </pre><br>  And, actually, the connection of the shader and the rendering. <br><br><pre> <code class="java hljs">shaderProgram.enable(); indices.draw();</code> </pre><br>  Unit test shader. <br><br><pre> <code class="java hljs">f.main(vso, frame); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, frame.gl_FragColor.w, <span class="hljs-number"><span class="hljs-number">0.000001</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.6</span></span>, frame.gl_FragColor.x, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, frame.gl_FragColor.y, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.3</span></span>, frame.gl_FragColor.z, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>);</code> </pre><br>  All example code <a href="https://github.com/kravchik/senjin/tree/master/src/main/java/yk/senjin/shaders/gshader/examples/specular">is here</a> . <br><br><pre> <code class="java hljs">Test.java <span class="hljs-comment"><span class="hljs-comment">// -  RawSpecular.java //      SpecularF.groovy //  SpecularV.groovy //  SpecularVi.java //,   (specular Vertex shader Input) SpecularFi.java //,        (specular Fragment shader Input)  WatchSpecular.java //    , ,  ,     </span></span></code> </pre><br>  The library is easy to connect via Maven: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>yk<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>senjin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.11<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>yk.senjin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>https://github.com/kravchik/mvn-repo/raw/master<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Well, briefly about the syntactic differences: <br><br><ol><li>  in the body of the shader, Vec3f is used instead of vec3 (the group could not make friends with the class starting with a small letter) </li><li>  no uniform - instead just fields in the shader </li><li>  no varying, in, out - instead fields in classes passed to main </li></ol><br>  PS I develop the project spontaneously - something will be needed, it is just interesting to do something.  Before I had time to make the structure and a lot of other things.  If you need some kind of functionality or direction of development (android? Geometry shaders? Kotlin?) - contact, discuss! <br><br>  I also want to thank <a href="http://habrahabr.ru/users/oshyshko/" class="user_link">oshyshko</a> and <a href="http://habrahabr.ru/users/olexiy/" class="user_link">olexiy</a> for the help in writing the article. </div><p>Source: <a href="https://habr.com/ru/post/269591/">https://habr.com/ru/post/269591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269575/index.html">Mobile NFC payments market: key players, current situation and future prospects</a></li>
<li><a href="../269577/index.html">Yes, I am writing a Windows desktop application.</a></li>
<li><a href="../269579/index.html">I2P: Transparent EdDSA Signature Implementation</a></li>
<li><a href="../269581/index.html">npm @ 3: the future is here</a></li>
<li><a href="../269589/index.html">Pure architecture</a></li>
<li><a href="../269597/index.html">Webinar third. Backup as the basis of peace. Backup schemes</a></li>
<li><a href="../269599/index.html">Search for uninitialized class members</a></li>
<li><a href="../269601/index.html">Step-by-step work GOST R 34.12-2015 in ECB mode</a></li>
<li><a href="../269603/index.html">Turn a group of surveillance cameras into a botnet? Nothing is easier</a></li>
<li><a href="../269607/index.html">Fujitsu ETERNUS CD10000 S2: what's new?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>