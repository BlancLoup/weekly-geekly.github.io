<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scientifically looking for errors in the cloud: an unexpected CEO adventure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of Stephen Wolfram's post (Stephen Wolfram) "Scientific Bug Hunting in the Cloud: An Unexpected CEO Adventure" . 
 I express my deep grati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scientifically looking for errors in the cloud: an unexpected CEO adventure</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/f5d/0f0/197/f5d0f01973674240897d2d2896c6bd52.png" width="800"></div><br>  <i>Translation of Stephen Wolfram's post (Stephen Wolfram) <a href="http://blog.wolfram.com/2015/04/16/scientific-bug-hunting-in-the-cloud-an-unexpected-ceo-adventure/">"Scientific Bug Hunting in the Cloud: An Unexpected CEO Adventure"</a> .</i> <i><br></i>  <i>I express my deep gratitude to <a href="http://vk.com/ld742">Kirill Guzenko</a> for his help in translating.</i> <br><br><h2>  Wolfram Cloud must be perfect </h2><br>  <a href="http://www.wolfram.com/cloud/">Wolfram Cloud</a> will soon be out of beta testing, at the moment I spend a lot of time to make this system as good as possible (and, it is worth noting, it turns out really great!).  I mainly deal with high-level functions and strategy.  But I like to control the process at all levels, because, as a CEO, I am fully responsible for everything that happens in my company.  And in early March, I was immersed in what I could not have guessed before. <br><br>  Actually, that's what it is about.  As a serious production system that many people will use, including for business, the Wolfram Cloud should work as quickly as possible.  The indicators showed that the speed was good enough, but it was subjectively felt that something was wrong.  Sometimes everything was really fast, but sometimes it seemed that everything was working too slowly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are excellent programmers in our team, however, months went by and there were no changes whatsoever.  In the meantime, we managed to release Wolfram Data Drop (see the article on <a href="http://habrahabr.ru/company/wolfram/blog/253873/">Wolfram Data Drop - the new Wolfram Research service</a> ).  So I thought, why don't I do some tests myself, maybe, and collect some information in our new Wolfram Data Drop? <br><br>  A significant advantage of <a href="http://www.wolfram.com/language/">Wolfram Language</a> is how good it is for busy people: even if you have time just to print just a few lines of code (see the article on Habrahabr. <a href="http://habrahabr.ru/company/wolfram/blog/237359/">Wolfram Research opened the Tweet-a-Program service: interesting programs in Wolfram Language, whose length does not exceed 140 characters</a> "), you can get something really useful.  And, in this case, it was enough for me to look through three lines of code to find the problem. <br><br>  First, I deployed a <a href="http://reference.wolfram.com/language/guide/CreatingAnInstantAPI.html">web API</a> for a simple program on the Wolfram Language on the Wolfram Cloud: <br><br><img title="In [1]: = CloudDeploy [APIFunction [{}, 1 &amp; amp;]]" src="https://habrastorage.org/getpro/habr/post_images/2b5/1ea/576/2b51ea5767d8025cb779826b6936f26e.png" alt="In[1]:= CloudDeploy[APIFunction[{}, 1 &amp;amp;]]" width="587" height="61"><br><a name="habracut"></a><br>  Then I called the API 50 times in a row, each time measuring how long the call lasted ( <a href="http://reference.wolfram.com/language/tutorial/UsingPreviousResults.html">%</a> is the previous calculated result): <br><br><img title="In [2]: = Table [First [AbsoluteTiming [URLExecute [%]]], {50}]" src="https://habrastorage.org/getpro/habr/post_images/992/74c/843/99274c84372d93274fa9d734da9c2403.png" alt="In[2]:= Table[First[AbsoluteTiming[URLExecute[%]]], {50}]" width="620" height="149"><br><br>  After that, I built a sequence of calls in time: <br><br><img title="In [3]: = ListLinePlot [%]" src="https://habrastorage.org/getpro/habr/post_images/7c2/178/fa8/7c2178fa8c7e501f098dddc0f48bf344.png" alt="In[3]:= ListLinePlot[%]" width="620" height="252"><br><br>  And then he got something that did not fit in the head.  Sometimes the call took <a href="http://www.wolframalpha.com/input/%3Fi%3D220%2520ms">220 ms</a> or something like that, but a delay of <a href="http://www.wolframalpha.com/input/%3Fi%3D900%2520ms">900 ms</a> was discovered twice.  But the craziest thing was that the signal seems to be quantized! <br><br>  I built a histogram: <br><br><img title="In [4]: ‚Äã‚Äã= Histogram [%%, 40]" src="https://habrastorage.org/getpro/habr/post_images/516/8bc/6a2/5168bc6a23afca0f5175f21568b48a01.png" alt="In[4]:= Histogram[%%, 40]" width="563" height="251"><br><br>  And, of course, there were several quick calls that were located on the left, rather slow calls in the middle, and the slowest calls on the right.  It was weird! <br><br>  I wondered if this was always the case.  So I created a <a href="http://reference.wolfram.com/language/guide/BackgroundAndScheduledTasks.html">scheduled task</a> ‚Äî to make an API call every few minutes, and then send the data to Wolfram Data Drop.  And when I returned in the morning, this is what I saw: <br><br><img title="Graph of API calls, showing strange, large-scale structure" src="https://habrastorage.org/getpro/habr/post_images/a6f/fb4/4d9/a6ffb44d9a25a20f15711ae4ed6cc15b.png" alt="Graph of API calls, showing strange, large-scale structure" width="528" height="219"><br><br>  Even more strange picture!  Where did the large-scale structure come from?  I could still understand, for example, that a particular node in a cluster is slowly slowing down, but why is it then slowly recovering? <br><br>  My first thought was that I ran into problems with the network, considering that I was more than a thousand miles away from the cloud server.  Then I looked at the ping.  But apart from a couple of strange peaks (hey, this is the Internet!), Everything was very stable. <br><br><img title="Ping times" src="https://habrastorage.org/getpro/habr/post_images/777/292/7bb/7772927bb3f4d352051ebbc471cdcb9f.png" alt="Ping times" width="506" height="217"><br><br><h2>  Something is wrong inside the servers </h2><br>  Well, it must be some kind of problem with the servers themselves.  Wolfram Cloud contains a lot of different technologies, but basically it‚Äôs still pure Wolfram Language code that is easily tested.  But behind the stratum of the language itself there is a modern server infrastructure.  Much of it is practically the same as that used in <a href="http://www.wolframalpha.com/">Wolfram | Alpha for the</a> last <a href="http://blog.stephenwolfram.com/2009/05/wolframalpha-is-launching-made-possible-by-mathematica/">fifteen years</a> to output billions of results, and that has been used in the <a href="http://www.wolfram.com/products/webmathematica/"><em>Mathematica</em> web for the</a> last ten years.  But, being a somewhat more demanding computing system, the Wolfram Cloud is a bit different. <br><br>  And my first guess was that different settings could be the reason that something was going wrong in the web server layer.  In the end, I hope the entire infrastructure from top to bottom will be written in pure Wolfram Language, but now we have to use the TomCat web server, which runs on Java.  And the first thing I thought was that such slowdowns could be caused by the Java garbage collector.  The analysis showed that the garbage collection initiated by Tomcat did cause some slowdowns, but they were insignificant and measured in units of milliseconds, not hundreds.  So this could not be an explanation. <br><br>  I was very focused on finding the problem.  I have not had to dig so deeply in search of problems and mistakes for a long time.  It felt as though I was doing experimental science.  And, as is customary in experimental science, it is important to simplify the object of study as much as possible.  Thus, I cut out most of the network elements, managing the ‚Äúcloud from the cloud‚Äù (calling the API from the same cluster).  Then I removed the load balancer, which sends requests to specific nodes of the cluster, blocking my requests to a specific node (which, by the way, third-party users cannot do if they do not have a <a href="http://www.wolfram.com/private-cloud/">private cloud</a> ).  However, the delay still remained. <br><br>  After that, I began to collect more detailed data.  My first step was to create an API that would return the absolute start and end time for the Wolfram Language code and compare it with the absolute time in the API.  And that's what I saw: <br><br><img title="The blue line shows the API. the gold line, after." src="https://habrastorage.org/getpro/habr/post_images/fab/173/85e/fab17385e7bacd7f9d4448a0d85e0f48.png" alt="The blue line shows the API-call times from before the Wolfram Language code was run; the gold line, after." width="511" height="218"><br><br>  The blue line indicates the time before the Wolfram Language code starts;  the golden line is after.  I collected this data during the period when the system as a whole worked rather poorly.  I saw serious decelerations in the period before initialization, and only a few isolated decelerations in the period after. <br><br>  And again - it was very strange.  It did not appear that the decelerations were specifically related to the period ‚Äúbefore‚Äù or ‚Äúafter‚Äù.  On the contrary, as if something <a href="">accidental</a> from outside the system knocked it out. <br><br>  I was embarrassed by the fact that each cluster node in general contains eight cores, and each core works with its own instance of the <a href="http://www.wolfram.com/engine/">Wolfram Engine</a> .  The engine is balanced and stable, and each instance of it can work for many hours or even days without rebooting.  And I thought - what if some instances contain some errors?  After that, I decided to build an API that would track the <a href="http://reference.wolfram.com/language/ref/%24ProcessID.html">ID</a> and <a href="http://reference.wolfram.com/language/ref/TimeUsed.html">time of the processes</a> , and then, for example, build the dependence of the total process time on the execution time of the API components: <br><br><img title="Total process time for the API call time" src="https://habrastorage.org/getpro/habr/post_images/390/fa1/922/390fa1922cb79a416644b66ac5864fa9.png" alt="Total process time plotted against components of the API call time" width="516" height="212"><br><br>  Indeed, the trends of new processes for a faster API call began to appear, but (especially noting the grouping of points near zero on the x axis), the effect was insignificant. <br><br><h2>  What feeds the CPU? </h2><br>  I started thinking about other Wolfram Cloud services running on the same machine.  It would seem that it does not make sense that they can lead to the quantized slowdowns, but to simplify the system I wanted to get rid of them.  First of all, we isolated the node on the production cluster.  Then I started setting up my private <a href="http://www.wolfram.com/private-cloud/">Wolfram Private Cloud</a> .  But everything slowed down.  Although, at different times and on different machines, their characteristics seemed to be somewhat different. <br><br>  In a private cloud, I could just go into raw Linux and start looking around.  The first thing I did was to <a href="http://reference.wolfram.com/language/guide/DirectControlOfExternalProcesses.html">start collecting results</a> from the Unix utilities ‚Äútop‚Äù and ‚Äúps axl‚Äù in Wolfram Language, and then I started analyzing them.  And one thing was completely obvious: a lot of system time was constantly involved, the Linux kernel was always busy with something.  And, in fact, it seemed that the slowdowns might not come from user code at all;  they can come from something that happens in the kernel of the operating system. <br><br>  Actually, it encouraged me to do a trace of system calls.  I have not done anything like this for the past almost 25 years, but my past experience suggested that I have the opportunity to obtain a large amount of data, but difficult to interpret.  However, now I have Wolfram Language. <br><br>  The running ‚Äústrace‚Äù utility on Linux, making API calls for a few seconds, contained 28,221,878 lines at its output.  However, it took just a few lines of the Wolfram Language code to put together the start and end times for certain system calls to build a histogram of the duration of the system calls.  Having done this for just a few system calls, I got this: <br><br><img title="System-call durations - note the clustering ..." src="https://habrastorage.org/getpro/habr/post_images/bf7/39f/685/bf739f6859c8c38f862fcd3607671253.png" alt="System-call durations--note the clustering..." width="528" height="214"><br><br>  Interestingly, we received pronounced discrete peaks.  And when I looked at the system calls corresponding to these peaks, it seemed that they all come from futex (the part of Linux responsible for synchronizing threads).  Then I selected only calls from futex and saw sharp peaks at 250 ms, 500 ms and 1000 ms: <br><br><img title="Fuck calls - showing sharp timing peaks" src="https://habrastorage.org/getpro/habr/post_images/100/687/60b/10068760b1f0c1f6c5fc169983c660bb.png" alt="System-call durations for just the futex calls--showing sharp timing peaks" width="620" height="138"><br><br>  But were they really a problem?  Call futex, in fact, is not active;  they do not take up CPU time.  And, in fact, this is a very typical situation - when some calls are waiting for I / O to complete them.  So for me, the most interesting point was that there were no other system calls that would take hundreds of milliseconds. <br><br><h2>  So, the operating system itself slows down! </h2><br>  So what happens?  I began to observe - what happens on the different cores of each node?  Now Tomcat and other parts of our infrastructure do an excellent job with multithreading.  Nevertheless, it turned out that what causes slowdowns causes all cores to slow down, even though they work with different threads.  And the only thing that can do this is the core of the operating system. <br><br>  But what would cause the Linux kernel to cause such slowdowns?  I thought about the planner.  I could not understand why our situation leads to inadequate behavior in the scheduler.  But we all looked at the scheduler and tried to change various settings.  No effect <br>  Then I got an even stranger thought.  The Wolfram Cloud instances that I used worked through virtual machines.  And what if the slowdown came ‚Äúfrom the outside of the Matrix‚Äù?  I requested a version of the Wolfram Cloud running on bare metal - without a virtual machine.  But before I was provided with it, I found a utility that measures the time it takes to lose a virtual machine, and it turned out to be negligible. <br><br>  At this point, I dealt with this issue for an hour or two every day.  At this time, I was just having a rich trip to the SXSW festival (see the article on Habrahabr " <a href="http://habrahabr.ru/company/wolfram/blog/255579/">Stephen Wolfram: Frontiers of computational thinking (report from the SXSW festival)</a> ").  Until now, professionals in our cloud software design team have been actively involved in this issue, and I left this task to their skilled hands. <br><br>  When I flew back, I came across other interesting moments.  We divided each API call into 15 intermediate actions.  Then one of our engineers with PhD in the field of physics compared the probability of slowing down at each step (left) with the average time spent on this step (right): <br><br><img title="Slow down in particular substeps; time spent on each substeps" src="https://habrastorage.org/getpro/habr/post_images/6db/922/d60/6db922d600025698bdbe96ed2d8804b4.png" alt="Bars on the left show the probability for a slowdown in particular substeps; bars on the right show the median time spent in each of those substeps" width="496" height="278"><br><br>  With one exception (which was caused by a known cause), we received a clear correlation.  Everything looked as if the Linux kernel (and everything that works under its control) fell under the influence of something incomprehensible and at a completely random time, causing the same slowdowns that occurred at the time of calling some part of the API. <br><br>  And we began to search for what caused these slowdowns.  The next suspicious thing we noticed is a large number of I / O operations.  In the configuration we tested, Wolfram Cloud used NFS to access the files.  We tried to push NFS, change various parameters, use asynchronous mode, use UDP instead of TCP, change the I / O scheduler of the NFS server, etc. No changes.  We tried to use a completely different file system called Ceph.  Same problem.  Then we tried to use a local disk as memory.  In the end, it seems that it worked - most of the slowdowns disappeared, but some remained. <br><br>  We took this as a sign and began to dig further into the area of ‚Äã‚ÄãI / O operations.  We conducted an experiment that involved editing a huge notebook on a node when running a large number of API calls on the same node: <br><br><img title="Note that it was time for the user to go online." src="https://habrastorage.org/getpro/habr/post_images/195/b53/6c1/195b536c19841cd1673946737c566cdb.png" alt="Graph of system time, user time, and API time spent editing a huge notebook--with quite a jump while the notebook was being edited and continually saved" width="604" height="209"><br><br>  The result was interesting.  During the period when the notebook was edited (and constantly saved), API calls lasted 500 ms instead of 100 ms.  But why did simple file operations have such a strong influence on all 8 cores of a node? <br><br><h2>  The culprit found </h2><br>  We began to dig further, and soon we realized that simple file operations really were not, and we quickly understood why.  You know, about five years ago, at the beginning of the development of Wolfram Cloud, we wanted to experiment with tracking file versions.  And, as a prototype, someone introduced a simple version control system called RCS. <br><br>  Many software systems in the world still use RCS, even though it has not had significant updates for almost 30 years, and by now much better solutions have emerged (like the ones we use for endless cancellation in notebooks) .  But for some reason, that very prototype RCS was never replaced in our Wolfram Cloud codebase - and it was still running in every file! <br><br>  One feature of RCS is that when a file is changed, even by just one bit, a large amount of data (sometimes as large as a file several times larger than the file itself) is written to disk.  We weren't sure how many I / O operations in general could be expected.  But it was clear that RCS makes this process unnecessarily more intensive. <br><br>  Can I / O operations actually hang the entire Linux kernel?  Perhaps there is some unknown global gateway.  The disk subsystem may hang because it does not quickly flush the full buffers.  The kernel may be busy re-displaying web pages in order to make large portions of memory available.  Anything could happen at all, however, it was obvious that you just need to replace the RCS and see what changes it leads to. <br><br>  We did it, and, lo and behold, these terrible decelerations immediately disappeared! <br><br>  So, after a week of intensive debugging, we got a solution to our problem.  And, when conducting the re-experiment, now everything worked as it should - the time for calling the API completely prevailed over the transfer time to the test cluster: <br><br><img title="Clean run times! Compare this to the In [3] image above." src="https://habrastorage.org/getpro/habr/post_images/0c0/e75/85c/0c0e7585ca90df54825616bb93ca8cf2.png" alt="Clean run times! Compare this to the In[3] image above." width="508" height="226"><br><br><h2>  Wolfram language and cloud </h2><br>  What did this teach me?  First of all, my impression has increased that cloud software is the most difficult (even hostile) environment of development and debugging that I have ever encountered.  Secondly, it made me realize how valuable Wolfram Language is as a kind of metasystem for analyzing, visualizing and organizing everything that happens within such a complex system as a cloud. <br><br>  As for debugging, in this matter I am somewhat spoiled - since I write overwhelmingly at Wolfram Language, where debugging is very easy, and where I rarely had to spend more than a few minutes to find the error.  Why is debugging so easy with Wolfram Language?  First of all, I think this is because the code is usually <a href="http://www.wolfram.com/language/tweet-a-program/">short and readable</a> .  The same code is usually written in notebooks, where it can be tested, and each part of the program is documented when it is created.  It is also an important detail that the Wolfram Language is a symbolic language, so you can always take any part of the program, and it will work independently. <br><br>  Debugging software at lower levels is a completely different process.  It is much more similar to the process of issuing a <a href="http://blog.stephenwolfram.com/2011/04/computation-and-the-future-of-biomedicine/">medical diagnosis</a> , where they also deal with complex multicomponent systems and try to make a diagnosis based on the results of several measurements or experiments (if we think by analogies, then our version control problem might look like some terrible defect in DNA replication). <br><br>  All this adventure in the cloud also very much emphasizes the value that we put on the Wolfram Cloud.  Because a significant part of what the Wolfram Cloud is - protecting users from all the problems with the complexities of cloud infrastructure software, enabling them to <a href="http://www.wolfram.com/universal-deployment-system/">develop and deploy</a> anything directly in Wolfram Language. <br><br>  Of course, in order to make this possible, we ourselves had to build the entire automated infrastructure.  And now, thanks to this little adventure in ‚Äúdebugging with a scientific approach,‚Äù we are one step closer to this.  And indeed, today, Wolfram Cloud has its own API, which works without any mysterious quantized slowdowns and is rapidly approaching the state when it can completely exit the beta version. </div><p>Source: <a href="https://habr.com/ru/post/256521/">https://habr.com/ru/post/256521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256505/index.html">Webix. The first acquaintance with the JavaScript framework</a></li>
<li><a href="../256509/index.html">Subject-event approach to modeling complex systems</a></li>
<li><a href="../256513/index.html">The challenge of a hundred boxes and the rescue of prisoners - the final chord</a></li>
<li><a href="../256515/index.html">Script to backup EC2-instance to AMI</a></li>
<li><a href="../256517/index.html">Separate interfaces for unit testing</a></li>
<li><a href="../256523/index.html">Sprockets 3 encoding problem when working with HTML files</a></li>
<li><a href="../256525/index.html">Checking the Haiku operating system (BeOS family) with PVS-Studio. Part 2</a></li>
<li><a href="../256527/index.html">Prototype this Or useful functionality faster than a cup of coffee</a></li>
<li><a href="../256529/index.html">Overview of add-ons for Blender 3D</a></li>
<li><a href="../256533/index.html">Fast stitching panorama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>