<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.6 - Textures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last lesson, we learned to paint our objects in different colors. But in order to achieve some realism, we need a lot of colors. Last time, we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.6 - Textures</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  In the last lesson, we learned to paint our objects in different colors.  But in order to achieve some realism, we need a lot of colors.  Last time, we painted the vertices of the triangle, if we go the same way, then we will need too many vertices to display the picture.  Interested, please under the cat. </p><br><habracut></habracut><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><p>  Part 1. Start <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2. Basic lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br><p>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br><p>  Part 4. OpenGL advanced features <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br><p>  Part 5. Advanced Lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li></ol></div></div><br><p>  Programmers and artists prefer to use <em>textures</em> .  The texture is a 2D image (1D and 3D texture also exist) used to add details to the object;  Consider that the texture is a piece of paper with a picture of a brick (for example) that is glued to your house and it seems that your house is made of brick. </p><br><blockquote>  In addition to images, textures can store large data sets sent to shaders, but we will leave this question for another lesson.  Below you can see the texture of a brick wall stuck on a triangle from the last lesson. </blockquote><p><img src="https://habrastorage.org/files/856/b75/ef5/856b75ef53f8487e8dc1e2e63597a68d.png" alt="Brick wall on the triangle"></p><br><p>  In order to bind a texture to a triangle, we must tell each vertex of the triangle which part of the texture this vertex belongs to.  Each vertex must have <i>texture coordinates</i> associated with a part of the texture. </p><br><p>  Texture coordinates are between 0 and 1 along the x and y axis (we use 2D textures).  Getting texture color using texture coordinates is called sampling.  Texture coordinates start at (0, 0) in the lower left corner of the texture and end with (1, 1) in the upper right corner.  The image below shows how we superimposed the texture coordinates on the triangle: </p><br><p><img src="https://habrastorage.org/files/847/194/dbf/847194dbf6c248aa8adf8dc4c0686361.png" alt="On the triangle"></p><br><p>  We specified 3 texture coordinates for the triangle.  We want the lower left corner of the triangle to correspond with the lower left corner of the texture, so we pass <strong>(0, 0) to the</strong> lower left vertex of the triangle.  Accordingly, we transfer <strong>(1, 0)</strong> to the bottom right vertex.  The upper vertex of the triangle should correspond to the central part of the upper side of the texture, so we transfer to the upper vertex <strong>(0.5, 1.0)</strong> as the texture coordinate. </p><br><p>  As a result, the texture coordinates for the triangle should look something like this: </p><br><pre><code class="cpp hljs">GLfloat texCoords[] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    1.0f, 0.0f, //    0.5f, 1.0f //    };</span></span></code> </pre> <br><p>  Texture sampling can be performed by various methods.  Our job is to tell OpenGL how it should do the sampling. </p><br><h3 id="texture-wrapping">  Texture wrapping </h3><br><p>  Texture coordinates are often between <strong>(0,0)</strong> and <strong>(1,1)</strong> , but what happens if texture coordinates fall outside this range?  The default behavior of OpenGL is to repeat the image (in fact, the integer part of the floating-point number is simply ignored), but there are also other options: </p><br><ul><li>  <em>GL_REPEAT</em> : Standard behavior for textures.  Replaces the texture. </li><li>  <em>GL_MIRRORED_REPEAT</em> : It looks like _GL <em>REPEAT</em> , except that the image is reflected in this mode. </li><li>  <em>GL_CLAMP_TP_EDGE</em> : <em>Binds</em> coordinates between <strong>0</strong> and <strong>1</strong> .  As a result, coordinates outside the boundaries will be bound to the texture border. </li><li>  <em>GL_CLAMP_TO_BORDER</em> : Coordinates outside the range will give the user-defined border color. </li></ul><br><p>  Each of these options is displayed differently when using texture coordinates that extend beyond the gap.  The image below perfectly demonstrates the differences: </p><br><p><img src="https://habrastorage.org/files/cec/ccf/12d/cecccf12dd234b2f8525383be6eff548.png" alt="Demonstration of options differences"></p><br><p>  Each of the above options can be set on the axis ( <strong>s</strong> , <strong>t</strong> (and <strong>r</strong> if you use 3D textures), equivalent to <strong>x</strong> , <strong>y</strong> and <strong>z</strong> ) using the ** glTextParameter *** functions: </p><br><pre> <code class="cpp hljs">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</code> </pre> <br><p>  The first argument defines the goal to which our texture is attached, we work with a 2D texture, so our value will be <em>GL_TEXTURE_2D</em> .  The second value is required to tell OpenGL which particular parameter we want to set.  We want to configure the <strong>WRAP</strong> option and specify its value for the <strong>S</strong> and <strong>T</strong> axes.  The last argument passed the selected wrapping method.  In this case, we use <em>GL_MIRRORED_REPEAT</em> . </p><br><p>  If we had chosen <em>GL_CLAMP_TO_BORDER</em> , then we would still have to specify the color of the borders.  This is done <em>fv</em> alternative <strong>glTextParameter</strong> with the transfer to it <em>GL_TEXTURE_BORDER_COLOR</em> as an option and an array of floating-point numbers as a color value. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> borderColor[] = { <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</code> </pre> <br><h3 id="filtrovanie-tekstur">  Texture filtering </h3><br><p>  Texture coordinates are not dependent on resolution, but they can take any floating point values, so OpenGL needs to understand which pixel of the texture (also called <em>Texel</em> ) it needs to impose.  This problem becomes most acute if you want to impose a low-resolution texture on a large object.  You may have already guessed that in OpenGL there is an option for filtering textures.  There are several options available, but we will discuss only the most important ones: <em>GL_NEAREST</em> and <em>GL_LINEAR</em> . </p><br><p>  <em>GL_NEAREST</em> (also called <em>the nearest neighbor filter</em> ) is the standard OpenGL filtering method.  As long as it is installed, OpenGL will select the pixel that is closest to the texture coordinate.  Below you can see 4 pixels and a cross showing the texture coordinate.  Since the center of the upper left texel is closest to the texture coordinate, it is chosen as the color of the sample. </p><br><p><img src="https://habrastorage.org/files/08d/3ac/382/08d3ac38282a423ea9d4d3a291c3f93d.png" alt="Neighbor Neighbor Filter"></p><br><p>  <em>GL_LINEAR</em> (also called <em>(bi) linear filtering</em> ).  Accepts the interpolated value from the texels closest to the texture coordinate.  The closer the texel is to the texture coordinate, the greater the color multiplier of this texel. </p><br><p>  Below you can see an example of mixing colors of neighboring pixels: </p><br><p><img src="https://habrastorage.org/files/af8/890/e26/af8890e261f24f4b9dc3d813ecc62202.png" alt="Bilinear filtering"></p><br><p>  But what is the visual effect of the selected filtering effect?  Let's see how these methods will work with the texture in a small resolution on a large object (the texture has been enlarged so that you can see individual texels): </p><br><p><img src="https://habrastorage.org/files/4f4/d23/fdb/4f4d23fdb4304649a3991de8f6d7cc6d.png" alt="Filtrating job"></p><br><h4 id="mipmaps">  Mipmaps </h4><br><p>  Imagine that you have a large room with thousands of objects, each of which is attached to the texture.  Some of the objects are closer to the observer, some of the objects are farther from the observer and each object has a high resolution texture attached.  When the object is far from the observer, only a few fragments need to be processed.  OpenGL has difficulty getting the right color for a fragment from a high-resolution texture when you have to take into account a large number of texture pixels.  This behavior will generate artifacts on small objects, not to mention excessive memory waste associated with the use of high-resolution textures on small objects. </p><br><p>  To solve this problem, OpenGL uses a technology called mipmaps, which provides a set of texture images where each subsequent texture is half the size of the past.  The idea behind the mipmap is quite simple: after a certain distance from the observer, OpenGL will use a different mipmap texture that will look better at the current distance.  The farther away from the observer the object is, the less texture will be used, since it will be more difficult for the user to notice the difference between texture resolutions. Also, mipmaps have a pleasant property of increasing productivity, which is never superfluous.  Let's take a closer look at the mipmap example: </p><br><p><img src="https://habrastorage.org/files/396/2d6/aba/3962d6aba2f44a378d0d2d75f6c8715d.png" alt="Mipmap example"></p><br><p>  Creating a set of mipmap textures for each image is rather a chore, but fortunately OpenGL can generate them by calling <strong>glGenerateMipmaps</strong> after creating the texture.  Soon we will see an example. </p><br><p>  While switching between mipmap levels during the rendering process, OpenGL may display some artifacts, such as sharp edges between two levels.  As it is possible to use filtering on textures, it is also possible to use filtering at various mipmap levels using <em>NEAREST</em> and <em>LINEAR</em> filtering to switch between levels.  To specify the filtering method between mipmap levels, we can replace the standard methods with one of the following four settings: </p><br><ul><li>  _GL_NEARESET_MIPMAP <em>NEAREST</em> : Selects the closest mipmap associated with the pixel size and also uses the nearest neighbor interpolation for texture sampling. </li><li>  _GL_LINEAR_MIPMAP <em>NEAREST</em> : Selects the nearest mipmap and samples it using linear interpolation. </li><li>  _GL_NEAREST_MIPMAP <em>LINEAR</em> : Linear interpolation between the two closest mipmaps and texture sampling using linear interpolation. </li></ul><br><p>  As with texture filtering, we can set the filtering method using the <strong>glTexParameteri</strong> function </p><br><pre> <code class="cpp hljs">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code> </pre> <br><p>  A common mistake is to set the mipmap filtering method as a magnifying filter.  This will have no effect, since mipmaps are mainly used when reducing texture.  Enlargement of the texture does not use mipmaps, therefore, when passing the filter option to mipmaps, it generates an error <strong>GL_INVALID_ENUM</strong> . </p><br><h2 id="zagruzka-i-sozdanie-tekstur">  Loading and creating textures </h2><br><p>  Before we start using our textures, we need to load them into our application.  Texture images can be stored in a limitless number of formats, each of which has its own structure and data ordering, so how do we transfer our image to the application?  One solution is to use a convenient format, for example. <strong>PNG</strong> and write your own system for loading images into a large array of bytes.  Although writing your own image uploader does not constitute a very heavy job, it‚Äôs still quite tedious, especially if you want to use many file formats. </p><br><p>  Another solution is to use a ready-made library for downloading images, which would support many different popular formats and do a lot of hard work for us.  For example <strong>SOIL</strong> . </p><br><h3 id="soil">  SOIL </h3><br><p>  SOIL stands for Simple OpenGL Image Library, supports most popular image formats, is easy to use and can be downloaded <a href="http://www.lonesock.net/soil.html">from here</a> .  Like most other libraries, you will have to generate the <strong>.lib</strong> file yourself.  You can use one of their projects located in the <strong>/ projects</strong> folder (do not worry if their project version is lower than your VS version. Just convert them to a new version, this should work in most cases) to create your own based on it.  Also add the contents of the <strong>src</strong> folder to your <strong>include</strong> folder.  Also, do not forget to add <strong>SOIL.lib</strong> to your linker settings and add <strong>#include &lt;SOIL.h&gt;</strong> at the beginning of your code. </p><br><p>  For the current texture section we will use the image of a <a href="">wooden container</a> .  To load an image via SOIL, we use the <strong>SOIL_load_image</strong> function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, height; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* image = SOIL_load_image(<span class="hljs-string"><span class="hljs-string">"container.jpg"</span></span>, &amp;width, &amp;height, <span class="hljs-number"><span class="hljs-number">0</span></span>, SOIL_LOAD_RGB);</code> </pre> <br><p>  The first argument of the function is the location of the image file.  The second and third arguments are pointers to int into which the image dimensions will be placed: width and height.  We need them to generate the texture.  The fourth argument is the number of image channels, but we will leave there just 0. The last argument tells SOIL how to load the image: we need only RGB image information.  The result will be stored in a large array of bytes. </p><br><h3 id="generaciya-tekstury">  Texture generation </h3><br><p>  As with any other object in OpenGL, identifiers refer to textures.  Let's create one: </p><br><pre> <code class="cpp hljs">GLuint texture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture);</code> </pre> <br><p>  The <strong>glGenTextures</strong> function takes as the first argument the number of textures to generate, and the second argument is the <strong>GLuint</strong> array in which the identifiers of these textures will be stored (in our case, this is one <strong>GLuint</strong> ).  Just like any other object, we will bind it so that functions using textures know which texture to use. </p><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, texture);</code> </pre> <br><p>  After binding the texture, we can start generating texture data using the preloaded image.  Textures are generated using <strong>glTexImage2D</strong> : </p><br><pre> <code class="cpp hljs">glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, width, height, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_UNSIGNED_BYTE, image); glGenerateMipmap(GL_TEXTURE_2D);</code> </pre> <br><p>  This function has quite a lot of arguments, so let's take one step at a time: </p><br><ul><li>  The first argument describes the texture target.  By setting the value of <strong>GL_TEXTURE_2D,</strong> we told the function that our texture is tied to this target (so that other targets <strong>GL_TEXTURE_1D</strong> and <strong>GL_TEXTURE_3D</strong> will not be involved). </li><li>  The second argument describes the mipmap level for which we want to generate a texture, if suddenly we want to generate mipmaps ourselves.  Since we will leave the Mipmap generation on OpenGL, we will pass 0. </li><li>  The third argument tells OpenGL in which format we want to store the texture.  Since our image has only <strong>RGB</strong> values, we will also store only <strong>RGB</strong> values ‚Äã‚Äãin textures. </li><li>  The fourth and fifth arguments specify the width and height of the resulting texture.  We got these values ‚Äã‚Äãearlier while loading the image. </li><li>  The sixth argument should always be 0. (The argument is obsolete). </li><li>  The seventh and eighth arguments describe the format and data type of the original image.  We loaded RGB values ‚Äã‚Äãand stored them in bytes (char) so we pass these values. </li><li>  The final argument is the image data itself. </li></ul><br><p>  After calling <strong>glTexImage2D, the</strong> current bound texture will have an image bound to it.  True, the texture will have only the base image and if we want to use mipmaps, then we will have to set the image in the same way simply by incrementing the value of the mipmap level.  Well, or we can just call <strong>glGenerateMipmap</strong> after generating the texture.  This function will automatically generate all the required mipmaps for the currently bound texture. </p><br><p>  After the end of texture generation and mipmaps, it is good practice to free up a section of memory allocated for the loaded image and untie the texture object. </p><br><pre> <code class="cpp hljs">SOIL_free_image_data(image); glBindTexture(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  The whole texture generation process looks like this: </p><br><pre> <code class="cpp hljs">GLuint texture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); <span class="hljs-comment"><span class="hljs-comment">//      (  ) ... //     int width, height; unsigned char* image = SOIL_load_image("container.jpg", &amp;width, &amp;height, 0, SOIL_LOAD_RGB); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image); glGenerateMipmap(GL_TEXTURE_2D); SOIL_free_image_data(image); glBindTexture(GL_TEXTURE_2D, 0);</span></span></code> </pre> <br><h3 id="primenenie-tekstur">  Texture application </h3><br><p>  For the next chapters, we'll use the quad drawn with * <em>glDrawElements</em> from the last part of the <a href="https://habrahabr.ru/post/311808/">Hello Triangle</a> lesson.  We need to tell OpenGL how to sample the texture, so we will update the vertex data by adding texture coordinates to them: </p><br><pre> <code class="cpp hljs">GLfloat vertices[] = { <span class="hljs-comment"><span class="hljs-comment">//  //  //   0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, //   0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, //   -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, //   -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f //   };</span></span></code> </pre> <br><p>  After adding additional attributes, we will again have to notify OpenGL about our new format: <br><img src="https://habrastorage.org/files/299/b9a/8c3/299b9a8c3ef44d7f8561d63b0dda97d6.png" alt="New vertex data format">  . </p><br><pre> <code class="cpp hljs">glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, GL_FLOAT,GL_FALSE, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), (GLvoid*)(<span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat))); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Notice that we also adjusted the step value of the last two attributes under <strong>8 * sizeof (GLfloat)</strong> . </p><br><p>  Then we need to change the vertex shader so that it accepts the texture coordinates as an attribute and then passes them to the fragment shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 texCoord; out vec3 ourColor; out vec2 TexCoord; void main() { gl_Position = vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); ourColor = <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; TexCoord = texCoord; }</code> </pre> <br><p>  The fragment shader should also accept a <strong>TexCoord</strong> as an input variable. </p><br><p>  The fragment shader should also have access to the texture object, but how do we pass it to the fragment shader?  GLSL has a built-in data type for texture objects, called a <strong>sampler</strong> whose texture type is as an ending, ie <strong>sampler1D, sampler3D</strong> and, in our case, <strong>sampler2D</strong> .  We can add texture to the fragment shader by simply declaring a <strong>uniform smpler2D</strong> to which we will later transfer the texture. </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 ourColor; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 TexCoord; out vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D ourTexture; void main() { <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = texture(ourTexture, TexCoord); }</code> </pre> <br><p>  For sampling the color of the texture, we use the <strong>texture</strong> function built into GLSL, which takes the texture sampler as the first argument and texture coordinates as the second argument.  The <strong>texture</strong> function then samples the color value using the texture parameters we set earlier.  The result of this fragment shader is the (filtered) texture color at the (interpolated) texture coordinate. </p><br><p>  It remains only to bind the texture before calling <strong>glDrawElements</strong> and it will automatically be transferred to the fragment shader sampler: </p><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, texture); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">6</span></span>, GL_UNSIGNED_INT, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  If you did everything right then you will get the following image: </p><br><p><img src="https://habrastorage.org/files/275/b54/4b0/275b544b05c94327803300d57adf3bfe.png" alt="Result with one texture"></p><br><p>  If your quad is completely black or white, then you are wrong somewhere.  Check the shader logs and compare your code with the <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures">original one</a> . </p><br><p>  For a more colorful effect, we can mix the resulting color of the texture with the vertex color.  For blending, we simply multiply the colors in the fragment shader. </p><br><pre> <code class="hljs lisp">Color = texture(<span class="hljs-name"><span class="hljs-name">ourTexture</span></span>, TexCoord) * vec4(<span class="hljs-name"><span class="hljs-name">ourColor</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  You should have something like that? </p><br><p><img src="https://habrastorage.org/files/368/abb/fb3/368abbfb374545ebaea232ad6e9c2ed3.png" alt="Result with mixing"></p><br><h3 id="teksturnyy-blok">  Texture block </h3><br><p>  Perhaps you are wondering: ‚ÄúWhy is the <em>sampler2D</em> variable uniform if we never assigned any value to it using <em>glUniform</em> ?‚Äù.  With the help of <em>glUniform1i,</em> we can assign the value of the metaposition to the texture sampler so that we can use several textures in one fragment shader.  The location of the texture is often called the texture block.  The default texture block is 0, which means the current active texture block so that we do not need to specify a location in the previous section. </p><br><p>  The main purpose of texture units is to ensure that more than 1 texture can be used in our shader.  By passing the texture blocks to the sampler, we can snap several textures at a time as long as we activate the corresponding texture blocks.  Like <em>glBindTexture,</em> we can activate textures with <em>glActivateTexture by</em> passing the texture block we want to use there: </p><br><pre> <code class="cpp hljs">glActiveTexture(GL_TEXTURE0); <span class="hljs-comment"><span class="hljs-comment">//       glBindTexture(GL_TEXTURE_2D, texture);</span></span></code> </pre> <br><p>  After activating the texture unit, a subsequent call to <em>glBindTexture will</em> bind this texture to the active texture unit.  The <em>GL_TEXTURE0</em> block <em>is</em> always activated by default, so we did not need to activate the texture blocks in the last example. </p><br><blockquote>  OpenGL supports at least 16 texture units, which you can get through <strong>GL_TEXTURE0 <strong>-</strong> GL_TEXTURE15</strong> .  They are declared in order, so you can also get them as follows: <strong>GL_TEXTURE8 <strong>=</strong> GL_TEXTURE0</strong> + <strong>8</strong> .  This is useful if you have to iterate through texture units. </blockquote><p>  In any case, we still need to change the fragment shader to accept another sampler: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core ... <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D ourTexture1; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D ourTexture2; void main() { <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = mix(texture(ourTexture1, TexCoord), texture(ourTexture2, TexCoord), <span class="hljs-number"><span class="hljs-number">0.2</span></span>); }</code> </pre> <br><p>  The final result is a combination of two textures.  GLSL has a built-in <strong>mix</strong> function that takes two values ‚Äã‚Äãas input and interpolates them based on the third value.  If the third value is <strong>0.0,</strong> then this function will return the first argument, if <strong>1.0,</strong> then the second one.  A value of <strong>0.2</strong> will return 80% of the first input color and 20% of the second input color. </p><br><p>  Now we need to load and create another texture;  You are already familiar with the following steps.  Make sure you create another texture object, load the image, and generate the final texture using <strong>glTexImage2D</strong> .  For the second texture, we use the <a href="">face image while learning these lessons</a> . </p><br><p>  In order to use the second texture (and the first one) we will need to slightly modify the drawing procedure, linking both textures to the corresponding texture units and indicating to which sampler which texture unit belongs: </p><br><pre> <code class="cpp hljs">glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glUniform1i(glGetUniformLocation(ourShader.Program, <span class="hljs-string"><span class="hljs-string">"ourTexture1"</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); glUniform1i(glGetUniformLocation(ourShader.Program, <span class="hljs-string"><span class="hljs-string">"ourTexture2"</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">6</span></span>, GL_UNSIGNED_INT, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Notice that <strong>glUniform1i was</strong> used to set the position of the texture unit in a uniform sampler.  Installing them through <strong>glUniform1i</strong> we will be sure that the uniform sampler corresponds with the correct texture unit.  As a result, you will need to get the following result: </p><br><p><img src="https://habrastorage.org/files/c27/c25/298/c27c25298615478e9d94ee165c4de231.png" alt="Result with mixing"></p><br><p>  You probably noticed that the texture is turned upside down!  ,  OpenGL   0.0   Y  ,      0.0    Y.     ,  <a href="http://openil.sourceforge.net/tuts/tut_10/index.htm">Devil</a>     Y    . SOIL   .  SOIL   <strong>SOIL_load_OGL_texture</strong> ,    <strong></strong>     <em>SOIL_FLAG_INVERT_Y</em> ,    .       ,     OpenGL,       <strong>SOIL_load_image</strong>    . </p><br><p>         2 : </p><br><ol><li>           Y  ( Y   1) </li><li>        Y ,    TexCoord  <strong>TexCoord = vec2(texCoord.x, 1.0f ‚Äî texCoord.y);.</strong>  . </li></ol><br><blockquote>   ‚Äî   ,    .      ,           ,      ‚Äî      ,    ,  OpenGL. </blockquote><p>         Y        : </p><br><p><img src="https://habrastorage.org/files/cb1/3d8/052/cb13d80527364973a868eca73236f2f1.png" alt="Inverted mixing result"></p><br><p>     ,     .       <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures_combined"></a> ,   <a href="http://learnopengl.com/code_viewer.php%3Ftype%3Dvertex%26amp%3Bcode%3Dgetting-started/texture"></a>  <a href="http://learnopengl.com/code_viewer.php%3Ftype%3Dfragment%26amp%3Bcode%3Dgetting-started/texture"></a> . </p><br><h3 id="uprazhneniya">  Exercises </h3><br><p>              . </p><br><ol><li>  ,  <strong></strong>    ,     . <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures-exercise1"></a> </li><li>      ,       <strong>0.0f</strong>  <strong>2.0f</strong>  <strong>0.0f</strong>  <strong>1.0f</strong> . ,     4     . <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures-exercise2"></a> , <a href=""></a> </li><li>         ,         .     <em>GL_NEAREST</em>  ,      .  <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures-exercise3">The decision</a> . </li><li>  uniform    3   <strong>mix</strong>        .        . <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures-exercise4"></a> , <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/textures-exercise4_fragment"> </a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/315294/">https://habr.com/ru/post/315294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315280/index.html">Co-iterators on timers</a></li>
<li><a href="../315282/index.html">Configure the Sharepoint Application Environment (SharePoint Add-ins)</a></li>
<li><a href="../315284/index.html">Pepelats with Gravizapa - as I searched (and even found) CRM for a medical center</a></li>
<li><a href="../315286/index.html">Why and how to transfer corporate email security to the cloud. Part 2</a></li>
<li><a href="../315288/index.html">The new version of business process management solution JBoss BPM Suite will increase the role of using microservices</a></li>
<li><a href="../315298/index.html">Hammer on the office, work remotely</a></li>
<li><a href="../315300/index.html">How we translated server to php 7</a></li>
<li><a href="../315302/index.html">Email Services Digest: Featured Email Products and Podcasts by Product Hunt</a></li>
<li><a href="../315304/index.html">How to create an informative, but convenient corporate site?</a></li>
<li><a href="../315306/index.html">Mobio Talks with Irina Shashkina, CEO of Lingualeo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>