<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mirages of the future</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In early 2008, with the filing of the State Duma deputies, a discussion arose on the Internet about the need to create a national OS. An initiative gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mirages of the future</h1><div class="post__text post__text-html js-mediator-article">  <i>In early 2008, with the filing of the State Duma deputies, a discussion arose on the Internet about the need to create a national OS.</i>  <i>An initiative group emerged under the leadership of Ruslan Bogatyrev (all delphists should remember him, he wrote a lot about Pascal), for designing the Russian OS Rosa.</i>  <i>I exchanged several letters with Ruslan, where I tried to express some of my thoughts.</i>  <i>Unfortunately, the project stalled, as Ruslan explained due to internal organizational contradictions, and today I don‚Äôt know what his condition is, but I decided to try to resume the discussion by publishing a part of our correspondence.</i> <i><br></i> <br><a name="habracut"></a><br>  Ruslan in his <a href="http://rbogatyrev.livejournal.com/">blog</a> in post number 30 talked about the theory of metasystems Turchin.  It seems to me that it can serve as an excellent tool in the design and OS and programming languages.  As I understand it, one of its key points is the concept of a metasystem transition that occurs during a qualitative jump in the complexity level of a certain system.  It is then possible to consider the evolution of computers, OS and programming languages ‚Äã‚Äãin terms of the presence of such meta-transitions. <br>  For clarity, we will draw the analogy of computer systems with living ones, especially since many people use this analogy, and the creation of programs is more similar to animal breeding than designing a car.  Then the available hardware resources of the computer will represent, say, the primary bio-broth, in which the life of programs originates.  The first programs in machine codes and assembler will act as the first single-celled organisms.  Their capabilities are limited to the product of elementary computational operations and the manipulation of memory cells, i.e.  "Unicellular" take from the environment "amino acids", etc. <br><br>  With the increasing complexity of such "single-celled" the first meta-transition occurs.  Programs start writing in high-level languages, i.e.  tools that hide many elementary operations under the shell of language constructs.  This is the emergence of "multicellular organisms".  The equipment begins to abstract away from the operating systems.  Those.  The ‚Äúnutrient medium‚Äù for programs is also complicated; these are no longer direct CPU commands or operations with memory cells, but requests to the OS for allocating memory or producing trigonometric calculations.  So, the first meta-transition is the emergence of imperative languages ‚Äã‚Äãand operating systems that hide the small details of the hardware device, but still require an accurate and detailed description of the actions performed.  Those.  even though languages ‚Äã‚Äãhave become more complicated, they still require operating with ‚Äúsmall‚Äù entities like memory areas. <br><br>  Why I highlight only imperative languages.  In my opinion, the emergence of functional and logical programming is a new meta-transition in the language level.  In functional languages, the program operates not so much with memory areas and computational operations as with system states and actions to change it.  And in logical languages, ‚Äúhiding‚Äù and computing are hidden from us.  Those.  In my opinion, as a result of the meta-transition, the functional languages ‚Äã‚Äãshould have changed the imperative ones, and in turn they would have been replaced by logical ones.  But a meta-transition is possible only when the entire system is ready for it, and the hardware capabilities and organization of the OS are not ready for this. <br>  As in any complex system, different levels of control are distinguished in programming, leading to different meta-transitions.  If functional and logical methods can be viewed as a meta-transition in the organization of the process of the program, then the emergence of structured programming was a meta-transition in the organization of subsystems and their interaction.  Modular and object programming is the next transition in the organization of subsystems.  Moreover, from this point of view, they are almost equivalent.  Although it may be possible to take the object approach as another meta-transition, since  He added a new mechanism for increasing the complexity of subsystems - inheritance.  But here the question is complicated by the fact that although inheritance allows you to increase the multi-level system, to organize more subsystems, it does not add a new level of control to the emerging subsystems.  That is, roughly speaking, at the program level, the ‚ÄúEntity. Method ()‚Äù construction does not change, and we don‚Äôt have any difference what is hidden under this entity - a module, parent object or descendant. <br>  Rather, not inheritance, but polymorphism, can claim the role of a meta-transition.  It allows you to simplify the management of the program, because  allows you to reduce the number of structures that perform dispatching calls to specific methods.  Moreover, if we take into account the internal construction of polymorphism, the most suitable for this is exactly the dynamic polymorphism in the SmallTalk style.  It is appropriate to mention here an interesting variant proposed by Dr. Professor A.I.  Legalov from the Siberian Federal University (I saw this idea from him).  He proposed to build polymorphism not on the object, but on the method.  That is, in its variant, the ‚ÄúMethod. Essence ()‚Äù structure was obtained. <br>  Why does this approach seem more promising to me?  The number of possible entities can be unlimitedly large.  Our imagination to create various software objects is limited only by our ability to keep such a system under control.  And the introduction of new entities into the system, if they do not fit into the inheritance and do not undergo a typical control, will require the addition of new control structures.  The number of reasonable actions on objects is much smaller and having developed a certain control scheme, it can be applied to all entities existing and newly created. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we digress for a while from our organism-programs and return to the environment of the OS.  Having organized the primary broth of amino acids from memory cells and processor resources into a kind of vegetation in the form of API sets, the operating systems lingered at this level for a long time.  The only significant meta-transition can only be called the emergence of UNIX-like unification of the representation of all resources as files and the reduction of many operating system actions to read-write operations.  It was the presence of such a meta-transition in the management of computer resources that stimulated the popularity of the UNIX model.  And it is precisely the absence of qualitative differences in organization and management that does not allow us to speak about the advantages of Linux over Windows, these are systems of the same type. <br><br>  However, the development of an object model in programming languages ‚Äã‚Äãshould have led to a new meta-transition in the OS representing its services as a set of objects.  It is the need for such a transition to align the level of organization of programming languages ‚Äã‚Äãand organization of the OS, led to the emergence of projects such as Apple's OpenDoc architecture or the BeOS system.  In fact, the success of the Java and .NET platforms is due precisely to the presence of a qualitative leap in an organization representing all the resources of the environment as a set of high-level objects.  Those.  we can say that the fauna of objects appeared in the API flora.  An interesting picture came out, ‚Äúprograms-organisms‚Äù (complex organisms created in OO-languages, ie, consisting of complex subsystems of the ‚Äúbrain‚Äù, ‚Äústomach‚Äù, ‚Äúlimbs‚Äù, etc.) try to survive and function among other organisms. other OS programs and resources.  Fauna in all its glory and diversity. <br><br>  Let's make one more "parallel" view.  If in the management of the complexity of programming languages ‚Äã‚Äãand the OS device meta-transitions were carried out, then in the struggle with the quantitative side, i.e.  with the number of documents, programs, source versions, etc., there was only one general meta-transition the invention of a hierarchical file system.  Unfortunately, programs like version control systems have not gone beyond a narrow circle of professionals.  And Microsoft‚Äôs attempts to create a database-based storage system are glimpses of the meta-transition in managing the number of information units. <br><br>  And so, what do we do? <br>  Here we have identified meta transitions: <br><ul><li>  Languages ‚Äã‚Äã(computer operation control): imperative functional logical. </li><li>  Languages ‚Äã‚Äã(program complexity management): structured module-object programming. </li><li>  OS: API sets of objects. </li></ul><br><br>  And now, let me insolence to formulate such a theorem: <br>  <b>The success of the new system is possible only if there is a new meta-transition in it compared to the old system!</b> <br><br>  But at the expense of what qualities such a transition will be made, it requires additional and lengthy reflection ... <br><br>  Returning again to the theory of Turchin, we recall that the meta-transition is characterized by a simplification of control in a complicated system.  To some extent, this echoes Stafford Beer‚Äôs ideas about the organization of a cybernetic system in which each previous level serves to extract only key parameters from the total data flow in order to reduce the information load to the next level.  That is, the main stimulus of development is the struggle with complexity!  A meta-transition is a successful decision in this struggle.  So, to define development goals, it is necessary to single out the levels of complexity that need to be simplified in order to obtain a new quality of the system being developed. <br><br>  Based on these considerations, let me dare to formulate the following theses. <br><br>  <b>OS complexity (core):</b> <br><br><ol><li>  Abstraction from the hardware platform to simplify the transfer to different equipment. </li><li>  Efficient allocation and use of available resources (memory, processor time, etc.).  Perhaps in the conditions of dynamic change of these resources. </li><li>  Organization of the implementation and interaction processes.  Parallel work on one processor or parallelization on several.  The interaction of parallel operating equipment.  Distribution of processes on network nodes. </li><li>  The organization of shared libraries. </li><li>  Version control of used libraries.  Perhaps sharing libraries of different versions. </li><li>  Dynamic reloading of working modules. </li><li>  Processing software and hardware errors. </li><li>  Providing the minimum required set of application interfaces that fits into a single use paradigm (as for example made in OS Plan 9). </li></ol><br><br>  <b>The complexity of the programming language:</b> <br><br><ol><li> Organization of calculations.  These include expressions, flow control, parallel execution, exception handling, etc.  Those.  exclusively ‚Äúcounting‚Äù aspects of work.  This also includes typing, as a means to make it easier to get more code optimized for the platform. </li><li>  Code reuse from the point of view of definition (i.e., how such a code is drawn up in the program).  These are functions and procedures, modules and objects, inheritance, patterns, namespaces, etc.  As well as typing, as a tool for ensuring interface consistency.  Those.  all the mechanisms that allow, instead of repeated repetition of the same instructions in different places of the program, put them in one place and write them down once. </li><li>  Code reuse, from the point of view of implementation (i.e. run-time mechanisms for calling such a code).  Here, a procedure call, a message transfer and, on the other hand, data transfer to such a code (that is, transfer of actual parameters to a procedure or transfer of data to another process, possibly running on another node).  And also - polymorphism, as a mechanism for applying a single algorithm to different data. </li><li>  Description of the types and data structures used.  On the one hand, it is the "structuring" of memory.  And on the other - the implementation of effective access mechanisms, ideally - uniform, i.e.  ensuring polymorphism of work with data. </li></ol><br><br>  <b>OS complexity (user interface):</b> <br><br><ol><li>  Model storage organization.  It was one of the first tasks solved by the OS.  First of all, these are file systems in the perspective of moving to a kind of DBMS. </li><li>  Not solved at all in modern OSs, but in my opinion a very topical problem of multi-versioning of user data and tracking the history and interrelation of their changes.  For example, integration into the OS systems of the type "life line". </li><li>  Mechanisms of user interaction with the OS.  From command line to graphical interfaces.  If we consider this aspect within the framework of the ‚ÄúModel - View - Controller‚Äù paradigm, then all ‚Äúout-streams‚Äù are ‚Äúview‚Äù, and all ‚Äúin-streams‚Äù are ‚Äúcontroller‚Äù.  Ideally, the OS should adapt the program itself for the ‚Äúview - controller‚Äù combination used, i.e.  the same program can work in a text terminal, on a full-size PC monitor or on a smartphone display. </li></ol><br><br>  Uh, so here in the first approximation ... It may even be that I missed something, but here it is difficult to do without a glance from the outside. <br>  Maybe someone raised the questions are interesting and he wants to continue the discussion? </div><p>Source: <a href="https://habr.com/ru/post/83407/">https://habr.com/ru/post/83407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../83398/index.html">Yulia Tymoshenko‚Äôs website has been hacked</a></li>
<li><a href="../83399/index.html">GNU is Now Ubuntu</a></li>
<li><a href="../83402/index.html">JHtmlArea visual editor</a></li>
<li><a href="../83403/index.html">Finishing Emacs for netbooks</a></li>
<li><a href="../83405/index.html">Did you know</a></li>
<li><a href="../83408/index.html">Magazine PC Magazine / Russian Edition Fights Wikipedia</a></li>
<li><a href="../83410/index.html">Swype - interesting keyboard for Android</a></li>
<li><a href="../83412/index.html">LEC - A new generation of light panels from Swiss developers</a></li>
<li><a href="../83418/index.html">Dropbox - the simplest minihosting sites</a></li>
<li><a href="../83419/index.html">February 9 - ‚Äú1C-Bitrix: Corporate portal - effective management of communications and business processes‚Äù, free Softin webinar and 1C-Bitrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>