<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inter-Process Object Replication with QtRemoteObjects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On October 7, 2014, the Qt-module QtRemoteObjects sources appeared in public access. The module was created in the depths of the Ford Motor Company (b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inter-Process Object Replication with QtRemoteObjects</h1><div class="post__text post__text-html js-mediator-article">  On October 7, 2014, the Qt-module <a href="https://qt.gitorious.org/qtplayground/qtremoteobjects/commit/ec68d2724872c4e3c0b63e0ac12a369e639088de">QtRemoteObjects</a> sources appeared in public access.  The module was created in the depths of the Ford Motor Company (by Brett Stottlemyer).  The thing, in my opinion, is very promising.  The module allows, for example, to transmit signals between objects over the network.  But this module is not limited to.  More precisely, the essence of the module is described by its previous name, Replica, since objects are ‚Äúreplicated‚Äù between processes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/76b/37f/a80/76b37fa80fd24d8a85996514ccdef8f5.png"></div><br><br>  The key idea of ‚Äã‚ÄãQtRemoteObjects, which qualitatively distinguishes it from other methods of interprocess communication / remote procedure call, is the idea to completely duplicate the Qt-object to other processes.  This means that all changes of properties (properties) in an object - source are reflected (with notification by signals) in a replica object.  Any signals emitted by the source object will also be emitted at each replica object.  You can also set properties, call slots in a replica object, whereby requests are sent to the source object that processes them and then changes are reflected in other replica objects by means of signals or by changing properties.  As a result, all objects (including the source object) are synchronized.  At the same time, the complexity of interprocess communication is hidden inside QtRemoteObjects. <br><a name="habracut"></a><br><h4>  Assembly and installation of the module </h4><br><h5>  1. Install private header files for your <b>Qt 5</b> version </h5><br>  On your system, performed by installing the package <i>qtbase5-private-dev</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  2. Get the source of the module </h5><br>  git clone <a href="">gitorious.org/qtplayground/qtremoteobjects.git</a> <br><br><h5>  3. Assemble and install the module </h5><br>  Collected the project in QtCreator, using shadow assembly.  As a result, all the necessary files appeared in the build-qtremoteobjects-qt5_3_0-Release directory.  If you then perform make install in this directory, then the module header files, library and code generator for the rep files will be installed in the corresponding directories.  The only thing that was not installed is the contents of the qtremoteobjects / mkspecs / features directory, it needs to be copied to the / usr / lib / x86_64-linux-gnu / qt5 / mkspecs / features directory. <br><br>  If there are problems with make install, you can do everything ‚Äúmanually‚Äù: copy the library libQt5RemoteObjects.so (dll) to the Qt library directory and the / include / QtRemoteObjects directory to the Qt directory, respectively.  Also, in ‚Äúmanual‚Äù mode, you will need to copy the binary from the bin / repc build directory to the Qt binary directory (in my case, this is / usr / lib / x86_64-linux-gnu / qt5 / bin / repc). <br><br><h4>  Use of the module </h4><br>  The presence of the object - the source and the object - the replica evokes the idea of ‚Äã‚Äãa client-server architecture.  Therefore, to demonstrate the operation of the module, we will create two projects - the client and the server.  The source object on the server will emit a signal, in the parameters of which the text will be transmitted, and in the slot of the client connected to the signal of the replica object, the transmitted text will be processed. <br>  The example is very simple, but with this example it will be easier to show the operation of the module.  Two pictures of the resulting applications and further code. <br><br>  <b>Server</b> <br><img src="https://habrastorage.org/files/533/0dc/f2a/5330dcf2a1cd4a0b8e944bb03a5a9f48.png"><br>  <b>Customer</b> <br><img src="https://habrastorage.org/files/3ce/b6f/8a5/3ceb6f8a5c434a969b9cb6d1f46c06ad.png"><br><br><h5>  Client and server projects </h5><br>  We will have one common directory (for example remoteobj) and 2 subdirectories: client and server, in which projects of two applications will be located.  In the project files of both applications you need to connect the module. <br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">QT</span></span> += remoteobjects</code> </pre> <br><h5>  .Rep files </h5><br>  Files with the .rep extension are used to describe the interface of the object that will be used for interprocess communication.  In the directory that is parent of the client and server projects directory, create a text file MessageSender.rep with the following contents: <br><pre> <code class="hljs kotlin">#include &lt;QtCore&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageSender</span></span></span><span class="hljs-class"> </span></span>{ SIGNAL(sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;message)); };</code> </pre> <br>  Remember I wrote about the files from the directory mkspecs / features?  It is in these files that the described ones are described for processing rep files.  In order for them to be processed during assembly, the following lines must be added to the project files: <br>  for client <br><pre> <code class="hljs lua">REPC_REPLICA += ../MessageSender.<span class="hljs-built_in"><span class="hljs-built_in">rep</span></span></code> </pre>  for server <br><pre> <code class="hljs lua">REPC_SOURCE += ../MessageSender.<span class="hljs-built_in"><span class="hljs-built_in">rep</span></span></code> </pre> <br>  During the build from the file MessageSender.rep will be generated header files <br><div class="spoiler">  <b class="spoiler_title">for client - rep_MessageSender_replica.h</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifndef</span></span> <span class="hljs-type"><span class="hljs-type">REP_MESSAGESENDER_REPLICA_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">REP_MESSAGESENDER_REPLICA_H</span></span> // <span class="hljs-type"><span class="hljs-type">This</span></span> is an autogenerated file. // <span class="hljs-type"><span class="hljs-type">Do</span></span> not edit this file, any changes made will be lost the next time it is generated. <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QObject</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QVariantList</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QMetaProperty</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QRemoteObjectNode</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QRemoteObjectReplica</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QRemoteObjectPendingReply</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtCore</span></span>&gt; class <span class="hljs-type"><span class="hljs-type">MessageSenderReplica</span></span> : public <span class="hljs-type"><span class="hljs-type">QRemoteObjectReplica</span></span> { <span class="hljs-type"><span class="hljs-type">Q_OBJECT</span></span> <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-type"><span class="hljs-type">QCLASSINFO_REMOTEOBJECT_TYPE</span></span>, <span class="hljs-comment"><span class="hljs-comment">"MessageSender"</span></span>) friend class <span class="hljs-type"><span class="hljs-type">QRemoteObjectNode</span></span>; private: <span class="hljs-type"><span class="hljs-type">MessageSenderReplica</span></span>() : <span class="hljs-type"><span class="hljs-type">QRemoteObjectReplica</span></span>() {} void initialize() { <span class="hljs-type"><span class="hljs-type">QVariantList</span></span> properties; properties.reserve(<span class="hljs-number"><span class="hljs-number">0</span></span>); setProperties(properties); } public: virtual ~<span class="hljs-type"><span class="hljs-type">MessageSenderReplica</span></span>() {} <span class="hljs-type"><span class="hljs-type">Q_SIGNALS</span></span>: void sendMessage(const <span class="hljs-type"><span class="hljs-type">QString</span></span> &amp; message); }; <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> // <span class="hljs-type"><span class="hljs-type">REP_MESSAGESENDER_REPLICA_H</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">for the server - rep_MessageSender_source.h</b> <div class="spoiler_text"><pre> <code class="hljs lua">#ifndef REP_MESSAGESENDER_SOURCE_H #define REP_MESSAGESENDER_SOURCE_H // This is an autogenerated file. // Do <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> edit this file, any changes made will be lost the <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> it is generated. #include &lt;QObject&gt; #include &lt;QVariantList&gt; #include &lt;QMetaProperty&gt; #include &lt;QRemoteObjectNode&gt; #include &lt;qremoteobjectsource.h&gt; #include &lt;QtCore&gt; class MessageSenderSource : public QObject { Q_OBJECT Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, <span class="hljs-string"><span class="hljs-string">"MessageSender"</span></span>) friend class QRemoteObjectNode; public: MessageSenderSource(QObject *parent = Q_NULLPTR) : QObject(parent) { } public: virtual ~MessageSenderSource() {} Q_SIGNALS: void sendMessage(const QString &amp; message); }; class MessageSenderSimpleSource : public QObject { Q_OBJECT Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, <span class="hljs-string"><span class="hljs-string">"MessageSender"</span></span>) friend class QRemoteObjectNode; public: MessageSenderSimpleSource(QObject *parent = Q_NULLPTR) : QObject(parent) { } public: virtual ~MessageSenderSimpleSource() {} Q_SIGNALS: void sendMessage(const QString &amp; message); }; template &lt;class ObjectType&gt; struct MessageSenderSourceAPI : public SourceApiMap { MessageSenderSourceAPI() { _properties[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; _signals[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; _signals[<span class="hljs-number"><span class="hljs-number">1</span></span>] = qtro_signal_index&lt;ObjectType&gt;(&amp;ObjectType::sendMessage, static_cast&lt;void (QObject::*)(QString)&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>),signalArgCount+<span class="hljs-number"><span class="hljs-number">0</span></span>,signalArgTypes[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _methods[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } QString name() const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QStringLiteral(<span class="hljs-string"><span class="hljs-string">"MessageSender"</span></span>); } int propertyCount() const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _properties[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } int signalCount() const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _signals[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } int methodCount() const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _methods[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } int sourcePropertyIndex(int index) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _properties[index+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } int sourceSignalIndex(int index) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _signals[index+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } int sourceMethodIndex(int index) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _methods[index+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } int signalParameterCount(int index) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signalArgCount[index]; } int signalParameterType(int sigIndex, int paramIndex) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signalArgTypes[sigIndex][paramIndex]; } int methodParameterCount(int index) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methodArgCount[index]; } int methodParameterType(int methodIndex, int paramIndex) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methodArgTypes[methodIndex][paramIndex]; } int propertyIndexFromSignal(int index) const Q_DECL_OVERRIDE { Q_UNUSED(index); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } const QByteArray signalSignature(int index) const Q_DECL_OVERRIDE { switch (index) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QByteArrayLiteral(<span class="hljs-string"><span class="hljs-string">"sendMessage(QString)"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QByteArrayLiteral(<span class="hljs-string"><span class="hljs-string">""</span></span>); } const QByteArray methodSignature(int index) const Q_DECL_OVERRIDE { Q_UNUSED(index); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QByteArrayLiteral(<span class="hljs-string"><span class="hljs-string">""</span></span>); } QMetaMethod::MethodType methodType(int) const Q_DECL_OVERRIDE { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QMetaMethod::Slot; } const QByteArray typeName(int index) const Q_DECL_OVERRIDE { Q_UNUSED(index); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QByteArrayLiteral(<span class="hljs-string"><span class="hljs-string">""</span></span>); } int _properties[<span class="hljs-number"><span class="hljs-number">1</span></span>]; int _signals[<span class="hljs-number"><span class="hljs-number">2</span></span>]; int _methods[<span class="hljs-number"><span class="hljs-number">1</span></span>]; int signalArgCount[<span class="hljs-number"><span class="hljs-number">1</span></span>]; const int* signalArgTypes[<span class="hljs-number"><span class="hljs-number">1</span></span>]; int methodArgCount[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const int* methodArgTypes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; #endif // REP_MESSAGESENDER_SOURCE_H</code> </pre><br></div></div><br><br>  These files must be included in the header files of the client and server - according to their belonging. <br><br><h5>  Customer </h5><br>  First we will analyze the client, as it is simpler than the server. <br>  You need to add a member of the client class: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">QRemoteObjectNode</span></span> clientNode;</code> </pre> <br>  And then in the initializing function (or directly in the constructor) we write: <br><pre> <code class="hljs ruby">clientNode = QRemoteObjectNode::createNodeConnectedToRegistry(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  QRemoteObjectReplica *sender = m_client.acquire&lt; MessageSenderReplica &gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    connect(sender, SIGNAL(sendMessage(const QString &amp;)), this, SLOT(appendMessage(const QString &amp;))); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   </code> </pre><br>  In the appendMessage slot, the resulting string is simply added to the list and therefore I‚Äôll skip its description and go to the client‚Äôs description. <br><br><h5>  Server </h5><br>  Since only the interface is in the generated header files, in order to do useful work with our source object, you need to add functionality to it.  To do this, we inherit from the generated class and define the slot: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageSender</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MessageSenderSource { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;message)</span></span></span></span>; };</code> </pre> <br>  The implementation of this slot will simply emit a signal. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessageSender::postMessage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;message) { <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span></span>; }</code> </pre> <br><br>  Now add the following server class members: <br><pre> <code class="hljs ruby">MessageSender *serverSender; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   QRemoteObjectNode registryHostNode; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  QRemoteObjectNode objectNode; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre><br><br>  And in the initializing function (or directly in the constructor) we write: <br><pre> <code class="hljs lisp">connect(<span class="hljs-name"><span class="hljs-name">ui-&gt;sendButton</span></span>, SIGNAL(<span class="hljs-name"><span class="hljs-name">clicked</span></span>()), this, SLOT(<span class="hljs-name"><span class="hljs-name">startSendMessage</span></span>()))<span class="hljs-comment"><span class="hljs-comment">; //  registryHostNode = QRemoteObjectNode::createRegistryHostNode(); //   objectNode = QRemoteObjectNode::createHostNodeConnectedToRegistry(); //   serverSender = new MessageSender(); // - objectNode.enableRemoting(serverSender);//   </span></span></code> </pre><br><br>  In the startSendMessage () slot, the source object slot will be called: <br><pre> <code class="hljs erlang-repl">QString messageText = ui-&gt;messageTextEdit-&gt;text(); serverSender-&gt;postMessage(messageText);</code> </pre><br><br>  Now we run the applications: first the server and then the client. <br><br><h5>  Networking </h5><br>  In this example, interprocess communication within a single host has been described.  When creating nodes without parameters, it is considered that the interaction is local. <br><br>  For networking, you need to modify the node creation code. <br>  server side <br><pre> <code class="hljs ruby">objectNode = QRemoteObjectNode::createHostNode(QUrl(<span class="hljs-string"><span class="hljs-string">"tcp://localhost:9999"</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//registry</span></span>HostNode  </code> </pre><br>  client side <br><pre> <code class="hljs pgsql">clientNode = QRemoteObjectNode(); clientNode.<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(QUrl("tcp://localhost:9999"));</code> </pre><br><br><h5>  Instead of conclusion </h5><br>  The article does not cover the use of properties.  An example of using properties and slots (which are also described in the rep file) can be seen in the examples that come with the module. <br><br>  <a href="">Link to the archive with the source server and client.</a> <br>  <a href="http://www.qtdeveloperdays.com/sites/default/files/north-america/Kalle-Lightning-talk-QtRemoteObjectsUS.pptx.pdf">Presentation with Qt Developers Days 2014 North America</a> </div><p>Source: <a href="https://habr.com/ru/post/216939/">https://habr.com/ru/post/216939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216921/index.html">Dell Desktop Virtualization Forum 2014. Program and start registration</a></li>
<li><a href="../216923/index.html">Introduction to Behavior Programming (BDD)</a></li>
<li><a href="../216925/index.html">Microsoft and Nokia postponed closing the deal until April</a></li>
<li><a href="../216931/index.html">Turkey has blocked Google DNS</a></li>
<li><a href="../216937/index.html">How-to: how to choose a programming language to create a trading robot</a></li>
<li><a href="../216941/index.html">FireChat: First Mesh Messenger</a></li>
<li><a href="../216943/index.html">How we did the island of the Mistress of Copper Mountain</a></li>
<li><a href="../216949/index.html">MS Word vulnerability is exploited in-the-wild</a></li>
<li><a href="../216953/index.html">New CEO Mozilla has become the creator of JavaScript Brendan Ike</a></li>
<li><a href="../216955/index.html">Use traits with benefits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>