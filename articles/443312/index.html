<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python memory management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! That ended the long March weekend. We want to devote the first post-holiday publication to our favorite, many courses - ‚ÄúPython Developer‚Äù , wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python memory management</h1><div class="post__text post__text-html js-mediator-article">  Hello!  That ended the long March weekend.  We want to devote the first post-holiday publication to our favorite, many courses - <a href="https://otus.pw/PJTW/">‚ÄúPython Developer‚Äù</a> , which starts in less than 2 weeks.  Go. <br><br>  <b>Content</b> <br><br><ol><li>  Memory is an empty book </li><li>  Memory management: from hardware to software </li><li>  Basic Python implementation </li><li>  Global Interpreter Lock (GIL) concept </li><li>  Garbage collector </li><li>  CPython memory management: <br><ul><li>  Pula </li><li>  Blocks </li><li>  Arenas </li></ul></li><li>  Conclusion </li></ol><br><img src="https://habrastorage.org/webt/ww/vn/wj/wwvnwjqala4vtezc2ei4dx4ml_w.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Have you ever wondered how Python behind the scenes processes your data?  How are your variables stored in memory?  At what point are they removed? <br>  In this article, we delve into the internal structure of Python to understand how memory management happens. <br><br>  After reading this article, you: <br><br><ul><li>  Learn more about low-level operations, especially memory. </li><li>  Understand how Python abstracts low-level operations. </li><li>  Learn about memory management algorithms in Python. </li></ul><br>  Knowledge of the internal device Python will give a better understanding of the principles of its behavior.  I hope you can take a look at Python from a new perspective.  Behind the scenes, a great many logical operations take place so that your program works properly. <a name="habracut"></a><br><br>  <b>Memory is an empty book</b> <br><br>  You can think of a computer's memory as an empty book, waiting for many short stories to be written into it.  On its pages there is nothing yet, but soon there will be authors who will want to write down their stories in it.  For this they need a place. <br>  Since they cannot write one story over another, they need to be very careful about the pages on which they write.  Before you start writing, they consult with the book manager.  The manager decides where in the book the authors can write down their history. <br><br>  Since the book has been around for many years, many stories in it become obsolete.  When no one reads or refers to a story, it is deleted so that it makes room for new stories. <br>  At its core, computer memory is like an empty book.  Continuous fixed-length memory blocks are usually called pages, so this analogy comes in handy. <br><br>  Authors may be various applications or processes that need to store data in memory.  The manager, who decides where authors can write their stories, plays the role of a memory manager - a sorter.  And the one who erases old stories is a garbage collector. <br><br>  <b>Memory management: from hardware to software</b> <br><br>  Memory management is the process by which software applications read and write data.  The memory manager determines where to put these programs.  Since the amount of memory is of course, as is the number of pages in the book, respectively, the manager needs to find free space in order to give it to the use of the application.  This process is called ‚Äúmemory allocation‚Äù. <br><br>  On the other hand, when data is no longer needed, it can be deleted.  In this case, talking about the release of memory.  But what is it free from and where does it come from? <br>  Somewhere inside the computer there is a physical device that stores data when you run Python programs.  Python code goes through many levels of abstraction before it reaches this device. <br><br>  One of the main levels lying above the hardware (RAM, hard disk, etc.) is the operating system.  It manages requests to read and write to memory. <br>  There is an application layer above the operating system, which has one of the implementations of Python (wired into your OS or downloaded from python.org).  Memory management for code in this programming language is governed by special Python tools.  The algorithms and structures that Python uses to manage memory are the main topic of this article. <br><br>  <b>Basic Python implementation</b> <br><br>  The basic Python implementation, or ‚Äúpure Python‚Äù, is CPython, written in C. <br>  I was very surprised when I first heard about it.  How can one language be written in another language ?!  Well, not literally, of course, but the idea is something like this. <br><br>  The Python language is described in a <a href="https://docs.python.org/3/reference/index.html">special reference manual in English</a> .  However, this guide alone is not very helpful.  You still need a tool to interpret code written according to the rules of the directory. <br><br>  And you will need something to run the code on your computer.  A basic Python implementation ensures that both conditions are met.  It converts Python code into instructions that are executed on a virtual machine. <br><br><blockquote>  Note: Virtual machines are like physical computers, but they are built into the software.  They handle basic instructions similar to <a href="https://en.wikipedia.org/wiki/Assembly_language">assembly code</a> . </blockquote><br><br>  Python interpreted programming language.  Your Python code is compiled using instructions that are more easily understood by the computer - <a href="https://docs.python.org/3/glossary.html">bytecode</a> .  These instructions are interpreted by the virtual machine when you run the code. <br><br>  Have you ever seen files with the extension <i>.pyc</i> or folder <i>__ pycache__</i> ?  This is the same bytecode that is interpreted by the virtual machine. <br>  It is important to understand that there are other implementations besides CPython, for example <a href="http://ironpython.net/">IronPython</a> , which is compiled and run in the Microsoft Common Language Runtime (CLR).  <a href="http://www.jython.org/">Jython is</a> compiled into Java bytecode to run on a Java virtual machine.  And there is <a href="https://pypy.org/">PyPy</a> about which you can write a separate article, so I will mention it only in passing. <br><br>  In this article, we will focus on memory management using CPython tools. <br>  Warning: Python versions are updated and anything can happen in the future.  At the time of writing, the latest version was <a href="https://realpython.com/python37-new-features/">Python 3.7</a> . <br><br>  Well, we have CPython, written in C, which interprets Python bytecode.  How does this relate to memory management?  To begin with, the algorithms and structures for memory management exist in the CPython code, in C. To understand these principles in Python, you need a basic understanding of CPython. <br><br>  CPython is written in C, which in turn does not support object-oriented programming.  Because of this, the CPython code has a rather interesting structure. <br><br>  You must have heard that everything in Python is an object, even types such as int and str, for example.  This is true at the CPython implementation level.  There is a structure called PyObject that every object in CPython uses. <br><br>  Note: A structure in C is a user-defined data type, which in itself groups various data types.  You can draw an analogy with object-oriented languages ‚Äã‚Äãand say that a structure is a class with attributes, but without methods. <br><br>  PyObject is the progenitor of all objects in Python, containing just two things: <br><br><ul><li>  <b>ob_refcnt</b> : reference count; </li><li>  <b>ob_type</b> : pointer to another type. </li></ul><br>  Reference counting is required for garbage collection.  We also have a pointer to a specific type of object.  An object type is just another structure that describes objects in Python (such as dict or int). <br><br>  Each object has an object-oriented memory allocator that knows how to allocate memory and store an object.  Each object also has an object-oriented resource liberator, which clears the memory if its contents are no longer needed. <br><br>  There is one important factor in talking about memory allocation and cleansing.  Memory is a shared computer resource, and a rather unpleasant thing can happen if two processes try to write data to the same memory cell at the same time. <br><br>  <b>Global Interpreter Lock (GIL)</b> <br><br>  GIL is a solution to the general problem of sharing memory between such combined resources as computer memory.  When two streams try to change the same resource at the same time, they step on each other‚Äôs heels.  As a result, a complete mess is formed in memory and no process finishes its work with the desired result. <br><br>  Returning to the book analogy, suppose that of the two authors, each decides that he should write his own history on the current page at this particular moment.  Each of them ignores the attempts of the other to write a story and begins to write obstinately on the page.  As a result, we have two stories, one on top of the other, and an absolutely unreadable page. <br><br>  One of the solutions to this problem is GIL, which blocks the interpreter while the thread interacts with the selected resource, thus allowing one and only one thread to write to the allocated memory area.  When CPython allocates memory, it uses GIL to make sure it does it correctly. <br>  This approach has both a lot of advantages and a lot of disadvantages, so GIL causes fights in the Python community.  To learn more about GIL, I suggest reading the following <a href="https://realpython.com/python-gil/">article</a> . <br><br>  <b>Garbage collector</b> <br><br>  Let us return to our analogy with the book and imagine that some stories in it are hopelessly outdated.  Nobody reads them or addresses them.  In this case, the natural way out would be to get rid of them as unnecessary, thereby freeing up space for new stories. <br>  Such old, unused stories can be compared to objects in Python, whose reference count has dropped to 0. Remember that every object in Python has a reference count and a pointer to a type. <br><br>  The link count may increase for several reasons.  For example, it will increase if you assign one variable to another variable. <br><br><img src="https://habrastorage.org/webt/zv/me/dj/zvmedjrxhn3qqrac6tibjlrpnuu.png"><br><br>  It will also increase if you pass the object as an argument. <br><br><img src="https://habrastorage.org/webt/kq/np/pm/kqnppmeqfhl4pg6-4atqz_nnhhq.png"><br><br>  In the last example, the reference count will increase if you include an object in the list. <br><br><img src="https://habrastorage.org/webt/ql/ro/mj/qlromj2eg80jfhzykfkpzv8syfg.png"><br><br>  Python allows you to find out the current value of the reference count using the sys module.  You can use <code>sys.getrefcount(numbers)</code> , but remember that calling <code>getrefcount()</code> will increase the reference count by one. <br><br>  In any case, if an object is still needed in your code, its reference count value will be greater than 0. And when it drops to zero, a special memory cleaning function will be initiated that will free it and make it available to other objects. <br><br>  But what does ‚Äúfree up memory‚Äù mean and how do other objects use it?  Let's dive directly into memory management in CPython. <br><br>  <b>CPython memory management</b> <br><br>  In this part, we dive into the CPython memory architecture and the algorithms by which it functions. <br><br>  As mentioned earlier, there is such a thing as abstraction layers between physical equipment and CPython.  The operating system (OS) abstracts the physical memory and creates a virtual memory layer that applications can access, including Python. <br><br>  An OS-based virtual memory manager allocates a specific area of ‚Äã‚Äãmemory for Python processes.  In the picture, the dark gray areas are the space that the Python process occupies. <br><br><img src="https://habrastorage.org/webt/6k/-f/n6/6k-fn6hhelja1ilktfil1yzmaas.png"><br><br>  Python uses part of the memory for internal use and non-object memory (non-object memory).  The other part is divided into the storage of objects (your <i>int, dict</i> , etc.). Now I speak a very simple language, but you can look right ‚Äúunder the hood‚Äù, that is, in the <a href="">source code of CPython</a> and see how it all happens from a practical point of view. . <br><br>  In CPython, there is an object allocator responsible for allocating memory within an object memory area.  It is in this object distributor that all the magic is accomplished.  It is called every time when each new object needs to occupy or free memory. <br><br>  Usually, adding and deleting data in Python, such as int or list, for example, does not use a lot of data at one time.  That is why the architecture of the distributor focuses on working with small amounts of data in one unit of time.  Also, he does not allocate memory in advance, that is, until it becomes absolutely necessary. <br><br>  Comments in the source code define the allocator (allocator) as "a fast, special purpose memory allocator that works like the generic malloc function."  Accordingly, in C, malloc is used for memory allocation. <br><br>  Now let's take a look at the memory allocation strategy in CPython.  To begin, let's talk about the three main parts and how they relate to each other. <br><br>  Arenas (arena) - the largest areas of memory, which occupy space to the edges of pages in memory.  The page boundary (page spread) is the extreme point of the continuous block of fixed-length memory used by the OS.  Python sets the system page boundary to 256 KB. <br><br><img src="https://habrastorage.org/webt/cu/t2/ta/cut2ta8lwor00zy8h5k8ogjjhgy.png"><br><br>  Inside the arenas are pools (pool), which are considered one virtual memory page (4 Kb).  They are like pages in our analogy.  Pools are divided into even smaller pieces of memory - blocks. <br><br>  All blocks in the pool are in the same "size class".  Class size (size class) determines the size of the block, having a certain amount of requested data.  The gradation in the table below is taken directly from the comments in the source code: <br><br><img src="https://habrastorage.org/webt/n9/sk/55/n9sk55ex-esbcfdnnxhavivbeta.png"><br><br>  For example, if 42 bytes are needed, then the data will be placed in a block of 48 bytes in size. <br><br>  <b>Pula</b> <br><br>  Pools are made up of blocks of the same size class.  Each pool works on the principle of a doubly linked list with other pools of the same size class.  Therefore, the algorithm can easily find the necessary space for the required block size, even among multiple pools. <br><br>  The list of used pools ( <code>usedpools list</code> ) keeps track of all the pools that have some free space available for the data of each size class.  When the requested block size is requested, the algorithm checks the list of pools used to find a suitable pool for it. <br><br>  Pools are in three states: used, full, empty.  The used pool contains blocks in which you can write some information.  Full pool blocks are all distributed and already contain data.  Empty pools do not contain data and can be divided into which size classes are appropriate if needed. <br><br>  The list of empty pools ( <code>freepools list</code> ) contains, respectively, all pools in an empty state.  But at what point are they used? <br><br>  Let's say your code needs a memory area of ‚Äã‚Äã8 bytes.  If there are no pools with a size class of 8 bytes in the list of used pools, the new empty pool is initialized as storing blocks of 8 bytes each.  Then an empty pool is added to the list of used pools and can be used for the following requests. <br><br>  A filled pool frees up some blocks when this information is no longer needed.  This pool will be added to the list of used in accordance with its class size.  You can observe how pools change their states and even size classes according to an algorithm. <br><br>  <b>Blocks</b> <br><br><img src="https://habrastorage.org/webt/p4/y1/_v/p4y1_v_kaiwweb9eut_gl3boybg.png"><br><br>  As can be seen from the figure, pools contain pointers to free memory blocks.  In their work there is a small nuance.  According to the comments in the source code, the distributor "strive never to touch any memory area at any level (arena, pool, block) until it is needed." <br><br>  This means that a block can have three states.  They can be defined as follows: <br><br><ul><li>  <b>Intact</b> : areas of memory that were not allocated; </li><li>  <b>Free</b> : memory areas that were allocated, but later released by CPython, because they did not contain relevant information; </li><li>  <b>Distributed</b> : areas of memory that currently contain current information. </li></ul><br>  The freeblock pointer is a simply linked list of free blocks of memory.  In other words, this is a list of free places where information can be recorded.  If you need more memory than there is in the free blocks, then the distributor uses intact blocks in the pool. <br><br>  As soon as the memory manager releases blocks, these blocks are added to the top of the free block list.  The actual list may not contain a continuous sequence of blocks of memory, as in the first ‚Äúsuccessful‚Äù figure. <br><br><img src="https://habrastorage.org/webt/cj/7g/d-/cj7gd-xeci1k_d0qwexo8zarr5y.png"><br><br>  <b>Arenas</b> <br><br>  Arenas contain pools.  Arenas, in contrast to pools, do not have explicit state separations. <br><br>  They themselves are organized into a doubly linked list, which is called the list of used arenas (usable_arenas).  This list is sorted by the number of free pools.  The fewer free pools, the closer the arena to the top of the list. <br><br><img src="https://habrastorage.org/webt/4e/1f/fl/4e1ffl6eisaila8c1zxsmh3fc_m.png"><br><br>  This means that the most complete arena will be selected to record even more data.  But why exactly?  Why not write data to where the most free space is? <br><br>  This brings us to the idea of ‚Äã‚Äãa complete liberation of memory.  The fact is that in some cases, when the memory is released, it is still inaccessible to the operating system.  The Python process keeps it distributed and uses it later for new data.  Full release of memory returns memory to the use of the operating system. <br><br>  Arenas are not the only areas that can be completely vacated.  Thus, we understand that those arenas that are on the ‚Äúcloser to empty state‚Äù list should be released.  In this case, the memory area can actually be completely freed, and accordingly the total memory size of your Python program is reduced. <br><br>  <b>Conclusion</b> <br><br>  Memory management is one of the most important parts in working with a computer.  Python somehow makes almost all the actions in the hidden mode. <br><br>  From this article, you learned: <br><br><ul><li>  What is memory management and why is it important? </li><li>  What is CPython, the basic implementation of Python; </li><li>  How data structures and algorithms work in CPython memory management and store your data. </li></ul><br>  Python abstracts many small nuances of working with a computer.  This gives you the opportunity to work at a higher level and get rid of the headache on how and where the bytes of your program are stored. <br><br>  So we learned about memory management in Python.  Traditionally, we are waiting for your comments, as well as we invite you to <a href="https://otus.pw/3V8C/">the open door</a> on the Python Developer course, which will be held on March 13 </div><p>Source: <a href="https://habr.com/ru/post/443312/">https://habr.com/ru/post/443312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443302/index.html">How Apple is preparing for the era after the iPhone</a></li>
<li><a href="../443304/index.html">Being a technophobe is pointless, even if technophobia is justified.</a></li>
<li><a href="../443306/index.html">Eight named laws in UX design (part 1)</a></li>
<li><a href="../443308/index.html">Myths of modern physics. Conservation laws</a></li>
<li><a href="../443310/index.html">Bellabeat Women Wellness Gadget Review</a></li>
<li><a href="../443314/index.html">What is Cordentity? [Translation of the article]</a></li>
<li><a href="../443320/index.html">Electronic document management system "Vizir"</a></li>
<li><a href="../443322/index.html">GitLab 11.8 released with SAST for JavaScript, GitLab Pages for subgroups and bug tracking</a></li>
<li><a href="../443324/index.html">Python vs. Scala for Apache Spark - the expected benchmark with an unexpected result</a></li>
<li><a href="../443326/index.html">Python & Arduino. Simple, fast and beautiful</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>