<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Calculation of the correcting FIR filter on the FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I was encouraged to write this article by speaking at seminars on digital signal processing, where students have always focused their interest ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Calculation of the correcting FIR filter on the FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a12/2b5/579/a122b557953d4a69ae65971fff2ebc31.jpg"><br><br>  Hello!  I was encouraged to write this article by speaking at seminars on digital signal processing, where students have always focused their interest in the method of calculating corrective FIR filters, despite the fact that I touched on this topic superficially and for the most part told about it in introductory features.  If the public wants to get secret knowledge, then why not share it.  In this article I will try to present in an accessible form an algorithm for calculating corrective FIR filters, which is necessary for equalizing the frequency response in the passband after the CIC filter links in the problems of decimation and interpolation of signals.  In particular, consider the design of filters on modern FPGAs Xilinx.  As usual, at the end of the article there will be a link to useful scripts for calculating various filters and getting a file of filter-corrector coefficients. <br><br>  It is assumed that the reader is familiar with the basics of digital signal processing and has an understanding of CIC and FIR filters.  Let's get started <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  As is known, CIC filters are often used in problems of decimation and interpolation of signals, because they have one very important property - <b>ease of implementation</b> , which makes this class of filters cheap to perform.  A special feature of CIC filters is the absence of multiplication operations for calculating the response at the filter output.  CIC filters are applied everywhere, where work at several or different speeds is required, that is, in those tasks where decimation and interpolation of the data stream is required.  Let me remind you that decimation refers to the process of lowering the signal sampling rate (reducing the data rate), and interpolation is the process of increasing the signal sampling rate (increasing the data rate).  The CIC filter is an integral part of the <b>DDC</b> (Digital Down Converter) and <b>DUC</b> (Digital Up Converter) nodes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/fc4/129/f73/fc4129f739eb46008aea29c6bbc94b0f.png"></div><br>  The frequency response of the CIC filter is equivalent to the frequency response of the low-pass filter (LPF).  The shape of the frequency response and the position of the zeros of the characteristics are influenced by some filter parameters: order- <b>N</b> , the decimation / interpolation coefficient ‚Äî <b>R</b> , the delay value in the differentiating link ‚Äî <b>M.</b>  And it is precisely in the influence of these parameters on the FK that the main drawback of CIC filters lies.  For large orders of the filter N and the values ‚Äã‚Äãof the decimation / interpolation coefficient R, the resulting spectrum in the passband deteriorates significantly, namely, the shape of the main lobe of the frequency response is distorted.  For many multi-frequency and wideband signal processing tasks, it is necessary to have the most uniform and rectangular spectrum in the passband.  But if you look at the graph of the frequency response of the CIC filter, then we see a sharply decreasing curve in the passband.  Such unevenness is unacceptable and leads to the loss of energy of the useful signal and the distortion of its shape.  In this regard, the urgent task of aligning the frequency response of CIC filters in the passband while minimizing interference in the attenuation band. <br><br><h3>  Formulation of the problem </h3><br>  Let there be a CIC filter for which the order of <b>N</b> and the rate of change of the sampling rate <b>R are given</b> .  The delay value, if it is not a moving average filter, is in practice <b>M</b> = 1 or 2 and is determined by the registers at the nodes of the DSP48 FPGAs multipliers (regardless of the vendor, Altera or Xilinx).  It is necessary to calculate the correction filter to equalize the frequency response after the signal passes through the CIC link of the filter. <br><br><h3>  Decision </h3><br>  The correction filter is easiest to do on the basis of the FIR filter.  To calculate this filter, it is necessary to determine its parameters in advance: <br><br><ul><li>  filter order or impulse response length - <b>NFIR</b> , </li><li>  effective band within which alignment is required - <b>Fr</b> , </li><li>  the width of the filter coefficients - <b>Bc</b> , </li><li>  presence of window filtering - <b>WIN</b> . </li></ul><br>  <i>The order</i> is NFIR.  This parameter defines the "quality" of the frequency response of the filter.  The developer of DSP on the FPGA is constantly faced with the task of choosing the optimal order of the filter, because the greater the order is, the better in terms of frequency properties, but the more FPGA chip resources need to be spent to implement this filter.  The optimal values ‚Äã‚Äãof the order of the filter-corrector are in the range from 32 to 128. In some tasks, the value of the order of the filter may be higher and reach the number 256, but in practice it does not make sense, and I have not seen such long filter-correctors.  The correction filter should be small and not affect the computing resources that are needed to implement more complex things.  The order of the filter for this implementation is better to set an even number and a multiple of a power of two, if we are talking about applying a FPGA-based filter, but this requirement is <u>optional</u> . <br><br>  By <i>effective bandwidth</i> <b>Fr,</b> I mean the value of the relative normalized cutoff frequency after decimation or interpolation.  For problems of decimation, it is calculated using the formula <b>Fr = Fo / R</b> , where Fo is the parameter of the normalized frequency (for example, from 0.1 to 0.5), and R is the decimation coefficient.  The value of Fo determines the filter bandwidth.  It should be noted that when Fr = 0.5, the order of the filter must be odd so that the zero frequency response of the filter-corrector does not fall into the band of the useful signal.  For other values ‚Äã‚Äãof Fr, the filter order can be any.  This is due to the peculiarities of calculating the FIR2 embedded function in Matlab CAD software. <br><br>  <i>The width of the coefficients</i> for the described algorithm determines the non-uniformity of the frequency response in the passband and the barrier line.  In practice, the width of the coefficients is set from 16 to 27 bits, which is associated with the peculiarities of the DSP48 node of modern FPGAs.  For practical purposes, it is enough to set the bit width of the coefficients equal to 16-18 bits and this will adequately ensure the required uniformity of the frequency response.  For high-order filters (for example, N = 256), the bit width of 18 bits is insufficient and quantization effects begin to appear, in particular in the obstacle band.  Therefore, for high-order filters, it is necessary to increase the width of the coefficients, since the structure of the DSP48 processing nodes in the FPGA allows for this (see fig. Of the DSP48 node). <br><br><img src="https://habrastorage.org/files/d24/660/483/d24660483db44ed3b7e4afa462fd3a7f.png"><br><br>  <i>Window filtering</i> allows smoothing the pulsations of the resulting frequency response in the passband after applying the filter-corrector.  The window function is superimposed on the impulse response of the calculated FIR filter (mathematically this is a convolution of the spectra).  Based on personal experience, I note that <b>the Kaiser function</b> is the best version of the window function.  Using one parameter <b>BETA,</b> you can change the frequency response of the filter for the desired task.  The Kaiser function is calculated using the modified Bessel functions of zero order <i>I0</i> , but in many standard packages it is built-in ( <i>Matlab, GNU Octave, MathCAD</i> ).  Physically, the BETA parameter determines the fraction of energy concentrated within the main lobe of the spectrum.  The larger the BETA parameter, the more concentrated the energy and the wider the main lobe, but the lower the side lobes level.  For practical purposes, the parameter BETA = 3-11. <br><br>  I will not give a detailed method for calculating the FIR filter, you can read about it <a href="https://habrahabr.ru/post/274847/">in my previous article</a> .  There is nothing complicated - you need to get the FIR filter coefficients in any convenient way.  This can be done using MathCAD, GNU Octave, Matlab (FDATool utility), ScopeFIR application, LabView program, or write your own calculation methodology based on known algorithms. <br><br><h3>  Algorithm </h3><br>  We describe the algorithm for calculating the corrective FIR filter.  Below, Matlab script code inserts will be used to better understand the implementation process. <br><br>  <b>Step 1:</b> set the initial parameters of the CIC filter - <br><br><pre><code class="matlab hljs">R = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">% Decimation factor N = 4; % Number of stages M = 1; % Differential delay (only 1)</span></span></code> </pre> <br>  <b>Step 2: we</b> set the parameters of the FIR filter (coefficient width, order, window) and the normalized cutoff frequency of the frequency response - <br><br><pre> <code class="matlab hljs">NFIR = <span class="hljs-number"><span class="hljs-number">128</span></span>; <span class="hljs-comment"><span class="hljs-comment">% Filter order, must be odd when Fo = 0.5 ! Bc = 16; % Coef. Bit-width Fo = 0.3; % Normalized Cutoff: 0.2 &lt; Fo &lt; 0.5; BETA = 8; % BETA parameter for Kaiser window (if IS_WIND = 'Y')</span></span></code> </pre><br>  <b>Step 3:</b> Select the step of "discretization" of vectors to calculate the characteristics.  In accordance with this step, we create the required arrays of numbers.  We calculate the CIC filter using a well-known formula and translate the result into decibels. <br><br><pre> <code class="matlab hljs">HCIC = (R^-N*<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>*M*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>*M*R*ff) ./ <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>*ff)).^N); HCICdb = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">log10</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(HCIC));</code> </pre><br>  <b>Step 4:</b> In accordance with the effective bandwidth parameter Fo, we divide the frequency sample vector into two parts: <i>fp</i> is the frequency vector in the passband, <i>fs</i> is the frequency vector in the attenuation band.  We calculate the ideal characteristic of the compensating filter with the cut-off frequency Fo / R according to the following formula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d49/6f0/78c/d496f078c2cb4212b9a88f567f0d4801.png"></div><br>  where <i>f</i> - samples of the normalized frequency in the bandwidth range from 0 to Fo / R.  The remaining counts are zero. <br><br><pre> <code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">% Calculate ideal response Mp = ones(1, length(fp)); % Pass band response; Mp(1) = 1 Mp(2:end) = abs(M * R * sin(pi*fp(2:end)/R) ./ sin(pi*M*fp(2:end))).^(N); Mf = [Mp zeros(1, length(fs))];</span></span></code> </pre><br>  The type of the obtained characteristic is shown in the figure below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dab/391/824/dab3918244e945bc8435a424bff50e74.png"></div><br>  <b>Step 5:</b> According to the ideal frequency response, we calculate the impulse response of the FIR compensating filter with the specified parameters (weight window, if any, coefficient width and filter order). <br><br>  The type of the impulse response of the filter-corrector (the calculation is performed using the built-in function <i>FIR2</i> , and the window function is <i>calculated</i> through the function <i>FIR1</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d6c/aae/48d/d6caae48d6994a4ab2eb1a08a086984b.png"></div><br>  Source code for the calculation of their correction filter: <br><br><pre> <code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">% Calculate FIR hFIR = fir2(NFIR-1, f, Mf); % Filter length NFIR hFIR = hFIR / max(hFIR); % Double coefficients hCOE = round(hFIR*(2^(Bc-1)-1)); % Fixed point coefficients % Windowed FIR (Kaiser with BETA) if (IS_WIND == 'Y') WIND = kaiser(NFIR, BETA); % KAISER WINDOW IS USED! hWIND = fir1(NFIR-1, Fo/R, 'low', WIND); hNEW = hCOE .* hWIND;% conv2(hCOE,Hwind); hCOE = hNEW; end</span></span></code> </pre><br>  At this point, the filter calculation ends.  The result is a file of filter coefficients in a user-friendly form.  As you can see, there is nothing complicated and the whole process is divided into 4-5 stages: <br><br><ul><li>  Determining the input parameters of CIC and FIR filters, </li><li>  Forming the perfect frequency response, </li><li>  Calculation of FIR filter coefficients ( <i>FIR2</i> function), </li><li>  Construction of the frequency response of the compensating filter to check </li><li>  Calculation of bandwidth irregularity. </li></ul><br>  It should be noted that for downsampling schemes (decimation task), compensating filters are usually placed after CIC filters.  For the tasks of increasing the sampling rate (interpolation), compensating filters are up to CIC filters.  This arrangement of filters is best suited from the point of view of the amount of crystal resources occupied, since the corrective FIR filter in this case operates at a lower frequency (after decimation or before interpolation). <br><br>  The following figure shows the frequency response of the CIC and FIR filters and the resulting frequency response after compensation with the following parameters: <br><br><ul><li>  The decimation coefficient <b>R = 11</b> ; </li><li>  Order CIC filter <b>N = 4</b> ; </li><li>  The delay in the chain diff.  link <b>M = 1</b> ; </li><li>  The order of the FIR filter is <b>NFIR = 64</b> ; </li><li>  The width of the coefficients is <b>Bc = 16</b> ; </li><li>  Normalized cut-off frequency <b>Fo = 0.4</b> ; </li><li>  Window function - not used </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/799/466/bde/799466bde2994446b180f4de5f014f1b.png"></div><br>  As can be seen, the frequency response of the CIC filter is compensated, and the resulting frequency response visually has sufficient squareness (red curve). <br><br><h3>  Uneven frequency response in the passband </h3><br>  Unfortunately, the alignment of the frequency response does not end there.  Increase the graph within the bandwidth.  In the following graph you can see small beats in the band. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c78/dea/170/c78dea1702c149f19b89ddfc84cc3fcf.png"></div><br>  <i>Why is that?</i>  The uneven frequency response in the passband is the higher, the greater the order of the CIC filter <b>N.</b>  The decimation / interpolation coefficient <b>R</b> does not affect the non-uniformity.  Also, non-uniformity is affected by the order of the compensating FIR filter.  The smaller the filter order, the greater the unevenness.  But the greater the order of the filter, the greater the frequency of "beats" in the passband.  For this reason, for practical purposes, <b>NFIR&gt; 128</b> high-order compensating filters are not used!  The effective band also makes a minor contribution: the smaller the strip being leveled, the smaller the unevenness. <br><br>  To combat beats are used window functions, which I mentioned earlier.  Let's see how the graph looks at an enlarged scale without window filtering and using the Kaiser function ( <i>BETA = 8</i> ).  The remaining parameters remain unchanged. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b69/0ce/aee/b690ceaee13a41249f1f28b76d7f530a.png"></div><br><ul><li>  Blue - result without window filtering, </li><li>  Red - application of the Kaiser window function. </li></ul><br>  As you can see, window filtering allows you to smooth out the beats in the passband, making the graph of the resulting frequency response smooth. <br><br>  The second way to improve the properties of the frequency response is to divide the processing into several stages.  For example, decimation is carried out not in one stage, but with the help of several links to lower the sampling frequency: <b>R = R1 * R2 * ... Rn</b> . <br><br>  In order to save FPGA resources in some tasks it is possible to combine corrective and formative FIR filters.  To do this, multiply their impulse responses or perform convolution of the spectra. <br><br><h3>  Result </h3><br>  For the convenience of calculating the filter-corrector, an m-script was written, which allows to get the result in visual form.  The script can output the coefficients data in one of several popular formats, but if you wish, you can add and modify it to fit your goals. <br><br><ul><li>  <b>COE</b> - Xilinx format for loading coefficients in the <i>Core Generator</i> , </li><li>  <b>H</b> - file header for connection to C / C ++ projects (Code Composer Studio), </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/03d/c15/104/03dc15104a584704a8d514a04de36a03.png"></div><br>  To run the script, you need a CAD system Matlab or GNU Octave (I debugged in the latter).  Next, the resulting coefficient file is loaded in <b>* .COE</b> format, into the Xilinx Core Generator, where a compensating FIR filter is implemented. <br><br><img src="https://habrastorage.org/files/849/340/e7b/849340e7b75c4768be5aa3000554ff9c.png"><br><br>  Schematic view of the FIR filter in the Xilinx Vivado environment (post-synthesis tab): <br><br><img src="https://habrastorage.org/files/a97/68f/659/a9768f6595ee462fb7f653d89e27a9be.png"><br><br><h3>  Alternative method </h3><br>  Another method for calculating corrective filters was suggested by my colleague - Antonov A.E.  He wrote an interactive application that, step by step in manual mode, selects the required unevenness of the frequency response of the filter and unloads the coefficients for further work.  The proposed program, <i>c_koeff.exe,</i> is designed to adjust the FIR filter coefficients behind the system of two CIC filters to compensate for the uneven frequency response of the entire system in the passband introduced by the CIC filters.  It is assumed that the FIR filter coefficients are obtained in the FDATool environment of the MATLAB package and specified as a C-header file.  The program is written in C ++ Builder.  To display the calculated coefficients of the compensated FIR filter and its frequency response, an <i>ISVI 6</i> or higher version program is used, which was developed by CJSC InSys and <a href="http://insys.ru/downloads/common">distributed free of charge</a> .  In order not to violate the rules of the resource, I will not advertise the achievements of the company and the features of the application software. <br><br>  The result of the program is shown in the following figure.  By iterating the parameter <b>Np</b> , we obtain the spectral function of the compensating filter.  In the ISVI application, you can also observe the impulse response of the filter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/176/8b6/458/1768b6458e2d4eb8827f745ab8f7a1de.png"></div><br>  The application description is in the word-file among the sources on github (link below). <br><br><h3>  Source </h3><br><ul><li>  <a href="https://github.com/capitanov/math">Matlab / GNU Octave m-scripts</a> (calculation of FIR filters and corrective filters) </li><li>  <a href="https://github.com/capitanov/CFIR_Comp">C_koeff application</a> for interactive calculation of filter-corrector </li></ul><br><h3>  Literature </h3><br><ul><li>  <a href="https://habrahabr.ru/post/274845/">Digital signal processing on FPGA - 1</a> </li><li>  <a href="https://habrahabr.ru/post/274847/">Digital signal processing on FPGA - 2</a> </li><li>  <a href="https://www.altera.com/en_US/pdfs/literature/an/an455.pdf">Altera DS (Understanding CIC Compensation Filters)</a> </li><li>  <a href="http://www.dsplib.ru/content/cicid/cicid.html">Using CIC filters for decimation and interpolation tasks</a> </li><li>  E.S.  Ifcher, Barry U. Dervis., Digital Signal Processing.  Practical approach </li><li>  Rabiner L., Gold B., Theory and application of digital signal processing </li><li>  An economical class of digital filters for decimation and interpolation </li></ul><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/324986/">https://habr.com/ru/post/324986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324974/index.html">Open lecture by Sergei Zykov on April Fools ‚Äôactions in games</a></li>
<li><a href="../324978/index.html">Cones stuffed with 15 years of using actors in C ++. Part II</a></li>
<li><a href="../324980/index.html">Webinar "Testing applications for vulnerabilities. The practice of building SDLC</a></li>
<li><a href="../324982/index.html">First experience with Google API (for example, ContactsAPI) and OAuth2.0 on pure HTTP</a></li>
<li><a href="../324984/index.html">Basic concepts of the chrono library (C ++)</a></li>
<li><a href="../324988/index.html">Java implementation of a hashed binary tree</a></li>
<li><a href="../324990/index.html">Advantages of SDN: on the example of VMware vSphere integration with Huawei Cloud Fabric</a></li>
<li><a href="../324992/index.html">How to create an Internet of things from LEGO bricks based on AWS IoT platform</a></li>
<li><a href="../324994/index.html">Native Data Centers: Overview of Russian Data Centers (Part 1)</a></li>
<li><a href="../324996/index.html">Relevant connection - specific and universal attributes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>