<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenEMS dipole antenna simulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous part it was described how to model the propagation of EME using a simulator 
 openEMS . Now consider how to calculate something useful...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenEMS dipole antenna simulation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c1f/b17/405/c1fb17405cda4305a5dfbfede018f1aa.png"><br><br>  In the <a href="http://habrahabr.ru/post/258489/">previous part</a> it was described how to model the propagation of EME using a simulator <br>  <a href="http://openems.de/">openEMS</a> .  Now consider how to calculate something useful.  We simulate a dipole half-wave antenna at a frequency of 500 MHz.  Modeling in the frequency domain and antenna pattern modeling will be considered.  The scheme of this antenna is shown in the figure. <br><br><img src="https://habrastorage.org/files/403/79c/6a4/40379c6a41d145e8b7b126d69effe6e7.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A dipole antenna consists of two beams, each of which has a length equal to 1/4 of a wave for a resonant frequency.  The antenna is powered from the center.  The antenna has a resonance resonance resistance of approximately 75 ohms and a torus-shaped di-gram.  More information about the theory of the dipole antenna can be found, for example, in the textbook of Eisenberg or Belotserkovsky.  These results we should get after the simulation. <br><br>  Under the cut, there is a script with a model of a dipole antenna with line-by-line analysis.  It is assumed that the reader is familiar with the basics of Matlab / Octave, electrical engineering and antenna theory (he knows what complex resistance, S-parameters and VSWR are). <br><a name="habracut"></a><br>  For those who do not know what is happening here, links to my previous articles: <br><ul><li>  <a href="http://habrahabr.ru/post/255317/">openEMS is an open source electromagnetic simulator</a> </li><li>  <a href="http://habrahabr.ru/post/258489/">OpenEMS modeling basics</a> </li></ul><br><br>  The simulation script must first be saved to a text file with the extension * .m, using your favorite test editor (for example KWrite).  Then you need to run Octave from the command line, passing in the name of the script as a parameter.  Suppose if our script is called dipole.m, then the simulation starts like this: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">octave</span></span> dipole.m</code> </pre> <br>  If you want to use the graph view from Octave interactively, you must first run Octave from the command line, and then use the source command.  It will load the dipole.m script from the current directory. <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">source</span></span> dipole.m</code> </pre><br>  As a result of the simulation, we want to get: <br><ul><li>  The dependence of the input impedance of the antenna at the power point of the frequency. </li><li>  Dependence of the antenna CWS at the power point on the frequency for a 50 Ohm source </li><li>  DN in polar coordinates </li><li>  3D NAM in spherical coordinates </li></ul><br><br>  Let's start the line by line parsing script.  The openEMS documentation suffers from spaces, so something had to be thought out for itself. <br><br>  So at the beginning of the script we clear all variables: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">close</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>; clear; clc;</code> </pre><br>  Now you need to announce the name of the XML file that contains the task for the simulation and the temporary directory in which the simulation results will be stored.  Files with the results of calculations reach 100 MB, so you need to take care of disk space. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">physical_constants</span></span> SimPath = <span class="hljs-string"><span class="hljs-string">'tmp'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">SimCSX</span></span> = <span class="hljs-string"><span class="hljs-string">'tmp.xml'</span></span>;</code> </pre><br>  Now we begin the description of the parametric model of the antenna.  This means that when changing parameters (for example, the calculated resonant frequency), Matlab / Octave will automatically recalculate all antenna sizes.  The grid spacing is set equal to 1/50 wavelength. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">f_max</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>.5e9; <span class="hljs-comment"><span class="hljs-comment">#    lambda = c0/f_max; #   step=lambda/50; #  </span></span></code> </pre><br>  As you remember from physics, wavelength and frequency are related through the speed of light. <br>  c0 <br><br>  We declare simulation space (SimBox) - a cube with an edge equal to <br>  doubled wavelength (2 * lambda).  Fill the space with a grid <br>  mesh <br><br><pre> <code class="hljs python">CSX = InitCSX(); mesh.x = -<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>:step:<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>; mesh.y = -<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>:step:<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>; mesh.z = -<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>:step:<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>; SimBox = [<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>]; CSX = DefineRectGrid(CSX,<span class="hljs-number"><span class="hljs-number">1</span></span>,mesh);</code> </pre><br>  Now we set the excitation source.  In the last part, we used a sinusoidal source of a fixed frequency.  openEMS first performs the calculation in the time domain, and then recalculates the result in the frequency domain.  Therefore, in order to simulate the frequency properties of the system, you need a source with an extended spectrum.  The Gaussian impulse is available as such a source in openEMS. <br><br>  So, first, we assign the variables in which we will store the parameters of the Gaussian pulse.  You must specify the center frequency of the Gaussian pulse spectrum and half the width of the spectrum.  We will model our antenna in the frequency range from 200 MHz to 600 MHz.  Therefore, the center frequency will be 400 MHz, and the width of the spectrum + -200 MHz from the center frequency. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">f0</span></span> = 400e6; <span class="hljs-attribute"><span class="hljs-attribute">fc</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>*f0; <span class="hljs-attribute"><span class="hljs-attribute">FDTD</span></span> = InitFDTD(<span class="hljs-string"><span class="hljs-string">'NrTS'</span></span>,<span class="hljs-number"><span class="hljs-number">30000</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">FDTD</span></span> = SetGaussExcite(FDTD,f0,fc);</code> </pre><br>  The FDTD space is initialized using the InitFDTD () function. The second parameter is to pass the number of samples in the time domain to it.  It must be chosen in such a way that it exceeds the pulse duration in sampling steps.  Usually 30,000 is enough.  Otherwise, we will receive an error message, which states that the calculation interval is less than the duration of the Gaussian pulse. <br><br>  Now you need to set the boundary conditions.  We are modeling an antenna in free space, so it will be surrounded on all sides by an absolutely absorbing MUR dielectric: <br><br><pre> <code class="hljs cs">BC = {<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>}; FDTD = SetBoundaryCond(FDTD,BC);</code> </pre><br>  Now we declare the geometry.  The process of describing geometry for those familiar with, for example, HFSS looks unusual and unusual. <br><br>  The dipole will consist of two conducting parallelepipeds between which the excitation source is connected.  The thickness of the dipole rays may be less than the grid pitch.  As the theory says, the greater the thickness of the dipole antenna, the wider its bandwidth.  All our geometry is parameterized and will be automatically recalculated when changing parameters.  This is the advantage of the Matlab / Octave simulator. <br><br><pre> <code class="hljs pgsql">t = step/<span class="hljs-number"><span class="hljs-number">4</span></span>; #    (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">200</span></span>  ) CSX = AddMetal(CSX,<span class="hljs-string"><span class="hljs-string">'right_beam'</span></span>); #    start = [t -t -t]; #   stop = [lambda/<span class="hljs-number"><span class="hljs-number">4</span></span> tt]; #   CSX = AddBox(CSX,<span class="hljs-string"><span class="hljs-string">'right_beam'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,stop); #    </code> </pre><br>  The coordinates of points in space are specified in openEMS as a matrix-row of three components, which follow the order [xyz]. <br><br>  The AddMetal () function adds some metal object.  The created object must be associated with some geometric object.  The AddBox () function adds a box.  The penultimate and last parameters are the coordinates of its extreme vertices.  The third parameter is the priority.  His appointment remains unclear to me.  You can always set it to 1. The second parameter is the name of the parallelepiped material object.  We have to use the 'right_beam' object that we created earlier. <br><br>  Similar action for the left beam: <br><br><pre> <code class="hljs sql">CSX = AddMetal(CSX,'left_beam'); <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> = [<span class="hljs-number"><span class="hljs-number">0</span></span> -t -t]; <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> = [-lambda/<span class="hljs-number"><span class="hljs-number">4</span></span> tt]; CSX = AddBox(CSX,'left_beam',1,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">stop</span></span>);</code> </pre><br>  Now you need to power the antenna.  To power the antenna is a special object called the port (Lumped Port). <br><br>  There is also a distributed port, which is an area of ‚Äã‚Äãspace from which EMW is distributed.  The distributed port was used in the second part. <br><br>  We need to use a regular port.  It corresponds to the case of powering the antenna from the voltage source.  The voltage source is the previously announced Gaussian pulse.  The port consists of two points in space, between which the terminals of the virtual voltage source are connected.  First, we declare these two points.  They should lie on the surface of the dipole rays: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">start</span></span> = [<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">#    stop = [step 0 0];</span></span></code> </pre><br>  Now we will declare the output impedance of the source: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">R</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre><br>  And you can add the actual port: <br><br><pre> <code class="hljs sql">[CSX port] = AddLumpedPort(CSX,1,1,R,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">stop</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>],<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  The AddLumpedPort () function has 8 parameters.  Consider them in more detail: <br><ul><li>  The second parameter is priority.  You can put in 1 </li><li>  The third parameter is the serial number of the port.  Maybe a few <br>  ports. </li><li>  The fourth parameter is the output impedance of the source </li><li>  The fifth and sixth parameters - port connection points </li><li>  The seventh parameter is the direction of the signal.  Vector of three components <br>  which shows the direction of the signal in [xyz] format.  We have <br>  the signal is directed along the x axis. </li></ul><br><br>  Now you need to specify the area in which the field emitted by the antenna will be calculated.  openEMS calculates the field in the near zone, and then using the post-processor NF2FF recalculates it in the field in the far zone.  The antenna DN is calculated from the field in the far zone.  The area in which the field is calculated is to be taken equal to the modeling area, having necessarily stepped inside several grid steps from the border. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">SimBox</span></span> = SimBox-step*<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">#    [CSX nf2ff] = CreateNF2FFBox(CSX,'nf2ff',-SimBox/2,SimBox/2);</span></span></code> </pre><br>  Everything!  Geometry set.  You can write a job file for openEMS and see the result in the AppCSXCAD interactive viewer. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">mkdir</span></span>(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>); SimPath = <span class="hljs-string"><span class="hljs-string">'tmp/tmp.xml'</span></span> WriteOpenEMS(SimPath,FDTD,CSX); CSXGeomPlot(SimPath);</code> </pre><br>  If everything is done correctly, we will see the following picture (the port is visible in the dipole gap): <br><br><img src="https://habrastorage.org/files/44d/c94/eef/44dc94eef9134b368ce25c83c0b4c9b4.png"><br><br>  Now we run openEMS. <br><pre> <code class="hljs lisp">RunOpenEMS('tmp','tmp.xml')<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  The calculation takes quite a long time.  After calculation are created for the structure: <br><ul><li>  port - contains information about the characteristics of the antenna in <br>  frequency domain </li><li>  nf2ff - contains information about the antenna NAM </li></ul><br><br>  We need to extract from the structure of the port information about the input impedance of the antenna and the reflection coefficient S11.  To do this, you need the following structure fields <br>  port: <br><ul><li>  port.uf.tot - Full voltage at the port terminals </li><li>  port.if.tot - Total current flowing through the port </li><li>  port.uf.inc - Amplitude of incident wave voltage </li><li>  port.uf.ref - amplitude of the voltage of the reflected wave </li></ul><br><br>  Tepr using formulas known from the course of radio engineering, we calculate the input resistance Zin and the reflection coefficient at the input S11 (it can be recalculated into <br>  standing wave ratio - SWR).  Now you can plot the graphics Zvh (active and reactive parts), VSWR and S11, using standard tools Matlab / Octave This piece of code does not require explanation. <br><br><pre> <code class="hljs vhdl">freq = linspace(f0-fc,f0+fc,<span class="hljs-number"><span class="hljs-number">501</span></span>); #   <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> = calcPort(<span class="hljs-keyword"><span class="hljs-keyword">port</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">'tmp</span></span>',freq); #   Zin = <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>.uf.tot ./ <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.tot; S11 = <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>.uf.ref ./ <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>.uf.inc; subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); plot(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,real(Zin),freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,imag(Zin)); #   R  X legend(<span class="hljs-symbol"><span class="hljs-symbol">'Re</span></span>(Zin)',<span class="hljs-symbol"><span class="hljs-symbol">'Im</span></span>(Zin)'); subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); plot(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,S11); #   S11 swr = (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(S11))./(<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(S11)); #     [swr_min idx] = min(swr); [Xmin idx1] = min(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(imag(Zin))); #    fr = freq(idx); fr1 = freq(idx1); Zr = Zin(idx); Zr1 = Zin(idx1); disp(<span class="hljs-string"><span class="hljs-string">"Minimum SWR frequency:"</span></span>); #    disp(fr); disp(<span class="hljs-string"><span class="hljs-string">"Resonant frequency (jX=0)"</span></span>); disp(fr1); disp(<span class="hljs-string"><span class="hljs-string">"Impedance at minimum SWR"</span></span>); disp(Zr); disp(<span class="hljs-string"><span class="hljs-string">"Impedance at resonant frequency"</span></span>); disp(Zr1); disp(<span class="hljs-string"><span class="hljs-string">"Minimum SWR:"</span></span>); disp(swr_min); subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); semilogy(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,swr);</code> </pre><br>  We get the following antenna parameters.  It is seen that the resonance frequency went down from the calculated one.  Antenna resistance at a resonance of 71.2 ohms is almost like in textbooks, the deviation is caused by the dipole thickness. <br><br><pre> <code class="hljs matlab">Minimum SWR frequency: <span class="hljs-number"><span class="hljs-number">427200000</span></span> Resonant frequency (jX=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">431200000</span></span> Impedance at minimum SWR <span class="hljs-number"><span class="hljs-number">68.7692</span></span> - <span class="hljs-number"><span class="hljs-number">6.5511</span></span><span class="hljs-built_in"><span class="hljs-built_in">i</span></span> Impedance at resonant frequency <span class="hljs-number"><span class="hljs-number">71.18555</span></span> - <span class="hljs-number"><span class="hljs-number">0.45064</span></span><span class="hljs-built_in"><span class="hljs-built_in">i</span></span> Minimum SWR: <span class="hljs-number"><span class="hljs-number">1.4013</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/fab/4c2/ed9/fab4c2ed934645e5966f706eeeb88ff0.png"><br><br>  Now we calculate the DN in polar coordinates.  The last two parameters of the function CalcNF2FF () are the range of angles within which the pattern is viewed.  By the third parameter, it needs to transmit the frequency at which the pitch pattern is calculated. <br>  We get the following graphics: <br><br><pre> <code class="hljs matlab">nf2ff = CalcNF2FF(nf2ff,<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,fr,[<span class="hljs-number"><span class="hljs-number">-180</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">180</span></span>]*<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>,[<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">90</span></span>]*<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">figure</span></span> polarFF(nf2ff,<span class="hljs-string"><span class="hljs-string">'xaxis'</span></span>,<span class="hljs-string"><span class="hljs-string">'theta'</span></span>,<span class="hljs-string"><span class="hljs-string">'param'</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>],<span class="hljs-string"><span class="hljs-string">'normalize'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br><img src="https://habrastorage.org/files/480/056/873/4800568737ae441882ebc3a391252ec0.png"><br><br>  DN in Cartesian coordinates: <br><br><pre> <code class="hljs lisp">figure plotFFdB(<span class="hljs-name"><span class="hljs-name">nf2ff</span></span>,'xaxis','theta','param',[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>])<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/e85/0dd/435/e850dd4351dd4ba28c9093aba2a151b7.png"><br><br><pre> <code class="hljs matlab">thetaRange = (<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">180</span></span>); phiRange=(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">360</span></span>)<span class="hljs-number"><span class="hljs-number">-180</span></span>; nf2ff = CalcNF2FF(nf2ff,<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,fr,thetaRange*<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>,phiRange*<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">180</span></span>,<span class="hljs-string"><span class="hljs-string">'Verbose'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'Outfile'</span></span> ,<span class="hljs-string"><span class="hljs-string">'3D_Pattern.h5'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">figure</span></span> plotFF3D(nf2ff,<span class="hljs-string"><span class="hljs-string">'logscale'</span></span>,<span class="hljs-number"><span class="hljs-number">-20</span></span>);</code> </pre><br><br><img src="https://habrastorage.org/files/2dd/5ad/bad/2dd5adbad43b408185fa85277167a96d.png"><br><br>  Spatial DN has the shape of a torus as in the textbooks on antennas.  Coefficient <br>  2.1 dB antenna gain. <br><br>  You can also create a * .vtk file so that you can view it later with Paraview: <br><br><pre> <code class="hljs pgsql">E_far_normalized = nf2ff.E_norm{<span class="hljs-number"><span class="hljs-number">1</span></span>} / max(nf2ff.E_norm{<span class="hljs-number"><span class="hljs-number">1</span></span>}(:)) * nf2ff.Dmax; DumpFF2VTK([<span class="hljs-string"><span class="hljs-string">'tmp/3D_Pattern.vtk'</span></span>],E_far_normalized,thetaRange,phiRange,<span class="hljs-string"><span class="hljs-string">'scale'</span></span>, <span class="hljs-number"><span class="hljs-number">1e-3</span></span>);</code> </pre><br>  This is how the DN looks in Paraview (you need to open the 3D_Pattern.vtk file): <br><br><img src="https://habrastorage.org/files/1e8/ec5/7e0/1e8ec57e038b42b4bad73480c17bc511.png"><br><br>  We simulated a dipole antenna in the frequency range from 200 to 600 MHz.  As you can see, the simulation gives results close to the theory and allows to take into account the influence of the deviation of the parameters of the dipole from the ideal.  Those who have at hand HFSS can check the result. <br><br>  In conclusion, we give our entire script: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">close</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>; clear; clc; physical_constants #unit = <span class="hljs-number"><span class="hljs-number">1e-3</span></span>; # Units <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mm SimPath = <span class="hljs-string"><span class="hljs-string">'tmp'</span></span>; SimCSX = <span class="hljs-string"><span class="hljs-string">'tmp.xml'</span></span>; f_max = <span class="hljs-number"><span class="hljs-number">0.5e9</span></span>; lambda = c0/f_max; dipole_L = lambda/<span class="hljs-number"><span class="hljs-number">2</span></span>; step=lambda/<span class="hljs-number"><span class="hljs-number">50</span></span>; CSX = InitCSX(); mesh.x = -lambda:step:lambda; mesh.y = -lambda:step:lambda; mesh.z = -lambda:step:lambda; SimBox = [<span class="hljs-number"><span class="hljs-number">2</span></span>*lambda <span class="hljs-number"><span class="hljs-number">2</span></span>*lambda <span class="hljs-number"><span class="hljs-number">2</span></span>*lambda]; CSX = DefineRectGrid(CSX,<span class="hljs-number"><span class="hljs-number">1</span></span>,mesh); #f0 = f_max; f0 = <span class="hljs-number"><span class="hljs-number">400e6</span></span>; fc = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*f0; FDTD = InitFDTD(<span class="hljs-string"><span class="hljs-string">'NrTS'</span></span>,<span class="hljs-number"><span class="hljs-number">30000</span></span>); FDTD = SetGaussExcite(FDTD,f0,fc); BC = {<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>,<span class="hljs-string"><span class="hljs-string">'MUR'</span></span>}; FDTD = SetBoundaryCond(FDTD,BC); t = step/<span class="hljs-number"><span class="hljs-number">4</span></span>; CSX = AddMetal(CSX,<span class="hljs-string"><span class="hljs-string">'right_beam'</span></span>); start = [t -t -t]; stop = [lambda/<span class="hljs-number"><span class="hljs-number">4</span></span> tt]; CSX = AddBox(CSX,<span class="hljs-string"><span class="hljs-string">'right_beam'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,stop); CSX = AddMetal(CSX,<span class="hljs-string"><span class="hljs-string">'left_beam'</span></span>); start = [<span class="hljs-number"><span class="hljs-number">0</span></span> -t -t]; stop = [-lambda/<span class="hljs-number"><span class="hljs-number">4</span></span> tt]; CSX = AddBox(CSX,<span class="hljs-string"><span class="hljs-string">'left_beam'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,stop); start = [<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ]; stop = [step <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>]; R = <span class="hljs-number"><span class="hljs-number">50</span></span>; [CSX port] = AddLumpedPort(CSX,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,R,<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,stop,[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>],<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); SimBox = SimBox-step*<span class="hljs-number"><span class="hljs-number">4.0</span></span>; [CSX nf2ff] = CreateNF2FFBox(CSX,<span class="hljs-string"><span class="hljs-string">'nf2ff'</span></span>,-SimBox/<span class="hljs-number"><span class="hljs-number">2</span></span>,SimBox/<span class="hljs-number"><span class="hljs-number">2</span></span>); mkdir(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>); SimPath = <span class="hljs-string"><span class="hljs-string">'tmp/tmp.xml'</span></span> WriteOpenEMS(SimPath,FDTD,CSX); CSXGeomPlot(SimPath); RunOpenEMS(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,<span class="hljs-string"><span class="hljs-string">'tmp.xml'</span></span>); freq = linspace(f0-fc,f0+fc,<span class="hljs-number"><span class="hljs-number">501</span></span>); port = calcPort(port,<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,freq); Zin = port.uf.tot ./ port.<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.tot; S11 = port.uf.<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ./ port.uf.inc; subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); plot(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,<span class="hljs-type"><span class="hljs-type">real</span></span>(Zin),freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,imag(Zin)); legend(<span class="hljs-string"><span class="hljs-string">'Re(Zin)'</span></span>,<span class="hljs-string"><span class="hljs-string">'Im(Zin)'</span></span>); subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); plot(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,S11); legend(<span class="hljs-string"><span class="hljs-string">'S11'</span></span>); swr = (<span class="hljs-number"><span class="hljs-number">1</span></span>+abs(S11))./(<span class="hljs-number"><span class="hljs-number">1</span></span>-abs(S11)); [swr_min idx] = min(swr); [Xmin idx1] = min(abs(imag(Zin))); fr = freq(idx); fr1 = freq(idx1); Zr = Zin(idx); Zr1 = Zin(idx1); disp("Minimum SWR frequency:"); disp(fr); disp("Resonant frequency (jX=0)"); disp(fr1); disp("Impedance at minimum SWR"); disp(Zr); disp("Impedance at resonant frequency"); disp(Zr1); disp("Minimum SWR:"); disp(swr_min); subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); semilogy(freq/<span class="hljs-number"><span class="hljs-number">1e6</span></span>,swr); legend(<span class="hljs-string"><span class="hljs-string">'SWR'</span></span>); nf2ff = CalcNF2FF(nf2ff,<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,fr,[<span class="hljs-number"><span class="hljs-number">-180</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">180</span></span>]*pi/<span class="hljs-number"><span class="hljs-number">180</span></span>,[<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">90</span></span>]*pi/<span class="hljs-number"><span class="hljs-number">180</span></span>); figure polarFF(nf2ff,<span class="hljs-string"><span class="hljs-string">'xaxis'</span></span>,<span class="hljs-string"><span class="hljs-string">'theta'</span></span>,<span class="hljs-string"><span class="hljs-string">'param'</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>],<span class="hljs-string"><span class="hljs-string">'normalize'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); figure plotFFdB(nf2ff,<span class="hljs-string"><span class="hljs-string">'xaxis'</span></span>,<span class="hljs-string"><span class="hljs-string">'theta'</span></span>,<span class="hljs-string"><span class="hljs-string">'param'</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>]); thetaRange = (<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">180</span></span>); phiRange=(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">360</span></span>)<span class="hljs-number"><span class="hljs-number">-180</span></span>; nf2ff = CalcNF2FF(nf2ff,<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>,fr,thetaRange*pi/<span class="hljs-number"><span class="hljs-number">180</span></span>,phiRange*pi/<span class="hljs-number"><span class="hljs-number">180</span></span>,<span class="hljs-string"><span class="hljs-string">'Verbose'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'Outfile'</span></span> ,<span class="hljs-string"><span class="hljs-string">'3D_Pattern.h5'</span></span>); figure plotFF3D(nf2ff,<span class="hljs-string"><span class="hljs-string">'logscale'</span></span>,<span class="hljs-number"><span class="hljs-number">-20</span></span>); E_far_normalized = nf2ff.E_norm{<span class="hljs-number"><span class="hljs-number">1</span></span>} / max(nf2ff.E_norm{<span class="hljs-number"><span class="hljs-number">1</span></span>}(:)) * nf2ff.Dmax; DumpFF2VTK([<span class="hljs-string"><span class="hljs-string">'tmp/3D_Pattern.vtk'</span></span>],E_far_normalized,thetaRange,phiRange,<span class="hljs-string"><span class="hljs-string">'scale'</span></span>, <span class="hljs-number"><span class="hljs-number">1e-3</span></span>); pause;</code> </pre><br></div></div><br><br>  Perhaps the continuation should ... </div><p>Source: <a href="https://habr.com/ru/post/259383/">https://habr.com/ru/post/259383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259371/index.html">Welcome to the OWASP Russia Meetup June 6</a></li>
<li><a href="../259375/index.html">Writing Tetris for LG SmartTV (WebOS)</a></li>
<li><a href="../259377/index.html">Developing a successful international business with Google Play</a></li>
<li><a href="../259379/index.html">Opera browsers, their modes and engines</a></li>
<li><a href="../259381/index.html">100 Years Later: Ramanujan Records Complete</a></li>
<li><a href="../259385/index.html">Why did we open the code Virtuozzo</a></li>
<li><a href="../259389/index.html">(Not) safe frontend</a></li>
<li><a href="../259391/index.html">How to organize interaction of processes in Oracle BPM</a></li>
<li><a href="../259393/index.html">Skype Skype for Windows and Mac OS DoS Exploit</a></li>
<li><a href="../259397/index.html">AI, BigData & HPC Digest # 1 (May 7 - June 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>