<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The exceptional beauty of Doom 3 source code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today you will find a story about the source code of Doom 3 and how beautiful it is. 
 Yes, beautiful . Let me explain. 

 After the release of my vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The exceptional beauty of Doom 3 source code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/632/6e3/46b/6326e346bfe7d71e24fc85e3bd1707c7.png" alt="image"><br><br>  Today you will find a story about the source code of <i>Doom 3</i> and how beautiful it is. <br>  Yes, <i>beautiful</i> .  Let me explain. <br><a name="habracut"></a><br>  After the release of my video game <i>Dyad,</i> I decided to take a short break.  I finally read a few books and watched films that I had been putting in a long box for so long.  Then I worked on the European version of <i>Dyad</i> , but all this time I mostly waited for feedback from Sony's quality department, so I had more than enough time.  After a month of such a pastime, I seriously thought about what to do next.  I remembered that I was going to separate pieces of source code from <i>Dyad a</i> long time ago that I wanted to use in my new project. <br><br>  When I first started working on <i>Dyad</i> , it was a ‚Äútransparent‚Äù game engine with good functionality, and it turned out that thanks to my experience in previous projects.  Toward the end of the development of the game, he turned into a hopeless mess. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Over the last 6 weeks of developing <i>Dyad,</i> I have added 13k lines of code.  The main menu source MainMenu.cc alone expanded to 25,501 lines.  Once a beautiful code turned into a real mess from all #ifdef, function pointers, ugly SIMDs and assembler inserts - and I discovered the new term "code entropy".  Sadly looking at all this, I went on a journey through the Internet in search of other projects that would help me understand how other developers beautifully managed with hundreds of thousands of lines of code.  But after I looked at the code for a couple of big game engines, I was just discouraged;  my ‚Äúterrible‚Äù source code compared to the rest was even clearer! <br><br>  I continued my search, dissatisfied with this result.  In the end, I came across an <a href="http://fabiensanglard.net/doom3/index.php">interesting analysis of the <i>Doom 3</i> source code from <i>id Software</i> , written by Fabian Sangard</a> . <br><br>  I spent several days studying the source code of Doom 3 and reading Fabian's articles, after which I tweeted: <br><blockquote>  I spent some time studying the Doom3 source code.  This is probably the most understandable and cutest code I've ever seen. </blockquote><br>  And it was true.  Up to this point, I have never cared about the source code.  Yes, I, in fact, do not like too much to call myself a "programmer."  I'm good at it, but for me, programming lasts exactly until everything starts working.  After viewing the source code of Doom 3, I really learned to appreciate good programmers. <br><br>  *** <br>  So that you get some idea: <i>Dyad</i> contains 193k lines of code, all in C ++.  <i>Doom 3</i> is 601k, <i>Quake III</i> is 229k and <i>Quake II</i> is 136k.  These are big projects. <br><br>  When I was asked to write this article, I used this as an excuse to read some more source code for other games and articles on programming standards.  After a few days of my research, I would be embarrassed by my own tweet and it made me think - so what should be considered a ‚Äúbeautiful‚Äù source code?  I asked several of my fellow programmers what they thought it meant.  Their answers were obvious, but it still makes sense to bring them here: <br><br><ul><li>  The code must be grouped locally and uniformly functional: One function must do exactly one thing.  It should be clear what a particular function is doing. </li><li>  Local code should explain or at least point to the architecture of the entire system. </li><li>  The code must be documented "by itself".  Comments should be avoided in all possible situations.  Comments duplicate work for both reading and writing code.  If you need to comment on something, then most likely it should be rewritten from scratch. </li></ul><br>  For idTech 4, code standards are publicly available ( <a href="">.doc</a> ) and I can recommend them as worthy reading.  I will go over most of these standards and try to explain how they make the <i>Doom 3</i> code so beautiful. <br><br><h5>  Universal parsing and lexical parsing </h5><br>  One of the smartest things I saw in Doom is using their lexical analyzer and parser throughout the program.  All resource files are ascii files with a single syntax including: scripts, animation files, configs, etc .;  everything is the same.  This allows you to read and process all files with the same piece of code.  The parser is especially reliable, and supports the main subset of C ++.  The commitment to a single parser and lexical analyzer helps the rest of the engine components not to worry about data serialization, since the code responsible for this part of the application has already been written.  Due to this, the rest of the code becomes much clearer. <br><br><h5>  Const and strict parameters (Rigid Parameters) </h5><br>  The Doom code is rather strict, but (in my opinion) not strict enough with respect to const.  Const serves several reasons, which I am sure are ignored by too many programmers.  My rule is this: "const should be used everywhere, except in cases where it cannot be used."  I dream that all variables in C ++ will be const by default.  <i>Doom</i> almost always follows the ‚Äúno input-output‚Äù policy for parameters;  meaning that all parameters passed to a function are either input or output, and never combine this role in one person.  This simple trick allows you to see how much faster what happens to any variable when you pass it to a function.  For example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/511/515/8ff5115153f35b359b34f57cfb0bf78d.png" alt="image"><br><br>  The mere definition of this function already makes me happy! <br><br>  Only from a few things that immediately strike my eyes, very much already becomes clear: <br><ul><li>  idPlane is passed to the function as an immutable argument.  I can safely use the same plane after calling this function without checking for idPlane changes. </li><li>  I know that epsilon will not be changed inside the function (although it can be copied to another variable without problems and used to initialize it - this method will be unproductive) </li><li>  front, back, frontOnPlaneEdges and backOnPlaceEdges are OUTPUT variables.  They will be recorded. </li><li>  the final const modifier after the parameter list is my favorite.  It indicates that idSurface :: Split () cannot change the surface itself.  This is one of my favorite features in C ++, which I miss so much in other languages.  She lets me do something like this: <br>  void f (const idSurface &amp; s) { <br>  s.Split (....); <br>  } <br><br>  if Split would not have been defined as Split (...) const;  this code would not compile.  Now I will always know that any call to f () will not change the surface, even if f () is passed to the surface by another function or calls any of the Surface :: method () methods.  Const tells me a lot about this feature and also gives hints about the overall system architecture.  One reading of the declaration of this function makes it clear that the surfaces can be separated by planes dynamically.  Instead of changing the original surface, we will be returned new surfaces - front and back, and also, possibly, the side frontOnPlaneEdges and backOnPlaneEdges. </li></ul><br><br>  The rule of using const and the absence of "input-output" parameters in my assessment is one of the most important things separating good code from delightful code.  Such an approach makes it easier not only to understand the system itself, but also to change or refactor it. <br><br><h5>  Minimalist comments </h5><br>  This item, of course, is more concerned with the style of writing code, but nevertheless - there is such a wonderful thing in <i>Doom</i> as the absence of excessive commenting.  I have seen in my practice too much code, very similar to similar: <br><img src="https://habrastorage.org/getpro/habr/post_images/77b/5d9/947/77b5d994723b31433305b2550c15dfc8.png" alt="image"><br>  Such techniques, in my opinion, very, very annoying thing.  Why?  Because I can already name what this code does, you just have to look at its name.  If the purpose of the method from its name is not clear to me, then its name should be changed.  If the name is too long, shorten it.  If it cannot be changed and is already reduced - well, then you can use the comment.  All programmers from school are taught that commenting is good;  but it is not so.  Comments are bad until they are needed.  But they are extremely rare.  The creators of <i>Doom</i> did a responsible job in order to keep the number of comments to a minimum.  Using idSurface :: Split () as an example, let's look at how it is commented out: <br><br>  // splits the surface into front and back surfaces, the surface itself remains unchanged <br>  // frontOnPlaneEdges and backOnPlaneEdges optionally store the indexes of the vertices that lie on the edges of the dividing plane <br>  // returns SIDE_? <br><br>  The first line is completely redundant.  We already know all this from the definition of a function.  The second and third lines carry some new information.  We could remove the second line, but this could cause a potential ambiguity. <br><br>  For the most part, the <i>Doom</i> code is very harsh with respect to your own comments, which makes it much easier to read.  I know that this may be a matter of style for some people, but it seems to me that there definitely is a ‚Äúright‚Äù way to do it.  For example, what should happen if someone changes the function and removes the constant at the end?  In this case, for the external code, the function call will change, and now the comment will be unrelated to the code.  Unauthorized comments harm the readability and accuracy of the code, so the code gets worse. <br><br><h5>  Indentation </h5><br>  <i>Doom is</i> not inclined to waste free vertical screen space. <br>  Here is an example from t_stencilShadow :: R_ChopWinding (): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a29/eef/9b0/a29eef9b089b58e484c3328c38de5bd3.png" alt="image"><br><br>  I can read the whole algorithm without problems, because it fits on 1/4 of my screen, leaving the other 3/4 to figure out how this code can relate to the surrounding it.  I've seen too much of this in my life: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05c/599/77b/05c59977b9a3116717c87e9daca1f453.png" alt="image"><br><br>  There will be one more remark falling under the category "style".  I have been programming in the style of the last example for more than 10 years, and forced myself to switch to a more compact code only six years ago while working on one of the projects.  I'm glad I switched in time. <br><br>  The second method takes 18 lines relative to the 11 lines in the first.  Almost twice as many lines of code with <i>the same</i> functionality.  In addition, the next piece of code clearly does not fit on my screen.  And what's in it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23a/f8b/67e/23af8b67ed019388587e27341135550c.png" alt="image"><br><br>  This code does not make any sense without a previous piece with a loop.  If <i>id</i> didn't save vertical space, then their code would become much harder to read, support and immediately lose in beauty. <br><br>  The other thing that <i>id</i> decided to accept as a permanent rule, I also strongly support - this solution is always to use {}, even when it is not necessary.  I have seen too much code like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40a/408/d5b/40a408d5b0873309637119b12321deaa.png" alt="image"><br><br>  I could not find a single example in the <i>id</i> code, where they would at least once miss {}.  If you omit the additional {}, then the analysis of the while () block will take several times longer than it should.  In addition, any revision turns into real suffering - it‚Äôs enough to imagine that I will need to insert an if-condition on the else if (c&gt; d) path. <br><br><h5>  Minimal pattern usage </h5><br>  <i>id</i> broke one of the greatest bans in the C ++ world.  They rewrote all the required STL functions.  Personally, I am in the STL relationship ‚Äúfrom love to hate one step‚Äù.  In <i>Dyad,</i> I used it in debug builds to manage dynamic resources.  In the release, I packed all the resources so that they could be loaded as quickly as possible, and they stopped using the STL functionality.  STL is quite a handy thing because it gives access to basic data structures;  its main problem is that its use leads to ugly code and is error prone.  For example, take a look at the std :: vector class.  Let's say if I need to sort through all the elements: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/59c/300/42459c3004798d92f1e3997c7afe7da6.png" alt="image"><br><br>  In C ++ 11, the same thing looks a lot easier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/d6e/522/2a0d6e5225abeb825ce495038922e08a.png" alt="image"><br><br>  Personally, I do not like the use of auto, it seems to me that it makes the code easier to write, but harder to read.  I sometimes used auto in past years, but now it seems to me that this was the wrong decision.  I'm not even going to start discussing the absurdity of some of the algorithms on STL, such as std: for_each or std :: remove_if. <br><br>  Removing a value from std :: vector is also a horror: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/161/8e8/5f1/1618e85f1c1c21c5dea77935baa94e8c.png" alt="image"><br><br>  Imagine, each programmer must type this line correctly each time! <br><br>  <i>id</i> removes all ambiguity: they roll out their own base containers, string class, etc.  They try to make them more specific than their STL counterparts ‚Äî perhaps to make them easier to understand.  They are minimally template-based and use their own memory allocators.  And the STL code is littered with the constant use of templates so that it is simply impossible to read. <br><br>  C ++ code quickly becomes unmanageable and ugly, so programmers constantly have to make their efforts to get the opposite effect.  And so that you understand how far things can go, look at this STL source code.  Microsoft's implementation of STL and GCC is one of the worst source codes I've ever seen.  Even if the programmer blows away any specks of dust from the template code, the code still turns into a complete mess.  For an example, take a look at the Loki library from Andrei Alexandrescu, or the boost libraries - these lines are written by one of the best C ++ programmers in the world, and even his efforts to make them as beautiful as possible were able to degenerate only into ugly and completely unreadable code. <br><br>  How does <i>id</i> solve this problem?  They simply do not try to bring everything to a ‚Äúcommon denominator‚Äù by over-generalizing their functions.  They have classes HashTable and HashIndex, the first requires the type of the key to be const char *, and the second - a pair of int-&gt; int.  In the case of C ++, such a decision is considered to be bad - ‚Äúshould‚Äù create a single class HashTable, and write two different processing in it for KeyType = const char * and &lt;int, int&gt;.  But what made the <i>id</i> , also correctly, and moreover - made their code many times more beautiful. <br><br>  It is not difficult to verify this; it is enough to trace the contrast between the ‚Äúgood C ++ programming style‚Äù to generate the hash and the way id handled it. <br><br>  To many, it seems like a good idea to create a special class of calculations that can be passed as a parameter to the HashTable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ea/3f4/ca1/6ea3f4ca1deb0606f11b47736bf961d8.png" alt="image"><br><br>  it can be specified as a specific type: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/08b/d48/c4908bd48a1f74a287a781c05f361210.png" alt="image"><br><br>  Now you can pass ComputeHashForType as a HashComputer for HashTable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47a/9bf/e9d/47a9bfe9d2b033b61efa5686ca2b7f39.png" alt="image"><br><br>  Similarly, I did at home.  It looks like a smart decision, but ... how ugly!  What if we end up with a large number of parameters in the template?  With memory allocator?  With debugging?  Then we will have something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d33/309/740/d3330974032ea1a8f12bcc7746c9388d.png" alt="image"><br><br>  Brutal definition of a function, isn't it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2c/4a1/9ed/f2c4a19ede592c8d8cb041e5e119b581.png" alt="image"><br><br>  So what is this all about?  I could hardly find the name of the method without a bright syntax highlighting.  It is likely that the definition of a function will take up more space than its body.  Definitely hard to read and not too beautiful. <br><br>  I have seen how other engines manage with a similar disorder method of offloading the assignment of function arguments using billions of typedefs.  This is even worse!  Maybe the code ‚Äúright in front of you‚Äù will become clearer, but there will be an even greater gap between the system and the current code than it was before, and this code will no longer indicate the design of the entire system - which violates our principle of beauty.  For example, we have the code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/139/044/6e6/1390446e62ef234a9dcdb8aba5c025d7.png" alt="image"><br><br>  and <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a84/ebd/a70/a84ebda707c967fb5b0a3d7047f000d7.png" alt="image"><br><br>  and you used them together and did something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/bec/0fe/fcfbec0fe945fed07b7b4267ef5b20a7.png" alt="image"><br><br>  Perhaps the StringHashTable memory allocator named StringAllocator does not contribute to global memory, which can confuse you.  You will have to look through all the code, find out that the StringHashTable is in fact typedef from confusing patterns, go through the source code of the pattern, find another allocator, find its description ... a nightmare, just a nightmare. <br><br>  <i>Doom</i> goes against the principles of C ++ logic: the code is written as specific as possible, using generalizations only where it makes sense.  What does the HashTable of <i>Doom do</i> when it needs to generate a hash or something else?  It calls idStr :: GetHash (), because the only type of key it accepts is const char *.  What happens if another key is needed?  It seems to me that they template the key and simply force the call to key.getHash (), and the compiler ensures that the key types have an int getHash () method. <br><br><h5>  Remains in the "inheritance" from C </h5><br>  I don‚Äôt know exactly how many of the <i>id</i> programmers in the 90s are working for the company now, but at least John Carmack himself has a lot of programming experience in C. All the id games before <i>Quake III</i> were written in C. I met C ++ programmers who don‚Äôt had a lot of programming experience in C, so their code was too C ++ zipper.  The last example was just one of many - here are others that I meet quite often: <br><br><ul><li>  Frequent use of get / set methods </li><li>  use stringstream </li><li>  operator overloading. </li></ul><br>  id strictly follows all these cases. <br><br>  It often happens that someone creates a class in this way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/b1a/e9a/8dcb1ae9ac2818fe00c92a9015215669.png" alt="image"><br><br>  This is a waste of lines of code and the subsequent time to read it.  This option will eat more of your time than <br><br><img src="https://habrastorage.org/getpro/habr/post_images/766/f4c/c48/766f4cc486c0ee182a494abc26afa2eb.png" alt="image"><br><br>  And what if you often have to increase var by some number n? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/52c/263/42052c263c2f213f6d9d9e5eb8bb7ef9.png" alt="image"><br><br>  in comparison with <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ec/66f/d09/6ec66fd09835501a1e4deee3b01c71be.png" alt="image"><br><br>  The first example is much easier to write and read. <br><br>  id does not use stringstream.  stringstream contains one of the most important "bastardization" operator overload, which I have ever met: &lt;&lt;. <br><br>  For example, <br><br><img src="http://img.gawkerassets.com/img/18bh2kv5mjeygpng/original.png" alt="image"><br><br>  It's not beautiful.  This method has a strong advantage: you can define the equivalent of the toString () function from Java for a particular class that will affect class variables, but the syntax will become too inconvenient, and id decides not to use this method.  The choice to printf () instead of stringstream makes the code easier to read, and I think this choice is the right one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/532/7fb/03b/5327fb03b29c14d3440dd56523fbfd64.png" alt="image"><br><br>  Much better! <br><br>  The syntax of the &lt;&lt; operator for SomeClass is ridiculous: <br><br><img src="http://img.gawkerassets.com/img/18bh2n7zzyvdtpng/original.png" alt="image"><br><br>  [Note: John Carmack once remarked that statistical code analysis programs helped to find out that their common bug was caused by incorrect parameters in printf (). I wonder if they switched to stringstream in <i>Rage</i> because of this? .. GCC and clang both They report such an error when using the -Wall flag, so that you can all see for yourself without resorting to costly analyzers to look for these errors.] <br><br>  Another principle that makes the <i>Doom</i> code so beautiful is the minimal use of operator overloading.  This is a very popular and convenient feature, introduced in C ++, that allows you to do something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/539/da7/76b539da751f21c260038832d5f9d4ec.png" alt="image"><br><br>  Without overloading, these operations will become less obvious and take longer to write and read.  This is where <i>Doom</i> stops.  I saw the code that goes on.  I‚Äôve seen code that overloads the '%' operator to denote the scalar product of vectors, or the Vector * Vector operator that performs vector multiplication.  It makes no sense to start the operator * for such an action, which will be feasible only in 3D.  After all, if you want to do some_2d_vec * some_2d_vec, then what would you do?  What about 4d or more?  That is why the principle of minimal intervention from id is correct - it does not leave us any discrepancies. <br><br><h5>  Horizontal indents </h5><br>  One of the most important things I learned from the Doom source code was a simple style change.  I'm used to my classes look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f5/f10/3fe/4f5f103fec32c1e6845b4bdf9c1b8acd.png" alt="image"><br><br>  According to the standard code for <i>Doom 3</i> , <i>id</i> uses a real tab, which corresponds to 4 spaces.  The same default tab allows all programmers to align the definitions of their classes horizontally without any hesitation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccb/639/ab2/ccb639ab279104de7e3742dd442a8bac.png" alt="image"><br><br>  They prefer not to make the definition of inline functions inside the class definition.  The only case I met was when the code was written on the same line as the function declaration.  Most likely, this practice is not the norm and is not approved.  This way of organizing class definitions makes them easy to read.  It may take you a little more time to reprint the ones already entered to define the methods: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67f/28b/d40/67f28bd402f67bea967c23c381b6449b.png" alt="image"><br><br>  I myself am against excessive typing on the keyboard.  The main thing that I need is to do my job as quickly as possible - but in this situation, a small bust of typing in the definition of a class pays off more than once or twice in the case when the programmer has to view the definition of the class.  There are a few more examples of coding style that are described in the <i>Doom 3 Coding Standards</i> ( <a href="http://kotaku.com/5975610/%2520ftp://ftp.idsoftware.com/idstuff/doom3/source/CodeStyleConventions.doc">.doc</a> ) document, which is responsible for all the beauty of the <i>Doom 3</i> source code. <br><br><h5>  Method Names </h5><br>  In my opinion, the rules for naming methods in <i>Doom</i> still lack something.  Personally, I like to use this rule in my work: all method names must begin with verbs, and exceptions are only those cases where this cannot be implemented. <br><br>  For example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/798/bed/842/798bed842eeffc074ec9b8621ba85f3c.png" alt="image"><br><br>  much better than: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b16/385/61a/b1638561a774d8a71857f528f41cf98c.png" alt="image"><br><br><h5>  Yes, he is incredibly beautiful. </h5><br>  I am glad that this article saw the light, because it allowed me to reflect on the topic of what we mean by the beauty of the code.  To be honest, I'm not sure that I understood anything.  It is possible that all my assessments are too subjective.  Personally for myself, I noted at least a couple of very important things - the style of indents and the constant use of constants. <br><br>  Many of the choices in the code style are my personal preferences;  I have no doubt that other programmers will be completely different.  In my opinion, the burden of choosing the style of writing code rests entirely on the shoulders of the one who is going to write and read it, but even this should be thought about from time to time. <br><br>  I would like to advise everyone to take a look at the source code of <i>Doom 3</i> , because you will not see such source code every day: here you have a complete set, from the design of the system architecture to tabulation between characters. <br><br>  <i>Shawn McGrath</i> is a game developer living in Toronto, the creator of the popular psychedelic game for the Playstation 3 - <i>Dyad</i> puzzle-race.  We advise you to take a look at his <a href="http://www.dyadgame.com/">game</a> and follow him on <a href="https://twitter.com/DyadGame">Twitter</a> . <br><br><h5>  Notes </h5><br>  <b>Note</b>  <b>John Carmack</b> <br><br>  Thank!  A few comments: <br><br>  I continue to think that in a certain way, the Quake 3 code is still better, because it became the top of the evolution of my C-style - unlike the first attempt at programming the C ++ engine, but this can only be my illusion due to the small number of lines in the first , or due to the fact that I have not looked into him for a dozen years.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that ‚Äúgood C ++‚Äù is better than ‚Äúgood C‚Äù in terms of readability, while otherwise languages ‚Äã‚Äãare equivalent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I was doing it with C ++ in Doom 3 - the fact is that I was an experienced C programmer with OOP skills from the time of NeXT and Objective-C, so I started writing C ++ code without full learning all the principles of using language. Looking back, I can notice that I strongly regret that I did not read Effective C ++ and something else on this subject. A couple of other programmers had enough experience in C ++, but for the most part they followed my stylistic choices.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I didn‚Äôt trust templates for many years, and now I use them cautiously, but I somehow decided that the charms of strong typing outweigh the balance in the direction opposite to the strange code in the header files. So the controversy surrounding the STL still does not subside with us in id, and now they have received an additional ‚Äúspark‚Äù. Returning to the days when the development of Doom 3 began, I can almost certainly say that using STL would definitely be a bad idea, but now ... there are many reasonable arguments for, even in the case of games. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I have become a terrible "const nazi", and I report to any programmer who does not make a variable or parameter a constant, if they could be it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With regards to me personally, my own evolution directs me towards a more functional programming style, which means weaning off from a large number of old habits and a departure from some OOP techniques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[</font></font><a href="http://www.altdevblogaday.com/"><i></i></a><i><a href="http://www.altdevblogaday.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.altdevblogaday.com</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><br>  <b>Note</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Translation</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I myself came across </font></font><a href="http://fabiensanglard.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabien blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about fifteen years ago, and I can safely recommend it to all who are interested - if not for the thoughtful reading, at least for the sake of inspiration. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the "clean" code - on Twitter, I asked Carmack not so long ago what he would recommend to read on the topic. </font><font style="vertical-align: inherit;">He strongly advised the book </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Art of the Readable Code"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://www.amazon.com/Art-Readable-Code-Dustin-Boswell/dp/0596802293"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amazon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div><p>Source: <a href="https://habr.com/ru/post/166113/">https://habr.com/ru/post/166113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166093/index.html">We use vector SVG images in Android applications, or how to kill screen fragmentation and not lose quality (pros, cons, features)</a></li>
<li><a href="../166097/index.html">We write the plug-in for XBMC. So far without blackjack and all the rest</a></li>
<li><a href="../166105/index.html">CES Results: Samsung's New Cameras at the International Consumer Electronics Show</a></li>
<li><a href="../166107/index.html">On Saturday, Kim Dotcom will present the file hosting service Mega</a></li>
<li><a href="../166109/index.html">What we should build DOM</a></li>
<li><a href="../166119/index.html">How to withdraw money from the App Store to Payoneer card</a></li>
<li><a href="../166121/index.html">What is more advantageous to contests than direct advertising, or how we came up with a contest for diafan.CMS</a></li>
<li><a href="../166125/index.html">Phosphors. A bit of theory and practice</a></li>
<li><a href="../166127/index.html">John Resig on the internationalization of JavaScript applications</a></li>
<li><a href="../166131/index.html">Site vulnerability yota.ru fixed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>