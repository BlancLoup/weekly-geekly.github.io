<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comet for ASP.NET do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, as part of the development of a large ASP.NET project, the following subtask arose: to implement a visual display of tabular data, up...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comet for ASP.NET do it yourself</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, as part of the development of a large ASP.NET project, the following subtask arose: to implement a visual display of tabular data, updated in real-time mode.  The update scheme is quite simple, namely: data are sent to the server via the QueryString, which should replace the outdated data on the page as quickly as possible, without needing to refresh this page.  The first solution that immediately occurred to me was to use the already-accepted AJAX timer technique, say, every 5 seconds.  However, there were immediately obvious shortcomings in the use of this approach: firstly, a rather impressive number of potential customers pulling the server every 5 seconds with the creation of a new connection each time, and secondly, it‚Äôs still a rather rough real-time emulation, because the data to the server hypothetically can come even once a second (or they may not come even for a few minutes, and this already refers to the ‚Äúfirst‚Äù). <br><br>  The idea of ‚Äã‚Äãthe solution came quite unexpectedly from a work colleague who shared a link to <a href="http://habrahabr.ru/blogs/webdev/76144/">an article on Habr√©</a> describing the implementation of the Comet technology in Perl in order to create a web chat.  " <i>Comet is what you need!</i> ", We thought, and I started to figure out how this thing can be screwed to ASP.NET.  What, in fact, will be discussed under the cut. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, let's see what is Comet.  This is what Wikipedia tells us about this: <br><br>  <b>Comet</b> (in web development) is a neologism that describes the model of the web application, in which a permanent HTTP connection allows the web server to send (push) data to the browser, without an additional request from the browser.  Comet is a hyperonym used to refer to a variety of techniques that allow such interactions to be achieved.  What these methods have in common is that they are based on technologies directly supported by the browser, such as JavaScript, and not on proprietary plugins.  Theoretically, the Comet approach is different from the original concept of the world wide web, in which the browser requests the page in whole or in part in order to refresh the page.  However, in practice, Comet applications typically use <b>Ajax with long polling</b> to check for new information on the server. <br><br>  So, the keywords we can learn from this definition for ourselves are ‚ÄúAjax with long polling‚Äù.  What is it and what is it eaten with?  When using the ‚Äúlong polling‚Äù technology, the client sends a request to the server and ... waits.  Waiting for new data to appear on the server.  As soon as the data has arrived, the server sends them to the client, after which it sends a new request and waits again.  An alternative technology of "infinite query", implemented, for example, through the so-called.  "Forever iframe" (you can read a little more <a href="http://habrahabr.ru/blogs/webdev/80466/">here</a> ), is not always applicable, because  such a thing as timeout has not been canceled. <br><br>  Well, the task is very clear - you need to implement the aforementioned long polling with improvised means (AJAX + ASP.NET).  This also leads to the first problem: how to preserve incoming requests and not to issue responsa until the server has fresh data that could be given to clients (and we obviously have more than one client).  And here asynchronous HTTP Handler comes to the rescue. <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">interface</font> IHttpAsyncHandler : IHttpHandler <br> { <br> IAsyncResult BeginProcessRequest( <font color="#2B91AF">HttpContext</font> ctx, <br> AsyncCallback cb, <br> <font color="#0000ff">object</font> obj); <br> <font color="#0000ff">void</font> EndProcessRequest(IAsyncResult ar); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Notice that we will inherit our class not from the IHttpHandler interface, but from IHttpAsyncHandler, which will bring two new methods along with the familiar ProcessRequest method to our implementation: BeginProcessRequest and EndProcessRequest.  In particular, the first of them will be of interest to us, since  Immediately at the beginning of processing a request, we need to grab this request and not let go until X-hour comes.  As you can see, BeginProcessRequest returns an object that implements the IAsyncResult interface. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">interface</font> IAsyncResult <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">object</font> AsyncState            { <font color="#0000ff">get</font> ; } <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> CompletedSynchronously { <font color="#0000ff">get</font> ; } <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> IsCompleted            { <font color="#0000ff">get</font> ; } <br> <font color="#0000ff">public</font> WaitHandle AsyncWaitHandle     { <font color="#0000ff">get</font> ; } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We will create a new class that will implement the specified interface, and will also serve as a repository for the request data transferred to the BeginProcessRequest and our own clientGuid parameter, which we will use later as a unique identifier of the client connected to the server in order to somehow identify its requests. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> CometAsyncRequestState : IAsyncResult <br> { <br> <font color="#0000ff">private</font> <font color="#2B91AF">HttpContext</font> _currentContext; <br> <font color="#0000ff">private</font> AsyncCallback _asyncCallback; <br> <font color="#0000ff">private</font> Object _extraData; <br> <br> <font color="#0000ff">private</font> Boolean _isCompleted; <br> <font color="#0000ff">private</font> <font color="#2B91AF">Guid</font> _clientGuid; <br> <font color="#0000ff">private</font> ManualResetEvent _callCompleteEvent = <font color="#0000ff">null</font> ; <br> <br> <font color="#0000ff">public</font> CometAsyncRequestState( <font color="#2B91AF">HttpContext</font> currentContext, AsyncCallback asyncCallback, Object extraData) <br> { <br> _currentContext = currentContext; <br> _asyncCallback = asyncCallback; <br> _extraData = extraData; <br> <br> _isCompleted = <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> CompleteRequest() <br> { <br> _isCompleted = <font color="#0000ff">true</font> ; <br> <br> <font color="#0000ff">lock</font> ( <font color="#0000ff">this</font> ) <br> { <br> <font color="#0000ff">if</font> (_callCompleteEvent != <font color="#0000ff">null</font> ) <br> _callCompleteEvent.Set(); <br> } <br> <br> <font color="#0000ff">if</font> (_asyncCallback != <font color="#0000ff">null</font> ) <br> { <br> _asyncCallback( <font color="#0000ff">this</font> ); <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#2B91AF">HttpContext</font> CurrentContext <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _currentContext; <br> } <br> <font color="#0000ff">set</font> <br> { <br> _currentContext = <font color="#0000ff">value</font> ; <br> } <br> } <br> <br> <font color="#0000ff">public</font> AsyncCallback AsyncCallback <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _asyncCallback; <br> } <br> <font color="#0000ff">set</font> <br> { <br> _asyncCallback = <font color="#0000ff">value</font> ; <br> } <br> } <br> <br> <font color="#0000ff">public</font> Object ExtraData <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _extraData; <br> } <br> <font color="#0000ff">set</font> <br> { <br> _extraData = <font color="#0000ff">value</font> ; <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#2B91AF">Guid</font> ClientGuid <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _clientGuid; <br> } <br> <font color="#0000ff">set</font> <br> { <br> _clientGuid = <font color="#0000ff">value</font> ; <br> } <br> } <br> <br> <font color="#008000">// IAsyncResult implementations</font> <br> <font color="#0000ff">public</font> Boolean CompletedSynchronously <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> } <br> <br> <font color="#0000ff">public</font> Boolean IsCompleted <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _isCompleted; <br> } <br> } <br> <br> <font color="#0000ff">public</font> Object AsyncState <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> _extraData; <br> } <br> } <br> <br> <font color="#0000ff">public</font> WaitHandle AsyncWaitHandle <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">lock</font> ( <font color="#0000ff">this</font> ) <br> { <br> <font color="#0000ff">if</font> (_callCompleteEvent == <font color="#0000ff">null</font> ) <br> _callCompleteEvent = <font color="#0000ff">new</font> ManualResetEvent( <font color="#0000ff">false</font> ); <br> <br> <font color="#0000ff">return</font> _callCompleteEvent; <br> } <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As you can see, until we call the CompleteRequest function ourselves, the request will not be considered complete.  Great - what we need.  It remains only somewhere to store these incoming requests.  For this function, as well as for the query processing function, we will create a static class CometClientProcessor: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> CometClientProcessor <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">static</font> Object _lockObj; <br> <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#2B91AF">List</font> &lt;CometAsyncRequestState&gt; _clientStateList; <br> <br> <font color="#0000ff">static</font> CometClientProcessor() <br> { <br> _lockObj = <font color="#0000ff">new</font> Object(); <br> _clientStateList = <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;CometAsyncRequestState&gt;(); <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> PushData( <font color="#2B91AF">String</font> pushedData) <br> { <br> <font color="#2B91AF">List</font> &lt;CometAsyncRequestState&gt; currentStateList = <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;CometAsyncRequestState&gt;(); <br> <br> <font color="#0000ff">lock</font> (_lockObj) <br> { <br> <font color="#0000ff">foreach</font> (CometAsyncRequestState clientState <font color="#0000ff">in</font> _clientStateList) <br> { <br> currentStateList.Add(clientState); <br> } <br> } <br> <br> <font color="#0000ff">foreach</font> (CometAsyncRequestState clientState <font color="#0000ff">in</font> currentStateList) <br> { <br> <font color="#0000ff">if</font> (clientState.CurrentContext.Session != <font color="#0000ff">null</font> ) <br> { <br> clientState.CurrentContext.Response.Write(pushedData); <br> clientState.CompleteRequest(); <br> } <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> AddClient(CometAsyncRequestState state) <br> { <br> <font color="#2B91AF">Guid</font> newGuid; <br> <br> <font color="#0000ff">lock</font> (_lockObj) <br> { <br> <font color="#0000ff">while</font> ( <font color="#0000ff">true</font> ) <br> { <br> newGuid = <font color="#2B91AF">Guid</font> .NewGuid(); <br> <font color="#0000ff">if</font> (_clientStateList.Find(s =&gt; s.ClientGuid == newGuid) == <font color="#0000ff">null</font> ) <br> { <br> state.ClientGuid = newGuid; <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <br> _clientStateList.Add(state); <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> UpdateClient(CometAsyncRequestState state, <font color="#2B91AF">String</font> clientGuidKey) <br> { <br> <font color="#2B91AF">Guid</font> clientGuid = <font color="#0000ff">new</font> <font color="#2B91AF">Guid</font> (clientGuidKey); <br> <br> <font color="#0000ff">lock</font> (_lockObj) <br> { <br> CometAsyncRequestState foundState = _clientStateList.Find(s =&gt; s.ClientGuid == clientGuid); <br> <br> <font color="#0000ff">if</font> (foundState != <font color="#0000ff">null</font> ) <br> { <br> foundState.CurrentContext = state.CurrentContext; <br> foundState.ExtraData = state.ExtraData; <br> foundState.AsyncCallback = state.AsyncCallback; <br> } <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> RemoveClient(CometAsyncRequestState state) <br> { <br> <font color="#0000ff">lock</font> (_lockObj) <br> { <br> _clientStateList.Remove(state); <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  CometClientProcessor contains a list of currently held requests, AddClient functions for adding rekvests (when a new client is connected), UpdateClient for updating rekvests (when the already attached client sends a new request) and RemoveClient for removing rekvests (when the client disconnects), as well as the main PushData method.  To "push" for clarity, we will be the simplest data, namely the string that comes to the server through a parameter in the URL.  As you can see, everything is extremely simple - we run over the current retained requests, write down the response data from the server to the response, and call the CompleteRequest function, which releases the request, and sends a response to the client.  The call to PushData is done in this example from the Page_Load function of our single page: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">protected</font> <font color="#0000ff">void</font> Page_Load( <font color="#0000ff">object</font> sender, <font color="#2B91AF">EventArgs</font> e) <br> { <br> <font color="#0000ff">if</font> (!IsPostBack) <br> { <br> <font color="#0000ff">if</font> (Request.QueryString[ <font color="#A31515">"x"</font> ] != <font color="#0000ff">null</font> ) <br> { <br> CometClientProcessor.PushData(Request.QueryString[ <font color="#A31515">"x"</font> ].ToString()); <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As mentioned above, the data comes to us through a parameter in the URL, in this case, for clarity, it bears the name "x".  In the server part, it remains only to implement, in fact, the asynchronous handler itself.  But first, let's turn to the client part and write (not without the help of the jQuery library) a few rather trivial JavaScript functions: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> clientGuid <br> <br> $( <font color="#0000ff">document</font> ).ready( <font color="#0000ff">function</font> () { <br> <font color="#0000ff">var</font> str = window.location.href; <br> <font color="#0000ff">if</font> (str.indexOf( <font color="#A31515">"?"</font> ) &lt; 0) <br> Connect(); <br> }); <br> <br> $(window).unload( <font color="#0000ff">function</font> () { <br> <font color="#0000ff">var</font> str = window.location.href; <br> <font color="#0000ff">if</font> (str.indexOf( <font color="#A31515">"?"</font> ) &lt; 0) <br> Disconnect(); <br> }); <br> <br> <font color="#0000ff">function</font> SendRequest() { <br> <font color="#0000ff">var</font> url = <font color="#A31515">'./CometAsyncHandler.ashx?cid='</font> + clientGuid; <br> $.ajax({ <br> type: <font color="#A31515">"POST"</font> , <br> url: url, <br> success: ProcessResponse, <br> error: SendRequest <br> }); <br> } <br> <br> <font color="#0000ff">function</font> Connect() { <br> <font color="#0000ff">var</font> url = <font color="#A31515">'./CometAsyncHandler.ashx?cpsp=CONNECT'</font> ; <br> $.ajax({ <br> type: <font color="#A31515">"POST"</font> , <br> url: url, <br> success: OnConnected, <br> error: ConnectionRefused <br> }); <br> } <br> <br> <font color="#0000ff">function</font> Disconnect() { <br> <font color="#0000ff">var</font> url = <font color="#A31515">'./CometAsyncHandler.ashx?cpsp=DISCONNECT'</font> ; <br> $.ajax({ <br> type: <font color="#A31515">"POST"</font> , <br> url: url <br> }); <br> } <br> <br> <font color="#0000ff">function</font> ProcessResponse(transport) { <br> $( <font color="#A31515">"#contentWrapper"</font> ).html(transport); <br> SendRequest(); <br> } <br> <br> <font color="#0000ff">function</font> OnConnected(transport) { <br> clientGuid = transport; <br> SendRequest(); <br> } <br> <br> <font color="#0000ff">function</font> ConnectionRefused() { <br> $( <font color="#A31515">"#contentWrapper"</font> ).html( <font color="#A31515">"Unable to connect to Comet server. Reconnecting in 5 seconds..."</font> ); <br> setTimeout(Connect(), 5000); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As soon as the document is loaded, we check the URL for the presence of parameters in it (the parameterized URL, once again let me remind you - this is the transfer of data to the server for ‚Äúpushing‚Äù) and call the Connect function.  That, in turn, is already beginning to communicate with our handler.  Service words that define an action (CONNECT / DISCONNECT), as we can see, are transmitted for simplicity through the cpsp parameter.  Accordingly, Connect should initiate an AddClient call on the server, and Disconnect should initiate RemoveClient.  When the connection is established and the client has received its clientGuid, the SendRequest function is called, which will ‚Äúlongpoll‚Äù the server until the client decides to disconnect from it.  Each SendRequest will initiate the execution of the UpdateClient function on the server, which for this client will update the context and the return point (callback). <br><br>  Well, almost everything is ready, the time has come to implement the core of the whole above-presented mechanism - the asynchronous handler. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">enum</font> ConnectionCommand <br> { <br> CONNECT, <br> DISCONNECT <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> ConnectionProtocol <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">String</font> PROTOCOL_GET_PARAMETER_NAME = <font color="#A31515">"cpsp"</font> ; <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#2B91AF">String</font> CLIENT_GUID_PARAMETER_NAME = <font color="#A31515">"cid"</font> ; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">&lt;%@ WebHandler Language= <font color="#A31515">"C#"</font> Class= <font color="#A31515">"CometAsyncHandler"</font> %&gt; <br> <br> <font color="#0000ff">using</font> System; <br> <font color="#0000ff">using</font> System.Web; <br> <br> <font color="#0000ff">using</font> DevelopMentor; <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> CometAsyncHandler : IHttpAsyncHandler, System.Web.SessionState.IRequiresSessionState <br> { <br> <font color="#0000ff">static</font> <font color="#0000ff">private</font> ThreadPool _threadPool; <br> <br> <font color="#0000ff">static</font> CometAsyncHandler() <br> { <br> _threadPool = <font color="#0000ff">new</font> ThreadPool(2, 50, <font color="#A31515">"Comet Pool"</font> ); <br> _threadPool.PropogateCallContext = <font color="#0000ff">true</font> ; <br> _threadPool.PropogateThreadPrincipal = <font color="#0000ff">true</font> ; <br> _threadPool.PropogateHttpContext = <font color="#0000ff">true</font> ; <br> _threadPool.Start(); <br> } <br> <br> <font color="#0000ff">public</font> IAsyncResult BeginProcessRequest( <font color="#2B91AF">HttpContext</font> ctx, AsyncCallback cb, Object obj) <br> { <br> CometAsyncRequestState currentAsyncRequestState = <font color="#0000ff">new</font> CometAsyncRequestState(ctx, cb, obj); <br> _threadPool.PostRequest( <font color="#0000ff">new</font> WorkRequestDelegate(ProcessServiceRequest), currentAsyncRequestState); <br> <br> <font color="#0000ff">return</font> currentAsyncRequestState; <br> } <br> <br> <font color="#0000ff">private</font> <font color="#0000ff">void</font> ProcessServiceRequest(Object state, <font color="#2B91AF">DateTime</font> requestTime) <br> { <br> CometAsyncRequestState currentAsyncRequestState = state <font color="#0000ff">as</font> CometAsyncRequestState; <br> <br> <font color="#0000ff">if</font> (currentAsyncRequestState.CurrentContext.Request.QueryString[ConnectionProtocol.PROTOCOL_GET_PARAMETER_NAME] == <br> ConnectionCommand.CONNECT.ToString()) <br> { <br> CometClientProcessor.AddClient(currentAsyncRequestState); <br> currentAsyncRequestState.CurrentContext.Response.Write(currentAsyncRequestState.ClientGuid.ToString()); <br> currentAsyncRequestState.CompleteRequest(); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (currentAsyncRequestState.CurrentContext.Request.QueryString[ConnectionProtocol.PROTOCOL_GET_PARAMETER_NAME] == <br> ConnectionCommand.DISCONNECT.ToString()) <br> { <br> CometClientProcessor.RemoveClient(currentAsyncRequestState); <br> currentAsyncRequestState.CompleteRequest(); <br> } <br> <font color="#0000ff">else</font> <br> { <br> <font color="#0000ff">if</font> (currentAsyncRequestState.CurrentContext.Request.QueryString[ConnectionProtocol.CLIENT_GUID_PARAMETER_NAME] != <font color="#0000ff">null</font> ) <br> { <br> CometClientProcessor.UpdateClient(currentAsyncRequestState, <br> currentAsyncRequestState.CurrentContext.Request.QueryString[ConnectionProtocol.CLIENT_GUID_PARAMETER_NAME].ToString()); <br> } <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> EndProcessRequest(IAsyncResult ar) <br> { <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> ProcessRequest( <font color="#2B91AF">HttpContext</font> context) <br> { <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> IsReusable <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  After all of the above, the only question that may arise from an attentive reader is "why use custom tredpool"?  The answer is quite simple, though not entirely obvious: in order to ‚Äúrelease‚Äù the ASP.NET workflow workflow as quickly as possible, so that it can continue processing incoming requests, and transfer the request to the ‚Äúinternal‚Äù flow directly.  If this is not done, then with a sufficiently large number of incoming requests, a banal ‚Äúplug‚Äù may occur for a reasonably ridiculous at first glance: ‚ÄúASP.NET has run out of workflows‚Äù.  For the same reason, neither the asynchronous delegate excited by the BeginInvoke method, nor the standard threadPool.QueueUserWorkItem method can be used.  in both of these cases, the thread will be withdrawn from the same ASP.NET traffic pool, which leads us to the situation of an ‚Äúawl on soap‚Äù.  This example uses a custom threadpool, implemented by Mike Woodring;  This and many other of his developments can be found <a href="http://www.bearcanyon.com/dotnet/">here</a> . <br><br>  Here, in general, that's all.  Not so difficult as it seemed at the beginning.  Clients connect to our Comet server by calling Default.aspx, and we push the data by passing the GET parameter ala Default.aspx? X = Happy_New_Year to the same page.  Unfortunately, we have not mastered the testing of the scalability of this approach, but if anyone has any ideas on this subject, write, do not hesitate. <br><br>  Thanks for attention. <br><br>  <b>UPD</b> Add a link to the <a href="http://www.filefront.com/15428329/CometSkeleton.zip/">archive with the sample project</a> (~ 30 KB).  How to look: in VS we set CometPage.aspx as the start page, launch, open several tabs in the browser / browsers with the same URL (just remember the restriction in these browsers to the number of simultaneous connections), then in one of the tabs we add the parameter to the URL <i>? X = [any_text]</i> and observe how the value of the parameter appears in all open tabs. </div><p>Source: <a href="https://habr.com/ru/post/82015/">https://habr.com/ru/post/82015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../82010/index.html">The deadline for registering a domain emspost.ru (EMS Russian Post)</a></li>
<li><a href="../82011/index.html">Google Reader now allows you to subscribe to a site without RSS</a></li>
<li><a href="../82012/index.html">Send SMS to the number HHHCH to get this job</a></li>
<li><a href="../82013/index.html">Color your tags. CSSL</a></li>
<li><a href="../82014/index.html">On open video and on prevention</a></li>
<li><a href="../82017/index.html">SmartFish small and fast airplane</a></li>
<li><a href="../82021/index.html">Encyclopedia "AntiRAO" opens the door to the masses</a></li>
<li><a href="../82023/index.html">MP3 creators challenge Apple iTunes</a></li>
<li><a href="../82026/index.html">How are you doing with higher education and work?</a></li>
<li><a href="../82027/index.html">Kepler telescope discovery: hot planets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>