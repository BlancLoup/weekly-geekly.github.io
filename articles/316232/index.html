<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generation and selection of machine learning models. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The use of machine learning can include working with data, fine-tuning an already trained algorithm, etc. But a large-scale mathematical preparation i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generation and selection of machine learning models. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  The use of machine learning can include working with data, fine-tuning an already trained algorithm, etc. But a large-scale mathematical preparation is also needed at an earlier stage: when you only choose a model for further use.  You can choose "manually" using different models, but you can also try to automate this process. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OINtissED6U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Under the cut - a lecture by leading researcher of the Russian Academy of Sciences, doctor of science and editor-in-chief of the Machine Learning and Data Analysis journal Vadim Strizhov, as well as most of the slides. <br><br><a name="habracut"></a><hr><br>  We will talk about ways of generating and selecting models using the example of the time series of the Internet of things. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The concept of the Internet of things appeared more than ten years ago.  From the usual Internet, it differs primarily in the fact that the request is not made by a person, but by a device or message on a network that interacts with other devices without a person. <br><br>  The first example.  No one wants to climb into the corner with a flashlight every month, look at how much the electricity meter is wrapped around, and then go up and pay.  It is clear that modern meters monitor not only hourly energy consumption in an apartment, but even know how much energy has been taken from each outlet. <br><br>  The second option.  Monitoring human health.  An example of time series that are in this area is the following.  Now patients with tetraplegia, whose limbs have failed, put a palm-sized sensor directly on the cortex.  It is not visible from the inside, it is completely closed.  It gives 124 channels from the surface of the cortex with a frequency of 900 hertz.  In these time series, we can predict the movement of limbs, the way he wants to move. <br><br>  The next example is trading.  Now cashiers exit the store are expensive, and the queue at the exit of the store is not good either.  It is required to create such a system and receive such signals when a person with a cart, driving past the exit, immediately receives all the price values ‚Äã‚Äãof the products he purchased. <br><br>  The last rather obvious example is the automatic regulation of the work of urban services: traffic lights, lighting, weather sensors, floods, etc. <br><br><img src="https://habrastorage.org/files/c47/543/f1f/c47543f1fb074212a19c64109e70f340.jpg"><br><br>  Here is the first example of a time series with which we will work.  We have hourly electricity consumption, maximum and minimum daily temperature, humidity, wind, day length. <br><br><img src="https://habrastorage.org/files/ad4/27c/f07/ad427cf07c334fcda3308e6a26335fac.jpg"><br><br>  The second example of time series, which is hierarchically located above the first, is the same, only for each point of a certain region.  In this case, a piece of Europe is shown, and together with these time series, in particular, the value of air pollution is removed at each point. <br><br><img src="https://habrastorage.org/files/fd8/f31/1cb/fd8f311cbbd44502930302555957c413.jpg"><br><br>  An even more complex example is the values ‚Äã‚Äãof the electric field.  Frequencies are plotted along the ordinate axis, time is plotted along the abscissa.  This is also a time series.  If the last time series is the Cartesian product of time and space into space, here we have the Cartesian product of time and frequencies. <br><br><img src="https://habrastorage.org/files/0a9/9ac/9bf/0a99ac9bf12e42fe86fd6ba07b880506.jpg"><br><br>  The next time series is even more complex.  The axis of abscissa and ordinate space, on the axis of applicat - time.  Thus, we have many different beautiful time series, and the time series does not necessarily contain only time and values.  It may contain a Cartesian product of several time axes, frequencies, spaces, etc. <br><br>  Consider the easiest option.  We have time series of electricity consumption of a small city.  There is a price, volume of consumption, day length, temperature, etc. These time series are periodic.  Electricity consumption fluctuates during the year, during the week and during the day. <br><br><img src="https://habrastorage.org/files/23c/2f2/e8c/23c2f2e8c1aa415b84fa19c468c80519.jpg"><br><br>  Take an arbitrary day.  Blue - time series, red - forecast.  12 at night, citizens fall asleep, the mafia wakes up.  The time series falls, consumption falls.  All of Moscow is lit at night with lights, in general, because it is surrounded by CHP, there is nowhere to put the energy, and the price of electricity may even fall below zero, and you can pay extra for electricity - just to consume. <br><br>  6 hours, citizens wake up, go to work, drink tea, then work, then go home - this cycle repeats. <br><br>  The task is to forecast the electricity consumption by the next day by the hour and purchase all the electricity for a day at once.  Otherwise, the next day will have to pay extra for the difference in consumption, and this is more expensive. <br><br><img src="https://habrastorage.org/files/674/9e1/3e1/6749e13e1a794fc499d5ed09335eaab4.jpg"><br><br>  How is this problem solved?  Let's build such a matrix based on the previous time series.  Here in rows are days, about 40 days for 24 hours.  And we can easily see special lines here - Saturdays and Sundays.  It can be seen that in Ankara, as well as in Moscow, on Saturday people behave quite actively, and rest on Sunday. <br><br>  Each column - in this case 20 hours of a day of the week.  There are five weeks in total. <br><br><img src="https://habrastorage.org/files/afe/b29/edc/afeb29edc55646cb8d0e9fc4cef4abb5.jpg"><br><br>  Imagine this matrix in formal form.  We take the time series by the tail, by days of the week or by weeks we turn, we get an object ‚Äì feature matrix, where the object is the day, and the sign is an hour, and we solve the standard linear regression problem. <br><br>  Using this value, we are looking for, for example, 12 o'clock the next day.  What we predict, we count y for our entire history.  X - the whole story, except these 12 hours.  The forecast is the scalar product of the last week, the vectors of values ‚Äã‚Äãand our weights, which we obtain, for example, using the method of least squares. <br><br>  What needs to be done to get a more accurate forecast?  Let's spawn the various elements of the model.  We call them generating functions or primitives. <br><br><img src="https://habrastorage.org/files/1d0/36f/10f/1d036f10fab144f49a0d8ee4fa55063c.jpg"><br><br>  You can do the following with the time series: take the root from it.  You can leave it, you can take the time series - the root of the time series, the time series - the logarithm of the time series, etc. <br><br>  Thus, we add columns to the matrix object ‚Äì feature, increase the number of columns, and the number of rows remains the same. <br><br>  Moreover, we can use the Kolmogorov-Gabor polynomial to generate features.  The first member is the time series itself.  The second member is all the works of time series.  The third is the product of time series triples.  And so on, until we get bored. <br><br>  The coefficient is collected from the entire time series - and again we obtain a linear model.  After that we get a pretty decent forecast.  And even there is a suspicion whether we have not retrained, is the forecast too good? <br><br><img src="https://habrastorage.org/files/152/6a4/61e/1526a461e81542f2b559439682074a20.jpg"><br><br>  He is just as good that the parameters have generally lost their meaning. <br><br>  Suppose the row of matrices of the plan is a week, 7 days, 168 hours.  There are data, for example, for three years.  There are 52 weeks in the year.  Then the three-year base matrix is ‚Äã‚Äã156 rows by 168 columns. <br><br><img src="https://habrastorage.org/files/e64/cfb/d72/e64cfbd7261940c1b1f400e032f36890.jpg"><br><br>  If we use six time series that I will list, that is, together with the consumption, we also take into account price, humidity, temperature, and so on, then there will be more than 1000 columns in the matrix. And if there are four more generating functions, then these are 4000 rows and 156 columns.  That is, the matrix is ‚Äã‚Äãstrongly degenerate, and it is not possible to solve the linear equation normally.  What to do? <br><br><img src="https://habrastorage.org/files/575/4f3/ca3/5754f3ca323b44be9b11dd4472aa6e2c.jpg"><br><br>  Probably, you need to run the procedure for selecting models.  To do this, look at what weights make sense.  For each hour we build our model, and here on the x-axis shows the values ‚Äã‚Äãof the model parameters by the hour on the next day.  And on the y-axis are the parameters themselves.  We see a yellow-red diagonal, the value of the scales is larger where there is an hour in the model for the previous days. <br><br>  The principle is simple.  The forecast for tomorrow at 12 o'clock depends on the values ‚Äã‚Äãfor 12 hours of the previous day, the day before yesterday, and so on. Thus, we can leave only these values ‚Äã‚Äãand throw away everything else. <br><br><img src="https://habrastorage.org/files/cf6/834/000/cf68340004f84a8299ebfb8b90f7bb1d.jpg"><br><br>  What exactly should be discarded?  Imagine the matrix x as a set of columns.  We approximate the time series y with a linear ‚Äî or optionally linear ‚Äî combination of columns of the matrix x.  We would like to find a column œá that would be closer to y.  A significant part of the feature selection algorithms will select the columns œá <sub>1</sub> and œá <sub>2</sub> if we want to leave two columns.  But among those that we have created, we need œá <sub>3</sub> and œá <sub>4</sub> .  They provide both an accurate and stable model.  Exact - because the linear combination <sub>of</sub> œá <sub>3</sub> and œá <sub>4</sub> exactly approximates y, and stable - because they are orthogonal. <br><br>  Why two columns?  We need to see in which space we are working, how many objects are in the drawn sample.  Here are three objects.  Matrix x contains 3 rows and 6 columns. <br><br><img src="https://habrastorage.org/files/26e/f57/cc5/26ef57cc5bc749f6ba23e4ddfe8a43f9.jpg"><br><br>  How do feature selection algorithms work?  As a rule, they use error functions.  In linear regression, this is the sum of the squares of the regression residuals.  And there are two types of feature selection algorithms.  The first type is regularizing algorithms.  In addition to error, they use, as was said by Konstantin Vyacheslavovich in the last lecture, also some regularizer, a penalty on the value of the parameters and some coefficient, which is responsible for the importance of the penalty. <br><br>  This coefficient can be represented in the form of such or such a fine.  The weights must be no more than some value of œÑ. <br><br>  In the first case, it is not about the loss of the number of columns in the matrix x, the number of features, but only about increasing stability.  In the second case, we just lose a significant number of columns. <br><br>  It is important to understand how the columns correlate with each other.  How to find out? <br><br><img src="https://habrastorage.org/files/bbd/f64/262/bbdf64262ca143e48921f9ffdff3f115.jpg"><br><br>  Consider the parameter space of our model, the vector w, and calculate the value of the error at various points of w.  The picture on the right shows the space itself, w <sub>1</sub> or w <sub>2</sub> .  Two weights are sampled, 100 points each.  It turns out 100 pairs of scales.  Each point of this figure is the value of the error function.  On the left, for convenience, the same is the exponent of the minus value of the error function. <br><br>  It is clear that the optimal values ‚Äã‚Äãlie somewhere in the point of 0.2‚Äì0.25 and this is what we are looking for.  And the importance of the parameters is defined as follows: let's take a little bit of the parameter values ‚Äã‚Äãfrom the optimal value.  If we change w, the error function practically does not change.  Why do we need such a parameter?  Probably not needed. <br><br>  Here, the value of the parameters slightly rocked along the w <sub>2</sub> axis, the error function dropped - fine.  This basis of parameter space analysis is a way to find multi-correlating features. <br><br>  Where do these signs come from?  Let's look at the four main ways of generating signs.  The first is the signs themselves.  Where are they from?  We take a time series and chop it into pieces, for example, multiples of a period.  Or just by chance, or with overlap.  We add these chopped segments into matrix X, the plan matrix. <br><br>  The second way.  Same.  We transform the time series using some parametric or non-parametric features. <br><br>  The third method is very interesting and promising.  We are bringing pieces of the time series with some models.  We will call this local modeling.  And we use the parameters of these models as signs for the forecast. <br><br>  Fourth.  Everything happens in some kind of metric space.  Let's find the centroids, cluster thickening in this space, and consider the distances from each time series to the centroids of these clusters. <br><br><img src="https://habrastorage.org/files/cf0/b18/043/cf0b180435534c23a7ff8930f6aa0e46.jpg"><br><br>  Bad news.  In order to build a matrix of the plan, the ratios of frequencies to sampling time series, if the series are different, should be short.  In this case, the matrix of the plan grows.  True, you can throw out some parts of the time series, as shown here.  The entire time series ‚Äúday length‚Äù is not needed, only one point per day is needed, and the plan matrix will look like this: 24 points in a row is electricity consumption, and one point and one more is the length of the daylight hours. <br><br><img src="https://habrastorage.org/files/b4f/b93/48f/b4fb9348f3274672ab23222f95b4a4ea.jpg"><br><br>  Here is the time series.  What we have already reviewed.  x ln x, in pairs, is the sum, difference, product, and various other combinations. <br><br><img src="https://habrastorage.org/files/b7c/eba/899/b7ceba899e8843c2a8e482da094cbb1a.jpg"><br><br>  Here are non-parametric transformations.  Just the average amount, the standard deviation.  Histogram of time series quantiles. <br><br><img src="https://habrastorage.org/files/2dd/f55/99a/2ddf5599a3e6426d889fd6acc24c9267.jpg"><br><br>  The next option.  Nonparametric transformation, Haar transform.  We take the arithmetic average and put it as a single point instead of two.  Or take the difference.  Thus, we generate the feature and reduce the number of points in the time series, respectively, reduce the dimension of space. <br><br><img src="https://habrastorage.org/files/6dd/874/222/6dd874222d164a6a8f02ee13dd3afb2f.jpg"><br><br>  The next set of generating functions is parametric functions.  With them, we can approximate the time series.  The first is to use this approximate series instead of the initial one.  The second is to use the parameters themselves, denoted as w. <br><br>  Constant, parabola, hyperbola, logarithmic sigmoid, product, power functions, exponential functions. <br><br><img src="https://habrastorage.org/files/705/7a2/3f2/7057a23f20194f1599087767637e2ecc.jpg"><br><br>  Another very convenient class is monotone functions.  Here neural network experts can see, for example, activation functions that are often used in networks.  They can be used not only at the output of networks, but also at the entrance.  This also greatly improves the quality of the forecast. <br><br><img src="https://habrastorage.org/files/cff/b6c/9ac/cffb6c9accfd479494a807f24dec6771.jpg"><br><br>  The next class of generating functions is parametric time series transformations.  Here we are interested in the parameters of the series themselves.  We take the above functions and collect their parameters in the vector b.  We have two types of parameters: the first is the parameters of the approximating functions themselves, local approximation functions, and the second vector are the model parameters, those that were considered earlier, that is, the weight parameters of linear combinations of columns of the X matrix. We can adjust them simultaneously, or we can set up iteratively and use them including as columns of the design matrix.  In other words, the matrix of the plan, X, changes iteratively. <br><br>  Where else can we get the parameters of the models?  I will consider from the end.  The splines in the approximation of the time series have parameters, nodes of splines. <br><br>  Fast Fourier transforms.  Instead of a time series, we can use its spectrum and also insert it into the matrix of the object ‚Äì feature. <br><br>  An important and well-working technique is to use the parameters of the ‚ÄúSingular structural analysis‚Äù or ‚ÄúCaterpillar‚Äù method. <br><br><img src="https://habrastorage.org/files/c6b/795/84b/c6b79584badc4a35b25d7bacdef4aa72.jpg"><br><br>  This method works as follows.  First, we built the matrix X - let's build a new matrix in a similar way.  Now the local approximation matrix will be called H, and it will be constructed as follows: the segment of the time series enters the rows of the matrix, not one after the other, but with overlap.  Let here p = 1, and k = 3. The matrix by indices will look like 1,2,3;  2,3,4;  3,4,5 and so on to the end. <br><br>  Adjust the last column of the previous we will be the same method of least squares, and the coefficients used as our signs.  In particular, this technique works well in determining physical activity.  For example, an athlete has a watch on his arm and an athlete wants to understand how efficiently he is moving.  This task is especially popular with swimmers.  It is required to determine not only the type of swim, but also the power of the stroke. <br><br>  The processor is weak there, no memory.  And instead of solving a large problem of determining the class of a time series or predicting a series, we immediately approximate it in a similar way when we receive data.  We use not an approximated time series, but approximation parameters. <br><br>  This is why it works. <br><br>  It shows not the time series itself, but its logged values.  This point is the value of the series at a given time and one count later.  It is clear that the sine will look like an ellipse.  The good news is that the dimension of this ellipse in the space of logged variables will always be 2. Whatever length of prehistory we take in this space, the dimension of the space will still remain fixed.  And the dimension of space can always be determined by singular decomposition. <br><br><img src="https://habrastorage.org/files/f09/daa/ee6/f09daaee6a724c3aa7777887e55279a3.jpg"><br><br>  Then we can represent each time series in the form of its main components in a singular decomposition.  Accordingly, the first main component will be some kind of trend, the second - the main harmonic and so on in ascending harmonics.  We use the weights of these components as attributes in approximating models. <br><br><img src="https://habrastorage.org/files/710/65d/02a/71065d02af41490c96796016648bd483.jpg"><br><br>  Here is the last way to generate traits.  Signs are metric.  We have already somehow generated the plan matrix - let's see how its columns are located in some kind of metric space, for example, in Euclidean space. <br><br>  We assign the metric œÅ and cluster the rows of the object ‚Äì feature matrix, X. <br><br>  Naturally, the number of distances from all objects in the sample to all objects in the sample is the power of the sample in the square.  Therefore, we select the centers of the clusters, measure the distance from each row to the center, and use the obtained distances as signs in the matrix of the object-attribute. <br><br>  In practice, it looks like this.  In order for the distance to be calculated correctly, we first align the time series.  It shows six classes of rows for the accelerometer: a person goes, goes up the steps, down the steps, stands and lies.  It is proposed to first align the rows with a procedure and get, for example, such rows.  Next - calculate the average values ‚Äã‚Äãor centroids for each row. <br><br><img src="https://habrastorage.org/files/d57/ee4/e63/d57ee4e632d749ee9b7f6298885c917a.jpg"><br><br>  And then calculate the distance from each time series in the matrix X, the object ‚Äì feature, to these centroids. <br><br>  What happened as a result of generating signs in different ways?  Let's look at the same data as in the beginning. <br><br><img src="https://habrastorage.org/files/cc9/780/225/cc97802250dc43a9b78fde60d2a74b16.jpg"><br><br>  This is the data of power consumption in Poland, they are hourly.  In addition, they are accompanied by different time series that describe them.  We also insert gaps into this sample.  Throw away some data, for example 3, 5, 10%.  Fill them, and then try to predict the value of all the series at once. <br><br><img src="https://habrastorage.org/files/1d9/505/09a/1d950509a2354575a57378e28930676d.jpg"><br><br>  On the right, we get the following object ‚Äì feature matrix.  On the left, time series, chopped into pieces.  The first 24 time series - day.  Instead of a zigzag, you should build a histogram. <br><br><img src="https://habrastorage.org/files/81f/99a/248/81f99a24893a4e30ba008ba6ff818c3a.jpg"><br><br>  What models do we have?  The best model is the forecast for tomorrow, the same as today.  We will call this the base method. <br><br>  Linear regression, which we considered at the beginning.  Support vector machine.  Neural network random forest.  Of course, the fourth magic method was not enough.  There are four methods that always work well, if the problem is solved at all: neural networks, support vectors, random forest and gradient boosting. <br><br>  Let's compare how four different methods work with different ways of generating signs.  Here again, these four ways.  Historical time series.  The approximation of time series.  ‚Äî      . <br><br><img src="https://habrastorage.org/files/5a8/723/fc1/5a8723fc1fd44bfe8cea7a813850e7a3.jpg"><br><br>     .   ‚Äî ,        .  ‚Äî    . <br><br><img src="https://habrastorage.org/files/9dc/7b6/95c/9dc7b695c575497092b7cfcbc9b14179.jpg"><br><br>      .     .   ,  .     ‚Äì   ,    .  ,      ‚Äî       . Support vector machine      .  random forest   .    . <br><br><img src="https://habrastorage.org/files/2b9/0d1/b72/2b90d1b72d1a427cbca002e52a150c60.jpg"><br><br>   .    ,     support vector regression  . ,         . , , , , .        ‚Äî support vector regression    .       ,     . <br><br><img src="https://habrastorage.org/files/d02/6dd/074/d026dd0747f34109abc9467505fc13fd.jpg"><br><br>      ?  ,   ,  -  ,    .    :     ,   ,  -  ,               ,     .   , . </div><p>Source: <a href="https://habr.com/ru/post/316232/">https://habr.com/ru/post/316232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316220/index.html">msvcore - c ++, cross-platform library, bicycle and 12 years of development</a></li>
<li><a href="../316224/index.html">The digest of interesting materials for the mobile developer # 181 (November 21-27)</a></li>
<li><a href="../316226/index.html">New domain zones: several myths and rumors associated with them</a></li>
<li><a href="../316228/index.html">ESET specialists have released a new Crysis crypter file decryption tool.</a></li>
<li><a href="../316230/index.html">Blockchain, its prospects and shared economy</a></li>
<li><a href="../316234/index.html">FPGA Debug Board - Frankenstein. Telegraph transmitter</a></li>
<li><a href="../316236/index.html">Refactoring is not a task in Backlog</a></li>
<li><a href="../316238/index.html">Laziness, reflection, attributes, dynamic assemblies</a></li>
<li><a href="../316244/index.html">20 useful Node.js frameworks</a></li>
<li><a href="../316246/index.html">JDF format. Automation of processes in printing production</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>