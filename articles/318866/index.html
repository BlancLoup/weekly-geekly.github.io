<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker swarm mode (swarm mode)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© already wrote about Docker swarm mode (swarm mode), which is a new feature of version 1.12 . This option has brought a little confusion to th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker swarm mode (swarm mode)</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/387/a02/5c6/387a025c6d7a45e6931da923105316df.png"><br>  On Habr√© already <a href="https://habrahabr.ru/company/centosadmin/blog/310390/">wrote</a> about <a href="https://docs.docker.com/engine/swarm/">Docker swarm mode</a> (swarm mode), which is a new feature of version <a href="">1.12</a> .  This option has brought a little confusion to the heads of those who are familiar with the stand-alone <a href="https://docs.docker.com/swarm/">Docker Swarm</a> implementation that had spread before and did not differ in ease of configuration and use.  However, after adding Swarm to the box with Docker, everything became much simpler, more obvious and more functional. <br><br>  Learn more about how the new cluster of Docker containers is arranged from the user's point of view, as well as about a simple and convenient way of deploying Docker services on an arbitrary infrastructure further under the cat. <br><a name="habracut"></a><br>  For a start, as I promised in the previous <a href="https://habrahabr.ru/company/redmadrobot/blog/314104/">article</a> , with a slight delay, but still released <a href="https://github.com/renskiy/fabricio">Fabricio</a> release with support for Docker services.  At the same time, the ability to work with individual containers remains, plus, the user interface and configuration developer remain unchanged, which greatly simplifies the transition from configurations based on separate containers to fault-tolerant and horizontally scalable services. <br><br><h2>  Docker swarm mode activation </h2><br>  In swarm mode, all nodes are divided into two types: manager and worker.  At the same time, a full-fledged cluster can do without working nodes in general, that is, managers by default are also workers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Among managers there is always one who is currently the leader of the cluster.  All control commands that run on other managers are automatically redirected to it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2bf/780/f4c/2bf780f4c52942d3b2bced39b0b5083d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Sample list of nodes in a running Docker cluster</b> <div class="spoiler_text"><pre><code class="bash hljs">$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS 6pbqkymsgtnahkqyyw7pccwpz * docker-1 Ready Active Leader avjehhultkslrlcrevaqc4h5f docker-2 Ready Active Reachable cg1maoa11ep7h14f2xciwylf3 docker-3 Ready Active Reachable</code> </pre> <br></div></div><br>  To enable swarm mode, simply select a host that will be the initial leader in the future cluster, and execute only one command on it: <br><br><pre> <code class="bash hljs">docker swarm init</code> </pre><br>  After the swarm is initialized, it is ready to launch any number of services on it.  However, the state of such a cluster will be inconsistent (the consistent state is reached when there are at least 3 managers).  And of course, there can be no talk of scaling and failover in this case either.  To do this, you need to connect at least two more control nodes to the cluster.  You can learn how to do this by running the following commands on the leader: <br><br><div class="spoiler">  <b class="spoiler_title">Adding a control node</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ docker swarm join-token manager To add a manager to this swarm, run the following <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: docker swarm join \ --token SWMTKN-1-1yptom678kg6hryfufjyv1ky7xc4tx73m8uu2vmzm1rb82fsas-c12oncaqr8heox5ed2jj50kjf \ 172.28.128.3:2377</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Adding a work node</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ docker swarm join-token worker To add a worker to this swarm, run the following <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: docker swarm join \ --token SWMTKN-1-1yptom678kg6hryfufjyv1ky7xc4tx73m8uu2vmzm1rb82fsas-511vapm98iiz516oyf8j00alv \ 172.28.128.3:2377</code> </pre><br></div></div><br>  You can add and remove nodes at any time during the life of a cluster ‚Äî this does not seriously affect its performance. <br><br><h2>  Creating a service </h2><br>  Creating a service in Docker is not fundamentally different from creating a container: <br><br><pre> <code class="bash hljs">docker service create --name nginx --publish 8080:80 --replicas 2 nginx:stable-alpine</code> </pre><br>  Differences, as a rule, consist in a different set of options.  For example, the service does not have the option <i>--volume</i> , but there is an option <i>--mount</i> - these options allow you to connect local node resources to containers, but they do it in different ways. <br><br><h2>  Service update </h2><br>  Here begins the biggest difference between the work of containers and the work of a cluster of containers (service).  Usually, to update a single container, you have to stop the current one and start a new one.  This leads, albeit to insignificant, but to the existing idle time of your service (if you have not bothered to handle such situations using other tools). <br><br>  When using a service with a number of replicas of at least 2, the service is not idle in most cases.  This is achieved due to the fact that Docker updates the service containers <a href="https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/">in turn</a> .  That is, at the same moment in time there is always at least one working container that can service the user's request. <br><br>  For updating (including adding and deleting) service properties that can have several values ‚Äã‚Äã(for example, <i>--publish</i> or <i>--label</i> ), Docker suggests using special options ending with <b>-add</b> and <b>-rm suffixes</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      docker service update --label-add foo=bar nginx</span></span></code> </pre><br>  Removing some options, however, is less trivial and often depends on the option itself: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     docker service update --label-rm foo nginx #       (target port) docker service update --publish-rm 80 nginx</span></span></code> </pre><br>  Details on each option can be found in the description of the <i><a href="https://docs.docker.com/engine/reference/commandline/service_update/">docker service update command</a></i> . <br><br><h2>  Scaling and balancing </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/008/29a/98d/00829a98db20465d817750d67a940cc5.png"></div><br>  To distribute requests between existing Docker nodes, a scheme called <b>ingress load balacing is used</b> .  The essence of this mechanism is that no matter what the user's request comes from, it will first go through the internal balancing mechanism and then be redirected to the node that can serve the request at the moment.  That is, any node is able to process a request to any of the cluster services. <br><br>  Scaling the Docker service is achieved by specifying the required number of replicas.  At that moment when you need to increase (or decrease) the number of nodes servicing requests from the client, you simply update the properties of the service with an indication of the desired value of the <i>--replicas</i> option: <br><br><pre> <code class="bash hljs">docker service update --replicas 3 nginx</code> </pre><br>  In this case, you must first remember to make sure that the number of available nodes is not less than the number of replicas you want to use.  Although nothing terrible will happen even if the node is smaller than the replicas - just some nodes will launch more than one container of the same service (otherwise Docker will try to launch replicas of the same service on different nodes). <br><br><h2>  fault tolerance </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/771/f19/f67/771f19f676fe4a25b40f82c3387c8711.png"></div><br>  Fail safety of service is guaranteed by Docker.  This is achieved, among other things, due to the fact that several control nodes can work simultaneously in a cluster, which can replace a failed leader at any time.  In more detail, the so-called <a href="https://raft.github.io/">distributed consensus support algorithm, Raft, is used</a> .  I recommend to those interested to watch this wonderful visual demonstration: <a href="http://thesecretlivesofdata.com/raft/">Raft at work</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Raft: choosing a new leader</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/584/dcc/4e8/584dcc4e857d4e0a999e487d2e0dbbbe.gif"></div><br></div></div><br><h2>  Automatic Deploy </h2><br>  The warmth of the new version of the application on the combat servers is always accompanied by the risk that something will go wrong.  That is why it is considered a bad sign to roll out a new version of the application before weekends and holidays.  Moreover, before long holidays, like the New Year holidays, any changes on the combat infrastructure cease within a week or even two before they start. <br><br>  Despite the fact that Docker services offer a completely reliable way to launch and update an application, quite often a quick rollback to the previous version is difficult for one reason or another, which can cause users to be out of service for many hours. <br><br>  The most reliable way to avoid problems when updating an application is <b>automation and testing</b> .  For this purpose, automatic deployment systems are being developed.  An important part of such systems, as a rule, is the ability to quickly upgrade and roll back to the previous version on any chosen infrastructure. <br><br><h3>  Fabricio </h3><br>  Most deployment automation tools offer to describe the configuration using popular markup languages ‚Äã‚Äãlike XML or YAML.  Some go further and develop their own language for describing such configurations (for example, <a href="https://github.com/hashicorp/hcl">HCL</a> or <a href="https://docs.puppet.com/puppet/latest/lang_summary.html">Puppet language</a> ).  I do not see the need to go along any of these paths for the following reasons: <br><br><ul><li>  XML / YAML will never be compared in terms of expansion and use with full-fledged programming languages, and the desire to simplify configuration through the use of simplified markup is often the other way around, only complicates everything. Plus, few programmers will want to program in XML / YAML, and in fact configuration is special case of programming. </li><li>  Developing your own programming language is an extremely complicated and tedious process, most often unsuccessful. </li></ul><br>  Therefore, Fabricio uses standard Python and some of the reliable and time-tested libraries (among them, the well-known <a href="http://www.fabfile.org/">Fabric</a> ) to describe the configurations. <br><br>  Of course, many may argue about this, saying that not all developers and DevOps know Python.  Well, first of all, Python (as well as Bash) is included in the gentlemen‚Äôs set of scripting languages ‚Äã‚Äãthat every DevOps self-respecting (or almost everyone) should know.  And secondly, as it is not paradoxical, knowing Python is almost optional.  In support of my words, I give an example of the configuration of the Django-based service for Fabricio: <br><br><div class="spoiler">  <b class="spoiler_title">fabfile.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fabricio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fabricio.apps.python.django <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DjangoService django = tasks.DockerTasks( service=DjangoService( name=<span class="hljs-string"><span class="hljs-string">"django"</span></span>, image=<span class="hljs-string"><span class="hljs-string">"project/django"</span></span>, options={ <span class="hljs-string"><span class="hljs-string">"publish"</span></span>: <span class="hljs-string"><span class="hljs-string">"8080:80"</span></span>, <span class="hljs-string"><span class="hljs-string">"env"</span></span>: <span class="hljs-string"><span class="hljs-string">"DJANGO_SETTINGS_MODULE=my_settings"</span></span>, <span class="hljs-string"><span class="hljs-string">"replicas"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }, ), hosts=[<span class="hljs-string"><span class="hljs-string">"user@manager1"</span></span>, <span class="hljs-string"><span class="hljs-string">"user@manager2"</span></span>, <span class="hljs-string"><span class="hljs-string">"user@manager3"</span></span>], )</code> </pre><br></div></div><br>  Agree that this example is no more complicated than a similar description on YAML.  A person with at least one programming language will understand this config without any problems. <br><br>  But pretty lyrics. <br><br><h3>  Deploy process </h3><br>  Schematically, the process of deploying a service with Fabricio looks like it is shown in the figure below (after executing the <b>fab django</b> command for the <b>config</b> described above): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/34a/94d/fd2/34a94dfd2e32493885adfb344f250892.png"></div><br><br>  Consider each item in order.  To begin with, I just want to note that the presented scheme is relevant when the parallel execution mode is on (with the specified option <b>--parallel</b> ).  The only difference between the sequential mode is that all actions in it are performed strictly sequentially. <br><br>  Immediately after launching the deployment team, the following steps begin to be performed sequentially: <br><br><ul><li>  <b>pull</b> , simultaneously on all nodes, the process of downloading a new Docker image starts.  I note that in the configuration it is enough to specify only the addresses of the managing nodes (managers), and it is not even necessary to list all the available managers - the unspecified nodes will be automatically updated by Docker.  Although nothing prevents to specify in the configuration including workers (in some cases it may be necessary, for example, when <a href="https://github.com/renskiy/fabricio">using an SSH tunnel</a> ). </li><li>  <b>migrate</b> , the next step is to use migrations.  It is important that this step be performed simultaneously on only one of the current nodes, so Fabricio in this case uses a special mechanism to ensure that the migration process will be started on only one node and executed only once. </li><li>  <b>update</b> , since to update all containers of the service, the update command is enough to run only once, then Fabricio at this step also ensures that it is not executed twice. </li></ul><br>  Each command (pull, migrate, update), if necessary, can be executed separately.  Additional steps (prepare, push, backup) can also be included in the deployment process as described in this earlier <a href="https://habrahabr.ru/company/redmadrobot/blog/303118/">review article about Fabricio</a> . <br><br>  All Fabricio commands (except backup and restore) are idempotent, that is, safe when re-executed with the same parameters. <br><br><div class="spoiler">  <b class="spoiler_title">Idempotency test</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">fab --parallel nginx</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ fab --parallel nginx [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.5] run: docker pull nginx:stable-alpine [vagrant@172.28.128.4] run: docker pull nginx:stable-alpine [vagrant@172.28.128.3] run: docker pull nginx:stable-alpine [vagrant@172.28.128.3] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.3] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.3] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.3] out: [vagrant@172.28.128.4] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.4] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.4] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.4] out: [vagrant@172.28.128.5] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.5] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.5] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.5] out: [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.5] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.4] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.3] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.5] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.4] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.3] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.3] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.3] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.4] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.3] run: docker service inspect nginx [vagrant@172.28.128.4] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.3] No changes detected, update skipped. [vagrant@172.28.128.4] No changes detected, update skipped. [vagrant@172.28.128.5] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.5] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.5] No changes detected, update skipped. Done. Disconnecting from vagrant@127.0.0.1:2222... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Disconnecting from vagrant@127.0.0.1:2200... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Disconnecting from vagrant@127.0.0.1:2201... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>.</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">fab nginx</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ fab nginx [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.3] run: docker pull nginx:stable-alpine [vagrant@172.28.128.3] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.3] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.3] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.3] out: [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.4] run: docker pull nginx:stable-alpine [vagrant@172.28.128.4] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.4] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.4] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.4] out: [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.pull'</span></span> [vagrant@172.28.128.5] run: docker pull nginx:stable-alpine [vagrant@172.28.128.5] out: stable-alpine: Pulling from library/nginx [vagrant@172.28.128.5] out: Digest: sha256:ce50816e7216a66ff1e0d99e7d74891c4019952c9e38c690b3c5407f7af57555 [vagrant@172.28.128.5] out: Status: Image is up to date <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nginx:stable-alpine [vagrant@172.28.128.5] out: [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.3] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.4] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.migrate'</span></span> [vagrant@172.28.128.5] run: docker info 2&gt;&amp;1 | grep <span class="hljs-string"><span class="hljs-string">'Is Manager:'</span></span> [vagrant@172.28.128.3] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.3] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.3] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.3] run: docker service inspect nginx [vagrant@172.28.128.3] No changes detected, update skipped. [vagrant@172.28.128.4] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.4] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.4] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.4] No changes detected, update skipped. [vagrant@172.28.128.5] Executing task <span class="hljs-string"><span class="hljs-string">'nginx.update'</span></span> [vagrant@172.28.128.5] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> image nginx:stable-alpine [vagrant@172.28.128.5] run: docker inspect --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> container nginx_current [vagrant@172.28.128.5] No changes detected, update skipped. Done. Disconnecting from vagrant@172.28.128.3... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Disconnecting from vagrant@172.28.128.5... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Disconnecting from vagrant@172.28.128.4... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>.</code> </pre><br></div></div><br></div></div><br><h3>  Rollback to the previous version </h3><br>  Reverting to the previous version ( <b>fab django.rollback command</b> for the previously described configuration) is in many ways similar to the deployment process: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3d5/3a1/d26/3d53a1d262ab4ac5916e86a2934ee3d2.png"></div><br>  Both the rollback of migrations and the rollback of the service itself to the previous state are performed strictly once on one of the manager's nodes. <br><br><h2>  Conclusion </h2><br>  For containerization is the future of server development.  Those who have not yet realized this will soon be confronted with a fait accompli.  Containers are a convenient, simple and powerful weapon in the hands of developers and DevOps. <br><br>  With the release of Docker 1.12, the supporters of Kubernetes have practically no arguments in favor of using the latter.  Docker services not only provide all the same features as Kubernetes services, but they even have a number of advantages due to the ease of configuration on any OS (Linux, macOS, Windows) and the absence of the need to install and run additional components (containers). <br><br>  Fabricio - a tool that helps in developing, testing and laying out new versions of applications for combat and test servers with Docker - now supports the deployment of scalable and fault-tolerant services.  You can get acquainted with various options for using Fabricio on the page with <a href="https://github.com/renskiy/fabricio/tree/master/examples">examples and recipes</a> (all examples are described and automated in detail using Vagrant). </div><p>Source: <a href="https://habr.com/ru/post/318866/">https://habr.com/ru/post/318866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318856/index.html">Data integrity in spite of everything. Disaster Backup in the Azure Pack Infrastructure Cloud</a></li>
<li><a href="../318858/index.html">Enable TLS / SRTP encryption in 3CX</a></li>
<li><a href="../318860/index.html">VulnHub: Reverse everything you can in DC416 Baffle</a></li>
<li><a href="../318862/index.html">Building Mobile Applications with Ember</a></li>
<li><a href="../318864/index.html">How to evaluate your publication?</a></li>
<li><a href="../318868/index.html">Virtual Reality 2016 Market Analysis</a></li>
<li><a href="../318870/index.html">"Kazakov" no secrets</a></li>
<li><a href="../318872/index.html">How to write the best post on Habr√©. 7 answers, 7 tips</a></li>
<li><a href="../318874/index.html">Difficulties on the way of creating a ‚Äúuniversal‚Äù metamodel for modeling subject domains</a></li>
<li><a href="../318876/index.html">VCL, get rid of flicker, once and for all</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>