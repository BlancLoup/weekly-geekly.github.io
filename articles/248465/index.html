<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we were friends Neo4j and Meteor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Writing driver support graph database Neo4j for Meteor 
 In Meteor, any work with data is related to two-way reactivity. Currently, MongoDB and Redis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we were friends Neo4j and Meteor</h1><div class="post__text post__text-html js-mediator-article"><h3>  Writing driver support graph database Neo4j for Meteor </h3><br>  In Meteor, any work with data is related to two-way reactivity.  Currently, MongoDB and Redis built into Meteor (both drivers are developed in Meteor walls) have 100% reactivity, and some reactivity is implemented for MySQL and MSSQL (by third-party developers). <br><br>  For the above databases, reactivity is implemented by observers who report where, how, when and what data has changed, so that the driver servicing the communication [data &lt;-&gt; presentation] knows what data and which Clients to update.  Neo4j is devoid of any watchers and observers, but this did not stop us.  How we came out of this situation and why we need Neo4j read under the cut. <br><a name="habracut"></a><br>  Under node.js there is an official and eponymous npm-package from manufacturers Neo4j, which is replete with functionality, but in the first two lines of its documentation it is gently hinted that only the connection to the <strong>GraphDatabase</strong> and the <strong>query</strong> method works stably. <br><br><h4>  Why do we need Neo4j </h4><br>  I believe that each task should have its own tool, created and designed to perform this task at the highest level.  Everyone knows that one nail can be, and sometimes it is necessary (if the time spent searching for or buying funds for a hammer is unjustifiably inflated) to score with a sneaker.  But for 100 and even more than 100,000 nails, it would be advisable to get a hammer, and better nails.  In our case, we need to store and retrieve relationship data between records.  We continue to store the data in a denormalized form in MongoDB, but we store the relationships of this data in Neo4j. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  How it all began: Connector </h4><br>  Initially it was assumed that by creating a global variable that holds an object of the type <strong>GraphDatabase</strong> , the functionality supplied in the npm-package will be enough for the tasks: at that time we wrote / read data to / from the database (without reactivity).  This is how neo4jdriver was born - a package containing the globally available class <strong>Neo4j</strong> , which, when initialized, creates a connection to a database running locally or remotely.  During initialization, you can pass a single <strong>url</strong> parameter. <br><br>  Later there was a need for: <br><ul><li>  reactivity; </li><li>  observer; </li><li>  isomorphism - the ability to perform requests from both the server and the client; </li><li>  to receive incoming data - by default Neo4j on any <strong>MATCH</strong> request throws out a bunch of garbage that weighs a lot. </li></ul><br>  This is where the fun began. <br><br><h4>  How it went: Reactivity </h4><br>  The second was the neo4jreactivity package, based on the principle of pseudo-reactivity, implemented through a layer in the form of MongoDB.  Simply put, on any request in Neo4j, we return - <strong>Mongo \ Cursor</strong> , which in turn is the source of reactive data or, as it is commonly called in the Meteor community: REACTIVE DATA SOURCE. <br><br>  Initially, everything seemed simple: <br><ul><li>  We make some kind of caching collection in MongoDB, which contains the request, the request hash and the response from Neo4j; </li><li>  For the Client, we create a session in which we hold an array containing all the hashes of the requests to which you want to subscribe; </li><li>  All requests are passed through the <strong>Meteor.neo4j.query</strong> method, which creates a hash from a query to the database, receives a response from the database, writes it to the database and sends it to all Clients subscribed to this request hash; </li><li>  To launch requests from the Client, we do the Meteor-method, which eats!  any request and executes it on the server. </li></ul><br><br>  At the time of release of one of the first driver versions, you could run absolutely any request on the Client, i.e.  could change, retrieve or erase all data stored in Neo4j.  This problem was solved by introducing the <strong>Meteor.neo4j.methods ({})</strong> and <strong>Meteor.neo4j.call (methodName, opts, callback) methods</strong> , which work according to the standard <strong>Meteor.methods ({})</strong> principle, for example: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Meteor.isServer){ Meteor.neo4j.methods({ <span class="hljs-string"><span class="hljs-string">'GetUser'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'MATCH (n:User {_id: {userId}}) RETURN n'</span></span> } }); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Meteor.isClient){ Meteor.neo4j.call(<span class="hljs-string"><span class="hljs-string">'GetUser'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">userId</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!error){ Session.set(<span class="hljs-string"><span class="hljs-string">'theUser'</span></span>, data); } }); }</code> </pre> <br>  The second thing we did was property <strong>Meteor.neo4j.allowClientQuery</strong> , which is <strong>true</strong> and <strong>false</strong> , and is <strong>false</strong> by default.  This will allow developers at the time of developing and testing the application to work in the browser console, send data and verify the received data. <br><br>  If for some reason you decide to leave the possibility of executing requests to Neo4j from the Client, then the following functionality is provided to limit the type of requests to Neo4j.  You have two methods available: <strong>neo4j.set.allow</strong> and <strong>neo4j.set.deny</strong> .  Both methods take a single parameter - an array of strings (array of strings).  In addition, arrays are available to you: <strong>Meteor.neo4j.rules.allow</strong> , <strong>Meteor.neo4j.rules.deny</strong> and <strong>neo4j.rules.write</strong> , which contain the current rules, and the latter contains an array with write statements, which allows you to do this shortcut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Meteor.isClient){ Meteor.neo4j.set.deny(Meteor.neo4j.rules.write); }</code> </pre><br>  And prohibit all requests for recording by the Client.  All methods described in the paragraph above are isomorphic.  The client‚Äôs hack will not work, as the data is additionally checked for integrity on the Server side. <br><br><h4>  Watching the data: your Observer with blackjack and listener </h4><br>  It was later discovered that data change requests did not initiate data updates on Clients.  Reactivity simply did not work until one of the Clients turned to the changed data and initiated an update in MongoDB, and as a result, on all Clients.  This happened due to the fact that we did not have an observer who would monitor the changed data and initiate the launch of all queries related to the data that had changed. <br><br><h5>  Listener </h5><br>  We return to our ideal package called <strong>neo4jdriver</strong> , erase the entire project and write again: <br><ul><li>  We leave the class structure and initialization of the class instance with the ability to transfer the <strong>url</strong> to the database; </li><li>  Create an array <strong>GraphDatabase.callbacks</strong> , storing callbacks that take two parameters - <strong>query</strong> and <strong>opts</strong> ; </li><li>  Add the <strong>GraphDatabase.listen (func)</strong> method, which accepts a function with two parameters, <strong>query</strong> and <strong>opts</strong> , all functions fall into the <strong>GraphDatabase.callbacks</strong> array; </li><li>  We reassign the <strong>query</strong> method built into the npm-package by adding to it the launch of all callbacks from the <strong>GraphDatabase.callbacks</strong> array. </li></ul><br><br><h5>  Reactivity Observer: </h5><br>  First of all, we need to learn how to separate the request data from the query design; for this, the <strong>sensitivities</strong> parameter was entered.  This parameter contains data that can be changed.  Now the entry in the <strong>Neo4jCacheCollection</strong> collection looks like this: <br><br><pre> <code class="javascript hljs">uid <span class="hljs-comment"><span class="hljs-comment">// Unique hashed ID of the query data // Parsed data returned from Graph query // Original Cypher query string sensitivities // Sensitive data, which contains a map of parameters, and hardcoded data into query opts // Original map of parameters for the Cypher query type // Type of query ('READ'|'WRITE') created // Creation time</span></span></code> </pre><br><br><h4>  We connect observer and listener: </h4><br><ul><li>  Put a wiretap on all requests to Neo4j; </li><li>  We <strong>get the sensitivities of the</strong> current request; </li><li>  We find all requests for reading, which include <strong>sensitivities</strong> from the current request; </li><li>  Run the resampling for the resulting matches; </li><li>  Further necessary reactivity will provide us a layer in the form of MongoDB. </li></ul><br><br>  We managed to provide data updates when they change - on all Clients, in a very simple way. <br><br><h4>  We get only the data we need </h4><br>  The third problem was the data that came from Neo4j.  In addition to the fields we requested, we also get a bunch of empty objects that are returned to us by the npm package.  Empty objects weigh a lot and do not contain information, we have nothing to store them.  For the separation of useful and requested data, the <strong>parseReturn</strong> method was written, which parsed the query in the database (Cypher query) and understood what data was requested and what fields the developer wanted to receive.  After that, for each requested information, an object was created containing an array of nodes with their data and metadata.  If relations of nodes are requested, each node contains <strong>relations</strong> object containing data in the form of the following parameters: <br><br><ul><li>  extensions </li><li>  start </li><li>  end </li><li>  self </li><li>  type </li></ul><br><br><h4>  We deliver updates to customers </h4><br>  We learned to update the data in MongoDB and monitor their changes in Neo4j, but the embedded objects in the returned data will not be updated by themselves.  The functionality offered by the reactive-var package came to our rescue.  For this, data on the Client upon receipt from the <strong>Neo4jCache</strong> collection are assigned and returned via <strong>ReactiveVar</strong> .  On the Server, upon receipt from the collection, <strong>Neo4jCache</strong> will be returned from promise.  On the server and the Client, it is enough to call the <strong>get ()</strong> method to <strong>get the</strong> data reactively.  For those who need to get <strong>Mongo \ Cursor</strong> there is a property <strong>cursor</strong> . <br><br>  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   (  ) */</span></span> allUsers = Meteor.neo4j.query(<span class="hljs-string"><span class="hljs-string">'MATCH (users:User) RETURN users'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = allUsers.get().users; <span class="hljs-comment"><span class="hljs-comment">/*  Mongo\Cursor  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersCursor = allUsers.cursor; <span class="hljs-comment"><span class="hljs-comment">/*   (  )  callback*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> allUsers; Meteor.neo4j.query(<span class="hljs-string"><span class="hljs-string">'MATCH (users:User) RETURN users'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ allUsers = data.user; });</code> </pre><br>  At this stage, we created a test application and published it on GitHub.  A week later, the developer community helped us ‚Äúfinish‚Äù the driver and fix minor bugs.  I will be glad to questions and suggestions for improvement and further development of the project.  Thanks for attention. <br><br>  References: <br><ul><li>  NPM package: <a href="https://github.com/thingdom/node-neo4j">node-neo4j</a> </li><li>  Neo4j Meteor Driver: <a href="https://github.com/VeliovGroup/ostrio-neo4jdriver">neo4jdriver</a> </li><li>  Neo4j Meteor Reactivity layer: <a href="https://github.com/VeliovGroup/ostrio-Neo4jreactivity">neo4jreactivity</a> </li><li>  An example of using Neo4j in Meteor: <a href="https://github.com/VeliovGroup/Meteor-Leaderboard-Neo4j">Neo4j based Leaderboard Meteor app</a> </li></ul><br><br>  PS At the moment, the company Neo4j is actively involved in the development of the project and recognized this driver for Meteor as official. </div><p>Source: <a href="https://habr.com/ru/post/248465/">https://habr.com/ru/post/248465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248453/index.html">Automated testing of services using the MQ protocol using JMeter</a></li>
<li><a href="../248455/index.html">CrystaX NDK 10.1 release</a></li>
<li><a href="../248457/index.html">Introduction to the development of web-applications on PSGI / Plack. Part 4. Asynchrony</a></li>
<li><a href="../248459/index.html">Remove images from cartridges for Dendy / Famicom / NES</a></li>
<li><a href="../248463/index.html">How to quickly assess what is in the infrastructure and how is it used (for how much)?</a></li>
<li><a href="../248467/index.html">Opened vacancies in the laboratory of software engineering</a></li>
<li><a href="../248469/index.html">(Kiev) From January 27 to January 30 the course ‚ÄúENA 15.3: Switch Operation, Configuration & Management‚Äù will take place</a></li>
<li><a href="../248475/index.html">C raffle for the C ++ Russia conference ticket from JetBrains</a></li>
<li><a href="../248477/index.html">Video reports from GDG DevFest Voronezh 2014</a></li>
<li><a href="../248479/index.html">Development experience for Android Wear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>