<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Azure Service Fabric: Second Steps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Charlie Chaplin again in the factory in the film "New Times" 



 Continuing the conversation about Azure Service Fabric. In the previous article, I m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Azure Service Fabric: Second Steps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4dd/bc5/edd/4ddbc5edd6a942eaa7ac4fbadba03b83.jpg"><br><p>  <i>Charlie Chaplin again in the factory in the film "New Times"</i> <br></p><br><p>  Continuing the conversation about Azure Service Fabric.  In the previous <a href="https://habrahabr.ru/post/303924/">article,</a> I mentioned plans to write first about stateful services, and then go to the model of actors in ASF.  The concept has changed - I thought that it would be nice for examples to use, if not a production-solution, then something close, so that there would be a theoretical advantage and practical meaning.  It is possible to combine all the components of ASF in one bottle - so that the cows feed, and the amusement park, and Winnie the Pooh and everything.  It was with such thoughts that I went to the cemetery of home projects in search of a candidate for animation. </p><br><a name="habracut"></a><br><p></p><h3>  The living Dead </h3><br>  And there was such a candidate.  How they like to write in ‚Äúiron‚Äù articles, ‚Äúdigging into the boxes with spare parts‚Äù fished out the once-unfinished library of working with the <a href="https://ru.wikipedia.org/wiki/Advanced_Direct_Connect">Advanced Direct Connect</a> protocol.  ‚ÄúIt‚Äôs awful, terrible inside‚Äù, however, having cleaned the dust with a file, he was convinced that life was still warm inside.  The library was once intended for an unwritten ADC client, but why not write an ADC hub based on it?  Here is an idea, fresh and original - you can try. <p></p><br><div class="spoiler">  <b class="spoiler_title">What is Advanced Direct Connect?</b> <div class="spoiler_text"><p>  The ADC protocol appeared more than 10 years ago, in 2004 (the latest version 1.0.3 in 2013) as the successor of NMDC (it‚Äôs also just DC).  As in NMDC, ADC network nodes exchange simple text commands.  There are only two types of nodes - this is the central node (hub) and end clients that join the hub and each other.  Through the hub, clients can chat (chat) and search for the necessary files, while data transfer is carried out directly between clients, bypassing the hub.  Roughly speaking, the hub serves to authenticate clients, store their list and send commands between clients.  The only existing transport I know is TCP, adc: // addressing scheme, the port is not defined by the standard, but in practice the usual DC 411 is used. Clients have their own Private ID, but more importantly, each connected client is first issued a SID (session identifier) ‚Äã‚Äãby which his (client) and other clients. </p><br><img src="https://habrastorage.org/files/1f5/eca/8f5/1f5eca8f5c444fcb9fd5d1b987a3ad6e.png"><br><p>  <i>Typical P2P connections are valid for ADC</i> </p><br><p>  The protocol is extensible - you can add both completely new commands and parameters to existing commands.  The list of supported features each hub / client is announced when establishing a connection.  Mandatory support for basic ADC features for the hub and client, plus TCPx / UDPx for the client for file sharing.  Extensions are quite a powerful mechanism for increasing the capabilities of the protocol - for example, extensions include both a few additional hashing functions (the coordination of the function used is in the basic capabilities at the client-hub connection installation stage) and the secure ADCS connection. </p><br><p>  With regard to the current state of affairs, then, oddly enough, the P2P area is still alive (of course, I do not consider torrents that are always well-known).  Both hubs and heirs of StrongDC ++ (I used to use this client myself) are still being developed, so the problem to be solved has not completely lost its applied meaning, going into the category of academic ones. </p></div></div><br><p>  Unfortunately, the ADC specification leaves room for imagination - not exactly ‚Äúthe music for the game is written by professional programmers,‚Äù but also, say, RFC accuracy or W3C standards are far away from it.  Because of this, along the way, we had to clarify the details of the existing ADC implementations (ADCH ++, AirDC ++, etc.). </p><br><p></p><h3>  Model to build </h3><br>  I will begin, as usual, with a general architectural estimate.  For simplicity, the hub will be open, that is, users can log in without registration and passwords, but their names must be unique.  As you go, you can see three logical parts of the overall picture - this is a TCP connection server, then objects that implement ADC to exchange with clients, one for each client (I will call them users) and, finally, a general catalog of all active clients. <p></p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/38a/e10/568/38ae105689d84f2eb40407ccc0f4cd07.png"></div><br><p>  The TCP server will establish TCP connections and exchange serialized ADC messages with the client, users are responsible for correctly implementing the protocol according to the specification, and the catalog has the task of maintaining a list of active clients (including issuing their identifiers) and broadcasting messages.  Here from this stove and I will dance. </p><br><h3>  Snapping to the terrain </h3><br><p>  Now each logical part must find a match among the components of the ASF.  The main limitation is the minimum of the self-written code and the maximum of the existing capabilities in ASF. </p><br><h4>  TCP server </h4><br><p>  The TCP server does not have a status and needs one instance on each node of the ASF cluster - obviously, this is a <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-services-quick-start/">stateless service</a> (described in the previous article, so I will not repeat). </p><br><h4>  Users </h4><br><p>  I will try to entrust the exchange of ADC teams with clients to the <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-introduction/">actors</a> . </p><br><h5>  Actors </h5><br><p>  <a href="https://en.wikipedia.org/wiki/Actor_model">The model of actors</a> (actor model) appeared, oddly enough, from the scientific community (however, in 1973, for the then computer science, this is not surprising).  According to this model, an entity is called an entity, which (as a rule) has a state, functions independently of other actors, can asynchronously send and receive messages, as well as create other actors.  The aggregate (or system) of actors can unite actors of different types.  For a message exchange, each actor has a special address (usually, numeric or text).  It is important to understand that all the actors operate in parallel, the message exchange is asynchronous, but the processing of these messages goes sequentially - the actor is ‚Äúsingle-threaded‚Äù, serves as a synchronization point and processes at most one message at a time. </p><br><p>  This speculative model can be implemented differently - I am aware of three implementations of the actors <a href="">Akka.NET</a> , <a href="http://dotnet.github.io/orleans/">Orleans</a> and ASF actors.  In Akka.NET, the creation of an actor, its deletion from the system, and sending messages to it are explicitly highlighted.  Akka.NET actors form a hierarchy, so that ‚Äúparents‚Äù can follow the behavior of ‚Äúchildren.‚Äù  In Orleans and ASF, they chose a different path - they adopted a flat <a href="https://www.microsoft.com/en-us/research/publication/orleans-distributed-virtual-actors-for-programmability-and-scalability/">model of distributed virtual actors</a> , in which all actors always exist, but until the first call in an implicit state.  When called, the actor is created and then its state is maintained between reboots.  Asynchronous message passing is modeled by C # interface calls, and for complete ‚Äúgalvanic isolation‚Äù Orleans contains persistent <a href="http://dotnet.github.io/orleans/Orleans-Streams/">Streams</a> that implement Pub-Sub.  There is no ASF Streams, but there <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-events/">are actor events</a> that you can also subscribe to.  And (as in Akka.NET) there is the removal of the actor and the clearing of its state - after the removal, the actor goes back to the ‚Äúworld of shadows‚Äù before the next call.  As you can see, in all implementations there are both similar and different features. </p><br><p>  Oddly enough, quite often the question is - how does an ASF actor differ from an ASF service?  See for yourself - a service instance is created once at the cluster start, then it works until the ASF stops or restarts, it has external and / or internal communication points.  Actors instances are created and deleted by external queries, and their number is limited only by the physical capabilities of the cluster.  Therefore, if it is necessary to implement a collection of objects (possibly of different types), which should dynamically change in the course of work, these are actors.  If you need to create a known number of objects in advance, especially if these objects implement external communications or internal functionality, these are services.  And it is important to remember that the actors process calls to them sequentially, and services in parallel. </p><br><h4>  User Directory </h4><br><p>  Coming back to our components - for the directory of active clients it is logical to choose a <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-services-quick-start/">stateful</a> service. </p><br><h5>  Stateful services </h5><br><p> In short, stateful services are the same as stateless, but with state.  And indeed, their life cycle is similar - the same OnOpen, OnClose and RunAsync.  There are also listeners for communications, ASF Remoting, etc. is also possible. However, the presence of the state introduces noticeable differences.  First of all, there are differences in terminology - if it makes sense for stateless services to talk about instances, then stateful services have replicas.  Replicas are combined into <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-concepts-partitioning/">replica sets</a> (replica set), each set of replicas has its own state, independent of the other sets in this service.  In each set, only one replica is primary, and the rest are secondary ‚Äî only the primary replica can change the state (and only for it the life-cycle functions are called), all other states only read.  If the service is partitioned, then each partition is such a set of replicas and, accordingly, has its own separate state.  Both partitions and the number of replicas in them are set ‚Äî again, as for stateless services ‚Äî through the application configuration.  In the event of a primary replica falling down, one of the secondary ones assumes this role, therefore, for reliability, the ASF scatters all the replicas of one set across the cluster nodes, and the state of the service is replicated between the nodes.  Only objects originating from the IReliableState interface can be stored.  By itself, the interface resembles a marker; it is impossible to implement it properly, so out of the box there are actually only two reliable objects: ReliableDictionary and ReliableQueue (dictionary and FIFO queue).  You can use transactions to synchronize changes in several reliable-objects. </p><br><p>  Total goes: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b7e/836/e47/b7e836e470714b38a38b99cdb3214ddd.png"></div><br><p></p><h3>  The devil is in the details </h3><br>  Brainstorming is over and it's time to move on to the implementation of all the above.  Here I will try to avoid going into technical details, limited to a general description and subtle places; if necessary, an inquisitive reader can refer directly to the source code (there is a link at the end of the article). <br>  So, in order. <p></p><br><h4>  TCP server </h4><br><p>  For a TCP server, you can use standard TcpListener / TcpClient, which is wrapped in a non-standard TcpCommuncationListener.  TcpListener runs on OpenAsync, stops on CloseAsync.  and the TcpCommuncationListener itself is created in CreateServiceInstanceListeners. <br>  In the configuration there is a small detail - for local debugging in Local.xml I put </p><pre>  &lt;Parameter Name = "TcpServer_InstanceCount" Value = "1" /&gt; </pre>  , and in parameters for Azure will be <pre>  &lt;Parameter Name = "TcpServer_InstanceCount" Value = "- 1" /&gt; </pre>  This is because the nodes of the debug cluster run locally on the same computer and cannot divide the 411 port among themselves; therefore, only one instance of the service is needed.  '-1' means that one instance of the service must be running on each node of the ASF cluster ‚Äî in Azure, the ASF nodes are located on different VMs and each has its own 411 port. <p></p><br><p>  How to contact the right actor and what is his general address?  This will be discussed further in the implementation of actors, but for now the first problem (however predictable) is the installation of a TCP connection, which created an instance of TcpClient, tightly pinning it to the cluster node with which the client connected.  The actor can move through the nodes, but it is easy to call him - he is addressing, but how to call TcpClient from the actor?  After all, messages must be both received and sent.  Through the stateless service itself it is impossible - it is not known which of the instances of the service is the desired TcpClient.  And then the events of the actors come to the rescue - TcpClient can subscribe to the events of ‚Äúits‚Äù actor and receive outgoing messages through them (I would prefer streams, but I try to do what is). </p><br><h4>  Users </h4><br><p>  The actor has only two functions - to receive and process the next message, and send a message to the client.  Nevertheless, this is the most confusing part of the hub, since it is up to the actor to support the protocol.  Not the binomial of Newton, but there is also something to think about.  First you need to choose what to address the actor.  In the protocol, the client addresses the SID that is issued by the hub - why not use this SID as the address of the ASF actor?  Further, the ADC assumes four protocol states for the hub - PROTOCOL (negotiation of connection parameters), IDENTIFY (client information), VERIFY (password check), NORMAL (normal operation).  Since the hub is open, there are no passwords and VERIFY is not required.  And since the actor in ASF is virtual, it makes sense to add the state UNKNOWN for an actor who seems to be alive, but still / is not connected anywhere. </p><br><div class="spoiler">  <b class="spoiler_title">State machine</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/227/f74/013/227f740135cb4673983f1d0da71c1f54"></div><br><p>  As soon as there are states, the <a href="https://en.wikipedia.org/wiki/State_pattern">state machine</a> immediately appears - the incoming ADC commands will be processed by the current state and serve as triggers for the transition between states.  ASF is asynchronous through and through, so the state machine needs asynchronous.  The search for ready-made libraries produced not so many options.  Stateless behind the authorship of the notorious Nicholas Blumhardt (he is the author of Autofac and Serilog) and <a href="https://github.com/appccelerate/statemachine">Appcelerate</a> (nee bbv.Common) were considered as applicants.  Both did not fit, because they are perfectly synchronous.  There is also an asynchronous heir to stateless <a href="https://github.com/prasannavl/LiquidState">LiquidState</a> , but it was not suitable for lack of functionality.  I really do not like to write bicycles, but then I had to, it is easy.  Based on the description of the <a href="http://www.omg.org/spec/UML/2.5/PDF">UML State Machine</a> (by the way, I recommend - this is a good formal model, including machines Miles and Mura). </p></div></div><br><p>  In this part of the development problems arose as many as two.  The first and main thing is the ‚Äúone-threading‚Äù of the actor.  Formally, this means that it is possible to call another object from the actor, but from this call, the actor cannot be called back.  In fact, ASF does support the <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-reentrancy/">actor's reentrancy</a> , but only if the call chain started from him.  Moreover, such a resolution only concerns calls between actors - to call, say, the service from the actor and call the actor back again is impossible.  And such functionality is needed, for example, for broadcasting, which the actor initiates, and executes the directory, and the message must go away to the newsletter himself.  I did not find a good solution, so I simply divided the actor into two parts - one main, receiving messages from the client and managing the state of the actor, and the second additional one, which simply sends messages to the client.  As a result, we have two actors, through which unidirectional data flows go.  The types of actors are different, so you can address them equally through the SID (in ASF, the type of actor is in its address, so even for identical SIDs, the addresses of the actors will be different). </p><br><p>  The second problem is the connection setup time (in terms of ADC, this is a transition to the NORMAL state).  It makes sense to limit it, and the situation is aggravated by the fact that the progenitor DC uses the same port, and the hub sends the first message to DC.  As a result, DC clients, having connected, will wait for a response before the second coming.  It's time to apply <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-actors-timers-reminders/">timers and reminders</a> ASF. </p><br><h5>  Timers and Reminders </h5><br><p>  Timers and reminders in ASF are, as their name implies, alarm clocks.  They are similar, but only in that they call specified functions according to specified intervals.  The timer is a more lightweight object that exists only with the active actor, and disappears when the actor is deactivated.  The reminder is stored and works separately from the actor, so that it can even activate the deactivated actor.  The calls of the actor's methods for timers and reminders, like all the others, are performed all the same ‚Äúin a single thread‚Äù, but the call from the reminder is considered a ‚Äúfull-fledged‚Äù call, which is taken into account when deactivating inactive actors.  A call from a timer using an actor is not considered, so it is impossible to keep the actor from deactivating with a timer. </p><br><p>  To limit the connection time, the easiest way is to use a one-time reminder, who sends a pseudo ADC command ConnectionTimedOut - the NORMAL state simply swallows it, and all others will break the connection according to the protocol. </p><br><h4>  User Directory </h4><br><p>  The service does not have external communications and is intended solely for performing internal tasks, so it is logical to use <a href="https://azure.microsoft.com/en-us/documentation/articles/service-fabric-reliable-services-communication-remoting/">Remoting</a> to communicate with it.  There is no special reason to partition the catalog - the state of the service stores a collection of identifiers, and the service itself implements operations on it as a whole.  However, broadcasting can create a load for which one primary replica of the service may not be enough.  And here you can take advantage of the curious feature of stateful services - they can open listeners even on secondary replicas, but only for reading.  Since mailings in the state of the directory do not change anything, nothing prevents them from using all the replicas of the service. </p><br><p>  The list of current SIDs is stored in the ReliableDictionary dictionary - it can be enumerated as part of a transaction, and information about the user (name, supported client capabilities, etc.) is stored in the key values.  A separate ReliableDictionary must also be used to verify the uniqueness of the client's name ‚Äî simply as a unique key with no values.  There was no specific rake in the development of the catalog, but there is a nuance associated with disconnecting the client. </p><br><p>  There are only two reasons for the client to disconnect - this is an error in the communication channel (the source is a TCP server) and an error in the protocol (the source is an actor).  Both errors will be considered fatal and break the connection with the client.  I would like to handle errors in a centralized way, and it is logical to do this in the actor, as responsible for the protocol.  To do this, you can do the same as with the reminder - add another pseudo ADC message DisconnectOccured and include it in the state machine of the actor.  For a full cleanup, it would be good to completely remove the actor, but how to do this if the actor is the initiator of the shutdown?  This functionality can be transferred to the directory in which to use ReliableQueue ‚Äî the SID of clients to be disconnected is added to this queue, and in the RunAsync catalog this queue is processed in an infinite loop that receives identifiers from the queue and deletes the corresponding actors. </p><br><p>  Here is such a state: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/486/ea6/90a/486ea690addd40b5abee7f2f6081ecee"></div><br><p>  And in general, development has come to an end.  In testing on a local cluster, two ADC clients (I used AirDC ++) connected to the newly-baked hub ‚Äúsaw‚Äù each other and were able to exchange files.  Still not a bang, but you can already try to deploy a hub in Azure. </p><br><h3>  Deploy to Azure </h3><br><p>  The most boring part of the story, since the deployment went like a note.  For deployment I used Free Trial subscription, ASF control is available from the <a href="https://portal.azure.com/">new portal</a> .  First, the cluster name, RDP user data, resource group, and location are selected.  For the number of cluster nodes, I chose three, because ‚ÄúChoosing less than 5‚Äù, I could not find out what a test cluster is, but the portal itself writes this recommendation.  In custom endpoints, you need to remember to put 411 so that the load balancer will let connections through this port.  For test purposes, it is easier to create an unsecure cluster - that's basically it.  Despite the apparent simplicity of the ASF cluster, Azure creates a whole range of resources: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ca7/297/69f/ca729769f34f4df8b84036777ba3e494"></div><br><p>  The list includes vhd storage for VMs (it's unclear why there are 5, not 3), storage for Azure Diagnostics logs and information, a set of virtual machines that are connected in a VPN, and covering all of this load balancer with its public IP address. </p><br><p>  Deploying to Azure did reveal one problem that I left unresolved.  It seems that Azure checks the availability of port 411, creating and immediately terminating TCP connections over it.  The TCP server immediately after the occurrence of the connection creates a SID, which immediately turns out to be unnecessary.  Theoretically, this is the correct behavior - the server may be full (in the ADC there is a limit on the number of users for one hub), but in practice this approach fails.  On the other hand, for simple testing, these empty connections are too frequent - in general, while this is a mystery covered in darkness. </p><br><p>  However, this does not affect the functioning, so again the test, again two ADC clients, again file sharing - everything seems to be working.  Now, absolutely cheers. </p><br><h3>  Conclusion </h3><br><p>  In general, the idea justified itself - it was possible to walk through the entire ASF, and if not use it, then at least get acquainted with the various possibilities and details of its functioning.  And although not everything went smoothly at ASF, the end result is not so bad for a test project.  I hope that the readers were curious.  The source code of the entire project can be found on <a href="https://github.com/Caraul/FabricAdcHub">GitHub</a> - we say goodbye to new articles. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/304236/">https://habr.com/ru/post/304236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304226/index.html">How to become a specialist in the field of "big data"?</a></li>
<li><a href="../304228/index.html">MQTT and Modbus: a comparison of the protocols used in IoT gateways</a></li>
<li><a href="../304230/index.html">Game of Thrones. Search for dialog authors in books</a></li>
<li><a href="../304232/index.html">How does a little bird find a golden ‚Äúcage‚Äù? Advice to freelancers in finding employment in the office</a></li>
<li><a href="../304234/index.html">In the wake of WWDC 2016. Practical Guide</a></li>
<li><a href="../304238/index.html">Decide in your mind: What you need to know when starting a business in e-commerce</a></li>
<li><a href="../304242/index.html">Why do you need to model individual and sample scenarios?</a></li>
<li><a href="../304244/index.html">Thought is material: Alan Turing as a ‚Äúuniversal calculator‚Äù</a></li>
<li><a href="../304246/index.html">As I wrote classic tanks with intelligence</a></li>
<li><a href="../304248/index.html">A working day on Wall Street: what hedge fund financial analysts actually do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>