<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redefining method implementation. Inspired by java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation can be read here habrahabr.ru/post/170265 

 Introduction 
 Studying the basics of developing for Android, I had to get acquainted with s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Redefining method implementation. Inspired by java</h1><div class="post__text post__text-html js-mediator-article">  Continuation can be read here <a href="http://habrahabr.ru/post/170265/">habrahabr.ru/post/170265</a> <br><br><h4>  Introduction </h4><br>  Studying the basics of developing for Android, I had to get acquainted with such a wonderful language like Java.  Reading the next section of Google's GetStarted, I came across this design: <br><br><pre><code class="java hljs">Button.OnClickListener mTakePicSOnClickListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Button.OnClickListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v)</span></span></span><span class="hljs-function"> </span></span>{ } };</code> </pre> <br>  Declare a representative of OnClickListener and override his onClick method (correct me Java programmers).  Hmm, I thought, but this feature would be cool to fuck in Objective-C, namely the ability to override the implementation of a method for an object (a specific object, and not a method implementation for all objects of a class) and even through blocks in runtime (!) And forgot about all this ... until I found myself in a half-empty bus in rainy weather.  There was a lot of time and I decided to think about what can be done here. <br>  Why was this necessary?  Initially, I wanted to be able to do this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="objectivec hljs">tableView1.delegate = [[<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> new] override:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(tableView:didDeselectRowAtIndexPath:) imp:^<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>* ip){ <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"selected row %i"</span></span>, ip.row); }] tableView2.delegate = [[<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> new] override:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(tableView:didDeselectRowAtIndexPath:) imp:^<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>* ip){ <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"selected row %i"</span></span>, ip.row); }]</code> </pre><br>  Please note that it is supposed to change the delegate and add / predetermine methods for it.  And the tableView remains original, without any changes. <br><br>  In that very place, I felt that this was quite realizable thanks to the <s>rich inner world of the</s> Objective-C Runtime. <br>  And yes, that very place did not let me down. <br><a name="habracut"></a><br><br><h4>  Examples </h4><br>  Let's start with examples.  On the implementation and pitfalls, I'll tell you below <br><h6>  1) Override the viewWillApear method for the newly created UIViewContoller </h6><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span>* vc = [[<span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> new] overrideMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(viewWillAppear:) blockImp:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span>* selfVC, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> anim) { selfVC.view.backgroundColor=[<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor]; <span class="hljs-comment"><span class="hljs-comment">//  view }]; [self presentViewController:vc animated:YES completion:^{ }]; // vc</span></span></code> </pre><br><h6>  2) Implementing the UITableViewDataSource protocol </h6><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// ds (  MMProxy ) MMProxy *ds = [MMProxy proxyWithMMObject]; //     NSArray *arr=@[@"one",@"two",@"three", @"four",@"five"]; //   (  ,    ) //:  isRequired         (@required) //   (@option) //     [ds addMethod:@selector(numberOfSectionsInTableView:) fromProtocol:@protocol(UITableViewDataSource) isRequired:NO blockImp:^NSUInteger(id object, UITableView* tb) { return 1; }]; [ds addMethod:@selector(tableView:numberOfRowsInSection:) fromProtocol:@protocol(UITableViewDataSource) isRequired:YES blockImp:^NSUInteger (id object, UITableView* tb) { return [arr count]; }]; [ds addMethod:@selector(tableView:cellForRowAtIndexPath:) fromProtocol:@protocol(UITableViewDataSource) isRequired:YES blockImp:^id(id obj, UITableView* tb, NSIndexPath* indexPath) { static NSString *TableIdentifier = @"SimpleTableItem"; UITableViewCell *cell = [tb dequeueReusableCellWithIdentifier:TableIdentifier]; if (cell == nil) cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:TableIdentifier]; cell.textLabel.text=arr[indexPath.row]; return cell; }]; self.tableView.dataSource=(id&lt;UITableViewDataSource&gt;)ds; [self.tableView reloadData];</span></span></code> </pre><br><h6>  3) Like Java. </h6><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//UIOnClickListener  .    onClick:    //-(IBAction)onClick:(id)sender{}; [button1 addTarget:[[UIOnClickListener new] overrideMethod:@selector(onClick:) blockImp:^void(id obj,id sender){ NSLog(@"bump 1"); }] action:@selector(onClick:) forControlEvents:UIControlEventTouchUpInside]; [button2 addTarget:[[UIOnClickListener new] overrideMethod:@selector(onClick:) blockImp:^void(id obj,id sender){ NSLog(@"bump 2"); }] action:@selector(onClick:) forControlEvents:UIControlEventTouchUpInside];</span></span></code> </pre><br><br><h4>  Implementation </h4><br>  So, I had an idea and a plan for its implementation: <br><ul><li>  get the desired method by the selector (Method) </li><li>  override its implementation (IMP).  Of course, through the blocks.  For stylish and fashionable now </li><li>  ... </li><li>  PROFIT </li></ul><br>  Fool, how naive I was. <br><br><h6>  Attempt # 1 </h6><br>  Here you should probably make a small digression and tell a little about the methods.  Let's see what a method in Objective-C is: <br><ul><li>  SEL - selector, method name </li><li>  IMP - implementation of the method.  Normal C function </li><li>  method_types is a string describing the types of the method arguments, as well as the type of the value that the method returns. </li></ul><br>  Since it was planned to change the implementation of the method, first of all it was necessary to deal with the IMP.  But to my regret, Apple's documentation was too superficial.  All that could be found by IMP on this <a href="https://developer.apple.com/library/mac/">page</a> : <br><blockquote>  An Objective-C method is simply a function.  You can add a function using the function class_addMethod.  Therefore, given the following function: </blockquote><br>  and a small example IMP for a method of the form <i>- (void) method;</i>  But what to do with methods that have parameters (or returning something) was not clear.  And the most important thing!  C-function is good, but I would like to use blocks, how to deal with them?  These two questions led me to this wonderful <a href="http://www.friday.com/bbum/2011/03/17/ios-4-3-imp_implementationwithblock/">article</a> and I received answers to all my questions.  Starting with ios 4 Runtime Api allows you to get IMP directly from the unit.  By the way, Apple‚Äôs Runtime API documentation is not a word about this.  I will give a description of the IMP and examples from the same article: <br><ul><li>  IMP in the form of a C function has at least two arguments: the s-object whose method was invoked (probably correct to say the object to which the message was sent) and _c is the method selector.  All the rest are method arguments. </li><li>  IMP as a block is similar to the previous one, but without a selector. </li></ul><br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)doSomething: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*doSomethingIMP)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s, SEL _c); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^doSomethingBLOCK)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s); -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)doSomethingWith:(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*doSomethingWithIMP)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s, SEL _c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^doSomethingWithBLOCK)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x); -(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)doToThis:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>*)n withThat:(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)d; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(*doToThis_withThatIMP)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s, SEL _c, <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *n, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(^doToThis_withThatBLOCK)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> s, <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *n, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d);</code> </pre><br><br>  At that time, I could get information about the method, create an IMP from the block and replace the old IMP with a new one from the block, all thanks to runtime.  That's it, I thought, how simple it is, and why has nobody done it yet?  And only here I realized my mistake ... I will show with an example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *str1= <span class="hljs-string"><span class="hljs-string">@""</span></span>; [str1 overrideMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(intValue) imp:^<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>* selfStr){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;}]; <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *str2= <span class="hljs-string"><span class="hljs-string">@""</span></span>; [str2 overrideMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(intValue) imp:^<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>* selfStr){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;}]; [str1 intValue]; <span class="hljs-comment"><span class="hljs-comment">//  2,   1 [str2 intValue]; //  2</span></span></code> </pre><br>  Not that this is bad ... redefining the implementation of a method for all instances of a class using a block is cool, but not exactly what I needed initially. <br><br><h6>  Attempt # 2 </h6><br>  And I started all over again, making a ‚Äúknight's move‚Äù.  It was decided instead of overriding the implementation of the old method to generate a new one, but with a unique name.  And, intercepting sending a message to an object, replace the command / method selector.  In the role of the unique name of the selector, the pair &lt;address&gt; _ &lt;old selector&gt; was selected.  Those.  The previous code should have been converted to this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 0x0000042 NSString *str1= @""; //   0x0000042_intValue [str1 overrideMethod:@selector(intValue) imp:^int(NSString* selfStr){ return 1;}]; // 0x0000043 NSString *str2= @""; //   0x0000043_intValue [str2 overrideMethod:@selector(intValue) imp:^int(NSString* selfStr){ return 2;}]; [str1 0x0000042_intValue]; // 1 [str2 0x0000043_intValue]; // 2</span></span></code> </pre><br><br>  Of course, no problems for the user.  It was planned to do all this through the mechanism of intercepting messages.  Most likely this is my mistake, but I didn‚Äôt know and now I don‚Äôt know how it can be implemented differently, maybe you have some ideas? <br><br>  In Objective-C, it is possible to intercept the sending of a message to an object in the following cases: <br><ol><li>  when using NSProxy wrapper </li><li>  if the object receives a message that it cannot process (unrecognized selector) </li></ol><br><br>  As you see, it is impossible to intercept any message sent to the NSObject object (or did I just not find it?). <br>  Using the NSProxy wrapper could help, but it: <br>  1) not so elegant <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *str1= <span class="hljs-string"><span class="hljs-string">@""</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">NSProxy</span></span> *proxy=[<span class="hljs-built_in"><span class="hljs-built_in">NSProxy</span></span> proxyWithObject:str1]; [proxy overrideMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(intValue) imp:^<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>* selfStr){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;}]; [proxy intValue]; <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  2) Sometimes it does not work.  This is not how it can be done, since applicationDidBecomeActive will be sent to the delegate, not a wrapper from the proxy.  Why do so?  This is a completely different question ... <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)launchOptions { <span class="hljs-built_in"><span class="hljs-built_in">NSProxy</span></span> *p=[<span class="hljs-built_in"><span class="hljs-built_in">NSProxy</span></span> proxyWithObject:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Override point for customization after application launch. [p overrideMethod:@selector(applicationDidBecomeActive:) blockImp:^void(id obj,UIApplication* app) { UIAlertView *alv=[[UIAlertView alloc] initWithTitle:@"ss" message:nil delegate:nil cancelButtonTitle:@"fuuu" otherButtonTitles:nil]; [alv show]; [alv release]; }]; return YES; }</span></span></code> </pre><br>  And I decided to implement a redefinition of the implementation of the method through both mechanisms: <br>  1) via NSProxy.  As more correct, but not a universal solution <br>  2) through a crutch, but universal, for any representative of NSObject. <br>  And since NSObject and NSProxy are root classes, I theoretically implemented a predefined method implementation for any objective-c class at runtime.  In practice, this was not entirely true. <br><br>  So, briefly try to describe how everything works when using NSProxy: <br><ul><li>  when overriding the implementation of a method, a new method is generated of the form &lt;object address&gt; _ &lt;method selector&gt;. </li><li>  when sending a proxy message, it is checked whether the class has a method of the form &lt;object address&gt; _ &lt;method selector&gt; </li><li>  if there is such a method, then a message is sent to the object (not a proxy) with this selector. </li><li>  if there is no method, a message is sent to the object with the original selector &lt;method selector&gt; </li></ul><br><br>  How it all works when using the crutch for NSObject <br><ul><li>  implemented category for NSObject </li><li>  when overriding the implementation of a method, a new method is generated of the form &lt;object address&gt; _ &lt;method selector&gt;. </li><li>  it also generates a new method of the form &lt;mm_old&gt; _ &lt;method selector&gt;, which contains the IMP (implementation) of the original method </li><li>  the original method is ‚Äúdeleted‚Äù </li><li>  when sending a message to an object by the old selector, the forwardInvocation mechanism is triggered, since the old method is ‚Äúdeleted‚Äù </li><li>  In forwardInvocation, it is checked whether the class can handle a selector of the form &lt;object address&gt; _ &lt;method selector&gt;.  If so, it is called. </li><li>  in forwardInvocation, it checks if the class can handle the &lt;mm_old&gt; _ &lt;method selector&gt;.  If so, it is called. </li><li>  otherwise, we call [self doesNotRecognizeSelector: anInvocation.selector];  - standard implementation. </li></ul><br>  The use of such a crutch is fraught with problems.  So, for example, if a custom class overrides the forwardInvocation method, then for it override will no longer work correctly.  And most importantly, the destruction of the old method and working with forwardInvocation is a very serious blow to performance.  And for all instances of the class.  I will try to explain: if we redefine the intValue for one object in this way in the NSString class, then this class will never be the same.  Now when sending the intValue message, all representatives of the NSString will be called mm_old_intValue, and moreover through the forwardInvocation mechanism. <br><br>  By the way, about the removal.  Unfortunately in Objective-C 2.0, the ability to remove methods was removed.  For this, I had to make another crutch.  By deletion, I mean replacing IMP of a deleted method with IMP of a non-existing method.  Something like this <br><br><pre> <code class="objectivec hljs"> IMP forw=class_getMethodImplementation(clas, <span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(methodThatDoesNotExist:iHope:::::)); IMP oldImpl= method_setImplementation(method,forw);</code> </pre><br>  Or equivalently, use _objc_msgForward. <br><pre> <code class="objectivec hljs">IMP oldImpl= method_setImplementation(method,(IMP)_objc_msgForward);</code> </pre><br><br>  Yes, now everything does not look so rosy, as it was in the examples.  But what fun you can do by overriding the methods of viewControllers, AppDelegatov, delegates and other objects.  And all this in two lines of code.  And the methods are different: black, white, public, and <s>privat</s> .  Oh, something suffered me. <br><br><h6>  Restrictions </h6><br>  Although there are a few other limitations that I did not mention earlier: <br><ul><li>  You cannot override methods from the NSObject protocol (for both NSProxy and for the NSObject category), as well as methods of the NSInvokation class (for the NSObject category) </li><li>  to call the super method you will have to call runtime api </li><li>  to access the private properties of the object, you will have to refer to runtime api </li></ul><br>  Maybe something else I don't know about.  Such manipulations on the verge of a foul, they are like the East - a delicate matter. <br><br><h6>  How to use </h6><br>  There are two possible scenarios for changing the implementation: <br><br>  Using MMProxy wrapper.  To do this, you need to initialize MMProxy with the object that interests us and call the method to override it.  Messages should be sent to the proxy, not to the object. <br>  Example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">id</span></span> object; MMProxy *p= [MMProxy proxyWithObject:object]; [object overrideMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(onClick:) blockImp:^<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> obj,<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> sender){ }] ; [p onClick:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]</code> </pre><br>  For delegates, I recommend using a proxy created by the proxyWithMMObject method <br><pre> <code class="objectivec hljs"> MMProxy *ds = [MMProxy proxyWithMMObject]; [ds addMethod:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(numberOfSectionsInTableView:) fromProtocol:<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@protocol</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewDataSource</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isRequired</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NO</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blockImp</span></span></span><span class="hljs-class">:^</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSUInteger</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tb</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }];</code> </pre><br><br>  The second method is implemented through a category, and for this you can call the methods you need on any object inherited from NSObject.  I already spoke about restrictions. <br><br>  Both options implement a protocol with the following methods: <br>  - (id) overrideMethod: (SEL) sel blockImp: (id) block; <br>  allows you to change the implementation of the method.  If the method for the specified selector is not found by the class (or there are any other problems), an exception will be generated <br><br>  - (id) addMethod: (SEL) sel fromProtocol: (Protocol *) p isRequired: (BOOL) isReq blockImp: (id) block; <br>  allows to add a method to an object in case the class does not have such a method.  Similarly, if any problems occur, an exception will be thrown. <br><br><h6>  Application area </h6><br>  Separately, it is worth discussing the scope and general necessity of such an approach.  As for me, yes, it is necessary.  This is another approach that allows you not only to shoot yourself in the foot, but also to tear down the floor of the head. <br>  Well, among other things <br><ul><li>  fun </li><li>  adding block support to where everything was originally based on delegates.  And this is a universal solution when using NSProxy.  It is suitable for UIAlertViewDelegate, and for UIActionSheet, and for tableView, without the need to modify these classes (through categories or inheritance) </li><li>  debugging </li><li>  tests, this is of course not OCMock, but still. </li></ul><br>  Can "this" be used in industrial development.  Definitely not. <br>  At least for now.  But you can play now. <br>  And of course, the main goal of the article is to discuss. <br><br>  Download the test project and see the implementation here: <a href="https://github.com/Flanker4/MMMutableMethods/">github.com/Flanker4/MMMutableMethods</a> <br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">  ‚ÄúChukchi is not a writer, Chukchi reader.‚Äù Perhaps the article is written too incomprehensibly or contains errors.  I apologize, write LS, we will correct. </div></div></div><p>Source: <a href="https://habr.com/ru/post/168105/">https://habr.com/ru/post/168105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168091/index.html">LiveReload on Node.js</a></li>
<li><a href="../168095/index.html">Simple-Science - Simple Experiments (Digest # 15)</a></li>
<li><a href="../168097/index.html">Nokia, Elop Effect and Burning Platform</a></li>
<li><a href="../168099/index.html">Batch virus</a></li>
<li><a href="../168103/index.html">Lexand vs. BlackVue - FullHD DVRs</a></li>
<li><a href="../168109/index.html">3D printer prints lunar base of regolith</a></li>
<li><a href="../168111/index.html">Anti-GTD or anti-procrastination medication</a></li>
<li><a href="../168115/index.html">Logic - the most interesting news gaming and IT-industry ‚Ññ12</a></li>
<li><a href="../168117/index.html">BonBon - Sweet CSS3 Buttons</a></li>
<li><a href="../168119/index.html">Network Ring on Microcontrollers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>