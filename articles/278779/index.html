<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why is ownership / borrowing in Rust so complicated?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The original article was written by Ivan Sagalaev , living in Washington, husband of the notorious Alena C ++ . 

 The article itself. 

 Working with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why is ownership / borrowing in Rust so complicated?</h1><div class="post__text post__text-html js-mediator-article">  The original <a href="http://softwaremaniacs.org/blog/2016/02/12/ownership-borrowing-hard/">article was</a> written by <a href="http://softwaremaniacs.org/about/">Ivan Sagalaev</a> , living in Washington, husband of the notorious <a href="http://alenacpp.blogspot.ru/">Alena C ++</a> . <br><br>  <b>The article itself.</b> <br><br>  Working with pure functions is simple: you pass arguments and get results, without any side effects.  On the other hand, if the function produces side effects, such as changing your own arguments or global objects, then it is difficult to find the reasons for this.  We are also used to the fact that if we see something like <i>player.set_speed (5)</i> , then we can be sure that the <i>player</i> object is going to change in a predictable way (and maybe send some signals somewhere). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The system of <a href="https://doc.rust-lang.org/book/ownership.html">possession / borrowing of the Rust language</a> is complicated and it creates a completely new class of side effects. <br><a name="habracut"></a><br>  <b>Simple example</b> <br>  Consider this code: <br><pre><code class="cpp hljs">let point = Point {x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>}; let result = is_origin(point); println!(<span class="hljs-string"><span class="hljs-string">"{}: {}"</span></span>, point, result);</code> </pre> <br>  The experience of most programmers will not prepare for the fact that the <i>point</i> object suddenly <b>becomes inaccessible</b> after calling the <i>is_origin ()</i> function!  The compiler will not allow you to use it in the next line.  This is a side effect, something happened to the argument, but this is not at all what you have seen in other languages. <br><br>  This happens because the <i>point</i> object is moved (instead of being copied) to the function, and thus the function becomes responsible for its destruction.  The compiler interferes with the use of the object after the change of ownership.  There is a way to fix this: you need to either pass the argument by reference, or teach it to copy itself.  It makes sense if you know about the "default move".  But these things tend to come out randomly during some kind of innocent refactoring or, for example, when adding logging. <br><br>  <b>The example is more complicated</b> <br>  Consider a parser that takes some data from <i>lexer</i> and saves some state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> {</span></span> lexer: Lexer, state: State, } impl Parser { <span class="hljs-function"><span class="hljs-function">fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume_lexeme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;mut self)</span></span></span><span class="hljs-function"> -&gt; Lexeme </span></span>{ self.lexer.next() } <span class="hljs-function"><span class="hljs-function">pub fn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;mut self)</span></span></span><span class="hljs-function"> -&gt; Event </span></span>{ let lexeme = self.consume_lexeme(); <span class="hljs-comment"><span class="hljs-comment">//    if lexeme == SPECIAL_VALUE { self.state = State::Closed //    } } }</span></span></code> </pre><br>  Unnecessary at first glance, <i>consuming_lexeme ()</i> is simply a convenient wrapper around a long sequence of calls that I make in the above code.  <i>lexer.next ()</i> returns a self-contained lexeme by copying data from the <i>lexer</i> internal buffer.  But now we want to optimize this so that the tokens contain only references to this data in order to avoid copying.  Change the method declaration to the following: <br><pre> <code class="cpp hljs">pub fn next&lt;<span class="hljs-string"><span class="hljs-string">'a&gt;(&amp;'</span></span>a mut self) -&gt; Lexeme&lt;<span class="hljs-string"><span class="hljs-string">'a&gt;</span></span></code> </pre><br>  The mark <i>‚Äúa‚Äù</i> clearly tells us that the lifetime of the token is now related to the lifetime of the reference to <i>lexer</i> , with which we call the <i>.next ()</i> method.  Those.  cannot live by itself, but depends on the data in the <i>lexer</i> buffer.  And now <i>Parser :: next ()</i> stops working: <br><pre> <code class="cpp hljs">error: cannot assign to `self.state` because it is borrowed [E0506] : self.state    ,     self.state = State::Closed ^~~~~~~~~~~~~~~~~~~~~~~~~~ note: borrow of `self.state` occurs here :    `self.state` let lexeme = self.consume_lexeme(); ^~~~</code> </pre><br>  Simply put, the Rust compiler tells us that as long as <i>lexeme</i> is available in this block of code, it will not allow us to change <i>self.state</i> - another part of the parser.  But it is generally meaningless!  The culprit here is <i>consume_lexeme ()</i> .  Although in reality we only need <i>self.lexer</i> , we tell the compiler that we are referring to the entire parser (note <i>self</i> ).  And since this link can be changed, the compiler will not allow anyone to touch any part of the parser to change the data, now dependent on <i>lexeme</i> .  Thus, we have a side effect again: although we did not change the actual types in the function signature and the code is still correct and should work correctly, a change of ownership unexpectedly prevents it from being further compiled. <br><br>  Even though I understood the problem as a whole, it took me at least two days before it came to me and the correction became obvious. <br><br>  <b>Fix</b> <br>  The change <i>consume_lexeme ()</i> , which allows referring only to <i>lexer</i> and not to the entire parser, fixed the problem, but the code did not look idiomatic due to replacing the dot notation with a call to a normal function: <br><pre> <code class="cpp hljs">let lexeme = consume_lexeme(self.lexer); <span class="hljs-comment"><span class="hljs-comment">//     self.&lt;-&gt;</span></span></code> </pre><br>  Fortunately, Rust also allows you to go the right way.  Since in Rust the definition of data fields ( <i>struct</i> ) is different from the definition of methods ( <i>impl</i> ), I can define my own methods for any structure, even if it is imported from another namespace: <br><pre> <code class="cpp hljs">use lexer::Lexer; <span class="hljs-comment"><span class="hljs-comment">//   Lexer.       Lexer //     . impl Lexer { pub fn consume(&amp;mut self) -&gt; Lexeme { .. } } // ... let lexeme = self.lexer.consume(); //  !</span></span></code> </pre><br>  Gracefully! <br><br>  Checking borrowing in Rust is a great thing that makes you write more reliable code.  But this is different from what you are used to, and it will take time to develop effective work skills. <br><br>  <b>Reader Reviews</b> <br>  <b>Juarez:</b> I got the impression that Rust adds unnecessary complexity with the implementation of the ‚Äúdefault move‚Äù for elementary types.  A programmer everywhere has the added burden of boxing links.  In my opinion, it seems natural to think about: <br>  a) ‚Äúdefault copying‚Äù for elementary types <br>  b) ‚Äúdefault link‚Äù for composite types (structures, traits, etc.) <br>  c) ‚Äúmove by default‚Äù for composite types in asynchronous methods - from case to case. <br>  Did I miss something? <br>  <b>Ralf:</b> Notice, however, that what you call the ‚Äúeffect‚Äù here is actually very, very different from the ‚Äúeffects‚Äù that people usually mean when they talk about ‚Äúside effects‚Äù.  The concepts of ownership and movement are concepts only compile time, it does not change what your code does.  Consequently, this does not make reasoning about the behavior of your code more difficult, since the behavior does not change. <br><br>  In fact, side effects are now much more manageable.  This applies, in particular, to reasoning about unlimited effects, similar to those of C ++, where almost everywhere you can get access to all kinds of data under pseudonyms. <br><br>  The duty of checking borrowing and possession is not a new side effect, it is about limiting existing side effects.  If you own something or have a mutable link (which is necessarily unique), you can be sure that there are no unexpected (non-local) side effects of this object, because no one can have its alias.  By this I mean that calling some function for some data (which you own) will never magically change it.  If you have a shared link, you can be sure that there are no side effects, because no one can change the data.  When the compiler tells you that the data is being moved and you cannot use it, this is not a new side effect.  This ‚Äúsimple‚Äù compiler understanding of the side effects is necessary in order for it to be able to make sure that everything is under control. <br><br>  In C ++, if you pass the <i>Point</i> parameter before a certain function, the compiler makes an incomplete copy, and if the <i>Point</i> contains pointers, then this can lead to confusion.  Here, the <i>Point</i> object is safe to copy in a nearby context, but you must explicitly tell the compiler what you want: <br><pre> <code class="cpp hljs">#[derive(Copy,Clone)] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> ... }</code> </pre><br>  You may wonder why the compiler cannot understand this automatically.  It would be exactly the same as for <i>Send</i> . <br>  The problem here is the stability of the interface.  If you are writing a library that exports a type to which <i>Copy</i> is applied, then the library must always keep this <i>Copy</i> type in the future.  It must be the conscious choice of the author of the library to ensure that this type is and always will be <i>Copy</i> - due to the explicit annotation. <br><br>  <b>Afterword from the translator</b> : the impetus for the translation of this article was the desire to find out what kind of "a completely new class of side effects" appeared in Rust.  Although the article as a whole is curious, the author is in some misconception about a completely new class. </div><p>Source: <a href="https://habr.com/ru/post/278779/">https://habr.com/ru/post/278779/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278769/index.html">Extensible Android application code with MVP</a></li>
<li><a href="../278771/index.html">Import substitution successes or entertaining statistics based on the Register of Federal State Information Systems</a></li>
<li><a href="../278773/index.html">Grid implementation for working with large tables. Part 1</a></li>
<li><a href="../278775/index.html">We write on D for Raspberry Pi</a></li>
<li><a href="../278777/index.html">The digest of interesting materials for the mobile developer # 143 (February 29 - March 8)</a></li>
<li><a href="../278781/index.html">Adaptive Split View Controller and Popover in iOS 9 (Swift). Part 2</a></li>
<li><a href="../278783/index.html">Google fixed Android vulnerabilities</a></li>
<li><a href="../278785/index.html">Lessons from participation in the Dota Science hackathon in the framework of Data Fest 2</a></li>
<li><a href="../278787/index.html">√Öngstr√∂m Style System? The use of styles. S2</a></li>
<li><a href="../278789/index.html">Why I am NOT a TypeScript fan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>