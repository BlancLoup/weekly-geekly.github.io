<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Running cron inside the Docker container</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It just so happened that running cron in a Docker container is a very specific, if not hard to say. The network is full of solutions and ideas on this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Running cron inside the Docker container</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/redmadrobot/blog/305364/"><img src="https://habrastorage.org/files/e53/beb/02f/e53beb02fc0c404ba2d160ce79e2b538.jpg"></a> <br>  It just so happened that running cron in a Docker container is a very specific, if not hard to say.  The network is full of solutions and ideas on this topic.  Here is one of the most popular (and easiest) launch methods: <br><pre><code class="bash hljs">cron -f</code> </pre> <br>  But such a solution (and most of the others too) has a number of drawbacks that are difficult to get around right away: <br><ul><li>  inconvenience of viewing logs ( <strong>docker logs command</strong> does not work) </li><li>  cron uses its own Environment (the environment variables passed when the container is started are not visible for cron jobs) </li><li>  it is impossible to (gracefully) stop the container with the <strong>docker stop command</strong> (eventually SIGKILL arrives in the container) </li><li>  container stops with non-zero error code </li></ul><a name="habracut"></a><br><br><h2>  Logs </h2><br>  The problem of viewing logs using standard Docker tools is relatively easy to fix.  To do this, it is enough to decide on which file your cron job logs will be written to.  Suppose it is /var/log/cron.log: <br> <code>* * * * * www-data task.sh &gt;&gt; /var/log/cron.log 2&gt;&amp;1 <br></code> <br>  Starting after this container with the command: <br><pre> <code class="bash hljs">cron &amp;&amp; tail -f /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/cron.log</code> </pre><br>  we can always see the results of the tasks with the help of docker logs. <br><br>  A similar effect can be achieved by redirecting /var/log/cron.log to the standard container output: <br><pre> <code class="bash hljs">ln -sf /dev/stdout /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/cron.log</code> </pre><br>  <b>UPD</b> : This way will not work for <a href="https://github.com/docker/docker/issues/19616">this</a> reason. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If cron jobs write logs to different files, then most likely it would be preferable to use tail, which can ‚Äúfollow‚Äù several logs at the same time: <br><pre> <code class="bash hljs">cron &amp;&amp; tail -f /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/task1.log /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/task2.log</code> </pre><br>  <b>UPD</b> : It is more convenient to create the file (s) for the log as a named pipe (FIFO).  This will avoid the accumulation of unnecessary information inside the container, and assign the log rotate tasks to the <a href="https://docs.docker.com/engine/admin/logging/overview/">Docker</a> .  Example: <br><pre> <code class="bash hljs">mkfifo --mode 0666 /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/cron.log</code> </pre><br><br><h2>  Environment variables </h2><br>  Studying the information on the assignment of environment variables for cron tasks, I found out that the latter can use so-called <a href="https://ru.wikipedia.org/wiki/Pluggable_Authentication_Modules">plug-in authentication modules (PAM)</a> .  That at first glance is a non-subject matter of fact.  But PAM has the ability to define and redefine any environment variables for services that use it (or, more precisely, authentication modules), including cron.  All configuration is done in the <strong>/etc/security/pam_env.conf</strong> file (in the case of Debian / Ubuntu).  That is, any variable described in this file automatically enters the Environment of all cron tasks. <br><br>  But there is one problem, more precisely even two.  The syntax of the file (its description) at the first glance may discourage <s>stupor</s> .  The second problem is as when launching the container to transfer environment variables inside pam_env.conf. <br><br>  Experienced Docker users about the second problem will probably immediately say that you can use a live hack called <strong>docker-entrypoint.sh</strong> and they will be right.  The essence of this lifehack is to write a special script that is started at the time the container is started, and which is the entry point for the parameters listed in the CMD or transmitted on the command line.  The script can be registered inside the Dockerfile, for example, like this: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ENTRYPOINT</span></span> [<span class="hljs-string"><span class="hljs-string">"/docker-entrypoint.sh"</span></span>]</code> </pre><br>  And its code should be written in a special way: <br><div class="spoiler">  <b class="spoiler_title">docker-entrypoint.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash set -e #      /etc/security/pam_env.conf exec "$@"</span></span></code> </pre><br></div></div><br>  Let's return to the transfer of environment variables a bit later, but for now let's focus on the syntax of the pam_env.conf file.  When describing any variable in this file, the value can be specified using two directives: DEFAULT and OVERRIDE.  The first allows you to specify the default value of a variable (if it is not defined at all in the current environment), and the second allows you to override the variable value (if the value of this variable in the current environment is present).  In addition to these two cases, more complicated cases are described in the file as an example, but we are mostly interested only in DEFAULT.  In total, to determine the value for some environment variable, which will then be used in cron, you can use the following example: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">VAR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>=<span class="hljs-string"><span class="hljs-string">"value"</span></span></code> </pre><br>  Please note that <b>value</b> in this case should not contain variable names (for example, $ VAR), because the file context is executed inside the target Environment, where the specified variables are missing (or have a different value). <br><br>  But you can do even easier (and for some reason this method is not described in the examples pam_env.conf).  If you are satisfied that the variable in the target Environment will have the specified value, regardless of whether it is already defined in this environment or not, instead of the above line, you can simply write: <br><pre> <code class="bash hljs">VAR=<span class="hljs-string"><span class="hljs-string">"value"</span></span></code> </pre><br>  Here you should be warned that you cannot replace $ PWD, $ USER and $ PATH for cron jobs any time you want, because cron assigns the values ‚Äã‚Äãof these variables based on their own convictions.  You can, of course, take advantage of <a href="http://stackoverflow.com/questions/2388087/how-to-get-cron-to-call-in-the-correct-paths">various hacks</a> , among which there are workers, but this is at your discretion. <br><br>  Finally, if you need to transfer all current variables to the cron jobs environment, then in this case you can use the following script: <br><div class="spoiler">  <b class="spoiler_title">docker-entrypoint.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash set -e #       env | while read -r LINE; do #    'env'  #     ,     "=" (. IFS) IFS="=" read VAR VAL &lt;&lt;&lt; ${LINE} #      ,    sed --in-place "/^${VAR}/d" /etc/security/pam_env.conf || true #        echo "${VAR} DEFAULT=\"${VAL}\"" &gt;&gt; /etc/security/pam_env.conf done exec "$@"</span></span></code> </pre><br></div></div><br>  By placing the ‚Äúprint_env‚Äù script in the /etc/cron.d folder inside the image and running the container (see the Dockerfile), we will be able to make sure that this solution works: <br><div class="spoiler">  <b class="spoiler_title">print_env</b> <div class="spoiler_text"><pre> <code class="hljs markdown"><span class="hljs-bullet"><span class="hljs-bullet">* </span></span><span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> <span class="hljs-bullet"><span class="hljs-bullet">* *</span></span> www-data env &gt;&gt; /var/log/cron.log 2&gt;&amp;1</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dockerfile</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">FROM debian:jessie RUN apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> clean &amp;&amp; apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> update &amp;&amp; apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install -y cron RUN rm -rf /var/lib/apt/lists/* RUN mkfifo --mode <span class="hljs-number"><span class="hljs-number">0666</span></span> /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/cron.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> COPY docker-entrypoint.sh / COPY print_env /etc/cron.d ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"/docker-entrypoint.sh"</span></span>] CMD [<span class="hljs-string"><span class="hljs-string">"/bin/bash"</span></span>, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, <span class="hljs-string"><span class="hljs-string">"cron &amp;&amp; tail -f /var/log/cron.log"</span></span>]</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">container launch</b> <div class="spoiler_text"><pre> <code class="bash hljs">docker build --tag cron_test . docker run --detach --name cron --env <span class="hljs-string"><span class="hljs-string">"CUSTOM_ENV=custom_value"</span></span> cron_test docker logs -f cron <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br></div></div><br><br><h2>  Graceful shutdown </h2><br>  Speaking about the reason for the impossibility of the normal completion of the described container with cron, we should mention the way in which the Docker daemon communicates with the service running inside it.  Any such service (process) is started with PID = 1, and only Docker can work with this PID.  That is, each time Docker sends a control signal to a container, it addresses it to a process with PID = 1.  In the case of ‚Äúdocker stop‚Äù, this is SIGTERM and, if the process continues, after 10 seconds SIGKILL.  Since "/ bin / bash -c" is used to run (in the case of "CMD cron &amp;&amp; tail -f /var/log/cron.log", the Docker still uses "/ bin / bash -c", simply implicitly), then PID = 1 receives the process / bin / bash, and cron and tail already receive other PIDs, which cannot be predicted for obvious reasons. <br><br>  So it turns out that when we execute the ‚Äúdocker stop cron‚Äù command, SIGTERM receives the "/ bin / bash -c" process, and in this mode it ignores any received signal (except SIGKILL, of course). <br><br>  The first thought in this case is usually - it is necessary to somehow ‚Äúkiln‚Äù the tail process.  Well, it is quite easy to do: <br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> cron killall -HUP tail</code> </pre><br>  Cool, the container immediately stops working.  The truth about the graceful there are some doubts.  And the error code is still non-zero.  In general, I could not advance in solving the problem, following this path. <br><br>  By the way, launching the container using the <strong>cron -f</strong> command also does not give the desired result, cron in this case simply refuses to respond to any signals. <br><br><h2>  True graceful shutdown with zero exit code </h2><br>  Only one thing remains - to write a separate cron daemon startup script, which is able to react correctly to control signals.  It is relatively easy, even if you didn‚Äôt have to write to bash before, you can find information that it is possible to program the signal processing in it (using the <strong>trap</strong> command).  Here is how, for example, such a script could look like: <br><div class="spoiler">  <b class="spoiler_title">start-cron</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash #  cron service cron start #  SIGINT  SIGTERM   trap "service cron stop; exit" SIGINT SIGTERM</span></span></code> </pre><br></div></div><br>  if we could somehow make this script work endlessly (before receiving the signal).  And here one more life hacking, peeped <a href="https://medium.com/%40gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86">here</a> , comes to the rescue, namely the addition of the following line to the end of our script: <br><pre> <code class="bash hljs">tail -f /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/cron.log &amp; <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> $!</code> </pre><br>  Or, if cron jobs write logs to different files: <br><pre> <code class="bash hljs">tail -f /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/task1.log /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/task2.log &amp; <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> $!</code> </pre><br><br><h2>  Conclusion </h2><br>  The result was an effective solution for running cron inside the Docker container, bypassing the limitations of the first and following the rules of the second, with the possibility of normal stopping and restarting the container. <br><br>  At the end I quote a link where everything described in the article is in the form of a separate Docker image: <a href="https://hub.docker.com/r/renskiy/cron/">renskiy / cron</a> . </div><p>Source: <a href="https://habr.com/ru/post/305364/">https://habr.com/ru/post/305364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305350/index.html">Introduction to ReactiveUI: Studying Teams</a></li>
<li><a href="../305352/index.html">6 "harmful" tips to the developer</a></li>
<li><a href="../305354/index.html">Guilloche</a></li>
<li><a href="../305356/index.html">The digest of interesting materials for the mobile # 161 developer (July 3-10)</a></li>
<li><a href="../305360/index.html">Reasonable AOP for IOC container fans</a></li>
<li><a href="../305366/index.html">Amazing story document.write</a></li>
<li><a href="../305368/index.html">QNX 2 per virtual machine</a></li>
<li><a href="../305372/index.html">Ubuntu Unity desktop shell launched in Windows 10 environment</a></li>
<li><a href="../305374/index.html">UX design in the mobile application: a request to evaluate the application</a></li>
<li><a href="../305376/index.html">The digest of fresh materials from the world of the frontend for the last week No. 219 (July 4 - 10, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>