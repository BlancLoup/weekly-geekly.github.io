<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Single Core Windows</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows is one of the most versatile and flexible operating systems, it works on completely different architectures and is available in different vers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Single Core Windows</h1><div class="post__text post__text-html js-mediator-article">  Windows is one of the most versatile and flexible operating systems, it works on completely different architectures and is available in different versions.  Today, it supports x86, x64, ARM and ARM64 architectures.  Windows <a href="https://ru.wikipedia.org/wiki/Windows_NT">at one time</a> supported Itanium, PowerPC, DEC Alpha and MIPS.  In addition, Windows supports a variety of SKUs operating in various environments;  from data centers, laptops, Xbox and phones to embedded versions for the Internet of things, for example, at ATMs. <br><br>  The most surprising aspect is that the core of Windows practically does not change depending on all these architectures and <a href="https://ru.wikipedia.org/wiki/SKU">SKUs</a> .  The kernel is dynamically scaled depending on the architecture and the processor on which it works, so as to take full advantage of the hardware.  Of course, there is a certain amount of code associated with a particular architecture in the kernel, but there is a minimal amount of it, which allows Windows to run on various architectures. <br><br>  In this article, I will talk about the evolution of key parts of the Windows kernel, which allow it to transparently scale from low-power NVidia Tegra chip running on <a href="https://en.wikipedia.org/wiki/Surface_2">Surface RT</a> 2012 to giant <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes">monsters</a> working in Azure data centers. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55551i89F6A2C912C5C448/image-size/large?v=1.0&amp;px=999"></div><br>  Windows Task Manager running on a prerelease Windows DataCenter class machine, with 896 cores supporting 1792 logical processors and 2 TB of memory 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Evolution of a single core </h2><br>  Before discussing the details of the Windows kernel, we make a small digression towards <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D1%2584%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25BD%25D0%25B3">refactoring</a> .  Refactoring plays a key role in increasing the reuse of OS components on various SKUs and platforms (for example, client, server, and phone).  The basic idea of ‚Äã‚Äãrefactoring is to allow reuse of the same DLL on different SKUs, supporting small modifications made specifically for the desired SKU, without renaming the DLL or breaking applications. <br><br>  The basic Windows refactoring technology is a little-documented technology called " <a href="https://docs.microsoft.com/en-us/windows/desktop/apiindex/windows-apisets">API sets</a> ."  API sets are a mechanism that allows the OS to decouple the DLL and the place of their use.  For example, the API set allows applications for win32 to continue to use kernel32.dll, while the implementation of all APIs is written to another DLL.  These implementation DLLs may also differ in different SKUs.  You can view the API sets in the business by running a dependency bypassing on a traditional Windows DLL, for example, kernel32.dll. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55556i8BF228D9318A85CC/image-size/large?v=1.0&amp;px=999"></div><br>  Having finished this digression about the structure of Windows, which allows the system to maximize code reuse and sharing, let's move on to the technical depths of launching the kernel according to the scheduler, which is the key to OS scaling. <br><br><h2>  Kernel components </h2><br>  Windows NT is essentially a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D1%258F%25D0%25B4%25D1%2580%25D0%25BE">microkernel</a> , in the sense that it has its own core Kernel (KE) with a limited set of functions, using the Executive layer (Ex) to execute all high-level policies.  EX is still a kernel mode, so this is not exactly a microkernel.  The kernel is responsible for scheduling threads, synchronizing between processors, handling hardware-level exceptions, and implementing low-level functions that depend on hardware.  The EX layer contains various subsystems that provide a set of functionality, which is usually considered the core - IO, Object Manager, Memory Manager, Process Subsystem, etc. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55558i85CBB1B2E72B3E88/image-size/large?v=1.0&amp;px=999"></div><br>  To better understand the size of the components, here‚Äôs an approximate breakdown of the number of lines of code in several key directories of the kernel source tree (including comments).  The table does not include much more related to the core. <br><br><table><tbody><tr><th>  Kernel subsystems </th><th>  Lines of code </th></tr><tr><td>  Memory manager </td><td>  501, 000 </td></tr><tr><td>  Registry </td><td>  211,000 </td></tr><tr><td>  Power </td><td>  238,000 </td></tr><tr><td>  Executive </td><td>  157,000 </td></tr><tr><td>  Security </td><td>  135,000 </td></tr><tr><td>  Kernel </td><td>  339,000 </td></tr><tr><td>  Process sub-system </td><td>  116,000 </td></tr></tbody></table><br>  For more information on the Windows architecture, see the ‚Äú <a href="https://docs.microsoft.com/en-us/sysinternals/learn/windows-internals">Windows Internals</a> ‚Äù book series. <br><br><h2>  Scheduler </h2><br>  Having prepared the ground in this way, let's talk a little about the scheduler, its evolution and how the Windows kernel can scale to so many different architectures with so many processors. <br><br>  A stream is a basic unit that executes program code, and it is the Windows scheduler that plans its work.  When deciding which threads to start, the scheduler uses their priorities, and in theory, the thread with the highest priority should run on the system, even if it means that there is no time left for threads with lower priorities. <br><br>  Having worked quantum time (the minimum amount of time that a thread can work), the stream experiences a decrease in dynamic priority so that threads with high priority cannot work forever, the soul of everyone else.  When another thread wakes up to work, it is prioritized, calculated based on the importance of the event that caused the wait (for example, the priority is greatly increased for the foreground user interface, and not much to complete input / output operations).  Therefore, the thread works with high priority, while it remains interactive.  When it becomes associated primarily with computing (CPU-bound), its priority drops, and it is returned to it after other high-priority threads get their CPU time.  In addition, the kernel arbitrarily increases the priority of ready-made threads that have not received processor time for a certain period in order to prevent their computational starvation and correct the inversion of priorities. <br><br>  The Windows scheduler initially had one ready queue, from which it selected the next highest priority thread to start.  However, with the beginning of support for an ever-increasing number of processors, the only line has become a bottleneck, and around the exit area of ‚Äã‚ÄãWindows Server 2003, the scheduler changed jobs and organized one ready queue per processor.  When switching to the support of several requests for a single processor, they did not make a single global lock protecting all the queues, and allowed the scheduler to make decisions based on local optima.  This means that at any time one thread with the highest priority runs in the system, but does not necessarily mean that the N highest priority threads in the list (where N is the number of processors) are running in the system.  This approach justified itself until Windows began to switch to low-power CPUs, such as laptops and tablets.  When the stream with the highest priorities did not work on such systems (for example, the user interface front-end stream), this led to noticeable interface glitches.  Therefore, in Windows 8.1, the scheduler was transferred to a hybrid model, with queues for each processor for threads associated with this processor, and a shared queue of ready processes for all processors.  This did not affect the speed in a noticeable way due to other changes in the architecture of the scheduler, for example, refactoring of the database lock of the dispatcher. <br><br>  In Windows 7, they introduced such a thing as a dynamic scheduler with fair shares (Dynamic Fair Share Scheduler, DFSS);  This primarily concerned terminal servers.  This feature tried to solve the problem related to the fact that one terminal session with a high CPU load could affect flows in other terminal sessions.  Since the scheduler did not take into account the session and simply used the priority for the distribution of threads, users in different sessions could affect the work of users in other sessions, strangling their flows.  It also gave an unfair advantage to sessions (and users) with a large number of threads, since a session with a large number of threads had more opportunities to get CPU time.  An attempt was made to add to the scheduler a rule according to which each session was treated on an equal basis with the others in terms of processor time.  There is similar functionality in Linux with their absolutely honest scheduler ( <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely Fair Scheduler</a> ).  In Windows 8, this concept was summarized as a group scheduler and added to the scheduler, with the result that each session fell into an independent group.  In addition to priorities for threads, the scheduler uses the scheduler groups as a second-level index, deciding which thread to run next.  In the terminal server, all scheduler groups have the same weight, so all sessions get the same amount of CPU time, regardless of the number or priority of threads within the scheduler groups.  In addition, such groups are also used for more precise control over processes.  In Windows 8, work objects (Job) were added to support <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh448384(v%3Dvs.85).aspx">CPU time management</a> .  Using a special API, you can decide which part of the processor time a process can use, should it be a soft or hard constraint, and be notified when the process reaches these constraints.  This is similar to <a href="https://ru.wikipedia.org/wiki/Cgroups">cgroups</a> resource management on Linux. <br><br>  Starting with Windows 7, Windows Server now <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/gg463349.aspx">supports over 64 logical processors</a> on a single computer.  To add support for such a large number of processors, a new category, the ‚Äúprocessor group,‚Äù was introduced into the system.  A group is an unchanged set of logical processors with the number of not more than 64 pieces, which are considered by the scheduler as a computational unit.  The kernel when loading determines which processor belongs to which group, and for machines with fewer than 64 processor cores, this approach is almost impossible to notice.  One process can be divided into several groups (for example, an instance of a SQL server); a single thread at a time can be executed only within one group. <br><br>  But on machines where the number of CPU cores exceeds 64, Windows began to show new bottlenecks that did not allow such demanding applications as SQL Server to scale linearly with the increase in the number of processor cores.  Therefore, even with the addition of new cores and memory, speed measurements did not show a significant increase.  One of the main problems associated with this was a dispute over the blocking of the dispatcher base.  The blocking of the dispatcher's base protected access to the objects that had to be scheduled.  Among these objects are streams, timers, I / O ports, other kernel-susceptible objects (events, semaphores, mutexes).  Under the pressure of the need to resolve such problems, in Windows 7, work was done to eliminate the blocking of the dispatcher's base and replace it with more precise adjustments, for example, object-by-blocking.  This allowed performance measurements such as SQL <a href="http://www.tpc.org/tpcc/">TPC-C</a> to show a 290% increase in speed compared to the previous scheme in some configurations.  It was one of the biggest productivity gains in the history of Windows, due to a change in a single feature. <br><br>  Windows 10 brought another innovation by introducing CPU sets.  CPU Sets allow the process to divide the system so that the process can be divided into several groups of processors, not allowing other processes to use them.  The Windows kernel doesn't even allow device interrupts to use the processors in your set.  This ensures that even devices will not be able to execute their code on processors issued to the group of your application.  It looks like a low-tech virtual machine.  It is clear that this is a powerful feature, so many security measures are built into it so that the application developer does not make big mistakes while working with the API.  The functionality of the CPU sets is used in <a href="https://www.windowscentral.com/windows-10-game-mode">game mode</a> (Game Mode). <br><br>  Finally, we come to support ARM64, <a href="https://channel9.msdn.com/Events/Build/2018/BRK2438">which appeared in Windows 10</a> .  The ARM architecture supports the <a href="https://en.wikipedia.org/wiki/ARM_big.LITTLE">big.LITTLE</a> architecture, which is heterogeneous in nature - the ‚Äúlarge‚Äù core runs fast and consumes a lot of energy, while the ‚Äúsmall‚Äù core runs slowly and consumes less.  The idea is that minor tasks can be performed on a small core, thus saving battery.  To support the big.LITTLE architecture and increase battery life when running Windows 10 on ARM, support for a heterogeneous layout was added to the scheduler, taking into account the wishes of the application working with the big.LITTLE architecture. <br><br>  By desires, I mean that Windows tries to maintain applications with high quality, tracking threads running in the foreground (or those that do not have enough CPU time), and ensuring that they run on the ‚Äúbig‚Äù core.  All background tasks, services, and other auxiliary threads run on small kernels.  Also in the program, you can <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadinformation">forcibly mark the</a> unimportance of the thread to make it work on a small core. <br><br>  Work on Behalf: in Windows, quite a lot of work in the foreground is carried out by other services running in the background.  For example, when searching in Outlook, the search itself is performed by the Indexer background service.  If we just run all the services on the small core, the quality and speed of the applications in the foreground will suffer.  So that under such scenarios of work it does not slow down on the big.LITTLE architectures, Windows tracks application calls to other processes in order to perform work on their behalf.  In this case, we give out the foreground priority to the flow related to the service, and force it to run on the large core. <br><br>  With this let me finish the first article on the Windows kernel, giving an overview of the work of the scheduler.  Articles with similar technical details about the internal workings of the OS will follow later. </div><p>Source: <a href="https://habr.com/ru/post/428469/">https://habr.com/ru/post/428469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428455/index.html">Relocation to Nizhny Novgorod</a></li>
<li><a href="../428457/index.html">Bypassing labels: SoundCloud launched direct deals with musicians - conditions were criticized</a></li>
<li><a href="../428461/index.html">Building a distributed VPN network based on Check Point. Several typical scenarios</a></li>
<li><a href="../428465/index.html">Instructions for Business Impact Analysis</a></li>
<li><a href="../428467/index.html">Everything's under control. Why do we need monitoring systems of engineering infrastructure of data processing centers</a></li>
<li><a href="../428471/index.html">Copyright law just got a little better in terms of video game history.</a></li>
<li><a href="../428475/index.html">How designers are deceiving themselves</a></li>
<li><a href="../428477/index.html">For those who choose a firewall</a></li>
<li><a href="../428481/index.html">Contracts in digital: a brief guide for non-lawyers</a></li>
<li><a href="../428485/index.html">People are most annoyed by irrelevant advertising and the use of gadgets in public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>