<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intercom multi-key and everything about the imitation of "tablets"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yes, this is a terribly battered topic. The universal intercom key ‚Äútablet‚Äù was probably made by every second who began to study microcontrollers. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intercom multi-key and everything about the imitation of "tablets"</h1><div class="post__text post__text-html js-mediator-article">  Yes, this is a terribly battered topic.  The universal intercom key ‚Äútablet‚Äù was probably made by every second who began to study microcontrollers.  There are a lot of articles on this topic and ready-made solutions on the Internet.  However, interest in this fade does not cease even with the massive transition to RFID.  This is not surprising, because many people want to assemble such a device that performs not only a very interesting task, but also always with them.  In addition, it is not so difficult to manufacture. <br><br>  In this post I would like to gather in one place all the necessary information for those who want to make such a key.  Now I will try to talk about what contact intercom keys are, how they work, how to imitate them, what kind of pitfalls there are, and also to tell about my own realization of such a device and how you can assemble the same thing yourself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41b/efa/a0d/41befaa0d15f5decf70e98dd83fcc54b.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Attention!</b>  <b>This key does not allow illegal penetration anywhere.</b>  <b>This device is only to carry one key instead of several.</b> <br><h6>  Although nothing prevents you from writing into it the universal codes for opening door phones. </h6><br><a name="habracut"></a><br><br><h3>  Types of intercom keys "tablets" </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/888/409/37d/88840937dd8dfbd3e07e8f6e9a6ea527.jpg"><br><br>  In fact, such keys in the MicroCAN package come in different types, although they look almost the same in appearance.  The only thing that unites them is that the key has two contacts, the earth and the data, and parasitic power is used, i.e.  the key is powered directly from the data line.  To open the door, the serial number is used, which is given at the factory.  That is, this is not the key that is programmed to open the doorphone, but a list of keys that can open it is entered into the memory of the doorphone.  Consider them in more detail. <br><br><h5>  iButton </h5><br>  The most popular type of intercom keys is iButton, namely DS1990A from Dallas, it works using the 1-Wire protocol.  The protocol is very tricky, it implies two-way interaction - you can send various commands to the key, to which it reacts differently.  The serial number has a size of six bytes, which gives 2 <sup>8 * 6</sup> = 281474976710656 different combinations and implies that all keys issued must be unique.  If you are lucky and you have an original iButton, then this number in hexadecimal must be engraved on it with a laser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73f/94c/62e/73f94c62ef7b295646f3cbdb949d09e7.jpg"><br><br>  That is, theoretically, someone else's such a key can be faked, if you just write down somewhere or take a picture of these numbers! <br><br>  To interact with the iButton, it is enough to connect it to the microcontroller and pull the data line to the power supply (2.8-5 volts) through a resistor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bef/502/d4e/bef502d4e81b8f66577d2a9ca16b4574.png"><br><br>  Most likely for many, this is all already old as the world, but still I will briefly tell you how 1-Wire works.  Data exchange takes place due to the alternate pressing of the line to the ground, the information being coded by the duration of such signals.  It happens like this: <br><br><ul><li>  <b>Reset</b> - the master presses the line to the ground for at least 480 microseconds, this indicates the start of data transfer. </li><li>  <b>Presence</b> - after some time, the key responds with a pulse of about 120 microseconds, which confirms its presence on the line. </li><li>  <b>Command</b> - the master sends a command of eight bits, while the logical unit is 1-15 microseconds, and zero - 60-120. </li></ul><br><br>  Further, it all depends on the sent command.  Usually it is 33h - " <b>READ ROM</b> ", reading the serial number, after which the master reads 64 bits (1 byte is the device type, 6 bytes is the number itself, 1 byte is the CRC).  Reading of each bit is initialized by the master, for this it sends a pulse of 1-15 microseconds.  If after that the line is pressed to the ground from the side of the key for 60-120 microseconds, then zero is read, otherwise - one. <br><br>  As you can see, the key is easy to read.  It is much more difficult to imitate a key, especially as many intercoms use various tricks.  Here are the main pitfalls: <br><br><ul><li>  You must always respond to a <b>reset</b> , even if it is sent during data transfer.  A pulse longer than 480 microseconds suggests that you need to start over. </li><li>  The moment of applying the key from his point of view is also a <b>reset</b> , because before that there was no power.  Therefore, theoretically, the intercom may not send a <b>reset</b> , and should periodically respond with a <b>presence</b> signal at its own initiative. </li><li>  The keys can react to other commands: 0Fh as an alternative to 33h, <b>SKIP ROM</b> (CCh), <b>MATCH ROM</b> (55h) and the most cunning thing, which I will discuss separately below, is <b>SEARCH ROM</b> (F0h).  Some intercoms can send various combinations of such commands to make sure that the key is real. </li><li>  There is also a reverse situation - the intercom sends a command to which the key should not respond.  The fact is that some programmable keys still react to them, and this is how another check happens.  It is necessary to completely ignore everything that follows these commands until the <b>reset</b> is sent. </li><li>  For timing, it is better to use an asynchronous timer in the microcontroller, since  the count goes on microseconds.  However, the installation of quartz will be unnecessary. </li></ul><br><br>  <b>SEARCH ROM</b> Pro (F0h) is a command for searching all 1-Wire devices on a bus.  The fact is that theoretically it is possible to connect in parallel many keys and get a list of all serial numbers.  In reality, this is not used for iButton, because one key is always attached to the intercom.  However, some intercoms send this command, expecting to find a single serial number.  The algorithm is very interesting.  Each of the devices on the bus simultaneously sends the bit of its serial number, with it twice (i.e. the master must read two bits).  First, in the usual way, and then inverted.  What is the result?  If the device has a unit in the serial number, then "10" is sent.  If zero, then "01".  And everything is fine, as long as all devices have these bits are the same.  And if not ... I wrote above that when reading, the presence of a long signal is 0, and the absence is 1, i.e.  0 is dominant.  Thus, when conflicts arise, two zeroes are read.  After receiving ‚Äú10,‚Äù ‚Äú01,‚Äù or ‚Äú00,‚Äù the master must send the newly read bit to the line.  In the case of ‚Äú00,‚Äù he thus chooses which group of devices to work with next.  As a result, after N iterations, a binary tree of N serial numbers is obtained. <br>  Responding to such a command is somewhat more complicated than to the usual <b>READ ROM</b> .  You need to send each bit twice - normal and inverted, and then check whether the response received from the master matches it, and if it doesn‚Äôt match, then ignore further commands. <br><br><h5>  Cyfral </h5><br>  The key ‚ÄúDigital DC-2000A‚Äù is a domestic development.  It is much easier to interact with them, because  they are very stupid - do not accept any commands.  Simply power up the key and it will immediately start sending code endlessly, changing its resistance.  If you give it 5 volts by connecting through a 1 kŒ© resistor, then you can see something like this on the oscilloscope: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/ed5/449/e71ed5449a7050718518115e3d19c4cc.png"><br><br>  The key changes its resistance between about 800 ohms and 400 ohms, if I'm not mistaken, and therefore the current consumption.  We can say that the signal is analog, and this complicates things a little from the hardware point of view.  Although sometimes it can be simplified.  For example, the key can be read by simply connecting it to the microphone input of a computer and recording an audio file. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/c42/053/618c42053a2fa21e6a7b180f2c8b71fd.png" alt="image"><br><br>  And yes, the intercom after that can be opened with the most ordinary MP3 player.  But we are interested in more civilized methods, right? <br><br>  Coding is a bit strange.  The key cyclically sends nine nibbles (four bits), changing its resistance.  If it remains low for about 50 microseconds, then this is a logical zero, and if 100 microseconds it is one.  But the data is encoded not by logical zeros and ones, but by the position of the units among the zeros!  That is, the key when sending a code can give out only one of the four combinations: ‚Äú1000‚Äù, ‚Äú0100‚Äù, ‚Äú0010‚Äù and ‚Äú0001‚Äù.  However, the combination ‚Äú0111‚Äù is also used as the starting sequence.  As a result, the key data may look something like this: ‚Äú0111 1000 0100 0010 0001 1000 0100 0010 0001‚Äù, where ‚Äú0111‚Äù indicates the beginning.  There is no checksum - the code is simply read several times for confidence. <br><br>  A total of eight sequences in which four combinations are possible.  It is not difficult to calculate that this gives us 65,536 key options.  Not so much, they are clearly often repeated.  Theoretically, if there are 50 apartments at the entrance, each of which has three keys, you can pick one of them by going through a total of 436 combinations.  But I did not do that. <br><br>  How is it better to read the keys to Cyfral?  As I said, analog levels.  Option two: analog-to-digital converter and comparator.  The latter seems to me more reliable.  Everything works fine if you connect a data line pulled to Vdd with a 650 Ohm resistor to one of the inputs of the comparator, and exactly half Vdd to the second, for which you can use a voltage divider from two identical resistors.  After this, the result of the comparator output can be confidently perceived as high and low key resistance. <br><br>  How to imitate such a key?  At first glance, it seems that you also need to change the resistance, but the results showed that intercoms do not need such accuracy - you can safely close the line to the ground instead of low resistance and completely release it when you need high. <br><br><h5>  Metacom </h5><br>  Another domestic development is Metakom on-door speakerphones and K1233KT2 keys.  Like Cyfral, it just infinitely sends code, changing its resistance / current consumption.  Fortunately, official documentation is available on the Internet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/25d/4ae/69e25d4ae01ef2eb2ea947fbe0b48587.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d85/500/f7b/d85500f7bc0125783ebf24787041ff5e.png"><br><br>  That's all you need to know to work with this key.  It sends four bytes of data, but in each of them one bit goes to parity.  Total comes 28 useful bits, and 2 <sup>28</sup> = 268435456 combinations. <br><br>  Alas, I could not find any such key to experiment with it.  However, on the Internet it is easy to find a universal code that opens 99% of intercoms by Metacom.  One of them is just in the next doorway from me.  I wrote a program that sends this code based only on technical documentation.  The next entrance opened on the first attempt.  It seems that this intercom also does not really matter the exact resistance.  On this, I left Metacom alone and decided that reading their keys is not so necessary. <br><br><h3>  Universal key codes </h3><br>  In fact, universal keys for intercoms - it is rather a myth.  Developers almost never make for themselves some kind of special code for all doors, with the exception of only Vizit. <br><br>  But there is a legend which says that after reading the key code, many intercoms check it with all the codes that are recorded in the memory cells.  However, in cells where nothing else has been written, FFs or zeros are.  Thus, the intercom can be opened by sending a key only from zeros or only from the FF. <br><br>  Sounds like utter nonsense.  How do you need to be a programmer to prevent such a bug?  But ... it does work often.  Yes, in the latest firmware this is usually fixed, but many intercoms remain unchanged for years.  Unbelievable, but it is a fact. <br><br>  Any other key codes issued for universal ones are usually just service keys for the employees of the post office, LCD or the intercom company itself, and they work only in certain localities. <br><br><h3>  Multi-key creation </h3><br>  Let's move on to practice!  Yes, I tried to combine in one device and imitation of keys, and their reading (except Metacom), and synchronization with a computer via USB.  Here is a diagram of what happened (clickable): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d3a/f00/324/d3af00324a6def1830f5fdbdca7b86cd.png"></a> <br><br>  Components and their purpose: <br><br><ul><li>  <b>IC1</b> - ATMEGA8 / ATMEGA8A / ATMEGA8L microcontroller; </li><li>  <b>U1</b> - USB controller FT232RL, needed to connect the device to the computer; </li><li>  <b>CON1</b> - miniUSB connector; </li><li>  <b>BT1</b> - Batteries giving 3-5 volts; </li><li>  <b>D1</b> and <b>D2</b> - diodes (preferably schottky), which isolate the battery power from the USB; </li><li>  <b>P1</b> - ‚Äútablet‚Äù iButton, used to connect to intercoms; </li><li>  <b>P2</b> - contacts of the key reader, used to connect to the keys; </li><li>  <b>R1</b> - resistor, pull-up line 1-wire to VCC; </li><li>  <b>R2</b> - current-lowering resistor to control the transistor Q2; </li><li>  <b>R3</b> is a resistor, an even stronger pull-up line to VCC for reading Cyfral keys; </li><li>  <b>R4</b> - current-lowering resistor, used to open Q1 and determine the connection to USB; </li><li>  <b>R5</b> - pulls the base Q1 to the ground to close it when there is no USB connection; </li><li>  <b>R6</b> - current-lowering resistor for LEDs, one is enough, because  at the same time they do not burn; </li><li>  <b>R7</b> and <b>R8</b> - voltage divider for one of the comparator inputs to read Cyfral keys; </li><li>  <b>Q1</b> - transistor to determine the connection to USB; </li><li>  <b>Q2</b> - a transistor for turning on the ground on the reader and the emulator, in order not to put the batteries, accidentally closing the contacts in your pocket; </li><li>  <b>C1</b> , <b>C2</b> and <b>C3</b> - power filter capacitors; </li><li>  <b>SW1</b> - the only button to control the device; </li><li>  <b>LEDS</b> - seven LEDs in the shape of a <b>figure</b> eight to display the key number. </li></ul><br><br>  Printed circuit board (clickable): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c13/8bf/75d/c138bf75d8efd5fa95821a00d5864d2c.png"></a> <br><br>  It was still time before buying a 3D printer, when I designed the devices for the enclosures, not the enclosures for the devices.  A very nice copy in the form of a keychain and with a button fell into my hands.  Just perfect, it remained only to make holes for USB and LEDs.  Alas, I still can not find on sale exactly the same body.  The result was something like this: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c8b/ba2/9b2/c8bba29b22f2b31ce500c77281ed8e0f.jpg"></a> <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d8/64e/bc7/4d864ebc7a2673fcbb82bc91836ebc53.jpg"></a> <br><br>  Batteries under the board.  By the way, I had enough of them for a year, until I accidentally climbed up to swim, forgetting to pull out the keys. <br><br>  Control is done with just one button.  When you first press it, the device turns on.  By briefly pressing the button, the key is selected, the number of which is displayed by the LEDs.  When the key is selected, it is enough to attach the contacts to the intercom reader. <br><br>  A long press on the button switches the device to the key reading mode, while the middle LED flashes.  At this point, you need to attach the key to the contacts of the key reader (for this purpose, I have a screw screwed in from the bottom).  If the reading is successful, the number under which the key is stored in memory will be displayed. <br><br>  When connected via USB, the device is seen as a virtual COM port.  For simplicity, the client was written under Windows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/597/c68/591/597c685918cee0ff7bde37a5fbeaf25c.png"><br><br>  It allows you to read keys from the device, and automatically enters them into the database.  Of course, the keys can and write. <br><br>  The firmware sources are here: <a href="https://github.com/ClusterM/ibutton">github.com/ClusterM/ibutton</a> <br>  Client sources here: <a href="https://github.com/ClusterM/ibutton_client">github.com/ClusterM/ibutton_client</a> <br><br><h4>  Conclusion </h4><br>  It is very convenient in one device to have the keys to the house, relatives, work and friends' entrances.  Especially important for those who have not conducted an intercom handset in the apartment.  But creating a multi-key was not so much useful as interesting.  This is a great practice for learning microcontrollers.  Yes, it was from this that I started in my time.  In addition, each new non-opening staircase caused a storm of interest.  Running around the city and solving logical problems in order to open a door is like a video game in real life!  Damn exciting.  Lacking only fights with Gopniki and grannies at the entrances in the form of bosses;) </div><p>Source: <a href="https://habr.com/ru/post/229843/">https://habr.com/ru/post/229843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229831/index.html">Overview geek cafe: Solder, Kly√ºtch, Gagarin and others</a></li>
<li><a href="../229833/index.html">Vertical code alignment + a little punto</a></li>
<li><a href="../229837/index.html">The history of the project SHOPPILOT: From fakapu to a startup</a></li>
<li><a href="../229839/index.html">The history of the failure of the online store</a></li>
<li><a href="../229841/index.html">SpaceX put 6 satellites into orbit</a></li>
<li><a href="../229845/index.html">Postgraduate Studies in Holland: What (teaching and working process)</a></li>
<li><a href="../229847/index.html">FedEx: Part 1. Excursion to the FedEx World Package Sorting Center</a></li>
<li><a href="../229849/index.html">Is it possible to steal money from mobile banking? Part 2</a></li>
<li><a href="../229851/index.html">What we should build a network</a></li>
<li><a href="../229853/index.html">Building Reliable Web Applications with React: Part 2, Optimization with Browserify</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>