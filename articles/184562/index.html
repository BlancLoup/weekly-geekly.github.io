<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thread concurrency C ++ 11, your bike technology (Apple) GCD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Good evening habrovchane. In this article I want to describe the problems of working in a multithreaded environment, with whom I met an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thread concurrency C ++ 11, your bike technology (Apple) GCD</h1><div class="post__text post__text-html js-mediator-article"><h5>  Introduction </h5><br>  Good evening habrovchane.  In this article I want to describe the problems of working in a multithreaded environment, with whom I met and the ways to solve them.  For more than five years I have been developing game projects in C ++ / Objective C ++, based on the iOS platform.  2 years ago I decided to try myself in ‚Äúnative‚Äù development using only Objective-C.  Around the same time, I was interested in Apple's GCD technology (just after watching the next WWDC).  First of all, in this technology I was attracted by the flexible ability to delegate transactions between threads.  A fairly common task is to download any game resources in a low-priority thread.  But a rather non-trivial task is to change the stream at the end of the download operation to the main stream in order to further load into VRAM.  Of course, it was possible to turn a blind eye to this problem and use the Shared Context for the graphic context, but the growing awareness of my own code and solutions for designing graphic systems at that time did not allow me to do this.  In general, it was decided to test GCD on a ‚Äúpet‚Äù project, which I was working on at that very time.  And it turned out pretty not bad.  In addition to the tasks of solving the loading of game resources, I began to use GCD where it was appropriate, or I thought it was appropriate. <br><br>  Much time has passed and now the compilers have fully supported the C ++ 11 standard.  Since I am currently working in a company that develops computer games, a special requirement is placed specifically for development in C ++.  Objective-C is alien to most employees.  Yes, and I myself do not have a special love for this language (maybe only apart from its object model built according to the principles of the Smalltalk language). <br><br>  Having read the specs according to the 11th standard, having studied a lot of bourgeois blogs, I decided to write my bike similar to the Apple CGD.  Of course, I don‚Äôt set myself the goal of embracing the immaculate and limited myself to the implementation of the ‚ÄúThread Pool‚Äù pattern and the opportunity to go out of the context of the secondary thread to the context of the main thread at any time, and vice versa. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For this, I needed the following C ++ 11 innovations - std :: function, variadic templates and of course working with std :: thread.  (std :: shared_ptr is used only for a sense of self-comfort).  Of course, another goal that I set for myself is cross-platform.  And I was very disappointed when I learned that the compiler from Microsoft, staffed in VS 2012, did not support the variadic templates.  But, after checking out a little stackoverflow, I saw that this problem was also solved by installing the additional package ‚ÄúVisual C ++ November 2012 CTP‚Äù. <br><a name="habracut"></a><br><h5>  Implementation </h5><br>  As I already mentioned, this thread is based on the ‚ÄúThread Pool‚Äù pattern.  During the design, two classes ‚Äúgcdpp_t_task‚Äù were allocated to aggregate the actual task being performed and gcdpp_t_queue, the queue that accumulates tasks. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FUCTION</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_t_task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: FUCTION m_function; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;ARGS...&gt; m_args; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: gcdpp_t_task(FUCTION _function, ARGS... _args) { m_function = _function; m_args = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(_args...); }; ~gcdpp_t_task(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ apply(m_function, m_args); }; };</code> </pre> <br><br>  As we can see, this class is a template.  And this creates a problem for us - how can we store tasks in one queue, if they are of different types? <br><br>  Long ago I wondered why there is still no full-fledged implementation of interfaces / protocols in C ++.  After all, the principle of programming from abstraction is more effective than from implementation.  Well, nothing, you can create and abstrakny class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_t_i_task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: gcdpp_t_i_task(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { }; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~gcdpp_t_i_task(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }; };</code> </pre><br><br>  Now, by inheriting our task class from a task abstraction, we can easily put everything in one queue. <br><br>  Let's stop a bit and look at the gcdpp_t_task class.  As I already mentioned, the class is template.  It accepts a function pointer (in the specific implementation of the lambda expression) and a set of parameters.  It implements only one method execute, in which functions are passed to the locked parameters.  That's where the headache began.  How to block the parameters in such a way that they can be transmitted in a deferred call.  The decision to use std :: tuple came to the rescue. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUM&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apply_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... F_ARGS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T_ARGS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ARGS&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(F_ARGS... args)&gt; _function, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T_ARGS...&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; _targs, ARGS... args)</span></span></span><span class="hljs-function"> </span></span>{ apply_&lt;NUM<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::apply(_function, _targs, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;NUM<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;(_targs), args...); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apply_</span></span></span><span class="hljs-class">&lt;0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... F_ARGS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T_ARGS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ARGS&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(F_ARGS... args)&gt; _function, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T_ARGS...&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, ARGS... args)</span></span></span><span class="hljs-function"> </span></span>{ _function(args...); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... F_ARGS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T_ARGS&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(F_ARGS... _fargs)&gt; _function, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T_ARGS...&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; _targs)</span></span></span><span class="hljs-function"> </span></span>{ apply_&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(T_ARGS)&gt;::apply(_function, _targs); }</code> </pre><br><br>  Well, it seems like everything became transparent and clear.  Now it's up to you to organize the "Thread Pool" with priorities. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_t_queue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread m_thread; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_running; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _Thread(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: gcdpp_t_queue(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; _guid); ~gcdpp_t_queue(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;gcdpp_t_i_task&gt; _task)</span></span></span></span>; };</code> </pre><br><br>  This is the actual interface that implements the aggregation and encapsulation of the task queue.  In the constructor, each object of the gcdpp_t_queue class creates its own thread in which the assigned tasks will be executed.  Naturally, operations such as push and pop are wrapped in a mutex sync object, for safe operation in a multithreaded environment.  I also needed a class that implements a similar functionality, but it works exclusively in the main thread.  gcdpp_t_main_queue is more modest in its content, as it is more trivial. <br><br>  And now the most important thing is to arrange it all in a less working form. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcdpp_dispatch_init_main_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcdpp_dispatch_update_main_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_queue&gt; gcdpp_dispatch_get_global_queue(gcdpp::GCDPP_DISPATCH_QUEUE_PRIORITY _priority); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_main_queue&gt; gcdpp_dispatch_get_main_queue(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_dispatch_async</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_main_queue&gt; _queue, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(ARGS... args)&gt; _function, ARGS... args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_main_queue&gt; m_mainQueue; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_queue&gt; m_poolQueue[gcdpp::GCDPP_DISPATCH_QUEUE_PRIORITY_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_impl&gt; instance(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_queue&gt; gcdpp_dispatch_get_global_queue(gcdpp::GCDPP_DISPATCH_QUEUE_PRIORITY _priority); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_main_queue&gt; gcdpp_dispatch_get_main_queue(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcdpp_dispatch_async</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;gcdpp_t_main_queue&gt; _queue, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(ARGS... args)&gt; _function, ARGS... args); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: gcdpp_impl(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); ~gcdpp_impl(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); };</code> </pre><br><br>  The class gcdpp_impl is singleton and fully encapsulated from external influences.  It contains an array of 3 task pools (with priorities, while priorities are implemented by stubs), and a pool for executing tasks on the main thread.  The class also contains 5 friend functions.  The functions gcdpp_dispatch_init_main_queue and gcdpp_dispatch_update_main_queue are parasites.  Right now I am developing an ominous plan for cutting them out.  gcdpp_dispatch_update_main_queue - functions for processing tasks on the main thread ... and really want to save the user from sticking this function into your Run Loop. <br><br>  With the rest of the functions, everything seems to be transparent: <br><br>  gcdpp_dispatch_get_global_queue ‚Äî get priority queue; <br>  gcdpp_dispatch_get_main_queue - get a queue on the main thread; <br>  gcdpp_dispatch_async - puts the operation queue for deferred call in a specific thread in a specific queue. <br><br><h5>  Application </h5><br>  And why is all this necessary? <br>  I will try to show the profit of this implementation on several tests: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)&gt; function = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; c) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; gcdpp::gcdpp_dispatch_async&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(gcdpp::gcdpp_dispatch_get_global_queue(gcdpp::GCDPP_DISPATCH_QUEUE_PRIORITY_HIGH), function, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>);</code> </pre><br><br>  In this example, the function declared in lambda expression will be deferred in a stream with high priority. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clazz</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_varible; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _varible)</span></span></span><span class="hljs-function"> </span></span>{ m_varible = _varible; }; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Clazz&gt; clazz = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Clazz&gt;(); clazz-&gt;m_varible = <span class="hljs-number"><span class="hljs-number">101</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Clazz&gt; )&gt; function = [](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Clazz&gt; clazz) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"call"</span></span>&lt;&lt;clazz-&gt;m_varible&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; gcdpp::gcdpp_dispatch_async&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Clazz&gt;&gt;(gcdpp::gcdpp_dispatch_get_global_queue(gcdpp::GCDPP_DISPATCH_QUEUE_PRIORITY_HIGH), function, clazz);</code> </pre><br><br>  This is an example of using a deferred operation call with custom classes as a parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CParticleEmitter::_OnTemplateLoaded(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ITemplate&gt; _template) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)&gt; function = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;CVertexBuffer&gt; vertexBuffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;CVertexBuffer&gt;(m_settings-&gt;m_numParticles * <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_STREAM_DRAW); ... m_isLoaded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; thread_concurrency_dispatch(get_thread_concurrency_main_queue(), function); }</code> </pre><br><br>  And the most important test is the operation call on the main thread from the secondary thread.  The _OnTemplateLoaded function is called from the background of the thread that parses the xml settings file.  After that, a particle buffer should be created and the structures should be sent to VRAM.  This operation requires performing exclusively on the stream in which the graphics context was created. <br><br><h5>  Conclusion </h5><br>  In general, the problem is solved within the set goals.  Of course, there is still a lot of things that have not been worked out and have not been tested, but for the time being the spark in me will be burning, I will continue to improve my implementation of GCD.  Approximately 18 hours of work was spent on this project, most of which was a work break. <br><br>  Source codes can be found in the open <a href="https://github.com/codeoneclick/gcdpp">source source code</a> .  Under VS 2012, the project has not yet been pushing, but I think it will soon appear there. <br><br>  PS Waiting for adequate criticism ... </div><p>Source: <a href="https://habr.com/ru/post/184562/">https://habr.com/ru/post/184562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184552/index.html">DXperience 13.1 - New version of .NET components from DevExpress</a></li>
<li><a href="../184554/index.html">Crazy DIY toy: a homemade cell phone with a built-in dosimeter. Part 1</a></li>
<li><a href="../184556/index.html">Iterative search program</a></li>
<li><a href="../184558/index.html">The development of custom data types in programming</a></li>
<li><a href="../184560/index.html">VKontakte iOS SDK</a></li>
<li><a href="../184566/index.html">LinkMeUp. Release 4</a></li>
<li><a href="../184570/index.html">Digest of new MSDN materials in Russian for May and June</a></li>
<li><a href="../184572/index.html">Port "Age of Empires" for smartphones will be released before the end of the year</a></li>
<li><a href="../184574/index.html">SMS filtering of spam using a naive Bayes classifier (R code)</a></li>
<li><a href="../184576/index.html">Carberp source leaks are a big hit to user security.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>