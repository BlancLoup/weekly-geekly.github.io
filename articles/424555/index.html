<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js tutorial, part 7: asynchronous programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, in the seventh part of the Node.js tutorial, we will talk about asynchronous programming, consider issues such as the use of callbacks, promise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js tutorial, part 7: asynchronous programming</h1><div class="post__text post__text-html js-mediator-article">  Today, in the seventh part of the Node.js tutorial, we will talk about asynchronous programming, consider issues such as the use of callbacks, promises, and async / await constructs, and discuss work with events. <br><br> <a href="https://habr.com/company/ruvds/blog/424555/"><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[We advise to read] Other parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habr.com/company/ruvds/blog/422893/">General Information and Getting Started</a> <br>  Part 2: <a href="https://habr.com/company/ruvds/blog/423153/">JavaScript, V8, some design tricks</a> <br>  Part 3: <a href="https://habr.com/company/ruvds/blog/423701/">Hosting, REPL, work with the console, modules</a> <br>  Part 4: <a href="https://habr.com/company/ruvds/blog/423703/">npm, package.json and package-lock.json files</a> <br>  Part 5: <a href="https://habr.com/company/ruvds/blog/423705/">npm and npx</a> <br>  Part 6: <a href="https://habr.com/company/ruvds/blog/424553/">event loop, call stack, timers</a> <br>  Part 7: <a href="https://habr.com/company/ruvds/blog/424555/">Asynchronous Programming</a> <br>  Part 8: <a href="https://habr.com/company/ruvds/blog/424557/">Node.js Guide, part 8: HTTP and WebSocket protocols</a> <br>  Part 9: <a href="https://habr.com/company/ruvds/blog/424969/">Node.js Guide, part 9: working with the file system</a> <br>  Part 10: <a href="https://habr.com/company/ruvds/blog/425667/">Node.js Guide, part 10: standard modules, streams, databases, NODE_ENV</a> <br>  <a href="https://habr.com/company/ruvds/blog/428576/">Full PDF Node.js Manual</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asynchrony in programming languages</font> </h2><br>  By itself, JavaScript is a synchronous single-threaded programming language.  This means that in the code you cannot create new threads that run in parallel.  However, computers, by their nature, are asynchronous.  That is, some actions can be performed independently of the main program flow.  In modern computers, each program is allocated a certain amount of processor time, when this time expires, the system gives resources to another program, also for a while.  Such switchings are performed cyclically, this is done so quickly that a person simply cannot notice this, as a result we think that our computers run many programs at the same time.  But this is an illusion (if not to talk about multiprocessor machines). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the depths of programs, interrupts are used - signals transmitted by the processor and allowing the system to attract attention.  We will not go into details, the most important thing - remember that asynchronous behavior, when program execution is suspended until the moment when it needs processor resources, is completely normal.  At the time when the program does not load the system with work, the computer can solve other problems.  For example, with this approach, when a program waits for a response to a network request made to it, it does not block the processor until the response is received. <br><br>  As a rule, programming languages ‚Äã‚Äãare asynchronous, some of them give the programmer the ability to control asynchronous mechanisms using either built-in language tools or specialized libraries.  We are talking about languages ‚Äã‚Äãsuch as C, Java, C #, PHP, Go, Ruby, Swift, Python.  Some of them allow programming in asynchronous style using threads, starting new processes. <br><br><h2>  <font color="#3AC1EF">Javascript asynchrony</font> </h2><br>  As already mentioned, JavaScript is a single-threaded synchronous language.  Lines of code written in JS are executed in the order in which they appear in the text, one after another.  For example, here is a completely ordinary JS program that demonstrates this behavior: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  But JavaScript was created for use in browsers.  His main task, at the very beginning, was to organize the processing of events related to the user's activities.  For example, these are events such as <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> , and so on.  How to solve similar problems within the framework of the synchronous programming model? <br><br>  The answer lies in the environment in which JavaScript works.  Namely, the browser can effectively solve such tasks, giving the programmer the appropriate API. <br><br>  The Node.js environment has the means to perform non-blocking I / O operations, such as working with files, organizing data exchange over a network, and so on. <br><br><h2>  <font color="#3AC1EF">Callbacks</font> </h2><br>  If we talk about browser-based JavaScript, then it can be noted that it is impossible to know in advance when the user clicks on a certain button.  In order to ensure that the system responds to such an event, a handler is created for it. <br><br>  The event handler accepts a function that will be called when an event occurs.  It looks like this: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Such functions are also called callback functions or callbacks. <br><br>  A callback is a normal function that is passed, as a value, to another function.  It will be caused only in the event that an event occurs.  JavaScript implements the concept of first-class functions.  Such functions can be assigned to variables and transferred to other functions (called higher order functions). <br><br>  In client-side JavaScript-development, there is a common approach when all client code wraps a listener in the <code>load</code> event of the <code>window</code> object, which the callback passed to it after the page is ready for work: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Callbacks are used everywhere, and not just for handling DOM events.  For example, we have already met with their use in timers: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://en.wikipedia.org/wiki/XMLHttpRequest">Callbacks are</a> also used in XHR queries.  In this case, it looks like the function assignment to the corresponding property.  A similar function will be called when a specific event occurs.  In the following example, such an event is a change in the request status: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF"> Error handling in callbacks</font> </h3><br>  Let's talk about how to handle errors in callbacks.  There is one common strategy for handling such errors, which is also used in Node.js.  It is that the first parameter of any callback function is to make the object an error.  If there are no errors, the value <code>null</code> will be written to this parameter.  Otherwise, there will be an error object containing its description and additional information about it.  Here's what it looks like: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF"> Callback problem</font> </h3><br>  Callbacks are convenient to use in simple situations.  However, each callback is an additional level of code nesting.  If several nested callbacks are used, this quickly leads to a significant complication of the code structure: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  In this example, only 4 levels of code are shown, but in practice you can encounter a large number of levels, usually referred to as ‚Äúcallback hell‚Äù.  You can cope with this problem using other language constructs. <br><br><h2>  <font color="#3AC1EF">Promises and async / await</font> </h2><br>  Starting with the ES6 standard in JavaScript, new features appear that make it easier to write asynchronous code, allowing you to do without callbacks.  These are the promises that appeared in ES6, and the async / await construction that appeared in ES8. <br><br><h3>  <font color="#3AC1EF">Promises</font> </h3><br>  Promises (promise objects) are one of the ways to work with asynchronous software constructs in JavaScript, which, in general, reduces the use of callbacks. <br><br><h4>  Meet the promises </h4><br>  Promises are usually defined as proxies for some values ‚Äã‚Äãthat are expected to appear in the future.  Promises are also called ‚Äúpromises‚Äù or ‚Äúpromised results.‚Äù  Although this concept has been around for many years, promises have been standardized and added to the language only in ES2015.  In ES2017, an async / await design appeared, which is based on promises, and which can be considered as their convenient replacement.  Therefore, even if you do not plan to use conventional promises, understanding how they work is important for the effective use of the async / await construction. <br><br><h4>  How do promises </h4><br>  After calling the promise, it enters the pending state.  This means that the function that caused the promis continues to be performed, while some calculations are performed in the promis, after which the promis reports this.  If the operation that the promise performs completes successfully, the promise is set to the state ‚Äúfulfilled‚Äù.  Such a promise is said to be successfully resolved.  If the operation completes with an error, the promise is rejected. <br><br>  Let's talk about working with promises. <br><br><h4>  Creating promises </h4><br>  The API for working with promises is given by the corresponding constructor, which is called by a command like <code>new Promise()</code> .  This is how promises are created: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis checks the global constant <code>done</code> , and if its value is <code>true</code> , it is successfully resolved.  Otherwise, the promis is rejected.  Using the <code>resolve</code> and <code>reject</code> parameters, which are functions, we can return values ‚Äã‚Äãfrom the promise.  In this case, we return a string, but an object can be used here. <br><br><h4>  Work with promises </h4><br>  Above, we created a promise, now consider working with it.  It looks like this: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Calling <code>checkIfItsDone()</code> will lead to the implementation of the isItDoneYet <code>isItDoneYet()</code> and to the organization of waiting for its resolution.  If the promise resolves successfully, the callback passed to the <code>.then()</code> method will work.  If an error occurs, that is, the promise will be rejected, it can be processed in the function passed to the <code>.catch()</code> method. <br><br><h4>  Combination of promises in chains </h4><br>  Promise methods return promises, which allows them to be chained.  A good example of this behavior is the browser <a href="https://flaviocopes.com/fetch-api">API Fetch</a> , which is a level of abstraction over <code>XMLHttpRequest</code> .  There is a fairly popular npm package for Node.js that implements the Fetch API, which we will look at later.  This API can be used to load certain network resources and, thanks to the possibility of combining promises in chains, to organize the subsequent processing of downloaded data.  In fact, when accessing the API Fetch, performed by calling the function <code>fetch()</code> , a promise is created. <br><br>  Consider the following example of combining promises in chains: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Here we use the <a href="https://www.npmjs.com/package/node-fetch">node-fetch</a> npm package and the <a href="https://jsonplaceholder.typicode.com/">jsonplaceholder.typicode.com</a> resource as a source of JSON data. <br><br>  In this example, the <code>fetch()</code> function is used to load a TODO list item using a chain of promises.  After doing <code>fetch()</code> , an <a href="https://fetch.spec.whatwg.org/">answer is</a> returned that has many properties, among which we are interested in the following: <br><br><ul><li>  <code>status</code> is a numeric value representing the HTTP status code. </li><li>  <code>statusText</code> is a textual description of the HTTP status code, which is represented by the string <code>OK</code> in the event that the request was successful. </li></ul><br>  The <code>response</code> object has a <code>json()</code> method that returns a promise, which, if resolved, returns the processed contents of the request body, in JSON format. <br><br>  Given the above, we describe what happens in this code.  The first promis in the chain is represented by the <code>status()</code> function that we declared, which checks the response status, and if it indicates that the request failed (that is, the HTTP status code is not between 200 and 299), rejects the promise.  This operation leads to the fact that other <code>.then()</code> expressions in the promise chain are not executed and we immediately get into the <code>.catch()</code> method, displaying the text <code>Request failed</code> , along with an error message. <br><br>  If the HTTP status code suits us, the declared <code>json()</code> function is called.  Since the previous promise, when successfully resolved, returns a <code>response</code> object, we use it as an input value for the second promise. <br><br>  In this case, we are returning the processed JSON data, so the third promise receives it, after which they, preceded by a message stating that the necessary data could be obtained as a result of the request, are output to the console. <br><br><h4>  Error processing </h4><br>  In the previous example, we had a <code>.catch()</code> method attached to a chain of promises.  If something in the promise chain goes wrong and an error occurs, or if one of the promises is rejected, control is passed to the nearest <code>.catch()</code> expression.  Here is the situation when an error occurs in the promise: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Here is an example of triggering <code>.catch()</code> after rejecting the promise: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Cascade error handling </h4><br>  What if an error occurs in the <code>.catch()</code> expression?  To handle this error, you can include another <code>.catch()</code> expression in the promis chain (and then you can attach as many more <code>.catch()</code> expressions to the chain as you need): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Now consider several useful methods used to manage promises. <br><br><h4>  Promise.all () </h4><br>  If you need to perform an action after resolving several promises, you can do this with the help of the <code>Promise.all()</code> command.  Consider an example: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  In ES2015, the destructive assignment syntax has appeared, with its use you can create constructions of the following form: <br><br><pre> <code class="hljs coffeescript">Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([res1, res2])</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Here we, as an example, considered API Fetch, but <code>Promise.all()</code> , of course, allows you to work with any promises. <br><br><h4>  Promise.race () </h4><br>  The <code>Promise.race()</code> command allows you to perform a specified action after one of the promises passed to it is allowed.  The corresponding callback containing the results of this first promise is called only once.  Consider an example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Error Uncaught TypeError, which occurs when working with promises </h4><br>  If, while working with promises, you encounter an <code>Uncaught TypeError: undefined is not a promise</code> , check that the <code>new Promise()</code> construct is used when creating promises and not just <code>Promise()</code> . <br><br><h3>  <font color="#3AC1EF">As Async / await design</font> </h3><br>  The async / await design is a modern approach to asynchronous programming, simplifying it.  Asynchronous functions can be represented as a combination of promises and generators, and, in general, this design is an abstraction over promises. <br><br>  The async / await design allows you to reduce the amount of template code that you have to write when working with promises.  When promises appeared in the ES2015 standard, they were aimed at solving the problem of creating asynchronous code.  They coped with this task, but after two years separating the output of the ES2015 and ES2017 standards, it became clear that they could not be considered the final solution to the problem. <br><br>  One of the problems that promises solved was the famous ‚Äúhell callbacks‚Äù, but they, solving this problem, created their own problems of a similar nature. <br><br>  Promises were simple constructions around which one could build something with a simpler syntax.  As a result, when the time came, the async / await construction appeared.  Its use allows you to write code that looks like synchronous, but is asynchronous, in particular, does not block the main thread. <br><br><h4>  How the async / await construction works </h4><br>  The asynchronous function returns a promis, as, for example, in the following example: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  When you need to call a similar function, you need to put the <code>await</code> keyword before the command to call it.  This will cause the code calling it to wait for permission or rejection of the corresponding promise.  It should be noted that the function in which the <code>await</code> keyword is used must be declared using the <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Combine the above two code snippets and examine its behavior: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  This code will output the following: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  The text <code>I did something</code> will fall into the console with a delay of 3 seconds. <br><br><h4>  About promises and asynchronous functions </h4><br>  If you declare a certain function using the <code>async</code> , it will mean that such a function will return a promise even if it is not explicitly done.  That is why, for example, the following example is a working code: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br>  This construction is similar to this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Async / await strengths </h4><br>  Analyzing the above examples, you can see that the code that uses async / await is simpler than the code that uses the combination of promises in chains, or code based on callback functions.  Here we, of course, considered very simple examples.  You can fully experience the above benefits by working with much more complex code.  Here, for example, how to load and parse JSON data using promises: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  Here is the solution to the same problem using async / await: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Using sequences from asynchronous functions </h4><br>  Asynchronous functions can easily be combined into constructions resembling a chain of promises.  The results of this combination, however, are much better readability: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  This code will display the following text: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Simplified Debugging </h4><br>  Promises are difficult to debug, since using them you cannot effectively use the usual tools of the debugger (like ‚Äúwalk-by-step‚Äù, step-over).  The code written using async / await can be debugged using the same methods as regular synchronous code. <br><br><h2>  <font color="#3AC1EF">Generating events in Node.js</font> </h2><br>  If you worked with JavaScript in the browser, then you know that events play a huge role in the processing of user interactions with pages.  We are talking about handling events caused by clicks and mouse movements, keystrokes on the keyboard, and so on.  In Node.js, you can work with events that the programmer creates on his own.  Here you can create your own event system using the <a href="https://nodejs.org/api/events.html">events</a> module.  In particular, this module offers us the <code>EventEmitter</code> class, the capabilities of which can be used to organize work with events.  Before using this mechanism, you need to connect it: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  When working with it, <code>on()</code> and <code>emit()</code> methods are available to us, among others.  The <code>emit</code> method <code>emit</code> used to <code>emit</code> events.  The <code>on</code> method is used to set up callbacks, event handlers that are called when a particular event is called. <br><br>  For example, let's create a <code>start</code> event.  When it happens, we will output something to the console: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  In order to trigger this event, use the following construction: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  As a result of the execution of this command, an event handler is called and the <code>started</code> line gets into the console. <br><br>  You can pass arguments to the event handler, representing them as additional arguments to the <code>emit()</code> method: <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Similarly, they act in cases when the handler needs to pass several arguments: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Objects of the <code>EventEmitter</code> class have several other useful methods: <br><br><ul><li>  <code>once()</code> - allows to register an event handler that can be called only once. </li><li>  <code>removeListener()</code> - allows you to remove the handler passed to it from the handler array of the event passed to it. </li><li>  <code>removeAllListeners()</code> - allows you to remove all handlers of the event passed to it. </li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we talked about asynchronous programming in JavaScript, in particular, we discussed callbacks, promises, and the async / await construct.  We also touched upon the issue of working with events described by the developer using the <code>events</code> module.  Our next topic will be the mechanisms for networking the Node.js platform. <br><br>  <b>Dear readers!</b>  Do you use the async / await construct when programming for Node.js? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/424555/">https://habr.com/ru/post/424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424541/index.html">The UGJ-2018 story fiasco: how to make a game that nobody would like (do not do that!)</a></li>
<li><a href="../424543/index.html">Java 11 / JDK 11: General Availability</a></li>
<li><a href="../424545/index.html">How to understand that planning a sprint went well?</a></li>
<li><a href="../424551/index.html">Warm and lamp: five balalaika about magnetic recording technology</a></li>
<li><a href="../424553/index.html">Node.js tutorial, part 6: event loop, call stack, timers</a></li>
<li><a href="../424557/index.html">Node.js Part 8 Tutorial: HTTP and WebSocket Protocols</a></li>
<li><a href="../424559/index.html">Big Data resistance 1 or elusive Joe. Internet anonymity, anti-detection, anti-tracking for anti-you and anti-us</a></li>
<li><a href="../424561/index.html">Russian program to create a global satellite Internet network may lose a single investor</a></li>
<li><a href="../424563/index.html">Beeline sends details of conversations to strangers</a></li>
<li><a href="../424565/index.html">Review: 3D scanning of real estate premises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>