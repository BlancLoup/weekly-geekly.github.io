<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing a PCI device driver for Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I look at the process of writing a simple PCI device driver under Linux OS. The device of the PCI software model, the writing of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing a PCI device driver for Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/sf/xk/il/sfxkiltkrv6i--clz-dlrmgjrsw.jpeg"><br>  In this article, I look at the process of writing a simple PCI device driver under Linux OS.  The device of the PCI software model, the writing of the driver itself, the user test program and the launch of the entire system will be briefly studied. <br><br>  The interface of LIR940 / 941 displacement sensors will be presented as an experimental.  This device, domestically produced, provides connection to up to 4 encoders using the serial SSI protocol over the RS-422 physical interface. <br><a name="habracut"></a><br>  Today, the PCI bus (and its newer version, PCI Express) is a standard interface for connecting a wide range of additional equipment to modern computers and this bus does not need a special presentation. <br><br>  It is not uncommon in the form of a PCI adapter that various specialized input / output interfaces are implemented to connect at least specialized external equipment. <br>  Also, there are still not rare situations when a hardware manufacturer provides a driver only for Windows OC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      LIR941 was acquired by the organization in which I work to obtain data from high-precision absolute displacement sensors.  When there was a question about working under Linux, it turned out that the manufacturer does not provide anything for this OS.  There was also nothing in the network, which, incidentally, is normal for such a rare and specialized device. <br><br>  On the board itself, there is an Altera FPGA, which implements the entire interaction logic, as well as several (from 2 to 4) RS-422 interfaces with galvanic isolation. <br><br>  Typically, in such a situation, developers go the way of reverse engineering, trying to figure out how the Windows driver works. <br><br>  Morally preparing for this entertainment, I decided to start by trying the easiest and most direct way - I wrote the request directly to the equipment manufacturer. <br><br>  I asked if they could provide any documentation or specification for their device, so that I could develop an open source driver for Linux.  To my surprise, the manufacturer went to the meeting, they answered me very quickly and sent all the necessary documentation! <br><br><h2>  PCI bus </h2><br>  Before proceeding to the development of the actual driver, I propose to consider how the PCI software model works and how it interacts with the device. <br><blockquote>  A small note about PCI and PCI Express. <br>  Despite the fact that the hardware is two different interfaces - they both use the same software model, so from the point of view of the developer there is no particular difference and the driver will work the same way. </blockquote>  The PCI bus allows you to connect at the same time a large number of devices and often consists of several physical buses connected to each other through special ‚Äúbridges‚Äù - the PCI Bridge.  Each bus has its own number, devices on the bus are also assigned a unique number.  Also, each device can be multifunctional, as if divided into separate devices that implement some separate functions, each such function is assigned its own number in the same way. <br>  Thus, the system "path" to the specific functionality of the device looks like this: <br>  &lt;pci bus number&gt; &lt;device number&gt; &lt;function number&gt;. <br><br>  To see which devices are connected to the PCI bus on Linux, just run the lspci command. <br><br>  The output may be unexpectedly long, since in addition to devices directly physically connected via pci / pci express slots (such as a video adapter), there are many system devices that are soldered (or included in a chipset chipset device) on the motherboard. <br>  The first column of this conclusion, consisting of numbers, is precisely the set of identifiers discussed above. <br><br>  For example: <br><br><pre><code class="bash hljs">$ lspci 01:00.0 VGA compatible controller: NVIDIA Corporation GT215 [GeForce GT 240]</code> </pre> <br>  This output means that the NVIDIA GT 240 video adapter is on PCI bus 01, the device number is 00 and its only function number is also 0. <br><br>  It should also be added that each PCI device has a set of two unique identifiers - Vendor ID and Product ID, which allows drivers to uniquely identify devices and work with them correctly. <br><br>  The issuance of unique Vendor ID for hardware manufacturers engaged in a special consortium - <a href="https://en.wikipedia.org/wiki/PCI-SIG">PCI-SIG</a> . <br><br>  To see these identifiers it is enough to run lspci with the -nn keys: <br><br><pre> <code class="bash hljs">$ lspci -nn 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GT215 [GeForce GT 240] [10de:0ca3]</code> </pre> <br>  Where 10de is the manufacturer's identifier, NVIDIA Corporation, and 0ca3 is the identifier of the specific hardware. <br><br>  Find out who is who can use special sites, such as <a href="https://pci-ids.ucw.cz/read/PC">The PCI ID Repository</a> <br><br>  Reading service information and configuration of a PCI device is carried out through a set of configuration registers.  Each device must provide a standard set of such registers, which will be discussed later. <br><br>  The registers are mapped into the computer‚Äôs RAM at boot time and the operating system kernel associates with the device a special data structure - pci_dev, and also provides a set of functions for reading and writing. <br><br>  In addition to the PCI configuration registers, devices can have up to 6 data input / output channels.  Each channel is also displayed in RAM at a certain address assigned by the OS kernel. <br><br>  Read-write operations of this memory area, with certain parameters of block size and offset, lead directly to write-read to the device. <br><br>  It turns out that to write a PCI driver, you need to know what configuration registers the device uses, as well as what offsets (and what exactly) you need to write / read.  In my case, the manufacturer provided all the necessary information. <br><br><h2>  PCI configuration space </h2><br>  The first 64 bytes are standardized and must be provided by all devices, whether they are required or not. <br><br><img src="https://habrastorage.org/webt/9n/jv/po/9njvpoxxixlhyktcvogqkrepouw.png"><br><br>  The picture shows the registers that are mandatory, they must always contain any meaningful values, the rest may contain zeros, if this is not required in this case. <blockquote>  The byte order in all PCI registers is little-endian, this should be considered if driver development is carried out for an architecture with a different order. </blockquote>  Let's see what some of the registers are. <br><br>  <b>VendorID</b> and <b>ProductID</b> are registers already known to us, in which the manufacturer and equipment identifiers are stored.  Each of the registers takes 2 bytes. <br><br>  <b>Command</b> - this register defines some features of a PCI device, for example, it allows or denies access to memory. <br><br><img src="https://habrastorage.org/webt/np/-e/om/np-eom4gyq7dym_kdkoapei06ri.png"><br>  The initialization of these bits is handled by the operating system. <br><br>  <b>Status</b> - bits of this register store information about various PCI bus events. <br><br><img src="https://habrastorage.org/webt/t3/vv/nk/t3vvnkrpsol6drrmymbqgtfjyx4.png"><br>  These values ‚Äã‚Äãare set by the equipment; in my case, only bits 9, 10 were configured, which determine the board response time. <br><br>  <b>Revision ID</b> - number, revision of a specific board.  Useful when there are several revisions of the device and differences need to be considered in the driver code. <br><br>  <b>Class Code</b> is a ‚Äúmagic‚Äù number that displays the class of the device, for example: Network Controller, Display Controller, etc. The list of existing codes can be found <a href="https://wiki.osdev.org/PCI">here</a> . <br><br>  <b>Base Address Registers</b> - these registers, in the amount of 6 pieces, are used to determine how and how much memory is allocated to the device for input / output procedures.  This register is used by the pci subsystem of the kernel and is usually not of interest to driver developers. <br><br>  Now you can go to programming and try to read these registers and get access to the I / O memory. <br><br><h2>  Kernel module development </h2><br>  As many probably know, the entry and exit points to the Linux kernel module are special __init and __exit functions. <br><br>  We define these functions and execute the procedure for registering our driver by calling the special function pci_register_driver (struct pci_driver * drv), as well as the unloading procedure using pci_unregister_driver (struct pci_driver * drv). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/pci.h&gt; static int __init mypci_driver_init(void) { return pci_register_driver(&amp;my_driver); } static void __exit mypci_driver_exit(void) { pci_unregister_driver(&amp;my_driver); } module_init(mypci_driver_init); module_exit(mypci_driver_exit);</span></span></span></span></code> </pre> <br>  The argument of the register and unregister functions is the pci_driver structure that needs to be initialized first, let's do it at the very beginning, declaring the structure static. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pci_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_driver</span></span></span><span class="hljs-class"> = {</span></span> .name = <span class="hljs-string"><span class="hljs-string">"my_pci_driver"</span></span>, .id_table = my_driver_id_table, .probe = my_driver_probe, .remove = my_driver_remove };</code> </pre> <br>  The structure fields that we initialize: <br>  <b>name</b> is the unique name of the driver that will be used by the kernel in / sys / bus / pci / drivers <br>  <b>id_table</b> is a table of the Vendor ID and Product ID pairs that the driver can work with. <br>  <b>probe</b> - a function called by the kernel after loading the driver, serves to initialize the equipment <br>  <b>remove</b> - the function called by the kernel when the driver is unloaded, serves to free any previously occupied resources <br><br>  Also in the pci_driver structure, additional functions are provided that we will not use in this example: <br>  <b>suspend</b> - this function is called when the device goes to sleep <br>  <b>resume</b> - this function is called when the device wakes up <br><br>  Consider how the table identifies the pairs Vendor ID and Product ID. <br>  This is a simple structure with a list of identifiers. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pci_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_driver_id_table</span></span></span><span class="hljs-class">[] = {</span></span> { PCI_DEVICE(<span class="hljs-number"><span class="hljs-number">0x0F0F</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F0E</span></span>) }, { PCI_DEVICE(<span class="hljs-number"><span class="hljs-number">0x0F0F</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F0D</span></span>) }, {<span class="hljs-number"><span class="hljs-number">0</span></span>,} };</code> </pre><br>  Where 0x0F0F is the Vendor ID, and 0x0F0E and 0x0F0D are the Product ID pair of this vendor. <br>  A pair of identifiers can be one or several. <br>  Be sure to complete the list with the empty identifier {0,} <br><br>  After the declaration of the filled structure, you must pass it to the macro. <br><br><pre> <code class="cpp hljs">MODULE_DEVICE_TABLE(pci, my_driver_id_table);</code> </pre> <br>  In the function <b>my_driver_probe ()</b> we can actually do everything we want. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_driver_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct pci_device_id *ent)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br>  For example, you can try to read the configuration registers described above in order to verify the correctness of identifiers or to determine the revision of the board. <br><br>  In case of any problems or inconsistencies, you can return a negative error code value and the kernel will abort the loading of the module.  Reading the configuration registers will be discussed below. <br><br>  It is also usually in this place that the initialization of the device's I / O memory is performed for subsequent work with it. <br><br>  It will be useful in this place to define some ‚Äúprivate‚Äù driver structure in which data will be stored, useful in all driver functions.  For example, it might be a pointer to the same device I / O memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_driver_priv</span></span></span><span class="hljs-class"> {</span></span> u8 __iomem *hwmem; }</code> </pre> <br>  After initialization of the private structure, it is necessary to register it. <br><br><pre> <code class="cpp hljs">pci_set_drvdata(pdev, drv_priv);</code> </pre> <br>  In the <b>my_driver_remove ()</b> function, <b>it is</b> convenient to perform freeing of occupied resources, for example, you can free up I / O memory. <br><br>  Also here it is necessary to free the struct pci_dev structure itself. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_driver_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_driver_priv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">drv_priv</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pci_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (drv_priv) { kfree(drv_priv); } pci_disable_device(pdev); }</code> </pre> <br><h2>  Work with configuration registers </h2><br>  There are several functions for performing read / write registers in the Linux kernel.  All these functions related to the PCI subsystem are available in the header file &lt;linux / pci.h&gt; <br><br>  Reading 8, 16 and 32 bits of registers respectively: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_read_config_byte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u8 *ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_read_config_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u16 *ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_read_config_dword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u32 *ptr)</span></span></span></span>;</code> </pre> <br>  Write 8, 16 and 32 bits of registers, respectively: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_write_config_byte</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u8 val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_write_config_word</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u16 val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pci_write_config_dword</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> where, u32 val)</span></span></span></span>;</code> </pre> <br>  The first argument of all these functions is the pci_dev structure, which is directly related to a specific PCI device.  Initialization of this structure will be discussed below. <br><br>  For example, we want to read the values ‚Äã‚Äãof the Vendor ID, Product ID and Revision ID registers: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/pci.h&gt; ‚Ä¶. u16 vendor, device, revision; pci_read_config_word(pdev, PCI_VENDOR_ID, &amp;vendor); pci_read_config_word(pdev, PCI_DEVICE_ID, &amp;device); pci_read_config_word(pdev, PCI_REVISION_ID, &amp;revision);</span></span></span></span></code> </pre> <br>  As you can see, everything is extremely simple, by substituting the necessary value of the whrere argument, we can access any configuration register of a particular pci_dev. <br><br>  Reading / writing a device‚Äôs memory is a bit more complicated. <br><br>  We have to specify what type of resource we want to receive, decide on the size and offset, select the necessary piece of memory and map this piece of memory to the device. <br>  After that, we can write and read this memory as we please, interacting directly with the device. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/pci.h&gt; int bar; unsigned long mmio_start, mmio_len; u8 __iomem *hwmem; struct pci_dev *pdev; ... //        ,      / bar = pci_select_bars(pdev, IORESOURCE_MEM); // ""   pci_enable_device_mem(pdev); //    ,     pci_request_region(pdev, bar, "My PCI driver"); //            mmio_start = pci_resource_start(pdev, 0); mmio_len = pci_resource_len(pdev, 0); //      hwmem = ioremap(mmio_start, mmio_len);</span></span></span></span></code> </pre> <br>  Then we can freely work with the memory pointed to by hwmem. <br>  It is best to use special kernel functions for this purpose. <br><br>  Write 8, 16 and 32 bits in the device memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iowrite8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iowrite16</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iowrite32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span></span></code> </pre> <br><br>  Reading 8, 16 and 32 bits from device memory: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioread8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioread16</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioread32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __iomem *addr)</span></span></span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Full code of the test PCI driver module</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/pci.h&gt; #define MY_DRIVER "my_pci_driver" static struct pci_device_id my_driver_id_table[] = { { PCI_DEVICE(0x0F0F, 0x0F0E) }, { PCI_DEVICE(0x0F0F, 0x0F0D) }, {0,} }; MODULE_DEVICE_TABLE(pci, my_driver_id_table); static int my_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent); static void my_driver_remove(struct pci_dev *pdev); static struct pci_driver my_driver = { .name = MY_DRIVER, .id_table = my_driver_id_table, .probe = my_driver_probe, .remove = my_driver_remove }; struct my_driver_priv { u8 __iomem *hwmem; }; static int __init mypci_driver_init(void) { return pci_register_driver(&amp;my_driver); } static void __exit mypci_driver_exit(void) { pci_unregister_driver(&amp;my_driver); } void release_device(struct pci_dev *pdev) { pci_release_region(pdev, pci_select_bars(pdev, IORESOURCE_MEM)); pci_disable_device(pdev); } static int my_driver_probe(struct pci_dev *pdev, const struct pci_device_id *ent) { int bar, err; u16 vendor, device; unsigned long mmio_start,mmio_len; struct my_driver_priv *drv_priv; pci_read_config_word(pdev, PCI_VENDOR_ID, &amp;vendor); pci_read_config_word(pdev, PCI_DEVICE_ID, &amp;device); printk(KERN_INFO "Device vid: 0x%X pid: 0x%X\n", vendor, device); bar = pci_select_bars(pdev, IORESOURCE_MEM); err = pci_enable_device_mem(pdev); if (err) { return err; } err = pci_request_region(pdev, bar, MY_DRIVER); if (err) { pci_disable_device(pdev); return err; } mmio_start = pci_resource_start(pdev, 0); mmio_len = pci_resource_len(pdev, 0); drv_priv = kzalloc(sizeof(struct my_driver_priv), GFP_KERNEL); if (!drv_priv) { release_device(pdev); return -ENOMEM; } drv_priv-&gt;hwmem = ioremap(mmio_start, mmio_len); if (!drv_priv-&gt;hwmem) { release_device(pdev); return -EIO; } pci_set_drvdata(pdev, drv_priv); return 0; } static void my_driver_remove(struct pci_dev *pdev) { struct my_driver_priv *drv_priv = pci_get_drvdata(pdev); if (drv_priv) { if (drv_priv-&gt;hwmem) { iounmap(drv_priv-&gt;hwmem); } kfree(drv_priv); } release_device(pdev); } MODULE_LICENSE("GPL"); MODULE_AUTHOR("Oleg Kutkov &lt;elenbert@gmail.com&gt;"); MODULE_DESCRIPTION("Test PCI driver"); MODULE_VERSION("0.1"); module_init(mypci_driver_init); module_exit(mypci_driver_exit);</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">And a makefile to build it</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BINARY := test_pci_module KERNEL := /lib/modules/$(shell uname -r)/build ARCH := x86 C_FLAGS := -Wall KMOD_DIR := $(shell pwd) TARGET_PATH := /lib/modules/$(shell uname -r)/kernel/drivers/<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> OBJECTS := test_pci.o ccflags-y += $(C_FLAGS) obj-m += $(BINARY).o $(BINARY)-y := $(OBJECTS) $(BINARY).ko: make -C $(KERNEL) M=$(KMOD_DIR) modules install: cp $(BINARY).ko $(TARGET_PATH) depmod -a</code> </pre> <br></div></div><br>  Make sure you have the kernel header files installed.  For Debian / Ubuntu, installing the required package is as follows: <br><br><pre> <code class="bash hljs">sudo apt-get install linux-headers-$(uname -r)</code> </pre> <br>  The module is compiled with a simple make command, you can try loading the module with <br><br><pre> <code class="bash hljs">sudo insmod test_pci_module.ko</code> </pre> <br>  Most likely, nothing will just happen quietly, unless you really have a device with Vendor and Product ID from our example. <br><br>  Now I would like to return to the specific device for which the driver was developed. <br>  Here is what information about IO sent to me by the developers of the LIR-941 board: <br><br><img src="https://habrastorage.org/webt/tl/td/tf/tltdtfud9td0qywqixyle_akbuk.png"><br><blockquote>  RgStatus: <br>  b7 - Flag of pause between SSI transactions (1 - pause) (see SSI protocol) <br>  b6 - The flag of the current transaction (1 - data is being transmitted) (see SSI protocol) <br>  b5 - Ext4 (Data latch on Ext4 signal occurred) <br>  b4 - Ext3 (Data latch on Ext3 signal occurred) <br>  b3 - Ext2 (Data latch occurred on Ext2 signal) <br>  b2 - Ext1 (Data latch occurred on Ext1 signal) <br>  b1 - Continuous polling mode (Upon completion of the transfer of the code, a new request is generated by the hardware) <br>  b0 - On request from computer (Single request for current position) </blockquote>  This means that if I want, for example, to read data from an encoder connected to channel 3, I need to check the seventh bit of the RgStatus3 block, wait there for a unit (the pause between transactions means it has already received information from the sensor and recorded it in the board‚Äôs memory, prepare for the next request) and read the number stored in the third piece of memory with a length of 32 bits. <br><br>  It all comes down to calculating the necessary shift from the beginning of a piece of memory and reading the required number of bytes. <br><br>  It is clear from the table that channel data is stored as 32 bit values, and RgStatus data is stored as 8 bit lengths. <br><br>  So to read RgStatus3 you need to move 4 times 32 bits and two times 8 bits and then read 8 bits from this position. <br><br>  And to read the data of the third channel, you need to move 2 times 32 bits each and read the value 32 bits long. <br><br>  To perform all these operations, you can write convenient macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHANNEL_DATA_OFFSET(chnum) (sizeof(uint32_t) * chnum) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHANNEL_RG_ST_OFFSET(chnum) ((sizeof(uint32_t) * 4) + (sizeof(uint8_t) * chnum))</span></span></code> </pre> <br>  Where chnum is the number of the desired channel, starting from zero. <br><br>  Also, in this case, a simple macro will not be superfluous, determining whether the bit is ‚Äúon‚Äù at a certain position. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECK_BIT(var,pos) ((var) &amp; (1 &lt;&lt; (pos)))</span></span></code> </pre> <br>  It turns out this code to read the third data channel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/pci.h&gt; ‚Ä¶ uint8_t chnum = 2; uint32_t enc_data; // hwmem ‚Äî  ,     // r_addr     ,   RgStatus3 void* r_addr = hwmem + CHANNEL_RG_ST_OFFSET(chnum); //     while(1) { //  8    r_addr reg = ioread8(r_addr); //  7  ¬´¬ª -   ,   if (!CHECK_BIT(reg, 7)) { break; } } //    ,     r_addr = hwmem + CHANNEL_DATA_OFFSET(chnum); //  32   enc_data = ioread32(r_addr);</span></span></span></span></code> </pre> <br>  Everything, we received from the board the data of the sensor connected to the third channel and wrote it into the variable enc_data. <br><br>  Regarding the record in the device, the manufacturer has already sent another label. <br>  It can be seen that the record structure is slightly different and you will have to write new macros, with new offsets. <br><br><img src="https://habrastorage.org/webt/og/tf/pq/ogtfpqqcxx8ve8rugtmk7zleyty.png"><br><blockquote>  DATA WIDTH - Determines the maximum number of bits in a single SSI transaction.  (digit capacity of the receiving register).  Valid values ‚Äã‚Äãare from 1 to 32 <br><br>  CLOCK RATE - A port that determines the division ratio of the system Clk (33 MHz) for the formation of a Block SSI. <br>  Kdel = (CLOCK RATE) * 2 + 2 <br>  PAUSE RATE Port defining the amount of pause after the transaction, in periods Clk (30 ns) <br>  CONTROL 1: <br>  b7 - SSI mode (0 - normal mode, 1 - 16-bit abs mode. Sensor, with wait for the start bit (obsolete data output, only needed for compatibility)). <br>  b6 - Reserved <br>  b5 - Ext4 external signal resolution <br>  b4 - Resolution of the external signal Ext3 <br>  b3 - Resolution of the external signal Ext2 <br>  b2 - Resolution of the external signal Ext1 <br>  b1 - Resolution of continuous sensor polling <br>  b0 - Generate a one-time survey </blockquote>  It's all the same here - we consider the shift for the required area and write the value with the corresponding function iowriteX <br><br><h2>  User Interface Interaction with PCI Driver </h2><br>  There are several ways to communicate the higher software with our driver.  One of the oldest, easiest, and most popular ways is the character device. <br>  Character device is a virtual device that can be added to the / dev directory, it can be opened, something written, read, make ioctl calls to set any parameters. <br><br>  A good example of such a device is a serial driver with its / dev / ttySX <br><br>  Registering the character device is convenient to make a separate function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_char_devs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct my_driver_priv* drv)</span></span></span></span>;</code> </pre> <br>  A pointer to our private structure is necessary for the subsequent initialization of the file object, so that with each user open / read / write / ioctl / close call we will have access to our private structure and will be able to perform read / write operations to the PCI device. <br><br>  <b>It is</b> convenient to <b>call create_char_devs ()</b> in the <b>my_driver_probe ()</b> function, after all initializations and checks. <br><blockquote>  In my case, this function is called create_char_devs (), in the plural.  The fact is that the driver creates several of the same name (but with different digital indices at the end of the name) character device, one per channel of the LIR941 board, this allows you to conveniently, independently and simultaneously work with several connected sensors at once. <br></blockquote>  Creating a character device is pretty simple. <br><br>  We determine the number of devices, allocate memory and initialize each device with the configured file_operations structure.  This structure contains references to our file operations functions that will be called by the kernel when working with a device file in user space. <br><br>  Inside the kernel, all / dev devices are identified by a pair of ids. <pre> <code class="bash hljs">&lt;major&gt;:&lt;minor&gt;</code> </pre> <br><br>  Some major identifiers are reserved and are always assigned to specific devices, other identifiers are dynamic. <br>  The major value is shared by all devices of a specific driver; they differ only in the minor identifiers. <br><br>  When you initialize your device, you can set the value to major with your hands, well, it‚Äôs better not to do this, since you can arrange a conflict.  The best option is to use the <b>MAJOR ()</b> macro. <br><br>  Its application will be shown in the code below. <br><br>  In the case of a minor, the value usually coincides with the sequence number of the device, when created, starting from zero.  This allows you to find out which particular device / dev / device-X is accessed from the kernel space - just look at the minor available in the handler for file operations. <br><br>  Identifiers: displayed by the ls utility with the -l option <br>  for example, if you run: <br><br><pre> <code class="cpp hljs">$ ls -l /dev/i2c-* crw------- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> . <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span> /dev/i2c<span class="hljs-number"><span class="hljs-number">-0</span></span> crw------- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> . <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span> /dev/i2c<span class="hljs-number"><span class="hljs-number">-1</span></span> crw------- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> . <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span> /dev/i2c<span class="hljs-number"><span class="hljs-number">-2</span></span> crw------- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> . <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span> /dev/i2c<span class="hljs-number"><span class="hljs-number">-3</span></span> crw------- <span class="hljs-number"><span class="hljs-number">1</span></span> root root <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> . <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span> /dev/i2c<span class="hljs-number"><span class="hljs-number">-4</span></span></code> </pre> <br>  The number 89 is the major identifier of the driver for the i2c bus controller, it is common to all channels of i2c, and 0.1,2,3,4 is the minor identifier. <br><br>  An example of creating a set of devices. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/cdev.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/fs.h&gt; //  4  #define MAX_DEV 4 //     static int mydev_open(struct inode *inode, struct file *file); static int mydev_release(struct inode *inode, struct file *file); static long mydev_ioctl(struct file *file, unsigned int cmd, unsigned long arg); static ssize_t mydev_read(struct file *file, char __user *buf, size_t count, loff_t *offset); static ssize_t mydev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset); //   file_operations static const struct file_operations mydev_fops = { .owner = THIS_MODULE, .open = mydev_open, .release = mydev_release, .unlocked_ioctl = mydev_ioctl, .read = mydev_read, .write = mydev_write }; //  ,    struct my_device_data { struct device* mydev; struct cdev cdev; }; //          //            //   ,        static int dev_major = 0; //   ,      /sys //      udev static struct class *mydevclass = NULL; //       my_device_data,    //      ,      static struct lir_device_data mydev_data[MAX_DEV]; int create_char_devs() { int err, i; dev_t dev; //       err = alloc_chrdev_region(&amp;dev, 0, MAX_DEV, "mydev"); //  major      dev_major = MAJOR(dev); //  sysfs    mydev mydevclass = class_create(THIS_MODULE, "mydev"); //        for (i = 0; i &lt; MAX_DEV; i++) { //      file_operations cdev_init(&amp;mydev_data[i].cdev, &amp;mydev_fops); //   -    mydev_data[i].cdev.owner = THIS_MODULE; //       cdev_add(&amp;mydev_data[i].cdev, MKDEV(dev_major, i), 1); //      /dev/mydev-&lt;i&gt; //   &lt;i&gt;     mydev_data[i].mydev = device_create(mydevclass, NULL, MKDEV(dev_major, i), NULL, "mydev-%d", i); } return 0; }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mydev_open ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">will be called if someone tries to open our device in user space. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is very convenient in this function to initialize the private structure for an open device file. </font><font style="vertical-align: inherit;">In it, you can save the minor value for the current open device. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also put a pointer to some more global structures to help interact with the rest of the driver, for example, we can save a pointer to my_driver_priv, which we worked with earlier, in this place. </font><font style="vertical-align: inherit;">A pointer to this structure can be used in ioctl / read / write operations to execute hardware queries. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can define this structure:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_device_private</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chnum; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_driver_priv</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">drv</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opening function </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mydev_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_device_private</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_priv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   minor      unsigned int minor = iminor(inode); //         dev_priv = kzalloc(sizeof(struct lir_device_private), GFP_KERNEL); // drv_access ‚Äî     my_device_private,   //    ,   PCI dev_priv-&gt;drv = drv_access; dev_priv -&gt;chnum = minor; //          //        ,     file-&gt;private_data = dev_priv; //   0,  open()   return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read and write operations are fairly simple, the only ‚Äúnuance‚Äù is the lack of security (or even impossibility) of direct access of the user application to the kernel memory and vice versa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this regard, to obtain data written using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function, you must use the kernel function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy_from_user ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And when executing </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you must use </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy_to_user ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both features come with various checks and ensure safe data copying between the core and user space.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mydev_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct file *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,    open() struct my_device_private* drv = file-&gt;private_data; uint32_t result; //  -        // get_data_from_hardware,     result = get_data_from_hardware(drv-&gt;drv, drv-&gt;chnum); //      if (copy_to_user(buf, &amp;data, count)) { return -EFAULT; } //     return count; } static ssize_t mydev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) { ssize_t count = 42; char data[count]; if (copy_from_user(data, buf, count) != 0) { return -EFAULT; } //   data,  42   -    //        //     return count; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> call handler </font><font style="vertical-align: inherit;">takes as its arguments the actual ioctl number of the operation and some transmitted data as arguments (if necessary). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation numbers are </font><font style="vertical-align: inherit;">determined by the driver developer. </font><font style="vertical-align: inherit;">It's just some kind of "magic" numbers behind the readable define. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These numbers should be known to the user program, so it is convenient to take them somewhere as a separate header file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ioctl handler example</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mydev_ioctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct file *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cmd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_device_private</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">drv</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private_data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (cmd) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MY_IOCTL_OP_1: do_hardware_op_1(drv-&gt;drv, drv-&gt;chnum); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MY_IOCTL_OP_2: do_hardware_op_2(drv-&gt;drv, drv-&gt;chnum); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mydev_release ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">is called when the device file is </font><b><font style="vertical-align: inherit;">closed</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our case, it is enough just to free the memory of our private file structure.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mydev_release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, struct file *file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_device_private</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">priv</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private_data</span></span></span><span class="hljs-class">;</span></span> kfree(priv); priv = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the function to destroy a character device, you must delete all created devices, destroy the sysfs class, and free up memory. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy_char_devs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_DEV; i++) { device_destroy(mydevclass, MKDEV(dev_major, i)); } class_unregister(mydevclass); class_destroy(mydevclass); unregister_chrdev_region(MKDEV(dev_major, <span class="hljs-number"><span class="hljs-number">0</span></span>), MINORMASK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function should be called in the __exit method of the kernel module, so that a character device would be destroyed when it was unloaded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All other work is reduced to the interaction between the character device and the actual equipment, as well as the writing of various auxiliary code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full source code for the driver for the LIR941 card can be viewed on </font></font><a href="https://github.com/olegkutkov/lir941_linux_driver"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And </font></font><a href="https://github.com/olegkutkov/lir941_test_util"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a simple test utility that works with this driver. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Driver testing on real hardware :)</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7h7ju9n_nTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What to read: </font></font><br> <a href="https://wiki.osdev.org/PCI"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki.osdev.org/PCI </font></font></a> <br> <a href="http://www.tldp.org/LDP/tlk/dd/pci.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.tldp.org/LDP/tlk/dd/pci.html </font></font></a> <br> <a href="https://lwn.net/Kernel/LDD3/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lwn.net/Kernel/LDD3</font></font></a> <br><br>  Thanks for attention! <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I hope this material will be useful to those who decide to write their own driver for something. </font></font></div><p>Source: <a href="https://habr.com/ru/post/348042/">https://habr.com/ru/post/348042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348032/index.html">Mobility Express - when they decided to migrate and scale the wireless network, but as always, there is no money</a></li>
<li><a href="../348034/index.html">Meeting Room Little Helper</a></li>
<li><a href="../348036/index.html">Software sound synthesis on early personal computers. Part 1</a></li>
<li><a href="../348038/index.html">WSTester - JS library for testing web services with WebSocket</a></li>
<li><a href="../348040/index.html">How Atlassian has built a $ 10 billion business. Part 2</a></li>
<li><a href="../348044/index.html">Rook - "self-service" data store for Kubernetes</a></li>
<li><a href="../348046/index.html">What exactly is personal data?</a></li>
<li><a href="../348052/index.html">Top 5 Information Security Forecasts</a></li>
<li><a href="../348054/index.html">How we adapted the ELK stack to monitor and analyze errors in Java and .NET projects</a></li>
<li><a href="../348056/index.html">How I wrote the Java Olympics or why it is better not to use Scanner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>