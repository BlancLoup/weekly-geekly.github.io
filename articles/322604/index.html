<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Query translation to SQL using LinqToSql in tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For several years now we have been doing our marketing automation product, and CI, or rather, a large number of automated tests, helps us to cut featu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Query translation to SQL using LinqToSql in tests</h1><div class="post__text post__text-html js-mediator-article">  For several years now we have been doing our marketing automation product, and CI, or rather, a large number of automated tests, helps us to cut features with high speed. <br><br>  There are approximately 700,000 lines of code with all customizations in the product, and we all have about 7,000 tests for this, and their number is constantly growing.  Due to them, we are not afraid to perform large refactorings affecting many parts of the system.  But, unfortunately, tests are not a panacea.  Some tests may not be, some tests may be too expensive, and some situations are not reproduced in the test environment. <br><br>  Virtually every transaction in our system is associated with working with MS SQL using LinqToSql.  Yes, the technology is old, but it is quite difficult for us to migrate from it, and in business it suits us perfectly.  Moreover, as I <a href="https://habrahabr.ru/company/mindbox/blog/253779/">wrote earlier</a> , we even have <a href="">our own LinqToSql fork</a> , where we fix its bugs and add some functionality. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to make queries to the database using LinqToSql, you need to use the IQueryable interface.  At the time of receiving Enumerator or Execute from QueryProvider, the constructed expression tree is translated using SQL-methods to IQueryable to SQL, which is executed on SQL Server. <br><br>  Since our business logic is strongly tied to entities in the database, our tests work a lot with the database.  However, in 95% of tests we do not use a real database, since it is very time-consuming, and we are content with InMemoryDatabase.  It is part of our test infrastructure, about which you can write a separate article, and in fact is just a Dictionary &lt;Type, List&gt; for each existing entity type.  In tests, our UnitOfWork transparently works with such a database, giving access to EnumerableQueryable, which is simply obtained from any IEnumerable, calling AsQueryable () from it. <br><br>  I will show an example of a test for understanding what is happening: <br><a name="habracut"></a><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> customer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerTestDataBuilder(TestDatabase).Build(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SegmentFilter&lt;Customer&gt;(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, modelContext) { Segmentation = Controller.PeriodicalSegmentation, Segment = FilterValueWithPresence&lt;Segment&gt;.Concrete(Controller.PeriodicalSegment1) }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = modelContext.Repositories.Get&lt;CustomerRepository&gt;().GetFiltered(filter).ToList(); Assert.IsFalse(result.Contains(customer)); } }</code> </pre> <br>  In the test, we create a modelContext - our UnitOfWork, a wrapper over a DataContext with all sorts of buns, and then use it to get to the repository and filter out some segments.  Of course, the repository does not know about any tests, just ModelContext works with InMemoryDatabase.  The GetFiltered (filter) method forms some IQueryable, and then we materialize it. <br><br>  There is a problem with this approach: we are not testing in any way that the IQueryable that we got from GetFiltered translates to SQL.  As a result, we can get a bug on the production of something like this: <br><blockquote>  [NotSupportedException: Method 'Boolean DoesCurrentUserHaveSmsPermissionOnProject (Int32)' has no support.] <br>  at System.Data.Linq.SqlClient.PostBindDotNetConverter.Visitor.VisitMethodCall (SqlMethodCall mc) <br>  at System.Data.Linq.SqlClient.SqlVisitor.Visit (SqlNode node) <br>  at System.Data.Linq.SqlClient.SqlVisitor.VisitExpression (SqlExpression exp) <br>  at System.Data.Linq.SqlClient.SqlVisitor.VisitSelectCore (SqlSelect select) <br>  at System.Data.Linq.SqlClient.PostBindDotNetConverter.Visitor.VisitSelect (SqlSelect select) <br>  ... <br></blockquote><br>  How to make sure that such bugs do not fall on the production?  You can write tests with a real base, and we have them.  They are slightly different from those that work with InMemoryDatabase, the test class just has a different parent.  Here is an example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> () { Controller.CurrentDateTimeUtc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2016</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DateTimeKind.Utc); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionStartDateTime = Controller.CurrentDateTimeUtc.Value.AddHours(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> customer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerTestDataBuilder(modelContext).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activeSession = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerSessionTestDataBuilder(modelContext) .WithLastCustomer(customer) .Active() .WithStartDateTimeUtc(sessionStartDateTime) .Build(); modelContext.SubmitTestData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newSession = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomerSession { PointOfContact = activeSession.PointOfContact, DeviceGuid = activeSession.DeviceGuid, IpAddress = activeSession.IpAddress, ScreenResolution = activeSession.IpAddress, IsAuthenticated = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; newSession.SetStartDateTimeUtc(modelContext, Controller.CurrentDateTimeUtc.Value, customer); newSession.SetUserAgent(activeSession.UserAgent.UserAgentString, modelContext); newSession.SetLastCustomer(modelContext, customer, copyWebSiteVisitActions: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); modelContext.Repositories.Get&lt;CustomerSessionRepository&gt;().Add(newSession); modelContext.SubmitChanges(); Assert.IsNull(activeSession.IsActiveOrNull); Assert.IsNotNull(newSession.IsActiveOrNull); } }</code> </pre> <br>  In this test, everything happens in a real database, followed by a rollback of the Snapshot transaction, and cannot get through such errors.  But, of course, there are not very many such tests, only about a hundred.  The number does not come to any comparison with 7,000. And they cost much more time than usual ones. <br><br>  The decision suggested itself: write your own implementation of IQueryable and, accordingly, IQueryProvider, decorating EnumberableQueryble and System.Data.Linq.DataQuery.  Such an implementation should, when trying to get the result of a query using an enumerator, or by calling methods that immediately execute the query, such as Any, Count, Single, etc., first check whether the query can be translated to SQL, and if you can, just execute it over ordinary collections. <br><br>  Now I will tell you exactly how this is implemented, and I will begin with a test that such a translation works in general: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testEntity1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityTestDataBuilder(TestDatabase).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testEntity2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityTestDataBuilder(TestDatabase).Build(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = modelContext.Repositories.Get&lt;SomeTestEntityRepository&gt;().Items.Select(e =&gt; e.Id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery = query.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expectedQuery = <span class="hljs-string"><span class="hljs-string">$"SELECT [t0].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(SomeTestEntity.Id)}</span></span></span><span class="hljs-string">]\r\n"</span></span> + <span class="hljs-string"><span class="hljs-string">$"FROM [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SomeTestEntity.TableName}</span></span></span><span class="hljs-string">] AS [t0]"</span></span>; Assert.AreEqual(expectedQuery, sqlQuery); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entities = query.ToList(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">2</span></span>, entities.Count); Assert.IsTrue(entities.Contains(testEntity1.Id)); Assert.IsTrue(entities.Contains(testEntity2.Id)); } }</code> </pre> <br>  This and several other tests were written to verify that SQL translation actually occurs and works correctly.  Here are some more examples: <br><div class="spoiler">  <b class="spoiler_title">A couple of tests under the spoiler</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EntityRefInheritanceMapping() { SomeAbstractTestEntity testEntity1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityChildTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">1</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testEntity2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">2</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anotherTestEntity1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnotherTestEntityTestDataBuilder(TestDatabase).WithLinkedEntity(testEntity1).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anotherTestEntity2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnotherTestEntityTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">3</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = modelContext.Repositories.Get&lt;AnotherTestEntityRepository&gt;() .Items .Where(a =&gt; a.SomeTestEntity == testEntity1) .Select(a =&gt; a.Id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entities = query.ToList(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, entities.Count); Assert.IsTrue(entities.Contains(anotherTestEntity1.Id)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery = query.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expectedQuery = <span class="hljs-string"><span class="hljs-string">$"SELECT [t0].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(AnotherTestEntity.Id)}</span></span></span><span class="hljs-string">]\r\n"</span></span> + <span class="hljs-string"><span class="hljs-string">$"FROM [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{AnotherTestEntity.TableName}</span></span></span><span class="hljs-string">] AS [t0]\r\n"</span></span> + <span class="hljs-string"><span class="hljs-string">$"WHERE [t0].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(AnotherTestEntity.SomeTestEntityId)}</span></span></span><span class="hljs-string">] = @p0"</span></span>; Assert.AreEqual(expectedQuery, sqlQuery); } }</code> </pre> <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SQL() { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = modelContext.Repositories.Get&lt;SomeTestEntityRepository&gt;().Items.Where(e =&gt; e.ToString() == <span class="hljs-string"><span class="hljs-string">"asdf"</span></span>); AssertException.Throws&lt;InvalidOperationException&gt;( () =&gt; query.ToList(), <span class="hljs-string"><span class="hljs-string">"ToStringOnlySupportedForPrimitiveTypes"</span></span>); } }</code> </pre> <br></div></div><br>  As you can see in the last example, when you try to enumerate over IQueryable, which does not have translation in SQL, an exception occurs in the test. <br><br>  We now turn directly to the implementation.  We are interested in requests that occur within the model, that is, in fact, we are interested in any references to repositories.  The repository for each entity has a certain set of business methods and gives access to IQueryable through the Items property, which is just a DataTable.  Let's look at an example of using the Items property. <br><br>  Base class for all repositories: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Repository</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TEntity</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">Repository</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ITable&lt;TEntity&gt; table; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryable&lt;TEntity&gt; Items { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> table; } } }</code> </pre> <br>  Example of using Items inside the repository <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomerRepository</span></span> : <span class="hljs-title"><span class="hljs-title">ChangeRestrictedRepository</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Customer</span></span>, <span class="hljs-title"><span class="hljs-title">int</span></span>, <span class="hljs-title"><span class="hljs-title">CustomerInitialState</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Customer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCustomersByEmail</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> email</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(email)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Email  ."</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(email)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Items.Where(user =&gt; user.Email == email).ToList(); } }</code> </pre> <br><br>  Example of using outside repository: <br><pre> <code class="cs hljs">FmcgPurchase = Add(ReverseSingleLinkedItemFilter&lt;CustomerAction, FmcgPurchase&gt;.GetFactory( <span class="hljs-string"><span class="hljs-string">"fmcgpurchase"</span></span>, modelContext =&gt; customerAction =&gt; modelContext .Repositories .Get&lt;FmcgPurchaseRepository&gt;() .Items .Where(fmcgPurchase =&gt; fmcgPurchase.CustomerAction == customerAction), canLinkedItemBeAbsent: <span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  It turns out that you need to ensure that the Repository.Items returns our cunning IQueryable.  Well, write our sly IQueryable :) <br><br>  As was already seen above, Repository.Items actually returns ITable, and the table itself is initialized when creating UnitOfWork: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRepositoryRegistry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RepositoryRegistry repositories</span></span></span><span class="hljs-function">)</span></span> { table = repositories.DatabaseContext.GetTable&lt;TEntity&gt;(); }</code> </pre> <br>  The DatabaseContext.GetTable () method is abstract.  The DatabaseContext has 2 heirs: LinqDatabaseContext and InMemoryDatabaseContext.  In LinqDatabaseContext, which is used when working with a real database, everything is simple: GetTable returns System.Data.Linq.Table.  In InMemoryDatabase, the code is written like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> ITable&lt;T&gt; GetTable&lt;T&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tables.ContainsKey(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T))) tables.Add( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubTableImpl&lt;T&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InMemoryTable&lt;T&gt;)database.GetTable&lt;T&gt;(), linqToSqlTranslateHelperContext)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ITable&lt;T&gt;)tables[<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)]; }</code> </pre> <br>  There is a bit of magic with the cache and linqToSqlTranslateHelperContext, which is not very clear yet, but it is already clear that the IQueryable we need, which we need to replace, is StubTableImpl, as well as the database.GetTable () call is used. <br>  Let's start with database.GetTable ().  Here the point is that StubTable is created when we access some repositories when the UnitOfWork has already been created.  But in the test there can be a lot of UnitOfWork, and all of them should work with one base.  Database is that database, and StubTable is just a way to gain access to this database. <br><br>  Now let's take a closer look at the StubTableImpl class: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StubTableImpl</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ITable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IStubTable</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StubTableImpl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> InMemoryDatabaseContext databaseContext, InMemoryTable&lt;T&gt; inMemoryTable, DataContext linqToSqlTranslateHelperContext</span></span></span><span class="hljs-function">)</span></span> { InnerTable = inMemoryTable; innerQueryable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubTableQueryable&lt;T&gt;( databaseContext, linqToSqlTranslateHelperContext.GetTable&lt;T&gt;()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Type ElementType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerQueryable.ElementType; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression Expression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerQueryable.Expression; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryProvider Provider { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerQueryable.Provider; } } Type IStubTable.EntityType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerQueryable.Select(e =&gt; e).ToString(); } IEnumerable IStubTable.Items { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InnerTable; } } }</code> </pre> <br>  StubTableImpl implements IQueryable and IQueryProvider, delegating the entire implementation of StubTableQueryable innerQueryable.  The StubTableQueryable itself looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StubTableQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TEntity</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IOrderedQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TEntity</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> InMemoryDatabaseContext inMemoryContext; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IQueryable&lt;TEntity&gt; dataContextQueryable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StubTableQueryProvider stubTableQueryProvider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StubTableQueryable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> InMemoryDatabaseContext inMemoryContext, IQueryable&lt;TEntity&gt; dataContextQueryable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inMemoryContext = inMemoryContext; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dataContextQueryable = dataContextQueryable; stubTableQueryProvider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubTableQueryProvider(inMemoryContext, dataContextQueryable); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;TEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { inMemoryContext.CheckConvertionToSql(Expression); IEnumerable&lt;TEntity&gt; enumerable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumerableQuery&lt;TEntity&gt;(inMemoryContext.ConvertDataContextExpressionToInMemory(Expression)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> enumerable.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetEnumerator(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression Expression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataContextQueryable.Expression; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Type ElementType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataContextQueryable.ElementType; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryProvider Provider { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stubTableQueryProvider; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inMemoryContext.GetQueryText(Expression); } }</code> </pre> <br>  I will cite the StubTableQueryProvider code right away, because they are very interconnected (now it even seems that it would be reasonable for it to be one class): <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StubTableQueryProvider</span></span> : <span class="hljs-title"><span class="hljs-title">IQueryProvider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IQueryProvider enumerableQueryProvider = Array.Empty&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;().AsQueryable().Provider; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> InMemoryDatabaseContext inMemoryContext; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IQueryable dataContextQueryable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StubTableQueryProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> InMemoryDatabaseContext inMemoryContext, IQueryable dataContextQueryable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inMemoryContext = inMemoryContext; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dataContextQueryable = dataContextQueryable; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubTableQueryable&lt;TElement&gt;( inMemoryContext, dataContextQueryable.Provider.CreateQuery&lt;TElement&gt;(expression)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expression</span></span></span><span class="hljs-function">)</span></span> { inMemoryContext.CheckConvertionToSql(expression); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> enumerableQueryProvider.Execute(inMemoryContext.ConvertDataContextExpressionToInMemory(expression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TResult Execute&lt;TResult&gt;(Expression expression) { inMemoryContext.CheckConvertionToSql(expression); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> enumerableQueryProvider.Execute&lt;TResult&gt;(inMemoryContext.ConvertDataContextExpressionToInMemory(expression)); } }</code> </pre> <br>  Here it is necessary to explain how the construction of expression trees in general works using the extension methods on IQueryable in System.Linq. <br>  These methods themselves are defined in the static class Queryable.  Here is a piece of this class to understand what is happening: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Queryable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; predicate) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.Provider.CreateQuery&lt;TSource&gt;( Expression.Call( <span class="hljs-literal"><span class="hljs-literal">null</span></span>, GetMethodInfo(Queryable.Where, source, predicate), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expression[] { source.Expression, Expression.Quote(predicate) } )); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;TSource&gt; source) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.Provider.Execute&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( Expression.Call( <span class="hljs-literal"><span class="hljs-literal">null</span></span>, GetMethodInfo(Queryable.Count, source), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expression[] { source.Expression } )); } }</code> </pre> <br>  I gave here examples of the implementation of two methods: Where and Count.  My choice fell on them, because they show different ways of interaction between the IQueryable and IQueryProvider interfaces. <br>  Let's look first at the implementation of the Where method.  This method takes IQueryable and filter condition, and returns IQueryable.  With this, you can easily notice that this method does not filter anything.  All he does is create an expression tree: pull an expression tree out of an incoming IQueryable, add a call to the Where method to it, that is, itself, with the filter condition parameter.  After that, the resulting new expression tree is passed to IQueryProvider.CreateQuery, which is needed just to wrap the Expression in IQueryable. <br><br>  Let's try to make out by example.  Suppose we have this code: <br>  Customers.Where (c =&gt; c.Sex == Sex.Male) <br>  In this case, Customers - Table.  Then the IQueryable will be passed to the Where method, in which there will be an Expression - Table.  After that, Where will add itself to the end of this Expression with the condition we passed.  It turns out Table.Where (c =&gt; c.Sex == Sex.Male).  Next, this Expression is wrapped back into IQueryable and returned from the method.  There are no calls to the database, just a call to a pure function. <br><br>  Now look at the Count method.  It calculates the number of items in the requested collection immediately upon accessing it.  This is done by calling the IQueryProvider.Execute method.  This method takes an Expression, based on which it must build a query, and returns the result of this query ‚Äî a quantity.  Building an Expression here is similar to the Where method: the original IQueryable is taken, it turns out an Expression and is completed with a Count.  Thus, IQueryProvider.Execute should bypass this Expression, understand what is required of it and make the corresponding query to the database. <br><br>  Now, armed with new knowledge, let's return to StubTableQueryable and StubTableQueryProvider.  Now we roughly understand what we want from them: when calling the StubTableQueryable.GetEnumerator and StubTableQueryProvider.Execute methods, we have to take our Expression or IQueryable, try to translate it into SQL using some DataContext, and then retrieve the data just from memory.  To do this, StubTableQueryProvider.Execute and StubTableQueryable.GetEnumerator written similar code, which initially causes CheckConvertionToSql, and then use ConvertDataContextExpressionToInMemory converts source Expression and either executes it with the help EnumerableQueryble, or cause Enumerator in EnumerableQueryble with transformed Expression'om. <br><br>  To begin with, how to check that the query is actually translated into SQL.  The CheckConversionToSql method tries to get the query text by its Expression, for which it uses DataContext.GetCommand.  A small problem is that GetCommand accepts IQueryable, and we have Expression, but it doesn't matter, in fact, all he needs is Expression :) <br><br>  As a result, the code that checks that the query is translated to SQL looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryExpressionToQueryText.GetOrAdd( expression.ToString(), expressionText =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeQueryable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FakeQueryable(expression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = linqToSqlTranslateHelperContext.GetCommand(fakeQueryable); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.CommandText; }); }</code> </pre> <br>  The FakeQueryable class is just needed as an adapter, here‚Äôs its implementation: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FakeQueryable</span></span> : <span class="hljs-title"><span class="hljs-title">IQueryable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FakeQueryable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expression</span></span></span><span class="hljs-function">)</span></span> { Expression = expression; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression Expression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Type ElementType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryProvider Provider { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } } }</code> </pre> <br>  It would be more correct to correct Mindbox.Data.Linq so that the GetCommand (Expression) overload exists, but so far this has not been done. <br><br>  The linqToSqlTranslateHelperContext used above is the DataContext instance that is used not only to call GetCommand on it, but also to get a Table from it associated with the database.  The initial query is built against these Tables.  If we try to actually execute such a request, we will get an exception that there is no connection for this DataContext, because Connection is not needed to translate requests, but is needed to fulfill them. <br>  However, we still need to receive data from this Expression.  To do this, you have to convert a little, for which you use ConvertDataContextExpressionToInMemory. <br><br>  Usually, to do something with Expression, you need to inherit from ExpressionVisitor, where for each type of expression there is a method that you can override, and write your own logic there.  To replace the LinqToSql tables with the InMemoryDatabase tables in the Expression, we did.  Here is this Visitor: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConstantObjectReplaceExpressionVisitor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ExpressionVisitor</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;T, T&gt; replacementDictionary; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstantObjectReplaceExpressionVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Dictionary&lt;T, T&gt; replacementDictionary</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.replacementDictionary = replacementDictionary; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitConstant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ConstantExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = node.Value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitConstant(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!replacementDictionary.ContainsKey(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitConstant(node); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Constant(replacementDictionary[<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceConstants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression sourceExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Visit(sourceExpression); } }</code> </pre> <br>  The meaning of this Visitor is to replace one constant with another.  What to replace is transmitted in the constructor.  All logic is written in VisitConstant and fairly straightforward. <br>  Let's look at creating an instance of this Visitor: <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ConstantObjectReplaceExpressionVisitor&lt;IQueryable&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTableReplaceVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DataContext dataContext</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataContextTableToInMemoryTableMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;IQueryable, IQueryable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entityTypes = ModelApplicationHostController.Instance .ModelConfiguration .DatabaseModel .GetRepositoriesByEntity() .Keys; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entityType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> entityTypes) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataContextTable = dataContextGetTableFunc(dataContext, entityType); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataContextTable == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{entityType}</span></span></span><span class="hljs-string">      DataContext'"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inMemoryContextTable = GetInMemoryTable(database, entityType); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inMemoryContextTable == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{entityType}</span></span></span><span class="hljs-string">    InMemory "</span></span>); dataContextTableToInMemoryTableMap.Add(dataContextTable, inMemoryContextTable); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConstantObjectReplaceExpressionVisitor&lt;IQueryable&gt;(dataContextTableToInMemoryTableMap); }</code> </pre> <br>  Here we go through all types of entities that are registered, and for each type we get the Table from the DataContext - this will be the Key in the final Dictionary, as well as the InMemoryTable - this will be the Value.  As a result, the resulting Visitor will replace all ContantExpression, whose Value is present in the keys of the dictionary transferred to it and correspond to a Table of some of our entities, in InMemoryTable. <br><br>  It may seem that with such a passage there will be problems with expression trees, where we use not the constant value Table, but an expression whose value is Table.  The following test was written for this case: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testEntity1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">1</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testEntity2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeTestEntityTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">2</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anotherTestEntity1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnotherTestEntityTestDataBuilder(TestDatabase).WithId(testEntity1.Id).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anotherTestEntity2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnotherTestEntityTestDataBuilder(TestDatabase).WithId(<span class="hljs-number"><span class="hljs-number">3</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modelContext = CreateModelContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = modelContext.Repositories.Get&lt;SomeTestEntityRepository&gt;().Items .SelectMany(e =&gt; modelContext.Repositories.Get&lt;AnotherTestEntityRepository&gt;() .Items .Where(a =&gt; a.Id == e.Id)) .Select(a =&gt; a.Id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entities = query.ToList(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, entities.Count); Assert.IsTrue(entities.Contains(anotherTestEntity1.Id)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery = query.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expectedQuery = <span class="hljs-string"><span class="hljs-string">$"SELECT [t1].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(AnotherTestEntity.Id)}</span></span></span><span class="hljs-string">]\r\n"</span></span> + <span class="hljs-string"><span class="hljs-string">$"FROM [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SomeTestEntity.TableName}</span></span></span><span class="hljs-string">] AS [t0], [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{AnotherTestEntity.TableName}</span></span></span><span class="hljs-string">] AS [t1]\r\n"</span></span> + <span class="hljs-string"><span class="hljs-string">$"WHERE [t1].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(AnotherTestEntity.Id)}</span></span></span><span class="hljs-string">] = [t0].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(SomeTestEntity.Id)}</span></span></span><span class="hljs-string">]"</span></span>; Assert.AreEqual(expectedQuery, sqlQuery); } }</code> </pre> <br>  Here modelContext.Repositories.Get (). Items is part of the expression tree and will not be replaced by our Visitor.  Why, then, does such a test pass?  How the request is correctly transmitted and how does enumeration occur? <br>  Translating a query in such a situation should not be surprising, since LinqToSql during the broadcast of a query bypasses the expression tree, executing expressions in it that are actual constants.  All calls to C # methods will be called before the current translation, if they are not used in a context that requires execution on the SQL server.  That is why you can write modelContext.Repositories.Get (). Items.Where (a =&gt; a.TestNumber == GetSomeTestNumber ()) in the request, but you cannot write modelContext.Repositories.Get (). Items.Where (a =&gt; a .TestNumber == GetSomeTestNumber (a)).  Because in the first case, the result of GetSomeTestNumber () will be calculated at the broadcasting stage and substituted into the query, and in the second, GetSomeTestNumber takes the entity that the request is in, that is, depends on the entity, which means it must also be translated.  In the test, modelContext.Repositories.Get (). Items will be executed at the broadcasting stage, and Items from any repository will return StubTableImpl, the Expression of which is the Table.  For particularly inquisitive <a href="">I give a link to the code</a> that does what I described above. <br>  As for the direct execution of the request, it is still easier here.  After replacing the first and only Table in the Expression of the original query, it begins to run as a normal Enumerable.  And SelectMany just performs its part of the expression as a delegate.  As part of this implementation, we will try to translate the subquery into SQL, which we will, of course, replace the Table with InMemoryTable in it and perform exactly the same. <br><br>  What problems does this solution have?  The main problem is that there are still errors in the mapping that will not be detected in this way.  The fact that the request from IQueryable is translated to SQL does not mean that the materialization phase, when LinqToSql reads a stream with data and creates objects from them, will pass successfully.  For example, in this phase errors may occur related to attempts to write a Null-valued property of entities that cannot contain a Null.  ,       ,    ,          :     2 . <br>   ,     ,    . <br><br>  That's all.       :) </div><p>Source: <a href="https://habr.com/ru/post/322604/">https://habr.com/ru/post/322604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322592/index.html">The experience of creating a course on Android development on Udemy</a></li>
<li><a href="../322596/index.html">Implementing OOP inheritance in classes that work with SQL and MS Entity Framework</a></li>
<li><a href="../322598/index.html">Doom engine source code analysis: rendering</a></li>
<li><a href="../322600/index.html">IoT Security: Securing Azure IoT Deployment</a></li>
<li><a href="../322602/index.html">Why i ignore google recruiters</a></li>
<li><a href="../322606/index.html">Experience preparing and passing the Oracle Certified Professional Java SE 8 Programmer 1Z0-810 exam</a></li>
<li><a href="../322608/index.html">Parsim weblancer using PROXY</a></li>
<li><a href="../322610/index.html">The digest of interesting materials for the mobile # 192 developer (February 20-26)</a></li>
<li><a href="../322612/index.html">Perspective API is available for developers.</a></li>
<li><a href="../322614/index.html">Overview of automated paid parking systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>