<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the composition of functions in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's fantasize about the functional composition, as well as clarify the meaning of the composition / pipeline operator. 


 TL; DR 
 Compose function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the composition of functions in JavaScript</h1><div class="post__text post__text-html js-mediator-article"><p>  Let's fantasize about the functional composition, as well as clarify the meaning of the composition / pipeline operator. </p><br><p> TL; DR <br>  Compose functions like a boss: <br><img src="https://habrastorage.org/getpro/habr/post_images/57a/0a6/0a0/57a0a60a0d56aa2b5c54e460812190b4.png" alt="image"><br>  Popular <code>compose</code> implementations - when calling create new and new functions based on recursion, what are the disadvantages here and how to get around it. </p><a name="habracut"></a><br><p>  You can consider the compose function as a pure function that depends only on the arguments.  Thus composing the same functions in the same order, we must get an identical function, but in the JavaScript world this is not the case.  Any call to compose - returns a new function, this leads to the creation of more and more new functions in memory, as well as to the questions of their memoization, comparison and debugging. <br>  Need to do something. </p><br><h3 id="motivaciya">  Motivation </h3><br><ul><li>  Get associative identity: </li></ul><br><p>  It is highly desirable not to create new objects and reuse the previous results of the compose function.  One of the problems React of the developer - the implementation of shallowCompare, working with the result of the composition of functions.  For example, the composition of sending an event with a callback will always create a new function, which will lead to updating the value of the property. </p><br><p>  Popular implementations of the composition do not have the identity of the return value. <br>  Partially, the question of the identity of the compositions can be solved by memorizing the arguments.  However, the question of associative identity remains: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {memoize} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ramda'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoCompose = memoize(compose) memoCompose(a, b) === memoCompose(a, b) <span class="hljs-comment"><span class="hljs-comment">// ,   memoCompose(memoCompose(a, b), c) === memoCompose(a, memoCompose(b, c)) // ,       </span></span></code> </pre> <br><ul><li>  Simplify composition debugging: </li></ul><br><p>  Of course, using tap functions helps with debugging functions that have a single expression in the body.  However, it is advisable to have as flat a call stack as possible for debugging. </p><br><ul><li>  Get rid of the recursion overhead projector: </li></ul><br><p>  A recursive implementation of a functional composition has an overhead, creating new elements in the call stack.  When you call a composition of 5 or more functions, this is clearly visible.  And using functional approaches in the development it is necessary to build compositions from dozens of very simple functions. </p><br><h3 id="reshenie">  Decision </h3><br><p>  Make a monoid (or semigruppo with category specification support) in terms of fantasy-land: </p><br><pre> <code class="plaintext hljs">import compose, {identity} from 'lazy-compose' import {add} from 'ramda' const a = add(1) const b = add(2) const c = add(3) test('Laws', () =&gt; { compose(a, compose(b, c)) === compose(compose(a, b), c) //  compose(a, identity) === a //right identity compose(identity, a) === a //left identity }</code> </pre><br><h3 id="varianty-ispolzovaniya">  Use cases </h3><br><ul><li>  Useful in memosizing composite compositions when working with redaks.  For example for redux / mapStateToProps and <br>  reselect. </li><li>  The composition of the lenses. </li></ul><br><p>  You can create and reuse strictly equivalent lenses focused in one and the same place. </p><br><pre> <code class="plaintext hljs"> import {lensProp, memoize} from 'ramda' import compose from 'lazy-compose' const constantLens = memoize(lensProp) const lensA = constantLens('a') const lensB = constantLens('b') const lensC = constantLens('c') const lensAB = compose(lensB, lensA) console.log( compose(lensC, lensAB) === compose(lensC, lensB, lensA) )</code> </pre><br><ul><li>  Memotized callbacks, with the ability to composition up to the final function of sending an event. </li></ul><br><p>  In this example, the same callback will be passed to the list items. </p><br><pre> <code class="plaintext hljs">```jsx import {compose, constant} from './src/lazyCompose' // constant - returns the same memoized function for each argrum // just like React.useCallback import {compose, constant} from 'lazy-compose' const List = ({dispatch, data}) =&gt; data.map( id =&gt; &lt;Button key={id} onClick={compose(dispatch, makeAction, contsant(id))} /&gt; ) const Button = React.memo( props =&gt; &lt;button {...props} /&gt; ) const makeAction = payload =&gt; ({ type: 'onClick', payload, }) ```</code> </pre> <br><ul><li><p>  Lazy composition of React components without creating higher order components.  In this case, the lazy composition will collapse the array of functions, without creating additional closures.  This issue is of concern to many developers who use the recompose library. </p><br><pre> <code class="plaintext hljs">import {memoize, mergeRight} from 'ramda' import {constant, compose} from './src/lazyCompose' const defaultProps = memoize(mergeRight) const withState = memoize( defaultState =&gt; props =&gt; { const [state, setState] = React.useState(defaultState) return {...props, state, setState} } ) const Component = ({value, label, ...props)) =&gt; &lt;label {...props}&gt;{label} : {value}&lt;/label&gt; const withCounter = compose( ({setState, state, ...props}) =&gt; ({ ...props value: state, onClick: compose(setState, constant(state + 1)) }), withState(0), ) const Counter = compose( Component, withCounter, defaultProps({label: 'Clicks'}), )</code> </pre><br></li><li><p>  Monads and applicatives (in terms of fantasy-land) with strict equivalence through caching the result of the composition.  If inside the type constructor to access the dictionary of previously created objects, you get the following: </p><br></li></ul><br><pre> <code class="plaintext hljs"> type Info = { age?: number } type User = { info?: Info } const mayBeAge = LazyMaybe&lt;Info&gt;.of(identity) .map(getAge) .contramap(getInfo) const age = mayBeAge.ap(data) const maybeAge2 = LazyMaybe&lt;User&gt;.of(compose(getAge, getInfo)) console.log(maybeAge === maybeAge2) //   ,      //          </code> </pre> <br><p>  I have been using this approach for a long time, <a href="https://github.com/FlaPS/lazy-compose">I have created a repository here</a> . <br>  NPM package: <code>npm i lazy-compose</code> . </p><br><p>  It is interesting to get feedback about the limitation of the cache created in runtime functions dependent on the circuit. </p><br><p>  UPD <br>  I foresee obvious questions: <br>  Yes, you can replace Map with WeakMap. <br>  Yes, you need to make it possible to connect a third-party cache as middleware. <br>  It is not necessary to arrange a debate on caches, there is no perfect caching strategy. <br>  Why tail and head, if everything is in the list - tail and head, part of the implementation with memoization based on the parts of the composition, and not each function separately. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432196/">https://habr.com/ru/post/432196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432184/index.html">Problem personalities among testers</a></li>
<li><a href="../432186/index.html">Using STP to create p2p channels</a></li>
<li><a href="../432188/index.html">Hackers from the APT28 group attacked email-boxes of hundreds of employees of the Czech ministries</a></li>
<li><a href="../432190/index.html">Underside client-side physics prediction</a></li>
<li><a href="../432192/index.html">4 signs that you are not ready to implement a project management solution</a></li>
<li><a href="../432198/index.html">Delivery Manager - a new role in the world of Agile</a></li>
<li><a href="../432200/index.html">How Ivan stand conversion investigated</a></li>
<li><a href="../432202/index.html">Generation of type objects on the fly (or madness with Rust)</a></li>
<li><a href="../432204/index.html">Seminar "20 little things that will make the work in the data center truly comfortable", December 13, Moscow</a></li>
<li><a href="../432206/index.html">Detailed analysis of what Google showed at the FlutterLive conference (and what it means for Dart and the world)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>