<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift Error Handling - Sword and Magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you can see the overall picture from a distance, you can understand the essence at close range. Concepts that seemed far away to me and, frankly, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift Error Handling - Sword and Magic</h1><div class="post__text post__text-html js-mediator-article">  If you can see the overall picture from a distance, you can understand the essence at close range.  Concepts that seemed far away to me and, frankly, strange while experimenting with Haskell and Scala, when programming in Swift, become dazzlingly obvious solutions for a wide range of problems. <br><br>  Take error handling here.  A concrete example is the division of two numbers, which should cause an exception if the divisor is zero.  In Objective C, I would solve the problem like this: <br><br><pre><code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> result = [NMArithmetic divide:<span class="hljs-number"><span class="hljs-number">2.5</span></span> by:<span class="hljs-number"><span class="hljs-number">3.0</span></span> error:&amp;err]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"%@"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [NMArithmetic doSomethingWithResult:result] }</code> </pre> <br>  Over time, this began to seem like the most familiar way of writing code.  I don‚Äôt notice what kind of squiggles you have to write and how indirectly they are related to what I really want from the program: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Give me back the value.</i>  <i>If it does not work out, then let me know so that the error can be processed.</i> <br><br>  I pass the parameters, dereference the pointers, return the value in any case, and in some cases ignore it later.  This is unorganized code for the following reasons: <br><br><ul><li>  I speak machine language - pointers, dereferencing. </li><li>  I have to give the method myself the way in which it notifies me about the error. </li><li>  The method returns a certain result even in case of an error. </li></ul><br>  Each of these points is a source of possible bugs, and Swift solves all these problems in its own way.  The first item, for example, in Swift does not exist at all, since it hides all the work with pointers under the hood.  The remaining two points are solved with the help of transfers. <a name="habracut"></a><br><br>  If an error may occur during the calculation, there may be two results: <br><br><ol><li>  Successful - with return value </li><li>  Unsuccessful - preferably with an explanation of the cause of the error </li></ol><br>  These options are mutually exclusive - in our example, dividing by 0 causes an error, and everything else returns a result.  Swift expresses mutual exclusion through " <abbr title="enumerations">enumerations</abbr> ".  Here is the description of the result of the calculation with a possible error: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(<span class="hljs-type"><span class="hljs-type">T</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>) }</code> </pre><br>  An instance of this type can be either a <code>Success</code> label with a value or a <code>Failure</code> with a message describing the cause.  Each case keyword describes a constructor: the first accepts an instance of <code>T</code> (the value of the result), and the second <code>String</code> (the text of the error).  This is how the earlier Swift code would look like: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.5</span></span>, by:<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quotient): doSomethingWithResult(quotient) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errString): <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(errString) }</code> </pre><br>  Slightly longer, but much better!  The <code>switch</code> construction allows you to associate values ‚Äã‚Äãwith names ( <code>quotient</code> and <code>errString</code> ) and access them in code, and the result can be processed depending on the occurrence of an error.  All problems solved: <br><br><ul><li>  No pointers, and dereferencing and even more so </li><li>  You do not need to pass extra parameters to the <code>divide</code> function. </li><li>  The compiler checks if all enumeration options are processed. </li><li>  Since the <code>quotient</code> and <code>errString</code> are enumerated, they are declared only in their branches and it is impossible to access the result in case of an error. </li></ul><br>  But the most important thing is that this code does exactly what I want - it calculates the value and handles the errors.  It is directly related to the task. <br><br>  Now let's look at a more serious example.  Suppose I want to process the result ‚Äî get the magic number from the result, find the smallest prime factor from it and get its logarithm.  There is nothing magical in the calculation itself - I just chose random operations.  The code would look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magicNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(divisionResult:Result&lt;Float&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Float</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> divisionResult { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quotient): <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leastPrimeFactor = leastPrimeFactor(quotient) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logarithm = log(leastPrimeFactor) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Result</span></span>.<span class="hljs-type"><span class="hljs-type">Success</span></span>(logarithm) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errString): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Result</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>(errString) } }</code> </pre><br>  Looks easy.  But what if I want to get from a magic number ... a magic spell that corresponds to it?  I would write like this: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magicSpell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(magicNumResult:Result&lt;Float&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> magicNumResult { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value): <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spellID = spellIdentifier(value) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spell = incantation(spellID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Result</span></span>.<span class="hljs-type"><span class="hljs-type">Success</span></span>(spell) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errString): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Result</span></span>.<span class="hljs-type"><span class="hljs-type">Failure</span></span>(errString) } }</code> </pre><br>  Now, however, I have a <code>switch</code> expression for each function, and they are about the same.  Moreover, both functions handle only the successful value, while error handling is a constant distraction. <br><br>  When things begin to repeat, it is worth thinking about the method of abstraction.  And again, Swift has the right tools.  Enums can have methods, and I can get rid of the need for these <code>switch</code> expressions using the <code>map</code> method for the <code>Result</code> enumeration: <br><br><pre> <code class="bash hljs">enum Result&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Success(T) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Failure(String) func map&lt;P&gt;(f: T -&gt; P) -&gt; Result&lt;P&gt; { switch self { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Success(<span class="hljs-built_in"><span class="hljs-built_in">let</span></span> value): <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> .Success(f(value)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Failure(<span class="hljs-built_in"><span class="hljs-built_in">let</span></span> errString): <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> .Failure(errString) } } }</code> </pre><br>  The map method is named like this because it converts <code>Result&lt;T&gt;</code> to <code>Result&lt;P&gt;</code> , and it works very simply: <br><br><ul><li>  If there is a result, the function <code>f</code> is applied to it. </li><li>  If there is no result, the error is returned as is. </li></ul><br>  Despite its simplicity, this method allows you to work wonders.  Using error handling inside it, you can rewrite our methods using primitive operations: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magicNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(quotient:Float)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Float</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lpf = leastPrimeFactor(quotient) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> log(lpf) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magicSpell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(magicNumber:Float)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spellID = spellIdentifier(magicNumber) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incantation(spellID) }</code> </pre><br>  Now you can get the spell like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> theMagicSpell = divide(<span class="hljs-number"><span class="hljs-number">2.5</span></span>, by:<span class="hljs-number"><span class="hljs-number">3</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(magicNumber) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(magicSpell)</code> </pre><br>  Although you can get rid of the methods altogether: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> theMagicSpell = divide(<span class="hljs-number"><span class="hljs-number">2.5</span></span>, by:<span class="hljs-number"><span class="hljs-number">3</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(findLeastPrimeFactor) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(log) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(spellIdentifier) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(incantation)</code> </pre><br>  Isn't it cool?  All the need for error handling is removed inside the abstraction, and I only need to specify the necessary calculations - the error will be automatically forwarded. <br><br>  This, on the other hand, does not mean that I will never again have to use the <code>switch</code> expression.  At some point, you will have to either output an error or transfer the result to somewhere.  But it will be the only expression at the very end of the processing chain, and intermediate methods should not care about error handling. <br><br>  Magic, I tell you! <br><br>  This is all - not just academic "knowledge for the sake of knowledge."  Error handling abstraction is very often used to transform data.  For example, it is often necessary to get data from the server that comes in the form of <code>JSON</code> (an error string or result), convert it into a dictionary, then into an object, and then transfer this object to the UI level, where several more separate objects will be created from it .  Our enumeration will allow us to write methods as if they always work on valid data, and errors will be thrown between <code>map</code> calls. <br><br>  If you have never seen such techniques before, think about it for a while and try to tinker with the code.  <i>(For some time, the compiler had problems with generating code for generic enums, but maybe everything is already compiled).</i>  I think you will appreciate how powerful this approach is. <br><br><hr><br>  If you are good at math, you probably noticed a bug in my example.  The logarithm function is not declared for negative numbers, and values ‚Äã‚Äãsuch as <code>Float</code> may be.  In this case, the <code>log</code> will return not just <code>Float</code> , but rather <code>Result&lt;Float&gt;</code> .  If you pass such a value in the map, then we get the nested <code>Result</code> , and working with it so simply will not work.  For this, too, there is a reception - try to invent it yourself, and for those who are too lazy - I will describe in the next article. </div><p>Source: <a href="https://habr.com/ru/post/244575/">https://habr.com/ru/post/244575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244561/index.html">Do it yourself search on the site</a></li>
<li><a href="../244563/index.html">"Mathematics is one of the forms of art": post to the centenary of the birth of Martin Gardner</a></li>
<li><a href="../244565/index.html">The slowest x86 instruction</a></li>
<li><a href="../244571/index.html">Consulo: ~ 1000 kommitov, or as the autumn passed</a></li>
<li><a href="../244573/index.html">Eggs.Variant - Part I</a></li>
<li><a href="../244577/index.html">What the team leader should know and how we made up the program for the second day of the Go conference</a></li>
<li><a href="../244579/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ24 (November 24 - 30, 2014)</a></li>
<li><a href="../244585/index.html">CoreOS - Linux for minimalist clusters. Short</a></li>
<li><a href="../244587/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ136 (November 24 - 30, 2014)</a></li>
<li><a href="../244593/index.html">The fastest supercomputers in the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>