<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Migrating a non-downgrade database schema for postgresql using the example of django</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Hi, Habr! 


 I want to share the experience of writing migrations for postgres and django. This is mainly about postgres, django is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Migrating a non-downgrade database schema for postgresql using the example of django</h1><div class="post__text post__text-html js-mediator-article"><h1 id="vvedenie">  Introduction </h1><br><p>  Hi, Habr! </p><br><p>  I want to share the experience of writing migrations for postgres and django.  This is mainly about postgres, django is a good complement here, since it automatically migrates the data schema for model changes out of the box, that is, has a fairly complete list of work operations for changing the schema.  Django can be replaced with any favorite framework / library - approaches are likely to be similar. </p><br><p>  I will not describe how I came to this, but now reading the documentation I catch the thought that it was necessary to do this with more care and awareness earlier, therefore I highly recommend it. </p><br><p>  Before going further, let me make the following assumptions. </p><br><p>  You can divide the logic of working with the database of most applications into 3 parts: </p><br><ol><li>  Migrations - changing the database schema (tables), suppose we always run them in one thread. </li><li>  Business logic - direct work with data (in user tables), works with the same data constantly and competitively. </li><li>  Data migrations - do not change the data schema, they work essentially as a business logic, by default, when we talk about business logic, we also mean data migration. </li></ol><br><p>  Downtime is a state when part of our business logic is not available / is falling / loading for a noticeable time for the user, suppose it is a couple of seconds. </p><br><p>  Lack of downtime can be a critical condition for business that must be adhered to by any efforts. <a name="habracut"></a></p><br><h1 id="process-vykatki">  Rolling out process </h1><br><p>  The main requirements when rolling out: </p><br><ol><li>  we have one working base. </li><li>  we have several machines where business logic is spinning. </li><li>  Business logic machines are hidden behind the balancer. </li><li>  our application works well before, during and after the migration process (the old code works correctly with the old and new base scheme). </li><li>  our application works well before, during, and after updating the code on machines (the old and new code works correctly with the current database scheme). </li></ol><br><p>  If there are a large number of changes and roll-out ceases to meet these conditions, then it is divided into the necessary number of smaller roll-outs that meet these conditions, otherwise we have downtime. </p><br><p>  Direct vykatki order: </p><br><ol><li>  flooded migration; </li><li>  removed one machine from the balancer, updated the machine and restarted, returned the machine to the balancer; </li><li>  repeated the previous step before updating all the machines. </li></ol><br><p>  Reverse rollout order is relevant for deleting tables and columns in a table, when we automatically create migrations using a modified scheme and validate the presence of all migrations to CI: </p><br><ol><li>  removed one machine from the balancer, updated the machine and restarted, returned the machine to the balancer; </li><li>  repeated the previous step before updating all the machines; </li><li>  flooded migration. </li></ol><br><h1 id="teoriya">  Theory </h1><br><p>  Postgres is an excellent database, we can write an application that in hundreds and thousands of threads will write and read the same data, and with a high probability to be sure that our data will remain valid and will not be damaged, in general, full ACID.  Postgres implements several mechanisms to achieve this, one of which is locking. </p><br><p>  In postgres there are several types of locks, more details can be found <a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">here</a> , in the framework of the topic, I will only touch on blocking at the table and record level. </p><br><h2 id="blokirovki-na-urovne-tablicy">  Table level locks </h2><br><p>  At the table level, postgres has <a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">several types of locks</a> , the main feature is that they have conflicts, that is, two operations with conflicting locks cannot be performed simultaneously: </p><br><table><thead><tr><th></th><th><code>ACCESS SHARE</code> </th> <th> <code>ROW SHARE</code> </th> <th> <code>ROW EXCLUSIVE</code> </th> <th> <code>SHARE UPDATE EXCLUSIVE</code> </th> <th> <code>SHARE</code> </th> <th> <code>SHARE ROW EXCLUSIVE</code> </th> <th> <code>EXCLUSIVE</code> </th> <th> <code>ACCESS EXCLUSIVE</code> </th> </tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>ROW SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE ROW EXCLUSIVE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>EXCLUSIVE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  For example, <code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code> and <code>SELECT COUNT(*) FROM tablename</code> must be strictly executed one by one, otherwise we cannot find out which columns to return to <code>COUNT(*)</code> . </p><br><p>  The django migrations (full list below) contains the following operations and the corresponding locks: </p><br><table><thead><tr><th>  blocking </th><th>  operations </th></tr></thead><tbody><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> , <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>SHARE</code> </td> <td> <code>CREATE INDEX</code> </td> </tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td>  <code>CREATE INDEX CONCURRENTLY</code> , <code>DROP INDEX CONCURRENTLY</code> , <code>ALTER TABLE VALIDATE CONSTRAINT</code> </td></tr></tbody></table><br><p>  Of the notes, not all <code>ALTER TABLE</code> have <code>ACCESS EXCLUSIVE</code> locking, also in django migrations there are no <code>CREATE INDEX CONCURRENTLY</code> and <code>ALTER TABLE VALIDATE CONSTRAINT</code> , but they will be needed for a safer alternative to standard operations a bit later. </p><br><p>  If the migrations are performed in one stream sequentially, then everything looks good, since the migration will not conflict with another migration, but our business logic will work just during the migration and conflict. </p><br><table><thead><tr><th>  blocking </th><th>  operations </th><th>  conflicts with locks </th><th>  conflicts with operations </th></tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td> <code>SELECT</code> </td> <td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW SHARE</code> </td> <td> <code>SELECT FOR UPDATE</code> </td> <td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td>  <code>INSERT</code> , <code>UPDATE</code> , <code>DELETE</code> </td><td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> , <code>SHARE ROW EXCLUSIVE</code> , <code>SHARE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> , <code>CREATE INDEX</code> </td></tr></tbody></table><br><p>  Here you can summarize two points: </p><br><ol><li>  if there is an alternative with a lighter lock, you can use it like <code>CREATE INDEX</code> and <code>CREATE INDEX CONCURRENTLY</code> . </li><li>  most migrations of data schema changes conflict with business logic, and conflict with <code>ACCESS EXCLUSIVE</code> , that is, we cannot even make a <code>SELECT</code> while holding this lock and potentially downtime here, except if this operation does not work out instantly and our downtime is a couple of seconds. </li></ol><br><p>  There must be a choice, or we always avoid <code>ACCESS EXCLUSIVE</code> , that is, we create new labels and copy data there ‚Äî reliably, but for a long time for a large amount of data, or we make <code>ACCESS EXCLUSIVE</code> as fast as possible and make additional warnings against downtime ‚Äî potentially dangerous, but quickly. </p><br><h2 id="blokirovki-na-urovne-zapisi">  Write level locks </h2><br><p>  The record level also has its own locks <a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a> , they also conflict with each other, but only affect our business logic: </p><br><table><thead><tr><th></th><th> <code>FOR KEY SHARE</code> </th> <th> <code>FOR SHARE</code> </th> <th> <code>FOR NO KEY UPDATE</code> </th> <th> <code>FOR UPDATE</code> </th> </tr></thead><tbody><tr><td> <code>FOR KEY SHARE</code> </td> <td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>FOR SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR NO KEY UPDATE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR UPDATE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  Here is the main point in data migrations, that is, if we make <code>UPDATE</code> on the entire table data migration, then the rest of the business logic that updates the data will wait for the lock to be released and may exceed our downtime threshold, so it is better to do updates for data migrations.  It is also worth noting that when using more complex sql queries for data migrations, splitting into parts can work faster, as it can use a more optimal plan and indexes. </p><br><h2 id="ocheryodnost-vypolneniya-operaciy">  The sequence of operations </h2><br><p>  Another important knowledge is how operations will be performed, when and how they take and release locks: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/8f9/adb/8898f9adbf4eab0350517d07177b7257.png" alt="image"></p><br><p>  Here you can highlight the following items: </p><br><ol><li>  operation time - for migration, this is the lock hold time, if a heavy lock is held for a long time - we will have downtime, for example, this can be with <code>CREATE INDEX</code> or <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> (in postgres 11 this is better). </li><li>  waiting time for conflicting locks - that is, migration waits for all conflicting requests to work, but at this time new requests will wait for our migration, slow requests can be very dangerous either as simple as not optimal or analytical, so slow requests should not be migration. </li><li>  number of requests per second - if we have a lot of requests for a long time, then free connections can quickly end and instead of one problematic place, the entire database can go to downtime (only the connection limit for the superuser will remain), here you need to avoid slow requests, reduce the number of requests , for example, to start migrations during the minimum load, to separate critical components into different services with their bases. </li><li>  many migrations in one transaction - the more transactions in one transaction, the longer a heavy lock is held, so it is better to separate heavy operations, no <code>ALTER TABLE VALIDATE CONSTRAINT</code> or data migrations in a single transaction with a heavy lock. </li></ol><br><h2 id="taymauty">  Timeouts </h2><br><p>  <code>lock_timeout</code> has settings such as <code>lock_timeout</code> and <code>statement_timeout</code> , which can secure the launch of migrations, both from poorly written migration and bad conditions in which the migration can be started.  Can be installed both globally and for the current connection. </p><br><p>  <code>SET lock_timeout TO '2s'</code> allows you to avoid downtime when waiting for slow requests / transactions before migration: <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a> . </p><br><p>  <code>SET statement_timeout TO '2s'</code> allows you to avoid downtime when you start a heavy migration with heavy locking: <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a> . </p><br><h2 id="dedloki">  Deadlocks </h2><br><p>  Deadlocks in migrations are not about downtime, but pleasantly enough, when the migration is written, it works fine on a test environment, but catches deadlock when you roll on a prod.  The main sources of problems can be a large number of operations in one transaction and Foreign Key, since it creates locks in both tables, so it is better to separate the operations of migrations, the more atomic - the better. </p><br><h2 id="hranenie-zapisey">  Keeping records </h2><br><p>  Postgres <a href="https://www.postgresql.org/docs/current/static/storage-toast.html">stores different types of values ‚Äã‚Äãin different ways</a> : if the types are stored differently, then converting between them will require a complete rewriting of all the values, fortunately, some types are stored the same way and do not require rewriting when changing.  For example, lines are stored equally regardless of the size and the reduction / increase in the dimension of the line does not require rewriting, but the reduction requires checking that all the lines do not exceed the smaller size.  Other types can also be stored in a similar manner and have similar features. </p><br><h2 id="multiversion-concurrency-control-mvcc">  Multiversion Concurrency Control (MVCC) </h2><br><p>  According to the <a href="https://www.postgresql.org/docs/current/static/mvcc-intro.html">documentation</a> , the consistency in postgres is based on the multiversion of data, that is, each transaction and operation sees its version of the data.  This feature does a great job with competitive access, and also has an interesting effect when changing a schema like adding and deleting columns only changes the schema, if there are no additional operations to change data, indexes or constraints, after which low-level insert and update operations will create records with all necessary values, the deletion will mark the corresponding record as deleted.  VACUUM or AUTO VACUUM is responsible for cleaning up the remaining debris. </p><br><h1 id="primer-django">  Django example </h1><br><p>  We now have an idea of ‚Äã‚Äãwhat downtime can depend on and how it can be avoided, but before you apply the knowledge you can see what django gives out of the box ( <a href="https://github.com/django/django/blob/2.1.2/django/db/backends/base/schema.py">https://github.com/django/django/blob/2.1.2/django /db/backends/base/schema.py</a> and <a href="https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py">https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py</a> ): </p><br><table><thead><tr><th></th><th>  operation </th></tr></thead><tbody><tr><td>  one </td><td> <code>CREATE SEQUENCE</code> </td> </tr><tr><td>  2 </td><td> <code>DROP SEQUENCE</code> </td> </tr><tr><td>  3 </td><td> <code>CREATE TABLE</code> </td> </tr><tr><td>  four </td><td> <code>DROP TABLE</code> </td> </tr><tr><td>  five </td><td> <code>ALTER TABLE RENAME TO</code> </td> </tr><tr><td>  6 </td><td> <code>ALTER TABLE SET TABLESPACE</code> </td> </tr><tr><td>  7 </td><td> <code>ALTER TABLE ADD COLUMN [SET DEFAULT] [SET NOT NULL] [PRIMARY KEY] [UNIQUE]</code> </td> </tr><tr><td>  eight </td><td> <code>ALTER TABLE ALTER COLUMN [TYPE] [SET NOT NULL|DROP NOT NULL] [SET DEFAULT|DROP DEFAULT]</code> </td> </tr><tr><td>  9 </td><td> <code>ALTER TABLE DROP COLUMN</code> </td> </tr><tr><td>  ten </td><td> <code>ALTER TABLE RENAME COLUMN</code> </td> </tr><tr><td>  eleven </td><td> <code>ALTER TABLE ADD CONSTRAINT CHECK</code> </td> </tr><tr><td>  12 </td><td> <code>ALTER TABLE DROP CONSTRAINT CHECK</code> </td> </tr><tr><td>  13 </td><td> <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  14 </td><td> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  15 </td><td> <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  sixteen </td><td> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  17 </td><td> <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  18 </td><td> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  nineteen </td><td> <code>CREATE INDEX</code> </td> </tr><tr><td>  20 </td><td> <code>DROP INDEX</code> </td> </tr></tbody></table><br><p>  My needs for django migrations are very good, now we can discuss with our knowledge safe and dangerous operations for migrations without downtime. </p><br><p>  We will call safe migrations with <code>SHARE UPDATE EXCLUSIVE</code> lock or <code>ACCESS EXCLUSIVE</code> , which works out instantly. <br>  Dangerous call migration with <code>SHARE</code> and <code>ACCESS EXCLUSIVE</code> locks that take considerable time. </p><br><p>  I will leave in advance a useful <a href="https://www.postgresql.org/docs/current/static/sql-altertable.html">link to the documentation</a> with great examples. </p><br><h2 id="sozdanie-i-udalenie-tablicy">  Creating and deleting a table </h2><br><p>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> can be called safe, because the business logic either still or does not work with the table being migrated, the behavior of deleting the table with FOREIGN KEY will be a little later. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochih-tablicah">  Heavily supported operations on worksheets </h2><br><p>  <code>ALTER TABLE RENAME TO</code> - I can not call it safe, because it is hard to write logic that works with such a table before and after migration. </p><br><p>  <code>ALTER TABLE SET TABLESPACE</code> is unsafe, since it physically moves the tablet, and this can be long on a large volume. </p><br><p>  On the other hand, these operations are rather rare, as an alternative you can suggest creating a new table and copying data into it. </p><br><h2 id="sozdanie-i-udalenie-kolonki">  Creating and deleting a column </h2><br><p>  <code>ALTER TABLE ADD COLUMN</code> , <code>ALTER TABLE DROP COLUMN</code> - can be called safe (creating it without DEFAULT / NOT NULL / PRIMARY KEY / UNIQUE), because the business logic either does not work or does not work with the column being migrated, the behavior of deleting a column with FOREIGN KEY, other constructs and indexes will be later. </p><br><p>  <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> , <code>ALTER TABLE ADD COLUMN SET NOT NULL</code> , <code>ALTER TABLE ADD COLUMN PRIMARY KEY</code> , <code>ALTER TABLE ADD COLUMN UNIQUE</code> - unsafe operations, because they add a column and, without releasing the lock, update the data by defaulting or creating a set of patterns. nullable columns and further change. </p><br><p>  It is worth mentioning the faster <code>SET DEFAULT</code> in postgres 11, it can be considered as safe, but it does not become very useful in django, because django uses <code>SET DEFAULT</code> only to fill the column and then does <code>DROP DEFAULT</code> , and in the interval between migration and updating machines business logic, records can be created for which default will be absent, that is, then still do the data migration. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochey-tablice">  Heavily supported operations on a worksheet </h2><br><p>  <code>ALTER TABLE RENAME COLUMN</code> - I also cannot call it safe, since it is hard to write logic that works with such a column before and after migration.  Rather, this operation will also not be frequent, as an alternative can be offered to create a new column and copy data into it. </p><br><h2 id="izmenenie-kolonki">  Column change </h2><br><p>  <code>ALTER TABLE ALTER COLUMN TYPE</code> - the operation can be both dangerous and safe.  Safe if postgres only changes the schema, and the data is already stored in the correct format and no additional type checks are needed, for example: </p><br><ul><li>  type change from <code>varchar(LESS)</code> to <code>varchar(MORE)</code> ; </li><li>  type change from <code>varchar(ANY)</code> to <code>text</code> ; </li><li>  change type from <code>numeric(LESS, SAME)</code> to <code>numeric(MORE, SAME)</code> . </li></ul><br><p>  <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> is dangerous, as it passes through the data inside and checks for NULL, fortunately this constructor can be replaced with another <code>CHECK IS NOT NULL</code> .  It is worth noting that this replacement will lead to a different scheme, but with identical properties. </p><br><p>  <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code> , <code>ALTER TABLE ALTER COLUMN SET DEFAULT</code> , <code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code> - safe operations. </p><br><h2 id="sozdanie-i-udalenie-indeksov-i-konstreyntov">  Creating and deleting indexes and constructs </h2><br><p>  <code>ALTER TABLE ADD CONSTRAINT CHECK</code> and <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> are unsafe operations, but they can be declared as <code>NOT VALID</code> and then made <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> and <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> unsafe, because inside they create a unique index, but you can create a unique index like <code>CONCURRENTLY</code> , then create the corresponding count using the ready-made index via <code>USING INDEX</code> . </p><br><p>  <code>CREATE INDEX</code> is an insecure operation, but the index can be created as <code>CONCURRENTLY</code> . </p><br><p>  <code>ALTER TABLE DROP CONSTRAINT CHECK</code> , <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> , <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> , <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> , <code>DROP INDEX</code> - safe operations. </p><br><p>  It is worth noting that <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> and <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> make locking of two tables at once. </p><br><h2 id="primenyaem-znaniya-v-django">  We apply knowledge in django </h2><br><p>  Django has an operation in migrations to execute any SQL: <a href="https://docs.djangoproject.com/en/2.1/ref/migration-operations/">https://docs.djangoproject.com/en/2.1/ref/migration-operations/#django.db.migrations.operations.RunSQL</a> .  Through it, you can set the necessary timeouts and apply alternative operations for migrations, with indication of <code>state_operations</code> - the migration that we are replacing. </p><br><p>  This works well for your code, although it requires additional scribbling, but you can leave the dirty work on db backend, for example, <a href="https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema.py">https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema .py</a> collect the described practices and replace unsafe operations with safe counterparts, and this will work for third-party libraries. </p><br><h1 id="naposledok">  At last </h1><br><p>  These practices allowed me to get an identical scheme created by django out of the box, with the exception of replacing the <code>CHECK IS NOT NULL</code> constructor instead of <code>NOT NULL</code> and the names of some constructs (for example, for <code>ALTER TABLE ADD COLUMN UNIQUE</code> and the alternative).  Another compromise may be the lack of transactionality for alternative migration operations, especially where <code>CREATE INDEX CONCURRENTLY</code> and <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  If you do not go beyond postgres, then there are many options for changing the data scheme, and they can be combined in various ways for specific conditions: </p><br><ul><li>  use jsonb as schamaless solution </li><li>  the opportunity to go to downtime </li><li>  requirement to do migration without downtime </li></ul><br><p>  In any case, I hope that the material was useful either to increase uptime or to expand consciousness. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425063/">https://habr.com/ru/post/425063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425053/index.html">SSR: when, why and for what. On the example of Vue</a></li>
<li><a href="../425055/index.html">Oculus quest</a></li>
<li><a href="../425057/index.html">Preferential education loan for all GeekUniversity programs from GeekBrains and Alfa-Bank</a></li>
<li><a href="../425059/index.html">Hackathon number 1 in Tinkoff.ru</a></li>
<li><a href="../425061/index.html">CodeRainbow: interactive study and documenting code</a></li>
<li><a href="../425069/index.html">Testing presenter using PromiseKit</a></li>
<li><a href="../425071/index.html">How to protect against stack overflow (on Cortex M)?</a></li>
<li><a href="../425073/index.html">Easy creation of a git repository on OneDrive</a></li>
<li><a href="../425075/index.html">Machine vision: installing, configuring and using Google Cloud Vision in PHP</a></li>
<li><a href="../425077/index.html">Kotlin under the hood - look decompiled bytecode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>