<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Yandex created augmented reality in Maps for iOS. Experience using ARKit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fewer people remain who can be surprised by augmented reality (AR). For some, this technology is associated with a toy for a couple of hours. Others f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Yandex created augmented reality in Maps for iOS. Experience using ARKit</h1><div class="post__text post__text-html js-mediator-article"><p>  Fewer people remain who can be surprised by augmented reality (AR).  For some, this technology is associated with a toy for a couple of hours.  Others find it more practical application. </p><br><p>  My name is Dmitry, and I am developing Yandex.Maps for iOS.  Today I will tell Habr's readers how we created routing using augmented reality.  You will also learn about the features of the use of the ARKit framework, thanks to which the introduction of augmented reality has ceased to be the work of only specialists in the field of computer vision. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  In 2009, Esquire magazine was the first among the media publications to add support for augmented reality to its product.  On the cover of the magazine posted a code with which you can see Robert Downey Jr. "live". </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  The use of AR in the field of entertainment is not limited.  A striking example was the game Pokemon Go, released in 2016.  Already by July of the same year it was downloaded over 16 million times.  The success of the game led to the emergence of numerous clones with AR. </p><br><p>  Significant events in the AR industry in recent years can be considered the announcements of Google Glass and Microsoft Hololens.  The appearance of this kind of device shows the vector in which large companies are moving. </p><br><p>  Not an exception, and Apple.  In 2017, the company introduced the ARKit framework, the importance of which for the industry can not be overestimated.  And we will tell about it in more detail. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Features ARKit, thanks to which it became easy to use AR: </p><br><ul><li>  no need for special labels (markers), </li><li>  integration with existing frameworks for 2D / 3D graphics from Apple - SceneKit, SpriteKit, Metal, </li><li>  high accuracy of determining the position and orientation of the device in space, </li><li>  no need to calibrate the camera or sensors. </li></ul><br><p>  Under the hood of ARKit is a system of visual inertial odometry, which combines data from the visual (camera) and inertial (accelerometer, gyroscope) subsystems of the device for determining position and displacement on the stage.  The connecting element of this system is the Kalman filter - an algorithm that at each moment of time selects the best of the testimony of two subsystems and provides it to us in the form of our position and orientation on the stage.  ARKit also has an ‚Äúunderstanding‚Äù of the scene - we can define horizontal and vertical surfaces, as well as the conditions for the illumination of the scene.  Thus, when adding an object to the scene, we can add a default lighting to it, thanks to which the object will look more realistic. </p><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text"><p>  Soon, version 2.0 of the framework will be released, in which new features will be added and positioning accuracy will be significantly improved. </p></div></div><br><p>  ARKit allowed developers to embed augmented reality of high quality into their applications, while spending much less effort.  Let us demonstrate this using the example of Yandex.Maps. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Routing with AR in Yandex.Maps </h2><br><p>  Usually, after the announcement of the new version of iOS, many teams in Yandex gather to discuss the possibility of introducing new features into their applications.  The Yandex.Maps team did the same.  Within a month after the announcement of ARKit, we often discussed ways to incorporate it into Maps.  How many ideas we have not heard enough from each other!  Pretty quickly we came to the conclusion that one of the most useful and lying solutions is the use of augmented reality in routing. </p><br><p>  The choice of this idea was due to the fact that many card users often encounter a situation where you find yourself in unfamiliar terrain and need to quickly decide where to go.  The standard approach for the average card user is to open the application, build a walking route, and, turning on the spot, determine where to go.  The idea of ‚Äã‚Äãintroducing augmented reality into pedestrian routing is to save the user from unnecessary actions by immediately showing where to go right over the image from the camera. </p><br><p>  First I want to say a few words about routing.  What do I put into this concept?  From the point of view of implementation in a mobile application, this is a fairly standard set of steps that allow the user to get from point A to point B: </p><br><ul><li>  selection of points of departure and arrival, </li><li>  getting the route as a set of points in geographic (latitude, longitude) coordinates, </li><li>  display on the map of the route line, </li><li>  accompanying the user with additional information while driving along the route. </li></ul><br><p>  We will not dwell on the first two points.  I can only say that we get the route through our cross-platform Yandex.Mapkit library, which is also available to you as a pod.  What makes augmented reality routing different from standard routing in maps?  First of all, the main difference is the almost completely hidden card.  The main focus is on the area of ‚Äã‚Äãthe screen with the image of the video stream from the camera, on which additional visual elements are superimposed (finish mark, auxiliary mark and image of the route line).  Each of these visual elements has its own meaning and its own logic (when and how it should be displayed).  We will consider the role of each of these elements in more detail later, but for now I propose to consider the tasks that we faced initially: </p><br><ul><li>  learn how to position objects on the ARKit scene, knowing their geographic coordinates, </li><li>  learn how to draw the necessary UI on the 3D scene with sufficient performance. </li></ul><br><p>  We needed to convert the coordinates of points from geographic to coordinates on the stage, choose which of the points to display, and display the entire UI over the camera image in the correct position.  But everything turned out to be a little more complicated than it seemed at first glance. </p><br><p>  Before proceeding to the implementation of the feature itself, one of my colleagues was given the task of creating a prototype, showing the possibility (or impossibility) of implementing such functionality with an accessible set of tools.  For two weeks, we watched San Sanych plowing the open space and the surrounding area of ‚Äã‚Äãour office with a phone in hand and viewing the world through the lens of the camera.  As a result, we got a working prototype, which showed each point of the route as a tag on the stage with a distance to it.  With the help of this prototype, it was possible, under successful circumstances, to walk from work to the subway and almost never get lost.  But seriously, he confirmed the possibility of implementing the conceived functionality.  But there remained a number of tasks that our team still had to solve. </p><br><p>  It all started with the study of tools.  At that time, only one person in the team had experience in working with 3D graphics.  Let's take a quick look at the tools that anyone who has to think about the implementation of such ideas with the help of ARKit will have to face. </p><br><h2 id="instrumenty-i-api">  Tools and APIs </h2><br><p>  The main job of object rendering is the creation and management of scene objects of the SceneKit framework.  With the advent of ARKit, the ARSCNView class became available (the successor of the SCNView class is the base class for working with the scene in SceneKit), which solves most of the laborious tasks of integrating ARKit and SceneKit, namely: </p><br><ul><li>  synchronization of the position of the phone in space with the position of the camera on the scene, </li><li>  the scene coordinate system is the same as the ARKit coordinate system, </li><li> The video stream from the camera of the device is used as the background of the scene. </li></ul><br><p>  The ARSCNView object also provides the developer with an augmented reality session object that can be launched with the necessary configuration, stopped, or subscribe to its various events using the delegate object. </p><br><p>  To add objects to the scene, use heirs or directly SCNNode objects.  This class represents a position (three-dimensional vector) in the coordinate system of its parent object.  Thus, we get a tree of objects on the scene with a root in a special object - the rootNode of our scene.  Here, everything is very similar to the hierarchy of UIView objects in UIKit.  SCNNode objects can be displayed on the scene when they add material and lighting. </p><br><p>  In order to add augmented reality to a mobile application, you also need to know about the main objects of the ARKit API.  The main one is the object of an augmented reality session - ARSession.  This object performs data processing and is responsible for the life cycle of an augmented reality session.  The purpose of this article is not to retell the ARKit and SceneKit documentation, so I will not write about all the available configuration options for an augmented reality session, but I‚Äôll dwell on one of the most important for navigation applications, the configuration option for an augmented reality session - worldAlignment.  This parameter determines the direction of the coordinates of the scene axes at the time of session initialization.  In general, when initializing an augmented reality session, ARKit creates a coordinate system with the origin at the point that coincides with the current position of the phone in space, and directs the axes of this system depending on the value of the woldAlignment property.  In our implementation, the gravityAndHeading value is used, which means that the axes will be directed as follows: the Y axis in the opposite direction of gravity, the Z axis to the south, and the X axis to the east. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="world-alignment-gravity-and-heading"></p><br><p>  With good luck, the X / Z axis will indeed be aligned with the directions to the South / East, but due to errors in the compass readings, the axes may be directed at some angle to the direction described in the documentation.  This is one of the problems that we had to fight, but more on that later. </p><br><p>  Now that we have reviewed the main tools, let's summarize: route mapping using SceneKit is adding SCNNode objects to the scene at positions obtained by converting from geographic coordinates to scene coordinates.  Before we talk about coordinate conversion and generally about placing objects on the scene, let's talk about the problems of drawing UI elements, assuming that we know the positions of objects on the scene. </p><br><h1 id="metka-finisha">  Finish line </h1><br><p>  The main visual element of pedestrian routing with augmented reality is the finish mark, representing the end point of the route.  Also above the label, we show the user the distance to the end point of the route. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="finish-placemark-overview"></p><br><h2 id="razmer">  The size </h2><br><p>  When we were first shown the design of this tag, we first paid attention to the requirements for the size of this tag.  They did not obey the rules of perspective projection.  Let me explain that in three-dimensional engines that are used to create, for example, computer games, the ‚Äúlook‚Äù is modeled using a perspective projection.  According to the rules of perspective projection, distant objects are depicted on a smaller scale, and parallel lines in the general case are not parallel.  Thus, the size of the projection of an object onto the screen plane changes linearly (decreases) as the camera moves away from the object on the stage.  It followed from the description of the layouts that the size of the mark on the screen has a fixed (maximum) size when removed less than 50 m, then decreases linearly from 50 m to 2 km, after which the same minimum size remains.  Such requirements are obviously due to user convenience.  They allow the user to never lose the end point of the route from view, so the user will always have an idea of ‚Äã‚Äãwhere to go. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="finish-placemark-size-demands"></p><br><p>  We had to understand how you can break into the mechanism of projection SceneKit working according to certain rules.  I just want to note that we had about two weeks for everything, and therefore there was simply no time to carry out an in-depth analysis of various approaches to solving the set tasks.  Now, analyzing our decisions, it is much easier to evaluate them, and it can be concluded that the majority of decisions made were right.  The size requirement, in fact, was the first stumbling block.  All the problems outlined below can be solved with both SceneKit and UIKit.  I tried to describe in detail the ways to solve each of the problems using both approaches.  Which approach to use is up to you. </p><br><p>  Let's imagine that we decided to implement a finish mark using SceneKit.  If we consider that the label on the layouts should look like a circle on the screen, it becomes obvious that in SceneKit the label object must be a sphere (since the projection of the sphere on any plane is a circle).  In order for the projection to have a certain radius on the screen, specified in the requirements of the designers, it is necessary to know the radius of the sphere at each moment of time.  Thus, placing the sphere of a certain radius on the scene at a certain point and constantly updating its radius when approaching or moving away we will get a projection on the screen of the required size at each moment of time.  The algorithm for determining the radius of a sphere at an arbitrary point in time is as follows: </p><br><ol><li>  determine the position of the object on the scene - the center of the sphere, </li><li>  find the projection of this point on the screen plane (using the SceneKit API), </li><li>  to determine the required size of the label on the screen, we find the distance from the camera to the center of the sphere on the stage, </li><li>  determine the required size on the screen according to the distance to the object, using the rules described in the design, </li><li>  knowing the size of the label on the screen (the diameter of the circle), choose any point on this circle, </li><li>  make a reverse projection (unprojectPoint) of the selected point, </li><li>  find the length of the vector from the obtained point on the stage to the center of the sphere. </li></ol><br><p>  The resulting value of the length of the vector will be the desired radius of the sphere. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="finish-placemark-size-solution-scenekit"></p><br><p>  At the time of implementation, we were unable to find a way to determine the size of the object on the stage, and we decided to draw the finish mark using UIKit.  The algorithm in this case repeats steps 1-5, after which a circle of the required size is drawn on the screen with its center at the point obtained in step 2 by means of UIKit.  An example of the implementation of the label using UIKit can be found <a href="https://github.com/trimonovds/mobius-samples/blob/82a987ebdc6bc35e949cb6d10f2714d1d0dc90d2/PedestrianARNavigation/PedestrianARNavigation/ViewController.swift">here</a> . </p><br><div class="spoiler">  <b class="spoiler_title">A few words about the code</b> <div class="spoiler_text"><p>  At the end of the article, I gave several references to useful and simply interesting materials, including samples, in which you can look at the real code in detail, solve the problems presented in the article and implement the algorithms.  The main interest in my opinion is the <a href="https://github.com/trimonovds/mobius-samples/tree/master/PedestrianARNavigation">prototype pedestrian routing</a> , which brings together all the functionality, except for the mechanism for adjusting the axles, which is described in detail below. </p><br><p>  The code above does not claim to be optimal, complete and production quality =) </p></div></div><br><p>  The difference in the use of SceneKit and UIKit in this case lies in the fact that when implemented on SceneKit, the SCNNode object for the end point of the route (finish mark) will be created with the material and geometry, since it must be visible, while using UIKit we will need the node object only to search for a projection on the screen plane (to determine the center of the mark on the screen).  Geometry and material in this case do not need to be added.  Note that the distance from the camera to the SCNNode object of the end point of the route can be found in two ways - using the geographical coordinates of the points, or as the length of the vector between points on the scene.  This is possible due to the fact that the camera object is a property of SCNNode.  To get a camera node, you need to refer to the sceneOfView property of our scene. </p><br><p>  We learned how to determine the radius of a finish label node at an arbitrary point in time when implemented on a SceneKit and the position of the finish mark view in the case of a UIKit implementation.  It remains to understand when it is necessary to update these values?  This is the method of the object SCNSceneRendererDelegate: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  This method is called after each rendered frame of the scene.  By updating the property values ‚Äã‚Äãin the body of this method, we get the correctly displayed finish mark. </p><br><h2 id="animaciya">  Animation </h2><br><p>  After the finish mark appeared in dev, we started to add a ripple animation to this mark.  I think for most iOS developers, creating animations is not a big deal.  But while thinking about the method of implementation, we are faced with the problem of constantly updating the frame of our view.  Note that in most cases, animations are added to static UIView objects.  A similar problem - a constant update of the radius of a node's geometry also occurs when implemented with SceneKit.  The fact is that the pulsating animation is reduced to the animation of the size of the circle (for UIKit) and the radius of the sphere (for SceneKit).  Yes, we know that in UIKit such an animation can be done using CALayer, but for the sake of simplicity of the narration I decided to consider this question symmetrically for two frameworks.  Consider the implementation on UIKit.  If you add a code that animates the same frame to an existing code that updates the frame of the view, the animation will be lost by explicitly setting the frame.  Therefore, as a solution to this problem, we decided to use the animation property transform.scale.xy of the UIView object.  When implemented using SceneKit, you will have to add an animation of the scale property for the SCNNode object.  The nice thing about using SceneKit in this case is the fact that it fully supports CoreAnimation, so learning a new API is not necessary.  The code that implements an animation similar to an animation of a label in Yandex.Maps looks like this: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Billboard </h2><br><p>  At the beginning of the article I mentioned about the billboard with the distance to the end point of the route, which, in fact, is a label with text, located always above the finish line.  By tradition, I will identify the problems inherent in the implementations on UIKit and SceneKit, talking about possible solutions for each of the frameworks. </p><br><p>  Let's start with UIKit.  In this case, the billboard is a regular UILabel, which constantly updates text showing the distance to the end point of the route.  Let's look at the problem we are facing. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="finish-placemark-billboard-problem-uikit"></p><br><p>  If you set a label for a frame and then turn the phone, we will see that the frame will not change (it would be strange if this were not the case).  At the same time, we would like the label to remain parallel to the ground plane. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="finish-placemark-billboard-desired-uikit"></p><br><p>  I think everyone understands that when you change the orientation of the device, we need to turn the label, but at what angle?  If you turn on the imagination and mentally imagine all the axes of the coordinate systems and vectors involved in this process, you can come to the conclusion that the rotation angle is equal to the angle between the x axis of the UIKit coordinate system and the projection of the X axis of the SceneKit coordinate system onto the screen plane. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="finish-placemark-billboard-solution-uikit"></p><br><p>  A simple task that once again proved the benefits of a school geometry course. </p><br><p>  When implementing a finish mark using SceneKit, you will most likely have to render a billboard with a distance using SceneKit means, and this means that you will definitely have a task to force the SCNNode object to always be camera-oriented.  I think the problem will become clearer if you look at the picture: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="finish-placemark-billboard-problem-scenekit"></p><br><p>  This task is solved by using the SCNBillboardConstraint API.  Adding a constraint with a free Y axis to the collection of our node's constraints, we get a node that rotates around the Y axis of its coordinate system so that it is always oriented towards the camera.  The sole task of the developer is to place this node at the correct height so that the billboard with the distance is always visible to the user. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Secondary label </h1><br><p>  One of the main features of pedestrian routing with augmented reality, we inside the team, consider the auxiliary tag - a special visual element that appears on the screen at the moment when the end point of the route leaves the zone of visibility and shows the user where to turn the phone so that the mark appears on the screen finish line </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="finish-placemark-hint-overview"></p><br><p>  I'm sure many of the readers have encountered similar functionality in some games, most often - shooters.  What was the surprise of our team when we saw this UI element in the layouts.  At once I will say that the correct implementation of such a feature may require you more than one hour of experiments, but the end result is worth the time spent.  We began by defining requirements, namely: </p><br><ul><li>  With any orientation of the device, the label moves along the edges of the screen, </li><li>  if the user has turned 180 degrees to the end point of the route, the label is displayed at the bottom of the screen, </li><li>  at each moment of time, turning towards the mark should be the shortest turn to the end point of the route. </li></ul><br><p>  After describing the requirements, we started to implement.  Almost immediately, we came to the conclusion that rendering would be done using UIKit.  The main problem with the implementation was the definition of the center of this label at each point in time.  After reviewing the finish mark, such a task should not cause difficulties, so I will not dwell on its solution in detail.  In the article I will give only a description of the algorithm for selecting the center of the auxiliary label, and the source code can be found <a href="https://github.com/trimonovds/mobius-samples/blob/master/FinishPlacemarkHint/FinishPlacemarkHelper/ViewController.swift">here</a> . </p><br><p>  Algorithm for finding the center of the auxiliary tag: </p><br><ol><li>  create an SCNNode object for the end point of the route with a position on the scene obtained from the geographic coordinate of the point, </li><li>  find the projection of the point on the screen plane, </li><li>  find the intersection of the segment from the center of the screen to the point of the found projection with segments of the screen borders in the coordinate system of the screen. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="finish-placemark-hint-solution"></p><br><p>  The found intersection point is the desired center of the auxiliary label.  By analogy with the code that updates the parameters of the finish label, we placed the code that draws the auxiliary label in the delegate method already mentioned above. </p><br><h1 id="poliliniya-marshruta">  Route polyline </h1><br><p>  By constructing a route and seeing the finish mark on the screen, the user can reach it only by looking at the mark, but the routing is called that which shows the route to the user.  We thought that it would be very strange to cut down the pedestrian routing functionality by excluding the route display from the AR version.  To visualize the route line, it was decided to display a set of arrows moving along it.  In this case, the designers were satisfied that the arrows would almost disappear at a distance (the size would be determined by the perspective projection rules), and it was decided to use SceneKit to implement it. </p><br><p>  Before proceeding to the description of the implementation, it is important to note that, by design, the arrows should be located at a distance of 3 m from each other.  If we estimate the number of objects (arrows) that must be rendered with a route of about 1 km in length, then it will be approximately 330 pieces.  At the same time, each object is added animation movement along its route.  Note that the arrows removed from the position of the camera on the scene at a distance of about 100-150 meters are almost invisible due to their small size.  Having considered these factors, it was decided not to display all the objects, but to display only those that are no more than 100 meters away from the user along the route line, periodically updating the displayed set of objects.  We display a sufficient amount of visual information, eliminating unnecessary SceneKit calculations and saving the user's battery. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="route-polyline-overview"></p><br><p>  Let's look at the main steps that we had to implement in order to get the final result: </p><br><ul><li>  selection of the route segment for which we will display primitives, </li><li>  creating 3D models </li><li>  create animation, </li><li>  update while driving on the route. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Select a site to display </h2><br><p>  As I noted above, we do not display arrows for the entire route, but choose the optimal area for display.  Selecting a site at an arbitrary point in time consists in finding the nearest route segment (the route is a sequence of segments / segments) to the current position of the user and selecting segments from the nearest route to the end point until their total length exceeds 100 meters. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="route-polyline-route-part-selection"></p><br><h2 id="sozdanie-3d-modeli">  Creating a 3D model </h2><br><p>  Let us consider in more detail the process of creating a 3D model.  In most cases, all you need to do to create a simple 3D model (like our arrow) is to open any 3D editor, spend some time learning it and make this model in it.  If the guys from your team have 3D modeling experience, or they have time to learn, for example, 3DMax (and it should be bought), then you are incredibly lucky.  Unfortunately, at the time of the implementation of this feature, none of us had any special experience, there was no free time for training, so we had to make a model, so to speak, with improvised means.  I mean the description of the model in the code.  It all started with the presentation of a 3D model in the form of triangles.  Then we had to manually find the coordinates of the vertices of these triangles in the coordinate system of the model, and then create an array of indices of the vertices of the triangles.  With this data at our disposal, we can create the necessary geometry directly in SceneKit.  You can create a model like ours, for example, like this: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNGeometry</span></span></span><span class="hljs-class"> { convenience init(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">material</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNMaterial</span></span></span><span class="hljs-class">) { let vertices: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3</span></span></span><span class="hljs-class">] = [ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.02, 0.00, 0.00), // 0 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.02, 0.50, -0.33), // 1 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.10, 0.44, -0.50), // 2 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.22, 0.00, -0.39), // 3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.10, -0.44, -0.50), // 4 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">(-0.02, -0.50, -0.33), // 5 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.02, 0.00, 0.00), // 6 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.02, 0.50, -0.33), // 7 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.10, 0.44, -0.50), // 8 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.22, 0.00, -0.39), // 9 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.10, -0.44, -0.50), // 10 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNVector3Make</span></span></span><span class="hljs-class">( 0.02, -0.50, -0.33), // 11 ] let sources: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNGeometrySource</span></span></span><span class="hljs-class">] = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNGeometrySource</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vertices</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vertices</span></span></span><span class="hljs-class">)] let indices: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int32</span></span></span><span class="hljs-class">] = [0,3,5, 3,4,5, 1,2,3, 0,1,3, 10,9,11, 6,11,9, 6,9,7, 9,8,7, 6,5,11, 6,0,5, 6,1,0, 6,7,1, 11,5,4, 11,4,10, 9,4,3, 9,10,4, 9,3,2, 9,2,8, 8,2,1, 8,1,7] let geometryElements = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNGeometryElement</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">indices</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">indices</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primitiveType</span></span></span><span class="hljs-class">: .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">triangles</span></span></span><span class="hljs-class">)] self.init(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sources</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sources</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geometryElements</span></span></span><span class="hljs-class">) self.materials = [material] } } static func arrowBlue() -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNGeometry</span></span></span><span class="hljs-class"> { let material = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SCNMaterial</span></span></span><span class="hljs-class">() material.diffuse.contents = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UIColor</span></span></span><span class="hljs-class">.blue material.lightingModel = .constant return </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ARSCNArrowGeometry</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">material</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">material</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  The final result looks like this: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="route-polyline-arrow-model"></p><br><h2 id="animaciya-linii-marshruta">  Route line animation </h2><br><p>  The next step on the way to displaying the animated line of the route was the stage of creating the animation itself.  But what is the way to implement the animation, which in its final form looks like the arrow starts its movement at the starting point of the selected section of the route and ‚Äúfloats‚Äù along the route to the end of this section? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  I will not describe all possible ways to create such an animation; instead, I‚Äôll dwell in more detail on the method we have chosen.  After the section of the route is selected, we divide it into sections of the same length - sections of the animation of one arrow.  Each such area is highlighted in its color and has a length equal to the distance between the arrows. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="route-polyline-route-part-partitioning"></p><br><p>  At the beginning of each section, we create an object SCNNode arrows, the animation of which consists in moving along its section. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="route-polyline-arrows-initial-position"></p><br><p>  As you can see, the animation section sometimes consists of one segment, sometimes two or more.  It all depends on the step (in our case, 3 meters) between the arrows and the coordinates of the points that make up the route. </p><br><p>  The arrow animation is a sequence of two steps: </p><br><ul><li>  appearance in the initial position with the initial angle of rotation, </li><li>  the sequence of displacements along the segments with turns at the junction points of segments </li></ul><br><p>  Schematically it looks like this: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="route-polyline-arrow-anitaion-steps"></p><br><p>  It was easiest for us to implement such animation using the SCNAction API, a declarative API that allows you to conveniently create sequential, group, and repetitive animations.  More details on the implementation can be <a href="https://github.com/trimonovds/mobius-samples/tree/master/RoutePolyline">here</a> .  Due to the fact that each arrow finishes its animation at the starting point of the next arrow‚Äôs section of the animation, an impression of continuous arrow movement along the entire selected route‚Äôs section appears. </p><br><p>  At this point, I propose to finish the consideration of various aspects of rendering and go to the main part - determining the positions of objects on the scene according to the geographical coordinates of the objects. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Determining the position of an object on the stage </h1><br><p>  Let's start a conversation about determining the position of an object on the scene with an examination of the coordinate systems, the conversion between which is necessary.  There are only 2 of them: </p><br><ul><li>  geodetic (or geographical for simplicity) coordinates - the position of objects (route points) in the real world, </li><li>  Cartesian coordinates - the position of objects on the scene (in ARKit).  Recall that the scene coordinate system coincides with the ARKit coordinate system (in the case of using ARSCNView). </li></ul><br><p>  Translation from one coordinate system to another and vice versa is possible due to the fact that coordinates in ARKit are measured in meters, and the offset between two geodetic coordinates can be translated with great precision into offset in meters along the X and Z axes of the ARKit coordinate system at small offsets.  Let me remind you that geodetic coordinates are points with a certain longitude and latitude. </p><br><p>  Let us recall such important concepts from the geography course as parallels and meridians, and their basic properties: </p><br><ul><li>  <strong>Parallel</strong> - line with the degree value of latitude.  The lengths of the various parallels are different. </li><li>  <strong>Meridian</strong> - a line with a degree value of longitude.  The lengths of all the meridians are the same. </li></ul><br><p>  Now let's see how you can calculate the offset in meters, between two geodetic coordinates with coordinates <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  and <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">  : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta lon \ times metersInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ times metersInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="metersInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {land} \ cos \ left (\ alpha \ right)} {360 ^ {¬∞}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="metersInLatDegree = \ frac {2 \ pi R_ \ text {land}} {360 ^ {¬∞}}"></p><br><div class="spoiler">  <b class="spoiler_title">Explanation</b> <div class="spoiler_text"><p>  Displacement in geodetic coordinates is linearly mapped into meters only at small displacements.  At large displacements, you must honestly take the integral. </p></div></div><br><p>  Now, when we are able to translate the offset from one coordinate system to another, we need to determine the point of origin - a point for which the geographical coordinate and coordinate in ARKit (coordinate on the stage) are known at the same time.  Having found such a point, we will be able to determine the coordinate of any object on the scene, knowing its geographic coordinate and using the above formulas. </p><br><p>  For clarity, consider an example: <br>  At the beginning of the session of augmented reality, we asked CoreLocation our geographic coordinate and received it instantly - <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ inline (lat_0, lon_0)">  .  Recalling the fact that the origin of the ARKit coordinate system is located at the start of the session at the point where the device is located, we obtained the starting point, since we know the geographical coordinate and coordinate on the stage <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ inline (x_0, y_0, z_0) = (0,0,0)">  .  Suppose we need to find a coordinate on the scene of an object with a geographic coordinate <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  .  To do this, we find the offset in meters between the geographic coordinate of the object and the geographic coordinate of our point of origin, and then add the found offset to the coordinate on the scene of the point of origin.  The resulting coordinate on the stage and will be the desired. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="coordinates-conversion-object-position-on-scene"></p><br><p>  I note that the position found in this way on the scene will correspond to the position of the object in the real world only if the X / Z axis of the coordinate system of the scene is aligned with the directions to the South / East.  The alignment of the axes, in theory, should be achieved by setting the worldAlignment flag to gravitiAndHeading.  But as I said at the beginning of the post, this is not always the case. </p><br><p>  Let us consider in more detail the method of determining the point of reference.  To do this, we introduce the concept of <strong>estimate</strong> - a set of geographic coordinates and coordinates on the stage. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="coordinates-conversion-estimate-definition"></p><br><p>  The above proposed method of determining the starting point may not always be used.  At the time of the start of the session of the augmented reality, the request for obtaining the user CLLocation may not be executed immediately, moreover, the accuracy of the received coordinate may have a large error.  It would be more correct to ask SceneKit for a position on the stage at the moment when we get the value from CoreLocation.  In this case, the components of the obtained estimeyta really received simultaneously, and we have the opportunity to use any of the estimeytov, as a starting point.  When working with ARKit, the error in bias accumulates over time, so Apple does not recommend using ARKit as a navigation tool. </p><br><p>  When we decided to implement pedestrian routing with augmented reality, we conducted a small study of existing solutions using ARKit for similar tasks, and came across the ARKit + CoreLocation framework.  The idea behind this framework was that, thanks to ARKit, we can more accurately determine the user's location than using only CoreLocation. </p><br><p>  ARKit + CoreLocation concept: </p><br><ul><li>  when receiving CLLocation from CLLocationManager <br><ul><li>  request position on stage using scene.pointOfView.worldPosition </li><li>  save this pair of coordinates (estimate) to the buffer </li></ul></li><li>  get exact location if necessary <br><ul><li>  we choose the best estimate </li><li>  calculate the offset between the current position on the stage and the position on the stage of the best estimeyta </li><li>  apply the found offset to the geographic coordinate of the best estimate </li></ul></li></ul><br><p>          ,   ,   CoreLocation,       . </p><br><p>   ,   ¬´ ¬ª.   ,      . </p><br><p>     (,    ): </p><br><ul><li>    (  horizontalAccuracy), </li><li>       , </li><li>        100    . </li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Why?</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit ‚Äì        ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\inline t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\inline (lat_1,lon_1)">      ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\inline (x_1,z_1)">  .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">      CLLocationManager ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\inline (x_2,z_2)">  respectively. </p><br><p>      ARKit ‚Äî <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\inline (\Delta x,\Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\inline t_2">  .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\inline (lat_2,lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\inline (lat_{2calc},lon_{2calc})">  .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="coordinates-conversion-correction-angle-problem"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\inline initialBearing(1,2)">  and <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\inline initialBearing(1,2_{calc})">  where <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\inline 2_{calc}"> ‚Äì    2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\inline initialBearing(a,b)">   <a href="https://www.movable-type.co.uk/scripts/latlong.html"></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="coordinates-conversion-correction-angle-calculation-for-pair"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="coordinates-conversion-correction-angle-calculation-error"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  For example: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Testing </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="correction-angle-calculation-alg-testing-street-before-correction"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="correction-angle-calculation-alg-testing-street-after-correction"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="correction-angle-calculation-alg-testing-street-after-last-correction"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="correction-angle-calculation-alg-testing-tracks"></p><br><p>              ‚Äî     gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  Instead of conclusion </h1><br><p>      Slack, ,  <a href="https://arcl-dev.slack.com/join/shared_invite/enQtMjgzNTcxMDE1NTA0LTZjNDI0MjA3YmFhYjFiNGY4MWY5ZThhZGYzMzcyNTFjNzQzZGVlNmYwOGQ1Y2I5NmJmYTc2MTNjMTZhZTI5ZjU"></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  useful links </h1><br><ul><li> <a href="https://github.com/trimonovds/mobius-samples"></a> </li><li> <a href="https://www.movable-type.co.uk/scripts/latlong.html"> </a> </li><li> ARKit+CoreLocation <a href="https://github.com/ProjectDent/ARKit-CoreLocation"></a>  <a href="https://medium.com/journey-of-one-thousand-apps/arkit-and-corelocation-part-one-fc7cb2fa0150"></a> </li><li> <a href="https://medium.com/super-ventures-blog/why-is-arkit-better-than-the-alternatives-af8871889d6a">   ARKit</a> </li><li> <a href="https://github.com/mapbox/mapbox-ar-unity">    </a> </li><li> <a href="http://blog.maugry.ru/blog/technologies/history-of-augmented-reality/"> AR   </a> </li></ul><br><p>      ,           <a href="https://medium.com/yandex-maps-ios"> .</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/421957/">https://habr.com/ru/post/421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421945/index.html">Google and Mastercard make a secret shopping tracking deal</a></li>
<li><a href="../421947/index.html">Welcome to Android Devs Meetup September 8</a></li>
<li><a href="../421949/index.html">The suicide squad. How we recruit the most brutal junior developers</a></li>
<li><a href="../421953/index.html">Summ3r 0f h4ck: the results of a summer internship at Digital Security</a></li>
<li><a href="../421955/index.html">The Senate does not want robots to be distracted by beer. And what else to write on Friday?</a></li>
<li><a href="../421959/index.html">What to do when ‚Äúthis‚Äù loses contextual reference</a></li>
<li><a href="../421961/index.html">Creating a demo for an old phone - AONDEMO</a></li>
<li><a href="../421963/index.html">Accounting and accountant: their role in the organization</a></li>
<li><a href="../421965/index.html">"In addition to work, I still work" - 10 questions to the programmer, the third issue</a></li>
<li><a href="../421967/index.html">Children's toy on logic elements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>