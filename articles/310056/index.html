<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Launch Linux on FPGA: Hello, World</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD 09/21/16: BusyBox is now successfully launched. 


 Inspired by a series of articles on the Mars Rover project site, in which the author tries to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Launch Linux on FPGA: Hello, World</h1><div class="post__text post__text-html js-mediator-article">  <b>UPD 09/21/16:</b> BusyBox is now successfully launched. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7e2/093/1ef/7e20931ef54540bfb3a7d0a2d052c19b.jpg" alt="image"></div><br>  Inspired by a series of articles on the <a href="http://marsohod.org/projects/marsohod2/amber-arm-soc">Mars Rover project</a> site, in which the author tries to launch an open system on the <a href="http://opencores.org/project,amber">Amber SoC chip</a> and Linux on the FPGA-based Mars Rover 2, I decided to try to repeat this experience on my <a href="http://de2-115.terasic.com/">Terasic DE2-115 board</a> .  But, instead of the <s>old as shit mammoth</s> obsolete version of Linux 2.4.27, I will be running the latest version of Linux at the moment - 4.8.0-rc5. <br><a name="habracut"></a><br><h3>  Amber Crystal System </h3><br>  The Amber processor core is a 32-bit RISC processor, fully compatible with the architecture and the ARM v2a command system, which allows compiling programs for it using GCC.  In addition to the processor itself, the Amber project provides several peripheral devices as part of a system on a chip, including a UART, a timer, and an Ethernet MAC.  The processor core is available in two versions: <br><table><tbody><tr><td></td><td>  <b>Amber 23</b> </td><td>  <b>Amber 25</b> </td></tr><tr><td>  Conveyor </td><td>  three level </td><td>  five level </td></tr><tr><td>  Cache </td><td>  common (code + data) </td><td>  separated </td></tr><tr><td>  Wishbone bus width </td><td>  32 bits </td><td>  128 bits </td></tr><tr><td>  Performance </td><td>  0.75 DMIPS / MHz </td><td>  1.05 DMIPS / MHz </td></tr></tbody></table><br>  As you can see, the performance of the processor core is comparable to the performance of cores based on later versions of the ARM architecture, such as ARMv4 and ARMv5.  The ARMv2a architecture is implemented in the Amber processor for the reason that it is not covered by patents and its implementations can be freely distributed.  However, some problems are connected with this - this architecture is considered obsolete in GCC, from where its support is gradually being ‚Äúcut out‚Äù, and support for this architecture has been removed from the Linux kernel a long time ago. <br><br>  An important feature of the architecture is that, unlike the newer versions of the ARM architecture, the processor does not support the THUMB mode, it lacks the CPSR / SPSR registers and support for MSR / MRS instructions, and the processor flags are contained in the PC register bits: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/fdc/9a0/f13/fdc9a0f133ff475e8314f485715033c6.png"></div><br>  Because of this, the processor can address a maximum of 64 MB of memory (26 bits) in the PC register, the two youngest of which are always 0, because  The instructions are always aligned with the word boundary, so the two lower bits of the register are used as flags defining the processor operation mode (user / privileged, interrupt handler).  In other registers, the processor can address up to 4 GB of memory.  More details about the architecture of the processor core and the set of commands implemented in it can be found <a href="http://opencores.org/websvn,filedetails%3Frepname%3Damber%26path%3D%252Famber%252Ftrunk%252Fdoc%252Famber-core.pdf">here</a> and <a href="https://en.wikipedia.org/wiki/26-bit">here</a> . <br><br><h3>  Installing ARM Cross Compiler </h3><br>  Unfortunately, the Sourcery CodeBench Lite compiler, which was used by the author of articles about porting a project to the Mars Rover board, is no longer available for download, but this is not a very big problem.  To install the compiler, you can use <a href="http://crosstool-ng.org/">crosstool-NG</a> or <code>crossdev</code> in Gentoo Linux. <br><br>  To install using crosstool-NG, it suffices to use the out <code>arm-unknown-eabi</code> configuration: <br><br><pre> <code class="bash hljs">$ ct-ng arm-unknown-eabi $ ct-ng build</code> </pre><br>  This compiler will be used to build the Linux kernel and bare-metal programs, such as the initial boot loader, and a simple application that prints Hello, World to the serial port. <br><br><h3>  Compile Hello World and run in the Verilog simulator Verilator </h3><br>  Download the project distribution kit with <a href="https://github.com/madprogrammer/amber-de2">GitHub</a> and look inside: the project is divided into 2 parts - the <code>hw</code> folder contains the source of the ‚Äúhardware‚Äù part in the Verilog language, and the <code>sw</code> folder contains the source code of the programs that will be run on the processor, and some auxiliary utilities used in assembling and transforming ELF and BIN file formats into a format supported by Xilinx tools and Amber test bench scripts. <br><br>  Go to the folder <code>sw/hello</code> and compile the program <code>hello-world.c</code> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> sw/hello-world $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> AMBER_CROSSTOOL=arm-unknown-eabi $ make</code> </pre><br>  As a result, among other things, the file <code>hello-world.mem</code> will be generated - a text file with the contents of the compiled program, suitable for downloading to the simulator and to the Boot ROM of our processor. <br><br>  The author of the original articles that I used was used to simulate the Icarus Verilog project - a free and very popular simulator, but the problem is that it works terribly slowly - on my machine with a 2.6 GHz processor, the clock frequency of the Amber core during simulation in Icarus Verilog is about 16 kHz, and each character in the string ‚ÄúHello, World‚Äù from the example above is displayed for about half a second.  This speed is sufficient if you need to debug the execution of a small program, such as a bootloader or the same hello-world, but is unacceptable, if you want to debug the boot of the entire Linux kernel - you have to wait for ages. <br><br>  Therefore, we will use the Verilator simulator, which compiles Verilog in C ++ and works very fast - Hello World prints instantly without any visible delay, and the clock frequency on my machine is about 1.5 MHz, which is 100 times faster than Icarus Verilog!  By the way, the debugging process of launching the Linux kernel took me about a week, and the simulation helped a lot, because in the simulation mode, the test bench code writes to the text log file an assembler listing of all the instructions executed by the processor, including jumps to addresses, asynchronous and software interrupts, etc.  A sort of disassembler implemented in Verilog. <br><br>  We install Verilator according to the instructions from the <a href="http://www.veripool.org/wiki/verilator">official site</a> , go to the <code>hw/de2_115/tb</code> folder, where the modified testbench is located, and <code>make</code> .  <code>obj_dir</code> Verilog compiler warnings stream, the result will be the <code>obj_dir</code> folder, and in it the <code>Vtb</code> executable file, which we will run to simulate the operation of the system. <br><br>  Next, execute the following commands: <br><br><pre> <code class="bash hljs">$ cp ../../../sw/hello-world/hello-world.mem ./boot-loader.mem $ ./obj_dir/Vtb</code> </pre><br>  As a result, the simulation will be launched and we will see the long-awaited Hello, World: <br><br><pre> <code class="bash hljs">Load boot memory from boot-loader.mem Read <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 961 lines Hello, World!</code> </pre><br>  This means that the processor successfully read and executed our program compiled by GCC under ARM! <br><br>  If you wish, you can add the <code>verilator</code> key to the list of startup keys of the <code>verilator</code> the <code>--trace</code> , then another test file will be generated - <code>out.vcd</code> , which can then be opened by the GTKWave program, and see the waveforms of various signals inside the processor and other blocks : <br><br><img src="https://habrastorage.org/files/785/476/854/785476854f9e46f4a84b39fe97412936.png"><br><br><h3>  Build initramfs with Builtroot </h3><br>  Before building the Linux kernel, create an environment for compiling custom programs for our system (based on uClibc-ng) and generate a file that will be added to the kernel as an initramfs during the build process.  To do this, use Buildroot, which can be downloaded <a href="https://github.com/madprogrammer/amber-buildroot">from here</a> . <br><br><pre> <code class="bash hljs">$ make amber_defconfig $ make</code> </pre><br>  As a result, we will have an armchild <code>arm-buildroot-uclinux-uclibcgnueabi</code> and an image of the file system in <code>./output/images/rootfs.cpio</code> .  The path to this image will need to be specified in the kernel configuration file, the parameter <code>CONFIG_INITRAMFS_SOURCE</code> .  BusyBox is included in the file system image, <s>but it still doesn‚Äôt start up completely</s> <i>(now it is running),</i> but in this article <s>we‚Äôll</s> restrict ourselves to a simple ‚ÄúHello, World‚Äù as the process <code>/sbin/init</code> .  To do this, in the directory where BuildRoot was going to create a file <code>hello.c</code> with the content known to each programmer, and run the following commands: <br><br><pre> <code class="bash hljs">$ ./output/host/usr/bin/arm-buildroot-uclinux-uclibcgnueabi-gcc -o hello hello.c $ mv hello output/target/sbin/init $ rm hello.gdb $ make</code> </pre><br>  After successful execution of these commands, <code>./output/images/rootfs.cpio</code> will be rebuilt with our application instead of BusyBox.  This way of replacing files is suitable to quickly check something, for the full addition and replacement of files in <code>rootfs</code> during the build process there is a configuration option <code>BR2_ROOTFS_OVERLAY</code> . <br><br>  Unlike the example that we launched in the Verilator simulator, this new ‚ÄúHello, World‚Äù is not working as a bare-metal application, but as a user application for Linux ‚Äî the text will be output to the serial port using the uClibc standard library <code>write</code> system call and transfer control to the kernel through a software interrupt, the kernel will transfer control to the <code>tty</code> driver, then the serial port driver, and finally the message will be output. <br><br><h3>  Build the Linux kernel and boot loader </h3><br>  Naturally, in order to launch the freshest core, it had to make some changes.  For the most part, these changes are related to the interrupt handling code and processor mode switching code, since this code is architecture dependent.  Next, I adapted the code to support the Integrator platform (mach-integrator), since  In the original patch of the author of the Amber project for the 2.4 kernel, there are hints that this platform is the prototype of the Amber SoC architecture (in particular, it was discovered that peripheral devices, such as an interrupt controller, a timer, and a serial port, are implemented compatible with the device drivers used on this platform) and created on its basis a new platform Amber. <br><br>  Fortunately, the debugging clock is over, and now the assembly of the working core is done with a flick of the wrist.  Those who wish to repeat it can <a href="https://github.com/madprogrammer/amber-linux">clone the source</a> and execute the following commands: <br><br><pre> <code class="bash hljs">$ make ARCH=arm CROSS_BUILD=arm-none-eabi- amber_defconfig $ make -j8 ARCH=arm CROSS_BUILD=arm-none-eabi- Image $ make ARCH=arm CROSS_BUILD=arm-none-eabi- arch/arm/boot/dts/amber-de2115.dts</code> </pre><br>  After the kernel is assembled, the <code>arch/arm/boot/Image</code> and <code>arch/arm/boot/dts/amber-de2115.dtb</code> files will be created, ready to be loaded into the board using a bootloader via the serial port using the XMODEM protocol. <br><br>  To build the bootloader, go to the <code>sw/boot-loader-serial</code> folder, do <code>make</code> (don't forget about the environment variable <code>AMBER_CROSSTOOL</code> ) and get the file <code>boot-loader-serial.mem</code> , which can be converted to MIF, which accepts Altera, using the utility <code>mem2mif</code> Quartus II as a memory initialization file. <br><br><h3>  Putting it all together </h3><br>  For those who have a Terasic DE2-115 board, it‚Äôs time to open the <code>de2_115.qpf</code> project and synthesize it (note that I have a serial port on the EXT_IO connector instead of the RS232 board, since there are no COM ports on my motherboard ), specify the <code>de2_115_sram_2048_32_byte_en</code> memory received in the previous step as <code>boot-loader-serial.mif</code> as the file for initialization and load the bitstream into the board.  Since the Amber processor, for one developer, did not implement the reset logic for the known reasons, it is possible to reset the processor to the initial state only by reloading the bitstream.  At the same time, if in the process you hold down the KEY0 button, the processor will not start the program until it is released.  I used this button to debug Verilog code using SignalTap.  But if you let it go, then just reloading the bitstream will help start all over again. <br><br>  After downloading the bitstream in the terminal configured at 921600 baud, the prompt Amber will appear immediately.  Next, you need to type the <code>b 80000</code> command and send the Linux kernel file ( <code>arch/arm/boot/Image</code> ) generated earlier with XMODEM, and then again type the <code>b 78000</code> command and send the DTB file, which describes which devices to search for which addresses, what drivers for them to load, how much RAM is in the system, a command line with kernel parameters and other information.  I patched the bootloader in such a way that it sends the address <code>0x78000</code> to the kernel as the address where to look for DTB, so we load it at this address. <br><br><img src="https://habrastorage.org/files/7c9/4bf/c5e/7c94bfc5ef2449b2a8ddfb4a86971aea.png"><br><br>  Finally, when both files are loaded into random access memory (SDRAM), you can enter the <code>j 80000</code> command in the boot loader console.  The Linux download starts, and if everything is done correctly, the result will be something like this: <br><br><img src="https://habrastorage.org/files/b2b/805/cec/b2b805cec7fd46b78dcf879c0af7f50d.png"><br><br>  Our "Hello, World" was launched as the first user process ( <code>/sbin/init</code> ) and brought the cherished phrase to the screen through the standard library and the kernel.  Wow, isn't it? <br><br>  If you do not have a Terasic DE2-115 board or any other board with a FPGA of sufficient size, you can still run Linux in the Verilator simulator.  To do this, add the <code>-DAMBER_LOAD_MAIN_MEM=1</code> and <code>-DAMBER_LOAD_DTB_MEM=1</code> keys to <code>hw/de2_115/tb/Makefile</code> and rebuild the <code>Vtb</code> executable file.  Then, using the <code>amber-bin2mem</code> we create the kernel and DTB files for the simulator: <br><br><pre> <code class="bash hljs">$ amber-bin2mem arch/arm/boot/Image 80000 &gt; vmlinux.mem $ amber-bin2mem arch/arm/boot/dts/amber-de2115.dtb 78000 &gt; dtb.mem</code> </pre><br>  In addition, you will need to slightly correct the bootloader code for the simulation, commenting out the <code>main</code> function call as in the normal mode it requests commands from the user.  Then the loader will immediately transfer control to the Linux kernel.  Copy the <code>*.mem</code> files to the <code>*.mem</code> folder, run: <code>./obj_dir/Vtb</code> and watch Linux boot. <br><br><h3>  Limitations, practical benefits </h3><br>  Of course, Linux, which eventually started, is not quite similar to the one we used to see on servers and workstations, due to the fact that the Amber processor core does not have a MMU (Memory Management Unit) and, as a result, virtual memory support (all memory is physical), memory protection (any application can corrupt kernel memory or communicate with devices bypassing it, via the Wishbone bus), copy-on-write, etc. NOMMU Linux currently does not support ELF executable files (although There are developments on the support of the format FDPIC ELF) and dynamic bib  ioteki - used instead bFLT format (Binary Flat) - a simple format based on <code>a.out</code> .  And if you run, say, N instances of an application on such a system, then exactly as many copies of it will be in memory. <br><br>  The practical benefits of the work done are still there, even such ‚Äútrimmed‚Äù versions of Linux work in many devices based on microcontrollers with limited resources.  I hope that the habrayusers who are keen on FPGA programming can learn something useful by experimenting with full-fledged Linux on an FPGA-synthesized processor (which, incidentally, only takes up 8% of capacity on DE2-115 or about 10,000 LE).  If you have another board based on Altera or Xilinx, then porting to it is not difficult, because  Most of the work has already been done.  Of course, there are already more practical solutions that are more interesting from a practical point of view, such as Xilinx Zynq, Altera Cyclone V SoC, which contain a full-fledged ARM-SoC on a single chip with FPGA, but the solution presented in this article allows Linux to run even for owners of simple boards with no very powerful FPGAs on board.  The remaining free logic can be used to implement new custom peripherals, which can be ‚Äúhung‚Äù on the Wishbone bus and made available from the OS using drivers. <br><br><h3>  Plans </h3><br>  The Terasic DE2-115 board is truly one of the most powerful debugging boards, on the basis of which interesting projects have already been made (this is the <a href="https://geektimes.ru/post/257370/">clearest example</a> and <a href="https://geektimes.ru/post/258028/">another one</a> ).  She has on board a wide range of peripherals: <br><br><ul><li>  128 MB SDRAM </li><li>  8 MB SPI Flash </li><li>  LEDs and seven-segment indicators </li><li>  16x2 liquid crystal display </li><li>  24-bit audio codec </li><li>  SD card slot </li><li>  2 gigabit ethernet ports </li><li>  VGA monitor output, PS / 2 keyboard </li><li>  USB ports </li></ul><br>  Of all this wealth, I have used only RAM in this project.  In the future, if there is time, I want to compile U-Boot and place it in the built-in flash memory, in the bootloader code in the FPGA, load U-Boot, which would then load the Linux kernel and root file system from the SD memory card.  In addition, I would like to try to implement the support of peripheral devices available on the card - Ethernet, for example. </div><p>Source: <a href="https://habr.com/ru/post/310056/">https://habr.com/ru/post/310056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310046/index.html">How to manage the giants Vol.3: the full life cycle of the project</a></li>
<li><a href="../310048/index.html">How much conflict developers - infographics on the results of the survey on "My Circle"</a></li>
<li><a href="../310050/index.html">Tired of silencing: the truth about working in a technical support service for an IT company</a></li>
<li><a href="../310052/index.html">Animated QR codes</a></li>
<li><a href="../310054/index.html">Overview of the OPCache extension for PHP</a></li>
<li><a href="../310058/index.html">How to stop being afraid and fall in love with mbed [Part 3]</a></li>
<li><a href="../310060/index.html">Cycle of articles "NetRack Guards: guarding the client IT infrastructure": the story of a man who knows everything</a></li>
<li><a href="../310062/index.html">Pitfalls of conditional formatting in MS Access</a></li>
<li><a href="../310064/index.html">How to avoid mistakes using modern C ++</a></li>
<li><a href="../310066/index.html">31 best email marketing automation tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>