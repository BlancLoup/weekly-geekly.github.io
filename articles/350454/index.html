<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Surprisingly simple messaging with Spring Cloud Stream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article " Surprisingly simple messaging with the Spring Cloud Stream " by Richard Seroter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Surprisingly simple messaging with Spring Cloud Stream</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the article " <a href="https://seroter.wordpress.com/2017/09/05/surprisingly-simple-messaging-with-spring-cloud-stream/">Surprisingly simple messaging with the Spring Cloud Stream</a> " by Richard Seroter. <br><br>  There are many options for the interaction of microservices.  You can use service discovery (Service Discovery, for example, Spring Cloud Discovery Server / Client in a Netflix Eureka implementation) and make direct calls.  Or you can use a common database for sharing work results.  But message brokers continue to be a popular choice. <br><br>  They range from simple engines like Amazon SQS or RabbitMQ to event-based stream processors like Azure Event Hubs or Apache Kafka, and even service tires like Microsoft BizTalk Server.  When developers choose one of the engines, they critically need knowledge about their effectiveness.  How can you improve developer productivity?  For Java developers, <a href="https://cloud.spring.io/spring-cloud-stream/">Spring Cloud Stream</a> offers a valuable abstraction. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Spring Cloud Stream offers an interface for developers who do not need the nuances of the basic broker.  This broker, Apache Kafka or RabbitMQ, is configured by the Spring Cloud Stream itself.  Communication with the broker and back from the broker is also carried out through the Stream library. <br><br>  What worries me is that all brokers are treated the same.  Spring Cloud Stream normalizes behavior, even if it is not native to the broker.  For example, do you want to create a competing model of consumer bins for your customers or partition processing?  These concepts behave differently in RabbitMQ and Kafka.  No problems.  Spring Cloud Stream makes work equally transparent.  Let's actually try both of these scenarios. <br><a name="habracut"></a><br><h2>  Competitor Consumer through ‚Äúconsumer groups‚Äù </h2><br>  By default, Spring Cloud Stream establishes the relationship between posting and subscription to messages.  This makes it easy to exchange data between different subscribers.  But what if you want multiple instances of subscribers (for scaling processing)?  One solution is ‚Äúconsumer groups‚Äù.  But in brokers their implementation is different.  Here Spring Cloud Stream gets to work!  Let's create an example application using RabbitMQ. <br><br>  Before writing the code, we need an instance of the RabbitMQ server.  The simplest launch option is the Docker container for RabbitMQ.  If you have Docker installed, you only need to execute the following command: <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">run</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-d</span></span> ‚Äì<span class="hljs-selector-tag"><span class="hljs-selector-tag">hostname</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">local-rabbit</span></span> ‚Äì<span class="hljs-selector-tag"><span class="hljs-selector-tag">name</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">demo-rmq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-p</span></span> 15672<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:15672</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-p</span></span> 5672<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:5672</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rabbitmq</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3.6.11-management</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ma/zx/ng/mazxng6jnq1jwptz83x5hm6btsq.png"><br><br>  Instead of rabbitmq: 3.6.11-management, you can use the latest version from <a href="https://hub.docker.com/_/rabbitmq/">hub.docker.com/_/rabbitmq</a> <br><br>  After launch, I had a local docker image cache and a running container with the display of ports, which makes the container available on my working machine. <br><br>  How do we send messages to RabbitMQ?  Spring Cloud Stream supports multiple templates.  We can publish on schedule or on request.  Here, let's create a web application that publishes a message when a user issues a POST command at a REST endpoint. <br><br><h2>  Message Publishing Application (Producer, Producer) </h2><br>  First, create a Spring Boot application that uses spring-cloud-starter-stream-rabbit (and spring-boot-starter-web).  This is all I need to use Spring Cloud Stream and RabbitMQ as my goal for posting messages. <br><br><img src="https://habrastorage.org/webt/1m/st/7a/1mst7atyvusb6i1vmqdzcjvalug.png"><br><br>  Add a new class that implements the REST controller.  The simple @EnableBinding annotation runs the configuration of the application as a Spring Cloud Stream project.  Here I use the supplied simple ‚ÄúSource‚Äù interface, which defines one communication channel, but you can also create your own.  These are just two lines of code. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableBinding</span></span>(Source.class) <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BriefController</span></span></span><span class="hljs-class"> </span></span>{</code> </pre> <br>  In this controller class, add an @Autowired field that refers to the bean that Spring Cloud Stream creates in the Source interface.  (That's it! Configuring a channel in the interface that Spring Cloud Stream understands into bins).  Then we can use this variable to directly post messages in the connected channel!  Common code, whether it is RabbitMQ or Kafka.  Universally and simply. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableBinding</span></span>(Source.class) <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BriefController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//refer to instance of bean that Stream adds to container @Autowired Source mysource; //take in a message via HTTP, publish to broker @RequestMapping(path="/brief", method=RequestMethod.POST) public String publishMessage(@RequestBody String payload) { System.out.println(payload); //send message to channel mysource.output().send(MessageBuilder.withPayload(payload).build()); return "success"; }</span></span></code> </pre> <br>  The message publishing application is almost complete, and all that is left is the basic configuration.  This configuration tells the Spring Cloud Stream how to connect to the broker.  Please note that we do not need to tell the Spring Cloud Stream to use RabbitMQ;  this happens automatically, by the presence of the boot starter RabbitMQ classes.  No, all we need is information about the connection with our broker, an explicit link to the destination of the messages and the command to send JSON. <br><br><pre> <code class="hljs mel">server.port=<span class="hljs-number"><span class="hljs-number">8080</span></span> #rabbitmq settings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Spring Cloud Stream to use <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.host=<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.port=<span class="hljs-number"><span class="hljs-number">5672</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.username=guest <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.password=guest <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.output.destination=legalbriefs <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.contentType=application/json</code> </pre> <br><h2>  Message Consumer Application (Consumer, Consumer) </h2><br>  This part is too simple.  Here, create a new Spring Boot application and select only the dependency on spring-cloud-starter-stream-rabbit. <br><br>  Decorate the class with the @EnableBinding annotation and use the built-in Sink interface.  Then all that is left is to create a method for processing any messages found in the broker.  To do this, we denote the processing method using the @StreamListener annotation, and all content processing is done for us. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableBinding</span></span>(Sink.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlogStreamSubscriberDemoApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(BlogStreamSubscriberDemoApplication.class, args); } <span class="hljs-meta"><span class="hljs-meta">@StreamListener</span></span>(target=Sink.INPUT) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logfast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(msg); } }</code> </pre> <br>  Configuration for this application is simple.  As above, we have connection data for RabbitMQ.  Also note that the binding now refers to ‚Äúinput‚Äù, which was the name of the channel in the standard ‚ÄúSink‚Äù interface.  Finally, note that I used the same destination as the source to ensure that the Spring Cloud Stream was successfully connecting the publisher and the subscriber.  To feel the power of Cloud Stream below, I‚Äôll add the settings for a group of consumers (consumers). <br><br><pre> <code class="hljs mel">server.port=<span class="hljs-number"><span class="hljs-number">0</span></span> #rabbitmq settings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Spring Cloud Stream to use <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.host=<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.port=<span class="hljs-number"><span class="hljs-number">5672</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.username=guest <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.rabbitmq.password=guest <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.input.destination=legalbriefs</code> </pre> <br><h2>  Testing the solution </h2><br>  Let's see how it works.  First run three instances of the subscriber application.  I created a jar file and launched three instances in the shell. <br><br><img src="https://habrastorage.org/webt/uf/o8/ff/ufo8fftwocxnxvfgnuvtwygmfjm.png"><br><br>  When you launch these applications, Spring Cloud Stream starts working.  Log into the RabbitMQ web-based admin console and note that the exchange point has been created.  It is called ‚Äúlegalbriefs‚Äù and is mapped to the name we specified in the configuration file above. <br><br><img src="https://habrastorage.org/webt/nw/it/ls/nwitlsyaruqit003fyrsyfimpn8.png"><br><br>  We also have three queues that are displayed in each of the three application instances that we run. <br><br><img src="https://habrastorage.org/webt/qg/4l/dc/qg4ldcwzju52f9kgtthgmirdbkc.png"><br><br>  Finally, launch the producer and send the message via http request with / briefs on the end. <br><br><img src="https://habrastorage.org/webt/g3/nv/pb/g3nvpb2mzplynqrcqxxvvnfj14i.png"><br><br>  What's happening?  As expected, each subscriber receives a copy of the message, because by default everything happens in a simple publish / subscribe mode. <br><br><img src="https://habrastorage.org/webt/7d/mm/w1/7dmmw1q0nkel8winx2cdocq8yd8.png"><br><br><h2>  Add consumer group configuration </h2><br>  We do not want every copy of the subscriber to receive a copy of the message.  Rather, we want these instances to share messages with each other.  Each message should receive only one.  In the subscriber application, we add one line to our configuration file.  This tells the Spring Cloud Stream that all instances form a single group of subscribers who work together. <br><br><pre> <code class="hljs mel">#adds consumer <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> processing <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.input.<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> = briefProcessingGroup</code> </pre> <br>  After regenerating the jar file of the subscriber and running each file, we see a different setting in RabbitMQ.  What you see is one named queue, but three ‚Äúconsumer‚Äù queues. <br><br><img src="https://habrastorage.org/webt/yv/1g/8m/yv1g8m6dld--vo8djto3gajovtu.png"><br><br>  Send two different messages and make sure that each is processed by only one instance of the subscriber.  This is an easy way to use a message broker to scale processing. <br><br><img src="https://habrastorage.org/webt/ui/nu/ic/uinuicosc_7ifnzrh-3teef7cj8.png"><br><br><h2>  Performing stateful processing using partitioning </h2><br>  Separation looks like a connected, but different scenario than consumer groups.  Partitions in Kafka introduce a level of parallel processing by writing data to different sections.  Each subscriber then pulls a message from a given partition (partition) to do the work.  Here, in the Spring Cloud Stream, splitting is useful for parallel processing, but also for stateful processing.  When setting up, you specify a characteristic that directs messages to this section.  Then one instance of the application processes all the data in this section.  This can be useful for handling events or any scenario where it is useful for related messages to be processed by the same instance.  Consider: counters, complex event handling, or time-sensitive computing tasks. <br><br>  Unlike consumer groups, partitioning requires configuration changes for both publishers and subscribers.  On the publisher‚Äôs (producer) side, all you need to specify is: (a) the number of sections and (b) an expression describing the data separation.  No code changes. <br><br><pre> <code class="hljs mel">#adding configuration <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> processing <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.attorney <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.output.producer.partitionCount=<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  On the consumer side, you set the number of partitions and set the "partitioned" property to "true."  What is also interesting, but it is logical, is that as each subscriber starts, you need to give it an ‚Äúindex‚Äù so that Spring Cloud Streams knows which section it should read messages from. <br><br><pre> <code class="hljs mel">#add <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> processing <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.bindings.input.consumer.partitioned=true #<span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.instanceIndex=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">spring</span></span>.cloud.stream.instanceCount=<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Let's run all over again.  The producer runs the same way as before.  However, each subscriber instance runs with the "spring.cloud.stream.instanceIndex = X" flag, which indicates which index is being applied. <br><br><img src="https://habrastorage.org/webt/qj/zt/3n/qjzt3n9g5vpdz3f4irrmlwffil0.png"><br><br>  As you can see, in RabbitMQ, the setting is different from the previous one.  Now we have three queues, each with a different ‚Äúrouting key‚Äù (‚Äúrouting key‚Äù), which corresponds to its section. <br><br><img src="https://habrastorage.org/webt/gt/_w/r1/gt_wr12vrougxtzx3983usma9sy.png"><br><br>  Send the message and note that all messages with the same index name go to the same instance.  Change the number and make sure all messages still go to the same place.  Switch the number and note that another section (probably) gets it.  If you have more varieties of data than partitions, you will see a section descriptor with more than one data set.  No problem, just know that this is happening. <br><br><img src="https://habrastorage.org/webt/vb/g-/xi/vbg-xik_qmkpfpjkxbocxhwxm7g.png"><br><br><h2>  Summary </h2><br>  It is not necessary to deal directly with message brokers.  Of course, there are many scenarios in which you want to apply advanced broker options, but there are also many cases where you just want a reliable intermediary.  In such cases, Spring Cloud Stream simplifies the abstraction of broker knowledge, but at the same time normalizes the behavior of the unique broker implementations. <br><br>  In <a href="https://www.pluralsight.com/courses/java-microservices-spring-cloud-coordinating-services">my last Pluralsight course,</a> I spent more than an hour digging into the Spring Cloud Stream, and I worked with Spring Cloud Data Flow for another 90 minutes.  This project will help you quickly combine streaming applications.  Check it out for a deeper dive! </div><p>Source: <a href="https://habr.com/ru/post/350454/">https://habr.com/ru/post/350454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350442/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ304 (February 26 - March 4, 2018)</a></li>
<li><a href="../350444/index.html">Implement java promises</a></li>
<li><a href="../350446/index.html">Container Run Environments (container runtimes) Part 1: Introduction to Container Run Environments</a></li>
<li><a href="../350448/index.html">RegExp Unicode Property Escapes in JavaScript: Portrait Strokes</a></li>
<li><a href="../350452/index.html">Load testing "non-HTTP". Part 2 Gatling</a></li>
<li><a href="../350456/index.html">Digital events in Moscow from March 5 to 11</a></li>
<li><a href="../350458/index.html">Publish the game on Google Play. Configuring Play Games Plugin for Unity</a></li>
<li><a href="../350462/index.html">Configuring VoIP FXS of the Yeastar Neogate TAXXX gateway to work with 3CX</a></li>
<li><a href="../350464/index.html">Fintech news. Another pair of national cryptocurrency and cryptonalogues</a></li>
<li><a href="../350466/index.html">Adaptive Layout with SCSS and Gulp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>