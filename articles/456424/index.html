<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Utreexo: compress UTXO Bitcoin set</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 


 On the Bitcoin network, all nodes agree on a lot of UTXOs during consensus: how many coins are available for spending, to whom, and unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Utreexo: compress UTXO Bitcoin set</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Hi, Habr! </p><br><p>  On the Bitcoin network, all nodes agree on a lot of UTXOs during consensus: how many coins are available for spending, to whom, and under what conditions.  The UTXO set is the minimum data set required for the validator node, without which the node will not be able to verify the validity of incoming transactions and blocks containing them. </p><br><p>  In this regard, attempts are being made in every way to reduce the stored representation of this set, compress it without losing security guarantees.  The smaller the amount of stored data, the lower the requirements for the disk space of the validator node, which makes starting the validator node cheap, allows you to grow the network and thereby increase the stability of the network. </p><br><p>  In this post we‚Äôll write down a Rust-prototype of a recent proposal from the co-author of <a href="https://lightning.network/lightning-network-paper.pdf">Lightning Network Paper</a> , <a href="https://www.crunchbase.com/person/thaddeus-dryja">Thaddeus Dryja</a> - <a href="https://eprint.iacr.org/2019/611.pdf">Utreexo: a dynamic hash-based accumulator for the Bitcoin UTXO set</a> , which reduces the space requirements for validator nodes. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  What is the problem? </h2><br><p>  One of the eternal problems of Bitcoin was its scalability.  The idea of ‚Äã‚Äã‚Äúa bank itself‚Äù requires network members to keep records of all means available for use.  In Bitcoin, the available funds are expressed as a set of unspent outputs - UTXO-set.  Although this is not a particularly intuitive view, it is advantageous from the point of view of the performance of the implementation, compared to the view in which each ‚Äúwallet‚Äù has a ‚Äúbalance‚Äù in a separate record, and also adds privacy (for example, it provides <a href="https://en.bitcoin.it/wiki/CoinJoin">CoinJoin</a> ). </p><br><p>  It is important to distinguish between transaction history (what is called a blockchain) and the current state of the system.  Bitcoin transaction history currently occupies about 200 GB of disk space, and continues to grow.  However, the state of the system is much less, about 4 GB, and takes into account only the fact of ownership of coins by anyone at the present time.  The volume of this data also increases over time, but at a much slower rate and sometimes even tends to decrease (see KDPV). </p><br><p>  Light clients (SPV) exchange security guarantees for the ability to store no minimum state (UTXO-set), except for private keys. </p><br><h2 id="utxo-i-utxo-set">  UTXO and UTXO-set </h2><br><p>  UTXO (Unspent Transaction Output) - unspent transaction output, the end point of each Satoshi journey transmitted in transactions.  Unspent exits become inputs of new transactions and at the same time spend (spend) and are deleted from the UTXO-set. </p><br><p>  New UTXOs are always created by transactions: </p><br><ul><li>  coinbase transactions without entries: create new UTXOs during the coin issue by miners </li><li>  regular transactions: create new UTXOs, while spending a certain set of existing UTXOs </li></ul><br><p>  The process of working with UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Wallets consider the number of coins available for spending (balance) based on the amount of UTXO available to this wallet for spending. </p><br><p>  Each node validator, in order to prevent double spend attempts, must track the collection of <strong>all</strong> UTXOs when checking <strong>each</strong> transaction of <strong>each</strong> block. </p><br><p>  The node must have logic: </p><br><ul><li>  UTXO-set Additions </li><li>  Deletes from UTXO-set </li><li>  Checks for the presence of a single UTXO in the set </li></ul><br><p>  There are ways to reduce the requirements for stored information about the set, while retaining the ability to add and delete items, check and prove the existence of an item in a set using <a href="https://en.wikipedia.org/wiki/Accumulator_(cryptography)">cryptographic batteries</a> . </p><br><h2 id="akkumulyatory-dlya-utxo">  Batteries for UTXO </h2><br><p>  The idea of ‚Äã‚Äãusing batteries to store a variety of UTXO was <a href="https://bitcointalk.org/index.php%3Ftopic%3D1064860.0">discussed</a> <a href="http://www.erisian.com.au/bitcoin-core-dev/log-2018-12-13.html">earlier</a> . </p><br><p>  UTXO-set is built on the fly, during the initial download of a block chain (IBD, initial block download), stored in full and permanently, while its contents change after processing transactions from each new and correct network block.  This process requires downloading approximately 200 GB of data blocks and verifying hundreds of millions of digital signatures.  After the IBD process is completed, the UTXO-set will occupy about 4 GB in the bottom line. </p><br><p>  However, when using batteries, the rules of consensus regarding the means are reduced to checking and generating cryptographic evidence, and the burden of tracking the available funds is shifted onto the shoulders of the owner of these funds, which provides evidence of their presence and ownership. </p><br><p>  A battery can be called a compact representation of a set.  The size of the stored view, however, must either be constant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-4">1</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  or increase sublinearly relative to the power of the set and size of the element itself, for example <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">O</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">g</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">n</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  where n is the power of the stored set. </p><br><p>  In doing so, the battery should allow generation of evidence of the inclusion of the element in the set (inclusion proof) and to be able to effectively verify this evidence. </p><br><p>  A battery is called <strong>dynamic</strong> if it allows you to add elements and remove elements from the set. </p><br><p>  An example of such a battery is the <a href="https://eprint.iacr.org/2018/1188.pdf">RSA battery offered by Boneh, Bunz, Fisch in December 2018</a> .  Such a battery has a constant size of the stored representation, but requires a <em>shared secret</em> (trusted setup).  This requirement negates the applicability of such a battery for trustless networks such as Bitcoin, since data leakage when generating a secret could allow attackers to create fake evidence of the existence of UTXO, deceiving nodes from the UTXO-set on the basis of such a battery. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  The Utreexo design proposed by Thaddeus Dryja allows you to create a <strong>dynamic</strong> battery <strong>without a</strong> trusted-setup. </p><br><p>  Utreexo is a forest of perfect binary <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D1%2585%25D0%25B5%25D1%2588%25D0%25B5%25D0%25B9">Merkle Trees</a> and is a development of ideas presented in <a href="https://eprint.iacr.org/2015/718">Efficient asynchronous accumulators for distributed pki</a> , adding the ability to remove elements from the set. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  Battery Logical Structure </h4><br><p> The elements of the battery are located in the form of a forest of ideal binary trees.  The trees are ordered by height.  This view is selected as the most visual and allows you to visualize the merging of trees during battery operations. </p><br><p>  The author notes that since all the trees of a forest are ideal, their height is expressed by a power of two, as well as any natural number can be represented as a sum of powers of two.  Accordingly, any set of sheets can be grouped in the form of binary trees, and in all cases, adding a new element requires knowledge of <em>only the root nodes of the stored trees</em> . </p><br><p>  Thus, the Utreexo battery's stored representation is a list of root nodes (Merkle root), <em>and not the entire forest of trees</em> . </p><br><p> Imagine a list of root elements as <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  The optional <code>Option&lt;Hash&gt;</code> indicates that the root element may be missing, which means that there is no tree in the battery with the appropriate height. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Adding items </h4><br><p>  To begin with, we describe the <code>parent()</code> function, which recognizes a parent node for two given elements. </p><br><div class="spoiler">  <b class="spoiler_title">Parent () function</b> <div class="spoiler_text"><p>  Since we use Merkle trees, the parent of each of the two nodes is one node that stores the hash of the concatenation of the hashes of the descendant nodes: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  The author notes that to prevent the attacks described by Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir, and Sebastien Zimmer in <br>  <a href="https://eprint.iacr.org/2007/395">Second preimage attacks on dithered hash functions</a> , in addition to the two hashes should be added to the concatenation also the height inside the tree. </p></div></div><br><p>  In the course of adding elements to the battery, you need to keep track of which root elements are changed.  By following the path of changing the root elements for each element added, you can later construct a proof of the presence of these elements. </p><br><div class="spoiler">  <b class="spoiler_title">Tracking changes during the add process</b> <div class="spoiler_text"><p>  To track changes made, we will declare an <code>Update</code> structure that will store data about node changes. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  To add an element to the battery, you need: </p><br><ul><li>  Create an array of baskets of root elements <code>new_roots</code> and place the existing root elements there, one for each basket: </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Add added items (array of <code>insertions</code> ) to the first basket <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  To carry out a "union" (coalescing) of the elements added to the first basket with the rest: <br><ul><li>  For all baskets with more than one item: <br><ol><li>  We take two elements from the end of the basket, we calculate their parent, we delete both elements </li><li>  Add the computed parent to the next bin. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Move the root elements from the baskets to the resulting battery array </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Creating evidence for added items </h4><br><p>  The proof of the inclusion of the element in the battery ( <code>Proof</code> ) will serve as the path Merkle (Merkle Path), consisting of a chain <code>ProofStep</code> .  If the path leads nowhere, then the proof is false. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Using the information obtained earlier in the course of adding an element (structure <code>Update</code> ), you can create evidence that the element was added to the battery.  To do this, we go around the table of the changes made and add each step to the path of Merkle, which later will serve as evidence: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">The process of creating evidence</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Proof of evidence for </h4><br><p>  Testing the proof of inclusion of an element (inclusion proof) is reduced to following the path of Merkle until it leads to the existing root element: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Clearly: </p><br><div class="spoiler">  <b class="spoiler_title">Proof process for A</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Deleting items </h4><br><p>  To remove an item from the battery, you need to provide valid proof that the item is there.  Using the data from the proof, it is possible to calculate the new root elements of the accumulator for which this proof will no longer be true. </p><br><p>  The algorithm is as follows: </p><br><ol><li>  As with the addition, we will organize a set of empty baskets corresponding to the Merkle trees with a height of equal to two from the basket index </li><li>  Insert items from the steps of the Merkle path into the baskets;  the basket index is equal to the current step number </li><li>  Remove the root element, which leads the way from the proof </li><li>  As with the addition, we calculate the new root elements by combining the elements from the baskets in pairs and moving the result of the combination into the next basket. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  The process of removing the element "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integration into existing network </h2><br><p>  Using the proposed battery, the nodes can refuse to use the database to store all UTXO, while maintaining the ability to change the UTXO-set.  However, there is the problem of working with evidence. </p><br><p>  Let's call a validator node that uses a UTXO battery <em>compact</em> (compact-state node), and a validator without battery - <em>full</em> (full node).  The existence of two classes of nodes creates the problem of integrating them into a single network, since compact nodes require proof of the existence of UTXO, which are spent in transactions, and full nodes are not.  If all the network nodes do not switch to Utreexo at the same time and in a coordinated manner, then the compact nodes will be left behind and will not be able to work in the Bitcoin network. </p><br><p>  To solve the problem of integration of compact nodes in the network, it is proposed to introduce an additional class of nodes - <em>bridges</em> .  A bridge node is a complete node that, among other things, stores a Utreexo battery and proof of inclusion for <strong>all</strong> UTXOs from UTXO-set.  Bridges calculate new hashes and update battery and evidence as new blocks arrive with transactions.  Support and update of the battery and evidence does not impose additional computational load on such nodes.  Bridges sacrifice disk space: order required <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  hashes compared to <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">g</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  hashes for compact nodes, where n is the power of the UTXO set. </p><br><h3 id="arhitektura-seti">  Network architecture </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Bridges make it possible to gradually add compact nodes to the network without changing the software of existing nodes.  Full nodes work as before, spreading transactions and blocks among themselves.  The bridge nodes represent the complete nodes, which additionally store the Utreexo battery data and a set of evidence of inclusion for <strong>all</strong> UTXOs at the moment.  The bridge node does not advertise itself as such, pretending to be a full node for all full nodes and a compact node for all compact ones.  Although bridges connect both networks together, in reality you only need to connect them in one direction: from the existing full nodes to the compact nodes.  This is possible because the transaction format does not need to be changed, and evidence for UTXO for compact nodes can be discarded, so any compact node can also send transactions to all network participants without the participation of bridge nodes. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  We looked at the Utreexo battery and implemented its prototype in Rust.  Considered the network architecture, which will integrate nodes based on the battery.  The advantage of a compact catch is the size of the stored data, which depends logarithmically on the power of the UTXO set, which greatly reduces the requirements for disk space and storage performance for such nodes.  The disadvantage is the additional traffic of nodes for the transfer of evidence, but evidence aggregation techniques (when one evidence proves the existence of several elements) and caching can help keep traffic within acceptable limits. </p><br><p>  <strong>References</strong> : </p><br><ul><li>  <a href="https://github.com/eupn/utreexo-rs">Utreexo prototype github on Rust</a> </li><li>  <a href="https://www.crunchbase.com/person/thaddeus-dryja">Thaddeus Dryja</a> - <a href="https://eprint.iacr.org/2019/611.pdf">Utreexo: a dynamic hash-based accumulator optimized for the Bitcoin UTXO set</a> </li><li>  <a href="https://drive.google.com/file/d/1JDNo3s9mRo6qq0uaPifWYVhLKM_Prpbf/view%3Fusp%3Dsharing">Animated illustrations from the article</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456424/">https://habr.com/ru/post/456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456412/index.html">A controversial innovation from Yandex - login to your account through a letter</a></li>
<li><a href="../456414/index.html">Protection against fires in data centers, or how data integrity is ensured</a></li>
<li><a href="../456416/index.html">The book "Agile for all"</a></li>
<li><a href="../456418/index.html">A brief history of cheating in video games</a></li>
<li><a href="../456422/index.html">The announcement of the new version of Styled Components v5: Fangs</a></li>
<li><a href="../456426/index.html">BASS - framework for automatic synthesis of antivirus signatures</a></li>
<li><a href="../456428/index.html">How to implement a BI-approach to data analysis: practical recommendations</a></li>
<li><a href="../456430/index.html">The eternal question of technical duty</a></li>
<li><a href="../456432/index.html">Security Week 25: Evernote Vulnerability and Hundreds of Hacked Online Stores</a></li>
<li><a href="../456434/index.html">Professions of the future: "Who will you work on Mars?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>