<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blending Modes in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have probably heard about the blend modes , which are present in most popular programs for working with images and video. There it is - an import...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blending Modes in Unity</h1><div class="post__text post__text-html js-mediator-article">  Many have probably heard about the <a href="https://en.wikipedia.org/wiki/Blend_modes">blend modes</a> , which are present in most popular programs for working with images and video.  There it is - an important tool for creating content, has long become an integral part of them. <br><br>  And what about the games? <br><br>  Let's say it became necessary to use Color Dodge mixing for a particle system, or the UI artist made beautiful graphics for the game interface, but some of its elements use some kind of Soft Light.  Or maybe you needed to subject a three-dimensional object to a Divide-blending to get the effect straight from Lynch films? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/ada/53f/79a/ada53f79a5b1467185e3ec790755bf57.png"><br><br>  In this article we will look at the principle of operation of the popular blending modes and try to recreate their effect as accurately as possible on the Unity game engine. <a name="habracut"></a><br><br><h2>  Mixing algorithms </h2><br>  First, let's figure out what we need to do.  Take for example two graphic elements and arrange them so that one overlaps the other: <br><br><img src="https://habrastorage.org/files/9b5/191/34e/9b519134ec864a3ebc4489b63cc0d0f2.png"><br><br>  In the normal (Normal) blending mode, the color of each pixel of the lower layer ( <b>a</b> ) is completely replaced by the pixel color of the layer that ‚Äúoverlaps‚Äù it ( <b>b</b> ).  Here everything is trivial: most of the graphic objects in games are ‚Äúmixed‚Äù in this way. <br><br><img src="https://habrastorage.org/files/6a3/e9b/72e/6a3e9b72ed9d4c698464f5990ff1ce45.png"><br><br>  In Screen mode, the pixel colors of both layers are inverted, multiplied, and then inverted again.  We implement this algorithm in <a href="https://en.wikipedia.org/wiki/Cg_%2528programming_language%2529">Cg language</a> : <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> Screen (fixed4 a, fixed4 b) { <span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> r = <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - (<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - a) * (<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - b); <span class="hljs-attribute"><span class="hljs-attribute">ra</span></span> = ba; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> r; }</code> </pre> <br>  Note that in the alpha component of the resulting color ( <b>ra</b> ), we transfer the alpha value of the upper layer ( <b>ba</b> ) in order to preserve the ability to independently control the level of transparency of the material. <br><br><img src="https://habrastorage.org/files/d1e/29a/c0d/d1e29ac0dd0d4d4eade9a5bd4a1c6d01.png"><br><br>  Overlay algorithm works conditionally: for the "dark" areas the colors are multiplied, and for the "light" ones the analogue of the Screen mode is used. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> Overlay (fixed4 a, fixed4 b) { <span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> r = a &lt; .<span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> * a * b : <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - a) * (<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - b); <span class="hljs-attribute"><span class="hljs-attribute">ra</span></span> = ba; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> r; }</code> </pre><br><img src="//habrastorage.org/files/390/634/f54/390634f5435748dd8da8dc8828625b05.png"><br><br>  Blending mode Darken compares the values ‚Äã‚Äãof each of the three color channels for the two layers and leaves the one that is ‚Äúdarker‚Äù. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> Darken (fixed4 a, fixed4 b) { <span class="hljs-attribute"><span class="hljs-attribute">fixed4</span></span> r = min(a, b); <span class="hljs-attribute"><span class="hljs-attribute">ra</span></span> = ba; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> r; }</code> </pre><br>  Most of the other modes operate according to similar schemes.  If you're interested, the implementation of another 18 mixing algorithms for Cg can be found here: <a href="https://gist.github.com/Elringus/d21c8b0f87616ede9014">gist.github.com/Elringus/d21c8b0f87616ede9014</a> <br><br>  So, our task in general form can be formulated as follows: for each pixel of the object's material ( <b>b</b> ), find the pixel that is ‚Äúunder it‚Äù ( <b>a</b> ) and, using the selected algorithm, ‚Äúmix‚Äù them. <br><br><h2>  Implementing with GrabPass </h2><br>  Having received all the necessary mixing algorithms, it may seem that things are small: you only need to get <b>a</b> - the color of the pixels that are located ‚Äúunder‚Äù our object.  However, this stage turned out to be the most problematic in practical implementation. <br><br>  The fact is that it is impossible to access the contents of the frame buffer (frame buffer) in which that ‚Äúback layer‚Äù is located during the execution of the fragment shader (fragment shader) due to the operating logic of the rendering pipeline (rendering pipeline): <br><br><img src="//habrastorage.org/files/739/3c9/093/7393c90933b84e138a9e2539298f4f4a.png"><br><br>  The final image (final image) is formed after the execution of the fragment shader; accordingly, we cannot directly receive it during the execution of the Cg program.  So you need to look for workarounds. <br><br>  In fact, the need for data on the final image within the fragment shader arises quite often.  The implementation of most post-processing effects, for example, is unthinkable without access to the ‚Äúfinal picture‚Äù.  For such cases, there is a so-called render to texture: the data from the frame buffer is copied into a special texture, from which it is then read the next time the fragment shader is executed: <br><br><img src="//habrastorage.org/files/98f/fd6/56c/98ffd656cc424cd5835e9bba7cf13708.png"><br><br>  In Unity, there are several ways to work with render textures.  In our case, the most appropriate use of <a href="http://docs.unity3d.com/Manual/SL-GrabPass.html">GabPass</a> is a special type of ‚Äúpassage‚Äù (pass) that captures the contents of the screen into the texture where the object will be drawn.  Just what we need! <br><br>  Let's create a simple shader for UI-graphics, add GrabPass to it and return from the fragment function the result of color mixing using the Darken algorithm: <br><br><div class="spoiler">  <b class="spoiler_title">GrabDarken.shader</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "Custom/GrabDarken" { Properties { _MainTex ("Sprite Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color ("Tint", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { "Queue" = "Transparent" "RenderType" = "Transparent" } Blend SrcAlpha OneMinusSrcAlpha GrabPass { } Pass { CGPROGRAM #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" #pragma vertex ComputeVertex #pragma fragment ComputeFragment sampler2D _MainTex; sampler2D _GrabTexture; fixed4 _Color; struct VertexInput { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float2 texcoord : TEXCOORD0; }; struct VertexOutput { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; fixed4 color : COLOR; half2 texcoord : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> screenPos : TEXCOORD1; }; VertexOutput ComputeVertex (VertexInput vertexInput) { VertexOutput vertexOutput; vertexOutput.vertex = mul(UNITY_MATRIX_MVP, vertexInput.vertex); vertexOutput.screenPos = vertexOutput.vertex; vertexOutput.texcoord = vertexInput.texcoord; vertexOutput.color = vertexInput.color * _Color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertexOutput; } fixed4 Darken (fixed4 a, fixed4 b) { fixed4 r = min(a, b); ra = ba; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } fixed4 ComputeFragment (VertexOutput vertexOutput) : SV_Target { half4 color = tex2D(_MainTex, vertexOutput.texcoord) * vertexOutput.color; //      , //   ""    float2 grabTexcoord = vertexOutput.screenPos.xy / vertexOutput.screenPos.w; grabTexcoord.x = (grabTexcoord.x + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">.5</span></span>; grabTexcoord.y = (grabTexcoord.y + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">.5</span></span>; //    , //  V      . #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_UV_STARTS_AT_TOP grabTexcoord.y = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - grabTexcoord.y; #endif fixed4 grabColor = tex2D(_GrabTexture, grabTexcoord); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Darken(grabColor, color); } ENDCG } } Fallback "UI/Default" }</code> </pre><br></div></div><br>  To evaluate the result, let's take the same textures that we used in the graphic editor during the demonstration of blending modes: <br><br><img src="//habrastorage.org/files/4b8/f9a/c29/4b8f9ac29e034919b7bf5b07c0b16880.png"><br><br>  As you can see in the illustration, the results of the rendering of the UI graphics on Unity and the document in Photoshop are identical. <br><br>  It would be possible to dwell on this if it were not for one ‚Äúbut‚Äù: rendering to texture is a rather laborious operation.  Even on an average PC, the use of more than 100 such operations simultaneously leads to a noticeable reduction in frame rates.  The situation is aggravated by the fact that the speed of GrabPass is inversely related to the display resolution.  Imagine what would be the performance in the case of performing a similar procedure on any iPad with ultra-high resolution display?  In my case, even a pair of UI objects with ‚Äúunconventional‚Äù mixing in an empty scene led to a drop in FPS below 20. <br><br><h2>  Implementing with Unified Grab </h2><br>  One optimization suggests itself: why not use a single GrabPass?  The original image within the frame remains unchanged, so you can ‚Äúremove‚Äù it once and then use it for all subsequent blending operations. <br><br>  Unity provides us with a convenient way to realize our plans.  It is enough to pass to the GrabPass construction a string with the name of a variable in which we want to store the ‚Äúcommon‚Äù render texture: <br><br><pre> <code class="hljs objectivec">GrabPass { <span class="hljs-string"><span class="hljs-string">"_SharedGrabTexture"</span></span> }</code> </pre><br>  Now, any instance of a material using this shader will receive information from the general render texture and will not perform an expensive GrabPass if it has already been executed by one of the instances.  Thus, we get the opportunity to use a large number of mixing operations at a time without serious performance problems. <br><br>  Unfortunately, this solution has one major drawback: since different objects use the same information about the image of the ‚Äúback layer‚Äù, this layer becomes identical for them.  That is, such objects "do not see" each other and do not take this information into account when mixing. <br><br>  The problem becomes apparent if two objects are ‚Äúsuperimposed‚Äù on each other that use blending: <br><br><img src="//habrastorage.org/files/3a2/c83/43f/3a2c8343fd5144fc97d1ddf8185db229.png"><br><br>  In addition, even one GrabPass can be too ‚Äúexpensive‚Äù for most mobile devices, which means that you need to look for alternative approaches. <br><br><h2>  Implementing with BlendOp </h2><br>  Once using GrabPass in any form is too expensive, try to do without it.  One of the options: try to change the blend mode, which is performed after the fragment shader (within the Unity rendering pipeline): <br><br><img src="//habrastorage.org/files/935/d8c/83d/935d8c83dce243bdb66ccc257dbee86c.png"><br><br>  This stage is mainly used for processing translucent objects and the possibilities of its modification are severely limited - you will not insert instructions on Cg there.  It is possible only with the help of a set of key phrases to configure how the color obtained from the fragment shader should (and should it at all) interact with the color that is ‚Äúbehind‚Äù it. <br><br>  The operation is defined by the following construction: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Blend</span></span> SrcFactor DstFactor</code> </pre><br>  The logic is that the source color (obtained from the fragment shader) is multiplied by the value returned by the first operand ( <b>SrcFactor</b> ), the target color (the color of the ‚Äúback‚Äù layer) is multiplied by the second operand ( <b>DstFactor</b> ) and the resulting values ‚Äã‚Äãare added.  The list of operands, in turn, is quite limited: you can operate with ones, zeros, source and target colors, as well as the results of their inversion. <br><br>  The optional BlendOp command, which allows replacing the result of two operands with subtraction, taking the minimum or maximum, expands the possibilities somewhat. <br><br>  Having shown a little imagination, I was able to implement the following mixing algorithms: <br><br><ul><li>  Darken: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">BlendOp</span></span> Min Blend One One</code> </pre><br></li><li>  Lighten: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">BlendOp</span></span> Max Blend One One</code> </pre><br></li><li>  Linear Burn: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">BlendOp</span></span> RevSub Blend One One</code> </pre><br></li><li>  Linear Dodge: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">Blend</span></span> One One</code> </pre><br></li><li>  Multiply: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">Blend</span></span> DstColor OneMinusSrcAlpha</code> </pre><br></li></ul><br>  Modify our shader for mixing UI graphics in Darken mode to use BlendOp: <br><br><div class="spoiler">  <b class="spoiler_title">BlendOpDarken.shader</b> <div class="spoiler_text"><pre> <code class="hljs mel">Shader <span class="hljs-string"><span class="hljs-string">"Custom/BlendOpDarken"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span> = <span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } BlendOp Min Blend One One Pass { CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #pragma vertex ComputeVertex #pragma fragment ComputeFragment sampler2D _MainTex; fixed4 _Color; struct VertexInput { float4 vertex : POSITION; float4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> : COLOR; float2 texcoord : TEXCOORD0; }; struct VertexOutput { float4 vertex : SV_POSITION; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> : COLOR; half2 texcoord : TEXCOORD0; }; VertexOutput ComputeVertex (VertexInput vertexInput) { VertexOutput vertexOutput; vertexOutput.vertex = mul(UNITY_MATRIX_MVP, vertexInput.vertex); vertexOutput.texcoord = vertexInput.texcoord; vertexOutput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vertexInput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> * _Color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertexOutput; } fixed4 ComputeFragment (VertexOutput vertexOutput) : SV_Target { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, vertexOutput.texcoord) * vertexOutput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; } ENDCG } } Fallback <span class="hljs-string"><span class="hljs-string">"UI/Default"</span></span> }</code> </pre><br></div></div><br>  For the demonstration we will use all the same textures: <br><br><img src="//habrastorage.org/files/0aa/b60/f73/0aab60f73b7a4a45aedfc06199e36ab2.png"><br><br>  The problem is obvious: due to the fact that we use the blending stage ‚Äúto fit our needs‚Äù, alpha blending is nowhere to go and the transparency of objects is simply ignored.  On the other hand, opaque objects are mixed correctly and without loss in performance.  So, if it is necessary to use one of the modes, which is possible to recreate using the Blend construction and the object does not have transparent areas, this is probably the best option. <br><br><h2>  Implementing with Framebuffer Fetch </h2><br>  Earlier, I mentioned that it is impossible to access the frame buffer from a fragment shader.  In fact this is not true. <br><br>  In 2013, the <a href="https://www.khronos.org/registry/gles/extensions/EXT/EXT_shader_framebuffer_fetch.txt">EXT_shader_framebuffer_fetch</a> function was added to the <a href="https://ru.wikipedia.org/wiki/OpenGL_ES">OpenGL ES 2.0</a> <a href="https://www.khronos.org/registry/gles/extensions/EXT/EXT_shader_framebuffer_fetch.txt">specification</a> , which allows access to the frame buffer data from a fragment shader.  A few months ago, in the release of Unity 4.6.3, support for this feature from Cg was announced. <br><br>  We modify our shader to use Framebuffer Fetch: <br><br><div class="spoiler">  <b class="spoiler_title">FrameBufferFetchDarken.shader</b> <div class="spoiler_text"><pre> <code class="hljs mel">Shader <span class="hljs-string"><span class="hljs-string">"Custom/FrameBufferFetchDarken"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span> = <span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #pragma vertex ComputeVertex #pragma fragment ComputeFragment sampler2D _MainTex; fixed4 _Color; struct VertexInput { float4 vertex : POSITION; float4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> : COLOR; float2 texcoord : TEXCOORD0; }; struct VertexOutput { float4 vertex : SV_POSITION; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> : COLOR; half2 texcoord : TEXCOORD0; }; VertexOutput ComputeVertex (VertexInput vertexInput) { VertexOutput vertexOutput; vertexOutput.vertex = mul(UNITY_MATRIX_MVP, vertexInput.vertex); vertexOutput.texcoord = vertexInput.texcoord; vertexOutput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = vertexInput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> * _Color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertexOutput; } fixed4 Darken (fixed4 a, fixed4 b) { fixed4 r = <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(a, b); ra = ba; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } fixed4 ComputeFragment (VertexOutput vertexOutput #ifdef UNITY_FRAMEBUFFER_FETCH_AVAILABLE , inout fixed4 fetchColor : COLOR0 #endif ) : SV_Target { half4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = tex2D(_MainTex, vertexOutput.texcoord) * vertexOutput.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; #ifdef UNITY_FRAMEBUFFER_FETCH_AVAILABLE fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = fetchColor; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = fixed4(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Darken(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>); } ENDCG } } Fallback <span class="hljs-string"><span class="hljs-string">"UI/Default"</span></span> }</code> </pre><br></div></div><br><br><img src="//habrastorage.org/files/98e/497/a6f/98e497a6fa0f4bc2ae6758f40c58a482.png"><br><br>  Perfect.  It would seem, what else is needed?  No unnecessary operations, maximum performance, you can implement any mixing logic ... Only the illustration above is a fragment of the screenshot taken from the iPad Air.  But, for example, in the Unity editor our shader will simply refuse to work. <br><br>  The problem is that the OpenGL ES specification support is fully implemented only in devices running iOS.  On other platforms (even if their graphics subsystem uses the OpenGL ES API), this function may not work, so you cannot count on cross-platform functionality. <br><br><h2>  Conclusion </h2><br>  We looked at four implementations of blending modes on the Unity game engine: <br><br><ul><li>  <b>GrabPass is the</b> most resource-intensive, but reproduces all blending modes as accurately as possible; </li><li>  <b>Unified Grab</b> is a GrabPass optimization, seriously gains in performance while simultaneously performing several blending operations, but eliminates the possibility of mixing objects with each other; </li><li>  <b>BlendOp</b> works as fast as possible, however, it allows you to implement only a limited number of modes and does not support translucent materials; </li><li>  <b>Frame Buffer Fetch</b> works just as quickly, correctly reproduces all modes, but its use is possible only on devices running iOS. </li></ul><br>  The only universal and cross-platform solution could not be found, however, the combination of the presented options will allow to use the "mixing" in most cases. <br><br>  In conclusion, I want to offer a video with a demonstration of some blending modes applied to particle effects, GUI elements, three-dimensional objects and sprites in Unity: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/t42HHIw4Apw%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjZ2ZFrRWde6Hj3KyW2vJ6tz9xMpg" frameborder="0" allowfullscreen=""></iframe><br><br>  Also, I‚Äôm taking a chance (AppEngine - you stand up, I know!) To post a link to the WebGL assembly, where you can <a href="http://elringus.me/static/blend-modes-webgl/">experiment online with different blending modes</a> . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/256439/">https://habr.com/ru/post/256439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256427/index.html">Ubuntu 15.04 released (Vivid Vervet)</a></li>
<li><a href="../256431/index.html">Automatic 3D packaging size scanner</a></li>
<li><a href="../256433/index.html">Remote launch in PyCharm Community Edition</a></li>
<li><a href="../256435/index.html">Visual Studio Online. What is it and what does it eat?</a></li>
<li><a href="../256437/index.html">Webinar recording: "Methods of protecting information based on Azure, Backup (Microsoft, Veeam, BackupExec) and Azure Site Recovery"</a></li>
<li><a href="../256441/index.html">Open access to research results</a></li>
<li><a href="../256443/index.html">Pointers in C ++. Introduction</a></li>
<li><a href="../256445/index.html">Performance evaluation of Django Session Engine configurations</a></li>
<li><a href="../256451/index.html">We crack D-Link DIR-890L</a></li>
<li><a href="../256453/index.html">City laboratory of data analysis: we assemble a team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>