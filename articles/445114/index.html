<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improved sandboxing for groovy scripts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: In developing the CUBA Platform, we have laid into this framework the ability to execute custom scripts for more flexible customi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improved sandboxing for groovy scripts</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>From the translator: In developing the <a href="https://www.cuba-platform.ru/">CUBA Platform,</a> we have laid into this framework the ability to execute custom scripts for more flexible customization of the business logic of applications.</em>  <em>Whether this opportunity is good or bad (and we are talking not only about CUBA), there are many disputes, but the fact that control over the execution of user scripts is necessary is not a matter for anyone.</em>  <em>One of the useful features of Groovy for managing the execution of custom scripts is presented in this translation of the C√©dric Champeau article.</em>  <em>Despite the fact that he recently left the Groovy development team, the community of programmers, apparently, for a long time we will enjoy the fruits of his work.</em> </p><br><p>  One of the most commonly used ways to use Groovy is scripting, since Groovy makes it easy to execute code dynamically, in runtime.  Depending on the application, the scripts may be located in different places: the file system, the database, remote services ... but most importantly, the developer of the application executing the scripts does not necessarily write them himself.  Moreover, scripts can work in a limited environment (limited memory, limit on the number of file descriptors, execution time ...), or you may want to prevent the user from using all the features of the language in the script. </p><br><p>  <strong>This post will tell you</strong> </p><br><ul><li>  why groovy is good for writing internal DSL </li><li>  What are its capabilities in terms of the security of your application? </li><li>  how to set up compilation to improve DSL </li><li> about the value of <code>SecureASTCustomizer</code> </li><li>  extensions to control types </li><li>  how to use type control extensions to make sandboxing effective </li></ul><a name="habracut"></a><br><p>  For example, imagine that you need to do so that the user can calculate mathematical expressions.  One implementation option is to embed an internal DSL, create a parser, and finally, an interpreter for these expressions.  This, of course, will have to work, but if you need to improve performance, for example, by generating bytecode for expressions instead of calculating them in the interpreter or using caching of classes generated in runtime, then Groovy is a great option. </p><br><p>  There are many options described in the <a href="http://docs.groovy-lang.org/latest/html/documentation/index.html">documentation</a> , but the simplest example is simply using the <code>Eval</code> class: </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  Code <code>1+1</code> parsed, compiled into bytecode, Groovy is loaded and executed in runtime.  Of course, in this sample code is very simple, and you will need to add parameters, but the idea is that the executable code can be arbitrary.  And this may not be exactly what you need.  In the calculator, you need to resolve something like these: </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p>  but certainly not </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p>  This is where the difficulties begin, and it also becomes clear that we need to solve several problems: </p><br><ul><li>  limit the grammar of a language to a subset of its capabilities </li><li>  prevent the execution of a code not provided by users </li><li>  prevent the execution of malicious code </li></ul><br><p>  The calculator example is fairly simple, but for more complex DSLs, people may not notice that they are writing problem code, especially if DSL is so simple that <em>non-developers</em> can use <em>it</em> . </p><br><p>  A few years ago I was in such a situation.  I developed an engine that executed Groovy ‚Äúscripts‚Äù written by linguists.  One of the problems, for example, was that they could inadvertently create an endless loop.  The code was executed on the server, and there appeared a stream devouring 100% of the CPU, after which it was necessary to restart the application server.  I had to look for a way to solve the problem without affecting DSL, tools or application performance. </p><br><p>  In fact, many people have similar needs.  Over the past 4 years, I have been talking to a lot of people who have had the same question: <em>How can I prevent users from messing around with Groovy scripts?</em> </p><br><h2 id="kastomayzery-kompilyacii">  Customizers compilation </h2><br><p>  At that time I already had my own decision and I knew that other people also developed something similar.  In the end, Guillaume Laforge suggested that I create a mechanism in Groovy core to help solve these problems.  It appeared in Groovy 1.8.0 as a <a href="http://docs.groovy-lang.org/latest/html/documentation/index.html">compiler customizer</a> . </p><br><p>  Compiler customizers are a set of classes that modify the process of compiling Groovy scripts.  You can write your customizer, but Groovy delivers: </p><br><ul><li>  import customizer, implicitly adding imports to scripts, so that users do not need to add "import" descriptions </li><li>  customizer AST (Abstract Syntax Tree) -transformations, allowing you to add AST-transformations directly into the scripts </li><li>  Secure AST customizer, limiting grammatical and syntactic language constructs </li></ul><br><p>  The customizer of AST transformations helped me solve the problem of an infinite loop using the <a href="http://docs.groovy-lang.org/latest/html/gapi/groovy/transform/ThreadInterrupt.html"><code>@ThreadInterrupt</code></a> transformation, but <a href="http://docs.groovy-lang.org/latest/html/api/org/codehaus/groovy/control/customizers/SecureASTCustomizer.html">SecureASTCustomizer</a> is the thing that is probably misunderstood in the overwhelming majority of cases. </p><br><p>  I should apologize for that.  Then I could not think of a better name.  The most important part in the name ‚ÄúSecureASTCustomizer‚Äù is <strong>AST</strong> .  The purpose of this mechanism was to restrict access to certain functions of the AST.  The word "secure" in the title is generally superfluous, and I will explain why.  There is even a post on Jenkins Kawaguchi‚Äôs famous Jenkins blog called <a href="http://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful">‚ÄúDisastrous Groovy SecureASTCustomizer‚Äù</a> .  And everything is very well written there.  SecureASTCustomizer was created without sandboxing.  It was created to restrict the language at compile time, but not execution.  Now I think the best name would be <em>GrammarCustomizer</em> .  But, as you undoubtedly know, there are three difficulties in computer science: invalidation of a cache, inventing names and an error per unit. </p><br><p>  Now imagine that you consider the secure AST customizer as a means to ensure the security of your script, and your task is not to allow the user to call <code>System.exit</code> from a script.  The documentation says that calls can be banned in special receivers, creating black or white lists.  If security is needed, I always recommend whitelists that strictly prescribe what is allowed, but not blacklists that prohibit anything.  Because hackers always think about something that you could not take into account.  I will give an example. </p><br><p>  Here's how to set up a primitive sandbox script engine using <code>SecureASTCustomizer</code> .  Although I could write them in Groovy, I give examples of Java configuration, so that the difference between the integration code and the scripts is more explicit. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li>  create a compiler configuration </li><li>  create secure AST customizer </li><li>  declare that the <code>System</code> class as the receiver of method calls is blacklisted </li><li>  add customizer to compiler configuration </li><li>  bind the configuration with the shell script interpreter, that is, we are trying to create a sandbox </li><li>  run the ‚Äúbad‚Äù script </li><li>  display the result of running the script </li></ol><br><p>  If you run this class, then during the execution of the script an error will crash: </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p>  This output is generated by an application with a secure AST customizer, which prevents the <code>System</code> class from running.  Success!  So we protected our script!  But wait ... </p><br><h2 id="secureastcustomizer-vzloman">  SecureASTCustomizer hacked! </h2><br><p>  Protect, speak?  And what if I do this: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  If you run the program again, you will see that it crashes <strong>without</strong> error and <strong>without</strong> displaying the result on the screen.  The exit code of the process is -1, which means that the user script has been launched!  What happened?  During compilation, the secure AST customizer is unable to recognize that <code>c.exit</code> is a call to the <code>System</code> method in principle, because it works at the AST level!  It analyzes the method call, but in this case the method call is <code>c.exit(-1)</code> , then it determines the receiver and checks whether it is on the white (or black) list.  In this case, the receiver is <code>c</code> , this variable is <strong>declared via def</strong> , and this is the same as declaring it as <code>Object</code> , and the secure AST customizer will think that the type of the variable <code>c</code> is <code>Object</code> , and not <code>System</code> ! </p><br><p>  In general, there are <strong>many</strong> ways to circumvent the various configurations created on the secure AST customizer.  Here are some cool ones: </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  and there may be a <strong>lot</strong> more.  The dynamic nature of Groovy eliminates the ability to fix these problems during compilation.  However, a solution exists.  One option is to rely on the standard JVM security manager.  However, this is a ponderous and voluminous solution for the entire system at once, and this is tantamount to shooting a gun at sparrows.  In addition, it does not work in all cases, for example, if you want to prohibit reading files, but not creating ... </p><br><p>  This restriction - rather, for many of us, rather a disappointment - led to the creation of a solution based on <strong>checks during execution</strong> .  This type of check has no such problems.  For example, because you will know the actual receiver type of the message before you start validating a method call.  Of particular interest are the following implementations: </p><br><ul><li>  <a href="">SecureScript</a> by Jim White </li><li>  <a href="http://groovy-sandbox.kohsuke.org/">Groovy Sandbox</a> by Kosuke Kawaguchi </li><li>  <a href="https://github.com/simon-temple/groovy-sandbox">Groovy Sandbox</a> by Simon Temple </li></ul><br><p>  However, none of these implementations are absolutely reliable and secure.  For example, the Kosuke version is based on the hacking of the internal call site caching implementation.  The problem is that it is not compatible with the invokedynamic version of Groovy, and these inner classes will not be in future versions of Groovy.  Simon's version, on the other hand, is based on AST transformations, but leaves many possible holes. </p><br><p>  In the end, me and my friends Corinne Krish, Fabrizia Matrat and Sebastian Blanc decided to create a new sandboxing mechanism in runtime that would not have problems like these projects.  We started to implement it at the hackathon in Nice, and at the Greach conference last year we <a href="http://greachconf.com/speakers/fabrice-matrat-cedric-champeau-groovy-head-in-the-cloud/">made a report about it</a> .  This mechanism is based on AST transformations and essentially rewrites the code in order to check before each method call, attempt to access the class field, increment a variable, binary expression ... This <a href="https://github.com/rivieragug/groovy-core/tree/secureruntime">implementation</a> is still not ready, and not a lot of work has been done on it. As I realized that the problem with the methods and parameters called via "implicit this" has not yet been solved, as, for example, in the builders: </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p>  To date, I still have not found a way to solve this problem because of Groovy‚Äôs meta-object protocol architecture, which is based on the fact that the receiver throws an exception when it cannot find a method before switching to another receiver.  In short, this means that you cannot find out the type of receiver before actually calling a method.  And if the call was passed, then it's too late ... </p><br><p>  Until recently, I did not have an optimal solution to this problem for the case in which the executable script uses the dynamic properties of the language.  But now it is time to explain how you can significantly improve the situation if you are ready to sacrifice a little the dynamism of the language. </p><br><h2 id="proverka-tipov">  Type Check </h2><br><p>  Let's return to the main problem with SecureASTCustomizer: it works with an abstract syntax tree and does not have information about specific message types and receivers.  But with Groovy 2, Groovy has an extra compilation, and in Groovy 2.1 we added <a href="http://docs.groovy-lang.org/latest/html/documentation/">extensions for type checking</a> . </p><br><p>  Type checking extensions are a very powerful thing: they allow the Groovy DSL developer to help the compiler with type inference, and also allow you to generate compilation errors in cases where they do not normally occur.  These extensions are used internally by Groovy to support a static compiler, for example when implementing traits or a <a href="http://docs.groovy-lang.org/latest/html/documentation/markup-template-engine.html">markup template engine</a> . </p><br><p>  What if instead of using the results of the parser, we could rely on information from the type checking mechanism?  Take the code that our hacker tried to write: </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p>  If you enable type checking, the code will not compile: </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p>  So, this code is no longer compiled.  And what if we take this code: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  As you can see, it passes the type check, being wrapped in a method and executed using the <code>groovy</code> command: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p>  The type checker detects that the <code>exit</code> method is called from the <code>System</code> class and is valid.  Here it does not help us.  But what we know is that if this code passes type checking, it means that the compiler recognizes the call to the receiver with the type <code>System</code> .  In general, the idea is to bar a call using a type checking extension. </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov">  Simple extension for type checking </h2><br><p>  Before we dive into sandboxing in detail, we‚Äôll try to ‚Äúsecure‚Äù our script with the usual type checking extension.  Registering such an extension is easy: just set the <code>extensions</code> parameter for the <code>@TypeChecked</code> annotation (or <code>@CompileStatic</code> if you are using static compilation): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p>  An extension search will occur in the classpath in source code format (you can make precompiled extensions for type checking, but we do not consider them in this article): </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li>  when type checker selects the method to call </li><li>  if the method belongs to the class <code>System</code> </li><li>  let type checker generate an error </li></ol><br><p>  That's all you need.  Now run the code again and you will see a compilation error! </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p>  This time, thanks to type checker, <code>c</code> recognized as an instance of the <code>System</code> class, and we can bar the call.  This is a very simple example, and it doesn‚Äôt demonstrate all that can be done with AST‚Äôs secure customizer in terms of configuration.  In the extension we <strong>wrote</strong> , the checks are <strong>hardcoded</strong> , but it might be better to make them customizable.  So let's make an example more complicated. </p><br><p>  Suppose your application calculates certain indicators for a document and allows users to customize them.  In this case DSL: </p><br><ul><li>  will operate (at least) on the <code>score</code> variable </li><li>  allow users to perform mathematical operations (including calling methods <em>cos</em> , <em>abs</em> , ...) </li><li>  should ban all other methods </li></ul><br><p>  Sample custom script: </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p>  This DSL is easy to configure.  This is a variant of what we defined above: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li>  add import customizer, which will add <code>import static java.lang.Math.*</code> to all scripts </li><li>  make variable <code>score</code> available for the script </li><li>  execute script </li></ol><br><p>  <em>There are ways to cache scripts instead of parsing and compiling them every time.</em>  <em>See the documentation for details.</em> </p><br><p>  So, our script works, but nothing prevents a hacker from running a malicious code.  Since we plan to use type checking, I would recommend using the <code>@CompileStatic</code> transform: </p><br><ul><li>  it activates type checking in the script and we can perform additional checks due to the type checking extension </li><li>  improve script performance </li></ul><br><p>  Implicitly adding the <code>@CompileStatic</code> annotation to scripts is quite simple.  You only need to update the compiler configuration: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p>  Now if you try to run the script again, you will see a compilation error: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p>  What happened?  If you read the script from the point of view of the compiler, it becomes clear that it does not know anything about the "score" variable.  But as a developer, you know that this is a <code>double</code> variable, but the compiler cannot derive it.  For this purpose, extensions for type checking are created: you can give the compiler additional information, and the compilation will be fine.  In this case, we need to specify that the <code>score</code> variable is of type <code>double</code> . </p><br><p>  Therefore, you can slightly change the way that the <code>@CompileStatic</code> annotation is <code>@CompileStatic</code> : </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  This ‚Äúemulates‚Äù code annotated by <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> .  Now, of course, we will need to write an extension that will recognize the <code>score</code> variable: </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li>  in case type checker cannot define a variable </li><li>  if the variable name is <code>score</code> </li><li>  let the compiler define the variable dynamically with type <code>double</code> </li></ol><br><p>  A full description of the DSL extensions for type checking can be found <a href="http://docs.groovy-lang.org/latest/html/documentation/">in this section of the documentation</a> , but here is an example of a combined compilation mode: the compiler cannot define the <code>score</code> variable.  You, as a DSL developer, <strong>know</strong> that a variable actually exists and its type is <code>double</code> , so <code>makeDynamic</code> here to say: ‚Äúok, don't worry, I know what I'm doing, this variable can be defined dynamically with <code>double</code> type ".  That's all! </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie">  First completed "secure" extension </h2><br><p>  Now let's put it all together.  We wrote one extension for type checking, which prevents calls to methods of the <code>System</code> class, on the one hand, and the other, which defines the <code>score</code> variable, on the other.  So, if we connect them, we get the first full extension for type checking: </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p>  Remember to update the configuration in your Java class to use the new extension for type checking: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Run the code again - it still works.  Now try this: </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p>  Script compilation will crash with the error: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  Congratulations, you just wrote the first type-checking extension that prevents malicious code from running! </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya">  Enhanced Expansion Configuration </h2><br><p>  So, everything is going well, we can prohibit calls to methods of the <code>System</code> class, but it seems that new vulnerabilities will soon be discovered, and we will need to prevent the launch of malicious code.  So instead of hardcoding everything in an extension, we will try to make our extension universal and customizable.  This is probably the most difficult, because there is no direct way to pass context to an extension for type checking.  The idea is thus based on using the thread local variable (curve method, yes) to transfer configuration data to the type checker. </p><br><p>  First, we will make the list of variables customizable.  This is what Java code will look like: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    ‚Äî <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> ‚Äî   ‚Äú  ‚Üí  ‚Äù </li><li>      <code>score</code> </li><li> <code>options</code> ‚Äî     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  Exactly what is needed!        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       ‚Äî    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , ‚Äî  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/445114/">https://habr.com/ru/post/445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445104/index.html">Brief history of the Klipsch audio brand</a></li>
<li><a href="../445106/index.html">Round table: Additive technologies as an alternative to traditional production</a></li>
<li><a href="../445108/index.html">Not a single Falcon - fundamentally different reusable projects by ESA and ULA</a></li>
<li><a href="../445110/index.html">Computer with terminal-style drive from Fallout</a></li>
<li><a href="../445112/index.html">Unraveling vulnerability on sites</a></li>
<li><a href="../445116/index.html">The US Air Force is working on a drone with elements of AI called Skyborg</a></li>
<li><a href="../445118/index.html">In the Telegram personal chat, you can delete any messages - even strangers (added voting result)</a></li>
<li><a href="../445122/index.html">The digest of fresh materials from the world of the frontend for the last week No. 357 (March 18 - 24, 2019)</a></li>
<li><a href="../445124/index.html">Moderate Hardening for Firefox</a></li>
<li><a href="../445126/index.html">Reverse engineering applications after obfuscation (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>