<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KISS - the design principle, containing all other design principles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will try to explain the essence of the KISS design principle simply and at the same time in great detail. KISS is a very general and abstract design...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KISS - the design principle, containing all other design principles</h1><div class="post__text post__text-html js-mediator-article">  I will try to explain the essence of the KISS design principle simply and at the same time in great detail.  KISS is a very general and abstract design principle that contains almost all other design principles.  Design principles describe how to write "good" code.  However, what does good code mean?  Some people think that this is a code that runs as quickly as possible, some - that this is a code that involves as many design patterns as possible ... But the right answer lies on the surface.  The code is pure information.  And the main criteria for the value of information are 1) reliability 2) accessibility 3) understandability.  Why credibility and availability are important is obvious.  From the code there is no use, if it works with errors or if the server with the application "lies".  Why is clear code important?  In a clear code, it is easier to look for errors, it is easier to change, modify and maintain.  So, clarity is the main value to which the programmer should strive.  However, there is one discrepancy.  The fact is that clarity is a purely subjective thing. <a name="habracut"></a>  We need some more objective criterion of clarity.  And this criterion is simplicity.  Indeed, a simple application is more understandable than a complex one.  However, simplicity is difficult to achieve.  Here is what Peter Goodwin writes in his book The Craft of the Programmer: <br><blockquote>  If the project is simple, it is easy to understand ... Developing a simple project is not so easy.  It takes time.  For any complex program, the final solution is obtained by analyzing a huge amount of information.  When the code is well designed, it seems that it could not be otherwise, but it is possible that its simplicity is achieved as a result of intense mental work (and a large amount of refactoring).  Making a simple thing is difficult.  If the structure of the code seems obvious, do not think that it was easy. <br></blockquote><br>  <b>So, the KISS design principle (keep it simple and straightforward) proclaims that the simplicity of the code is above all, because simple code is the most understandable.</b> <br>  Almost all design principles are aimed at achieving clarity of the code.  Violating any design principle, you reduce the clarity of the code.  The incomprehensible code automatically causes the person to feel that the code is complex, since it is difficult to understand and modify it.  If any of these principles are violated, the KISS principle is also violated.  Therefore, it can be said that KISS includes almost all other design principles. <br>  Design patterns describe the most successful, simple and clear solutions to some problems.  If you use the design pattern where there is no problem that this pattern solves, then you break KISS by introducing unnecessary complications into the code.  If you do NOT use the design pattern where there is a problem matching the pattern, then again you are breaking KISS, making the code harder than it could be. <br><br>  <b>In my opinion, the KISS principle can be useful only for novice designers</b> who do not know or do not understand the basic principles of design.  KISS protects against misuse of design principles and patterns.  Since the principles and patterns are designed to increase the clarity of the code, their correct use can not lead to a decrease in the clarity of the code.  However, if you misunderstand the design principle (for example, interpret ‚Äúdo not multiply unnecessary entities‚Äù as ‚Äúproduce as few entities as possible‚Äù), or by observing one principle you violate a dozen others, then KISS can be a reliable airbag for you.  In other cases, there is little confusion from KISS, since  It is too general and abstract.  The remaining principles are more specific and contain more obvious ways to achieve comprehensibility and simplicity of the code. <br><br>  Due to the fact that the ideas of different people about such a concept as ‚Äúsimplicity‚Äù may differ, the following <b>misconceptions regarding KISS-a</b> have become widespread: <br>  <i>Misconception 1.</i> If we assume that simple code is such a code that is easiest to write, then we can interpret that the KISS principle calls for writing the first thing that comes to mind, without thinking about design at all. <br>  <i>Misconception 2.</i> If we assume that simple code is such a code that requires as little knowledge as possible to write, then we can interpret that the KISS principle calls for not using design patterns. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By simplicity, in this case it should be understood as <a href="http://www.classes.ru/all-russian/russian-dictionary-Ushakov-term-59601.htm">not complicated, devoid of artificiality, the most natural, not difficult, easily accessible to understand</a> . <br><br><h4>  <u><b>C # example</b></u> </h4><br><br>  Task: When crossing figures, it is necessary to shade the area of ‚Äã‚Äãtheir intersection. <br>  So how to develop a universal hatching algorithm for different combinations <br>  shapes (rectangle-rectangle, rectangle-polygon, <br>  polygon-polygon, ellipse-polygon, ellipse-ellipse) pretty <br>  difficult and most likely it will not be very effective, then we realize for everyone <br>  option your algorithm. <br><br>  What the first thing that comes to mind looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Expand Code</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IShape</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Circle</span></span> : <span class="hljs-title"><span class="hljs-title">IShape</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Rectangle</span></span> : <span class="hljs-title"><span class="hljs-title">IShape</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RoundedRectangle</span></span> : <span class="hljs-title"><span class="hljs-title">IShape</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IntersectionFinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IShape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IShape shape, IShape shape2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shape <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Circle &amp;&amp; shape2 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Rectangle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Circle, shape2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Rectangle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shape <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Circle &amp;&amp; shape2 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> RoundedRectangle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Circle, shape2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RoundedRectangle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shape <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> RoundedRectangle &amp;&amp; shape2 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Rectangle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RoundedRectangle, shape2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Rectangle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape2, shape); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IShape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Circle circle, Rectangle rectangle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoundedRectangle(); <span class="hljs-comment"><span class="hljs-comment">//     Rectangle  Circle,     .          RoundedRectangle } private IShape FindIntersection(Circle circle, RoundedRectangle rounedeRectangle) { return new Circle(); } private IShape FindIntersection(RoundedRectangle roundedRectanglerectangle, Rectangle rectangle) { return new Rectangle(); } }</span></span></code> </pre> <br></div></div><br><br>  However, this code contradicts two points from the definition of simplicity: the most natural and easily accessible.  The code is not natural, because there is some kind of artificial class IntersectionFinder.  The code is not easily accessible, because a person unfamiliar with the code will need to look through all the places of use of IShape in order to understand whether the functionality for calculating the intersection of shapes is implemented and how it is used.  In projects that have several tens (or even hundreds) of thousands of lines of code, this may not be a quick task.  There is one more unpleasant moment that adds difficulties to working with the IntersectionFinder class: the number of functions named FindIntersection increases as an arithmetic progression from the number of figures, as a result of which the IntersectionFinder class ‚Äúswells up‚Äù very quickly and with a large number of figures the search for the desired function in it becomes expensive on time occupation.  Therefore, we transfer FindIntersection to IShape. <br><br><div class="spoiler">  <b class="spoiler_title">Expand Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IShape</span></span> { <span class="hljs-function"><span class="hljs-function">IShape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IShape shape</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Circle</span></span> : <span class="hljs-title"><span class="hljs-title">IShape</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IShape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IShape shape</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shape <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Rectangle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Rectangle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shape <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> RoundedRectangle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindIntersection(shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RoundedRectangle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shape.FindIntersection(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IShape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Rectangle rectangle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoundedRectangle();<span class="hljs-comment"><span class="hljs-comment">//     Rectangle  Circle,     .          RoundedRectangle } private IShape FindIntersection(RoundedRectangle rounedeRectangle) { return new Circle(); } } public class Rectangle : IShape { public IShape FindIntersection(IShape shape) { if (shape is RoundedRectangle) return FindIntersection(shape as RoundedRectangle); return shape.FindIntersection(this); } private IShape FindIntersection(RoundedRectangle roundedRectangle) { return new Rectangle(); } } public class RoundedRectangle : IShape { public IShape FindIntersection(IShape shape) { return shape.FindIntersection(this); } }</span></span></code> </pre><br></div></div><br><br>  Great, now a programmer unfamiliar with the code will not have to look for a way to make the intersection of two shapes across the entire project.  The redundant Essence Evaluator entity has disappeared.  The code has become more natural and easily accessible, which means it is simpler.  Now, when creating a new type of shape, you do not need to make changes to the previously created classes, which means adding new types of shapes is also easier.  It is easier to find a specific algorithm for finding an intersection, since now you do not need to search for it in a giant class among a multitude of methods with the same name. <br><br>  But now we notice that the method of deciding which particular function to calculate the intersection needs to be called is not devoid of artificiality.  A more natural approach would be: to call a function called FindIntersection, the type of the argument of which coincides with the type of the second figure. <br><br><div class="spoiler">  <b class="spoiler_title">Expand Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Shape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Shape shape</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = MethodFinder.Find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType(), <span class="hljs-string"><span class="hljs-string">"FindIntersection"</span></span>, shape.GetType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Shape)method.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { shape }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shape.FindIntersection(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Circle</span></span> : <span class="hljs-title"><span class="hljs-title">Shape</span></span> { [UsedImplicitly] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Shape </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Rectangle rectangle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoundedRectangle();<span class="hljs-comment"><span class="hljs-comment">//     Rectangle  Circle,     .          RoundedRectangle } [UsedImplicitly] private Shape FindIntersection(RoundedRectangle rounedeRectangle) { return new Circle(); } } public class Rectangle : Shape { [UsedImplicitly] private Shape FindIntersection(RoundedRectangle roundedRectangle) { return new Rectangle(); } } public class RoundedRectangle : Shape { } public static class MethodFinder { public static MethodInfo Find(Type classType, string functionName, Type parameterType) { return classType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public) .FirstOrDefault( x =&gt; x.Name == functionName &amp;&amp; x.GetParameters().Count() == 1 &amp;&amp; x.GetParameters().First().ParameterType == parameterType); } } class Program { static void Main(string[] args) { Shape shape = new Rectangle(); var shapeIntersection = shape.FindIntersection(new Circle()); Console.WriteLine(shapeIntersection.GetType()); } }</span></span></code> </pre><br></div></div><br><br>  As you can see, the public IShape FindIntersection (IShape shape) methods have disappeared from each specific shape class, the total number of lines of code has decreased.  Now add new types of shapes has become even easier.  The FindIntersection (Shape shape) method is now in the base class and looks more simple and natural ( <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2580%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">declarative</a> ).  A new MethodFinder class has been added, but the programmer does not need to know its internal structure, since  it has a clear interface and does not implement concepts from the subject area (and therefore the reasons for its changes will be rare), so the complexity of the code practically did not increase when it was added. <br>  There might be an idea that reflection is a slow thing, and to speed up, you can, for example, cache delegates that are dynamically generated by an ExpressionTree, however KISS calls for writing as simple as possible code, so you should refrain from this thought until the performance of the FindIntersection method (Shape shape) really does not become the bottleneck of the program, creating problems for the user.  But what should not be postponed is the creation of a unit test, which, through reflection, recognizes all the heirs of the Shape class and checks that the programmer has not forgotten to implement intersection search algorithms for all pairs of shapes. <br><br><div class="spoiler">  <b class="spoiler_title">View test code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ShapeTest</span></span> { [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllIntersectsMustBeRealized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapeTypes = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Shape).Assembly.GetTypes().Where(x =&gt; x.IsSubclassOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Shape))); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorMessages = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shapeTypes) <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shapeTypes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MethodFinder.Find(firstType, <span class="hljs-string"><span class="hljs-string">"FindIntersection"</span></span>, secondType) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { errorMessages.Add(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"       : {0}  {1}"</span></span>, firstType.Name, secondType.Name)); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorMessages.Any()) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>, errorMessages)); } }</code> </pre><br></div></div><br><br>  By comparing the first and third examples, it may not seem obvious that the third example is simpler.  However, let's imagine that the figure types are not 3, but 30. Then the number of shape comparison functions is 465 (the sum of an arithmetic progression (1 + 30) * 30 \ 2).  In the first case, the mechanism for selecting the desired function will be hidden behind 465 if-s (or, alternatively, behind a container with 465 pointers to methods, which is not much better), and among this pile of if-s, the programmer unfamiliar with the code will have to see some system.  Whereas in the 3rd case the approach is declarative and does not depend on the number of types of figures.  This example is good because a significant part of programmers may think that the third example is a bad decision, because it uses reflection to access private variables (which is a kind of taboo among programmers), because they have heard from reputable sources that reflection for such purposes is bad, but they cannot explain why this is bad.  This psychological phenomenon is called fixed values. <br><br><div class="spoiler">  <b class="spoiler_title">Learn about the phenomenon of fixed values</b> <div class="spoiler_text">  The description of the phenomenon is taken from the book by Chad Fowler <a href="http://habrahabr.ru/company/piter/blog/250221/">, a fanatic programmer</a> and is demonstrated on the example of monkey fishing. <br>  The inhabitants of South India, who were harassed by monkeys for many years, came up with an original way of catching them.  They dug a deep narrow hole in the ground, then expanded the bottom of the hole with a thin object of the same length.  After that, rice was poured into a wider part of the bottom of the hole.  Monkeys love to eat.  In fact, it is mainly because of this that they are so annoying.  They will jump on cars or risk running through a large crowd of people to snatch food right out of your hands.  Residents of South India know this too well.  (Believe me, it‚Äôs very unpleasant when you are standing in the middle of a park and suddenly at great speed a monkey starts to run at you to grab something.) So, the monkeys came up, found rice and put their hands in a hole.  Their hands were down.  They eagerly seized as much rice as possible, gradually folding their palms into fists.  The fists occupied the volume of the wide part of the burrow, and the upper part was so narrow that the monkey could not squeeze the fists through it.  And she was trapped.  Of course, they could just refuse to eat and stay free.  But monkeys attach great importance to food.  In fact, food is so important to them that they cannot bring themselves to give it up.  They will squeeze the rice until they pull it out of the ground or die trying to pull it out.  Usually the second came earlier.  Fixing values ‚Äã‚Äãis when you believe in the value of something so much that you can no longer objectively question it.  Monkeys value rice so highly that when they have to choose between rice and a death captive, they cannot understand that now it is better to lose rice.  The story presents monkeys very silly, but most of us have our equivalent of rice.  If you were asked if it was good to help the starving children of the third world countries with food, you most likely would have answered without thinking ‚Äúyes‚Äù.  If anyone tried to challenge your point of view, you would decide that he is crazy.  This is an example of fixed value.  You are convinced of something so strongly that you cannot imagine how you can not believe in it.  And in this case, fixed value is the belief that using reflection to access private methods is bad. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Find out why the use of reflection to access private methods in this case is not blasphemous</b> <div class="spoiler_text">  In fact, calling private methods outside the data type within which the method is declared is a violation of encapsulation.  However, no matter how surprising this may sound, in this example the encapsulation is not broken.  Conceptually, the parent class and the derived class are the same data type.  The parent's code, encapsulated from the outside world, can be called in the (protected) heir, while the parent can call the encapsulated (virtual) inherited methods (protected virtual).  If you delve into the "insides" of the heir class, you will inevitably have to look at the internal structure of the parent class, and if the parent, in turn, also has a parent, then his internal structure also.  Many developers are aware of this feature and prefer to use composition instead of inheritance (if the situation allows it). <br></div></div><br><br>  This example clearly demonstrates how, using KISS and trying to make the code simpler, you can come to a better solution to the problem, even if your wrong understanding of certain principles or taboos tells you to use a ‚Äúcrutch‚Äù instead of a declarative code that fully reflects <u>the</u> developer‚Äôs <u>intention</u> . <br><br>  A bit of history. <br>  The KISS principle originated in the aircraft industry and is historically translated as ‚ÄúKeep it simple stupid‚Äù and stands for ‚Äúmake it simple to idiocy‚Äù.  In the history of the aircraft industry there are cases when too zealous workers nailed extra armor plates on the plane to make the aircraft more resilient in battle, as a result of which the mass of the aircraft became more calculated and the plane simply could not take off.  In addition, the skill of many workers was low.  In such conditions, the design of the aircraft, which a drunk unskilled worker could not assemble correctly, even if he wanted, had a special value.  One of the echoes of the design decisions of the time was the impossibility of confusing and plugging the wrong plug into the socket inside the computer.  However, if the result of the labor of the aircraft engineer is the drawing according to which the product will be created, then in the case of the programmer, the product is the drawing itself (figuratively speaking).  In the case of a programmer, he must write the code so that a drunk unqualified programmer can make changes to it in accordance with the changed business requirements (that is, change the drawing, and not assemble the plane).  Due to differences in the specifics of the aircraft industry and programming, the decoding ‚ÄúKeep it simple stupid‚Äù, suitable in the aircraft industry, does not so well reflect the essence of the principle for a programmer.  Many lazy programmers decipher ‚Äúmake it simple to idiocy‚Äù as ‚Äúdon't bother with design‚Äù (compare, for example, the description of the KISS principle in this article with this <a href="http://habrahabr.ru/post/153225/">description</a> ).  Fortunately, KISS has <a href="https://en.wikipedia.org/wiki/KISS_principle">some other decoding</a> , one of which, in my opinion, best reflects the essence of KISS in programming - ‚Äúkeep it simple and straightforward‚Äù.  Straightforward translates as simple, honest, straightforward, frank.  ‚ÄúKeep it simple and straightforward,‚Äù thus, can be freely translated as ‚ÄúMake it simple and declarative,‚Äù and design is required to achieve declarativeness. <br><br>  For example, thank <a href="http://habrahabr.ru/users/Hokum/">Hokum</a> , who gave the initial idea for an example, which I changed a little. </div><p>Source: <a href="https://habr.com/ru/post/249639/">https://habr.com/ru/post/249639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249629/index.html">BemPHP: implementation of the BEM methodology using PHP</a></li>
<li><a href="../249631/index.html">The first development and publication of the game in social networks</a></li>
<li><a href="../249633/index.html">What is CRM-systems and how to choose them correctly?</a></li>
<li><a href="../249635/index.html">Yandex killed service Subscriptions</a></li>
<li><a href="../249637/index.html">Twitter-based bot Markov and phrases from the series</a></li>
<li><a href="../249641/index.html">Diablo 3 - Resource Bubbles</a></li>
<li><a href="../249643/index.html">New Year star with Wi-Fi based on ESP8266</a></li>
<li><a href="../249645/index.html">Kernel .Net (GC, JIT, interop, ...) in Open Source</a></li>
<li><a href="../249647/index.html">Making a queue of incoming calls with the callback function</a></li>
<li><a href="../249649/index.html">Configuring Kerio Control Firewall for 3CX Phone System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>