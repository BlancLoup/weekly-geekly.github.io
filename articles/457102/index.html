<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QVD files - what's inside, part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first article about the structure of a QVD file, I described the general structure and dealt in some detail with the metadata, in the second , ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QVD files - what's inside, part 3</h1><div class="post__text post__text-html js-mediator-article"><p>  In the <a href="https://habr.com/ru/company/alfastrah/blog/454302/">first article</a> about the structure of a QVD file, I described the general structure and dealt in some detail with the metadata, in the <a href="https://habr.com/ru/company/alfastrah/blog/455940/">second</a> , the storage of columns (characters).  In this article I will describe the format of storing information about rows, summarize, tell you about plans and achievements. </p><br><p>  So (remember) the QVD file corresponds to a relational table, in the QVD file the table is stored as two indirectly related parts: </p><br><p>  Character tables (my term) contain the unique values ‚Äã‚Äãof each column in the source table.  I talked about them in the second article. </p><br><p>  The row table contains the rows of the source table, each row stores the indices of the values ‚Äã‚Äãof the column (field) of the row in the corresponding symbol table.  This is what this article will be about. </p><a name="habracut"></a><br><p>  On the example of our tablet (remember - from the first part) </p><br><pre><code class="plaintext hljs">SET NULLINTERPRET =&lt;sym&gt;; tab1: LOAD * INLINE [ ID, NAME 123.12,"Pete" 124,12/31/2018 -2,"Vasya" 1,"John" &lt;sym&gt;,"None" ];</code> </pre> <br><p>  In the table of rows of our QVD file, this label will correspond to 5 lines - always an exact match: how many rows in a table, how many rows in the table of rows of a QVD file. </p><br><p>  A string in the string table consists of non-negative integers, each of these numbers is an index into the corresponding symbol table.  At the logical level, everything is simple, it remains to clarify the nuances and give an example (to disassemble - our table is represented in QVD). </p><br><h2 id="format-tablicy-strok">  Row table format </h2><br><p>  The string table consists of K * N bytes, where </p><br><ul><li>  K - the number of rows in the source table (value of the "NoOfRecords" tag metadata) </li><li>  N is the byte length of the string of the symbol table (the value of the "RecordByteSize" tag of the metadata) </li></ul><br><p>  The table of lines begins with the offset "Offset" (tag metadata) relative to the beginning of the binary part of the file. </p><br><p>  Information about the row table (length, row size, offset) is stored in the common part of the metadata. </p><br><h2 id="format-stroki-tablicy-strok">  Row table row format </h2><br><p>  All rows of the string table have the same format and are a concatenation of "unsigned numbers".  The length of the number is minimal enough to represent a specific field: the length depends on the number of unique values ‚Äã‚Äãof a specific field. </p><br><p>  For fields with a single value (as I already wrote), this length will be zero (this value is the same in each row of the source table and is stored in the corresponding symbol table). </p><br><p>  For fields with two values, this length will be equal to one (the possible index values ‚Äã‚Äãin the symbol table are 0 and 1), and so on. </p><br><p>  Since the cumulative length of a row of a table of rows must be a multiple of a byte, the length of the "last character" is aligned to the byte boundary (see below when we parse our table). </p><br><p>  Information about the format of each field is stored in the metadata section dedicated to this field (let's stop a little more below), the length of the field's bit representation is stored in the "BitWidth" tag. </p><br><h2 id="hranenie-znacheniy-null">  Storing null values </h2><br><p>  How to store missing values?  Refraining from reasoning on the topic of "why," I will answer as follows: as far as I understand, the following combination corresponds to NULL values </p><br><ul><li>  the "Bias" tag of the corresponding field takes the value "-2" (in total, I came across two possible values ‚Äã‚Äãof this tag - "0" and "-2") </li><li>  the field index for the line where this field is NULL is 0 </li></ul><br><p>  Accordingly, all other indices in the column with NULL values ‚Äã‚Äãare increased by 2 - we will see in our example a little lower. </p><br><h2 id="poryadok-sledovaniya-poley-v-stroke">  The order of the fields in the row </h2><br><p>  The order of the fields in the row of the table of rows corresponds to the bit offset of the field, which is stored in the "BitOffset" tag of the metadata section of the field. </p><br><p>  Let us examine our example (see the metadata in the first part of this series). </p><br><p>  ID field </p><br><ul><li>  bit offset 0 - the field will be "rightmost" </li><li>  bit length 3 - the field will occupy 3 bits in the row of the string table </li><li>  Bias is "-2" - the field has NULL values, all indices are increased by 2 </li></ul><br><p>  NAME field </p><br><ul><li>  bit offset 3 - the field is located ‚Äúto the left‚Äù of the ID field at 3 bits </li><li>  bit length 5 - the field will occupy 5 bits in the row of the string table (aligned to the byte boundary) </li><li>  Bias is "0" - the field has no NULL values, all indices are "fair" </li></ul><br><h2 id="predstavlenie-nashey-tablichki">  Presentation of our tablet </h2><br><p>  Let's look at the real "zeroes and ones" - I will give fragments of a QVD file in the form of a binary representation "in hexadecimal format" (so compact). </p><br><p>  First, the entire binary part (highlighted in pink, the metadata is cut off - it hurts a lot of them ...) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_1.png" alt="image"></p><br><p>  Compact enough, agree.  Let's take a closer look - the symbol tables are located immediately after the metadata (metadata, by the way, ended up with a newline and a null byte in the file - technically this happens, null bytes after the metadata should be skipped ...). </p><br><p>  The first symbol table is highlighted in the figure below. </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_2.png" alt="image"></p><br><p>  We see: </p><br><p>  The first unique <strong>ID field</strong> value is </p><br><ul><li>  type "6" (first allocated byte) - a floating number with a string (see the second article) </li><li>  after the first byte of the next 8 bytes, this is a binary floating number </li><li>  after them comes a string representation - very convenient (no need to remember - what was the number), ending in a zero byte </li></ul><br><p>  The remaining three unique values ‚Äã‚Äãare of type 5 (integer with string) - the values ‚Äã‚Äã"124", "-2" and "1" (it is easy to see in the lines). </p><br><p>  In the figure below, I selected the second symbol table (for the "NAME" field) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_3.png" alt="image"></p><br><p>  The first unique value of the <strong>field "NAME"</strong> - type "4" (the first byte allocated) is a string ending in zero. </p><br><p>  The other four unique values ‚Äã‚Äãare also the lines "12/31/2018", "Vaysa", "John" and "None". </p><br><p>  Now - a table of rows (highlighted in the figure below) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_4.png" alt="image"></p><br><p>  As expected - 5 bytes (5 lines of one byte). </p><br><p>  <strong>First line</strong> (corresponding to line 123.12, "Pete" of our table) </p><br><p>  The string value is byte "02" (binary 000000010). </p><br><p>  Separate it (remember the description above) </p><br><ul><li>  right 3 bits (binary 010, in our opinion, this is 2) - this is the index in the symbol table of the "ID" field </li><li>  we have the field "ID" contains NULL, so the index is increased by 2, i.e.  the total index is 0, which corresponds to the symbol "123.12". </li><li>  the next 5 bits (binary and decimal 0) are the index in the symbol table of the field "NAME", it does not contain NULL, therefore this is the index "Pete" in the symbol table. </li></ul><br><p>  <strong>The second line</strong> (124.12 / 31/2018) in the string table </p><br><p>  The value is byte "0B" (binary 00001011) </p><br><ul><li>  right 3 bits (binary 011, in our opinion it is 3) - this is the index in the symbol table of the "ID" field </li><li>  we have the field "ID" contains NULL, so the index is increased by 2, i.e.  the total index is 1, which corresponds to the symbol "124". </li><li>  the next 5 bits (binary and decimal 1) are the index in the symbol table of the "NAME" field, it does not contain NULL, therefore this is the index "12/31/2018" in the symbol table. </li></ul><br><p>  Well and so on, let's look quickly at the <strong>last line</strong> - there we had it, "None" (i.e. NULL and the string "None"): <br></p><p>  The value is byte "20" (binary 0010000) </p><br><ul><li>  the right 3 bits (binary and decimal 0) is the index to the symbol table of the "ID" field </li><li>  we have the field "ID" contains NULL, so the index is increased by 2, i.e.  the total index is -2, which corresponds to the value NULL. </li><li>  the next 5 bits (binary 100, decimal 4) is the index in the symbol table of the "NAME" field, it does not contain NULL, therefore this is the index of "None" in the symbol table. </li></ul><br><p>  <strong>IMPORTANT</strong> I can not find an example confirming this, but I came across files that contained the final index -1 for NULL values.  Therefore, in my programs I consider NULLs all fields whose total index is negative. </p><br><h2 id="bolee-dlinnye-stroki-v-tablice-strok">  Longer rows in the string table </h2><br><p>  At the end of the QVD format parsing I will briefly focus on the important nuances - the long lines in the row table store the fields in right-to-left order, where the field with zero bit offset will be the most right (as I described above).  <strong>But the</strong> byte order is reversed, i.e.  the first byte will be the rightmost (and will contain the "right" field - the field with zero bit offset), the last - the first (ie, contain the most "left" field - the field with the maximum bit offset). </p><br><p>  It is necessary to give an example, but not overload with details.  Let's look at such a label (I quote a fragment ‚Äî to get long rows in the string table, you need to increase the number of unique values). </p><br><pre> <code class="plaintext hljs">tab2: LOAD * INLINE [ ID, VAL, NAME, PHONE, SINGLE 1, 100001, "Pete1", "1234567890", "single value" 2, 200002, "Pete2", "2234567890", "single value" ... ];</code> </pre> <br><p>  In summary, the information about the fields (squeeze from metadata): </p><br><ul><li>  ID: width 8 bits, bit offset - 0, bias - 0 </li><li>  VAL: width 5 bits, bit offset - 8, bias - 0 </li><li>  NAME: width 6 bits, bit offset - 18, bias - 0 </li><li>  PHONE: width 5 bits, bit offset - 13, bias - 0 </li><li>  SINGLE: 0 bit width (one value) </li></ul><br><p>  The row table consists of rows of length 3 bytes, respectively, in a row of the row table the field data will logically decompose as follows: </p><br><ul><li>  first 6 bits - field "NAME" </li><li>  the next 5 bits is the PHONE field </li><li>  further 5 bits - the "VAL" field </li><li>  last 8 bits - ID field </li></ul><br><p>  The logical sequence is converted into physical by permutation of bytes in the reverse order, i.e. </p><br><ul><li>  the "ID" field completely occupies the first byte (which is the last in logical sequence) </li><li>  the "VAL" field occupies the lower 5 bits of the second byte </li><li>  the "PHONE" field occupies the upper 3 bits of the second byte and the lower 2 bits of the third byte </li><li>  the "NAME" field occupies the upper 6 bits of the third byte </li></ul><br><p>  Let's look at examples, here's what the first row of the table of rows looks like (highlighted in pink) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_5.png" alt="image"></p><br><p>  Field values </p><br><ul><li>  ID - binary 00000000 decimal 0 </li><li>  VAL - binary 00010, decimal 2, subtract 2 due to bias - we get 0 </li><li>  PHONE - binary 00010, decimal 2, subtract 2 due to bias - we get 0 </li><li>  NAME - binary 000000 decimal 0 </li></ul><br><p>  That is, the first line contains the first characters of the corresponding character tables. </p><br><p>  In general, it is convenient to start parsing it from the first line - it usually contains zeros as an index (so the QVD file is built that the values ‚Äã‚Äãfrom the first line fall into the symbol table). </p><br><p>  Let's take a look at the second line to fix </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_7.png" alt="image"></p><br><p>  Field values </p><br><ul><li>  ID - binary 00000001 decimal 1 </li><li>  VAL - binary 00011, decimal 3, subtract 2 for bias - we get 1 </li><li>  PHONE - binary 00011, decimal 3, subtract 2 for bias - we get 1 </li><li>  NAME - binary 000001 decimal 1 </li></ul><br><p>  Ie the second line contains the second characters from the corresponding symbol tables. </p><br><h2 id="effektivnyy-razbor-formata">  Efficient format parsing </h2><br><p>  I will share a little experience - how I technically "read" QVD. </p><br><p>  The first version was written on python (I will improve it and put it in github). </p><br><p>  It quickly became clear the main problems: </p><br><ul><li>  character tables can only be read "in a row" (it is impossible to read character number N without reading all the previous characters) </li><li>  real files "do not fit" into RAM </li><li>  of the slowest operations (except for working with files) - bit operations (unpacking the string of the string table) </li><li>  performance sags heavily on wide QVD files (when there are many columns) </li></ul><br><p>  Some of these problems can be solved by changing the language (from python to C, for example).  The part demanded some additional actions. </p><br><p>  The current fast enough implementation looks like this - the general logic is implemented on python, and the most critical operations are moved to separate C programs, launched in parallel. </p><br><p>  Short </p><br><ul><li>  character tables are written to files, indexes are additionally created for text fields, thus it is possible to read the character number N </li><li>  Work with QVD and files with character tables is implemented through memory mapped files (this is faster) </li><li>  first, parallel (with a limit on the number of processors) files with tables of characters (and indexes) are created </li><li>  further parallel (with a similar limitation) the rows of the string table are read and csv files are created (in HDFS) </li><li>  the final step is to convert these files to an ORC table (using Hive) </li><li>  C implements the creation of files with symbol tables and the creation of a CSV file for a range of lines </li></ul><br><p>  I don‚Äôt want to give figures on the performance - they will require binding to the hardware, at a qualitative level it turns out to copy the QVD file into the ORC table at about the speed of copying data over the network.  Or, in other words, to take data from QVD is quite realistic (at the household level). </p><br><p>  I also implemented the logic of creating QVD files - it works quite quickly on python (apparently, I haven‚Äôt reached large amounts yet - no need. I‚Äôll go - I will rewrite it in a similar way to the ‚Äúreading‚Äù variant). </p><br><h2 id="plany-na-buduschee">  Future plans </h2><br><p>  What's next: </p><br><ul><li>  I plan to put the Python version of the code in github (this version allows you to "explore" the QVD file - watch metadata, read and write characters, strings. The version is as simple as possible and obviously slow - without files for character tables, with sequential reading, using standard libraries for working with bits, etc.) </li><li>  I think about doing something for pandas (like read_qvd ()), holding back the fact that it will be slow on the python, as well as the fact that not every QVD will "fit" into memory, therefore </li><li>  I think about making a QVD file a data source for Spark - there shouldn't be this problem with not getting into memory (and the language there - scala is more close to the hardware) </li></ul><br><h2 id="vmesto-poslesloviya">  Instead of epilogue </h2><br><p>  For a long time I was walking around the QVD files, it seemed that "everything is complicated there."  It turned out that it was difficult, but not very good, to be served as a good push by the github, which I mentioned in the first part (a kind of catalyst).  Next was the case of technology.  To yourself and everyone to note (another confirmation) - in programming everything can be done, the question is in time and motivation. </p><br><p>  I hope I am not very tired of the details, I am ready to answer questions (in the comments or in any other way).  If there is a continuation, I will definitely write. </p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457102/">https://habr.com/ru/post/457102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457092/index.html">We study MITER ATT & CK. Mobile Matrices: Device Access. Part 5</a></li>
<li><a href="../457096/index.html">We free our hands to several analysts: API Livy to automate typical banking tasks</a></li>
<li><a href="../457098/index.html">Elegant JavaScript error handling with the Either monad</a></li>
<li><a href="../4571/index.html">"Soup" suffers from bad PR</a></li>
<li><a href="../457100/index.html">AWS Lambda - theory, familiarity</a></li>
<li><a href="../457106/index.html">The war with robo calls in the USA - who wins and why</a></li>
<li><a href="../457108/index.html">WWDC19: Getting Started with Test Plan for XCTest</a></li>
<li><a href="../45711/index.html">Evaluation of the effectiveness of advertising, and not only - correlation statistics</a></li>
<li><a href="../457110/index.html">Unit testing of C ++ and Mock Injection patterns using Traits</a></li>
<li><a href="../457112/index.html">Summary HolyJS 2019 Piter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>