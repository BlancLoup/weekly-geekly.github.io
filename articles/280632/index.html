<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming example in Puppet version 3.8 using Hiera and R10K</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We Need To Go Deeper. 
 Inception. 

 Here I want to describe programming examples / techniques. The reason is the same: there should be more docks on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming example in Puppet version 3.8 using Hiera and R10K</h1><div class="post__text post__text-html js-mediator-article">  <i>We Need To Go Deeper.</i> <i><br></i>  <i>Inception.</i> <br><br>  Here I want to describe programming examples / techniques.  The reason is the same: there should be more docks on the Internet.  In <a href="https://habrahabr.ru/post/272199/">my last article I</a> talked about installing and configuring Puppet version 3.8 using the example of Centos 6.5.  There would be the simplest example to test the client-server bundle.  Now let's see how this can be complicated and why it is necessary. <br><br><a name="habracut"></a><br><h5>  <b>Example ‚Ññ1: Using parameters in module manifests</b> </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1</span></span></span><span class="hljs-class"> { </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#    $text1 = ‚Äúour‚Äù #   $text2 = ‚Äútext‚Äù #   file { 'puppetenv file': #  ,  ¬´puppetenv file¬ª ‚Äì    #   file.     . path =&gt; '/tmp/puppetenv', #    ensure =&gt; file, #   content =&gt; "test: ${text1} - ${text2}" #      } }</span></span></span></span></code> </pre> <br><br>  Chain of transmission of our text in the parameters: <br>  <i>class ($ text1 $ text2) -&gt; file (content ($ {text1} - $ {text2})</i> <br><br><h5>  <b>Example 2: Uniform storage of parameters in the module manifest</b> </h5><br><br>  So the next level: we have many classes and we want to make an analogue of the library of variables.  Parameters can be stored in one recipe and then used throughout the module.  For example, we want to collect some system variables and add something of our own. <br><br>  A little bit of the basics: <br><br>  We go to the Master server in / etc / puppet / modules and generate the skeleton: <br><br><pre> <code class="bash hljs">puppet module generate myname-test1</code> </pre><br><br>  We press 8 times the input, because all this can then be redone.  Get the directory myname-test1, which we will rename to test1.  You need the full name if you want to knock out and upload your module to the public <a href="https://forge.puppetlabs.com/">Puppet forge</a> . <br><br>  Create the file <b>/etc/puppet/modules/test1/manifests/init.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1</span></span></span><span class="hljs-class"> ( $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envname</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params::env</span></span></span><span class="hljs-class">, </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     params $text1 = $test1::params::text1 ) inherits test1::params { #    inherits file { 'puppetenv file': path =&gt; '/tmp/puppetenv', ensure =&gt; file, content =&gt; "${env} - test: ${text1}" } }</span></span></span></span></code> </pre><br><br>  Create the file <b>/etc/puppet/modules/test1/manifests/params.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params</span></span></span><span class="hljs-class"> { $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">settings::environment</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   puppet $text1 = 'ptestint' #    }</span></span></span></span></code> </pre><br><br>  Explanations: <br>  <b>test1</b> - Module name - The root name of the project in the puppet value system. <br>  <b>init.pp, params.pp</b> - manifests - One manifest stores one class.  File name and class must match. <br>  <b>class test1</b> - the initial class, the code of which works by default with a simple call after the class via the simple <i>include test1</i> <br>  If desired, you can leave empty and create separate noun classes (see below). <br>  <b>class test1 :: params</b> is a name class.  The name params is chosen for convenience and can be any. <br><br>  You can check the syntax in advance in 2 ways: <br>  - Initially available via type command: <br><pre> <code class="bash hljs">puppet parser validate /etc/puppet/modules/test1/manifests/*</code> </pre><br><br>  - Put a more advanced spell checker <b>ppuppet-lint</b> through <i>gem install puppet-lint</i> and then check the files (at the same time you can slightly brush the syntax with the key --fix): <br><pre> <code class="bash hljs">puppet-lint --fix /etc/puppet/modules/test1/manifests/*</code> </pre><br><br>  But do not rely on them, you can easily miss an error like the wrong name of the manifest that will generate an error already when running on the client like: <br><br><pre> <code class="bash hljs">Error: Could not retrieve catalog from remote server: Error 400 on SERVER: Could not find parent resource <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'test::params'</span></span> of <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> hostclass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> production at /etc/puppet/modules/test1/manifests/init.pp:1 on node stage.test.net</code> </pre><br><br>  Again, I want to warn you that I noticed that in the 3.8.4 branch now having changed the module code, I have to restart the puppetmaster or httpd service so that the changes in the modules are applied immediately, before it did not ignore it.  Perhaps in other versions it will not appear.  I suspect that the module cache is stuck somewhere. <br><br>  Add a call to our test1 module in the <b>/etc/puppet/manifests/site.pp</b> file for the test <b>stage.test.net</b> node. <br><pre> <code class="bash hljs">node default { } node <span class="hljs-string"><span class="hljs-string">'stage.test.net'</span></span> { include test1 }</code> </pre><br><br>  Check on client: <br>  You can configure the service and wait for XX (usually 30) minutes until it works and then look at the logs.  And you can start everything manually: <br><pre> <code class="bash hljs">[root@stage ~]<span class="hljs-comment"><span class="hljs-comment"># puppet agent --test Info: Retrieving pluginfacts Info: Retrieving plugin Info: Caching catalog for stage.test.net Info: Applying configuration version '1459348679' Notice: /Stage[main]/Test1/File[puppetenv file]/ensure: defined content as '{md5}af1b5424181346c5f4827af742b07abf' Notice: Finished catalog run in 0.12 seconds [root@stage ~]# cat /tmp/puppetenv production - test: ptestint</span></span></code> </pre><br><br>  As you can see the file was successfully created.  If anyone wants to see how parameters can be reached, here is an example of a module for apache. <br><br>  The chain of transmission of our text ptestint: <br>  <i>manifests / site.pp -&gt; modules / test1 / init.pp ($ test1 :: params :: text1) -&gt; file (content ($ {text1})</i> <br><br>  Now, how can you change the default variables in /etc/puppet/manifests/site.pp, since they have higher priority. <br><pre> <code class="ruby hljs">node <span class="hljs-string"><span class="hljs-string">'stage.test.net'</span></span> { <span class="hljs-comment"><span class="hljs-comment"># include test1 class { 'test1': text1 =&gt; 'newparam', } }</span></span></code> </pre><br><br>  Check on client: <br>  ... <br>  -production - test: ptestint <br>  \ No newline at end of file <br>  + production - test: newparam <br>  \ No newline at end of file <br>  ... <br><br><br>  As you can see the update was successful. <br>  The chain of transmission of our text newparam: <br>  <i>manifests / site.pp ($ text1) -&gt; modules / test1 / init.pp (text1) -&gt; file (content ($ {text1})</i> <br><br>  Such storage of parameters is also convenient if we do not create all manifests in one directory, but have made another level in the form <b>/test1/manifests/check/time.pp</b> <br>  And then use this class anywhere through the form call: <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> { '::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::check::time</span></span></span><span class="hljs-class">': }</span></span></code> </pre><br><br><h5>  <b>Example 3: Add a template.</b> </h5><br><br>  The minus variation from the last example is that there is only one line in <b>content</b>  Therefore, it is better to use templates for generating large files. <br><br>  Add to the test: <br>  - File <b>/etc/puppet/modules/test1/manifests/usetmpl.pp</b> - new class for working with the template <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::usetmpl</span></span></span><span class="hljs-class"> ( $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envname</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params::env</span></span></span><span class="hljs-class">, </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#1 $text1 = $test1::params::text1 #2 ) inherits test1::params { file { 'puppetenv file from tmpl': path =&gt; '/tmp/puppetenv', ensure =&gt; file, content =&gt; template('test1/puppetenv.erb'), } }</span></span></span></span></code> </pre><br><br>  Changes in the replacement of the content of the text to the call of the template puppetenv.erb plus we brought everything into a separate class, although we could add the creation of the second file in init.pp. <br><br>  - The file <b>/etc/puppet/modules/test1/templates/puppetenv.erb</b> - Our generator template. <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Created by puppet Our text: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@text</span></span></span><span class="hljs-comment">1 %&gt; Env: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@envname</span></span></span><span class="hljs-comment"> %&gt; Host: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@hostname</span></span></span><span class="hljs-comment"> %&gt;</span></span></code> </pre><br><br>  The variables <b>$ {text1} are</b> here passed in Ruby format as <b>&lt;% = @ text1%&gt;</b> .  $ envname is taken from params.pp, $ text1 I again redefined in site.pp and at the same time added a ‚Äúsystem‚Äù variable (they are called facts in puppet) &lt;% = <a href="https://habrahabr.ru/users/hostname/" class="user_link">hostname</a> %&gt; <br><br>  Check on client: <br><pre> <code class="bash hljs">[root@stage ~]<span class="hljs-comment"><span class="hljs-comment"># puppet agent --test ... -production - test: newparam \ No newline at end of file +# Created by puppet +Our text: param_tmpl +Env: production +Host: stage ...</span></span></code> </pre><br><br>  Total: <br><pre> <code class="bash hljs">[root@stage ~]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/puppetenv # Created by puppet Our text: param_tmpl Env: production Host: stage</span></span></code> </pre><br>  The chain of our text param_tmpl: <br>  <i>manifests / site.pp ($ text1) -&gt; modules / test1 / init.pp :: usetmpl ($ text1) -&gt; file (content (puppetenv.erb (&lt;% = @ text1%&gt;)))</i> <br><br><h5>  <b>Example number 4: Hiera or even more centralization</b> </h5><br><br>  If you need to work with 1-10 servers, then the usual modules will be enough, but if there are more plus, the separation into subclusters went, where each module is configured in its own way, then you can get lost in the swollen parameters of the site.pp modules, or in modules of the same name and their versions.  We go deeper and tune Hiera. <br><br>  Hiera is a Ruby library; it is included by default in Puppet and helps organize data for all modules in a single directory. <br><br>  To work our storage you need: <br><br>  - Create a file <b>/etc/puppet/hiera.yaml of the following</b> form: <br><br><pre> <code class="bash hljs">:hierarchy: - <span class="hljs-string"><span class="hljs-string">"%{::clientcert}"</span></span> - <span class="hljs-string"><span class="hljs-string">"%{::custom_location}"</span></span> - <span class="hljs-string"><span class="hljs-string">"nodes/%{::fqdn}"</span></span> - <span class="hljs-string"><span class="hljs-string">"nodes/%{::environment}"</span></span> - <span class="hljs-string"><span class="hljs-string">"virtual/%{::virtual}"</span></span> - common - <span class="hljs-string"><span class="hljs-string">"%{::environment}"</span></span> :backends: - yaml :yaml: :datadir: <span class="hljs-string"><span class="hljs-string">"/etc/puppet/hieradata"</span></span></code> </pre><br><br>  Here, we are waiting for a backdoor from the system as a priority of the native file /etc/hiera.yaml <br>  T. h. You need to replace it with the symlink /etc/hiera.yaml -&gt; /etc/puppet/hiera.yaml <br><br>  - Create a folder <b>/ etc / puppet / hieradata</b> (you can give your name and specify it in: datadir) <br>  Files in this folder must have the extension .yaml and data format YAML. <br><br>  - Create file <b>/etc/puppet/hiera/common.yaml</b> <br>  For example, here we can write the second test parameter available to all nodes <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>::text2: common-hiera</code> </pre><br><br>  <i>Since</i> we set the directory as the storage point for the node parameters <i>, ‚Äúnodes /% {:: fqdn}‚Äù</i> , then for our test node we create the file <b>/etc/puppet/hiera/nodes/stage.test.net.yaml</b> .  In it, we can now set our third test parameter and a small array in which there will be a parameter and one more array <br><pre> <code class="bash hljs">testparam::text3: <span class="hljs-string"><span class="hljs-string">'node stage hiera'</span></span> arrexmpl::colors: bw: <span class="hljs-string"><span class="hljs-string">"B&amp;W"</span></span> rgb: - red - blue - green</code> </pre><br><br>  Checking the availability of parameters from the command line in debug and simple mode: <br><pre> <code class="bash hljs">[root@pmaster /etc]<span class="hljs-comment"><span class="hljs-comment"># hiera -d test::text2 DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> Wed Mar 30 13:06:13 -0400 2016: Hiera YAML backend starting DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> Wed Mar 30 13:06:13 -0400 2016: Looking up test::text2 in YAML backend DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> Wed Mar 30 13:06:13 -0400 2016: Looking for data source common DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> Wed Mar 30 13:06:13 -0400 2016: Found test::text2 in common common-hiera [root@pmaster /etc]# hiera testparam::text3 ::fqdn=stage.test.net node stage hiera hiera arrexmpl::colors ::fqdn=stage.test.net {"rgb"=&gt;["red", "blue", "green"], "bw"=&gt;"B&amp;W"}</span></span></code> </pre><br><br>  Now we need to save them in the parameters and use in the template. <br>  <b>/etc/puppet/modules/test1/manifests/params.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params</span></span></span><span class="hljs-class"> { </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># sss $env = $settings::environment $text1 = 'ptestint' $text2 = hiera('test::text2', 'ptestint2') #   'test::text2'.       'ptestint2' $text3 = hiera('testparam::text3', 'ptestint3') $colors = hiera('arrexmpl::colors', 'nohiera') #    arrexmpl::colors if $colors != 'nohiera' { #      $c1 = $colors['bw'] $c2 = $colors['rgb'] } else { $c1 = "lost" } }</span></span></span></span></code> </pre><br><br>  <b>/etc/puppet/modules/test1/manifests/usetmpl.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::usetmpl</span></span></span><span class="hljs-class"> ( $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envname</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params::env</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text1</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params::text1</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text2</span></span></span><span class="hljs-class"> = $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1::params::text2</span></span></span><span class="hljs-class">, </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     $text3 = $test1::params::text3, $c1 = $test1::params::c1, $c2 = $test1::params::c2 ) inherits test1::params { file { 'puppetenv file': path =&gt; '/tmp/puppetenv', ensure =&gt; file, content =&gt; template('test1/puppetenv.erb'), } file { 'hiera test': path =&gt; '/tmp/phiera', ensure =&gt; file, content =&gt; template('test1/hieratst.erb'), } }</span></span></span></span></code> </pre><br><br>  <b>/etc/puppet/modules/test1/templates/hieratst.erb</b> <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Hiera test # Created by puppet Our text1: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@text</span></span></span><span class="hljs-comment">1 %&gt; Our text2: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@text</span></span></span><span class="hljs-comment">2 %&gt; Our text3: &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@text</span></span></span><span class="hljs-comment">3 %&gt; Colors: BW = &lt;%= </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@c</span></span></span><span class="hljs-comment">1 %&gt; &lt;% if c1 == "lost" %&gt; #    ! Hiera fail ! &lt;% end -%&gt; RGB = &lt;%- c2.each do |colors| -%&gt; #    arrexmpl::colors::rgb: - &lt;%= colors %&gt; &lt;%- end -%&gt;</span></span></code> </pre><br><br>  Check on client: <br><br><pre> <code class="bash hljs">[root@stage ~]<span class="hljs-comment"><span class="hljs-comment"># puppet agent --test ... [root@stage /etc/puppet]# cat /tmp/phiera # Hiera test # Created by puppet Our text1: paramtmpl Our text2: common-hiera Our text3: node stage hiera Colors: BW = B&amp;W RGB = - red - blue - green</span></span></code> </pre><br><br><h5>  <b>Example number 5: R10K or even more centralization</b> </h5><br><br>  Actually if the account of the servers went to tens of hundreds, then it becomes safer to divide them into environments.  You can do this with handles, but it is better to use R10K, which allows you to run a separate configuration using modules, which is stored in its personal settings.  That is. In essence, it replaces a single giant site.pp with its configs tree. <br><br>  I will not do the test, just give the conditional algorithm for such a setting on the example of my working configuration. <br><br>  - Servers are divided into settings groups that are stored in separate directories in <b>/ etc / puppet / environments</b> <br><br>  For example, we will test our recipe on the server group <b>test_devops</b> <br><br>  <b>Hyer's tree</b> <br><br>  - stored on the gita / beatback <br>  - tends to update the application of changes to the Master server <br>  - in <b>hiera.yaml</b> added to: hierarchy: <br><pre> <code class="bash hljs"> - %{environment}/%{role}/%{calling_module} - %{environment}/%{role} - %{role} - %{environment}/%{environment}</code> </pre><br>  - Our parameters will be conditionally stored in files <br>  / etc / puppet / hieradata / test_devops / <b>test_devops.yaml</b> - for all nodes via additional tag for R10K <br><pre> <code class="ruby hljs"> <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - roles::base</code> </pre><br>  / etc / puppet / hieradata / test_devops / <b>stage.test.net.yaml</b> for server plus need label for R10K <br><pre> <code class="ruby hljs"> <span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - roles::stagesrv::test</code> </pre><br><br>  <b>Configuring module startup for test_devops via R10K</b> <br><br>  - On the stage.test.net site, add the line to the / etc / puppet / <b>puppet.conf</b> file <br><pre> <code class="bash hljs">environment = stage_nbc210</code> </pre><br>  - <b>/ etc / puppet / environments / test_devops / Puppetfile</b> - all used modules are stored here. <br>  Recording examples <br><pre> <code class="ruby hljs">mod <span class="hljs-string"><span class="hljs-string">'saz/sudo'</span></span>, <span class="hljs-string"><span class="hljs-string">'3.0.1'</span></span> mod <span class="hljs-string"><span class="hljs-string">'stdlib'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:git</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'git://github.com/puppetlabs/puppetlabs-stdlib.git'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:ref</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'4.1.0'</span></span> mod <span class="hljs-string"><span class="hljs-string">'test1'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:git</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'git://github.com/fake_link/test1.git'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:ref</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'master'</span></span></code> </pre><br><br>  They are then downloaded / updated in the console via a command like <br><pre> <code class="bash hljs">sudo r10k deploy module test1 -e test_devops</code> </pre><br>  / etc / puppet / environments / test_devops / modules / <b>test1</b> - Where our module went down <br><br>  - <b>/ etc / puppet / environments / test_devops / dist / profiles / manifests /</b> - module launch manifest tree.  File names must <b>not</b> be the same as module names. <br><br>  Create a file of type <b>runtest1.pp here</b> <br><br><pre> <code class="ruby hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles::runtest1</span></span></span><span class="hljs-class">{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> { '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1</span></span></span><span class="hljs-class">': </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text1</span></span></span><span class="hljs-class"> =&gt; '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newparam</span></span></span><span class="hljs-class">', }</span></span></code> </pre><br><br>  As you can see the nodes are no longer indicated.  If other nodes need other parameters, you can create runtest2.pp, etc. Additional levels are supported.  For example, you can create the file / etc / puppet / environments / test_devops / dist / profiles / manifests / ver2 / <b>runtest3.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles::ver2::runtest3</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> { '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test1</span></span></span><span class="hljs-class">': </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text1</span></span></span><span class="hljs-class"> =&gt; '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newparam</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">', } }</span></span></code> </pre><br><br>  - Now you need to bind the launch manifest modules to the nodes: <br>  <b>/etc/puppet/environments/test_devops/dist/roles/manifests/init.pp</b> <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles</span></span></span><span class="hljs-class"> { } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles::base</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inherits</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles::base</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles::private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inherits</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles::private</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles::public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inherits</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">profiles::public</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roles::stagesrv::test</span></span></span><span class="hljs-class"> { </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># &lt;-      Hiera ? include profiles::runtest1 } #          ,   . #      ,  runtest3      # runtest1,        roles::ver2::runtest3, . .   . class roles::ver2::runtest3 inherits roles::stagesrv::test { include profiles::ver2::runtest3 }</span></span></span></span></code> </pre><br><br>  - Actually there was a dump of the totals of the settings <br><pre> <code class="bash hljs">sudo r10k deploy environment test_devops</code> </pre><br><br>  And then it will be applied on the node by autorun or you can test it manually via puppet agent --test <br><br>  This is actually all.  Thank you for reading to here. <br><br>  Additions or options for other versions of those who wish can be included in this article. <br><br>  I will not compare it with the experience of using chef client-server / chef + berkshelf / chef + AWS Opswork, since there is a completely different algorithm for organizing kukbok- ‚Äúmodules‚Äù and cleaner Ruby in recipes- ‚Äúmanifestos‚Äù. <br><br>  Additional docks: <br>  1. According to <a href="http://www.puppetcookbook.com/">micro samples of</a> Puppet code. <br>  2. By introduction to <a href="https://habrahabr.ru/post/242657/">Hiera</a> <br>  3. A bit on <a href="https://docs.puppetlabs.com/pe/latest/r10k.html">R10K</a> </div><p>Source: <a href="https://habr.com/ru/post/280632/">https://habr.com/ru/post/280632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280622/index.html">Build 2016 conference text translation - second day</a></li>
<li><a href="../280624/index.html">Stand EAST 4 SCADA: how to arrange an accident on the railway</a></li>
<li><a href="../280626/index.html">Apple Developer Center certification in simple and clear language</a></li>
<li><a href="../280628/index.html">C ++ Russia 2016 at ++ 5</a></li>
<li><a href="../280630/index.html">Fibbing: IT Routes</a></li>
<li><a href="../280634/index.html">Mandrill everything? As I was looking for a replacement and found 2 excellent alternatives to Mandrila</a></li>
<li><a href="../280636/index.html">How you can use responsive web components today</a></li>
<li><a href="../280638/index.html">Xamarin is now free. "In the debugger, I have an exception (vosk. Sign)"</a></li>
<li><a href="../280640/index.html">[The Methanum project] Creating tools for building distributed systems with the ‚ÄúStar‚Äù topology</a></li>
<li><a href="../280642/index.html">man! (D => Rust) .basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>