<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write an analogue of Paint on Objective-C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we would like to offer our readers a step-by-step algorithm for creating a simple photo editor, which can be useful for applications ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write an analogue of Paint on Objective-C</h1><div class="post__text post__text-html js-mediator-article">  In this article, we would like to offer our readers a step-by-step algorithm for creating a simple photo editor, which can be useful for applications involving user interaction with images.  It will include the most basic functions, making it possible to make small adjustments: wipe a certain area (for example, nickname), highlight important text (phone, address or just a quote), circle some area on the map, or ‚Äúdraw a word‚Äù.  From a technical point of view, the topic is rather trite, but we have found a way to modify the process, making it faster and easier ‚Äî perhaps someone will take a note. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c91/636/d5c/c91636d5c8e142b093b9dc6a04f879dd.jpg"></div><br><a name="habracut"></a><br>  Any curve can be decomposed into a sequence of interrelated lines.  Then the curve can be drawn by the following simple algorithm: <br><br><ol><li>  We divide the curve into a sequence of segments </li><li>  Put the pen at the beginning of the first segment </li><li>  Draw a line to the end point </li><li>  Go to the next segment </li><li>  Choose color, line thickness and other settings </li><li>  Display line on screen </li><li>  Repeat the listed actions for each segment of the sequence </li></ol><br>  To implement this algorithm, you need to create a class PaintLine, which will contain the starting and ending points.  The line is drawn using the UIBezierPath component. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To implement the drawing algorithm, you must create and add a custom view.  This component will intercept touch events and fill the image. <br><br>  The first touch of the finger to the screen sets the starting point for the first line: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)touchesBegan:(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *&gt; *)touches withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> touchesBegan:touches withEvent:event]; <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *allTouches = [event allTouches]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allTouches.count != <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *touch = [[allTouches allObjects] objectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; pointTo = [touch locationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; }</code> </pre> <br>  Changing the position of the finger leads to the chain creating lines and adding each created line to the sequence to display: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)touchesMoved:(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *&gt; *)touches withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> touchesMoved:touches withEvent:event]; <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *allTouches = [event allTouches]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allTouches.count != <span class="hljs-number"><span class="hljs-number">1</span></span>){ [linePaint removeAllObjects]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setNeedsDisplay]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *touch = [[allTouches allObjects] objectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; pointFrom = pointTo; pointTo = [touch locationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointTo.y &lt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height &amp;&amp; pointFrom.y &lt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addLineFrom:pointFrom to:pointTo]; } }</code> </pre><br>  When the user removes his finger from the screen, the curve is transferred from the preview directly to the image itself: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)touchesEnded:(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *&gt; *)touches withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> touchesEnded:touches withEvent:event]; <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *allTouches = [event allTouches]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allTouches.count != <span class="hljs-number"><span class="hljs-number">1</span></span>){ [linePaint removeAllObjects]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setNeedsDisplay]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *touch = [[allTouches allObjects] objectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; pointFrom = pointTo; pointTo = [touch locationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointTo.y &lt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height &amp;&amp; pointFrom.y &lt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addLineFrom:pointFrom to:pointTo]; } imgForPaint = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getImage:imgForPaint]; <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_main_queue(), ^{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_imageAfterEndPaint) { _imageAfterEndPaint(imgForPaint); } }); }</code> </pre><br>  The result of the algorithm has one small drawback.  If you select a thick line, the ends of the segment are perpendicular to the direction of the beginning and end of the curve, respectively.  It looks not quite nice and reliable, considering that a round-shaped tool is chosen for drawing. <br><br>  You can draw circles instead of lines.  If you smoothly swipe your finger across the screen of the phone, you get a good result, but a sharp movement leads to the relief of the line or even the appearance of gaps. <br><br>  To compensate for the shortcomings of both methods, you can use a filled shape to draw one line, as shown in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a4a/5df/e88/a4a5dfe8822e4a29872dab8fa3d91cd9.png"></div><br>  The result is a continuous curve with rounded ends. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span>*)getBezuerPathWith:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)zoom { <span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> *bezierPath = [[<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> alloc] init]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = zoom * _lineWidth / <span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (PaintLine *line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> linePaint) { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> point1 = <span class="hljs-built_in"><span class="hljs-built_in">CGPointApplyAffineTransform</span></span>(line.point1, <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransformMakeScale</span></span>(zoom, zoom)); <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> point2 = <span class="hljs-built_in"><span class="hljs-built_in">CGPointApplyAffineTransform</span></span>(line.point2, <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransformMakeScale</span></span>(zoom, zoom)); [bezierPath moveToPoint:point1]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alf = atan2(point2.y - point1.y, point2.x - point1.x); [bezierPath addArcWithCenter:point1 radius:width startAngle:alf + M_PI_2 endAngle:alf - M_PI_2 clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alf0 = alf - M_PI_2; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> point = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(cos(alf0) * width + point2.x, sin(alf0) * width + point2.y); [bezierPath addLineToPoint:point]; [bezierPath addArcWithCenter:point2 radius:width startAngle:alf - M_PI_2 endAngle:alf + M_PI_2 clockwise:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; alf0 = alf + M_PI_2; point = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(cos(alf0) * width + point1.x, sin(alf0) * width + point1.y); [bezierPath addLineToPoint:point]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bezierPath; }</code> </pre> <br>  Moving on to the image.  It is implemented by changing the color of the pixel as follows: <br><br><ol><li>  Translate an image into an array of pixels </li><li>  Change text for all pixels that need it. </li><li>  Jump to the coordinate of the desired pixel and change 32 bits of color in ARGB format </li><li>  To collect the image from the converted array </li></ol><br>  To fill the area, you can use the quick method with the optimization of the number of calls on the stack or queue.  But if you display the intermediate result of the slow fill method, you get a beautiful effect of pouring.  To achieve it, you must perform the following steps: <br><br>  1. Get the pixel color of the image and save it as a replacement color <br>  2. Check if the replacement color matches the new pixel color.  If not: <br><br>  a) Put a pixel in a queue <br>  b) Repaint the selected pixel to a new color. <br>  c) Repeat until the queue is empty <br>  d) Pull a pixel from the queue <br><br>  3. Check the color value checking procedure for each of the adjacent pixels. <br>  4. If the color of the adjacent pixel is equal to the color of the pixel to replace: <br><br>  a) Replace pixel color with new color <br>  b) Put a pixel at the end of the queue <br><br>  Depending on how the neighboring pixels are selected, you can get different forms of the distribution of the fill: <br><br>  <b>1. Fill by 4 adjacent points</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/495/4f8/1d9/4954f81d94d9449aa0b8b4b987bd5acd.png"></div><br>  <b>2. Fill by 8 adjacent points</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/af4/c75/d4a/af4c75d4aa324ff39b8f0178a8e364ee.png"></div><br>  <b>3. The alternation of the fill in 4 and 8 adjacent points (2 - in four, 1 - in eight)</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d71/1eb/7e2/d711eb7e22494a9686de7e8414433913.png"></div><br>  All these methods lead to polygonal spreading of the fill.  At the same time, the presented variants do not correspond to the natural pattern of the spread of liquid on a flat surface.  To obtain the effect of spreading the fill around the circumference, the algorithm must make the following changes: <br><br>  1. Get the pixel color of the image and save it as a replacement color <br>  2. If the color for the replacement does not match the new pixel color: <br><br>  a) Put a pixel in a queue <br>  b) Repaint the selected pixel to a new color. <br>  c) Set the radius of the circle to 1 <br>  d) Set the number of pixels that must be processed to move to the next radius <br>  d) Repeat until the queue is empty <br>  f) Pull a pixel from the queue <br>  g) Reduce by 1 the number of pixels that must be processed to move to the next radius. <br><br>  3. Check the color value checking procedure for each of the adjacent pixels. <br>  4. If the color of the adjacent pixel is equal to the color of the pixel to replace: <br><br>  a) Replace pixel color with new color <br>  b) Put a pixel at the end of the queue <br><br>  5. If the number of pixels that must be processed to move to the next radius, decreased to 0: <br><br>  a) Set as a new value a number equal to the current queue size <br>  b) Increase by 1 the radius of the circle. <br><br>  By changing the equality when comparing the color for the replacement and the new color for the range, you can get a smooth transition between the fill area and the fill border: <br><br><pre> <code class="objectivec hljs">[colorQueue addObject:[<span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span> valueWithCGPoint:newStartPoint]]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">4</span></span>*((w*round(newStartPoint.y))+round(newStartPoint.x)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; memcpy(colorFroUpdate, &amp;data[offset], <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> limit = <span class="hljs-number"><span class="hljs-number">10</span></span>; isCanPaint = !(abs(newColorArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] - data[offset]) &lt; limit &amp;&amp; abs(newColorArray[<span class="hljs-number"><span class="hljs-number">1</span></span>] - data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; limit &amp;&amp; abs(newColorArray[<span class="hljs-number"><span class="hljs-number">2</span></span>] - data[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>]) &lt; limit); <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> countPixelICurrentIterrations = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterrationIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isCanPaint &amp;&amp; colorQueue.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> point = [[colorQueue objectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">CGPointValue</span></span>]; [colorQueue removeObjectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; countPixelICurrentIterrations--; offset = <span class="hljs-number"><span class="hljs-number">4</span></span>*((w*round(point.y))+round(point.x)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; memcpy(&amp;data[offset], newColorArray, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> newPoint; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x0 = point.x - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1 = point.x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y0 = point.y - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y1 = point.y + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = x0; x &lt;= x1; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = y0; y &lt;= y1; y++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = sqrtf((x - newStartPoint.x) * (x - newStartPoint.x) + (y - newStartPoint.y) * (y - newStartPoint.y)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s &lt; iterrationIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { newPoint = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newPoint.x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; newPoint.x &lt; w &amp;&amp; newPoint.y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; newPoint.y &lt; h) { offset = <span class="hljs-number"><span class="hljs-number">4</span></span>*((w*round(newPoint.y))+round(newPoint.x)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(colorFroUpdate[<span class="hljs-number"><span class="hljs-number">0</span></span>] - data[offset]) &lt; limit &amp;&amp; abs(colorFroUpdate[<span class="hljs-number"><span class="hljs-number">1</span></span>] - data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; limit &amp;&amp; abs(colorFroUpdate[<span class="hljs-number"><span class="hljs-number">2</span></span>] - data[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>]) &lt; limit) { memcpy(&amp;data[offset], newColorArray, <span class="hljs-number"><span class="hljs-number">3</span></span>); [colorQueue addObject:[<span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span> valueWithCGPoint:newPoint]]; } } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countPixelICurrentIterrations &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updateImageOn) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iterrationIndex % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">@autoreleasepool</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">CGImageRef</span></span> cgImage = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapContextCreateImage</span></span>(cgctx); <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *resultUIImage = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageWithCGImage:cgImage]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updateImageOn(resultUIImage); <span class="hljs-built_in"><span class="hljs-built_in">CGImageRelease</span></span>(cgImage); } countPixelICurrentIterrations = [colorQueue count]; iterrationIndex++; } } }</code> </pre> <br>  By starting the drawing process asynchronously, you can observe the following effect of the spreading fill: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/70f/9ba/ead/70f9baeada674ac0a842f2d883f6a6fe.gif"></div><br>  So, we implemented the intended functionality and at the same time demonstrated how simple and sometimes seemingly inefficient algorithms can produce a very unexpected result.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/329180/">https://habr.com/ru/post/329180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329168/index.html">Pygest # 9. Releases, articles, interesting projects from the world of Python [May 8, 2017 - May 22, 2017]</a></li>
<li><a href="../329170/index.html">Domestic processor from the company ELVIS</a></li>
<li><a href="../329174/index.html">Load testing: where to start and where to look</a></li>
<li><a href="../329176/index.html">From dependent types to homotopic type theory on Scala + Shapeless + ProvingGround</a></li>
<li><a href="../329178/index.html">PostgreSQL Diagnostic Techniques - Vladimir Borodin and Ildus Kurbangaliev</a></li>
<li><a href="../329182/index.html">Seminar "Modernization of engineering systems in the existing data center", May 31, Moscow</a></li>
<li><a href="../329184/index.html">Bitdefender Hypervisor Introspection: a new means of dealing with hidden cyber threats</a></li>
<li><a href="../329188/index.html">Confronting Positive Hack Days: Hackers won't be bored</a></li>
<li><a href="../329190/index.html">Google I / O Site Tour</a></li>
<li><a href="../329194/index.html">Use Cake to build C # code.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>