<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS works: web workers and five use cases</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[We advise you to read] Other 19 parts of the cycle  Part 1: Overview of the engine, execution time mechanisms, call stack 
 Part 2: About the V8 inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS works: web workers and five use cases</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br>  We publish the translation of the seventh part of a series of materials about the features of the various mechanisms of JavaScript.  Our topic today is web workers.  In particular, it will focus on the different types of web workers, how the joint work of the parts of which they are composed, as well as their capabilities and limitations that can be encountered in different scenarios of their use, is organized.  It will also show 5 options for the practical use of web workers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/1dd/71c/6261dd71cfa500ab1358f61cf5f8d157.png" alt="image"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asynchronous Programming Limitations</font> </h2><br>  Before we start talking about web workers, it‚Äôs worth remembering that JavaScript is a <a href="https://habrahabr.ru/company/ruvds/blog/337042/">single-threaded</a> language, however, it also supports asynchronous code execution. <br><br>  <a href="https://habrahabr.ru/company/ruvds/blog/340508/">One of the previous</a> materials in this series was <a href="https://habrahabr.ru/company/ruvds/blog/340508/">devoted to</a> asynchronous programming and its use in JS projects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Asynchronous code execution allows the user interface of web applications to function normally and respond to user commands.  The system ‚Äúschedules‚Äù the load on the event loop in such a way that the operations associated with the user interface are performed first. <br><br>  A good example of the use of asynchronous programming methods demonstrates the technique of performing AJAX requests.  Since waiting for a response can take a lot of time, requests can be made asynchronously, and while the client is waiting for a response, code that is not related to the request can be executed. <br><br><pre><code class="plaintext hljs">//   jQuery jQuery.ajax({    url: 'https://api.example.com/endpoint',    success: function(response) {        // ,           } });</code> </pre> <br>  This approach, however, demonstrates the following problem: requests are processed by the browser's WEB API.  We are also interested in the possibility of asynchronous execution of arbitrary code.  Say, what if the code inside the callback function uses processor resources intensively? <br><br><pre> <code class="plaintext hljs">var result = performCPUIntensiveCalculation();</code> </pre> <br>  If the <code>performCPUIntensiveCalculation</code> function is not something like an asynchronously executed HTTP request, but code that blocks the main thread (say, a huge and heavy <code>for</code> loop), then with a single-threaded approach to JS development we have no way to release the event loop and unlock the browser interface.  As a result, the user will not be able to work with him normally. <br><br>  This means that asynchronous functions mitigate only a small part of the limitations associated with single-threading JS. <br><br>  In some cases, a good result in unloading the main stream when performing resource-intensive operations can be achieved with the help of <code>setTimeout</code> .  For example, if you break up complex calculations into fragments performed in different <code>setTimeout</code> calls, you can ‚Äúdistribute‚Äù them across the event loop, and thus not block the user interface. <br><br>  Take a look at a simple function that calculates the average for a numeric array. <br><br><pre> <code class="plaintext hljs">function average(numbers) {   var len = numbers.length,       sum = 0,       i;   if (len === 0) {       return 0;   }     for (i = 0; i &lt; len; i++) {       sum += numbers[i];   }    return sum / len; }</code> </pre> <br>  This code can be rewritten so that it ‚Äúemulates‚Äù asynchronous execution: <br><br><pre> <code class="plaintext hljs">function averageAsync(numbers, callback) {   var len = numbers.length,       sum = 0;   if (len === 0) {       return 0;   }   function calculateSumAsync(i) {       if (i &lt; len) {           //       .           setTimeout(function() {               sum += numbers[i];               calculateSumAsync(i + 1);           }, 0);       } else {           //     ,              callback(sum / len);       }   }   calculateSumAsync(0); }</code> </pre> <br>  With this approach, we use the <code>setTimeout</code> function, which schedules the execution of calculations.  This leads to the placement in the event loop of a function that performs the next portion of the calculations, so that there is enough time between the sessions for performing this function for other calculations, including those related to the user interface. <br><br><h2>  <font color="#3AC1EF">Web workers</font> </h2><br>  <a href="https://www.w3schools.com/html/html5_intro.asp">HTML5 has</a> given us many great features, among which are the following: <br><br><ul><li>  SSE (we considered and compared this technology with the WebSocket protocol in one of the previous <a href="https://habrahabr.ru/company/ruvds/blog/342346/">materials</a> ). <br></li><li>  Geolocation. <br></li><li>  Application cache <br></li><li>  Local storage. <br></li><li>  Technology Drag and Drop. <br></li><li>  Web workers. <br></li></ul><br>  Web workers are streams owned by the browser that can be used to execute JS code without locking the event loop. <br><br>  This is truly a great opportunity.  The JavaScript concept system is based on the idea of ‚Äã‚Äãa single-threaded environment, and now we have a technology that (partially) removes this restriction. <br><br>  Web workers allow the developer to place tasks that require lengthy and complex calculations that use the processor intensively in background threads without blocking the user interface, which allows applications to respond quickly to user input.  Moreover, we no longer need workarounds, like the above <code>setTimeout</code> trick to find an acceptable way to interact with the event loop. <br><br>  Here is a simple <a href="http://afshinm.github.io/50k/">example</a> that demonstrates the difference between sorting an array with and without a web worker. <br><br><h3>  <font color="#3AC1EF">‚ñç Web Worker Review</font> </h3><br>  Web workers allow you to perform computationally heavy and lengthy tasks without blocking the user interface flow.  In fact, when using them, calculations are performed in parallel.  Before us is a real multithreading. <br><br>  You may recall that JavaScript is a single-threaded programming language.  Perhaps, here you should realize that JS is a language that does not define a thread model.  Web workers are not part of JavaScript.  They represent a browser feature that can be accessed via javascript.  Most browsers have historically been single-threaded (this situation has, of course, changed), and most JavaScript implementations are designed for browsers. <br><br>  Web workers are not implemented in Node.js - there is the concept of "clusters" or "child processes", and this is a little different. <br><br>  It is worth noting that the <a href="http://www.whatwg.org/specs/web-workers/current-work/">specification</a> mentions three types of web workers: <br><br><ul><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Dedicated Workers</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared Workers</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">Service Workers</a> <br></li></ul><br><h3>  <font color="#3AC1EF">‚ñçDedicated Workers</font> </h3><br>  Instances of dedicated web workers are created by the main process.  Only he can exchange data with them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73e/c07/197/73ec07197730444ce1f7ca096826a482.png"></div><br>  <i><font color="#999999">Browser support for dedicated workers</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñçShared Workers</font> </h3><br>  Any process that has the same source as the worker can get access to the shared worker (for example, different browser tabs, <code>iframe</code> , and other shared workers). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/a78/42b/e3fa7842b74d1b310b7f62f72c136ef4.png"></div><br>  <i><font color="#999999">Support for shared workers in browsers</font></i> <br><br><h3>  <font color="#3AC1EF">Service Workers</font> </h3><br>  Service workers are event-driven workers registered using their origin and path.  They can control the web page with which they are connected, intercepting and modifying navigation commands and resource requests, and performing data caching that can be very precisely controlled.  All this gives us excellent means of controlling the behavior of the application in a certain situation (for example, when the network is not available). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df5/2dc/448/df52dc44826fb3c8c6e552a37a85aa03.png"></div><br>  <i><font color="#999999">Support for service workers in browsers</font></i> <br><br>  It should be noted that in this material we will deal with dedicated workers, we will keep them in mind when talking about ‚Äúweb workers‚Äù or ‚Äúworkers‚Äù. <br><br><h2>  <font color="#3AC1EF">How web workers work</font> </h2><br>  Web workers are implemented using .js files, which are included on the page using an asynchronous HTTP request.  These requests are completely hidden from the developer thanks to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker API</a> . <br><br>  Workers use message transfer mechanisms that are characteristic of technologies that are used to organize the interaction of threads, which allows them to be organized in parallel.  They are great for performing heavy computational operations without slowing down the user interface. <br><br>  Web workers are run in isolated threads in the browser.  As a result, the code they execute must be included in a separate file.  It is important to remember. <br><br>  Here's how web workers are created: <br><br><pre> <code class="plaintext hljs">var worker = new Worker('task.js');</code> </pre> <br>  If the <code>task.js</code> file exists and is accessible to it, the browser will create a new thread that loads this file asynchronously.  After the download is complete, the workman‚Äôs code will begin to run.  If the browser receives an error message 404 when trying to download a file, the file will not be loaded, and no error messages will be displayed. <br><br>  To run a newly created worker, call his <code>postMessage</code> method: <br><br><pre> <code class="plaintext hljs">worker.postMessage();</code> </pre> <br><h2>  <font color="#3AC1EF">Data exchange with web worker</font> </h2><br>  In order for the page that created the web worker to interact with it, you need to use either the <code>postMessage</code> method or the broadcast data channel represented by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadcastChannel</a> object. <br><br><h3>  <font color="#3AC1EF">Post postMessage method</font> </h3><br>  When calling this method, newer browsers support, as the first parameter, a JSON object, and in older browsers only a parameter of the <code>String</code> type is supported. <br><br>  Let's look at an example of how the page that created the worker can exchange data with it using a JSON object.  When you send a string, everything looks almost the same. <br><br>  Here is part of the HTML page: <br><br><pre> <code class="plaintext hljs">&lt;button onclick="startComputation()"&gt;Start computation&lt;/button&gt; &lt;script&gt; function startComputation() {   worker.postMessage({'cmd': 'average', 'data': [1, 2, 3, 4]}); } var worker = new Worker('doWork.js'); worker.addEventListener('message', function(e) {   console.log(e.data); }, false); &lt;/script&gt;</code> </pre> <br>  Here is the contents of the worker code file: <br><br><pre> <code class="plaintext hljs">self.addEventListener('message', function(e) { var data = e.data; switch (data.cmd) {   case 'average':     var result = calculateAverage(data); // ,          self.postMessage(result);     break;   default:     self.postMessage('Unknown command'); } }, false);</code> </pre> <br>  When the button is pressed, the page invokes the <code>postMessage</code> method of the worker.  This call passes the JSON object to the worker with the <code>cmd</code> and <code>data</code> keys and their corresponding values.  The worker will process this message using the <code>message</code> handler specified in it. <br><br>  When the worker receives the message and understands what is wanted of him, he will perform the calculations on his own, without blocking the cycle of events.  What the worker is doing looks like a standard JS function.  When the calculations are completed, their results are transmitted to the main page. <br><br>  In the context of the worker, both <code>self</code> and <code>this</code> indicate a global namespace for the worker. <br><br>  In order to stop the worker, you can use one of two methods.  The first is to call from the main page the <code>worker.terminate()</code> method.  The second is executed inside the worker and is implemented by the <code>self.close()</code> command. <br><br><h3>  <font color="#3AC1EF">‚ñçBroadcast channel</font> </h3><br>  The <a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadcastChannel</a> object is a more universal API for data transmission.  It allows you to send messages that can be accepted in all contexts that have the same source.  All browser tabs, <code>iframe</code> or workers from the same source can send and receive broadcast messages: <br><br><pre> <code class="plaintext hljs">//     var bc = new BroadcastChannel('test_channel'); //    bc.postMessage('This is a test message.'); //    ,  //     bc.onmessage = function (e) { console.log(e.data); } //    bc.close()</code> </pre> <br>  Here is the scheme of interaction between various entities using a broadcast messaging channel: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/83c/f9d/ea783cf9db67051ba2f98d6f828aaf8e.png"></div><br>  <i><font color="#999999">Data Exchange Using Broadcast Message Channel</font></i> <br><br>  However, it is worth noting that the <code>BroadcastChannel</code> object still has rather limited support in browsers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/2ed/897/4c62ed897a106832e9fc171e49f81dbc.png"></div><br>  <i><font color="#999999">BroadcastChannel support in browsers</font></i> <br><br><h2>  <font color="#3AC1EF">Ways to send messages to web workers</font> </h2><br>  There are two ways to send messages to web workers.  The first is to copy the data, the second is to transfer data from the source to the receiver without copying them.  Consider these ways to work with messages: <br><br><ul><li>  Copy message.  The message is serialized, copied, sent, and then, on the receiving side, deserialized.  The page and the worker do not use a shared copy of the message, so here we are faced with the creation of copies of data in each session of sending messages.  Most browsers implement this feature by automatically converting the transmitted information into JSON on the transmitter side and decoding this data on the receiver side.  As you might expect, this adds a significant load on the system when sending messages.  The larger the message, the longer it will take to send it. <br></li><li>  Send a message.  With this approach, it turns out that the sender of the message can no longer use the message after it has been sent.  In this case, the transfer of messages is performed almost instantly.  The main feature of this method is that with its help you can only <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">transfer</a> an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a> object. <br></li></ul><br><h2>  <font color="#3AC1EF">Features available to web workers</font> </h2><br>  For web workers, due to their multi-threading nature, only a limited set of JavaScript features is available.  Here are these features: <br><br><ul><li>  <code>navigator</code> object </li><li>  <code>location</code> object (read only) <br></li><li> <code>XMLHttpRequest</code> </li> <li>  <code>setTimeout()/clearTimeout()</code> and <code>setInterval()/clearInterval()</code> </li><li>  <a href="https://www.html5rocks.com/tutorials/appcache/beginner/">Application cache</a> <br></li><li>  Import external scripts using <code>importScripts()</code> </li><li>  <a href="https://www.html5rocks.com/en/tutorials/workers/basics/">Creating</a> other web workers </li></ul><br><h2>  <font color="#3AC1EF">Limitations of web workers</font> </h2><br>  Unfortunately, web workers do not have access to some very important features of JavaScript.  Among them are the following: <br><br><ul><li>  DOM (this is not thread safe) <br></li><li>  Window object </li><li>  <code>document</code> object </li><li>  <code>parent</code> object </li></ul><br>  All of this means that web workers cannot manipulate the DOM (and thus cannot directly affect the user interface).  At first, it may seem that this makes it much more difficult to use web workers, but over time, having learned how to use web workers correctly, you will begin to perceive them as separate ‚Äúcomputers‚Äù, while what relates to working with web workers. user interface will be executed in the page code.  Workers will perform heavy calculations, and after the work is completed, send the results to the page that calls them, the code of which will already make the necessary changes to the user interface. <br><br><h2>  <font color="#3AC1EF">Error processing</font> </h2><br>  As with any JS code, web workers need to handle errors.  If an error occurs during the execution of the worker, the <code>ErrorEvent</code> event is <code>ErrorEvent</code> .  The error object contains three useful properties that allow you to understand its essence: <br><br><ul><li>  <code>filename</code> is the name of the file containing the worker script that caused the error. </li><li>  <code>lineno</code> is the line number where the error occurred. <br></li><li>  <code>message</code> - description of the error. <br></li></ul><br>  Here is a sample code for handling errors in a web worker: <br><br><pre> <code class="plaintext hljs">function onError(e) { console.log('Line: ' + e.lineno); console.log('In: ' + e.filename); console.log('Message: ' + e.message); } var worker = new Worker('workerWithError.js'); worker.addEventListener('error', onError, false); worker.postMessage(); //    .</code> </pre> <br>  Here is the worker code <br><br><pre> <code class="plaintext hljs">self.addEventListener('message', function(e) { postMessage(x * 2); //  . 'x'  . };</code> </pre> <br>  Here you can see how we created the worker and assigned him an <code>error</code> event handler. <br><br>  Inside the worker (second code snippet) we intentionally raise an exception by multiplying <code>x</code> by 2 while <code>x</code> not defined in the current scope.  The exception reaches the source script and an <code>onError</code> handler is <code>onError</code> that <code>onError</code> the error information. <br><br><h2>  <font color="#3AC1EF">Web Worker Usage Scenarios</font> </h2><br>  We talked about the strengths and weaknesses of web workers.  Now consider several scenarios for their use. <br><br><ul><li>  3D rendering scenes.  In particular, we are talking about the implementation of the ray-tracing method - a <a href="https://en.wikipedia.org/wiki/Rendering_%2528computer_graphics%2529">rendering</a> technique that allows you to create images by tracking the direction of <a href="https://en.wikipedia.org/wiki/Light">light</a> rays and determining the color of pixels.  Ray tracing uses intensive mathematical calculations to model the propagation of light.  With this approach, effects such as reflections and refractions are realized, ray tracing allows you to simulate the appearance of various materials, and so on.  All this computational logic can be moved to a web worker so that it does not block the user interface flow.  You can make it even more interesting, namely, divide the rendering of the image between several workers (and, accordingly, between several processor cores).  <a href="https://nerget.com/rayjs-mt/rayjs.html">Here is a</a> simple example of implementing ray tracing using web workers. <br></li><li>  Encryption.  End-to-end encryption is becoming increasingly popular due to increasing attention to regulating the distribution of personal and confidential data.  Encryption operations can be quite long, especially if there is a need for frequent encryption of large amounts of data.  This is a very appropriate scenario for using a web worker, since you don't need access to DOM objects or something like that.  Encryption is information processing algorithms that are sufficiently basic JS features.  When encryption is performed by a worker, this does not affect the user's experience with the site interface. <br></li><li>  Preloading data.  In order to optimize the website and improve the user experience of working with it, you can use web workers to download and store some data in advance, which you can use very quickly when the need arises later.  Web workers are great for this use case, as the operations they perform will not affect the application interface, unlike the preloading of data implemented by the main stream. <br></li><li>  Progressive web applications.  Such applications should, even with an unreliable network connection, load quickly.  This means that the data must be stored in the browser locally.  This is where <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> or a similar API comes into <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">play</a> .  In general, we are talking about the need to maintain some kind of data storage on the client side.  In order to work with this repository, without blocking the user interface, the work must be organized in a web worker.  It should be noted here that, in the case of IndexedDB, there is an asynchronous API that allows you to not load the main thread without web workers, but earlier there was a synchronous API (which may appear again) that you need to use only inside web workers. <br></li><li>  Spell checker  A simple spell checker works like this: the program reads a dictionary file with a list of correctly written words.  A search tree is formed from the dictionary, which provides an effective search in the text.  When a word is sent to the system for verification, it checks its presence in the search tree.  If the word cannot be found, the user can be provided with alternative variants of this word, obtained by replacing the symbols of the original word and searching the obtained words in the tree to check whether they are correct from the point of view of the verification system.  All this can be easily transferred to the web worker, which will allow the user to work with the text without experiencing the problems associated with locking the interface when checking the word and when searching for alternative spellings. <br></li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we talked about web workers ‚Äî a relatively new feature available to web developers in most modern browsers.  Web workers allow you to carry out resource-intensive operations into separate threads, which allows you to not load the main stream, which can easily handle everything related to the user interface. <br><br>  Previous parts of a series of articles: <br><br>  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">How JS Works: About V8 Inside and Code Optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">How JS works: memory management, four types of memory leaks and how to deal with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">How JS works: event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">How JS: WebSocket and HTTP / 2 + SSE work.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">How JS Works: Features and Scope of WebAssembly</a> <br><br>  <b>Dear readers!</b>  Do you use web workers in your projects? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/348424/">https://habr.com/ru/post/348424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348414/index.html">Threats of the past and future protocols</a></li>
<li><a href="../348416/index.html">The system bus PC transmits music in the middle frequencies</a></li>
<li><a href="../348418/index.html">Understand Bitcoin and the Future. Like what you know will be rethought forever</a></li>
<li><a href="../348420/index.html">Wi-Fi under the Neva: how we built a network in the deepest metro of the world</a></li>
<li><a href="../348422/index.html">Top 10 errors from 1000+ JavaScript projects and recommendations for eliminating them</a></li>
<li><a href="../348428/index.html">Writing a Microsoft DNS server plugin to protect against IDN spoofing</a></li>
<li><a href="../348430/index.html">Security technology: virtual servers vs. containers</a></li>
<li><a href="../348432/index.html">QIWI invites designers, researchers and analysts to the kitchen</a></li>
<li><a href="../348436/index.html">Build projects with dapp. Part 1: Java</a></li>
<li><a href="../348440/index.html">How to hold a tender for the development of the site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>