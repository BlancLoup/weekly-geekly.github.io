<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SWAT - DSL for rapid development of automated web application tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 The task of automating testing is not new, but nevertheless the available tools in the field of testing web applications may have their...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SWAT - DSL for rapid development of automated web application tests</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  The task of automating testing is not new, but nevertheless the available tools in the field of testing web applications may have their limitations. <br><br>  What if we have a hundred different web applications that need to be updated in a short period of time, but there are no tests to check their performance?  Developing a UI test will take a lot of time, but simply making a <a href="http://curl.haxx.se/">curl</a> request and checking that 200 OK returned is not enough. <br><br>  We need a reasonable compromise, a simple, but at the same time sufficient universal means for the development of automatic tests.  So <a href="http://swatpm.org/">SWAT was</a> born. <br><a name="habracut"></a><br><h4>  Foundations idea </h4><br>  So, from the point of view of the end user, SWAT is a console client for running test scripts and some writing language ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">DSL</a> ) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The user creates test scripts in a specific format, puts them in a separate directory, and runs.  In general, it all looks like this: <br><br><pre><code class="bash hljs">$ swat /path/to/your/project/ <span class="hljs-variable"><span class="hljs-variable">$base_url</span></span></code> </pre> <br><br>  Thus, a SWAT project is a folder with test scripts, as well as a certain base <a href="https://ru.wikipedia.org/wiki/URL">URL</a> to which all http requests will be sent when testing a web application.  OK, so far nothing new, many testing systems use similar layouts ... What is the essence of the SWAT system? <br><br>  For a moment, let's forget that we are talking about SWAT and imagine that all we can do is perform a regular http request using the curl utility and analyze the answer using the <a href="https://ru.wikipedia.org/wiki/Grep">grep</a> utility: <br><br><pre> <code class="bash hljs">$ curl <span class="hljs-variable"><span class="hljs-variable">$base_url</span></span> | grep foo-bar-baz</code> </pre><br><br>  Actually this is the quintessence of the SWAT framework. <br><br>  The whole point is that the responses from the server being tested are perceived <i>simply as text</i> , in which you can perform a variety of searches, plus checking for successful http status is added.  As shown by my practice of these two methods (roughly speaking, checking back 200 OK and see <i>what</i> came back) may be quite enough to write test scripts of various degrees of complexity, from superficial <a href="https://ru.m.wikipedia.org/wiki/Smoke_test">smoke</a> tests to full-fledged <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">functional</a> <br><br>  As my practical experience of application showed, SWAT is capable of much, we read further. <br><br><h4>  DSL Description and Data Structure </h4><br>  SWAT is based on a set of arrangements in terms of naming files and directories.  It also provides a <a href="https://github.com/melezhik/outthentic-dsl">special syntax</a> for writing rules for validating arbitrary text - in our case, the response from the server. <br><br>  Let's start with a description of the file structure of a typical SWAT project. <br><br>  So, the SWAT project, as mentioned earlier, is just a directory with files and subdirectories <i>describing the</i> test logic. <br><br>  Well, all you have to do first is just create a project: <br><br><pre> <code class="bash hljs"> $ mkdir swat-project</code> </pre><br><br>  I will introduce a couple of terms to simplify the understanding of the material. <br><br>  Dealing with testing any web application, you can talk about the <a href="https://en.m.wikipedia.org/wiki/Web_resource">resources</a> available in it or just the routes to which you can make a request using various http <a href="https://en.m.wikipedia.org/wiki/HTTP_verbs">methods</a> <br><br>  So, let's say that the application we are testing has the following set of resources and methods for accessing them: <br><br><pre> <code class="bash hljs">GET / <span class="hljs-comment"><span class="hljs-comment">#   GET foo/bar # GET    foo/bar POST bar/baz # POST    bar/baz</span></span></code> </pre><br><br>  To describe this configuration with the help of SWAT you need quite a bit - to use the agreement adopted in SWAT projects, namely, resources are just directories, and methods are files.  Actually it will look like this: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> swat-project $ mkdir -p foo/bar $ mkdir -p bar/baz $ touch get.txt $ touch foo/bar/get.txt $ touch bar/baz/post.txt <span class="hljs-comment"><span class="hljs-comment">#    ...</span></span></code> </pre><br><br>  I hope the principle is clear.  Directory names correspond to http resource names, and file names refer to http method names.  Why the names of the method files contain the * .txt extension will become apparent a little later, now we don‚Äôt pay attention to it. <br><br>  Congratulations!  We have just written a minimal set of tests that can be run (provided, of course, that we have a <a href="https://github.com/melezhik/stuff/blob/master/swat-paper/app.pl">web service</a> that will accept requests): <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> swa-project $ swat ./ 127.0.0.1:3000 /home/vagrant/.swat/.cache/31999/prove/00.GET.t ........... ok 1 - GET 127.0.0.1:3000/ succeeded <span class="hljs-comment"><span class="hljs-comment"># response saved to /home/vagrant/.swat/.cache/31999/prove/KBoHRGrYRm 1..1 ok /home/vagrant/.swat/.cache/31999/prove/bar/baz/00.POST.t .. ok 1 - POST 127.0.0.1:3000/bar/baz succeeded # response saved to /home/vagrant/.swat/.cache/31999/prove/z5lXw_dCLa 1..1 ok /home/vagrant/.swat/.cache/31999/prove/foo/bar/00.GET.t ... ok 1 - GET 127.0.0.1:3000/foo/bar succeeded # response saved to /home/vagrant/.swat/.cache/31999/prove/_DnvkvcUBw 1..1 ok All tests successful. Files=3, Tests=3, 0 wallclock secs ( 0.04 usr 0.02 sys + 0.25 cusr 0.03 csys = 0.34 CPU) Result: PASS</span></span></code> </pre><br><br>  As we can see, SWAT successfully parsed the file structure, turn it into a set of http requests, and executed them.  At the same time, the default responses from the server were validated for the presence of a successful <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2_%25D1%2581%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D1%258F_HTTP">http status,</a> and in case of errors from the server, such tests would not have passed: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> swat-project <span class="hljs-comment"><span class="hljs-comment">#   : $ mkdir unknown $ touch unknown/get.txt #   SWAT : $ swat ./ 127.0.0.1:3000 /home/vagrant/.swat/.cache/32379/prove/bar/baz/00.POST.t .. ok 1 - POST 127.0.0.1:3000/bar/baz succeeded # response saved to /home/vagrant/.swat/.cache/32379/prove/Um9VB1zVyS 1..1 ok /home/vagrant/.swat/.cache/32379/prove/unknown/00.GET.t ... not ok 1 - GET 127.0.0.1:3000/unknown succeeded # Failed test 'GET 127.0.0.1:3000/unknown succeeded' # at /usr/local/share/perl/5.20.2/swat.pm line 81. # curl -X GET -k --connect-timeout 20 -m 20 -L -f -i -o /home/vagrant/.swat/.cache/32379/prove/TJO6JpsClL --stderr /home/vagrant/.swat/.cache/32379/prove/TJO6JpsClL.stderr '127.0.0.1:3000/unknown' # % Total % Received % Xferd Average Speed Time Time Time Current # Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0curl: (22) The requested URL returned error: 404 Not Found # can't continue here due to unsuccessfull http status code 1..1 # Looks like you failed 1 test of 1. # Looks like your test exited with 1 just after 1. Dubious, test returned 1 (wstat 256, 0x100) Failed 1/1 subtests /home/vagrant/.swat/.cache/32379/prove/foo/bar/00.GET.t ... ok 1 - GET 127.0.0.1:3000/foo/bar succeeded # response saved to /home/vagrant/.swat/.cache/32379/prove/N0i8or4eCR 1..1 ok /home/vagrant/.swat/.cache/32379/prove/00.GET.t ........... ok 1 - GET 127.0.0.1:3000/ succeeded # response saved to /home/vagrant/.swat/.cache/32379/prove/eQpLp7zbAw 1..1 ok Test Summary Report ------------------- /home/vagrant/.swat/.cache/32379/prove/unknown/00.GET.t (Wstat: 256 Tests: 1 Failed: 1) Failed test: 1 Non-zero exit status: 1 Files=4, Tests=4, 1 wallclock secs ( 0.03 usr 0.02 sys + 0.28 cusr 0.02 csys = 0.35 CPU) Result: FAIL</span></span></code> </pre><br><br>  So, well, we see that SWAT works by successfully validating unknown resources, or rather by simply analyzing the http status of the responses that came from the server. <br><br>  I want to say a few words about <i>how</i> SWAT makes requests.  To generate http requests, use the <a href="http://curl.haxx.se/">curl</a> utility.  Why was curl chosen and not used, like some kind of Perl library?  (for example, <a href="https://metacpan.org/pod/LWP">LWP</a> ).  IMHO is one of the important advantages in the case of curl - ease of use, good documentation and support (I recently started a non-critical ticket that I was answered in minutes).  For all the time I use this utility, I have hardly come across types of http requests that cannot be implemented via the curl command line interface, except that curl <a href="https://ru.wikipedia.org/wiki/WebSocket">web sockets</a> cannot ... <br><br>  So, SWAT uses curl to create http requests.  This means that all the parameters required for the request you write in the terms of this utility.  For this, the so-called request settings are used - swat.ini files that are created by the user inside the directories with resources and allow you to set additional parameters for each test script that determine its behavior, including the parameters of the curl call.  I will give examples: <br><br><pre> <code class="bash hljs">$ cat bar/baz/swat.ini <span class="hljs-comment"><span class="hljs-comment">#     POST/GET  curl_params="-d name=Alexey -d age=39" $ cat foo/bar/swat.ini #  http  curl_params="-H 'Content-Type: application/json'" $ cat login/swat.ini #  http basic  curl_params="-ufoo-user:foo-password'" $ cat slow-route/swat.ini #  -         try_num=3</span></span></code> </pre><br><br>  More information on the list of parameters that can be set in swat.ini files can be found in the <a href="https://github.com/melezhik/swat">documentation.</a> <br><br>  It is important to note that the swat.ini files are regular <a href="https://ru.wikipedia.org/wiki/Bash">bash</a> scripts, in which, among other things, you can use standard bash constructs, there is a lot of room for creativity, to get acquainted with examples - I refer interested readers to the SWAT documentation pages. <br><br>  Okay, everything is fine, but as you can see, we have never told to check the responses from the server, except for the truth, only the http status.  All that we managed to understand by running the above set of tests is that a certain set of application resources is available and that the server returned a successful (200 OK) response when querying for these resources. <br><br>  It's time to talk about SWAT DSL. <br><br><h4>  SWAT DSL </h4><br>  SWAT DSL is the second (after describing resources and setting requests) the main component of the framework.  DSL allows you to check the answers that came from the server for compliance with certain rules, described in the form of single-line statements: <br><br><pre> <code class="bash hljs">RULE1 RULE2 <span class="hljs-comment"><span class="hljs-comment">#    ...</span></span></code> </pre><br><br>  If no match is found, a test passing error is generated.  For each statement, the answer is checked again.  This is a formal description of the validation process.  In fact, everything is simpler, assertions are just plain lines of text or regular expressions that you would like to <i>see</i> in the server response. <br><br>  I will give examples: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     #  ,   SWAT   , #        200 OK #      regexp: (red|green|blue) #      #   ,    ,     #    -    HELLO WORLD #   regexp: ^HELLO WORLD$</span></span></code> </pre><br><br>  After these examples, I want to add the following: <br><br><ul><li>  SWAT does not provide DSL directly, but uses a ready-made module for validating textual data - <a href="https://github.com/melezhik/outthentic-dsl">Outthentic-DSL</a> .  For a deeper understanding of the capabilities of SWAT DSL - use the documentation for this module. </li><li>  comments can be used when writing rules or (synonym for this tremin) verification statements </li><li>  when parsing a DSL script, lines containing only whitespace or empty lines are ignored </li><li>  SWAT uses a line-by-line check mode, which means that the response from the server is broken down into lines and each line is compared with the next rule.  If at least one line corresponds to the rule - a test for this rule is considered passed, otherwise not passed, as reported by SWAT in the output from the console client. </li><li>  if you want multi-line checks, you can use <a href="https://github.com/melezhik/outthentic-dsl">SWAT blocks</a> </li><li>  regular expressions syntax must match <a href="http://perldoc.perl.org/perlre.html">regular expressions in Perl</a> , because  SWAT DSL written in Perl </li><li>  check rules can be static, i.e.  described in advance, as in the example given here, but SWAT provides the ability to set such rules dynamically, through the programming API through the <a href="https://github.com/melezhik/outthentic-dsl">generator</a> mechanism </li><li>  In this article it is impossible to mention all the possibilities of DSL and the rules for writing verification statements - since they are quite diverse and numerous, again, I‚Äôm referring to the pages of the interested reader. </li></ul><br><br>  So, we have a DSL for writing test rules, the question remains, where will we create these rules?  The answer comes up on its own - of course in the http method files!  (We recall the remark about the extension * .txt in the names of the method files). <br><br>  Let's rewrite, or rather update our previous example, by adding a few checks on the response from the server to when requesting various resources: <br><br><pre> <code class="bash hljs">$ cat get.txt HELLO USER! THIS IS INDEX PAGE $ cat foo/bar/get.txt I AM FOO-BAR $ cat bar/baz/post.txt POST TO BAR-BAZ OK</code> </pre><br><br>  Now run the tests again: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> swat-project $ swat ./ 127.0.0.1:3000 /home/vagrant/.swat/.cache/1422/prove/foo/bar/00.GET.t ... ok 1 - GET 127.0.0.1:3000/foo/bar succeeded <span class="hljs-comment"><span class="hljs-comment"># response saved to /home/vagrant/.swat/.cache/1422/prove/CmDiEY28iD ok 2 - output match 'I AM FOO-BAR' 1..2 ok /home/vagrant/.swat/.cache/1422/prove/bar/baz/00.POST.t .. ok 1 - POST 127.0.0.1:3000/bar/baz succeeded # response saved to /home/vagrant/.swat/.cache/1422/prove/rX8oenyA0j ok 2 - output match 'POST TO BAR-BAZ OK' 1..2 ok /home/vagrant/.swat/.cache/1422/prove/00.GET.t ........... ok 1 - GET 127.0.0.1:3000/ succeeded # response saved to /home/vagrant/.swat/.cache/1422/prove/PxDCnlbOA5 ok 2 - output match 'HELLO USER! THIS IS INDEX PAGE' 1..2 ok All tests successful. Files=3, Tests=6, 0 wallclock secs ( 0.03 usr 0.00 sys + 0.24 cusr 0.00 csys = 0.27 CPU) Result: PASS</span></span></code> </pre><br>  As we can see, SWAT did its job and validated the responses from the server.  This is the first introduction to SWAT DSL. <br><br>  At the end of this article, I would like to mention one more interesting feature of SWAT, which allows you to write not only simple checks, but also full functional tests (remember at the very beginning I said that SWAT is capable of much? ...).  So, let's talk about reused http requests. <br><br><h4>  Reusable http requests </h4><br>  Any more or less complex web application or service, being decomposed into many individual resources or routes, turns out to be strongly ‚Äúbound‚Äù relative to these resources.  What I want to say is that a request to a resource <i>implies,</i> in some cases, a preliminary request to another resource.  Those.  we are not talking about single and independent requests for individual resources, but about chains of such requests.  Examples are obvious: <br><br><ul><li>  access to resources requiring authentication / authorization </li><li>  creation of records in the database, requiring the prior removal of the old record </li><li>  conditional requests - delete the record from the database if it is there </li></ul><br><br>  And so on‚Ä¶ <br><br>  Obviously, with the ‚Äúone test - one resource - one request‚Äù approach, such test scenarios are not feasible.  It is necessary somehow before a request to one resource, to make requests to one or, possibly, to several other resources.  How to be?  And here we come to the aid of SWAT <a href="https://github.com/melezhik/swat">modules</a> - reusable http requests. <br><br>  In a general sense, SWAT modules are very similar to functions, having defined them once, you can call them arbitrarily once, in another place, if necessary, transferring some initial parameters to the module input and processing the result, SWAT implements this through the <a href="https://github.com/melezhik/swat">upstream / downstream history</a> . <br><br>  So, what you need to understand about SWAT modules: <br><br><ul><li>  these are the same http resources as all the other ones created in the SWAT project, with the only difference that SWAT will never call (execute the request associated with the http resource) module </li><li>  another resource can invoke the SWAT module via the SWAT <a href="https://github.com/melezhik/swat">HOOKs API</a> </li><li>  calling the SWAT module in another resource means that SWAT will first make the http request for the module resource and validate the answer (that is, it will run the entire chain of checks associated with this resource, starting from checking the http status to validation through the rules defined for the resource), and then it will make a request for the main resource in which the SWAT module was called. </li><li>  On the SWAT documentation page, a resource that calls a SWAT module is called an upstream story - the main story, and the SWAT module being called is a downstream story - a secondary story.  The terminology is taken from <a href="https://jenkins-ci.org/">jenkins-ci.org</a> , although this model is inverted in SWAT, since  in Jenkins downstream job is called <i>after</i> the main task </li><li>  SWAT HOOKs API - the ability to extend SWAT test scripts by writing Perl code, in this context the HOOKS API, also allows SWAT modules to be programmatically called </li></ul><br><br>  Let us explain all the above with a simple example.  Suppose we have a web service that provides access to two resources: <br><br>  POST login / - Resource for user authentication.  If a valid username and password are sent to the server, the application returns the <a href="https://ru.wikipedia.org/wiki/HTTP_cookie">cookie</a> session.  For simplicity, we assume that the server accepts the login and password through the named fields of the POST request ‚Äî user and password. <br><br>  GET restricted / - Only authenticated users can have access to a protected resource. <br><br>  We will write a SWAT test for such an application.  An obvious test history here is to authenticate and gain access to the GET restricted protected resource. <br><br>  Create a skeleton of the project, describing the resources and methods: <br><br><pre> <code class="bash hljs">$ mkdir swat-project $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> swat-project $ mkdir login $ mkdir restricted $ touch login/post.txt $ touch restricted/get.txt</code> </pre><br><br>  Now we need to declare that the resource is a login / SWAT module, since  we will want to call it <i>before</i> calling the GET restricted / resource. <br>  Use the resource settings file for this - swat.ini file: <br><br><pre> <code class="bash hljs">$ cat login/swat.ini swat_module=1</code> </pre><br><br>  Setting the variable swat_module to one declares the resource as a SWAT module. <br><br>  Add the parameters required for authentication.  In this case, for the sake of simplicity of the example, the login and password are set explicitly, but SWAT will also allow you to take similar parameters from the project and set them elsewhere for security reasons. <br><br><pre> <code class="bash hljs">$ cat login/swat.ini swat_module=1 url_params=<span class="hljs-string"><span class="hljs-string">"-d user=my-login -d password=my-password"</span></span></code> </pre><br><br>  And finally, the final touch - the server in case of successful authentication will return us cookies, we must save them somewhere, we will keep using the cookie-jar mechanism of the same curl utility, the final version of the resource request settings will be: <br><br><pre> <code class="bash hljs">$ cat login/swat.ini swat_module=1 <span class="hljs-comment"><span class="hljs-comment"># $test_root_dir -  ,    #      #        url_params="-d user=my-login -d password=my-password --cookie-jar $test_root_dir/cookie.txt"</span></span></code> </pre><br>  Ok, POST login / resource ready.  If we know <i>that,</i> in addition to the successful status (200 OK), the server must return (and we know ;-)), we can add an additional check in the method file: <br><br><pre> <code class="bash hljs">$ cat login/post.txt hello user!</code> </pre><br><br>  Now we call POST login / before calling GET restricted /, this is done like this: <br><br><pre> <code class="bash hljs">$ cat restricted/hook.pm run_swat_module( POST =&gt; <span class="hljs-string"><span class="hljs-string">'/login'</span></span> );</code> </pre><br><br>  What have we done?  We created a hook file for the GET restricted / resource and requested that the POST login / request be made <i>at the very beginning</i> . <br><br>  What is left for us?  Set up a GET restricted call / that he would use cookies to be created after a successful authentication using POST login /: <br><br><pre> <code class="bash hljs">$ cat restricted/swat.ini url_params=<span class="hljs-string"><span class="hljs-string">"--cookie </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$test_root_dir</span></span></span><span class="hljs-string">/cookie.txt"</span></span></code> </pre><br><br>  Well, similarly to the POST login / resource, you can specify an additional check for the response from the server in the case of the GET restricted / request: <br><br><pre> <code class="bash hljs">$ cat login/get.txt restricted content</code> </pre><br><br>  What else would you like to mention in brief regarding the re-used SWAT requests (unfortunately the format of the article does not allow to fully disclose all the material)?  I will list theses: <br><br><ul><li>  cascading calls to SWAT modules ‚Äî one module can call another, and so on, all as with normal functions </li><li>  data transfers (states) between the main resource and the SWAT modules it calls for.  Yes, it is possible, because  purely technically, the module and the code that caused it are executed in the same process, see the <a href="https://github.com/melezhik/swat">documentation</a> </li><li>  passing parameters to the SWAT module input and accessing them within the code of the module implementing - this is called module variables, again see the documentation </li></ul><br><br><h4>  Conclusion </h4><br>  I do not want to finish the article with a banal phrase - ‚Äúnow go to <a href="https://github.com/melezhik/swat">the project page</a> , learn how to install the utility and start using it ...‚Äù, although it would not be bad :-) <br><br>  But here is why you could start using SWAT in your work (IMHO): <br><br><ul><li>  let me paraphrase freely <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BE%25D0%25BB%25D0%25BB,_%25D0%259B%25D0%25B0%25D1%2580%25D1%2580%25D0%25B8">Larry Wal</a> - SWAT allows you to make simple things simple and complex workable.  Notice how little code we had to write in our examples, and at the same time, SWAT is a powerful tool with the ability to extend to Perl.  Whether you are a sysadmin with basic programming skills or an experienced developer - SWAT can be equally convenient and understandable to you </li><li>  SWAT is very pragmatic.  It was coined on the basis of the realities of life for solving specific problems - namely, the rapid development of autotests for a large number of applications that are subject to frequent updates.  All extra functionality has been removed from SWAT, it is as accurate as possible to solve the problem and does not provide anything to the load. </li><li>  SWAT is built on widely used and proven solutions, known to both system administrators and developers - namely, curl and bash.  If you know curl, then you are already half-familiar with SWAT syntax, SWAT simply translates the settings in swat.ini files directly to curl (or almost so ;-)), if you know the basics of bash, it‚Äôs easy for you to describe the SWAT settings resources </li><li>  SWAT is supported by the satellite project <a href="https://github.com/melezhik/sparrow">Sparrow</a> .             SWAT       - SWAT ,     <a href="https://sparrowhub.org/">SparrowHub</a> ,         <a href="https://sparrowhub.org/"></a> .      <a href="http://habrahabr.ru/post/272245/"></a>  <a href="http://blogs.perl.org/users/melezhik/2015/12/sparrowhub---swat-plugins-repository.html"></a> </li></ul><br><br>    . <br><br>  Thank. <br><br> PS  web   SWAT ,    ,   <a href="https://github.com/melezhik/stuff/tree/master/swat-paper"></a> . <br><br> PPS   ! </div><p>Source: <a href="https://habr.com/ru/post/273731/">https://habr.com/ru/post/273731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273719/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 23. "Anglerphish"</a></li>
<li><a href="../273721/index.html">Fixed opening links with a wheel and other fixes in Vivaldi 1.0.357.5 assembly</a></li>
<li><a href="../273723/index.html">Script for quick assessment of the status of Linux systems</a></li>
<li><a href="../273725/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 24. "Exposure"</a></li>
<li><a href="../273727/index.html">Swift. Functional programming</a></li>
<li><a href="../273733/index.html">‚ÄúWings, paws and tails‚Äù of our Linux hosting, part 1: how we automated the deployment of infrastructure</a></li>
<li><a href="../273737/index.html">What year 2015 brought us?</a></li>
<li><a href="../273741/index.html">Adobe Playpanel project closes January 31, 2016</a></li>
<li><a href="../273743/index.html">QThread + QtSql the right way</a></li>
<li><a href="../273745/index.html">History of the 5th place in the Russian AI Cup 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>