<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a blog engine with Phoenix and Elixir / Part 3. Add roles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: ‚Äú Elixir and Phoenix are a great example of where modern web development is heading. Already, these tools provide high-quality ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a blog engine with Phoenix and Elixir / Part 3. Add roles</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/edc/f8c/b9d/edcf8cb9df1e4b23b636baea3538c37e.png"><br><br>  From the translator: ‚Äú <i>Elixir and Phoenix are a great example of where modern web development is heading.</i>  <i>Already, these tools provide high-quality access to real-time technologies for web applications.</i>  <i>Sites with increased interactivity, multiplayer browser games, microservices - those areas in which these technologies will serve a good service.</i>  <i>The following is a translation of a series of 11 articles that describe in detail the aspects of development on the Phoenix framework that would seem such a trivial thing as a blog engine.</i>  <i>But do not hurry to sulk, it will be really interesting, especially if the articles encourage you to pay attention to the Elixir or become its followers.</i> <i><br><br></i>  <i>In this part, we will add support for roles and begin to differentiate access rights.</i>  <i>The key point of this series of articles is that a lot of attention is paid to tests, and this is great!</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i><b>Read to the end to find out why you need to subscribe to Wunsh.ru and how to win a very useful prize</b></i> . ‚Äù <br><a name="habracut"></a><br>  At the moment, our application is based on: <br><br><ul><li>  <b>Elixir</b> : v1.3.1 </li><li>  <b>Phoenix</b> : v1.2.0 </li><li>  <b>Ecto</b> : v2.0.2 </li><li>  <b>Comeonin</b> : v2.5.2 </li></ul><br><h2>  Where we stayed </h2><br>  We broke up with you last time when we finished linking posts with users and started the process of restricting access to posts for users who are not their authors.  We would also like to ensure that users follow the rules, without waiting for the development of events in which some wretch will delete all users, or all posts. <br><br>  To solve this problem, we will use a fairly standard approach: create roles. <br><br><h2>  Creating roles </h2><br>  Let's start by running the following command in the terminal: <br><br><pre><code class="bash hljs">$ mix phoenix.gen.model Role roles name:string admin:boolean</code> </pre> <br>  Which should display something similar: <br><br><pre> <code class="bash hljs">* creating web/models/role.ex * creating <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/models/role_test.exs * creating priv/repo/migrations/20160721151158_create_role.exs Remember to update your repository by running migrations: $ mix ecto.migrate</code> </pre><br>  I propose to use the advice of the script and immediately run the command <code>mix ecto.migrate</code> .  Based on the assumption that our database is configured properly, we should see a similar conclusion: <br><br><pre> <code class="bash hljs">Compiling 21 files (.ex) Generated pxblog app 11:12:04.736 [info] == Running Pxblog.Repo.Migrations.CreateRole.change/0 forward 11:12:04.736 [info] create table roles 11:12:04.742 [info] == Migrated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.0s</code> </pre><br>  We will also run the tests to make sure that adding a new model is not broken.  If they are all green, then we will move on and associate the roles with users. <br><br><h2>  Add a relationship between roles and users </h2><br>  The main idea that I followed when implementing this feature is that each user can have only one role, and each role belongs to several users at once.  To do this, modify the file <code>web/models/user.ex</code> as written below. <br><br>  Inside the <b>‚Äúusers‚Äù</b> section of the scheme <b>,</b> add the following line: <br><br><pre> <code class="hljs pgsql">belongs_to :<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span></code> </pre> <br>  In this case, we are going to place the foreign key <b>role_id</b> in the <b>users</b> table, that is, we say that the user "belongs" to the role.  Also open the <code>web/models/role.ex</code> and add the following line to the <b>"roles"</b> section of the schema: <br><br><pre> <code class="bash hljs">has_many :users, Pxblog.User</code> </pre> <br>  Then run the tests again, but this time we will get a bunch of errors.  We told <b>Ecto</b> that our user table has a link to the role table, but nowhere in the database have it identified.  So we need to change the user table to keep the role reference in the <b>role_id</b> field.  Call the command: <br><br><pre> <code class="bash hljs">$ mix ecto.gen.migration add_role_id_to_users</code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">Compiling 5 files (.ex) * creating priv/repo/migrations * creating priv/repo/migrations/20160721184919_add_role_id_to_users.exs</code> </pre><br>  Let's open the newly created migration file.  By default, it looks like this: <br><br><pre> <code class="hljs sql">defmodule Pxblog.Repo.Migrations.AddRoleIdToUsers <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Ecto.Migration <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">change</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  We need to make a few adjustments.  Let's start by changing the <b>users</b> table.  Add a link to the role in this way: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :role_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">roles</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  We also need to add an index to the <b>role_id</b> field: <br><br><pre> <code class="hljs lisp">create index(<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:role_id</span></span>])</code> </pre> <br>  Finally, run the <code>mix ecto.migrate</code> again.  Migration must be successful!  If we run the tests now, they will all be green again! <br><br>  Unfortunately, our tests are not perfect.  First of all, we did not change them with the <b>Post</b> / <b>User</b> models.  Therefore, we cannot be sure that, for example, a user is necessarily defined for a post.  Similarly, we should not be able to create users without a role.  Let's change the <b>changeset</b> function in the <code>web/models/user.ex</code> as follows (note the addition <b>: role_id</b> in two places): <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct, params \\ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> struct <span class="hljs-params"><span class="hljs-params">|&gt; cast(params, [:username, :email, :password, :password_confirmation, :role_id]) |</span></span>&gt; validate_required([<span class="hljs-symbol"><span class="hljs-symbol">:username</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:email</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:password</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:password_confirmation</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:role_id</span></span>]) <span class="hljs-params"><span class="hljs-params">|&gt; hash_password </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br><h2>  Creating a helper for tests </h2><br>  As a result of running tests, you can now get a large number of errors, but this is normal!  We need to do a lot of work to get them in order.  And we start by adding a certain test helper that will save us from writing the same code over and over again.  Create a new <code>test/support/test_helper.ex</code> and fill it with the following code: <br><br><pre> <code class="hljs sql">defmodule Pxblog.TestHelper <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.User <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Role <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Post <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>: [build_assoc: <span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Role.changeset(%<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span>{}, %{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>}) |&gt; Repo.insert <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: email, username: username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, password_confirmation: password_confirmation}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">role</span></span> |&gt; build_assoc(:<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>) |&gt; User.changeset(%{email: email, username: username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, password_confirmation: password_confirmation}) |&gt; Repo.insert <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> create_post(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, %{title: title, <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> |&gt; build_assoc(:posts) |&gt; Post.changeset(%{title: title, <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>}) |&gt; Repo.insert <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Before we proceed to edit the tests further, let's talk about what this file does.  The first thing you should pay attention to is where we put it.  Namely, in the <b>test / support</b> directory, in which we can also put any modules to make them available to our tests in general.  We still need to reference this helper from each test file, but it should be so! <br><br>  So, first we specify aliases for the <b>Repo</b> , <b>User</b> , <b>Role</b> and <b>Post</b> modules to shorten the syntax for calling them.  Then import <b>Ecto</b> to access the <b>build_assoc</b> function to create associations. <br><br>  In the <b>create_role</b> function <b>,</b> we expect to receive a dictionary for input, which includes the name of the role and the administrator flag.  Since we used the <code>Repo.insert</code> function <code>Repo.insert</code> , then we‚Äôll get the standard answer <code>{:ok, model}</code> when the addition is successful.  In other words, this is simply the insertion of a <b>Role</b> revision. <br><br>  We begin to move down the chain from the role received to the input, which we pass on to create a user model (because we have defined <b>: users</b> as an association), on the basis of which we create a <b>User</b> revision with the parameters mentioned earlier.  The end result is passed to the <code>Repo.insert()</code> function and everything is ready! <br><br>  Though difficult to explain, we are dealing with super readable and super clear code.  We get the role, create the associated user, prepare it for adding to the database and then directly add it! <br><br>  In the <b>create_post</b> function <b>,</b> we do the same thing, except that instead of the user and the role, we work with the post and the user! <br><br><h2>  We fix the tests </h2><br>  Let's start by editing the file <code>test/models/user_test.exs</code> .  First we need to add <code>alias Pxblog.TestHelper</code> to the very top of the module definition, which will allow us to use convenient helpers that we created a little earlier.  Then we will create a <b>setup</b> block before the tests to reuse the role. <br><br><pre> <code class="hljs pgsql">setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} = TestHelper.create_role(%{<span class="hljs-type"><span class="hljs-type">name</span></span>: "user", <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  And then in the first test with the help of pattern matching, we will get the role from the <b>setup</b> block.  Let's save ourselves some more time and write a helper function to get valid attributes along with the role: <br><br><pre> <code class="hljs pgsql">defp valid_attrs(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Map.put(@valid_attrs, :role_id, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "changeset with valid attributes", %{<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> changeset = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.changeset(%<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>{}, valid_attrs(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> changeset.<span class="hljs-keyword"><span class="hljs-keyword">valid</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Summarize.  We match the sample key <b>role</b> , obtained from the <b>setup</b> block, and then change the <b>valid_attrs</b> key to include a valid role in our helper!  As soon as we change this test and run it again, we will immediately return to the green state of the <code>test/models/user_test.exs</code> . <br><br>  Now open the file <code>test/controllers/user_controller_test.exs</code> .  To pass tests from it, we will use the same lessons.  At the very top, add the <code>alias Pxblog.Role</code> instruction, as well as the <code>alias Pxblog.TestHelper</code> next.  Then we place the <b>setup</b> block in which the role is created and the <b>conn</b> object is <b>returned</b> : <br><br><pre> <code class="hljs sql">setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, user_role} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}) {:ok, admin_role} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"admin"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: build_conn(), user_role: user_role, admin_role: admin_role} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Add the <b>valid_create_attrs</b> helper, which takes a role as an argument, and returns a new dictionary of valid attributes with the <b>role_id</b> added. <br><br><pre> <code class="hljs pgsql">defp valid_create_attrs(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Map.put(@valid_create_attrs, :role_id, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Finally, let's make the <b>create</b> and <b>update</b> actions use this helper, as well as pattern matching the <b>user_role</b> value from our dictionary. <br><br><pre> <code class="hljs pgsql">test "creates resource and redirects when data is valid", %{conn: conn, user_role: user_role} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> conn = post conn, user_path(conn, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: valid_create_attrs(user_role) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> redirected_to(conn) == user_path(conn, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> Repo.get_by(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, @valid_attrs) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test "updates chosen resource and redirects when data is valid", %{conn: conn, user_role: user_role} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>! %<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>{} conn = put conn, user_path(conn, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: valid_create_attrs(user_role) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> redirected_to(conn) == user_path(conn, :<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> Repo.get_by(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, @valid_attrs) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Now all user controller tests should pass!  However, running the <code>mix test</code> still shows errors. <br><br><h2>  Correcting post controller tests </h2><br>  We ended up working with <b>PostController</b> tests on adding a bunch of helpers that make it easy to create posts with users.  Therefore, now we need to add the concept of roles to them so that we can create valid users.  Let's start by adding a link to <b>Pxblog.Role</b> to the very top of the <code>test/controllers/post_controller_test.exs</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.TestHelper</code> </pre><br>  Then create a <b>setup</b> block, slightly different from what we did earlier. <br><br><pre> <code class="hljs sql">setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"User Role"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"testuser"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) {:ok, post} = TestHelper.create_post(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, %{title: <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-string"><span class="hljs-string">"Test Body"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = build_conn() |&gt; login_user(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The first thing we did here was to create a standard role without administrative privileges.  On the next line, based on this role, we created a user.  Then for this user created a post.  We have already discussed the piece with the entrance, so go ahead.  Finally, we return all the models we have just created so that each of the tests selects the ones that are needed by using the pattern matching. <br><br>  We only need to change one test so that everything turns green again.  The <i>‚Äúredirects when trying to</i> try <i>a different user‚Äù</i> test fails because it tries to create another user on the fly without knowing the role.  We'll fix it a little bit: <br><br><pre> <code class="hljs pgsql">test "redirects when trying to edit a post for a different user", %{conn: conn, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, other_user} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: "test2@test.com", username: "test2", <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: "test", password_confirmation: "test"}) conn = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> conn, user_post_path(conn, :edit, other_user, post) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> get_flash(conn, :error) == "You are not authorized to modify that post!" <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> redirected_to(conn) == page_path(conn, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> conn.halted <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  So, we added getting the role through pattern matching in the test definition, and then slightly modified the creation of <b>other_user</b> , so that <b>TestHelper</b> was used <b>here</b> along with the resulting role. <br><br>  We have the opportunity to refactor because we added a <b>post</b> object from <b>TestHelper</b> as one of the values ‚Äã‚Äãthat can be obtained by pattern matching.  Therefore, we can change all <b>build_post</b> calls to a <b>post</b> object obtained in this way.  After all changes, the file should look like this: <br><br><pre> <code class="hljs sql">defmodule Pxblog.PostControllerTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pxblog.ConnCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Post <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.TestHelper @valid_attrs %{<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-string"><span class="hljs-string">"some content"</span></span>, title: <span class="hljs-string"><span class="hljs-string">"some content"</span></span>} @invalid_attrs %{} setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"User Role"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"testuser"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) {:ok, post} = TestHelper.create_post(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, %{title: <span class="hljs-string"><span class="hljs-string">"Test Post"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-string"><span class="hljs-string">"Test Body"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = build_conn() |&gt; login_user(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp login_user(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, session_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: %{username: user.username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: user.password} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"lists all entries on index"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"Listing posts"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"renders form for new resources"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"New post"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"creates resource and redirects when data is valid"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = post <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>), post: @valid_attrs assert redirected_to(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) == user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) assert Repo.get_by(assoc(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, :posts), @valid_attrs) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"does not create resource and renders errors when data is invalid"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = post <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>), post: @invalid_attrs assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"New post"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"shows chosen resource"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"Show post"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"renders page not found when id is nonexistent"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> assert_error_sent <span class="hljs-number"><span class="hljs-number">404</span></span>, fn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"renders form for editing chosen resource"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :edit, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"Edit post"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"updates chosen resource and redirects when data is valid"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = put <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post), post: @valid_attrs assert redirected_to(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) == user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) assert Repo.get_by(Post, @valid_attrs) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"does not update chosen resource and renders errors when data is invalid"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = put <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post), post: %{<span class="hljs-string"><span class="hljs-string">"body"</span></span> =&gt; nil} assert html_response(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>) =~ <span class="hljs-string"><span class="hljs-string">"Edit post"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"deletes chosen resource"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, post) assert redirected_to(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) == user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) refute Repo.get(Post, post.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"redirects when the specified user does not exist"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) assert get_flash(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) == <span class="hljs-string"><span class="hljs-string">"Invalid user!"</span></span> assert redirected_to(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) == page_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) assert conn.halted <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"redirects when trying to edit a post for a different user"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, post: post} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, other_user} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: <span class="hljs-string"><span class="hljs-string">"test2@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"test2"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, user_post_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :edit, other_user, post) assert get_flash(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) == <span class="hljs-string"><span class="hljs-string">"You are not authorized to modify that post!"</span></span> assert redirected_to(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) == page_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) assert conn.halted <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><h2>  Eliminate tests for Session Controller </h2><br>  Some tests from the <code>test/controllers/session_controller_test.exs</code> file do not pass due to the fact that we did not tell them to start using our <b>TestHelper</b> .  As before, add aliases to the top of the file and change the <b>setup</b> block: <br><br><pre> <code class="hljs sql">defmodule Pxblog.SessionControllerTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pxblog.ConnCase <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.User <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.TestHelper setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}) {:ok, _user} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{username: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: build_conn()} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  That should be enough for the tests to start!  Hooray! <br><br><h2>  We fix the remaining tests </h2><br>  We still have two broken dough.  So let's make them green! <br><br><pre> <code class="bash hljs">1) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> current user returns the user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the session (Pxblog.LayoutViewTest) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:13 Expected truthy, got nil code: LayoutView.current_user(conn) stacktrace: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:15 2) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> current user returns nothing <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> there is no user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the session (Pxblog.LayoutViewTest) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:18 ** (ArgumentError) cannot convert nil to param stacktrace: (phoenix) lib/phoenix/param.ex:67: Phoenix.Param.Atom.to_param/1 (pxblog) web/router.ex:1: Pxblog.Router.Helpers.session_path/4 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:20</code> </pre><br>  At the very top of the <code>test/views/layout_view_test.exs</code> you can see how a user is created without a role!  In the <b>setup</b> block, we also do not return this user, which leads to such sad consequences!  Horror!  So let's quickly refactor the entire file: <br><br><pre> <code class="hljs sql">defmodule Pxblog.LayoutViewTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Pxblog.ConnCase, async: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.LayoutView <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.TestHelper setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>} = TestHelper.create_role(%{<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-string"><span class="hljs-string">"User Role"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} = TestHelper.create_user(<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, %{email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"testuser"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: build_conn(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"current user returns the user in the session"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = post <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, session_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: %{username: user.username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: user.password} assert LayoutView.current_user(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"current user returns nothing if there is no user in the session"</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, session_path(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) refute LayoutView.current_user(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Here we add an alias for the <b>Role</b> model, create a valid role, create a valid user with this role, and then return the resulting user with the object <b>conn</b> .  And finally, in both test functions, we get the user through pattern matching.  Now run the <code>mix test</code> and ... <br><br>  All tests are green!  But we received a few warnings (because overdone with taking care of clean code). <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/controllers/post_controller_test.exs:20: warning: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> create_user/0 is unused <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:6: warning: unused <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> Role <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/views/layout_view_test.exs:5: warning: unused <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> User <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/controllers/user_controller_test.exs:5: warning: unused <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> Role <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/controllers/post_controller_test.exs:102: warning: variable user is unused <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/controllers/post_controller_test.exs:6: warning: unused <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> Role</code> </pre><br>  To fix it, just go to each of these files and delete the problematic aliases and functions, since  we don't need them anymore! <br><br><pre> <code class="bash hljs">$ mix <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">......................................... Finished <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.4 seconds 41 tests, 0 failures Randomized with seed 588307</code> </pre><br><h2>  Create initial admin data </h2><br>  Ultimately, we need to allow the creation of new users only by the administrator.  But this means that a situation will arise in which initially we will not be able to create either users or administrators.  We cure this ailment by adding <i>seed data</i> for the administrator by default.  To do this, open the <code>priv/repo/seeds.exs</code> and paste the following code into it: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">role</span></span> = %<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span>{} |&gt; <span class="hljs-keyword"><span class="hljs-keyword">Role</span></span>.changeset(%{<span class="hljs-type"><span class="hljs-type">name</span></span>: "Admin Role", <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span> = %<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>{} |&gt; <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.changeset(%{username: "admin", email: "admin@test.com", <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: "test", password_confirmation: "test", role_id: <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>.id}) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>!</code> </pre><br>  And then load our sides with the following command: <br><br><pre> <code class="bash hljs">$ mix run priv/repo/seeds.exs</code> </pre> <br><h2>  What will happen next </h2><br>  Now that our models are configured and ready to interact with the roles, and all the tests are green again, we need to start adding functionality to the controllers to restrict certain operations if the user does not have rights to perform them.  In the next post we will look at how best to implement this functionality, how to add a helper module, and of course, how to keep the tests green. <br><br><h2>  Other series articles </h2><br><ol><li>  <a href="https://habrahabr.ru/post/311088/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/313482/">Authorization</a> </li><li>  Adding Roles </li><li>  <a href="https://habrahabr.ru/post/316368/">Process roles in controllers</a> </li><li>  <a href="https://habrahabr.ru/post/316996/">We connect ExMachina</a> </li><li>  <a href="https://habrahabr.ru/post/317550/">Markdown support</a> </li><li>  <a href="https://habrahabr.ru/post/318790/">Add comments</a> </li><li>  <a href="https://habrahabr.ru/post/323462/">We finish with comments</a> </li><li>  <a href="https://habrahabr.ru/post/332094/">Channels</a> </li><li>  <a href="https://habrahabr.ru/post/333020/">Channel testing</a> </li><li>  <a href="https://habrahabr.ru/post/335048/">Conclusion</a> </li></ol><br><br><h2>  Conclusion from the Wuns </h2><br>  We have two great news at once!  First, there are more of us, and thanks to this, <b>all subscribers will receive a new article tomorrow</b> ( <i>which does not belong to this cycle</i> ) about what the Elixir attracts developers and thus keeps them.  So, if you have not subscribed, do not waste time and <a href="http://wunsh.ru/">rather do it</a> ! <br><br>  Secondly, we decided to <b>play a super-useful gift - the book by Dave Thomas <i>‚ÄúProgramming Elixir‚Äù</i></b> .  A great introduction to the language ( <i>and not only for beginners</i> ) from the guru of the programming programming literature Dave Thomas.  In order to get it, you need to publish a post on Habrahabr on the subject of the Elixir language and indicate that the article was published specifically for the contest from Wunsh.ru.  The winner will be the person whose article will score the highest rating.  <a href="http://wunsh.ru/first_contest.html%3Futm_source%3Dhabr%26utm_medium%3Dcontent%26utm_campaign%3Dfirst_contest">Detailed conditions read the link</a> . <br><br>  Other parts: <br><ol><li>  <a href="https://habrahabr.ru/post/311088/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/313482/">Authorization</a> </li><li>  Adding Roles </li><li>  Soon... </li></ol><br>  Good luck in learning, stay with us! </div><p>Source: <a href="https://habr.com/ru/post/315252/">https://habr.com/ru/post/315252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315240/index.html">Testing Mobile Applications: Interview with Dan Cuellar (Appium)</a></li>
<li><a href="../315242/index.html">The media learned about the new way to intercept passwords and PIN-code from mobile phones</a></li>
<li><a href="../315244/index.html">JetBrains Night in Moscow. Video. Integrating JetBrains server products with each other</a></li>
<li><a href="../315246/index.html">Repair a damaged NTFS partition if it has been reduced to the minimum size (0 bytes free)</a></li>
<li><a href="../315248/index.html">Connect (); // 2016: Program, Live Broadcast and Bonus</a></li>
<li><a href="../315254/index.html">Simple migrations with PHPixie Migrate</a></li>
<li><a href="../315256/index.html">A smart reference for css-properties for a beginner</a></li>
<li><a href="../315258/index.html">Comparing objects by value - 4, or Inheritance & Equality operators</a></li>
<li><a href="../315260/index.html">A little bit about empty interfaces. Quick look inside</a></li>
<li><a href="../315262/index.html">MegaFon Laboratory: How a Mobile Operator Tests a Technique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>