<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Behavior-Driven Testing for iOS using Quick and Nimble</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reading this article, you can use Quick and Nimble in your projects! 


 Writing great, workable applications is one thing, but writing good tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Behavior-Driven Testing for iOS using Quick and Nimble</h1><div class="post__text post__text-html js-mediator-article">  After reading this article, you can use <b>Quick</b> and <b>Nimble</b> in your projects! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/do/m9/ak/dom9akfgi-uoatz_vguuzub6dxa.png" alt="Behavior-Driven Testing for iOS using Quick and Nimble"></div><br>  Writing great, workable applications is one thing, but writing good tests that confirm the expected behavior of your application is much more difficult.  In this article, we will look at one of the available approaches to testing applications, behavior-driven testing, using two extremely popular frameworks called <a href="https://github.com/Quick/Quick">Quick</a> and <a href="https://github.com/Quick/Nimble">Nimble</a> . <br><br>  You will learn about <i>behavior-driven testing</i> : learn what it is, why it is an extremely powerful concept and how easy it is to write readable tests using the Quick and Nimble frameworks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You will write tests for an amazingly simple and fun game called <b>AppTacToe</b> , in which you play Tic Tac Toe against the computer, portraying an iOS character playing against an evil Android player! <br><a name="habracut"></a><br>  <b>Note:</b> <i>For a better understanding of this article, it is assumed that you have a basic knowledge of the Unit Testing topic and use XCTestCase.</i> <br><br>  Although you can continue reading this article without this knowledge, it is still recommended that you read the article <a href="https://www.raywenderlich.com/150073/ios-unit-testing-and-ui-testing-tutorial">iOS Unit Testing and UI Testing Tutorial</a> to repeat the previously learned basics. <br><br><h3>  Start </h3><br>  The best way to start writing tests is to work on a real application, which in your case will be the AppTacToe game introduced earlier. <br><br>  <a href="">Download a start up project</a> that contains everything you need to work; it already contains Quick and Nimble.  After downloading, open <b>AppTacToe.xcworkspace</b> . <br><br>  Open <b>Main.storyboard</b> and learn the basic structure of the application.  It consists of two screens: <b>Board</b> , in which the game itself takes place, and the ‚Äú <i>Game Over screen</i> ‚Äù <i>screen</i> , which is responsible for displaying the result of the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2a/476/518/e2a47651878481db06faa629c91c7ab1.png" alt="image" width="650" height="465"></div><br><br>  Compile and run applications, and play one or two quick games to get familiar with the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/e7b/507/f77e7b5074cd1dda9dd2b57c95ec71b4.jpg" alt="image" width="650" height="465"></div><br><br>  You will also see useful logging, which is displayed in the console, duplicating the course of the game and displaying the final board, after the game is completed. <br><br>  <b>Note:</b> <i>Do not worry if you notice minor errors during the game;</i>  <i>you fix them, while working on this article!</i> <br><br>  Most of the business logic of the application is contained in one of two files: <br>  <b>Components / Board.swift</b> : This file provides a logical implementation of the game Tic Tac Toe.  There are no <b>UI</b> interface elements associated with this game. <br><br>  <b>ViewControllers / BoardViewController.swift</b> : This is the main game screen.  He uses the above-mentioned <b>Board</b> class for the game and is responsible for displaying the game state on the device screen and handling user interaction. <br><br>  What you really need to test in this case is the business logic of the game, so you will write tests for the <b>Board</b> class. <br><br><h3>  What is Behavior-Driven Testing? </h3><br>  The application consists of many code fragments.  In traditional unit tests, you test all sorts of elements of each of these parts.  You provide some data for a piece of code and claim that it returns the expected result. <br><br>  The disadvantage of this approach is that it emphasizes the need to verify the internal operation of the application.  This means that you spend more time testing implementation details, and then on the actual business logic, which is the real meat of your product! <br><br>  It would be nice if you could just confirm that the application behaves as expected, regardless of how it was implemented. <br><br>  Let's get acquainted with behavior-driven testing! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/655/9e2/09f/6559e209f27ac5ecd18eb78acf0ec317.png" alt="behavior-driven testing" width="650" height="429"></div><br><br>  With behavior-driven testing (or <b>BDT</b> ), your tests are based on user stories, which describe some specific expected actions of the application.  Instead of checking out the details of the implementation, you are actually checking what is most important: is the application correctly performing user stories? <br><br>  This approach makes tests extremely readable and supported, and also helps to describe the behavior of logical parts in the application to other developers who once have a chance to understand your code. <br><br>  Here are some examples of user stories that you could write as part of the AppTacToe game: <br><br>  <i>Performing a single game action switches to another player.</i> <i><br></i>  <i>Performing two game actions should switch back to the first player.</i> <i><br></i>  <i>Performing a winning move should put the game into the Victory state.</i> <i><br></i>  <i>Performing a turn after which there are no more moves puts the game into the Draw state.</i> <br><br><h3>  The role of Quick and Nimble in Behavior-Driven Testing </h3><br>  The tests are written based on the behavior management method and user stories, are simple sentences in English.  This makes their understanding much easier compared to the usual Unit tests that you used to write. <br><br>  Quick and Nimble provide an extremely powerful syntax that allows you to write tests that are read in the same way as regular sentences, allowing you to easily and quickly describe the behavior that you want to test.  Inside, they work just like regular XCTestCase (s). <br><br>  Quick provides most of the basic syntax and capabilities associated with writing behavior-driven tests, while Nimble is its companion framework.  It provides additional expressive mapping and affirmation capabilities through Matchers, which you will learn about later in this article. <br><br><h3>  Anatomy of a quick test </h3><br>  Break one of the user stories into three articles based on <a href="https://en.wikipedia.org/wiki/Given-When-Then">GWT</a> ‚Äî Given (the action / behavior you describe), When (the context of this action / behavior) and Then (what you expect to see): <br><br>  <b>Given / Given:</b> User plays. <br>  <b>When / When:</b> This is one move. <br>  <b>Then / Therefore:</b> The turn must be transferred to another player. <br><br>  In Quick, you use three functions: describe, context, and it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/26d/45c/a5326d45c108a8b344fe342dd6aeb464.gif" alt="Anatomy of a Quick test" width="650" height="329"></div><br><br><h3>  Writing the first test </h3><br>  Quick test suites are called Specs, and each one you create must be inherited from QuickSpec, in the same way that you inherit from XCTestCase in tests.  The test suite includes the main spec () method, which will contain all your test cases. <br><br>  The start project already contains an empty test suite.  Open the <b>AppTacToeTests / BoardSpec.swift file</b> and look at the BoardSpec test suite inherited from QuickSpec and containing the only <i>spec ()</i> method in which you will work. <br><br>  Note: When you open the <b>BoardSpec.swift</b> file, you will see the error message No such module 'Quick' or 'Nimble'.  Do not worry, as this is just an error in Xcode that is not related to the project.  Your code will compile and run without any problems. <br><br>  Begin by adding the following code inside the <i>spec ()</i> method: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> board: <span class="hljs-type"><span class="hljs-type">Board!</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 beforeEach { // 2 board = Board() }</span></span></code> </pre> <br>  This code performs two actions: <br><br><ol><li>  Defines the global variable board, which will be used in tests. </li><li>  Set a new Board instance for the board variable before each test, using the beforeEach closure with Quick's. </li></ol><br>  With a certain basic pattern, you can start writing the first test! <br><br>  As conceived by this application, the game always starts with Cross (that is, either so or so., X), and the opponent will be Naught (that is, O). <br><br>  Let's start with the first <i>user story</i> mentioned above: After making the first move, the second player must make the next move. <br><br>  Add the following code immediately after the closure of <i>beforeEach</i> : <br><br><pre> <code class="hljs ruby">describe(<span class="hljs-string"><span class="hljs-string">"playing"</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> context(<span class="hljs-string"><span class="hljs-string">"a single move"</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> it(<span class="hljs-string"><span class="hljs-string">"should switch to nought"</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> try! board.playRandom() /<span class="hljs-regexp"><span class="hljs-regexp">/ 4 expect(board.state).to(equal(.playing(.nought))) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 } } }</span></span></code> </pre><br>  This is what this code does: <br><br><ol><li>  <b>describe () is</b> used to determine which actions or behavior you will be testing. </li><li>  <b>context () is</b> used to define the specific context of the action that you will be testing. </li><li>  <b>it () is</b> used to determine the specific expected result for the test. </li><li>  You perform a random move using the <i>playRandom ()</i> method in the Board class. </li><li>  You state that the Board status is changed to <i>.playing (.nought)</i> .  At this stage, the <i>equal ()</i> method from Nimble is used, which is one of many available functions that can be used to ascertain whether specific conditions match the expected value. </li></ol><br>  <b>Note: You</b> <i>may have noticed a forced call to try and implicitly unwrapped an option to define test global variables.</i>  <i>Although this option is usually not approved when writing code in the application itself, it is a fairly common practice when writing tests.</i> <br><br>  Run tests by going to the <b>Product ‚ñ∏ Test</b> menu panel or using the keyboard shortcut <b>Command + U.</b> <br><br>  So, you will see your first test run.  <b>Awesome!</b> <br><br>  After completing the test, the Test navigator tab should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/617/707/aad617707b52201c5fbf2f3c92f3e4db.png" alt="Your Test navigator will look like this" width="650" height="229"></div><br>  You have already noticed some interesting points by viewing the code.  First of all, this is an extremely readable code.  After reviewing the test code, anyone can read it relatively easily, as a simple sentence in English: <br><br>  Performing a single move switches to the second player. <br><br>  At this stage, you are introduced to the simple use of Nimble Matchers.  Nimble uses these mappings so that you can get the expected test result in a very fast way, like simple sentences.  <i>equal ()</i> is only one of the matching functions that is available in Nimble.  You can even create your own functions. <br><br><h3>  Next test </h3><br>  The second user story - ‚ÄúAfter the second move should switch back to the first player‚Äù - sounds quite similar to the user story. <br><br>  Add the following code immediately after the end of the previous <b>context ()</b> method, inside the <b>describe ()</b> curly brace: <br><br><pre> <code class="hljs erlang-repl">context(<span class="hljs-string"><span class="hljs-string">"two moves"</span></span>) { // <span class="hljs-number"><span class="hljs-number">1</span></span> it(<span class="hljs-string"><span class="hljs-string">"should switch back to cross"</span></span>) { try! board.playRandom() // <span class="hljs-number"><span class="hljs-number">2</span></span> try! board.playRandom() expect(board.state) == .playing(.cross) // <span class="hljs-number"><span class="hljs-number">3</span></span> } }</code> </pre><br>  This test is similar to the previous one, but differs only in the fact that you make two moves instead of one. <br><br>  Here is what the test performs: <br><br><ol><li>  You define a new <b>describe ()</b> to create a ‚Äútwo moves‚Äù context.  You can have any number of <b>describe ()</b> and <b>context ()</b> blocks, and they may even be contained within each other.  Since you are still testing the gameplay, you have added context inside the describe ("playing"). </li><li>  You are making for successive moves. </li><li>  You state that the <b>state of the</b> board is now <i>.playing (.cross)</i> .  Notice that this time you used the regular equality operator ==, instead of the <i>.to (equal ())</i> syntax you used earlier.  Matching Nimble's equal () provides its own overloaded operators that you can choose to your taste. </li></ol><br><h3>  Arrange, Act &amp; Assert </h3><br>  The tests you just wrote were relatively simple and straightforward.  You make a single call on an empty board and state the expected result.  Usually, most scenarios are more complex, which requires a little extra work. <br><br>  The following two user stories will be more difficult: <br><br>  <i>The execution of the winning move should switch to the Victory state.</i> <i><br></i>  <i>Performing an exit from the game does not produce any action, but only a transition to the state of Completion of the game.</i> <br><br>  In both of these <i>user stories</i> you need to take some steps on the game board so that you can check its status, your statement. <br><br>  These tests are usually divided into three stages: <b>Arrange, Act and Assert</b> . <br><br>  Before planning tests, you should understand how the <b>Tic Tac Toe</b> platform is implemented. <br><br>  Board is modeled as an Array consisting of 9 cells addressed using indices from 0 to 8. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf2/c2a/120/cf2c2a120bba887009b333d8338a82c9.png" alt="image" width="650" height="429"></div><br>  At each step, the player performs one move.  To write a test to simulate a user's victory, you will need to bring the <b>Board</b> to a state when the next move will be a winning one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/f1e/8b0/c21f1e8b01f8e7a9ab6734375e227739.png" alt="image" width="650" height="429"></div><br>  Now that you understand how the Board works, it's time to write this test. <br><br>  Add the following code below your previous context ‚Äútwo moves‚Äù <b>context ()</b> : <br><br><pre> <code class="hljs erlang-repl">context(<span class="hljs-string"><span class="hljs-string">"a winning move"</span></span>) { it(<span class="hljs-string"><span class="hljs-string">"should switch to won state"</span></span>) { // Arrange try! board.play(at: <span class="hljs-number"><span class="hljs-number">0</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">1</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">3</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">2</span></span>) // Act try! board.play(at: <span class="hljs-number"><span class="hljs-number">6</span></span>) // Assert expect(board.state) == .won(.cross) } }</code> </pre><br>  Here is what this code implements: <br><br>  <b>Arrange:</b> You organize the Board to prepare it to the state when the next move will be a winning one.  You do this by performing the moves of both players in turn;  starting with X at point 0, at point 1, X at 3 and finally at 2. <br>  <b>Act:</b> You are making a Cross (X) move to position 6. In the current state of the Board, this move should lead to a winning state. <br>  <b>Assert:</b> You indicate that the game will be won by the Cross (X), and the Board will switch to the Win (.won (.cross)) state <br><br>  Run the test again, use the keyboard shortcut <b>Command + U.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f7/114/d7f/3f7114d7f713bbb00738ea2040c71dcc.png" alt="image"></div><br>  Something is wrong;  You have taken all the right steps, but the test unexpectedly failed. <br><br>  Add the following code directly below the <i>expect ()</i> line to see the error: <br><br><pre> <code class="hljs lisp">print(<span class="hljs-name"><span class="hljs-name">board</span></span>)</code> </pre><br>  Displaying the <b>Board</b> immediately after the <b>Assert</b> block, you will receive a detailed explanation of this situation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/742/bf5/82f742bf52798de79519513830961189.png" alt="image"></div><br>  As you can see, the Board should be in the Victory state, but the test still does not work.  Looks like you found a mistake. <br><br>  Go to the <i>Project navigator</i> tab and open <b>Board.swift</b> .  Go to the calculated <b>isGameWon</b> property in line 120. <br><br>  The code in this section checks all possible winning positions by rows, columns and diagonals.  But looking at the columns, the code seems to have only 2 columns checked, and in fact one of the winning options is missing.  Oops! <br><br>  Add the following line of code directly below the <b>// Columns</b> comment: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">0, 3, 6</span></span>],</code> </pre> <br>  Run the tests again and enjoy the three green markers! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b1/467/2b1/1b14672b159952e21b3c263f7e48d8b5.png" alt="image" width="500" height="429"></div><br>  Such a scenario will be much harder to detect with the usual Unit tests.  Since you are using behavior-based testing, you actually tested a specific use case for the application and found an error.  The fix for the main implementation fixed the tested behavior, resolving the problem your user story was experiencing. <br><br>  <b>Note:</b> <i>While working on one particular test or a specific test context, you may not want to run all your tests at once, so that you can focus specifically on one test.</i> <i><br><br></i>  <i>Fortunately, Quick provides a very easy way to do this.</i>  <i>Just add f (stands for focus) before any of the names of the test functions ‚Äî with it (), context, and describe (), become fit (), fcontext () and fdescribe ()</i> <i><br><br></i>  <i>For example, after replacing it (‚Äúshould switch to won state‚Äù) with fit (‚Äúshould switch to won state‚Äù), only this particular test will be run, skipping the rest of the test suite.</i>  <i>Just remember to delete it after you finish, otherwise only part of your tests will work!</i> <br><br><h3>  Little exercise </h3><br>  Time to call.  You have one last user story that you haven‚Äôt yet tested: Running a turn after which there are no more moves puts the game into the Draw state. <br><br>  Using the previous examples, write a test to verify the correctness of the Board definition. <br><br>  <b>Note:</b> <i>To reach the exit status, you can play the following positions in sequence: <b>0, 2, 1, 3, 4, 8, 6, 7</b> .</i> <br><br>  In this state, playing position 5 should result in your board being in the draw state. <br><br>  In addition, using the .draw method can confuse <b>Xcode</b> .  If so, use the full expression: <i>Board.State.draw</i> . <br><br>  If you didn‚Äôt manage to do this task, here‚Äôs the solution: <br><br><pre> <code class="hljs erlang-repl">context(<span class="hljs-string"><span class="hljs-string">"a move leaving no remaining moves"</span></span>) { it(<span class="hljs-string"><span class="hljs-string">"should switch to draw state"</span></span>) { // Arrange try! board.play(at: <span class="hljs-number"><span class="hljs-number">0</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">2</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">1</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">3</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">4</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">8</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">6</span></span>) try! board.play(at: <span class="hljs-number"><span class="hljs-number">7</span></span>) // Act try! board.play(at: <span class="hljs-number"><span class="hljs-number">5</span></span>) // Assert expect(board.state) == Board.State.draw } }</code> </pre><br><h3>  Happy Way is not the only way </h3><br>  All the tests you have written so far have one thing in common: they describe the correct behavior of your application by following the <b>happy path</b> .  You have confirmed that when a player plays the correct moves, the game behaves correctly.  But what about not very happy journey? <br><br>  When writing tests, you should not forget about the concept of expected errors.  You, as a developer, should be able to confirm the correct behavior of the Board, even if your player behaves incorrectly (for example, makes an unauthorized move). <br><br>  Consider the last two user stories of this tutorial: <br><br>  <i>making a move that has already been made should cause an error.</i> <i><br></i>  <i>making a move, after the game is won, should cause an error.</i> <i><br></i> <br>  Nimble provides a convenient <b>resolver</b> called <b>throwError ()</b> , which you can use to test this behavior. <br><br>  Start by checking that a move that has already been played cannot be played again. <br><br>  Add the following code right below the last <b>context ()</b> that you added, but still inside the <b>describe</b> block <b>("playing")</b> : <br><br><pre> <code class="hljs smalltalk">context(<span class="hljs-comment"><span class="hljs-comment">"a move that was already played"</span></span>) { it(<span class="hljs-comment"><span class="hljs-comment">"should throw an error"</span></span>) { try! board.play(at: <span class="hljs-number"><span class="hljs-number">0</span></span>) // <span class="hljs-number"><span class="hljs-number">1</span></span> // <span class="hljs-number"><span class="hljs-number">2</span></span> expect { try board.play(at: <span class="hljs-number"><span class="hljs-number">0</span></span>) } .to(throwError(<span class="hljs-type"><span class="hljs-type">Board</span></span>.<span class="hljs-type"><span class="hljs-type">PlayError</span></span>.alreadyPlayed)) } }</code> </pre><br>  This is what the code does: <br><br><ol><li>  You perform a move to position 0. </li><li>  You play the move in the same position and expect it to <b>roll the Board.PlayerError.alreadyPlayed</b> .  When you state that the error is displayed, expect accepts a closure in which you can run code that causes an error. </li></ol><br>  As you would expect from the Quick Tests, the statement reads the same as the English sentence: expected played (it is expected that the next game will cause an error ‚Äúhas already been played‚Äù). <br><br>  Run the test suite again by going to <b>Product ‚ñ∏ Test</b> or use the keyboard shortcut <b>Command + U.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c3/4a7/175/8c34a71756c0e65fce55ed490ba15db0.png" alt="image"><br><br>  The last user story you are going to study today will be: When making a move, after the game is won, it should cause an error. <br><br>  This test should be relatively similar to the previous <b>Arrange, Act and Assert</b> tests: you need to bring the board to a winning state, and then try to play one more step while the board is in this state. <br><br>  Add the following code right below the last <b>context ()</b> that you added for the previous test: <br><br><pre> <code class="hljs coffeescript">context(<span class="hljs-string"><span class="hljs-string">"a move while the game was already won"</span></span>) { it(<span class="hljs-string"><span class="hljs-string">"should throw an error"</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Arrange <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! board.play(at: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! board.play(at: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! board.play(at: <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! board.play(at: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! board.play(at: <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Act &amp; Assert expect { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> board.play(at: <span class="hljs-number"><span class="hljs-number">7</span></span>) } .to(throwError(Board.PlayError.noGame)) } }</code> </pre><br>  Based on the knowledge that you learned in this lesson, you should feel at home working with this test! <br><br>  You bring the board to the Win state (.won (.cross)) by playing back 5 steps ... Then you <b>Act and Assert</b> , trying to play the move while the board is already in the Win state, and waiting for the <b>Board.PlayError.noGame</b> display. <br><br>  Run your test suite again and pat your back after passing all these tests! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38b/5f1/c2e/38b5f1c2e9d7e4fe6a3e1e24c0daff8b.png" alt="image"><br><br><h3>  Custom mappings </h3><br>  When writing tests in this article, you already used several mappings embedded in Nimble: equal () (and its == overload operator), and <b>.throwError ()</b> . <br><br>  Sometimes you want to create your own mappings to encapsulate some complex form of mapping or to increase the readability of some of your existing tests. <br><br>  Think about how to improve the readability of the user story <i>"the winning move should switch the state to Win"</i> mentioned earlier: <br><br>  <b>expect (board.state) == .won (.cross)</b> <br><br>  Paraphrase this code as a sentence in English: <i>expect board to be won by cross (the board is expected to win the Cross (x))</i> .  Then the test will have the following form: <br><br>  <b>expect (board) .to (beWon (by: .cross))</b> <br><br>  Compilers in Nimble are nothing more than simple functions that return Predicate, where generic T is the type with which you compare.  In your case, T will be of type Board. <br><br>  In the project navigator, right-click the <b>AppTacToeTests</b> folder and select New File.  Select <b>Swift File</b> and click <b>Next</b> .  Name your file <b>Board + Nimble.swift</b> .  Make sure you set the file correctly as a member of your <b>AppTacToeTests</b> target task: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c76/cd9/400/c76cd9400b0f4973e3eca8fd78290961.png" alt="image"><br><br>  Replace the standard <b>import Foundation</b> with the following three imports: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Quick <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Nimble @testable <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppTacToe</code> </pre><br>  This code imports Quick and Nimble, and also imports your main target, so you can use the Board in your own comparison. <br><br>  As mentioned earlier, the Matcher is a simple function that returns a <b>Predicate</b> of the Board type. <br><br>  Add the main part of the mapping below the import: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beWon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(by: Board.Mark)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Predicate</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Board</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Predicate</span></span> { expression <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Error! ...your custom predicate implementation goes here } }</span></span></code> </pre><br>  This code defines the <b>beWon (by :)</b> mapping that Predicate returns, so it matches the Board correctly. <br><br>  Inside your function, you return a new instance of Predicate, passing it a closure with a single argument - expression - which is the value or expression you are comparing.  The closure should return a PredicateResult. <br><br>  At this point, you will see a compilation error, because the result has not yet been returned.  Further it will be corrected. <br><br>  To create a <b>PredicateResult</b> , you must consider the following cases: <br>  How <b>beWon (by :)</b> mapping works <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dce/133/db5/dce133db5c0492b1d45815e02600fc39.jpg" alt="image"><br><br>  Add the following code inside the Predicate closure, replacing the comment, // Error !: <br><br><pre> <code class="hljs cmake">// <span class="hljs-number"><span class="hljs-number">1</span></span> guard let board = try expression.evaluate() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PredicateResult(status: .fail, <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>: .fail(<span class="hljs-string"><span class="hljs-string">"failed evaluating expression"</span></span>)) } // <span class="hljs-number"><span class="hljs-number">2</span></span> guard board.state == .won(by) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PredicateResult(status: .fail, <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>: .expectedCustomValueTo(<span class="hljs-string"><span class="hljs-string">"be Won by \(by)"</span></span>, <span class="hljs-string"><span class="hljs-string">"\(board.state)"</span></span>)) } // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PredicateResult(status: .<span class="hljs-keyword"><span class="hljs-keyword">matches</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>: .expectedTo(<span class="hljs-string"><span class="hljs-string">"expectation fulfilled"</span></span>))</code> </pre><br>  Initially, this predicative implementation may seem confusing, but it's pretty simple if you follow it step by step: <br><br><ol><li>  You are trying to evaluate an expression passed to <b>expect ()</b> .  In this case, the expression is the board itself.  If the evaluation was failed, you return an unsuccessful PredicateResult with the appropriate message. </li><li>  You confirm that the state of the board is equal to <b>.won (by)</b> , where by is the argument passed to the Matcher function.  If the status does not match, you return a PredicateResult error with the message <b>.expectedCustomValueTo</b> . </li><li>  Finally, if everything looks good and is checked, you return a successful <b>PredicateResult</b> . </li></ol><br>  This is it!  Open <b>BoardSpec.swift</b> and replace the following line: <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board.state)</span></span></span><span class="hljs-function"> == .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">won</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(.cross)</span></span></span></span></code> </pre><br>  using the new mapping: <br><pre> <code class="hljs pgsql">expect(board).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>(beWon(<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>))</code> </pre><br>  Run the tests again by going to Product ‚ñ∏ Test or use the keyboard shortcut Command + U. You should see that all your tests still pass, but this time with the new Matcher! <br><br><h3>  What next? </h3><br>  Now you have the knowledge you need to write behavior-oriented tests in the application. <br><br>  You learned all about testing <i>user stories</i> , instead of testing implementation details, and how <b>Quick</b> helps to achieve this.  You also learned about <b>Nimble</b> comparisons and even wrote your own comparison.  Great! <br><br>  To get started with <b>Quick</b> and <b>Nimble</b> in your own project, start with the installation guide and <a href="">select the installation method</a> that is appropriate for your project. <br><br>  When you have everything set up, and you want to learn more about Quick, click on the link titled <a href="https://github.com/Quick/Quick/tree/master/Documentation/en-us">Quick's official documentation</a> .  Read also the <a href="">Readme Nimble for a wide</a> range of comparisons and features. </div><p>Source: <a href="https://habr.com/ru/post/352694/">https://habr.com/ru/post/352694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352682/index.html">Rsyslog 8. Centralized logging</a></li>
<li><a href="../352684/index.html">VulnHub Basic Pentesting</a></li>
<li><a href="../352686/index.html">SASS: Optimize the media screen</a></li>
<li><a href="../352688/index.html">Hellish project</a></li>
<li><a href="../352692/index.html">Sysmon to be safe. Enhance event auditing in Windows</a></li>
<li><a href="../352696/index.html">Product Design Digest March 2018</a></li>
<li><a href="../352698/index.html">Pre-sale engineer - personal psychologist of Sale or a person on the border of money and technology</a></li>
<li><a href="../352700/index.html">Matthias Noback on Ideal Architecture - Layers, Ports, and Adapters (Part 3 - Ports and Adapters)</a></li>
<li><a href="../352706/index.html">How to cut down a feature and not shoot yourself in the foot</a></li>
<li><a href="../352708/index.html">Basic Business Instinct: The Edge of Corporate Security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>