<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The process of developing and testing demons</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about the "low-level" bricks of our project - about demons.  Wikipedia definition:  ‚Äú Demon is a computer program on UNIX class sys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The process of developing and testing demons</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b21/cf6/c02/b21cf6c020d5429593c757eb4d0a5efb.jpg" align="left">  Today we will talk about the "low-level" bricks of our project - about demons. <div class="spoiler">  <b class="spoiler_title">Wikipedia definition:</b> <div class="spoiler_text">  ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25BD_%2528%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%2529">Demon</a> is a computer program on UNIX class systems, launched by the system itself and running in the background without direct user interaction.‚Äù </div></div><br>  Although it is not obvious, but almost all the functionality of the site depends on the work of these programs.  The game of ‚ÄúDating‚Äù, the search for new faces, the center of attention, messaging, statuses, geolocation and many other things are tied to one or another demon.  So we can say that they help people around the world to communicate and find new friends.  At the same time, several dozen demons can work and interact with each other on the site.  Their correct behavior is a very important task, so we decided to cover the main functionality of the daemons with autotests. <br><br>  In Badoo, this is a special department.  And today we will talk about how we go through the process of developing this critical part of the site and performing autotests.  This area is quite specific and there is a lot of material, so we prepared a structured overview of the whole process so that everyone who is interested could understand it. <br><br>  We use Git as VCS, TeamCity for continuous integration, and JIRA acts as a bug tracker.  For testing, we use PHPUnit.  Development of demons, like the rest of the site, is conducted on the principle of "feature - branch".  In order to understand what it is, we will look at the projections of our flow on Git and on JIRA. <br><a name="habracut"></a><br><h4>  Git flow </h4><br>  Work in Git can be schematically described with a picture: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/ff1/66c/d9a/ff166cd9a33243d89d43b4219a45f848.png"><br><br>  To work on the task from the master branch, fork a separate branch task_n, in which all development is done.  Then this branch and, possibly, several others merge into the so-called branch build_n.nn (or just a build), and only it already enters the master. <br><br><h4>  JIRA flow </h4><br>  The process in JIRA is more complex and involves more steps.  The figure below shows the main ones. <br><br><img src="https://habrastorage.org/files/415/d0d/959/415d0d959a7b43c1be1a99961ce9d245.png"><br><br>  <b>Open -&gt; In progress</b> <br>  <b>Open</b> status indicates that there is a task, but it has not yet begun.  When the programmer starts working and sends the first changes to our git-server (a branch appears in the name task_n, the identifier in JIRA), several events occur.  Firstly, the status of the task becomes <b>In progress</b> , and secondly, our TeamCity creates a separate assembly for this branch, which is launched every time a new developer pushes it.  Thanks to the efforts of release engineers and developers, artifacts from the assembly will be copied to the machines of our development environment, after that all regression tests will be launched, and the result of the run will be displayed in the TeamCity web interface.  When the developer considers that he has finished work on the task, he transfers the ticket with her to the <b>On Review</b> status. <br><br>  <b>On review</b> <br>  Here the task is thoroughly studied by a colleague.  If his glance did not find something to complain about, the ticket is transferred to the <b>In Branch QA</b> status. <br><br>  <b>In Branch QA</b> <br>  At this stage, the task falls to the tester.  He first of all looks at the result of the regression test run - suddenly some of them do not pass now.  In this case, there are two options: either everything is fine, this is the result of a new behavior and the regression tests need to be updated, or the daemon does not work as expected, then the task returns to the developer.  If revision of tests is necessary, the QA-engineer gets down to business closely.  It covers the demon's new behavior with tests, simultaneously correcting old ones, if necessary. <br><br>  <b>To Merge -&gt; In Build</b> <br><img src="https://habrastorage.org/files/caa/1b9/d89/caa1b9d89855445b9b3582b377910799.jpg" align="left">  When the developer and tester believe that the build from the task_n branch is stable and expected, the <b>To Merge</b> button is pressed in JIRA.  At this point, TeamCity ‚Äúmerges‚Äù the developer‚Äôs branch into the build_n.nn branch and launches its build.  The task again falls to the tester, but with the status of <b>In Build</b> . <br><br>  The fact is that during the merge unexpected conflicts can occur: while the branch was under testing, incompatible changes could be added to the build one.  When such a situation arises, the task is transferred to the programmer for manual merge in build.  Another problem may be falling regression tests or, in the worst case, inability to start a daemon.  This is solved by rolling back the task from the build branch with returning the ticket to the developer.  But if minor changes are needed to solve the problem, the task remains and a patch appears in the build itself. <br>  When the tests pass and the daemon is stable, the QA engineer assigns the status to the task to <b>In Build OK</b> and it returns to the developer.  Build a demon with a modified behavior becomes the main development environment devel and passes the test of battle. <br><br>  <b>In Build OK -&gt; On Production</b> <br>  At some point, many necessary changes are accumulated in the build branch, or critical tasks appear, and the developer decides that it is time to move the build to production.  The <b>Finish Build</b> button is pressed, and the new version of the demon, thanks to our valiant admins, starts working on the machines responsible for the real work of our site.  At this time, the build is merged into the master branch and a new build is created with the name build_m.mm, into which all new changes will fall.  Well, and the programmer's ticket will be set to <b>On Production</b> . <br><br>  Combining the two projections of the entire development process, we get the cycle shown below. <br><br><img src="https://habrastorage.org/files/fe4/cce/56d/fe4cce56dd484fd38c63a54e2420e0b8.png"><br><br>  Learn more about our development processes and tight integration of JIRA, TeamCity and Git in our articles <a href="http://habrahabr.ru/company/badoo/blog/193258/">here</a> , <a href="http://habrahabr.ru/company/badoo/blog/190572/">here</a> and <a href="http://habrahabr.ru/company/badoo/blog/169417/">here</a> . <br><br><h4>  Performing autotests </h4><br>  <b>Test object</b> <br>  First, let's define what we are testing. <br>  In our case, the program in general is a kind of binary file that runs from the terminal.  As arguments, various parameters affecting its operation can be passed to it: configuration files (‚Äúconfigs‚Äù), ports, log files, folders with scripts, etc.  Most often this is at least a config, and the launch string in this case will look like this: <br><br><blockquote><pre><code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> daemon_name -c daemon_config</code> </pre> <br></blockquote><br>  Once launched, the daemon waits for connections on several ports (socket files), which communicate with the outside world.  The format can be different, starting from text or JSON and ending with <a href="https://ru.wikipedia.org/wiki/Protocol_Buffers">protobuf</a> .  Usually supported immediately a couple of them.  Also, some demons have the ability to save their data to disk, and then load them at startup.  C and C ++ are mainly used for development, but Golang and Lua have recently been added. <br><br>  In general, the implementation of auto tests can be divided into several stages: <br><br><ol><li>  Preparation of the test environment. </li><li>  Run and run tests. </li><li>  Cleaning the test environment. </li></ol><br>  So, we run tests. <br><br><blockquote><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> phpunit daemon_tests/test.php --option=value</code> </pre><br></blockquote><br>  <b>Preparing the test environment</b> <br><img src="https://habrastorage.org/files/6ea/85f/44f/6ea85f44f3e4432182f100d36a08ec68.png" align="right">  After running the tests, the part of the code that is defined in the setUpBeforeClass and setUp constructors is first executed.  Just at this stage, the environment is prepared: first, the launch parameters are read, which we describe separately, then the necessary version of the binary file is selected, temporary folders, configs and various files that may be needed for work are created, and the databases are prepared if needed .  All created objects contain a unique identifier in the name, which is selected once in the constructor and then used everywhere.  This avoids a conflict while simultaneously running tests with several developers and testers. <br><br>  It often happens that a demon communicates with other demons during work ‚Äî it can receive or send data, receive or send commands from its kindred.  In this case, we use test stubs ("mocks") or run real demons.  When everything necessary is created, a daemon instance is launched with our config and working in our environment. <br><br>  Remember, I said that the daemon is waiting for a connection on the ports?  The last step is to create connections to them and check the demon's readiness for communication.  If all is well, then tests run directly. <br><br>  <b>Launch and execution</b> <br>  Most tests can be described by the algorithm: <br><br><img src="https://habrastorage.org/files/58b/947/081/58b9470817a34d0babe50eb57ade92ab.png"><br><br>  A <b>send request</b> can be one or more requests, resulting in a particular state.  Actions inside <b>get response</b> - getting a response, reading records in the database, reading a file.  <b>Assert,</b> however, means a wide range of actions: this is a validation of the response, evaluation of the state of the daemon, verification of data from neighboring demons, comparison of records in the database, and even verification of creating snapshots with the correct data. <br><br>  But our tests are not limited to the above-mentioned algorithm - we try to cover various aspects of our experimental life, if possible.  Therefore, random troubles can occur with it: it can be restarted several times, the data in the requests may be cut off or contain incorrect information, invalid settings may get into the configuration, the interlocutors of the daemon may not respond or mysteriously disappear. <br><br>  At the moment, the most difficult and interesting (in my opinion) is the area of ‚Äã‚Äãtesting inter-program interaction "demon-demon".  This is mainly due to the fact that the process of communication depends on many factors: internal logic, external requests, time, settings in the config, etc.  It becomes quite fun when our object can communicate with several different demons. <br><br>  <b>Cleaning the test environment</b> <br>  It would not have ended the tests, after you need to clean.  First of all, we close the connections, stop the daemon and all associated mocks or neighboring demons.  Then all files and folders created during tests are deleted if they are not needed, and the databases are cleared. <br><br>  The problem place here is cleaning after fatal errors - in some cases, temporary files may remain (sometimes even the daemon continues to work). <br><br>  A specific feature is superimposed on the whole described testing process - distribution across different machines.  The usual scenario now is to run tests on one server, and start the daemon on another.  Well, or on another server in the docker container. <br><br>  Let's return to the test run parameters.  Now the list consists of 5-6 options, and it is constantly growing.  All of them are aimed at facilitating the testing process and providing an opportunity to ‚Äúcustomize‚Äù tests a little, without getting into the code.  Here is our top: <br><ul><li>  <b>branch</b> .  The name of the ticket is transferred to JIRA, within which the work on the daemon was carried out.  Tests will use the binary file assembly of this particular task; </li><li>  <b>settings</b> .  The path to the ini-file is passed here, in which are test-specific things.  This may be the version of the build, the path to the default config, the user who starts the daemon, the location of the necessary files; </li><li>  <b>debug</b> .  If this flag is passed, tests run in debug mode.  For us, this means that the names of temporary files and folders will be readable, which allows them to be easily separated from the rest.  Also, all files created during the test run will not be deleted - this allows, if necessary, to play the falling tests; </li><li>  <b>script</b> .  When this flag is present, during the execution of the test, a php script is generated that repeats all the test actions until the end of the test or the assertion is triggered.  This script is completely independent, which helps with debugging a demon. </li></ul><br>  Today, this is all we would like to talk about, and we are happy to proceed to the questions in the comments. <br>  In stock, we have ideas for articles about creating scripts for playing a test, generating documentation, and using docker containers in tests ‚Äî tick off which topics you are most interested in. <br><br>  <i>Konstantin Karpov, QA engineer</i> </div><p>Source: <a href="https://habr.com/ru/post/254087/">https://habr.com/ru/post/254087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254071/index.html">Space landscape</a></li>
<li><a href="../254073/index.html">Lectures Technopark. Semester 2 Database</a></li>
<li><a href="../254075/index.html">What would JSON support look like in modern C ++?</a></li>
<li><a href="../254077/index.html">And once again about the unique constants</a></li>
<li><a href="../254079/index.html">Installation, configuration and use of Antidoto security scanner</a></li>
<li><a href="../254089/index.html">ROTE and Lua bind terminal emulation library</a></li>
<li><a href="../254091/index.html">Free online school of Android developers</a></li>
<li><a href="../254093/index.html">Algorithm Tasks</a></li>
<li><a href="../254097/index.html">How to avoid null pointer dereferencing, using the example of a single patch in the Linux kernel</a></li>
<li><a href="../254099/index.html">Wristwatches based on Arduino, created on a 3D printer in one Saturday evening</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>