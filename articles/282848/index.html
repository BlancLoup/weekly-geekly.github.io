<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Read more about the development of x-ray tomograph software</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scientists from Tomsk State University have created a microtomograph. The tomograph allows you to get to micron to learn about the internal structure ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Read more about the development of x-ray tomograph software</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/96f/5ef/9ab/96f5ef9ab16a49449217844fa566f41f.png"><br><br>  Scientists from Tomsk State University have created a microtomograph.  The tomograph allows you to get to micron to learn about the internal structure of various materials, such as diamonds. <br><br>  But it‚Äôs more interesting to stuff a fly into it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/diQGQEhnGLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  The <a href="https://www.edsd.com/projects/portfolio">EDISON Software Developement</a> was tasked to write software for the microtomograph.  About how they successfully coped with the task, there was an article <a href="https://habrahabr.ru/users/chookcha/" class="user_link">chookcha</a> on Habr√© ( <a href="https://habrahabr.ru/company/edison/blog/273295/">How to create software for a microtomograph for 5233 man-hours</a> ) with a description of algorithms, mathematical methods, implementation and debugging. <br><br>  Insatiable readers bombarded us with questions to which we finally formulated the answers ... <br><a name="habracut"></a><br>  The tomograph can enlighten the material with a resolution of up to microns.  It is 100 times thinner than a human hair.  After scanning, the program creates a 3D model, where you can look not only at the outer side of the part, but also find out what's inside. <br><br><div class="spoiler">  <b class="spoiler_title">Video scan results</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/6b2YZreJ8iE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/onWNZIA11v8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZLFdAtw_kWQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zJTsMkDBtcM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l3X9vHLbTnM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3a8ZHHgITDU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/onO5AeiKNOQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1jsI45BF5YA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/diQGQEhnGLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tomograph device</b> <div class="spoiler_text">  List of the main technical characteristics of the device. <br><br>  ‚Ä¢ Number of detector permitting elements: 2048 x 2018 cells with a size of one element of not more than 13.3 x 13.3 Œºm. <br>  ‚Ä¢ Resolution: 13 microns. <br>  ‚Ä¢ Overall dimensions: 504 x 992.5 x 1504 mm. <br>  ‚Ä¢ Weight: 450 kg. <br>  ‚Ä¢ Field of view: 1 mm. <br>  ‚Ä¢ Operating wavelength range: 0.3‚Äì2.3 A. <br>  ‚Ä¢ Accuracy of positioning of electromechanical motion modules in the PMT positioning system: ¬± 1 ¬µm. <br>  ‚Ä¢ Compliance with safety requirements: GOST 12.1.030-81. <br>  ‚Ä¢ X-ray protection: 1‚Äì3 ¬µSv / h. <br><br><img src="https://habrastorage.org/files/837/b4f/6c1/837b4f6c11e6422e889f9eafc69707ff.png"><br>  <i>Fig.</i>  <i>Appearance</i> <br><br><img src="https://habrastorage.org/files/f74/5fe/383/f745fe3830064e8da1bcdff9c27b736f.png"><br>  <i>Fig.</i>  <i>The principle of operation of the electro-mechanical part</i> <br><br><img src="https://habrastorage.org/files/59a/a0e/5ea/59aa0e5ea49f486d820dc1eb749ed341.png"><br>  <i>Fig.</i>  <i>X-ray source</i> <br><br>  ‚Ä¢ Voltage: 20‚Äì160 kV. <br>  ‚Ä¢ Current: 0‚Äì250 ŒºA. <br>  ‚Ä¢ Power: 10 watts. <br>  ‚Ä¢ Diameter of focal spot: 1‚Äì5 microns. <br><br><img src="https://habrastorage.org/files/4d3/dd9/aa2/4d3dd9aa25da40fb9ebb1ea53aec7294.png"><br>  <i>Fig.</i>  <i>Positioning</i> <br><br>  ‚Ä¢ Rotor stroke: SAMD - 360 ¬∞, LEMD - 100 mm. <br>  ‚Ä¢ Positioning accuracy, not less: ¬± 0.5 ¬µm. <br>  ‚Ä¢ The speed of the rotor: from 0.01 to 20 mm / s. <br>  ‚Ä¢ Power: 0.7 kW at 70 V. <br><br><img src="https://habrastorage.org/files/721/41e/971/72141e9716b648d3adf97e97ba391b24.png"><br>  <i>Fig.</i>  <i>X-ray detector based on CCD</i> <br><br>  ‚Ä¢ Sensitive area of ‚Äã‚Äãthe CCD: 2048 x 2048 pixels. <br>  ‚Ä¢ Geometrical pixel size: 13 x 13 microns. <br>  ‚Ä¢ Geometrical size of the sensitive area of ‚Äã‚Äãthe CCD: 26.6 x27.6 mm. <br>  ‚Ä¢ Built-in two-speed ADC: 16 bit, 100 kHz and 16 bit 2 MHz. <br></div></div><br><br><h4>  Question number 1 </h4><br>  <b>I would love to read about the conversion of the Radon transformation with a point source and about the implementation of this all using CUDA</b> <a href="https://habrahabr.ru/users/uranix/" class="user_link">Uranix</a> <br><br>  Radon calculation for a point source, if schematically described, is similar to calculation for parallel mode, but only the direction of the rays is not parallel, which affects the coordinates of points in the object cube where the densities are added.  With this schematic description, from the point of view of reconstruction, there is not much difference in which algorithm to use; only the coordinates of the segments / rays and the formula for calculating them change. <br><br>  Further, when, based on the shadow projection, we received rays from the source to each projection point in the coordinate space of the microtomograph, knowing the position of the rotating cube of the object, voxels lying on the beam are calculated along each of the rays.  Each voxel is assigned a pixel density value of the shadow projection into which the ray from the source enters, the data type of the scale is converted to float.  As a result, for each shadow projection, we repeat this projection operation on voxels, taking into account the projection angle.  After that, all the total voxel values ‚Äã‚Äãare normalized to the bit depth in which they will be stored in the future, usually it was a 16-bit unsigned integer.  This description explains in the most simplified way the scheme for reconstructing and obtaining the final voxel model, followed by a more detailed description of this algorithm. <br><br>  The X-ray system generates a flat shadow image of the complete internal volumetric structure of the sample, but in a separate shadow projection of the depth distribution of the structures of the sample are completely mixed.  Only X-ray tomography allows visualizing and measuring the spatial structures of samples without their chemical and mechanical processing. <br><br><img src="https://habrastorage.org/files/d86/0b1/dbe/d860b1dbefd94309b90417ba6d632a3c.jpg"><br>  <i>Fig.</i>  <i>1. Geometry of parallel beams</i> <br><br>  Any x-ray shadow image is a flat projection of a three-dimensional object.  In the simplest case, we can describe it as an image obtained in parallel x-rays (Fig. 1).  In this approximation, each point of the shadow image contains summary information on the adsorption of a particular X-ray beam over the entire volume of a three-dimensional object.  For the parallel geometry of X-ray beams, the reconstruction of a three-dimensional image of a sample from a two-dimensional shadow projection is realized using a series of reconstructions of two-dimensional sections of the sample along one-dimensional shadow lines.  The possibility of such reconstructions is demonstrated by a simple example: consider an object with a single point with high adsorption in an unknown place. <br><br><img src="https://habrastorage.org/files/52e/955/fab/52e955fab8d44d39a9d8b44f3d4b203e.jpg"><br>  <i>Figure 1.1.</i>  <i>Schematic representation of the three different positions of the absorbing region and the corresponding reconstruction from the resulting shadow projections</i> <br><br>  In a one-dimensional shadow line, a decrease in intensity due to its absorption on the absorbent object will be observed (Fig. 2).  Now we can simulate in computer memory an empty row of pixels (image elements) corresponding to the intended object displacement.  Naturally, it is necessary to make sure that all parts of the reconstructed object will be in sight.  Since we have the coordinates of the shadows from the absorbing areas of the object, we can select all possible positions of the absorbing areas inside the object as lines in the reconstructed area in the computer's memory.  Now we begin to rotate our object and repeat this operation.  In each new position of the object we will add to the reconstructed area lines of possible positions of the object in accordance with the position of its shadow projections.  This operation is called reverse projection.  After several turns, we can localize the position of the absorbing area inside the reconstruction volume.  With the increase in the number of shadow projections from different directions, this localization becomes more and more clear (Fig. 3). <br><br><img src="https://habrastorage.org/files/bfe/2e1/401/bfe2e1401cf2484886190a44ad52fc78.jpg"><br>  <i>Fig.</i>  <i>2. Reconstruction of a point object using a different number of displacements</i> <br><br>  In the case of reconstruction, based on an infinite number of projections, an image is obtained with a good clarity of determining the position of the absorption region inside the object under study.  At the same time, the dotted image will be accompanied by a blurred area, since it was obtained during the blending of lines with all possible deviations.  Now, since we know that the image is formed by a point object, we can carry out a preliminary correction of the initial information in the sorption lines in order to make the final image more relevant to the real object.  This correction adds a certain amount of negative adsorption along the outer edge of the point in order to remove the blurring inherent in the back projection process (Fig. 4).  This algorithm provides not only images of sections of individual point structures, but also allows you to explore real objects.  Each material object can be represented as a large number of individual elemental absorbing volumes and linear adsorption in each x-ray beam corresponds to the total adsorption on all absorbing structures encountered by the beam. <br><br><img src="https://habrastorage.org/files/6b5/53e/025/6b553e0250ae4faeba32f54fad8cf654.jpg"><br>  <i>Fig.</i>  <i>3. Back projection filtering</i> <br><br>  Thus, two-dimensional sections of the object can be restored from one-dimensional shadow lines from different angles.  However, most X-ray emitters are not capable of generating parallel beams of radiation.  In reality, point sources are used to produce conical X-ray beams. <br><br><img src="https://habrastorage.org/files/ac6/8b4/446/ac68b4446b2b48e594b2e2a85724b440.jpg"><br>  <i>Fig.</i>  <i>4. Geometry of diverging beam</i> <br><br>  In the fan geometry, the reconstructed sections will have some distortions in areas remote from the optical axis of the beam.  To solve this problem, we must use the algorithm of three-dimensional reconstruction of the conical beam (Feldkamp) to take into account the thickness of the object.  In other words, the rays passing through the front and back surfaces of the object will not be projected onto the same row of the detector (Fig. 6).  Thus, the most rapidly reconstructed section is the axial section, since it does not require a correction for the sample thickness. <br><br><img src="https://habrastorage.org/files/d68/e63/d84/d68e63d84a21406e876a762d820a67c7.jpg"><br>  <i>Fig.</i>  <i>5. Geometry of a conical beam</i> <br><br>  In the case of fluoroscopy of the sample image contains information on the reduction of the intensity of the incident radiation inside the object.  Since X-ray absorption is described by an exponential dependence (Lambert-Beer law), linear information on the adsorption of radiation from a shadow image can be disclosed using a logarithmic function.  Since logarithm is a non-linear operation, the slightest noise in the signal leads to significant errors in the reconstructions.  To avoid such errors, averaging of initial data can be used.  On the other hand, we could try to improve the signal-to-noise ratio in the shadow image by optimizing the exposure time to accumulate the most representative information.  The most effective way of noise reduction in the reconstruction process is the correct choice of the correction / filtering function for convolution before reverse projection.  In the simplest case (described above), the correction function produces two negative adsorption reactions around any signal or noise peak in the shadow line, and this behavior becomes very dangerous when working with a noisy signal.  The choice of correction for the function of convolution with spectral limitations (Hamming window) allows to solve this problem. <br><br><h4>  Job Description CUDA and Reconstruction </h4><br><h5>  Reconstruction of shadow projection data </h5><br>  The maximum size of the cube for the reconstruction is 1024x1024x1024 voxels.  Let's call such a cube unit.  The algorithm allows to reconstruct smaller cubes, but at the same time the dimension in all directions should be a multiple of 32. For one approach, a cube layer is reconstructed, no more than 128 MB, i.e.  1/8 unit cube.  If several CUDA devices are installed in the system, then the reconstruction will go on in parallel. <br><br>  Shadow projections are loaded into RAM during the first pass, in an amount sufficient to reconstruct the cube.  Those.  if the reconstruction of the cube requires 1200 lines from the shadow projection, and the height of the file is 2000, then these 1200 lines of data from the file are loaded into RAM and cached.  Since the reconstruction of the next cube, most likely, the projection segments will intersect, it will be possible to use the already loaded data again, reloading only new lines. <br><br><h5>  Server discovery and task distribution </h5><br>  UDP packets are used to locate clients and servers.  At start and every 5 seconds the server sends such a notification.  The client sends a broadcast request at the start, which forces the server to announce itself immediately.  The client, having received a notification about the presence of the server, establishes a TCP connection with it, through which control commands, tasks are sent, and notifications about the completion of the task are received.  All clients, servers, tasks have a unique identifier. <br><br>  When you disconnect from one server, it is considered that the server has stopped and its tasks are redistributed among others.  When a new server is connected, tasks from others are not selected or redirected to it.  Therefore, for uniform loading it is important to find all the servers at the beginning of the distribution of reconstruction tasks.  As the cubes are ready, it becomes possible to start merge tasks.  Tasks are sent to a random server.  Reconstruction and merge tasks are performed by servers in parallel. <br><br>  Tasks can come from multiple clients.  The server processes them in the order of receipt (FIFO).  The client prefers to distribute reconstruction tasks from one layer of single cubes to one server in order to reduce the amount of data needed by the reconstruction server.  The amount of RAM server determines the strategy for the reconstruction and compression of cubes.  If there is a lot of memory (more than 20 GB), then the compression of the previous cube and the reconstruction of the next one are performed in parallel, otherwise the reconstruction of the next cube does not start until the cube is fully processed, i.e.  compressed and saved to disk. <br><br><h5>  Basic reconstruction steps </h5><br>  First, the segments of the projections are determined, into which the reconstructed volume is projected taking into account the perspective.  Based on these data, it is determined which projections are needed for reconstruction.  If there are file segments in the RAM cache that are not included in this list, they are deleted from memory. <br><br>  The reconstruction stream is cached by the projection segment, the memory block containing the projection (considering the page size of 4096 bytes) is locked in the memory, which prohibits its unloading into the swap, and the pointer is passed to the CUDA procedure.  All further actions take place in the memory of the accelerator.  There is a decompression of 12 bits in the float, then all calculations are carried out in the float.  When unpacking, the segment is trimmed left and right to the width of the block being reconstructed, plus the gap required for convolution when filtering the projection.  Pre-processing occurs: inversion, gamma correction, filtering by average projection, the required number of smoothing iterations.  Next, a convolution occurs, and the segment is once again trimmed to the left and right to the minimum width necessary for reverse projection.  This is how projections are processed, as long as there is enough memory on the video card.  Those.  on the video card, an array of segments is formed that are ready for back projection. <br><br>  The essence of reverse projection is to sum up for each voxel from all projections the weight of the point from which the X-ray source beam hit.  One call to the CUDA core calculates 32 voxels located one above the other.  At the same time, a cycle is made for all projected segments loaded into memory.  This allows you to store all intermediate data in registers and not to make intermediate entries in memory.  At the end of the calculations, the density of the voxel is recorded in the memory.  The back projection core has 2 implementations, one slow with checks that there is a point on the projection from which to take data, since  there is not always a point at the ends of the projections where the value is taken from.  The quick implementation performs no checks.  The desired implementation is automatically selected.  The sampling of the value from the projection is made by the ‚Äúnearest neighbor‚Äù algorithm.  The use of texture memory in the first stages showed a sharp decrease in performance, and at this stage when using arrays of projections, it was impossible to create texture arrays due to limitations of CUDA 4.2. <br><br>  If there is not enough memory, then calculations may require several iterations of loading projections and back projection. <br><br>  Upon completion of the calculations, the voxels are evaluated.  The maximum and minimum density values ‚Äã‚Äãare calculated, a histogram is constructed.  The construction of the histogram and copying the results into RAM is performed in parallel. <br><br>  If there are multiple CUDA devices, the segments of the reconstructed cube are processed in parallel.  Upon completion of the cube reconstruction, another stream begins to engage in the compression of the cube, and the reconstruction flow is immediately taken to the next task, provided that there is enough RAM.  As it turned out, the allocation and release of large memory segments is a very time-consuming operation; therefore, all received large blocks of memory are reused.  So on CUDA memory allocation is made for a block of voxels, several intermediate buffers, and the rest of the memory will be allocated under the projection, and management of the placement of the projections in it is done manually. <br><br><h5>  Compression </h5><br>  Compression in the octree is made in several threads.  The number of threads depends on the number of processor cores.  Each thread processes its own octant.  Then it is saved to the file that was specified by the reconstruction client in the task, and a notification is sent that the cube processing is completed. <br><br><h5>  Customer </h5><br>  The client maintains a database of cubes in the form of a SQLite file.  It preserves the characteristics of cubes, the time of reconstruction, etc.  Upon completion of the reconstruction, the client program is closed, thus it is possible to organize batch reconstruction tasks. <br><br><h5>  CUDA code sample </h5><br>  The kernel (measureModel.cu), which makes the first pass when calculating the histogram.  The file is shown to show the general view of the code on CUDA in a real working project. <br><br><pre><code class="hljs pgsql">Ôªø#<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;iostream&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;cuda_runtime.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;cuda.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;device_functions.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "CudaUtils.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "measureModel.h" #define nullptr <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> struct MinAndMaxValue { <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">minValue</span></span>; float <span class="hljs-keyword"><span class="hljs-keyword">maxValue</span></span>; }; __global__ void cudaMeasureCubeKernel(float* src, MinAndMaxValue* dst, int ySize, int sliceSize, int blocksPerGridX) { int x = blockDim.x * blockIdx.x + threadIdx.x; int z = blockDim.y * blockIdx.y + threadIdx.y; int indx = z * blocksPerGridX * blockDim.x + x; MinAndMaxValue v; v.<span class="hljs-keyword"><span class="hljs-keyword">minValue</span></span> = src[indx]; v.<span class="hljs-keyword"><span class="hljs-keyword">maxValue</span></span> = v.<span class="hljs-keyword"><span class="hljs-keyword">minValue</span></span>; //indx += sliceSize; for (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ySize; ++i) { <span class="hljs-type"><span class="hljs-type">float</span></span> val = src[indx]; indx += sliceSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.minValue &gt; val) v.minValue = val; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.maxValue &lt; val) v.maxValue = val; } //        __shared__ MinAndMaxValue tmp[<span class="hljs-number"><span class="hljs-number">16</span></span>][<span class="hljs-number"><span class="hljs-number">16</span></span>]; tmp[threadIdx.y][threadIdx.x] = v; //       __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadIdx.y == <span class="hljs-number"><span class="hljs-number">0</span></span>) {//        <span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; blockDim.y; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.minValue &gt; tmp[i][threadIdx.x].minValue) v.minValue = tmp[i][threadIdx.x].minValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.maxValue &lt; tmp[i][threadIdx.x].maxValue) v.maxValue = tmp[i][threadIdx.x].maxValue; } tmp[<span class="hljs-number"><span class="hljs-number">0</span></span>][threadIdx.x] = v; } __syncthreads(); ///     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadIdx.x == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; threadIdx.y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; blockDim.y; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.minValue &gt; tmp[<span class="hljs-number"><span class="hljs-number">0</span></span>][i].minValue) v.minValue = tmp[<span class="hljs-number"><span class="hljs-number">0</span></span>][i].minValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.maxValue &lt; tmp[<span class="hljs-number"><span class="hljs-number">0</span></span>][i].maxValue) v.maxValue = tmp[<span class="hljs-number"><span class="hljs-number">0</span></span>][i].maxValue; } dst[blockIdx.y * blocksPerGridX + blockIdx.x] = v; } } <span class="hljs-type"><span class="hljs-type">void</span></span> Xrmt::Cuda::CudaMeasureCube(MeasureCubeParams ¬∂ms) { //      <span class="hljs-number"><span class="hljs-number">256</span></span>  <span class="hljs-type"><span class="hljs-type">int</span></span> threadsPerBlockX = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> threadsPerBlockZ = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> blocksPerGridX = (params.xSize + threadsPerBlockX - <span class="hljs-number"><span class="hljs-number">1</span></span>) / threadsPerBlockX; <span class="hljs-type"><span class="hljs-type">int</span></span> blocksPerGridZ = (params.zSize + threadsPerBlockZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) / threadsPerBlockZ; <span class="hljs-type"><span class="hljs-type">int</span></span> blockCount = blocksPerGridX * blocksPerGridZ; dim3 threadDim(threadsPerBlockX, threadsPerBlockZ); //  dim3 gridDim(blocksPerGridX, blocksPerGridZ); MinAndMaxValue *d_result = nullptr; size_t size = blockCount * sizeof(MinAndMaxValue); checkCudaErrors(cudaMalloc( (<span class="hljs-type"><span class="hljs-type">void</span></span>**) &amp;d_result, size)); cudaMeasureCubeKernel&lt;&lt;&lt;gridDim, threadDim&gt;&gt;&gt;( params.d_src, d_result, params.ySize, params.xSize * params.zSize, blocksPerGridX ); checkCudaErrors(cudaDeviceSynchronize()); MinAndMaxValue *result = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MinAndMaxValue[blockCount]; checkCudaErrors(cudaMemcpy(result, d_result, size, cudaMemcpyDeviceToHost)); params.maxValue = result[<span class="hljs-number"><span class="hljs-number">0</span></span>].maxValue; params.minValue = result[<span class="hljs-number"><span class="hljs-number">0</span></span>].minValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; blockCount; i++) { params.maxValue = std::max(params.maxValue, result[i].maxValue); params.minValue = std::min(params.minValue, result[i].minValue); } checkCudaErrors(cudaFree(d_result)); } __global__ <span class="hljs-type"><span class="hljs-type">void</span></span> cudaCropDensityKernel(<span class="hljs-type"><span class="hljs-type">float</span></span>* src, <span class="hljs-type"><span class="hljs-type">int</span></span> xSize, <span class="hljs-type"><span class="hljs-type">int</span></span> ySize, <span class="hljs-type"><span class="hljs-type">int</span></span> sliceSize, <span class="hljs-type"><span class="hljs-type">float</span></span> minDensity, <span class="hljs-type"><span class="hljs-type">float</span></span> maxDensity) { <span class="hljs-type"><span class="hljs-type">int</span></span> x = blockDim.x * blockIdx.x + threadIdx.x; <span class="hljs-type"><span class="hljs-type">int</span></span> z = blockDim.y * blockIdx.y + threadIdx.y; <span class="hljs-type"><span class="hljs-type">int</span></span> indx = z * xSize + x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ySize; ++i) { <span class="hljs-type"><span class="hljs-type">float</span></span> val = src[indx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; minDensity) src[indx] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; maxDensity) src[indx] = maxDensity; indx += sliceSize; } } <span class="hljs-type"><span class="hljs-type">void</span></span> Xrmt::Cuda::CudaPostProcessCube(PostProcessCubeParams ¬∂ms) { //      <span class="hljs-number"><span class="hljs-number">256</span></span>  <span class="hljs-type"><span class="hljs-type">int</span></span> threadsPerBlockX = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> threadsPerBlockZ = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> blocksPerGridX = (params.xSize + threadsPerBlockX - <span class="hljs-number"><span class="hljs-number">1</span></span>) / threadsPerBlockX; <span class="hljs-type"><span class="hljs-type">int</span></span> blocksPerGridZ = (params.zSize + threadsPerBlockZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) / threadsPerBlockZ; dim3 threadDim(threadsPerBlockX, threadsPerBlockZ); //  dim3 gridDim(blocksPerGridX, blocksPerGridZ); cudaCropDensityKernel&lt;&lt;&lt;gridDim, threadDim&gt;&gt;&gt;( params.d_src, params.xSize, params.ySize, params.xSize * params.zSize, params.minDensity, params.maxDensity ); checkCudaErrors(cudaDeviceSynchronize()); } //     #define DivideCount <span class="hljs-number"><span class="hljs-number">8</span></span> #define ValuesPerThread <span class="hljs-number"><span class="hljs-number">32</span></span> #define SplitCount <span class="hljs-number"><span class="hljs-number">16</span></span> #define SplitCount2 <span class="hljs-number"><span class="hljs-number">64</span></span> __global__ <span class="hljs-type"><span class="hljs-type">void</span></span> cudaBuildGistogramKernel( <span class="hljs-type"><span class="hljs-type">float</span></span> *src, <span class="hljs-type"><span class="hljs-type">int</span></span> count, <span class="hljs-type"><span class="hljs-type">int</span></span> *d_values, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">minValue</span></span>, int barCount ) { // ,     int barFrom = threadIdx.x * ValuesPerThread; int blockIndx = SplitCount * blockIdx.x + threadIdx.y; int blockLen = count / (SplitCount * SplitCount2); unsigned int values[ValuesPerThread]; for (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ValuesPerThread; i++) { <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } src += blockLen * blockIndx; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i = blockLen - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i<span class="hljs-comment"><span class="hljs-comment">--) { float v = src[i]; int indx = (int)((v - (float)minValue) * DivideCount) - barFrom; if (indx &gt;= 0 &amp;&amp; indx &lt; ValuesPerThread) values[indx]++; } for (int i = 0; i &lt; ValuesPerThread; i++) { d_values[blockIndx * barCount + barFrom + i] = values[i]; } } __global__ void cudaSumGistogramKernel( int *d_values, int barCount ) { // ,   int barIndx = blockIdx.x * ValuesPerThread + threadIdx.x; unsigned int sum = 0; d_values += barIndx; for (int i = 0 ; i &lt; SplitCount * SplitCount2; i++) { sum += d_values[i * barCount]; } d_values[0] = sum; } void Xrmt::Cuda::CudaBuildGistogram(BuildGistogramParams ¬∂ms) { checkCudaErrors(cudaMemcpyAsync( params.h_dst, params.d_src, params.count * sizeof(float), cudaMemcpyDeviceToHost, 0 )); //     int minValue = (int)(params.minDensity - 1);//      ,    ! minValue = std::max(minValue, -200); //    int maxValue = (int)params.maxDensity; maxValue = std::min(maxValue, 200); //    (  1   DivideCount ) int barCount = (maxValue - minValue + 1) * DivideCount; ///    ValuesPerThread int x32 = barCount % ValuesPerThread; barCount += (x32 == 0) ? 0 : ValuesPerThread - x32; /// : /// x -    32 , .. x    /// y -     SplitCount  dim3 threadDim(barCount / 32, SplitCount); /// ,     SplitCount2  dim3 gridDim(SplitCount2); ///        SplitCount2 * SplitCount  ///     barCount / 32  ///      int *d_values = nullptr; ///     size_t blockValuesCount = SplitCount2 * SplitCount * barCount; size_t d_size = blockValuesCount * sizeof(int); checkCudaErrors(cudaMalloc( (void**) &amp;d_values, d_size)); ///    cudaBuildGistogramKernel&lt;&lt;&lt;gridDim, threadDim&gt;&gt;&gt;( params.d_src, params.count, d_values, minValue, barCount ); //   GPU cudaSumGistogramKernel&lt;&lt;&lt;dim3(barCount / ValuesPerThread), dim3(ValuesPerThread)&gt;&gt;&gt;( d_values, barCount ); checkCudaErrors(cudaDeviceSynchronize()); //   params.histogramValues.resize(barCount); checkCudaErrors(cudaMemcpy( ¬∂ms.histogramValues[0], d_values, barCount * sizeof(int), cudaMemcpyDeviceToHost )); checkCudaErrors(cudaFree(d_values)); params.histogramStep = 1.0 / DivideCount; params.histogramStart = (float)minValue; }</span></span></code> </pre> <br><h4>  Question number 2 </h4><br>  <b>The camera that you used (PIXIS-XF, presumably) gives 2048x2048 images, and in the article you write ‚Äúup to 8000x8000‚Äù.</b>  <b>This is how you got?</b>  <b>Do you also move the sample or camera vertically and horizontally and then glue the pictures together?</b>  <a href="https://habrahabr.ru/users/andreydmitriev/" class="user_link">AndreyDmitriev</a> <br><br>  Yes, the PIXIS-XF: 2048B camera was used in the micro tomograph.  The size of the reconstruction according to TK 8000x8000x20000, in width and depth of 8000 means that the camera sees only a part of the image, but it is reconstructed more, this gives a drop in the quality of the reconstruction at the edges.  The table simply moves along the height, a new reconstruction is made, and the results are glued together. <br><br><h4>  Question number 3 </h4><br>  <b>The demo images that are in the video at the end of the article are all derived from 360 projections?</b>  <b>If so, then it is good, because 360 ‚Äã‚Äãprojections with a step to a degree are quite a few, usually going with a third / quarter degree step, otherwise there will be reconstruction artifacts.</b>  <b>It seems there is a formula for the optimal number of projections for a given resolution, but he forgot.</b>  <a href="https://habrahabr.ru/users/andreydmitriev/" class="user_link">AndreyDmitriev</a> <br><br>  In our case, 180-360 projections were used.  Different algorithms can produce different quality of reconstructions depending on the number of projections, but in general the rule is that the quality increases with an increase in the number of projections.  For our tasks, it was enough to use 180-360 projections to obtain good quality. <br><br>  The algorithm normally reacts to frame drops at the cost of a small decrease in resolution in the direction where there are gaps.  In addition, the camera had a peculiarity of overheating, and its ‚Äúbrightness‚Äù swam, therefore some of the frames were rejected as defective, the rest were normalized by the average brightness. <br><br><h4>  Question number 4 </h4><br>  <b>I also did not quite understand the frequency of the camera.</b>  <b>According to the specification, it is dual-frequency at 100 kilohertz or two megahertz.</b>  <b>If she has four megapixels, does this mean that she gives a frame every two seconds at the maximum frequency?</b>  <a href="https://habrahabr.ru/users/andreydmitriev/" class="user_link">AndreyDmitriev</a> <br><br>  Yes you are right. <br>  According to the <a href="http://www.princetoninstruments.com/userfiles/files/assetLibrary/Datasheets/Princeton-Instruments-PIXIS_XF_2048B_rev_N1_1-10-14-15.pdf">camera documentation</a> , the frequency characteristics are as follows: ADC speed / bits 100 kHz / 16-bit and 2 MHz / 16-bit <br><br>  That is, if one point of the image has a bit depth of 16bit, then we get that the frequency for the whole image will be: 2,000,000 / (2048 * 2048) = 0.47 hertz <br><br><h4>  Question number 5 </h4><br>  <b>Do you move the manipulator step by step or continuously?</b>  <b>How long does it take to scan typical samples that are presented in the video?</b>  <a href="https://habrahabr.ru/users/andreydmitriev/" class="user_link">AndreyDmitriev</a> <br><br>  The manipulator (table) moves step by step.  Turned to the corner, stopped, shot, turned again, etc. <br>  The average scan time is 11 minutes per 378 frames. <br><br><h4>  Question number 6 </h4><br>  <b>Well, about 12 bits - very curious.</b>  <b>The fact that cutting off four bits and packing every two pixels in three bytes is possible for storage and transmission is understandable.</b>  <b>But for the reconstruction you also have to re-deploy each pixel of at least two bytes?</b>  <b>Or do you have all the math on 12 bits?</b>  <b>In this case, how did you solve the problem that the pixels occupy one and a half bytes and are not aligned to the border?</b>  <a href="https://habrahabr.ru/users/andreydmitriev/" class="user_link">AndreyDmitriev</a> <br><br>  The file format is 12 bit lateral projections. <br><ol><li>  Pixels are packed bit by bit and arranged in rows, so that two points occupy 3 bytes, while it is assumed that the width of the projection image is a multiple of 2, according to the formula: lineWidthInBytes = width () * 3/2. </li><li>  Usually, the entire amount of data is not loaded immediately, but ‚Äúwindows‚Äù are used, in which only the necessary portion of the image is loaded, and the left and right borders are assumed to be a multiple of four pixels. </li><li>  After loading the ‚Äúwindow‚Äù, further work is carried out using the functions of full import / export of this window into float or quint arrays.  In the process of importing / exporting, a conversion from 12 bits to the required bit depth occurs. </li><li>  In our case, the gain from reducing the size of projection files was greater than the loss of performance in doing so.  In addition, since the files were not completely loaded, but only the ‚Äúwindows‚Äù intended for processing on a specific cluster machine, the performance loss is even less due to the parallelization of tasks. </li></ol><br><h4>  Volumetric (voxel) real-time rendering </h4><br>  Also interesting was the mapping of the model using voxels in real time.  In addition to the voxels of the model itself, it was necessary to display in 3D such tools as the bounding box, the section plane, hide half of the object along the section plane, and also hide the object outside the box.  On the cutting plane, the user interface element is displayed in the form of a ‚Äúlever‚Äù (which at the same time corresponds to the normal vector), which allows you to move the projection slice window along the cutting plane and shift the plane itself along the normal vector.  The projection slice window can also be stretched beyond its borders and rotated.  On the bounding box, in addition to its edges, the same ‚Äúlevers‚Äù appear on the plane, which also allow you to change its dimensions.  All these manipulations are performed in real time and the volume of the model space. <br><br>  A sufficient frame rate during operation was provided due to the dynamic level of detail, since the data is loaded automatically when the bounding box is reduced. <br><br>  For manipulation of interface elements in 3D, special sets of mathematical functions were implemented.  The initial creation of a cutting plane, if described in general terms without using formulas, looks like this: the user double-clicks the mouse at any point of the model, after which this point is fixed and the normal vector to the created plane is displayed from it with further mouse movement.  At the same time, the plane has already been created, and it lies on the ray coming from the screen coordinates of the mouse cursor into the space, not parallel to the perspective lines, so that the ray is projected as a point on the screen, and the orientation of the plane changes dynamically when the mouse is moved, immediately on the screen.  To complete the creation, click once again to fix the orientation of the plane. <br><br>  In addition to the elements of model manipulation, there are tools in the volume for controlling the color spectra of densities and levels of transparency. <br><br>  Directly, the rendering of voxels and cropping with the cutting plane and the bounding box were implemented using the VTK library. <br><br><h4>  List of Math Functions </h4><br>  Mathematical classes and functions used for geometric calculations in the project. <br>  1. Class <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BA%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_(%25D0%25B3%25D0%25B5%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%258F)">plane</a> . <br><ul><li>  <a href="http://www.nuru.ru/mat/alg/a012.htm">Description of the plane normal and point</a> . </li><li>  <a href="http://ege-ok.ru/2012/03/18/uravnenie-ploskosti">Description of the three points</a> . </li><li>  The angle of rotation of the 2D coordinate system inside the plane around the normal vector. </li><li>  Indenting the boundaries of a 2D rectangular area inside a plane with a reference point on the normal vector. </li><li>  The transition functions from a 2D point inside the plane rotated around the normal to real 3D coordinates and the inverse transform. </li></ul><br>  2. A set of mathematical functions for geometric calculations. <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Getting on the basis of the vector of two vectors mutually perpendicular and perpendicular to the original vector</a> . </li><li>  <a href="http://www.gamedev.ru/code/forum/%3Fid%3D75516">Getting a vector perpendicular to this vector in a 2D coordinate system</a> . </li><li>  Definition of an octant in the direction of a vector and vice versa creation of a vector in an octant. </li><li>  Correction of the center point of the plane for its positioning inside the bounding box. </li><li>  Check the entry point in the box. </li><li>  <a href="http://www.cleverstudents.ru/line_and_plane/intersection_point_of_line_and_plane.html">The intersection of the beam and the plane</a> . </li><li>  The intersection of the segment and the plane. </li><li>  <a href="http://ru.onlinemschool.com/math/library/analytic_geometry/p_line1/">The distance of a point from a straight line</a> . </li><li>  <a href="http://math.immf.ru/lections/004.html">Perpendicular to the line from an arbitrary point to a point on the line</a> . </li><li>  <a href="http://ru.onlinemschool.com/math/library/analytic_geometry/p_plane/">The distance from the point to the plane</a> . </li><li>  <a href="http://ateist.spb.ru/mw/distpoint.htm">The projection of the point on the plane</a> . </li><li>  <a href="http://yukhym.com/ru/vektory/skalyarnoe-i-vektornoe-proizvedeniya-proektsiya-vektora-na-vektor.html">Projection of vector onto vector</a> . </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Angle between 2D vectors</a> . </li></ul><br>  3. Mathematical functions used in the reconstruction. <br><ul><li>  Inversion. </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0-%25D0%25BA%25D0%25BE%25D1%2580%25D1%2580%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Gamma Correction</a> . </li><li>  Filtering averaged projection. </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">The required number of smoothing iterations</a> . </li><li>  Convolution. </li></ul><br><br> <a href="http://www.edsd.com/"><img src="https://habrastorage.org/files/398/998/a96/398998a96bd342d18422b1dbb66a271e.jpg" width="400"></a> <br><br>  More projects: <br>  <a href="https://habrahabr.ru/company/edison/blog/273295/">How to create software for a microtomograph for 5233 man-hours</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/282804/">SDK for the introduction of support for e-books in FB2 format</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/232033/">Control access to electronic documents.</a>  <a href="https://habrahabr.ru/company/edison/blog/232033/">From DefView to Vivaldi</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/317290/">Integrating two video surveillance systems: Axxon Next and SureView</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/282848/">Read more about the development of x-ray tomograph software</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/281765/">Sphere: how to monitor billions of kilowatt-hours</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/256789/">Developing a simple plugin for JIRA to work with a database</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/280550/">To help DevOps: a firmware builder for network devices on Debian for 1008 hours</a> <br>  <a href="https://habrahabr.ru/company/edison/blog/270777/">Windows Service Auto Update for Poor AWS</a> </div><p>Source: <a href="https://habr.com/ru/post/282848/">https://habr.com/ru/post/282848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282832/index.html">LinkedIn opens mega-data center in Singapore</a></li>
<li><a href="../282836/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ209 (April 25 - May 1, 2016)</a></li>
<li><a href="../282838/index.html">What happened to google maps?</a></li>
<li><a href="../282844/index.html">Entity ‚Äúframework‚Äù for PHP from one class</a></li>
<li><a href="../282846/index.html">Analysis of tasks with Google CTF 2016: Mobile</a></li>
<li><a href="../282850/index.html">Call Interception at 3CX Phone System</a></li>
<li><a href="../282852/index.html">Application server 1C on Linux</a></li>
<li><a href="../282854/index.html">Happy shipper</a></li>
<li><a href="../282858/index.html">MikroTik and 192.168.0.0/24</a></li>
<li><a href="../282860/index.html">Site protection against hacker attacks - Nemesida WAF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>