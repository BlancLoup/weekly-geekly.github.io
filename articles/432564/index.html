<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust 2018 came out ... but what is it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is written by Lin Clark in collaboration with the Rust development team (‚Äúwe‚Äù in the text). You can also read the post on the official Rus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust 2018 came out ... but what is it?</h1><div class="post__text post__text-html js-mediator-article"> The article is written by Lin Clark in collaboration with the Rust development team (‚Äúwe‚Äù in the text).  You can also read the <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">post</a> on the official Rust blog. <br><br>  The first version of Rust 2018 was released on December 6, 2018. In this release, we focused on performance so that the Rust developers can work as efficiently as possible. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">The timeline shows the transition of functions from the beta version to Rust 2018 and Rust 2015. It is surrounded by icons for tools and four areas: WebAssembly, embedded, networking and CLI.</font></i>  <i><font color="gray">The red circle - developer efficiency - surrounds everything except Rust 2015</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But in general it is not easy to explain what Rust 2018 is. <br><br>  Some people present it with a new version of the language ... approximately it is, but not quite.  I say ‚Äúnot really‚Äù, because here ‚Äúnew version‚Äù means not that new versions of other languages. <br><a name="habracut"></a><br>  In most other languages, all new features add a new version.  The previous version is not updated. <br><br>  The Rust system works differently.  This is due to how language develops.  Almost all new features are 100% compatible with Rust.  They do not require any changes.  This means that there is no reason to limit them with the Rust 2018 code. New versions of the compiler will continue to support ‚ÄúRust 2015 mode‚Äù by default. <br><br>  But sometimes language development requires innovation, for example, a new syntax.  And this new syntax can break existing code bases. <br><br>  For example, the function <code>async/await</code> .  Initially, there were no such concepts in Rust.  But it turned out that these primitives are really useful, they simplify writing asynchronous code. <br><br>  For this function, you must add the keywords <code>async</code> and <code>await</code> .  But care should be taken not to break the old code, where <code>async</code> or <code>await</code> could be used as variable names. <br><br>  Thus, we add keywords to Rust 2018. Although the function has not yet come out, keywords are now reserved.  All incompatible changes for the next three years of development (for example, adding new keywords) are made at the same time in Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Although there are incompatible changes in Rust 2018, this does not mean that your code will break.  Even with the <code>async</code> and <code>await</code> variables, the code will be compiled.  By default, the compiler works as before. <br><br>  But if you want to use one of the new functions, you can choose the new compilation mode Rust 2018. The team will tell <code>cargo fix</code> if you need to update the code to use the new functions and automate the process of making changes.  Then you can add <code>edition=2018</code> to your Cargo.toml, if you agree on the use of new functions. <br><br>  This version specifier in Cargo.toml does not apply to the entire project and does not apply to your dependencies.  It is limited to one particular crate.  That is, you can use Rust 2015 and Rust 2018 cracks at the same time. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Therefore, even when using Rust 2018, everything looks approximately the same as Rust 2015. Most changes are implemented simultaneously in Rust 2018 and Rust 2015. Only a few functions require incompatible changes. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 is not only a change of the main language.  Far not only they. <br><br>  Rust 2018 is primarily a push to increase the productivity of Rust developers, thanks in large part to tools that are outside the language, as well as working out specific applications and understanding how to make Rust the most effective programming language for these cases. <br><br>  Thus, you can think of Rust 2018 as a specifier in Cargo.toml, which is used to enable several functions that require incompatible changes ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Or you can imagine it at the point in time when Rust becomes one of the most effective languages ‚Äã‚Äãfor many applications ‚Äî when you need performance, efficient use of resources, or high reliability. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  We prefer the second definition.  So let's look at all the enhancements made outside the language, and then dive into the language itself. <br><br><h1>  Rust for specific applications </h1><br>  A programming language cannot be effective by itself, in the abstract.  It is effective in a particular application.  Therefore, we understood that it was necessary not just to improve Rust as a language or a tool.  It is also necessary to simplify the use of Rust in certain areas. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  In some cases, this meant creating a completely new set of tools for a completely new ecosystem.  In other cases - polishing of already existing functions and good documentation in order to make it easier to lift and run a working system. <br><br>  The Rust development team has formed working groups in four areas: <br><br><ul><li>  WebAssembly </li><li>  Embedded Applications </li><li>  Network tasks </li><li>  Command line tools </li></ul><br><h2>  WebAssembly </h2><br>  WebAssembly had to create a completely new set of tools. <br><br>  Only last year, WebAssembly made it possible to compile languages ‚Äã‚Äãlike Rust to run on the Internet.  Since then, Rust has quickly become the best language to integrate with existing web applications. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust works well for web development for two reasons: <br><br><ol><li>  Cargo ecosystem crate works the way most web application developers are used to.  Combine a bunch of small modules to form a larger application.  This means that Rust is easy to use exactly where needed. </li><li>  Rust consumes few resources and does not require a runtime environment.  Do not need a lot of code.  If you have a tiny module that does a lot of hard computing work, embed a few lines of Rust to speed it up. </li></ol><br>  Using <a href="https://rustwasm.github.io/2018/09/26/announcing-web-sys.html">web-sys and js-sys crates</a> from Rust code, it is easy to call web APIs, such as <code>fetch</code> or <code>appendChild</code> .  And <code>wasm-bindgen</code> simplifies support for high-level data types that WebAssembly does not natively support. <br><br>  After writing the Rust WebAssembly module, there are tools to easily connect it to the rest of the web application.  You can use the <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a> to automatically run these tools and launch the module in npm if you wish. <br><br>  For details, see the <a href="https://rustwasm.github.io/book/">book ‚ÄúRust and WebAssembly‚Äù</a> . <br><br><h4>  What's next? </h4><br>  After the release of Rust 2018, developers plan to discuss with the community in which areas to work further. <br><br><h2>  Embedded Applications </h2><br>  For embedded development, it was necessary to increase the stability of the existing functionality. <br><br>  In theory, Rust has always been a good language for embedded applications.  This is a modern toolkit, which was sorely lacking for developers, and very convenient high-level language functions.  All this without unnecessary load on the CPU and memory.  So Rust is great for embedded. <br><br>  But in practice it turned out differently.  The <a href="https://blog.rust-lang.org/2014/10/30/Stability.html">stable channel</a> lacked the necessary functions.  In addition, for use on embedded devices, it was necessary to change the standard library.  This means that people had to compile their own version of the Rust core crate (the crate used in each Rust application to provide the basic building blocks of Rust ‚Äî the built-in functions and primitives). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  As a result, the developers depended on the experimental version of Rust.  And in the absence of automatic tests, the experimental assembly often did not work on microcontrollers. <br><br>  To fix this, the developers tried to transfer all the necessary functions to a stable channel, add tests to the CI system for microcontrollers.  This means that changing a desktop component will not break the embedded version. <br><br>  With such changes, the development of embedded systems on Rust is moving from the field of advanced experiments to the area of ‚Äã‚Äãnormal efficiency. <br><br>  For details, see the <a href="https://rust-embedded.github.io/book/">book ‚ÄúRust for embedded systems‚Äù</a> . <br><br><h4>  What's next? </h4><br>  This year, Rust got really good support for the popular ARM Cortex-M family.  However, many architectures are not yet well supported.  You need to extend Rust for similar support for other architectures. <br><br><h2>  Network tasks </h2><br>  To work on the network, it was necessary to build in the language a key abstraction: <code>async/await</code> .  Thus, developers can use standard idioms of Rust even in asynchronous code. <br><br>  In network tasks often have to wait.  For example, a response to a request.  If the code is synchronous, the operation will be stopped: the core of the processor on which the code is executed cannot do anything until the request arrives.  But in the asynchronous code, such a function can be put on standby, while the CPU core will do the rest for now. <br><br>  Asynchronous programming is also possible in Rust 2015, and there are many advantages to this.  In high-performance applications, the server application will handle many more connections per server.  Embedded applications on tiny single-threaded CPUs optimize the use of a single thread. <br><br>  But these advantages are accompanied by a major drawback: for such a code there is no validation of borrowing and you will have to use non-standard (and slightly confused) idioms of Rust.  This is the benefit of <code>async/await</code> .  This gives the compiler the necessary information to check borrowing asynchronous function calls. <br><br>  Keywords for <code>async/await</code> implemented in version 1.31, although they are not currently supported by implementation.  Most of the work is done, and the function should be available in the next release. <br><br><h4>  What's next? </h4><br>  In addition to efficient low-level development, Rust can provide more efficient development of network applications at a higher level. <br><br>  Many servers perform routine tasks: analyze URLs or work with HTTP.  If you turn them into components ‚Äî common abstractions that are shared as crates ‚Äî then it will be easy to connect them to each other, forming all sorts of server and framework configurations. <br><br>  An experimental <a href="https://github.com/rust-net-web/tide">Tide framework has been</a> created for the development and testing of components. <br><br><h2>  Command line tools </h2><br>  For command-line tools, it was necessary to combine small low-level libraries into a higher-level abstraction and polish some existing tools. <br><br>  For some scripts, bash is ideal.  For example, to simply invoke other shell tools and transfer data between them. <br><br>  But Rust is a great option for many other tools.  For example, if you are creating a complex tool like <a href="https://github.com/BurntSushi/ripgrep/">ripgrep</a> or a CLI tool on top of the functionality of an existing library. <br><br>  Rust does not require a runtime environment and compiles into one static binary, which makes it easier to distribute the program.  And you get high-level abstractions that are not found in other languages, such as C and C ++. <br><br>  What else can improve Rust?  Of course, abstractions are even higher. <br><br>  With higher level abstractions, ready-made CLI is quickly and easily assembled. <br><br>  An example of such an abstraction is the <a href="https://github.com/rust-clique/human-panic">human panic</a> library.  In the absence of such a library in the event of a failure, the CLI code is likely to produce the entire reverse trace.  But it is not very interesting to users.  You can add special error handling, but this is difficult. <br><br>  With the human panic library, the output will automatically go to the error dump file.  The user will see an informative message prompting you to report a problem and upload a dump file. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Getting started developing CLI tools is also easier.  For example, the <a href="https://github.com/rust-clique/confy">confy</a> library automates its setting.  He asks only two things: <br><br><ul><li>  What is the name of the application? </li><li>  What configuration parameters do you want to provide (which you define as a structure that can be serialized and deserialized)? </li></ul><br>  All the rest will be determined by confy. <br><br><h4>  What's next? </h4><br>  We have abstracted many tasks for the CLI.  But you can abstract something else.  We are going to release more such high level libraries. <br><br><h1>  Rust Tools </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  When you write in a language, you work with its tools: starting with the editor and continuing with other tools at all stages of development and support. <br><br>  This means that an effective language depends on effective tools. <br><br>  Here are some new tools (and enhancements to existing ones) in Rust 2018. <br><br><h2>  IDE support </h2><br>  Of course, performance depends on quickly and smoothly transferring code from the developer‚Äôs mind to the computer screen.  IDE support is crucial here.  To do this, you need tools that can ‚Äúexplain‚Äù the IDE meaning of the Rust code: for example, suggest meaningful options for autocompleting lines. <br><br>  In Rust 2018, the community focused on the functions required by the IDE.  With the advent of the Rust Language Server and IntelliJ Rust, many IDEs now fully support Rust. <br><br><h2>  Faster compilation </h2><br>  Improving the efficiency of the compiler means accelerating it.  This is what we did. <br><br>  Previously, when you compiled the Rust crate, the compiler recompiled every single file in the crate.  Now incremental compilation is implemented: it compiles only those parts that have changed.  Along with other optimizations, this made the Rust compiler much faster. <br><br><h2>  rustfmt </h2><br>  Efficiency also requires that we never argue about the rules of code formatting and do not manually fix other people's styles. <br><br>  The rustfmt tool helps with this: it automatically reformats the code in accordance with the default style (according to which the <a href="https://github.com/rust-lang/rfcs/pull/2436">community has reached a consensus</a> ).  Rustfmt ensures that all Rust code matches the same style, like clang for C ++ or Prettier for JavaScript. <br><br><h2>  Clippy </h2><br>  Sometimes it's nice to have an experienced consultant nearby who gives advice on best practices when writing code.  Clippy does this: it checks the code while viewing it and suggests standard idioms. <br><br><h2>  rustfix </h2><br>  But if you have an old code base with outdated idioms, then checking and correcting the code yourself can be tedious.  You just want someone to fix the entire codebase. <br><br>  In these cases, rustfix automates the process.  It simultaneously applies the rules from tools like Clippy, and updates the old code in accordance with the idioms of Rust 2018. <br><br><h1>  Changes in Rust itself </h1><br>  Changes in the ecosystem have greatly increased the efficiency of programming.  But some problems can be solved only by changes in the language itself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  As we said in the introduction, most language changes are fully compatible with existing Rust code.  All these changes are part of Rust 2018. But since they break nothing, they work in any Rust code ... even in the old one. <br><br>  Let's look at the important features that have been added to all versions.  Then look at a small list of features of Rust 2018. <br><br><h2>  New features for all versions </h2><br>  Here is a small example of new features that are (or will be) in all versions of the language. <br><br><h4>  More accurate borrowing check </h4><br>  One big advantage of Rust is borrowing verification.  It ensures that the code is safe for memory.  But this is also a rather difficult feature for newcomers to Rust. <br><br>  Part of the difficulty lies in learning new concepts.  But there is another part ... Borrowing verification sometimes rejects code that seems to be working from the point of view of a programmer who fully understands the concept of memory security. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">You cannot borrow a variable because it has already been borrowed.</font></i> <br><br>  This happens because the borrowing lifetime supposedly should have spread to the end of its field ‚Äî for example, to the end of the function in which the variable is located. <br><br>  This meant that even if the variable completed its work with a value and no longer tries to gain access, other variables are still denied access to this value until the end of the function. <br><br>  To correct the situation, we made the check smarter.  Now she sees when the variable has <i>actually</i> completed using the value.  After that, it does not block the use of data. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  While it is available only in Rust 2018, but in the near future the function will be added to all other versions.  Soon we will write more on this topic. <br><br><h4>  Procedural macros in stable Rust </h4><br>  Macros in Rust were before Rust 1.0.  But in Rust 2018, major improvements were made, for example, procedural macros appeared.  They allow you to add your own syntax to Rust. <br><br>  Rust 2018 offers two types of procedural macros: <br><br><h4>  Macros like functions </h4><br>  Macros like functions allow you to create objects that look like normal function calls, but are actually executed at compile time.  They take one code and give another, which the compiler then inserts into a binary file. <br><br>  They existed before, but with limited.  The macro could only execute the match statement.  He did not have access to view all the tokens in the incoming code. <br><br>  But with procedural macros, you get the same input as the parser: the same stream of tokens.  This means that you can create much more powerful macros like functions. <br><br><h4>  Attribute-like macros </h4><br>  If you are familiar with decorators in languages ‚Äã‚Äãlike JavaScript, attribute macros are very similar.  They allow you to annotate code snippets on Rust, which should be pre-processed and turned into something else. <br><br>  The <code>derive</code> macro does exactly that.  When you put it over a structure, the compiler takes this structure (after it has been analyzed as a list of tokens) and processes it.  In particular, it adds the basic implementation of functions from the trait. <br><br><h4>  More ergonomic borrowing in comparisons </h4><br>  There is a simple change. <br><br>  Previously, if you wanted to borrow something and tried to do the mapping, you had to add some strange syntax: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Now, instead of <code>&amp;Some(ref s)</code> we simply write <code>Some(s)</code> . <br><br><h1>  New features of Rust 2018 </h1><br>  The smallest part of Rust 2018 is a function specific to this version.  Here is a small set of changes in Rust 2018. <br><br><h3>  Keywords </h3><br>  Several keywords have been added to Rust 2018: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  These functions are not yet fully implemented, but keywords have been added to Rust 1.31.  ,         (    ),     . <br><br><h3>   </h3><br>      Rust ‚Äî  .  And I understand why.   ,  Rust     .   ,       . <br><br> ,    ,         .       ,     . <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br>   ‚Äî  <code>::</code> ,      ,    .  ,   . <br><br>     .        ,    <code>crate::</code> .       . <br><br>   ,      Rust 2018,  ,       .     .      Cargo.toml   <code>cargo fix</code> ‚Äî  <code>rustfix</code>   . <br><br><h1>  Additional Information </h1><br>        <a href="https://rust-lang-nursery.github.io/edition-guide/rust-2018/index.html">¬´  Rust 2018¬ª</a> . </div><p>Source: <a href="https://habr.com/ru/post/432564/">https://habr.com/ru/post/432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432554/index.html">Douglas Engelbart: Strengthening the "collective IQ" of society</a></li>
<li><a href="../432556/index.html">Tesla has patented technology for vehicle positioning.</a></li>
<li><a href="../432558/index.html">Architectural pattern "Visitor" ("Visitor") in the universe of "iOS" and "Swift"</a></li>
<li><a href="../432560/index.html">Typography on the web. Yandex lecture on FrontTalks 2018</a></li>
<li><a href="../432562/index.html">Techday Make IT Real - December 17, Moscow</a></li>
<li><a href="../432566/index.html">Two worlds or "engineers have something to say." About the various types of complex tasks and processes associated with them</a></li>
<li><a href="../432568/index.html">‚ÄúWhen you are the editor in chief of Rusbase‚Äù: a new podcast about working with content and a career in technology media</a></li>
<li><a href="../432572/index.html">Metal-air transistor will extend Moore's law - how technology works</a></li>
<li><a href="../432574/index.html">Difficult development of simple devices</a></li>
<li><a href="../432576/index.html">Under the hood JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>