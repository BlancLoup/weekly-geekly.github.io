<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel noise and random number functions for OpenCL cores</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The sample Noise code attached to this article includes the implementation of the Perlin noise generation algorithm, useful for shaping natural-lookin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel noise and random number functions for OpenCL cores</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/e1a/644/01b/e1a64401b22d47d5824ff2a3e89956a0.jpg">  <a href="">The sample Noise code</a> attached to this article includes the implementation of the Perlin noise generation algorithm, useful for shaping natural-looking textures, such as marble or clouds, for three-dimensional graphics.  The article includes a test that uses the Perlin noise algorithm to create the ‚Äúcloud‚Äù image.  (For more information about the Perlin noise algorithm, see the Reference section.) The two-dimensional and three-dimensional versions of the algorithm are included.  This means that the functions take two or three data sets as input to create one output Perlin noise value. <br>  The Noise example also includes pseudo-random number generator (RNG) functions that produce relatively good results, enough to make the resulting image really look random.  The one-dimensional, two-dimensional and three-dimensional versions are included: the number of measurements and in this case is equal to the number of input data sets, on the basis of which one pseudo-random output value is formed. <br><a name="habracut"></a><br><h1>  <font color="#0071c5">Introduction and Motivation</font> </h1><br>  In many applications, some degree of ‚Äúrandomness‚Äù or, more precisely, ‚Äúpseudo-randomness‚Äù is required.  We are talking about sequences of values ‚Äã‚Äãthat seem to a person arbitrary, erratic, that is, "noise".  In this case, for repeatability purposes, applications often require that a random number generator can, with sufficient reliability, produce exactly the same sequence when obtaining the same input values ‚Äã‚Äã(or sets of values). <br><br>  In most algorithms for generating random numbers, this requirement is satisfied by the fact that each generated value depends on the previous value formed, and the first value formed in the sequence is derived directly from the input value.  This approach to random number generators is difficult for languages ‚Äã‚Äãwith a high level of parallel computing, such as OpenCL.  If you force each of the many computing threads to wait for one sequential source of random numbers, then all the advantages of parallelization and algorithms based on parallel processing will be reduced to zero. <br><br>  One of the possible ways to solve this problem is to calculate a large table of random values ‚Äã‚Äãin advance.  After that, each of the parallel threads will create unique, but strictly defined indexes on this table.  For example, an <a href="https://www.khronos.org/opencl/">OpenCL</a> core that processes an image can select an entry from a previously created table by calculating an index based on the coordinates of the pixel that is being processed or created by the core. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The disadvantage of this approach is the need for a lengthy sequential process of creating random numbers before the start of the parallel algorithm, which limits the increase in performance during parallelization.  Also in this case, it is required in advance (before running the parallel algorithm) at least approximately to know the number of random numbers needed.  This can be difficult for parallel algorithms that need to dynamically determine exactly how many random values ‚Äã‚Äãeach stream will use. <br><br>  In the OpenCL core-level functions in the Noise code sample, an approach that is more appropriate to the OpenCL partitioning algorithm for parallel operations is used. <br><br><h1>  <font color="#0071c5">Creating noise and random numbers for OpenCL</font> </h1><br>  In OpenCL, a global workspace (work item array) is defined using one, two, or three dimensions.  Each work item in this global space has a unique set of identifying integer values ‚Äã‚Äãcorresponding to the coordinates along the X, Y, and Z axes in the global space. <br><br>  The Perlin noise and random number generator functions in the Noise example create a random number (noise) based on up to three input values, which can be the global identifiers of each work item.  There is another algorithm: one or several values ‚Äã‚Äãcan be created by combining global identifiers and any data values ‚Äã‚Äãobtained or created by the kernel. <br><br>  For example, the following fragment of the OpenCL core code shows the creation of random numbers based on a two-dimensional global identifier of the work item. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">genRand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint x = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); uint y = get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>); uint rand_num = ParallelRNG2( x, y ); ...</code> </pre> <br>  <i>Figure 1. Example of using random numbers (two dimensions)</i> <br><br>  This approach makes it possible to run the functions of a random number generator or noise in parallel between work items, but at the same time get results with repeated sequences of values ‚Äã‚Äãthat differ randomly both between work items and between other values ‚Äã‚Äãwithin the same work item.  If you need to create multiple two-dimensional value sets, you can use three-dimensional creation functions: the first two input values ‚Äã‚Äãwill be obtained from the global identifiers of the work item, and the third dimension - by successively increasing any initial value for each additional value required.  This algorithm can be extended to work with several sets of three-dimensional random values ‚Äã‚Äãor noise values, as in the following example with Perlin noise. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multi2dNoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fScale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fX = fScale * get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fY = fScale * get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fZ = offset; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randResult = Noise_3d( fX, fY, fZ ); ...</code> </pre><br>  <i>Figure 2. An example of using the Perlin noise algorithm (three dimensions)</i> <br><br><h1>  <font color="#0071c5">Restrictions</font> </h1><br>  The Noise_2d and Noise_3d functions use the same basic Perlin noise algorithm, but the implementation is different based on the recommendations of Perlin.  (See the first link in the list of reference materials.) In the Noise sample, only Noise_3d is used in the noise example, and the Noise_2d test core is included in the Noise.cl file for readers who want to change this example and experiment with it. <br><br>  Noise_2d and Noise_3d functions should be called with floating-point input values.  Values ‚Äã‚Äãmust span a range, for example (0.0, 128.0), to set the size of the ‚Äútable‚Äù (see Figure 3) for random values.  Readers should look at the cloud example in order to understand how Perlin‚Äôs noise can be transformed into a variety of ‚Äúnatural-looking‚Äù images. <br><br>  The default ParallelRNG function used in the random test provides random (and seemingly similar) results, but is not the fastest random number generator algorithm.  This function is based on the ‚ÄúWong hash‚Äù, which was not originally intended to be used as a random number generator.  Nevertheless, some common functions of random number generators (commented out example in the file Noise.cl) showed visible repeatability when filling two-dimensional images, especially in the bits of the lower bit of the results.  Readers can experiment with other (faster) functions of random number generators. <br><br>  The default ParallelRNG function creates only 32-bit unsigned integers as results.  If floating-point values ‚Äã‚Äãare required for a range such as (0.0, 1.0), then the application should apply a mapping for that range.  The random sample matches the unsigned random integer result with a range (0, 255) to create pixel values ‚Äã‚Äãin shades of gray.  To do this, simply use the binary AND operation to select 8 bits. <br><br>  The default ParallelRNG function will not create all 4 294 967 296 (2 <sup>32</sup> ) unsigned integer values ‚Äã‚Äãfor successive calls based on the value created earlier.  For each individual initial value, the magnitude of the pseudo-random sequences (cycles) can range from just 7,000 unique values ‚Äã‚Äãto approximately 2 billion values.  ParallelRNG creates about 20 different loops.  The author considers it unlikely that any operating element of the OpenCL core may require more sequentially generated random numbers than it is formed in the smallest cycle. <br><br>  The two-dimensional and three-dimensional versions of this function ‚Äî ParallelRNG2 and ParallelRNG3 ‚Äî use "blending" of loops by applying a binary XOR operation between the result of a previous ParallelRNG call and the next input value, which changes the loop lengths.  However, this changed behavior has not been analyzed in detail, so the reader is advised to carefully verify that the ParallelRNG functions meet the needs of the application. <br><br><h1>  <font color="#0071c5">Project structure</font> </h1><br>  This section lists only the main elements of the sample application source code. <br><br><h4>  NoiseMain.cpp: </h4><br><h5>  main () </h5><br>  main input function.  After parsing the command line parameters, it initializes OpenCL, builds the OpenCL program from the Noise.cl file, prepares one of the cores for launch, and calls <i>ExecuteNoiseKernel ()</i> , and then <i>ExecuteNoiseReference ()</i> .  Checking that these two implementations produce the same results, <i>main ()</i> gives information about the operation time of each of these functions and stores the images resulting from their work. <br><br><h5>  ExecuteNoiseKernel () </h5><br>  Configure and run the selected Noise kernel in OpenCL. <br><br><h5>  ExecuteNoiseReference () </h5><br>  Set up and run selected Noise reference code in C. <br><br><h4>  Noise.cl: </h4><br><h5>  defaut_perm [256] </h5><br>  Table of random values ‚Äã‚Äã0‚Äì255 for the core of three-dimensional Perlin noise.  To further increase the randomness, this table can be formed and transferred to the Perlin noise core. <br><br><h5>  grads2d [16] </h5><br>  16 uniformly distributed unit vectors, gradients for the core two-dimensional Perlin noise. <br><br><h5>  grads3d [16] </h5><br>  16 vector gradients for the core Perlin noise. <br><br><h5>  ParallelRNG () </h5><br>  Pseudo-random number generator, one pass for one input value.  The alternate random number generator function is commented out, but added to the file in case readers want to test a function that works faster but produces worse results. <br><br><h5>  ParallelRNG2 () </h5><br>  A random number generator making 2 passes for 2 input values. <br><br><h5>  ParallelRNG3 () </h5><br>  A random number generator that makes 3 passes for 3 input values. <br><br><h5>  weight_poly3 (), weight_poly5 () and WEIGHT () </h5><br>  These are alternative weight functions used by the Perlin noise algorithm to ensure continuity of gradients.  The second (preferred) function also ensures the continuity of the second derivative.  The WEIGHT macro selects which function to use. <br><br><h5>  NORM256 () </h5><br>  A macro that converts a range (0, 255) to (-1.0, 1.0). <br><br><h5>  interp () </h5><br>  Bilinear interpolation using OpenCL. <br><br><h5>  hash_grad_dot2 () </h5><br>  Selects a gradient and calculates the scalar product with input values ‚Äã‚ÄãXY as part of the Perlin noise function Noise_2d. <br><br><h5>  Noise_2d () </h5><br>  Perlin noise generator with two input values. <br><br><h5>  hash_grad_dot3 () </h5><br>  Selects a gradient and calculates the scalar product with input values ‚Äã‚ÄãXYZ as part of the Perlin noise function Noise_3d. <br><br><h5>  Noise_3d () </h5><br>  Perlin noise generator with three input values. <br><br><h5>  cloud () </h5><br>  Creates one pixel of cloud output image for CloudTest using Noise_3d. <br><br><h5>  map256 () </h5><br>  Converts the output range of Perlin's noise (-1.0, 1.0) to the range (0, 255) required to obtain pixels in shades of gray. <br><br><h5>  CloudTest () </h5><br>  The test with the creation of the image of the cloud.  The slice parameter is passed to the cloud function so that the system code can create other cloud images. <br><br><h5>  Noise2dTest () </h5><br>  Noise_2d test is not used by default. <br><br><h5>  Noise3dTest () </h5><br>  Test Noise_3d - Perlin noise functions by default.  Uses map256 to get grayscale image pixel values. <br><br><h5>  RandomTest () </h5><br>  The ParallelRNG3 test uses the low-order byte of the unsigned integer result to produce a grayscale image. <br><br>  Two Microsoft Visual Studio solution files for Visual Studio versions 2012 and 2013 are provided. These are the Noise_2012.sln and Noise_2013.sln files.  If the reader uses a newer version of Visual Studio, it should be possible to use the Visual Studio solution and project update feature to create a new solution based on these files. <br>  In both solutions, it is assumed that <a href="https://software.intel.com/en-us/opencl-code-builder">Intel¬Æ OpenCL Code Builder is</a> installed on the system. <br><br><h1>  <font color="#0071c5">Sample management</font> </h1><br>  You can run the sample from the Microsoft Windows * command line from the folder where the exe file is located. <br> <code>Noise.exe &lt;&gt; <br></code> <br><br><h4>  Options </h4><br> <code>-h  --help <br></code>  Displays help at the command prompt.  Demonstrations will not start. <br><br> <code>-t  --type [ all | cpu | gpu | acc | default | &lt;   OpenCL&gt; <br></code>  Select the type of device for which the OpenCL kernel runs.  The default value is all. <br><br> <code>CL_DEVICE_TYPE_ALL | CL_DEVICE_TYPE_CPU | CL_DEVICE_TYPE_GPU | <br> CL_DEVICE_TYPE_ACCELERATOR | CL_DEVICE_TYPE_DEFAULT <br></code>  &lt;OpenCL device type constant&gt; <br><br> <code>-p  --platform &lt;  &gt; <br></code>  The choice of the used platform.  When you start the demo, a list of all numbers and platform names is displayed.  To the right of the platform being used will be [Selected].  When using a string, specify enough letters to uniquely recognize the name of the platform.  The default is Intel. <br><br> <code>-d  --device &lt;  &gt; <br></code>  Select the device on which OpenCL cores are running, by number or name.  When you start the demonstration, a list of all the numbers and names of devices on your platform is displayed.  [Selected] will be displayed to the right of the current device.  The default value is 0. <br><br> <code>-r  --run [ random | perlin | clouds ] <br></code>  Select the demo feature to run.  The random number generator, the Perlin noise algorithm and the cloud image generator have demo cores.  The default is random. <br><br> <code>-s  --seed &lt; &gt; <br></code>  Integer input value, depending on which the result of the algorithm changes.  The default value is 1. <br><br>  Noise.exe displays the operating time of the OpenCL core and the reference equivalent C code, as well as the names of the output files of both algorithms.  When the output is complete, the program waits for the user to press the ENTER key before exiting.  Please note that the functions of the C reference code have not been optimized, their purpose is only to verify the correctness of the OpenCL core code. <br><br><h1>  <font color="#0071c5">Results analysis</font> </h1><br>  After Noise.exe completes, view the BMP OutputOpenCL.bmp and OutputReference.bmp image files in the working folder to compare the results of the OpenCL and C ++ code.  These two images should be the same, although very slight differences are possible between two images of Perlin noise or between two images of clouds. <br>  The result of the noise algorithm (Perlin noise) should look like that shown in Figure 3. <br><br><img src="https://habrastorage.org/files/4c1/a1d/5ee/4c1a1d5ee9d747a9b2f432935cbf4fdf.jpg"><br>  <i>Figure 3. The result of the Perlin noise algorithm</i> <br><br>  The result of the random algorithm (random number generator) should look like that shown in Figure 4. <br><br><img src="https://habrastorage.org/files/e2e/56e/6f2/e2e56e6f2f3b44e1ad393ce4e1bbb6b1.jpg"><br>  <i>Figure 4. The result of the random number generator</i> <br><br>  The result of the cloud algorithm should look like that shown in Figure 5. <br><br><img src="https://habrastorage.org/files/434/4ed/1a8/4344ed1a8d214e538ab01534231fb1f5.jpg"><br>  <i>Figure 5. The result of the cloud creation algorithm</i> <br><br><h1>  <font color="#0071c5">Reference materials</font> </h1><br><ol><li>  <a href="http://mrl.nyu.edu/~perlin/paper445.pdf">K. Perlin (Perlin, K.) "Improving Noise"</a> </li><li>  <a href="http://burtleburtle.net/bob/hash/integer.html">"Hashing 4-byte integers"</a> </li><li>  <a href="http://www.drdobbs.com/tools/fast-high-quality-parallel-random-number/229625477">M. Overton (Overton, MA), ‚ÄúFast, High-Quality Parallel Random Number Generators,‚Äù Dr. Web site</a>  <a href="http://www.drdobbs.com/tools/fast-high-quality-parallel-random-number/229625477">Dobb's (2011)</a> </li><li>  <a href="https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-library-implementation-and-uses%3Futm_source%3DEmail%26utm_medium%3DIDZ">Implementing and Using the Intel¬Æ Digital Random Number Generator (DRNG) Library</a> </li><li>  <a href="https://software.intel.com/en-us/articles/intel-sample-source-code-license-agreement/">Intel License Agreement to Use Source Code Samples</a> </li><li>  <a href="https://software.intel.com/en-us/opencl-code-builder">Intel¬Æ OpenCL ‚Ñ¢ Code Builder</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/279393/">https://habr.com/ru/post/279393/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279379/index.html">Google's beacon platform. Part 2 - Nearby meassages API</a></li>
<li><a href="../279381/index.html">Google's beacon platform. Part 1 - Proximity beacon API</a></li>
<li><a href="../279383/index.html">Work with VK API when creating a game for VKontakte</a></li>
<li><a href="../279385/index.html">Work with events in Laravel. Sending push notifications when publishing an article</a></li>
<li><a href="../279389/index.html">Azure-IaaS-Digest number 3 (March)</a></li>
<li><a href="../279395/index.html">Windows 2008 R2 on HP DL380 G4p</a></li>
<li><a href="../279397/index.html">Anatomy of document editors: a common code for online and offline versions of ONLYOFFICE editors</a></li>
<li><a href="../279403/index.html">Update KB3035583 can automatically update Windows 7 to Windows 10</a></li>
<li><a href="../279405/index.html">Register for the ‚ÄúEasy Cloud Protection of Corporate Network with Low Total Cost of Ownership‚Äù webinar</a></li>
<li><a href="../279407/index.html">Is Grounded in a 2D Platform: How to find out if a character is worth it?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>