<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel Programming in Swift: Operations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In parallel programming in Swift: The Basics I have presented many low-level ways to manage concurrency in Swift. The initial idea was to collect all ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel Programming in Swift: Operations</h1><div class="post__text post__text-html js-mediator-article">  In parallel programming in Swift: The Basics I have presented many low-level ways to manage concurrency in Swift.  The initial idea was to collect all the various approaches that we can use in iOS in one place.  But when writing this article, I realized that there are too many of them to list in one article.  Therefore, I decided to reduce the methods of a higher level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f2/a9a/65a/5f2a9a65a3bd9c9adb703fb8a5a6fc14.png" alt="image"><br><br>  I mentioned Operations in one of my articles, but let's take a closer look at them. <br><a name="habracut"></a><br><h3>  OperationQueue </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e79/269/08e/e7926908e1e718c365b080736d50e88a.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Recall: <b>Operation</b> is a high-level abstraction of <b>Cocoa</b> over <b>GCD</b> .  To be more precise, this is an abstraction over <i>dispatch_queue_t</i> .  It uses the same principle as the queues to which you can add tasks.  In the case of OperationQueue, these tasks are operations.  When performing the operation, we need to know about the thread in which it runs.  If you need to update the user interface, the developer should use <b>MainOperationQueue</b> . <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">OperationQueue</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span></code> </pre> <br>  Otherwise, we can use a private queue. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operationQueue: <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span> = <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>()</code> </pre><br>  The difference from <i>dispatch_queue_t</i> is the ability to simultaneously set the maximum number of operations to run. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operationQueue: <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span> = <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>() operationQueue.maxConcurrentOperationCount = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><h3>  Operations </h3><br>  <b>OperationQueue</b> is a high-level abstraction of <i>dispatch_queue_t</i> , and the operations themselves are considered abstractions of the upper level of dispatch blocks.  But there are some differences.  For example, an operation can be performed within a few minutes, or longer, and a block is operating within a few milliseconds.  Since Operations are classes, we can use them to encapsulate our business logic.  Thus, we will need to replace a few small operations to change the main components (for example, our database level). <br><br><h3>  Life cycle </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9b6/a7b/493/9b6a7b49369f5b7c534f573f35a9993b.png" alt="image"><br><br>  Over the period of its existence, Operations goes through different stages.  When added to a queue, it is pending.  In this state, she expects her conditions.  As soon as all of them are completed, Operations transitions to the ready state, and in the case of an open slot, it will start.  When you have completed all your work, Operations will enter the Finished state, and will be removed from the OperationQueue.  In each state (except Completed), Operation may be canceled. <br><br><h3>  Cancel </h3><br>  Canceling Operation is pretty simple.  Depending on the operation, the cancellation may have completely different meanings.  For example, when starting a network request, canceling can result in stopping this request.  When importing data, this can mean abandoning a transaction.  The responsibility for assigning this value lies with you. <br><br>  So, how to cancel the Operation?  You simply call the .cancel () method.  This will change the isCancelled property.  That's all iOS will do for you.  It depends on you how to respond to this cancellation of the operation and how to proceed. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op = <span class="hljs-type"><span class="hljs-type">DemoOperation</span></span>() <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>.addOperations([op], waitUntilFinished: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) op.cancel()</code> </pre><br>  Keep in mind that the cancellation of an operation leads to the cancellation of all its conditions and the immediate start, in order to enter the <i>Finished</i> state as soon as possible.  Moving to the <i>Finished</i> state is the only way to remove an operation from the queue. <br><br>  If you forget to check for cancellation of an operation, you can see that they are executed, even if you canceled them.  Also keep in mind that it is susceptible to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8">race condition</a> .  Pressing the button and setting the mark takes a few microseconds.  During this time, the operation may complete and the cancellation mark will have no effect. <br><br><h3>  Readiness </h3><br>  Readiness is described by only one Boolean value.  This means that the operation is ready for execution, and it is waiting for its launch queue.  In a sequential queue, an operation is first performed that enters the ‚ÄúReady‚Äù state, although it may be in position 9 in the queue.  If several operations entered the ready state at the same time, they will be prioritized.  Operation will enter the ready state only after all its dependencies are completed. <br><br><h3>  Dependencies </h3><br>  This is one of the really huge features of operations.  We can create tasks in which it is indicated that other tasks must be performed first before they can be completed.  At the same time, there are tasks that can be performed in parallel with other tasks, but are dependent on subsequent actions.  This can be done by calling .addDependency () <br><br><pre> <code class="hljs pgsql">operation2.addDependency(operation1) //<span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> operation1 <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> operation2</code> </pre><br>  Any operation that has dependencies will by default have a ready state after all its dependencies are completed.  However, it‚Äôs up to you to decide how to act after you cancel the dependency <br><br>  This allows us to strictly streamline our operations. <br><br>  I don't think it's very easy to read, so let's create our own operator (==&gt;) to create dependencies.  Thus, we can specify the order of operations from left to right. <br><br><pre> <code class="hljs swift">precedencegroup <span class="hljs-type"><span class="hljs-type">OperationChaining</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==&gt; : <span class="hljs-type"><span class="hljs-type">OperationChaining</span></span> <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==&gt;&lt;T: Operation&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: T, rhs: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> { rhs.addDependency(lhs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs } operation1 ==&gt; operation2 ==&gt; operation3 <span class="hljs-comment"><span class="hljs-comment">// Execute in order 1 to 3</span></span></code> </pre><br>  Dependencies can be in different <i>OperationQueues</i> .  At the same time, they can create unexpected blocking behavior.  For example, the user interface can work with slowdown, because the update depends on the operation in the background and blocks other operations.  Remember about cyclic dependencies.  This happens if operation <b>A</b> depends on how <b>B</b> works and <b>B</b> depends on <b>A.</b>  So they both expect each other to complete, so you get a <b><a href="https://ru.wikipedia.org/wiki/Deadlock">deadlock</a></b> . <br><br><h3>  Done </h3><br>  After completing the Operation, it enters the ‚ÄúReady‚Äù state and completes its completion block exactly once.  Completion block can be set as follows: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op1 = <span class="hljs-type"><span class="hljs-type">Operation</span></span>() op1.completionBlock = { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"done"</span></span>) }</code> </pre><br><h3>  Practical example </h3><br>  Let's create a simple structure for operations with all these principles.  Operations have quite a few complex concepts.  Instead of creating an example that is too complicated, let's just type in ‚Äú <i>Hello world</i> ‚Äù and try to include most of them.  The example will contain asynchronous execution, dependencies, and several operations, treated as one.  Let's dive into creating an example! <br><br><h3>  AsyncOperation </h3><br>  First we will create an Operation to create asynchronous tasks.  Thus, we can create subclasses and any asynchronous tasks. <br><br><pre> <code class="hljs cs">import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AsyncOperation</span></span>: <span class="hljs-title"><span class="hljs-title">Operation</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isAsynchronous: Bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _isFinished: Bool = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isFinished: Bool { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { willChangeValue(forKey: <span class="hljs-string"><span class="hljs-string">"isFinished"</span></span>) _isFinished = <span class="hljs-function"><span class="hljs-function">newValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didChangeValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">forKey: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"isFinished"</span></span></span></span></span><span class="hljs-function">) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _isFinished } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _isExecuting: Bool = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isExecuting: Bool { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { willChangeValue(forKey: <span class="hljs-string"><span class="hljs-string">"isExecuting"</span></span>) _isExecuting = <span class="hljs-function"><span class="hljs-function">newValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didChangeValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">forKey: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"isExecuting"</span></span></span></span></span><span class="hljs-function">) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _isExecuting } } <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { isExecuting = <span class="hljs-function"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">true</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) isExecuting</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br>  It looks pretty ugly.  As you can see, we need to override <i>isFinished</i> and <i>isExecuting</i> .  In addition, changes to them must meet the requirements of the <b>KVO</b> , otherwise <b>OperationQueue</b> will not be able to monitor the status of our operations.  In our <i>start ()</i> method, we manage the state of our operation from the start of execution to the entry into the state of <i>Finished</i> .  We have created an <i>execute ()</i> method.  This will be the method that our subclasses need to implement. <br><br><h3>  TextOperation </h3><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TextOperation: AsyncOperation { let <span class="hljs-type"><span class="hljs-type">text</span></span>: String init(<span class="hljs-type"><span class="hljs-type">text</span></span>: String) { self.text = <span class="hljs-type"><span class="hljs-type">text</span></span> } override func <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>() { print(<span class="hljs-type"><span class="hljs-type">text</span></span>) } }</code> </pre><br>  In this case, we just need to pass the text that we want to print to <i>init ()</i> and override <i>execute ()</i> . <br><br><h3>  GroupOperation </h3><br>  <b>GroupOperation</b> will be our implementation to combine several operations into one. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation class GroupOperation: AsyncOperation { let queue = OperationQueue() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> operations: [AsyncOperation] = [] override <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"group started"</span></span>) queue.addOperations(operations, waitUntilFinished: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"group done"</span></span>) } }</code> </pre><br>  As you can see, we create an array in which our subclasses will add their operations.  Then, at run time, we simply add transactions to our private queue.  Thus, we guarantee that they will be executed in a specific order.  Calling the <i>addOperations ([Operation], waitUntilFinished: true)</i> method locks the queue until additional operations are performed.  After that, <i>GroupOperation</i> will change its state to <i>Finish</i> . <br><br><h3>  HelloWorld Operation </h3><br>  Just create your own operations, set the dependencies and add them to the array.  That's all. <br><br><pre> <code class="hljs cs">import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HelloWorldOperation</span></span>: <span class="hljs-title"><span class="hljs-title">GroupOperation</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { super.init() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op = TextOperation(text: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op2 = TextOperation(text: <span class="hljs-string"><span class="hljs-string">"World"</span></span>) op2.addDependency(op) operations = [op2, op] } }</code> </pre><br><h3>  Operation observer </h3><br>  So, how do we know that the operation is completed?  As one of the ways, you can add competionBlock.  Another way is to register the OperationObserver.  This is the class that subscribes to keyPath via KVO.  He oversees everything as long as it is compatible with KVO. <br><br>  Let's print ‚Äúdone‚Äù in our little framework as soon as <i>HelloWorldOperation</i> ends: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation class OperationObserver: NSObject { init(operation: AsyncOperation) { super.init() operation.addObserver(self, forKeyPath: <span class="hljs-string"><span class="hljs-string">"finished"</span></span>, options: .<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>, context: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } override <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span></span></span> { guard let key = keyPath <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> key { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"finished"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"done"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"doing"</span></span>) } } }</code> </pre><br><h3>  Data transfer </h3><br>  For ‚ÄúHello World!‚Äù It makes no sense to transfer data, but let's quickly consider this case.  The easiest way is to use <b>BlockOperations</b> .  Using them, we can set properties for the next operation that needs data.  Do not forget to establish a dependency, otherwise the operation may not be completed on time;) <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> op1 = <span class="hljs-type"><span class="hljs-type">Operation1</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op2 = <span class="hljs-type"><span class="hljs-type">Operation2</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adapter = <span class="hljs-type"><span class="hljs-type">BlockOperation</span></span>() { [unowned op1, unowned op2] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> op2.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = op1.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> } adapter.addDependency(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op1</span></span></span><span class="hljs-class">) op2.addDependency(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">adapter</span></span></span><span class="hljs-class">) queue.addOperations([</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">adapter</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waitUntilFinished</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">)</span></span></code> </pre><br><h3>  Error processing </h3><br>  One more thing that we do not consider now is error handling.  Truth be told, I have not yet found a good way to do this.  One option is to add a call to the method <i>finished (withErrors :)</i> and to enable each asynchronous operation to call it instead of <b>AsyncOperation</b> , processing it in <i>start ()</i> .  Thus, we can check for errors and add them to the array.  Suppose we have operation A, which depends on operation <b>B.</b>  Suddenly, operation B ends with an error.  And in this case Operation A can check this array and abort its execution.  Depending on the requirements, you may add additional errors. <br><br>  It might look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupOperation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncOperation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queue = <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> operations: [<span class="hljs-type"><span class="hljs-type">AsyncOperation</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errors: [<span class="hljs-type"><span class="hljs-type">Error</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"group started"</span></span>) queue.addOperations(operations, waitUntilFinished: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"group done"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withError errors: [Error])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.errors += errors } }</code> </pre><br>  Keep in mind that sub-operations must handle their state accordingly, and for this you need to make some changes in <b>AsyncOperation</b> . <br><br>  But, as always, there are many ways, and this is only one of them.  You can also use observer to monitor the error value. <br><br>  It doesn't matter how you do it.  Just make sure your operation will be deleted upon completion.  For example: If you write in the context of <a href="https://ru.wikipedia.org/wiki/CoreData">CoreData</a> , and something goes wrong, you need to clear this context.  Otherwise, you may have an unspecified state. <br><br><h3>  UI Operations </h3><br>  Operations are not limited to items that you do not see.  Everything that you do in an application can be an operation (although I would advise you not to do this).  But there are some things that are easier to see as Operations.  Everything that is modal should be considered accordingly.  Let's look at the operation to display the dialog: <br><br><pre> <code class="hljs objectivec">import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIOperation</span></span>: AsyncOperation { let viewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewcontroller</span></span>! override func execute() { let alert = <span class="hljs-built_in"><span class="hljs-built_in">UIAlertController</span></span>(title: <span class="hljs-string"><span class="hljs-string">"My Alert"</span></span>, message: <span class="hljs-string"><span class="hljs-string">@"This is an alert."</span></span>, preferredStyle: .alert) alert.addAction(<span class="hljs-built_in"><span class="hljs-built_in">UIAlertAction</span></span>(title: <span class="hljs-string"><span class="hljs-string">"OK"</span></span>, style: .`<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`, handler: { _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.handleInput() })) viewController.present(alert, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } func handleInput() { <span class="hljs-comment"><span class="hljs-comment">//do something and continue operation } }</span></span></code> </pre><br>  As you can see, it suspends its execution until the button is pressed.  After that, it will enter its finished state, and then all other operations that depend on this can continue. <br><br><h3>  UI Operations </h3><br>  Operations are not limited to items that you do not see.  Everything that you do in an application can be an operation (although I would advise you not to do this).  But there are some things that are easier to see as Operations.  Everything that is modal should be considered accordingly.  Let's look at the operation to display the dialog: <br><br><pre> <code class="hljs objectivec">import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIOperation</span></span>: AsyncOperation { let viewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewcontroller</span></span>! override func execute() { let alert = <span class="hljs-built_in"><span class="hljs-built_in">UIAlertController</span></span>(title: <span class="hljs-string"><span class="hljs-string">"My Alert"</span></span>, message: <span class="hljs-string"><span class="hljs-string">@"This is an alert."</span></span>, preferredStyle: .alert) alert.addAction(<span class="hljs-built_in"><span class="hljs-built_in">UIAlertAction</span></span>(title: <span class="hljs-string"><span class="hljs-string">"OK"</span></span>, style: .`<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`, handler: { _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.handleInput() })) viewController.present(alert, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } func handleInput() { <span class="hljs-comment"><span class="hljs-comment">//do something and continue operation } }</span></span></code> </pre><br>  As you can see, it suspends its execution until the button is pressed.  After that, it will enter its finished state, and then all other operations that depend on this can continue. <br><br><h3>  Mutual exclusion </h3><br>  Given that we can use <i>Operations</i> for the User Interface, a different challenge appears.  Imagine that you see an error dialog.  You may be adding several operations to a queue that will display an error when the network is unavailable.  This can easily lead to the fact that when warnings appear, all the above-mentioned Operations can break the network connection.  As a result, we would have several dialogues that would be displayed simultaneously, and we do not know which one is the first and which is the second.  Therefore, we will have to make these dialogues mutually exclusive. <br><br>  Despite the fact that the idea itself is complex, it is fairly easy to implement with dependencies.  Just create a dependency between these dialogs, and everything is ready.  One of the problems is tracking the operation.  But this can be resolved by using naming operations, and then by accessing the <b>OperationQueue</b> and searching for the name.  Thus, you do not need to keep the link. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op1 = <span class="hljs-type"><span class="hljs-type">Operation</span></span>() op1.name = <span class="hljs-string"><span class="hljs-string">"Operation1"</span></span> <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>.main.addOperations([op1], waitUntilFinished:<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operations = <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span>.main.operations operations.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { op <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op.name == <span class="hljs-string"><span class="hljs-string">"Operation1"</span></span> { op.cancel() } }</code> </pre><br><h3>  Conclusion </h3><br><br>  <b>Operations</b> is a good tool for concurrency.  But do not be fooled, they are more complicated than you think.  Currently, I support the project based on Operations, and some of its parts are very complex and inconvenient in work.  In particular, a lot of faults appear in error handling.  Every time you perform a group operation, and it is performed incorrectly, there is a possibility of more than one error.  You will have to filter them to get the necessary errors of a certain kind, so sometimes the error is confusing because of the display routines. <br><br>  Another problem is that you stop thinking about possible parallel identical problems.  I haven‚Äôt talked about these details yet, but I remember GroupOperations with the error handling code given above.  They contain a bug that will be fixed in a future post. <br><br>  <b>Operations</b> is a good tool for managing concurrency.  <b>GCDs</b> are still not ordered.  For small tasks, such as switching threads or tasks that need to be completed as quickly as possible, you may not want to use operations.  The ideal solution for this is <b>GCD</b> . </div><p>Source: <a href="https://habr.com/ru/post/350096/">https://habr.com/ru/post/350096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350084/index.html">Designing reliable databases. Chapter 1. Introduction</a></li>
<li><a href="../350086/index.html">Epic Growth Conference 2018 - grocery marketing conference in Moscow</a></li>
<li><a href="../350090/index.html">3D Facebook posts: what and how</a></li>
<li><a href="../350092/index.html">How the implementation of trading systems with artificial intelligence will affect investment management</a></li>
<li><a href="../350094/index.html">Guide to background work in Android. Part 2: Loaders</a></li>
<li><a href="../350098/index.html">Second breath multimode</a></li>
<li><a href="../350100/index.html">How to come up with ideas for patents</a></li>
<li><a href="../350102/index.html">How we searched for a translator in the section "Songs"</a></li>
<li><a href="../350104/index.html">Innovative 3D XPoint memory: technology potential and development prospects</a></li>
<li><a href="../350106/index.html">Custom animations in the mobile application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>