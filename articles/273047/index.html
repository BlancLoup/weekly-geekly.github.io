<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to squeeze a flat cat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once in the icy winter season ... exactly a year ago, we had a nontrivial task. There is a screen on electronic ink, there is a 16 MHz processor (yes,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to squeeze a flat cat</h1><div class="post__text post__text-html js-mediator-article">  Once in the icy winter season ... exactly a year ago, we had a nontrivial task.  There is a screen on electronic ink, there is a 16 MHz processor (yes, in embedded electronics, especially ultra-low power, there are such) and there is no memory at all.  Well, i.e.  kilobytes 8 RAM and 256 Flash.  Kilobytes, Karl.  And in these sad kilobytes it is necessary to push several 800x600 images in four shades of gray.  Multiplying quickly in mind 800 by 600 and 2 bits per pixel, we get 120 thousand bytes.  A few does not fit.  It is necessary to compress. <br><br>  So the task appeared before us: ‚Äúhow to compress a flat cat‚Äù?  Why a cat?  Yes, because they tested on the seals, what else to check for black and white pictures.  Not on dollar bills the same. <br><a name="habracut"></a><br>  The first answer was: let's squeeze the cat <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B4%25D0%25BB%25D0%25B8%25D0%25BD_%25D1%2581%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B9">RLE</a> .  The cat is flat ... That is, flat-colored - only four shades.  There are a lot of empty places on the screen, i.e.  duplicate pixels will be up to hell.  Should shrink. <br><br>  Should shrink - squeezed.  With the only difficulty: we don't care how to compress, we compress on the PC, or even on the server.  But we need to unclener sequentially, in a streaming way: the bytes were pulled out - the bytes were pulled out.  We do not have a video buffer on 8 kilobytes of RAM, there is no place to store a decompressed cat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Coped.  The cat is compressed. <br><br><div class="spoiler">  <b class="spoiler_title">RLE compression</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Common Utilities Library * (C) Componentality Oy, 2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RLE compression implementation */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rle.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory.h&gt; using namespace Componentality::Common; // Do 8-bit RLE encoding void Componentality::Common::RLE_Encode(unsigned char* source, size_t source_size, unsigned char* target, size_t&amp; target_size) { target_size = 0; unsigned char previous_character = source[0]; unsigned char series_counter = 1; bool same = false; size_t i; for (i = 1; i &lt; source_size; i++) { // If current byte is equal to previous if (source[i] == previous_character) { // If we process sequence of the same characters if (same) { if (series_counter &lt; 127) series_counter++; else { target[target_size++] = 0x80 | series_counter; target[target_size++] = previous_character; series_counter = 1; } } else { if (series_counter &gt; 1) { target[target_size++] = series_counter - 1; memcpy(target + target_size, source + i - series_counter, series_counter - 1); target_size += series_counter - 1; } series_counter = 2; same = true; } } else { if (same) { if (series_counter &gt; 1) { target[target_size++] = 0x80 | series_counter; target[target_size++] = previous_character; series_counter = 1; } else series_counter += 1; same = false; } else { if (series_counter &gt; 127) { target[target_size++] = series_counter - 1; memcpy(target + target_size, source + i - (series_counter - 1), series_counter - 1); target_size += series_counter - 1; series_counter = 1; } else series_counter++; } } previous_character = source[i]; } if (same) { target[target_size++] = 0x80 | series_counter; target[target_size++] = previous_character; } else { target[target_size++] = series_counter; memcpy(target + target_size, source + i - (series_counter), series_counter); target_size += series_counter; } } // Do buffered RLE decoding void Componentality::Common::RLE_Decode(unsigned char* source, size_t source_size, unsigned char* target, size_t&amp; target_size) { target_size = 0; for (size_t i = 0; i &lt; source_size;) { unsigned char size = source[i] &amp; ~0x80; if (source[i] &amp; 0x80) { memset(target + target_size, source[i + 1], size); i += 2; } else { memcpy(target + target_size, source + i + 1, size); i += size + 1; } target_size += size; } } // Check where two buffers are different size_t Componentality::Common::isDiff(unsigned char* left, unsigned char* right, size_t size) { for (size_t i = 0; i &lt; size; i++) { if (left[i] != right[i]) return i; } return (size_t)-1; } // Incremental decoding initialization void Componentality::Common::RLE_InitDecoder(RLE_DECODE* handler, unsigned char* source) { handler-&gt;mDecodedPortion = 0; handler-&gt;mPtr = 0; handler-&gt;mOffset = 0; handler-&gt;mSource = source; } // Decode next byte incrementally unsigned char Componentality::Common::RLE_Fetch(RLE_DECODE* handler) { if (handler-&gt;mDecodedPortion &gt; handler-&gt;mPtr) { handler-&gt;mPtr += 1; if (handler-&gt;mMode == 0x00) handler-&gt;mOffset += 1; return handler-&gt;mSource[handler-&gt;mOffset - 1]; } handler-&gt;mDecodedPortion = handler-&gt;mSource[handler-&gt;mOffset] &amp; ~0x80; handler-&gt;mMode = handler-&gt;mSource[handler-&gt;mOffset] &amp; 0x80; handler-&gt;mOffset += 2; handler-&gt;mPtr = 1; return handler-&gt;mSource[handler-&gt;mOffset - 1]; }</span></span></span></span></code> </pre> <br></div></div><br>  Good cat shrinks.  On average, the hospital is 4 times. But we are greedy, we would be closer.  We have little memory, very little, and we need it not only for the seals, we still need to build a peer-to-peer network, store routes and other nonsense. <br><br>  Thought again.  So they thought, they thought, they decided that <a href="https://ru.wikipedia.org/wiki/LZ77">LZ77</a> would also work, we just need to figure out how to decompress the data in a streaming manner without intermediate storage.  Invented.  It turned out like this: <br><br><div class="spoiler">  <b class="spoiler_title">Compression embedded-modification of LZ77 (scanback algorithm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Common Utilities Library * (C) Componentality Oy, 2014-2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Scanback compression implementation */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Scanback - LZ77 for embedded systems */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Designed and developed by Konstantin Khait */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"scanback.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bitmem.h"</span></span></span><span class="hljs-meta"> } using namespace Componentality::Common; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Scan buffer (buf) back from position &lt;index&gt; - 1 for byte &lt;wtf&gt; from &lt;minfind&gt; to &lt;maxfind&gt; index static unsigned char _sb__findback(unsigned char* buf, unsigned long index, unsigned char wtf, unsigned char minfind, unsigned char maxfind) { unsigned char i; for (i = minfind; i &lt; maxfind; i++) { if (buf[index - i] == wtf) return i; } return 0; } // Compare &lt;buf1&gt; and &lt;buf2&gt; for maximum length of &lt;size&gt; and return length of identical fragment static unsigned char _sb__match(unsigned char* buf1, unsigned char* buf2, unsigned char size) { unsigned char i; for (i = 0; i &lt; size; i++) { if (buf1[i] != buf2[i]) break; } return i; } // Find maximum matching sequence in buffer &lt;buf&gt; to sequence starting from &lt;index&gt; // &lt;winsize&gt; - size of window to be scanned in bytes, &lt;matchlen&gt; - maximum length of matching area in bytes, &lt;bufsize&gt; - size of &lt;buf&gt; SB_PTR _sb_scanback(unsigned char* buf, unsigned long index, unsigned char winsize, unsigned char matchlen, unsigned long bufsize) { SB_PTR result = { 0, 0 }; unsigned char i; if (winsize &gt; index) winsize = (unsigned char)index; if (matchlen &gt; winsize) matchlen = winsize; for (i = 1; i &lt; winsize; i++) { register unsigned char offset = _sb__findback(buf, index, buf[index], i, winsize); if (offset) { register unsigned char matchsize = (unsigned char)(matchlen &lt; (bufsize - index) ? matchlen : bufsize - index); if (matchsize &gt; offset) matchsize = offset; register unsigned char len = _sb__match(buf + index, buf + index - offset, matchsize); if (len &gt; result.length) { result.offset = offset; result.length = len; } i = offset; } } return result; } // Do compression of buffer &lt;buf&gt; of size &lt;size&gt; to bitwise memory &lt;mem&gt;. Returns number of produced bits unsigned long Componentality::Common::SB_Compress(unsigned char* mem, unsigned char* buf, unsigned long size) { unsigned long bitcount = 0, i; SB_PTR cptr; for (i = 0; i &lt; (1 &lt;&lt; LENGTH_BITS); i++) mem[i] = buf[i]; bitcount += (1 &lt;&lt; LENGTH_BITS) * 8; for (i = 1 &lt;&lt; LENGTH_BITS; i &lt; size;) { cptr = _sb_scanback(buf, i, 1 &lt;&lt; WINDOW_BITS, 1 &lt;&lt; LENGTH_BITS, size); if (!cptr.offset) { bitmem_put1(mem, bitcount++, 0); bitmem_put(mem, bitcount, buf[i], 8); bitcount += 8; i += 1; } else { bitmem_put1(mem, bitcount++, 1); bitmem_put(mem, bitcount, cptr.offset - 1, WINDOW_BITS); bitcount += WINDOW_BITS; bitmem_put(mem, bitcount, cptr.length - 1, LENGTH_BITS); bitcount += LENGTH_BITS; i += cptr.length; } } return bitcount; } // Initialize decoder context void Componentality::Common::SB_InitDecoder(SB_DECODER* decoder, unsigned char* mem) { decoder-&gt;bitindex = 0; decoder-&gt;mem = mem; decoder-&gt;total_decoded = 0; decoder-&gt;index = 0; decoder-&gt;brb = 0; } // Initialize decoder with ringbuffer void SB_InitDecoderRB(SB_DECODER* decoder, void* ringbuffer) { decoder-&gt;bitindex = 0; decoder-&gt;mem = 0; decoder-&gt;total_decoded = 0; decoder-&gt;index = 0; decoder-&gt;brb = ringbuffer; } // Unpack next byte from the packed stream unsigned char Componentality::Common::SB_Fetch(SB_DECODER* decoder) { register unsigned char result; if (decoder-&gt;index &lt; (1 &lt;&lt; LENGTH_BITS)) { if (!decoder-&gt;brb) result = decoder-&gt;decoded_buf[decoder-&gt;index % (1 &lt;&lt; WINDOW_BITS)] = decoder-&gt;mem[decoder-&gt;index]; else result = decoder-&gt;decoded_buf[decoder-&gt;index % (1 &lt;&lt; WINDOW_BITS)] = (unsigned char)bitmem_read_ringbuf((BIT_RINGBUF*)decoder-&gt;brb, 8); decoder-&gt;index += 1; decoder-&gt;bitindex += 8; decoder-&gt;total_decoded += 1; return result; } if (decoder-&gt;index &gt;= decoder-&gt;total_decoded) { bit isref = bitmem_get1(decoder-&gt;mem, decoder-&gt;bitindex++); if (!isref) { if (!decoder-&gt;brb) decoder-&gt;decoded_buf[decoder-&gt;total_decoded % (1 &lt;&lt; WINDOW_BITS)] = (unsigned char)bitmem_get(decoder-&gt;mem, decoder-&gt;bitindex, 8); else decoder-&gt;decoded_buf[decoder-&gt;total_decoded % (1 &lt;&lt; WINDOW_BITS)] = (unsigned char)bitmem_read_ringbuf((BIT_RINGBUF*)decoder-&gt;brb, 8);; decoder-&gt;bitindex += 8; decoder-&gt;total_decoded += 1; } else { register SB_PTR ptr; register unsigned char i; if (!decoder-&gt;brb) ptr.offset = (unsigned char)bitmem_get(decoder-&gt;mem, decoder-&gt;bitindex, WINDOW_BITS) + 1; else ptr.offset = (unsigned char) bitmem_read_ringbuf((BIT_RINGBUF*)decoder-&gt;brb, WINDOW_BITS) + 1; decoder-&gt;bitindex += WINDOW_BITS; if (!decoder-&gt;brb) ptr.length = (unsigned char)bitmem_get(decoder-&gt;mem, decoder-&gt;bitindex, LENGTH_BITS) + 1; else ptr.length = (unsigned char) bitmem_read_ringbuf((BIT_RINGBUF*)decoder-&gt;brb, LENGTH_BITS) + 1; decoder-&gt;bitindex += LENGTH_BITS; for (i = 0; i &lt; ptr.length; i++) { register unsigned long srcptr = decoder-&gt;total_decoded - ptr.offset; decoder-&gt;decoded_buf[decoder-&gt;total_decoded % (1 &lt;&lt; WINDOW_BITS)] = decoder-&gt;decoded_buf[srcptr % (1 &lt;&lt; WINDOW_BITS)]; decoder-&gt;total_decoded += 1; } } } result = decoder-&gt;decoded_buf[decoder-&gt;index % (1 &lt;&lt; WINDOW_BITS)]; decoder-&gt;index += 1; return result; }</span></span></span></span></code> </pre><br></div></div><br>  We were particularly pleased with the footprint for decompression, approximately equal to 150 bytes (with the "window" of the algorithm at 127 bytes).  Initially, in the Lempel-Ziv algorithms we were greatly confused by the need to allocate memory for the dictionary.  RLE dictionary is completely unnecessary ... But 150 bytes will not frighten us. <br><br>  Another thing scared us - despite the fact that it is known from theory that LZ77 is a generalization of RLE, replacing the second with the first gave an improvement in the result on the verge of statistical error: sometimes better, sometimes worse, but generally the same degree of compression that you don‚Äôt set . <br><br>  We began to think about the entropy methods: Huffman, arithmetic coding, wrote a couple of prototypes ... did not come up.  All decompressors need tables that are quite decent, but by our standards - downright indecent size. <br><br>  And then ... And then we launched the scanback compression <b>over</b> RLE.  And, oh, a miracle, the compression ratio from 3-4 jumped to 7-10, depending on the ‚Äúfluffiness of the cat,‚Äù that is, the degree of flat color of the picture and the number of gradient areas.  You can live.  And, most importantly, RLE + SB is uncompressed in an excellent way with a stream decompressor in one pass. <br><br>  Like this: <br><br><div class="spoiler">  <b class="spoiler_title">Stream decompressor RLE + Scanback</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Common Utilities Library * (C) Componentality Oy, 2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Combined RLE + Scanback implementation (compression is to be done */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* sequentially, decompression is optimized */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rlesbc.h"</span></span></span><span class="hljs-meta"> using namespace Componentality::Common; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Decode next byte incrementally for stream compressed by both RLE and Scanback unsigned char Componentality::Common::RLESB_Fetch(RLE_DECODE* handler, SB_DECODER* sb_handler, unsigned char* repeating_value) { if (handler-&gt;mDecodedPortion &gt; handler-&gt;mPtr) { handler-&gt;mPtr += 1; if (handler-&gt;mMode == 0x00) *repeating_value = SB_Fetch(sb_handler); return *repeating_value; } *repeating_value = SB_Fetch(sb_handler); handler-&gt;mDecodedPortion = *repeating_value &amp; ~0x80; handler-&gt;mMode = *repeating_value &amp; 0x80; *repeating_value = SB_Fetch(sb_handler); handler-&gt;mPtr = 1; return *repeating_value; }</span></span></span></span></code> </pre><br></div></div><br>  For the past year, our seals have lived beautifully almost ‚Äúin complete unconsciousness‚Äù, in spite of every ZLIB.  Which, of course, press much more densely, but resources consume incomparably more.  Meanwhile, we found that our RLE + SB is great for many other tasks, for example, raster fonts are perfectly compressed, even with transparency and anti-aliasing, as well as any network text traffic.  Naturally, the degree of compression is a ridiculous 2.5-6, but almost no resources are consumed, especially for decompression, which, as a rule, is performed more often, and to the speed-memory is much more critical. <br><br>  So we decided not to get stuck and put the code in open access (subject to the <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2586%25D0%25B5%25D0%25BD%25D0%25B7%25D0%25B8%25D1%258F_MIT">MIT license</a> ).  Suddenly, you will have to unclench something in conditions of a catastrophic shortage of memory and processor resources. </div><p>Source: <a href="https://habr.com/ru/post/273047/">https://habr.com/ru/post/273047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273035/index.html">Accelerate your application. PERFMATTERS !.</a></li>
<li><a href="../273037/index.html">Interactive C #</a></li>
<li><a href="../273039/index.html">Evolution in the cloud: the experience of the service to work with social networks</a></li>
<li><a href="../273043/index.html">On the effectiveness of Rutreker's ‚Äúteachings‚Äù</a></li>
<li><a href="../273045/index.html">Python internal list</a></li>
<li><a href="../273049/index.html">NOC Project. Where to start and how to continue?</a></li>
<li><a href="../273051/index.html">How I debugged the python httplib and httplib2</a></li>
<li><a href="../273053/index.html">CrystaX NDK 10.3.0 Released</a></li>
<li><a href="../273055/index.html">Open-source implementation of domestic cryptoGOST</a></li>
<li><a href="../273059/index.html">Extreme Networks Solutions Workshop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>