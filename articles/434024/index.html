<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Horsepower in Android or once again about RecyclerView.LayoutManager</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="According to the author, the article can be useful in the same way as it is for novice Android developers making their first steps in such an exciting...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Horsepower in Android or once again about RecyclerView.LayoutManager</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/ri/9w/fzri9wtwv04-sap1vq-ihg-40mw.gif"></div><br>  According to the author, the article can be useful in the same way as it is for novice Android developers making their first steps in such an exciting area.  The history of the subject of this note began with the idea to equip the educational project with the so-called ‚Äúwow effect‚Äù.  How much it was possible to judge you.  I ask all curious under kat. <br><a name="habracut"></a><br>  A demo project with all this disgrace can be found on GitHub by <a href="https://github.com/alien190/LaunchLayoutManager">reference</a> . <br><br>  At the heart of the screen that interests us is everyone‚Äôs favorite RecyclerView.  And the highlight is the fact that when scrolling through the list, one fully visible top element scaled in a special way.  This feature is characterized by the fact that scaling occurs in different ways for the components that make up the list item. <br><br>  However, it is better to see once. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Fig.</b>  <b class="spoiler_title">1. General view</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ji/yz/eo/jiyzeombd0zp1adcn-aeddcnf6e.gif"></div><br></div></div><br>  Consider the list item in detail.  In the project, it is implemented as a LaunchItemView class inherited from CardView.  Its markup contains the following components: <br><br><ul><li>  Image - class ScaledImageView, designed to render an image with a given height (scaling). </li><li>  Headline </li><li>  Explanatory text. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r6/tm/af/r6tmaf5i0c_9gua5kstsbhizono.gif"></div><br>  <i>Fig.</i>  <i>2. The structure of the list item (LaunchItemView).</i> <br><br>  In the process of scrolling the list, the following happens: <br><br><ol><li>  The element height changes from the minimum value (equal to the height of the title with decoration) to the maximum value (equal to the height that allows displaying the title and explanatory text, with decoration). </li><li>  The height of the image is equal to the height of the element minus decoration, the width changes proportionally. </li><li>  The relative position inside the element and the size of the explanatory text remains unchanged. </li><li>  The magnitude of the scaling is limited to the top with a minimum size sufficient to display all content with regard to decoration and below with a minimum size sufficient to display the title with regard to decoration. </li><li>  Scaling, other than boundary values, is applied to the top fully visible list item.  The elements above it have a maximum scale, below - the minimum. </li></ol><br>  Thus, when scrolling up, the effect of gradual ‚Äúpulling‚Äù of the element content with proportional scaling of the image is created.  When scrolling down, the opposite effect is observed. <br><br>  I solved the problem posed in this way by creating a LayoutManager for RecyclerView and two additional components.  But first things first. <br><br><h4>  LaunchLayoutManager </h4><br>  My training project is devoted to space topics, so the components have received the appropriate names. <br><br>  Studying the topic of creating an arbitrary LayoutManager, I found two good articles on this topic [1, 2].  I will not repeat their contents.  Instead, I‚Äôll focus on the most interesting points of my decision. <br><br>  Performing the decomposition of the task, I outlined two main stages: <br><br><ol><li>  The definition of the index of the first and last element, which are fully or partially visible on the screen. </li><li>  Rendering of visible elements with the necessary scaling. </li></ol><br>  In general, the location and size of the elements of the list is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ik/fb/l4/ikfbl4omk6dj1ev2vb18zy1cih8.gif"></div><br>  <i>Figure 3. RecyclerView and its elements.</i> <br><br><h4>  Definition of the closed interval of indices of visible elements </h4><br>  In fig.  3 visible elements include indexes from 3 to 11 inclusive.  Moreover, according to our algorithm, the elements with indices 0-3 have a maximum size, the elements 5-12 have a minimum size, and the element with an index 4 is intermediate between the minimum and maximum. <br><br>  As you might guess, one of the key points in determining the minimum and maximum index of visible elements is the offset by which the list is swept relative to the upper boundary of the visible area. <br><br>  Consider the method calculateVisiblePositions, designed to determine these values. <br><br><pre><code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateVisiblePositions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mBigViewHeight != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">3</span></span> mMaximumOffset = (getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>) * mBigViewHeight; <span class="hljs-number"><span class="hljs-number">4</span></span> mFirstVisibleViewPosition = mOffset / mBigViewHeight; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFirstVisibleViewPosition &gt; getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-number"><span class="hljs-number">6</span></span> mFirstVisibleViewPosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">7</span></span> mOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> mLastVisibleViewPosition = mFirstVisibleViewPosition; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> emptyHeight = getHeight(); <span class="hljs-number"><span class="hljs-number">12</span></span> mFirstVisibleViewTopValue = mBigViewHeight * mFirstVisibleViewPosition - mOffset; <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstVisibleViewBottomValue = mFirstVisibleViewTopValue + mBigViewHeight; <span class="hljs-number"><span class="hljs-number">14</span></span> emptyHeight -= firstVisibleViewBottomValue; <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> secondVisibleViewHeight = getViewHeightByTopValue(firstVisibleViewBottomValue); <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyHeight - secondVisibleViewHeight &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">17</span></span> emptyHeight -= secondVisibleViewHeight; <span class="hljs-number"><span class="hljs-number">18</span></span> mLastVisibleViewPosition++; <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smallViewPosCount = emptyHeight / mSmallViewHeight; <span class="hljs-number"><span class="hljs-number">20</span></span> mLastVisibleViewPosition += smallViewPosCount; <span class="hljs-number"><span class="hljs-number">21</span></span> emptyHeight -= smallViewPosCount * mSmallViewHeight; <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyHeight &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">23</span></span> mLastVisibleViewPosition++; <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-number"><span class="hljs-number">25</span></span> } <span class="hljs-number"><span class="hljs-number">26</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mLastVisibleViewPosition &gt; getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-number"><span class="hljs-number">27</span></span> mLastVisibleViewPosition = getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">28</span></span> } <span class="hljs-number"><span class="hljs-number">29</span></span> Timber.d(<span class="hljs-string"><span class="hljs-string">"calculateVisiblePositions mFirstVisibleViewPosition:%d, mLastVisibleViewPosition:%d"</span></span>, mFirstVisibleViewPosition, mLastVisibleViewPosition); <span class="hljs-number"><span class="hljs-number">30</span></span> } <span class="hljs-number"><span class="hljs-number">31</span></span> }</code> </pre> <br>  Line 2 - check whether the height of the element of the maximum size, which displays all the content (title, explanatory text and image), is determined.  If not, then it makes no sense to continue. <br><br>  Line 3 - we calculate how many places, except for one item scrolled up, will take up the maximum allowable offset.  This value will limit the offset value in the scrollVerticallyBy method. <br><br>  Line 4 - calculate the index of the first visible element.  Since the mFirstVisibleViewPosition variable is of integer type, due to the drop of the fractional part, we automatically take into account the case of the partially visible first element. <br><br>  Lines 5-8 - checks if the index of the first visible item exceeds the index of the last item in the list.  This can happen, for example, when the list was first scrolled up, and then the number of elements decreased, for example, by applying a filter.  In this case, simply ‚Äúrewind‚Äù the list to the beginning. <br><br>  Line 10 - use the index of the first visible element as a starting point to search for the index of the last. <br><br>  Line 11 - set the height of the visible area.  This value will decrease during the search for the maximum index of visible elements. <br><br>  Lines 12, 13 - we define the coordinates top and bottom of the rectangle of drawing the first element. <br><br>  Line 14 - we reduce the free visible area by the size of the visible part of the first element.  Those.  as if we are virtually placing the first element on the screen. <br><br>  Line 15 - calculate the height of the second visible element.  This element is potentially subject to scaling (see paragraph 5 of the algorithm).  The getViewHeightByTopValue method is described in detail below. <br><br>  Line 16 - check if there is still free space after the ‚Äúvirtual placement‚Äù of the second element on the screen. <br><br>  Line 17 - we fix how much free space is left. <br><br>  Line 18 - increment the index of the last visible item. <br><br>  Line 19 - we calculate the largest number of elements of the minimum size that can fit in the remaining free space and at the same time will be fully visible. <br><br>  Line 20 - increase the index of the last visible element by the calculated value. <br><br>  Lines 21-24 - check if there is room for partial placement of another item.  If so, increase the index by one more. <br><br>  Now about the method that calculates the height of the second visible element depending on the position on the screen - the top coordinates of the display rectangle of this element. <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getViewHeightByTopValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> topValue -= mTopAndBottomMargins; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topValue &gt; mBigViewHeight) { <span class="hljs-number"><span class="hljs-number">4</span></span> topValue = mBigViewHeight; <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (topValue &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">6</span></span> topValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">7</span></span> } <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> scale = <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) topValue / mBigViewHeight; <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (mSmallViewHeight + scale * (mBigViewHeight - mSmallViewHeight)); <span class="hljs-number"><span class="hljs-number">10</span></span> Timber.d(<span class="hljs-string"><span class="hljs-string">"getViewHeightByTopValue topValue:%d, scale:%f, height:%d"</span></span>, topValue, scale, height); <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height; <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre><br>  Line 2 - drop the lower and upper margin. <br><br>  Lines 3-7 - for correct calculation of the scale, we limit the top from the top to the maximum height of the element, and from below to zero. <br><br>  Line 8 - we calculate the scaling factor, which takes the value 1 for the maximally expanded element and 0 for the minimum.  For the correctness of this particular result, we need restrictions in lines 3-7. <br><br>  Line 9 - we calculate the element height as an increase to the minimum height and the difference between the maximum and minimum height, taking into account the scaling factor.  Those.  when the coefficient is 0, the height is minimal, and when 1 - minimum + (maximum - minimum) = maximum. <br><br>  So now we know the first and last indexes of the elements to be drawn.  It's time to do it! <br><br><h4>  Drawing elements with the necessary scaling </h4><br>  Since the process of drawing is cyclical, then immediately before drawing we warm up the cache with already existing RecyclerView elements (if there are any, of course).  This technique is covered in [1, 2] and here I will not dwell on it. <br><br>  Consider the fillDown method, designed to draw elements moving from top to bottom along the available visible area. <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView.Recycler recycler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isViewFromCache; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topValue = mFirstVisibleViewTopValue; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomValue; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHeight; <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curPos = mFirstVisibleViewPosition; curPos &lt;= mLastVisibleViewPosition; curPos++) { <span class="hljs-number"><span class="hljs-number">8</span></span> isViewFromCache = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span> View view = mViewCache.get(curPos); <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-number"><span class="hljs-number">11</span></span> isViewFromCache = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-number"><span class="hljs-number">12</span></span> view = recycler.getViewForPosition(curPos); <span class="hljs-number"><span class="hljs-number">13</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">14</span></span> mViewCache.remove(curPos); <span class="hljs-number"><span class="hljs-number">15</span></span> } <span class="hljs-number"><span class="hljs-number">16</span></span> viewHeight = getViewHeightByTopValue(topValue); <span class="hljs-number"><span class="hljs-number">17</span></span> bottomValue = topValue + viewHeight; <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> LaunchItemView) { <span class="hljs-number"><span class="hljs-number">19</span></span> ((LaunchItemView) view).updateContentSize(viewHeight); <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isViewFromCache) { <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view.getTop() != topValue) { <span class="hljs-number"><span class="hljs-number">23</span></span> view.setTop(topValue); <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view.getBottom() != bottomValue - mTopAndBottomMargins) { <span class="hljs-number"><span class="hljs-number">26</span></span> view.setBottom(bottomValue - mTopAndBottomMargins); <span class="hljs-number"><span class="hljs-number">27</span></span> } <span class="hljs-number"><span class="hljs-number">28</span></span> attachView(view); <span class="hljs-number"><span class="hljs-number">29</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">30</span></span> layoutView(view, topValue, bottomValue); <span class="hljs-number"><span class="hljs-number">31</span></span> } <span class="hljs-number"><span class="hljs-number">32</span></span> topValue = bottomValue; <span class="hljs-number"><span class="hljs-number">33</span></span> } <span class="hljs-number"><span class="hljs-number">34</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable throwable) { <span class="hljs-number"><span class="hljs-number">35</span></span> Timber.d(throwable); <span class="hljs-number"><span class="hljs-number">36</span></span> } <span class="hljs-number"><span class="hljs-number">37</span></span> }</code> </pre><br>  Line 3 - we initiate the variable topValue by the coordinate of the top of the first visible element.  From the stove of this value and we will dance on. <br><br>  Line 7 - we initiate a loop on the indices of the elements to be drawn. <br><br>  Line 8 - optimistically we assume that we will find the item we need in the cache. <br><br>  Line 9 - look at the cache (with hope). <br><br>  Line 10-12 - if the item we need does not appear in the cache, we request it from an instance of the RecyclerView.Recycler class, which returns a view initialized with data from the adapter for a specific position. <br><br>  Line 14 - if the item was still in the cache, delete it from there. <br><br>  Line 16 - calculate the height of the element depending on its position on the screen. <br><br>  Line 17 - calculate the lower boundary of the element. <br><br>  Lines 18-20 - we scale the content of the element, if it knows how to do it. <br><br>  Line 21 - it is important for us to understand whether the current view was previously drawn (taken from the cache) or whether we received a new instance.  These two options require different approaches. <br><br>  Lines 22-28 - if the view is obtained from the cache, then, if necessary, we change the values ‚Äã‚Äãof the coordinates top and bottom, and attach the view. <br><br>  Line 30 - if the view is not from the cache, then to display the element we use the layoutView method, which is described below. <br><br>  Line 32 - we shift the topValue to the lower border of the view just drawn so that this value becomes the starting point for the next iteration of the loop. <br><br>  Now about the layoutView method for displaying a new list item obtained from an instance of the RecyclerView.Recycler class. <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> top, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bottom)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> addView(view); <span class="hljs-number"><span class="hljs-number">3</span></span> measureChildWithMargins(view, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decoratedMeasuredWidth = getDecoratedMeasuredWidth(view); <span class="hljs-number"><span class="hljs-number">5</span></span> RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) view.getLayoutParams(); <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> layoutDecorated(view, <span class="hljs-number"><span class="hljs-number">8</span></span> layoutParams.leftMargin, <span class="hljs-number"><span class="hljs-number">9</span></span> top + layoutParams.topMargin, <span class="hljs-number"><span class="hljs-number">10</span></span> decoratedMeasuredWidth + layoutParams.rightMargin, <span class="hljs-number"><span class="hljs-number">11</span></span> bottom + layoutParams.bottomMargin); <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre><br>  Line 2 - add view to RecyclerView. <br><br>  Line 3 - measure the view. <br><br>  Line 4 - define the width of the view. <br><br>  Line 5 - we get the layout view parameters. <br><br>  Line 7 - we actually draw the view in the received coordinates. <br><br><h4>  Content scaling </h4><br>  Of the entire structure of the list item, only the image is subject to scaling.  The logic of this scaling is encapsulated in the ScaledImageView class inherited from View. <br><br>  In our case, the execution of scaling is required at arbitrary points in time, and depends on external factors that we cannot control, for example, on how intensively the user scrolls the list.  Since this very organically falls into the reactive programming paradigm, I could not miss the chance to practice with RxJava and the hot data source. <br><br>  We will use PublishProcessor to create a stream of integer values ‚Äã‚Äãthat define the desired image height: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PublishProcessor&lt;Integer&gt; mScalePublishProcessor;</code> </pre> <br>  Accordingly, to perform scaling, we simply generate another stream element with the required value: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setImageHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ mScalePublishProcessor.onNext(height); }</code> </pre><br>  This is how the asynchronous processing of this stream takes place: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initObserver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> mScalePublishProcessor <span class="hljs-number"><span class="hljs-number">3</span></span> .filter(value -&gt; value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value != mBitmapHeight &amp;&amp; mOriginalBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> .onBackpressureBuffer(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> () -&gt; Timber.d(<span class="hljs-string"><span class="hljs-string">"initObserver: buffer overflow"</span></span>), BackpressureOverflowStrategy.DROP_OLDEST) <span class="hljs-number"><span class="hljs-number">6</span></span> .observeOn(Schedulers.computation(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span> .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createScaledBitmap) <span class="hljs-number"><span class="hljs-number">8</span></span> .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::setScaledBitmap) <span class="hljs-number"><span class="hljs-number">9</span></span> .subscribe( <span class="hljs-number"><span class="hljs-number">10</span></span> (value) -&gt; { <span class="hljs-number"><span class="hljs-number">11</span></span> invalidate(); <span class="hljs-number"><span class="hljs-number">12</span></span> Timber.d(<span class="hljs-string"><span class="hljs-string">"initObserver invalidate ThreadId:%d"</span></span>, Thread.currentThread().getId()); <span class="hljs-number"><span class="hljs-number">13</span></span> }, Timber::d); <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre><br>  Line 3 - perform the initial filtering: <br><br><ul><li>  Drop values ‚Äã‚Äãless than or equal to zero. </li><li>  We do not consider values ‚Äã‚Äãwhose value is equal to the height of the image scaled earlier.  Those.  the case when scaling is no longer required. </li><li>  Do not perform scaling when the original image is not initialized.  Initialization is discussed below in the setBitmap method. </li></ul><br>  Line 4 - use backpressure with a buffer size of 1 element and a strategy of displacing an older element from the buffer.  Due to this, we will always receive the most current value of the height for scaling.  In our case, this is very important, since we have a hot source that, in response to user actions (for example, intensive scrolling of the list), will generate elements faster than we can process them (perform scaling).  In such conditions, it makes no sense to accumulate values ‚Äã‚Äãin the buffer and process these elements sequentially, since they are already outdated, the user has already ‚Äúsquandered‚Äù this state. <br><br>  To illustrate and enhance the effect, I added a delay of 25 ms to the image scaling method (createScaledBitmap) and below resulted in two visualizations: without using back pressure (left) and with back pressure (right).  The interface on the left is clearly behind the actions of the user, living some kind of life.  Right - lost in smoothness due to the additional delay in the scaling method, but not in responsiveness. <br><br><div class="spoiler">  <b class="spoiler_title">Comparison</b> <div class="spoiler_text"><table><tbody><tr><td align="center">  Without back pressure <img src="https://habrastorage.org/webt/vd/mw/mj/vdmwmjrlryyufs1dcl0zw7ypyok.gif"></td><td align="center">  Back pressure <img src="https://habrastorage.org/webt/ji/hl/ae/jihlaeq9kkok6vrqjez99_clqjk.gif"></td></tr></tbody></table><br></div></div><br>  Line 6 - transfer work to the Schedulers.computation () stream with indication of the buffer size. <br><br>  Line 7 - we perform scaling (see the description of the method below). <br><br>  Line 8 - set the scaled image to display. <br><br>  Line 9 - subscribe to the stream. <br><br>  Line 11 - at the end of scaling we redraw the element. <br><br>  The createScaledBitmap method directly involved in obtaining an image of the desired size: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createScaledBitmap</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> Timber.d(<span class="hljs-string"><span class="hljs-string">"createScaledBitmap value:%d"</span></span>, value); <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; mHeightSpecSize) { <span class="hljs-number"><span class="hljs-number">4</span></span> value = mHeightSpecSize; <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bitmap.createScaledBitmap(mOriginalBitmap, value, value, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-number"><span class="hljs-number">7</span></span> }</code> </pre><br>  Lines 3-5 - we will limit the maximum height to the size of view, which is calculated in the onMeasure method. <br><br>  Line 6 - create an image of the desired size from the original. <br><br>  In the setScaledBitmap method, we save the scaled image for displaying in view: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setScaledBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap bitmap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-number"><span class="hljs-number">3</span></span> mBitmapLock.lock(); <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitmap != mDrawBitmap &amp;&amp; mDrawBitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-number"><span class="hljs-number">5</span></span> mDrawBitmap.recycle(); <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-number"><span class="hljs-number">7</span></span> mDrawBitmap = bitmap; <span class="hljs-number"><span class="hljs-number">8</span></span> mBitmapHeight = bitmap.getHeight(); <span class="hljs-number"><span class="hljs-number">9</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable throwable) { <span class="hljs-number"><span class="hljs-number">10</span></span> Timber.d(throwable); <span class="hljs-number"><span class="hljs-number">11</span></span> } <span class="hljs-number"><span class="hljs-number">12</span></span> mBitmapLock.unlock(); <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre><br>  Lines 3, 12 - we use a lock to synchronize the access to the variable containing the image to be drawn on the screen. <br><br>  Lines 4-6 - recycle the previously created image. <br><br>  Lines 7-8 - remember the new image and its size. <br><br>  The setBitmap method sets the original image: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBitmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap bitmap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitmap != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-number"><span class="hljs-number">3</span></span> mOriginalBitmap = Bitmap.createScaledBitmap(bitmap, mWidthSpecSize, mHeightSpecSize, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitmap != mOriginalBitmap) { <span class="hljs-number"><span class="hljs-number">5</span></span> bitmap.recycle(); <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = mBitmapHeight; <span class="hljs-number"><span class="hljs-number">8</span></span> mBitmapHeight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span> setImageHeight(height); <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-number"><span class="hljs-number">11</span></span> }</code> </pre><br>  Line 3 - we scale the original image to the size of the view.  This will allow us to save resources when performing scaling in the createScaledBitmap method if the original image exceeds the view in size. <br><br>  Line 4-6 - recycle the old original image. <br><br>  Lines 7-9 - reset the height for scaling to overcome the filter in the initObserver method, and produce a stream element to redraw the new image at the required scale. <br><br><h4>  Total </h4><br>  As part of the article, I tried to clearly explain some of the ideas that came to me during the work on the educational project.  The demo project can be found on GitHub at the <a href="https://github.com/alien190/LaunchLayoutManager">link</a> .  With comments, suggestions, suggestions and criticism, please comment. <br><br><h4>  Related Links </h4><br><ol><li>  <a href="https://habr.com/company/eastbanctech/blog/267497/">Recipes for Android: How to make a delicious LayoutManager</a> </li><li>  <a href="http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/">Building a RecyclerView LayoutManager - Part 1</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/434024/">https://habr.com/ru/post/434024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434010/index.html">To yourself devops or configure Nginx proxy for Apache Tomcat on Ubuntu in 5 minutes with https and firewall</a></li>
<li><a href="../434012/index.html">Free PVS-Studio for those who develop open projects</a></li>
<li><a href="../434016/index.html">Operation of rabbits (RabbitMQ) in the "Survive at any cost"</a></li>
<li><a href="../434018/index.html">We get a certificate from Google Associate Android Developer</a></li>
<li><a href="../434022/index.html">Uber resumed tests of its robomobiles nine months after the fatal accident</a></li>
<li><a href="../434026/index.html">Price of change: how much will the processing of the code actually cost</a></li>
<li><a href="../434028/index.html">Alexa developers have integrated digital assistant with Wolfram Alpha</a></li>
<li><a href="../434030/index.html">The series "Mars": False accidents and ecology instead of astronautics</a></li>
<li><a href="../434032/index.html">California public transportation in 20 years should be safe for the environment</a></li>
<li><a href="../434034/index.html">Fit YouTube Tutorials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>