<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>List.of () and everything, everything, everything ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, habrozhiteli. Finally got around to write something on Habr. The first article was a bit boring and highly specialized. Therefore, I write in t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>List.of () and everything, everything, everything ...</h1><div class="post__text post__text-html js-mediator-article">  Hello, habrozhiteli.  Finally got around to write something on Habr.  The first article was a bit boring and highly specialized.  Therefore, I write in the sandbox a second time.  (UPD but for some reason it didn‚Äôt hit the wow in the sandbox) <br><br>  This time it will be about Java innovations.  Namely, about ImmutableCollections.  You probably have already used List.of () somewhere.  Most likely in tests, because I don‚Äôt see any practical value in these methods.  But even in the tests you can stumble on banal pitfalls.  They are banal due to the fact that once having read their code, everything immediately falls into place, but there are still very, very many questions why it was done this way and not differently. <br><br>  Let's start with the List interface, in which there are static functions of. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">As many as eleven !!!</b> <div class="spoiler_text"><br><br><pre><code class="java hljs">List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5, E e6); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5, E e6, E e7); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10); List&lt;E&gt; List&lt;E&gt;.&lt;E&gt;of(E... elements)</code> </pre> <br></div></div><br>  Why so many methods in Java ???  For a long time I asked this question, but did not reach into the source code and google.  Today I did find an answer that completely dissatisfied me. <br><br><blockquote>  In the case of vararg calls. </blockquote><a name="habracut"></a><br>  It would seem, nevertheless, quite logical, less objects, less memory, less work of the garbage collector.  Although, what's the difference if we use it by and large in tests.  But the fact is that I think this answer is incorrect. <br><br>  If we look at the code of these methods, we will see the following: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ImmutableCollections.List0.instance(); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableCollections.List1&lt;&gt;(e1); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e1, E e2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableCollections.List2&lt;&gt;(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e1, E e2, E e3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e1, E e2, E e3, E e4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4); } <span class="hljs-comment"><span class="hljs-comment">/* ...      ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (elements.length) { <span class="hljs-comment"><span class="hljs-comment">// implicit null check of elements case 0: return ImmutableCollections.List0.instance(); case 1: return new ImmutableCollections.List1&lt;&gt;(elements[0]); case 2: return new ImmutableCollections.List2&lt;&gt;(elements[0], elements[1]); default: return new ImmutableCollections.ListN&lt;&gt;(elements); } }</span></span></code> </pre><br>  The first 3 methods return us strange objects of the classes List0, List1, List2.  All others will return ListN.  And the last method in which varargs are used can return one of the listed lists.  Beginning from 3 elements to 10, we actually send arguments to the method, and in no array will this data be wrapped. <br><br>  It would seem that everything is fine, but let's dig further.  Let's see the implementation of the ListN &lt;&gt; constructor <br><br><pre> <code class="java hljs">ListN(E... input) { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) E[] tmp = (E[])<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[input.length]; <span class="hljs-comment"><span class="hljs-comment">// implicit nullcheck of input for (int i = 0; i &lt; input.length; i++) { tmp[i] = Objects.requireNonNull(input[i]); } this.elements = tmp; }</span></span></code> </pre><br>  As you can see, the varargs syntax is already present.  And this means that even if it was possible to avoid wrapping in an array during the first call, this happened anyway if the constructor was called.  And why was such an implementation needed?  This question is still open to me.  I would be glad if someone in the comments will tell. <br><br>  Now about the pitfalls of these collections.  Let's look at the implementation of these collections from the inside. <br><br>  At the head of all Immutable lists is: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractImmutableList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre><br>  All methods of this collection abstract throw UnsupportedOperationException.  Not all abstract methods from AbstractList have proven in this class.  Therefore, I attach the code: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeIf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Predicate&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; filter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retainAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Comparator&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> uoe(); }</code> </pre><br>  That is, for example, the method containsAll will have the same implementation as all the other collections that we have successfully used, and not always.  But now is not about that. <br>  The classes List0, List1, List2, and ListN are inherited from the AbstractImmutableList class.  Each class implements some of the methods. <br><br>  Take for example the class List0.  The contains method can throw a NullPointerException. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(o); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br>  This is very unexpected.  Why it was impossible to just always return false?  Why is there a check for null.  This remains to me incomprehensible. <br><br>  The behavior of the containsAll method is the same as in regular lists. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o.isEmpty(); <span class="hljs-comment"><span class="hljs-comment">// implicit nullcheck of o }</span></span></code> </pre><br>  True NPE will pop up because of the call to the isEmpty () method, and not the for each loop as in regular lists. <br>  In the source code, I noticed one comment that raised my spirits and reminded me how much the machine (more about the compiler) is smarter than a person. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ Objects.checkIndex(index, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// always throws IndexOutOfBoundsException return null; // but the compiler doesn't know this }</span></span></code> </pre><br>  Let's go further to List1.  There are more questions.  Let's start with the constructor. <br><br><pre> <code class="java hljs">List1(E e0) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.e0 = Objects.requireNonNull(e0); }</code> </pre><br>  Why can't I have null stored in the list?  What is the logic?  Let's go further.  The contains method still throws out the NPE. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o.equals(e0); <span class="hljs-comment"><span class="hljs-comment">// implicit nullcheck of o }</span></span></code> </pre><br>  Although there is already more logical.  If the constructor does not create lists with null, then this is expected.  But what prevented to write: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; o.equals(e0);</code> </pre><br>  or much more beautiful: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e0.equals(o);</code> </pre><br>  Again, relying on the fact that e0 cannot be null.  The implementation of the containsAll method lies in the AbstractCollection class: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object e : c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contains(e)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  If the collection is null, then we get the same NPE, as is the case with regular collections.  But we also get NPE if the collection of parameters is null, since there is a dependency on the contains method, which will give us this NPE. <br><br>  At what NPE is quite dangerous here. <br><br><pre> <code class="java hljs">List&lt;String&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-string"><span class="hljs-string">"FOO"</span></span>); list.add(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;String&gt; immutableList = List.of(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>); immutableList.containsAll(list);</code> </pre><br>  In this case, we will not say NPE, since our list does not contain the string "FOO".  We will immediately receive a false response.  If in our ArrayList the first element would be ‚Äúfoo‚Äù, then we would immediately catch the NPE.  Therefore, be extremely careful in such situations. <br><br>  List2 and ListN are sinners the same. <br><br>  In summary, I still have a few questions.  Why these collections do not behave the same as ordinary ArrayList, LinkedList?  Why collections cannot contain null.  Why was it necessary to create so many methods?  Is this code really in a hurry and nobody wants to do it?  But, since I cannot give answers to these questions, it remains to use what is, knowing about the pitfalls that are present in these new handy features. <br><br>  <b>P.S.</b>  I assume that Set and Map also have their own similar pitfalls.  But I‚Äôll reach them sometime later, when a few more minutes of free time appear. </div><p>Source: <a href="https://habr.com/ru/post/349944/">https://habr.com/ru/post/349944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349932/index.html">Business, let's go ...</a></li>
<li><a href="../349934/index.html">Richard Hamming: Chapter 8. Artificial Intelligence-III</a></li>
<li><a href="../349936/index.html">Richard Hamming: Chapter 3. The History of Computers - Iron</a></li>
<li><a href="../349940/index.html">Kubernetes success stories in production. Part 8: Huawei</a></li>
<li><a href="../349942/index.html">Parsing telegram channels for content aggregator in PHP</a></li>
<li><a href="../349946/index.html">Confession of a product manager</a></li>
<li><a href="../349948/index.html">Dismissal for keeping pornography on the computer: the European Court found no violation</a></li>
<li><a href="../349950/index.html">Making holes in torrents freeing up space and remaining on hand (part 1)</a></li>
<li><a href="../349954/index.html">‚ÄúProfit is great. We got a lot of freedoms that we didn‚Äôt have before, ‚Äù- Vladimir Plizga about microservices</a></li>
<li><a href="../349958/index.html">Come and pick up the prototype books</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>