<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do-it-yourself interactive 3D maps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If 3D-graphics is not your main specialization, you may still have to, or, as in the case of the author of this report, Alexander Amosov ( @ s9k ), yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do-it-yourself interactive 3D maps</h1><div class="post__text post__text-html js-mediator-article">  If 3D-graphics is not your main specialization, you may still have to, or, as in the case of the author of this report, <strong>Alexander Amosov</strong> ( <a href="https://habr.com/users/s9k/">@ s9k</a> ), you want to work with it.  The entry threshold is not so high, you can take the WebGL technology available in the browser, the popular Three.js framework and a small company of like-minded people to make an interesting project with your own hands.  It is by the example of such a project, started in the Avito hakaton, and we will analyze the main stages, pay attention to the problem areas, and finally motivate us to create something as cool as this office map. <br><br><img src="https://habrastorage.org/webt/pa/kn/xi/paknxiyevmdekeeu9if9oyjgpmo.png"><br><br>  The project, by the way, is interesting in itself.  In modern large open space to navigate in space, to find the right people or negotiations are often very difficult.  Of course, you can make a diagram in Excel, but this is not always a super good solution.  Alexander Amosov had an idea to make it more convenient, which he shared on <a href="http://frontendconf.ru/">Frontend Conf</a> , and the following is a transcript of his report. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/YLFwkbTvb-4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Story </h2><br>  A few words about the project.  Our company is actively developing, there are new employees, and there is a banal problem of navigation in the office. <br><img src="https://habrastorage.org/webt/fg/vh/3p/fgvh3p0ffkfvztcz56x9t7ec1je.png"><br><br>  Until recently, there were schematic maps, for example, like this map of one of the floors, which shows what is located.  But it is <strong>fixed</strong> , but over time, something changes, people change to different departments, and the map becomes irrelevant. <br><br>  An even bigger problem was finding the right employee.  At first there was a powerful table in Confluence, where the cells are the places of the employees, in which their names are entered.  If the imagination is not very good, it is not very convenient.  In the presented image, the table (on the left) and the map (on the right) correspond to the same place in the office.  Of course, the scheme can be made with the help of a table, it will be a very cheap and quick solution, but extremely beloved. <br><br><img src="https://habrastorage.org/webt/hj/sj/zl/hjsjzlfhhnbbvnwbrksixp29zue.png"><br><br>  There was an idea to make it more convenient, <strong>so that new employees without difficulty find what they need</strong> . <br><img src="https://habrastorage.org/webt/pa/kn/xi/paknxiyevmdekeeu9if9oyjgpmo.png"><br><br>  This is a three-dimensional map that has all the floors, you can search for a person and find out where he is, get his contacts and tritely find the right conversation. <br><br><h2>  2D vs 3D </h2><br>  When the project was just being born, naturally, it was not without controversy.  I was told: ‚ÄúWhy 3D?  This is all incomprehensible.  Everyone is accustomed to two-dimensional maps!  They can be made quickly and easily.  Let's do the two-dimensional! ‚Äù <br><br>  Why was the 3D implementation chosen? <br><img src="https://habrastorage.org/webt/cv/kf/ur/cvkfurqqwrwvasvilmhv2xhubv4.png"><br><br>  The original two-dimensional svg-scheme would look on the page is not very beautiful.  Even in the absence of large resources due to 3D, shadows and perspective, the map looks more elegant. <br><br>  ‚Ä¢ <strong>This is clear</strong> <br><br>  Such maps, it seems to me, are more illustrative, because we still exist in three-dimensional space.  You can turn as you like, and navigate - it is very convenient. <br><br>  ‚Ä¢ <strong>Because I can</strong> <br><br>  This is the main reason - I can, this is interesting to me, in contrast to the two-dimensional implementation, which I would not do. <br><br>  How does it all start? <br><br><h2>  Creating a model </h2><br>  There are options: <br><br>  ‚Ä¢ Find a modeler (optional) <br><br>  This is probably the most ideal option - to find a person who understands 3D MAX and similar programs so that he can do everything, and you would just take this model. <br><br>  ‚Ä¢ Find ready-made models (optional) <br><br>  If there is no such person, ready-made models can be found on the Internet. <br><br>  ‚Ä¢ Master the 3D editor yourself <br><br>  This option is actually <strong>mandatory</strong> (there is no word ‚Äúoptional‚Äù in brackets) - because you need it anyway.  Just a matter of immersion level.  Even if you have a modeler, then, most likely, you still have to edit something yourself or at least open it in the editor to check that the model is done as it should.  Therefore, this item is necessary. <br><br>  I used the blender 3D editor. <br><br><img src="https://habrastorage.org/webt/3g/y0/lw/3gy0lwwwepa8akmmr9ahhfppf10.png"><br><br>  Probably everyone has heard about 3D MAX - a program for three-dimensional editing.  This is its counterpart, only from the world of OpenSource.  This editor is free, is under all major platforms and it is constantly evolving.  There is a cool feature in it - everything that can be done with Blender can be done with a regular python script. <br><br>  You can hover over some element of the interface, and a pop-up window will show which method you need to perform in order to get data, or to trigger a specific action. <br><img src="https://habrastorage.org/webt/p-/cf/nx/p-cfnxrkn99igkozmq0mf9w2yz4.png"><br><br>  Another cool feature is that it supports import from SVG by default. <br><img src="https://habrastorage.org/webt/tx/ot/mm/txotmmkptojsamralzmogtgm80c.png"><br><br>  I just had the source material SVG, so it really suited me.  You can simply import the scheme, convert to triangles and set the height of the wall.  The only thing that there were no chairs on which there are employees, they had to be placed in Blender manually. <br><br><img src="https://habrastorage.org/webt/zx/bm/a3/zxbma3ecbuppmc5imqpbyfvz1f4.png"><br><br>  In principle, these places are all the same, so they had to be cloned with a slight shift.  The most convenient place to place when you look at the top, but it turned out that when you look at the top, everything seems to be in order, but in fact they can be at different levels. <br><br>  Plus, when you clone places, you can accidentally clone the so-called geometry.  <strong>Geometry is the points that make up the skeleton</strong> .  Duplication is not very good, as the model begins to occupy more disk space. <br><br>  Here comes to the aid of one of the chips, namely, that you can use the python script. <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bpy geometry = bpy.data.meshes[<span class="hljs-string"><span class="hljs-string">'place'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bpy.context.selected_objects: obj.rotation_euler.x = <span class="hljs-number"><span class="hljs-number">0</span></span> obj.rotation_euler.y = <span class="hljs-number"><span class="hljs-number">0</span></span> obj.data = geometry obj.location.z = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  We simply take the geometry of the place, run over the selected objects, reset the turn, indicate that they all refer to the same geometry and height (Z axis is pointing up) reset to 0. <br><br><h3>  Shadows </h3><br>  Shadows were also baked in Blender.  Naturally, with <strong>shading objects look more volumetric</strong> .  When using the ambient occlusion real-time shading technique (mutual shading of objects), drawing will slow down, so it is best to <strong>bake the shadows in advance</strong> . <br><img src="https://habrastorage.org/webt/bp/qu/jw/bpqujwzh-nyiqij1weuheogsw6k.png"><br><br>  The figure shows the pre-baked shadows: on the right ‚Äî the texture, on the left ‚Äî the texture coordinates by which this texture is superimposed on the object. <br><img src="https://habrastorage.org/webt/eh/qf/ob/ehqfob76trttf3le9s9l7x5-yzk.png"><br><br>  Another example of what texture coordinates look like. <br><br>  After some simple actions, you need to press the ‚ÄúBake‚Äù button, select mutual shading and bake.  These are not real shadows, because I am not very well versed in three-dimensional editors, and it was difficult for me to arrange light sources beautifully so that everything would be textured and cool.  Therefore, mutual shading is quite a suitable option. <br><img src="https://habrastorage.org/webt/w-/82/we/w-82we6e35bukxxuddkl1berfyi.png"><br><br>  You can compare how a flat implementation and a picture with shadows look like. <br><br>  We figured out the models, we believe that there is a model, and now we need to embed it in the browser so that everyone can use it. <br><br><h2>  Webgl </h2><br>  The WebGL specification comes to the rescue. <br><img src="https://habrastorage.org/webt/y5/4u/hf/y54uhfwcrtgecd6q4eqoznpq83o.png"><br><br>  A little bit of a story about what it is.  WebGL is based on the OpenGL for Embedded Systems version 2.0 specification, and essentially repeats it with minor changes.  OpenGL for Embedded Systems, in turn, is a subset of the OpenGL specifications, only designed for mobile devices.  That is, there is cut too much. <br><br>  WebGL version 2.0 is also supported by browsers, but is not yet so common.  WebGL Next is also being discussed now, but it is not clear what it will focus on, and whether it will be at all.  Maybe on Vulkan - for now it‚Äôs not clear. <br><img src="https://habrastorage.org/webt/jz/4m/vb/jz4mvbe0aelqhlyt607zfcyiuky.png"><br><br>  <strong>WebGL 1.0 is supported everywhere</strong> : on iOS, Android, etc.  There are no problems with this. <br><img src="https://habrastorage.org/webt/s2/v-/nl/s2v-nlthkz3c0hnjv6mdgmokhkw.png"><br><br>  For comparison, WebGL 2.0 is currently not very well supported, so for now let's wait. <br><br><h3>  2D vs 3D [2] </h3><br>  In order to understand WebGL, let's compare two- and three-dimensional implementations.  Let's make a simple test: how the two- and three-dimensional implementations of the usual red square will look like. <br><br>  A two-dimensional implementation on Canvas is quite simple: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvas"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> (</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> canvas = </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">document</span></span></span><span class="javascript">.getElementById(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'canvas'</span></span></span><span class="javascript">); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> context = canvas.getContext(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'2d'</span></span></span><span class="javascript">); context.fillStyle = </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'rgba(255, 0, 0, 1)'</span></span></span><span class="javascript">; context.fillRect(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">25</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">25</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">50</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">50</span></span></span><span class="javascript">); }()); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  There is a canvas element, we take its two-dimensional context, define the fill style, and draw a square. <br><br>  The three-dimensional implementation seems to be similar at first: there is also a canvas element, the context is taken using canvas.getContext ('webgl').  But here are the differences.  Now I will try to explain.  You can not go deep into the implementation and not be afraid of incomprehensible terms, then I will explain how to simplify it all. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvas"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"100"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> (</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> canvas = </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">document</span></span></span><span class="javascript">.getElementById(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'canvas'</span></span></span><span class="javascript">); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> gl = canvas.getContext(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'webgl'</span></span></span><span class="javascript">); </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">//   //   //    //        //   }()); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  What you need to do next: <br><br>  1. <strong>Vertex shader</strong> - compile and transfer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexShaderSource = <span class="hljs-string"><span class="hljs-string">` attribute vec4 position; void main() { gl_Position = position; } `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexShaderSource); gl.compileShader(vertexShader);</code> </pre><br>  2. <strong>Fragment shader</strong> , which simply gives red color at the output - again compile and transfer <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fragmentShaderSource = <span class="hljs-string"><span class="hljs-string">` void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, vertexShaderSource); gl.compileShader(fragmentShader);</code> </pre><br>  3. <strong>Program</strong> - we associate both shaders with the program and use it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); gl.useProgram(program);</code> </pre><br>  4. <strong>The vertex buffer</strong> , in which the coordinates of the square's vertices are set, after creation, you need to bind, transfer the coordinates of the vertices, associate the position attribute from the vertex shader with the vertex buffer, and use it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>([ <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexSize = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attrPosition = gl.getAttribLocation(program, <span class="hljs-string"><span class="hljs-string">'position'</span></span>); gl.vertexAttribPointer(attrPosition, vertexSize, gl.FLOAT, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gl.enableVertexAttribArray(attrPosition);</code> </pre><br>  5. Then we need to <strong>draw</strong> all this. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>([ <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexSize = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / vertexSize);</span></span></code> </pre><br>  So "easy" turned out to be a red square! <br><br>  You probably understand that WebGL is not so simple.  It is quite <strong>low-level</strong> , there are a bunch of methods, and there are a million arguments in them.  And this is a simplified code - there are no checks for errors that are needed in real code. <br><br><blockquote>  If you want to delve into the native WebGL, there is an excellent book in Russian Koichi Matsuda, Roger Lee "WebGL: programming three-dimensional graphics." <br></blockquote><br>  I recommend reading, there everything is available is told from the very beginning.  Starting, for example, with drawing the simplest triangle, and ending with the creation of full-fledged three-dimensional objects with shadows. <br><br>  If there is no time to figure it out, but most likely it is not there - even the project that I did was implemented as part of a hackathon within a couple of days (the first prototype with 2 floors).  Therefore, favorite (or not favorite) frameworks come to the rescue. <br><br>  I used <strong>Three.js</strong> , as the most popular and used WebGL framework.  The most important advantage of this framework is that they create <strong>convenient abstractions</strong> , with the help of which you can do everything faster and with less code, without delving into the low-level API.  It is possible for the entire project not to write a single shader. <br><br>  This example is taken from the <a href="">Readme Three.js</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scene, camera, renderer, geometry, material, mesh; init(); animate(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); camera.position.z = <span class="hljs-number"><span class="hljs-number">1000</span></span>; geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span> ); material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial( { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xff0000</span></span>, <span class="hljs-attr"><span class="hljs-attr">wireframe</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ); mesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Mesh( geometry, material ); scene.add( mesh ); renderer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.WebGLRenderer(); renderer.setSize( <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight ); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild( renderer.domElement ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame( animate ); mesh.rotation.y += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; renderer.render( scene, camera ); }</code> </pre><br>  By copying this code into your browser, in fact, we already have a full three-dimensional visualization.  And this is not just some ordinary square, but a three-dimensional cube, which also rotates. <br><br>  Consider this example. <br><ul><li>  We have a certain scene ( <code>scene</code> ) - this is virtual space.  These scenes may be several, but usually she is one.  If there are several scenes, then they exist as parallel worlds. <br></li><li>  There is a camera ( <code>camera</code> ) - the point from which we will shoot and receive a picture on the screen. <br></li><li>  Next comes the code section where we create the object.  This creates the geometry of the cube ( <code>geometry</code> ) and its material ( <code>material</code> ), in this case, just a flat red color.  When we combine the cube frame and impose material on it, we get a red cube ( <code>mesh</code> ), which we then place on the stage (our virtual space). <br></li><li>  The next step is to create a renderer object, create a canvas object and interact with WebGL.  In this case, we set the size so that the rendering takes place in full screen, and add the canvas to the body on the page. <br></li><li>  After that, we just need to call the <code>animate()</code> function, which by <code>requestAnimationFrame</code> calls itself - plus the cube rotates. <br></li></ul><br><img src="https://habrastorage.org/webt/s0/83/kf/s083kf4bdkilcmdmkkdvjd-da5s.png"><br><br>  Thus, we have a complete visualization. <br><br>  If you take a piece of code where we create a cube, it is easy to replace it with code where there is a loader. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ObjectLoader(); loader.load(<span class="hljs-string"><span class="hljs-string">'model.json'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mesh</span></span></span><span class="hljs-function">) </span></span>{ scene.add(mesh); });</code> </pre><br>  We call the load method in order to load the model, and already on the stand we add not an abstract cube, but our model, and see it in the browser.  This is generally already cool! <br><br>  To get a model, you need the model to have a specific format.  In Three.js there is a <a href="https://github.com/mrdoob/three.js/tree/r92/utils/exporters/blender">ready-made exporter</a> that needs to be connected (by default it does not exist in Blender) and with its help export the model into a format in which you can already import it into the scene. <br><img src="https://habrastorage.org/webt/mt/rl/y0/mtrly0w2dqpk-z17lovfuxtftgs.png"><br><br>  But the picture turned out to be static, but we want to twist the model, look at it from different sides. <br><img src="https://habrastorage.org/webt/km/sx/ez/kmsxezoyhjjxjdfrw7tuo6uvxrm.png"><br><br>  In Three.js, <strong>OrbitControls</strong> is already available for this.  It is not in the main Three.js folder, but in <a href="">examples</a> (&lt;script src = "three / examples / js / controls / OrbitControls.js"&gt; &lt;/ script&gt;).  There is a lot of everything that is not included in the core-code, but you can additionally connect it. <br><br>  We connect OrbitControls, and create their instance by passing the camera object: <br><br><pre> <code class="javascript hljs">scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); camera.position.z = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.OrbitControls(camera);</code> </pre><br>  Now our camera is controlled by OrbitControls.  After that, you can rotate our model with the mouse.  We pinch the left mouse button and start moving it, you can also zoom in and out. <br><br><img src="https://habrastorage.org/webt/li/hu/kk/lihukkfrdcmmeyl37yvoovlcbno.png"><br><br>  This is <a href="https://goo.gl/ell2e7">an example</a> from Three.js.  There just is the loading of the model and controls, in principle, this is already a complete visualization.  If we sell, for example, a watch, you can make a model or find it on the Internet, insert it into the browser and the user can zoom in and view it from different sides. <br><br><blockquote>  To learn more about the world of three-dimensional graphics based on the use of the Three.js framework, there is <a href="https://www.udacity.com/course/interactive-3d-graphics--cs291">an excellent course</a> on Udacity.  He is very funny, however, in English. <br></blockquote><br><h2>  How the application works </h2><br>  When we have mastered the basics, we want more - to realize the work of a full-fledged application - not just twist-twirl, but connect additional functions. <br><br>  I divided the application into 2 parts. <br><br><h3>  Viewer </h3><br>  This is the part that is responsible for working with Canvas and WebGL.  It contains: <br><br><ul><li>  Model with baked shadows; <br></li><li>  Object reykasting occurs - the mechanism for determining which element of three-dimensional space we hit by clicking on the canvas.  This is necessary, for example, to allocate seats on the plan or to obtain information on the icon. <br></li><li>  Sprites for icons are original two-dimensional pictures in three-dimensional space.  If you played the first three-dimensional shooters, then remember that, for example, in Doom 1 and 2 all opponents were made sprites, that is, two-dimensional, and always looked at you. <br></li></ul><br><h2>  Ui </h2><br>  The interface is fairly standard and superimposes over the canvas; it has search, authorization, and movement across floors.  Thus, the floors can be allocated not only directly by clicking on them in three-dimensional space, but also using the classic two-dimensional interface. <br><br><img src="https://habrastorage.org/webt/jx/pn/hy/jxpnhy1zu7nswojgn_jp9s2-pkw.png"><br><br>  I chose two independent blocks, because it seemed convenient to me - if someone suddenly doesn‚Äôt support WebGL, you can quickly replace the viewer with an alternative one, for example, you can replace it with a two-dimensional implementation with a static picture.  The UI may remain the same - let's say highlight the places in this two-dimensional image. <br><br><img src="https://habrastorage.org/webt/hs/xw/ge/hsxwgeowmjc9xrulmcfjzcbtyjs.png"><br><br>  Everything is managed through the Redux store.  If any action occurs, action is created.  In this case, we can select the floor, as in the three-dimensional scheme, by clicking on the floor, and in the two-dimensional interface.  Respectively, the action will occur, the state of the application will be updated, and then spread to both parts: the Viewer and the UI. <br><br>  It would seem that everything is fine: there is a model, there is interactivity, there is an interface.  But, most likely, at this moment if there is a sufficiently large application, you will encounter the problem that users will say: ‚ÄúEverything is slowing down!‚Äù. <br><br><h2>  Everything slows down </h2><br>  I'll tell you what problems I encountered, and what helped me solve them. <br><img src="https://habrastorage.org/webt/o0/bk/o_/o0bko_uckvkvo7c6ba_3-vu2jva.png"><br><br>  The first problem was <strong>the brakes in Safari</strong> on macOS.  Moreover, if you try to profile, it seems to be a <code>requestAnimatioFrame</code> gives you an honest 60 FPS and it seems that everything should be fine, but from the <a href="https://youtu.be/YLFwkbTvb-4%3Ft%3D1276">video you</a> can see that everything happens in spurts.  And this is only in Safari - everything is fine in Chrome, and in FireFox it's fine. <br><br>  I have long understood what could be wrong.  Disconnected everything that is possible - it still slows down.  Then I took an example from Three.js with a cube that showed above, launched it, and it also slows down! <br><img src="https://habrastorage.org/webt/gl/m5/mu/glm5muksm4zjraqt9o3czdre-94.png"><br><br>  It turned out that the thing was this.  WebGL supports <strong>hardware-based anti-aliasing</strong> , which does not require any effort to turn it on.  You can simply specify antialias: true - be it pure WebGL or Three.js, and the picture gets better.  And due to the fact that it is hardware anti-aliasing, it works fast enough, I have never noticed any problems with it until this moment. <br><br>  But it was in Safari on Retina screens of mac-books with a huge resolution and, as always, a weak video card, this problem appeared.  It helped to disable hardware anti-aliasing for such devices in this browser. <br><img src="https://habrastorage.org/webt/pu/it/ql/puitqloru3vmt336iuctvg3ch04.png"><br><br>  Another problem that was still complained about was that when the application was started, the <strong>computer cooler started spinning</strong> and making noises <strong>furiously</strong> . <br><br>  It all turned out to be simple.  In the example that I showed, there is a function <code>animate()</code> , which, by <code>requestAnimationFrame</code> calls itself.  The thing is that we basically do not need it.  Suppose we rotated the model - the picture is static, nothing happens, but the video card suffers, <code>requestAnimationFrame</code> (in the ideal case) triggers 60 times per second.  Nothing happens, but we <strong>torture the video card for nothing,</strong> forcing the scene to be redrawn again and again. <br><img src="https://habrastorage.org/webt/u3/ng/8y/u3ng8yfjmpvi7aq3eumkonfj6vm.png"><br><br>  The solution is obvious: <strong>do not render when not needed</strong> .  We start to rotate the camera, everything moves, we start rendering.  As soon as we let go of the mouse button, stopped rotating the camera, we can stop the render. <br><br>  If the state of the application has changed, let's say we have chosen a place through a two-dimensional interface and need to highlight it, we can generally just render one frame and that's it - it is already highlighted. <br><img src="https://habrastorage.org/webt/wg/1i/fo/wg1ifoxlto2hmh2r1arwkryj1ng.png"><br><br>  I have already mentioned Raycasting.  When we click on the canvas, a vector is created in three-dimensional space and it is calculated which triangles that the objects consist of intersect this vector.  Accordingly, what the first object we crossed, that and select.  In Three.js it looks like this: <br><br><ul><li>  have a raycaster <br></li><li>  We transmit the coordinates and the camera, and the objects for which you want to check the intersection, <br></li><li>  we end up with intersections. <br></li></ul><br><img src="https://habrastorage.org/webt/hk/zd/ud/hkzdudlla85lcdlwh4gfykpcgs0.png"><br><br>  But if we have rather large models consisting of a large number of triangles, then this may take a long time.  In fact, you need to go through all the triangles that make up all the objects.  Therefore, another method is used.  In Blender, you can create an object in advance that approximates an object, but consists of a very small number of triangles (shown in red in the image above). <br><br>  We can make it invisible or even place it on a separate stage, but raycasting happens with it and much faster. <br><br><img src="https://habrastorage.org/webt/i-/oe/j3/i-oej3ovino5gejljzgtdzxtl-e.png"><br><br>  And if for floors it was necessary to create them manually - because there is a complicated geometry, then for places you can generate automatically in JS code.  We take a place, calculate the maximum position in x and y axes (we don‚Äôt even need it in z), and it‚Äôs ready.  We have a square consisting of 2 triangles - that's all. <br><img src="https://habrastorage.org/webt/am/61/vr/am61vrhj2-4xnrwwn9vj9caufh0.png"><br><br>  Using the <strong>Instancing</strong> technique <strong>gave the biggest performance boost</strong> (left result).  Before using Instancing, there were 365 draw calls (drawing on a video card), and after - 51. Although this is also quite a lot, probably due to icons. <br><br>  What's the point?  Remember, I told you that there are places that refer to the same geometry - just different instances are in different places with different colors.  When there are such objects of the same type, we can use this technique and use it to reduce the number of drawings on the video card.  All these places are combined into one object, which is rendered at a time - in one pass. <br><img src="https://habrastorage.org/webt/6v/gt/6m/6vgt6m5ik0mrr2j9_sjnatrxekw.png"><br><br>  Instancing is included in the specification of WebGL 2, in the very first WebGL it is available through an extension that is supported and available in all modern browsers. <br><br>  I'll try to explain how it works.  Suppose, by default, there are 4 places in 4 different positions in 4 different colors.  Usually we transfer this data through uniform - this is ‚Äúvariable‚Äù, which apply to the entire shader program.  If these places are combined into one Batch, then the places will be the same color and be in one place crowded. <br><img src="https://habrastorage.org/webt/ac/hg/g7/achgg7hcdycfztn96u2bov7-v8w.png"><br><br>  Therefore, to transfer exactly this data: color, position of places.  need through attribute.  This is a parameter that is transmitted for each vertex separately. <br><img src="https://habrastorage.org/webt/a_/wo/ts/a_wotsyqjujs2fszd4jyl3sy-pe.png"><br><br>  What you should know about Instancing: <br><ul><li>  <strong>It greatly improves performance</strong> .  If you have a lot of objects of the same type and everything slows down, most likely, it will give a big boost. <br></li><li>  <strong>But it is difficult</strong> .  See examples from Three.js <a href="https://goo.gl/zdaWZU">here</a> . <br></li></ul><br><img src="https://habrastorage.org/webt/v1/rk/n7/v1rkn7khelaw5miobu5emycwdlq.png"><br><br>  The next problem you encounter is this picture (in Chrome).  This usually happens when there is <strong>not enough video memory</strong> . <br><br>  What can help? <br><br><h3>  Simplify model </h3><br>  When converting svg images to a three-dimensional object, Blender creates a lot of extra points.  Objects are obtained, of course, well smoothed, but, most likely, this is not particularly visible.  <strong>And every extra point is the consumption of video memory and a decrease in performance</strong> . <br><img src="https://habrastorage.org/webt/eo/ze/nj/eozenjmzrdzi6jinr4czubq3rrk.png"><br><br><h3>  Texture optimization </h3><br>  Usually in three-dimensional games are used as low-poly models with a small number of triangles.  To neutralize this, beautiful pictures are achieved by using a large number of textures.  Unfortunately, this becomes a problem in the browser due to the fact that not much memory can be allocated under the tab and the tab will crash if it is not enough.  Therefore, there are techniques to reduce the number of textures and their optimization. <br><img src="https://habrastorage.org/webt/9f/rc/d1/9frcd12q6xjxfruafrfyjy01n4o.png"><br><br>  One of their techniques involves combining several textures into one.  Suppose if there are 3 black and white textures, they can be broken down into channels and merged into one: transfer the first texture to the red channel, second to the green and third - to the blue.  It turns out that in the end all this will take 3 times less video memory. <br><br><h3>  Compressed textures </h3><br>  There are different formats: DXT, PVRTC, ETC, which allow you to make a texture of 1024 * 1024 in size on a video card to occupy video memory as a texture of 512 * 512, that is, 4 times less. <br><br>  It would seem a steep profit, but there are big limitations: <br><br><ul><li>  <strong>Different formats</strong> (DXT - supported only on the desktop, PVRTC - on iOS, ETC - on Android).  In general, most likely, you will have to keep 4 different textures (for each format, and the fourth uncompressed) and check which format your system supports.  If no formats are supported, then use the original uncompressed texture. <br></li><li>  <strong>Deterioration of the picture</strong> .  The degree of distortion depends on the original image. <br></li><li>  <strong>Problems with transparency</strong> when artifacts appear on the border of a transparent area. <br></li><li>  <strong>Larger files</strong> (but gzip can be used).  A completely black PNG image with a size of 1024 * 1024 is downloaded instantly, but on the video memory, each point will memory out.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With compressed images, the opposite situation is observed - the texture file itself may weigh more, but it will take less space on the video memory. </font></font><br></li></ul><br><img src="https://habrastorage.org/webt/pn/gp/qy/pngpqyphedtpcdnfoc_kemkuwkm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the quality of compressed textures - the cat did not suffer much from compression. </font></font><br><img src="https://habrastorage.org/webt/tu/he/gd/tuhegdjs54eacjtmtamboc1hg6a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artifacts are already visible on the textures of this type - the shadow merges with the inscription itself. </font><font style="vertical-align: inherit;">But for variegated textures (like herbs) this is great. </font></font><br><br><img src="https://habrastorage.org/webt/v1/kg/sq/v1kgsqoea_4xrvskdh82-lh7mtc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important and useful advice - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not pursue realism</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Note that in indie games almost never have super-realistic graphics. </font><font style="vertical-align: inherit;">She is sketchy - colorful, funny, but little poly men run around, but everything is fun and fun, works fast and requires less resources to develop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing I wanted to say. </font><font style="vertical-align: inherit;">If you do 3D, do </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not do the project alone</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Find companions. </font><font style="vertical-align: inherit;">I did a project in the framework of the hackathon; I was helped by many good people. </font><font style="vertical-align: inherit;">One is difficult, and when you are together, it motivates, and everything turns out faster.</font></font><br><br><h2>  Useful links: </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚úì Course </font></font><a href="https://www.udacity.com/course/interactive-3d-graphics--cs291"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on three-dimensional graphics on Udacity</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚úì The book </font></font><a href="http://www.ozon.ru/context/detail/id/31239396/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúProgramming of three-dimensional graphics‚Äù</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚úì Examples of </font></font><a href="https://threejs.org/examples/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">threejs</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚úì Video </font></font><a href="https://youtu.be/n3gtj7veL3I%3Ft%3D6541"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about text rendering in WebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://yadi.sk/i/KpvxK4E3pb4Dg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slides</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚úì Video </font></font><a href="https://www.youtube.com/watch%3Fv%3DgDp7xsof4Ng"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about WebGL performance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://habrahabr.ru/company/oleg-bunin/blog/328526/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><h3>  Contacts: </h3><br> <a href="https://twitter.com/gc_s9k"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://twitter.com/gc_s9k </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s9k0@ya.ru</font></font></a> <br><br><blockquote>  Time flies unnoticed, and quite a bit remains before the <a href="http://ritfest.ru/moscow/2018">RIT ++</a> conference festival, we recall it will take place <strong>on May 28 and 29</strong> in Skolkovo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soon we will publish the program, but for now we are giving a small selection of </font></font><a href="http://frontendconf.ru/moscow-rit/2018/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FrontEnd Conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> applications </font><font style="vertical-align: inherit;">:</font></font><br><br><ul><li> <a href="http://frontendconf.ru/moscow-rit/2018/abstracts/3506"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Shagarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Tutmee Agency). </font><font style="vertical-align: inherit;">Animation on the site - easy sauce or main course?</font></font><br></li><li> <a href="http://frontendconf.ru/moscow-rit/2018/abstracts/3530"> </a> (Coderiver).   <br></li><li> <a href="http://frontendconf.ru/moscow-rit/2018/abstracts/3331"> </a> (Luxoft). Apollo GraphQL.      <br></li></ul><br>  <a href="https://conf.ontico.ru/conference/join/rit2018.html%3Fpopup%3D3">You</a> can still <a href="https://conf.ontico.ru/conference/join/rit2018.html%3Fpopup%3D3">book</a> tickets, but do not forget, the price is steadily increasing. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/354980/">https://habr.com/ru/post/354980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354970/index.html">Splunk Distributed Search. Or how to build an indexer cluster on Splunk?</a></li>
<li><a href="../354972/index.html">Qt News, June 2017 - May 2018</a></li>
<li><a href="../354974/index.html">"Fant" and Okmeter: a symbiosis for the benefit of monitoring</a></li>
<li><a href="../354976/index.html">SmartMailHack. Solution of the 1st place in the problem of logo classification</a></li>
<li><a href="../354978/index.html">CPU Design I (First ver.)</a></li>
<li><a href="../354982/index.html">An open letter to marketers and other PR people involved in content on Habr√© and other resources</a></li>
<li><a href="../354984/index.html">Erlang-like microservices in Clojure application: it‚Äôs just</a></li>
<li><a href="../354986/index.html">Comparison of keyword automatic clustering services for SEO</a></li>
<li><a href="../354988/index.html">The digest of fresh materials from the world of the frontend for the last week No. 313 (April 30 - May 6, 2018)</a></li>
<li><a href="../354990/index.html">Module Nchan web server nginx. Work with Websocket, EventSource (Server-Sent Events), Long-Polling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>