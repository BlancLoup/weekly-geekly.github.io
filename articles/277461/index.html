<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Traits out of the box</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the standard library of the Rust language there are several traits that can be declared "for free" using derive . These traits are sure to come in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Traits out of the box</h1><div class="post__text post__text-html js-mediator-article">  In the standard library of the Rust language there are several traits that can be declared "for free" using <b>derive</b> .  These traits are sure to come in handy when declaring your own structures, they are very often found in various open-source libraries, but their implementation is generated by the compiler and can cause questions. <br>  Often see: <br><br><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(RustcEncodable, RustcDecodable, Clone, Eq, Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { }</code> </pre> <br>  and do not understand what it is and where? <br><a name="habracut"></a><br>  The compiler itself can provide you with simple "embedded" implementations for some traits using <code>#[derive]</code> .  Of course, these same traits can be implemented manually if more complex behavior is required. <br><br>  So, here is an exemplary list of traits that can be ‚Äúextracted‚Äù (derive is translated exactly this way): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> Comparison traits: <a href="http://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a> , <a href="http://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a> , <a href="http://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a> , <a href="http://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a> </li><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> <a href="http://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a> and <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy</a> are the traits responsible for cloning and copying. </li><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> <a href="http://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a> - to calculate the <code>&amp;T</code> hash </li><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> <a href="http://doc.rust-lang.org/std/default/trait.Default.html">Default</a> - allows you to set the "default value" </li><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> - determines the output format of the structure when using the <code>{:?}</code> <a href="http://doc.rust-lang.org/std/fmt/index.html">Formatter</a> </li></ul><br>  In addition, unstable: <br><br><ul><li>  <a href="https://habr.com/ru/post/277461/">[‚Üì]</a> <a href="https://doc.rust-lang.org/std/num/trait.Zero.html">Zero</a> , <a href="https://doc.rust-lang.org/std/num/trait.One.html">One</a> - set the values ‚Äã‚Äãof one and zero for "numeric" structures </li></ul><br>  All of the above traits are in the standard library <code>std</code> .  In addition, you can find self-made libraries, where there are also traits that are extracted using <code>#[derive]</code> .  An example is the commonly used <a href="https://crates.io/crates/rustc-serialize">RustcEncodable / RustcDecodable</a> .  You can implement <code>derive</code> support for your traits with the help of very tricky macros (which most likely will not work in half the cases :)), but this is beyond the scope of our article. <br><br>  Consider the above traits <br><br><a name="cmp"></a><br><h2>  Comparison traits </h2><br>  Allowed to arrange for their structures model of <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D0%25BD%25D0%25BE%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%258D%25D0%25BA%25D0%25B2%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BB%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">equivalence relations</a> .  Subsequently, structures can be compared, organized, structured and organized.  Consider them in more detail. <br><br><h4>  Eq and PartialEq </h4><br>  Two similar traits are responsible for saying <code>foo == bar</code> or not.  But why on such a simple matter two different treit?  And the answer is: <br><br><blockquote>  <code>PartialEq</code> does not guarantee equality with itself: not the fact that a == a </blockquote><br>  How can this be?  For example, the numbers NaN! = NaN <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>::NAN; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>::NAN; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, a == b); }</code> </pre> <br>  <a href="https://play.rust-lang.org/%3Fgist%3Dbeaec1a314b6a217edbd%26amp%3Bversion%3Dstable">returns false</a> <br><br>  Imagine yourself as the creator of a library in which there is some sort of comparison function: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar</span></span></span></span>&lt;T&gt;(param: T) { ... }</code> </pre> <br>  How to choose a limit for <code>T</code> ?  If complete equivalence is fundamental to us, and without it, the function will collapse, we write this: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>&gt;(param: T) { ... }</code> </pre> <br>  but in this case, <code>f32</code> cannot be passed to this function: for example, as we saw earlier, it only supports <code>PartialEq</code> . <br>  If such restrictions are not significant, and the function is stable for any parameters, then the semantics will look like this: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>&gt;(param: T) { ... }</code> </pre> <br>  This function with less restrictions (you can play <a href="https://play.rust-lang.org/%3Fgist%3Deda4c9dc99691aaedd44%26amp%3Bversion%3Dstable">here</a> ) <br><br>  From the fact that <code>Eq</code> is one more limit than <code>PartialEq</code> , and does not differ from it in any way in the ‚Äúless‚Äù limiting direction, the following important conclusion follows: <br><br><blockquote>  All structures that implement <code>Eq</code> must also implement <code>PartialEq</code> </blockquote><br>  That is, the <code>#[derive(Eq)]</code> entry is not valid, if <code>PartialEq</code> is not defined on the structure, it <code>PartialEq</code> <a href="https://play.rust-lang.org/%3Fgist%3Daf539a7fe8258d2c3072%26amp%3Bversion%3Dstable">error!</a> <br><br>  The easiest way to avoid this: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Eq, PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { ... }</code> </pre> <br>  Recall our function <code>fn foo&lt;T: Eq&gt;()</code> from the previous example.  According to the semantics in it, <code>T</code> defined as <code>Eq</code> , but it turns out that it automatically accepts <code>PartialEq</code> structures as well. <br><br>  Another property of <code>Eq</code> and <code>PartialEq</code> is that they cannot be automatically extracted for structures whose at least one element does not implement <code>Eq</code> and <code>PartialEq</code> respectively.  For example: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Eq, PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { bar: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> }</code> </pre> <br>  will give an error, because, as we have already found out, <code>f32</code> does not implement <code>Eq</code> . <br><br>  Similarly, the following code will not work: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> {} <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span> { foo: Foo }</code> </pre> <br>  because our structure <code>Foo</code> does not implement <code>PartialEq</code> (you can play <a href="https://play.rust-lang.org/%3Fgist%3D0da25811757939914487%26amp%3Bversion%3Dstable">here</a> ) <br><br>  However, <strong>this behavior corresponds to all <code>derivable</code> traits</strong> .  This we will see next <br><br>  <strong>Conclusion:</strong> when writing code, it will be reasonable to implement <code>Eq</code> (where possible) or at least <code>PartialEq</code> in all public structures - it will be useful!  And it will save a person who uses your code from sudden compilation errors when he decides to compare a couple of objects, or allows him to include your structure in his own, realizing comparison, without unnecessary tambourines! <br><br><h4>  Ord and PartialOrd </h4><br>  Again two similar traits, but this time they are responsible for ‚Äúmore-less‚Äù.  However, they differ more than <code>Eq</code> and <code>PartialEq</code> : <br><br><blockquote>  PartialOrd <code>PartialOrd</code> adds comparison functions: <strong>&gt;</strong> , <strong>&lt;</strong> , <strong>&gt; =</strong> , <strong>&lt;=</strong> <code>PartialOrd</code> <strong>=</strong> , And implements loose ordering: <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>&lt;Ordering&gt;</code></a> </blockquote><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp::Ordering; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">1.0</span></span>.partial_cmp(&amp;<span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Ordering::Less)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">1.0</span></span>.partial_cmp(&amp;<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Ordering::Equal)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">2.0</span></span>.partial_cmp(&amp;<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Ordering::Greater)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = std::<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::NAN.partial_cmp(&amp;<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result, <span class="hljs-literal"><span class="hljs-literal">None</span></span>);</code> </pre> <br><blockquote>  Trait <code>Ord</code> implements "strict" ordering: <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> </blockquote><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp::Ordering; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>.cmp(&amp;<span class="hljs-number"><span class="hljs-number">10</span></span>), Ordering::Less); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>.cmp(&amp;<span class="hljs-number"><span class="hljs-number">5</span></span>), Ordering::Greater); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>.cmp(&amp;<span class="hljs-number"><span class="hljs-number">5</span></span>), Ordering::Equal);</code> </pre> <br>  If you look at the dependencies of these traits, then everything becomes clear: <br><br><blockquote>  To implement <code>Ord</code> , the structure <strong>must</strong> implement <code>Eq</code> . <br>  To implement <code>PartialOrd</code> , the structure <strong>must</strong> implement <code>PartialEq</code> </blockquote><br>  Indeed, is it possible to say for sure that the value is ‚Äúgreater‚Äù or ‚Äúgreater than or equal to‚Äù relative to the second, if it may turn out that the structure is not equal to itself? <br><br>  Note also that <code>Ord</code> requires a <code>PartialOrd</code> implementation, so all comparison operations for such structures will work guaranteed.  In general, the next is a complete analogy with <code>Eq</code> and <code>PartialEq</code> . <br>  You can play with all this farm <a href="https://play.rust-lang.org/%3Fgist%3D210ad4e3f5ff7e9f0299%26amp%3Bversion%3Dstable">here</a> . <br><br>  <strong>Conclusion</strong> : by analogy with <code>Eq</code> and <code>PartialEq</code> , we try to implement <code>Ord</code> or at least <code>PartialOrd</code> in all structures where it is possible and logical.  Accordingly, structures with <code>Eq</code> will be able to support <code>Ord</code> , structures with <code>PartialEq</code> - <code>PartialOrd</code> . <br><br><a name="copy"></a><br><h2>  Clone and Copy </h2><br>  Even in Russian, the words "cloning" and "copying" are synonyms with a difficult difference.  But in the Rust language - these are different things.  Now with them and we shall understand <br><br><blockquote>  <code>Clone</code> allows you to create <a href="https://doc.rust-lang.org/book/references-and-borrowing.html"><code>T</code> from <code>&amp;T</code></a> using copy. <br>  <code>Copy</code> allows you to copy rather than " <a href="https://doc.rust-lang.org/book/ownership.html">move</a> " the value of a variable during assignment. </blockquote><br>  In short, these traits are generally responsible for different things, they are connected only by the fact that: <br><br><blockquote>  To implement <code>Copy</code> , the structure <strong>must</strong> implement <code>Clone</code> . </blockquote><br>  <code>Clone</code> is essentially a common thing.  It is implemented for almost everything that can be assumed.  Yes, and copying an object by returning a generated copy of an object from the <code>clone()</code> function is not such a big problem, no matter how such an object is stored in memory - we create a new object, bring it to the same form, return it. <br><br>  <code>Copy</code> is another song.  In essence, the ‚Äúcopy‚Äù here is a one-by-one object transfer byte.  And not all structures support this functionality.  For example, if the pointer is ‚Äústupid‚Äù, two pointers will be created, showing the same place, which completely contradicts the ‚Äúsafe‚Äù ideology of Rust.  Or, for example, objects that store some kind of metadata also cannot be copied byte-by-byte. <br><br>  However, <code>Copy</code> makes it easier to deal with the transfer semantics. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar = foo; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"foo is {:?} and bar is {:?}"</span></span>, foo, bar); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Bar; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar = foo; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"foo is {:?} and bar is {:?}"</span></span>, foo, bar); }</code> </pre> <br>  First <code>println!</code>  work, the second - no.  And the difference is in <code>Copy</code> . <br>  You can play with it <a href="https://play.rust-lang.org/%3Fgist%3D92988164babce997e260%26amp%3Bversion%3Dstable">here</a> . <br><br>  <strong>Conclusion</strong> : as advised in the official docks, we implement <code>Copy</code> in general, wherever possible.  And it is impossible, in general, to implement it where <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> is implemented.  Because, in general, if you need to call a destructor for a structure, it means that it is made in such a way that you cannot copy it with a simple memory replica.  <code>Clone</code> does not seem to interfere anywhere. <br><br><a name="easy"></a><br><h2>  Hash, Default and Debug </h2><br>  Treyt <code>Hash</code> is responsible for the possibility of taking hash from the structure.  This is a prerequisite for compiling a <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a> or <a href="http://doc.rust-lang.org/std/collections/struct.HashSet.html">HashSet</a> from such structures. <br><br>  Trait <code>Default</code> is responsible for the initial (default) values ‚Äã‚Äãof the newly created structure.  Structures that implement <code>Default</code> are often required in various data libraries.  Also, the implementation of this trait is useful for structures that characterize the parameters of a system - there are always default parameters, which are too lazy to write every time :) <br><br>  Treyte <code>Debug</code> is responsible for displaying the structure as a text formatted string.  Nowhere is required, except in logging libraries, but it is useful when debugging your own programs. <br><br>  The traits are different on their own, combined them because they <code>derive</code> same way from <code>derive</code> : <br><br><blockquote>  <code>Hash</code> , <code>Default</code> , and <code>Debug</code> can be implemented in those structures, all of whose members support <code>Hash</code> , <code>Default</code> and <code>Debug</code> respectively. </blockquote><br>  And this is not only necessary, but also sufficient.  No unnecessary trouble, treit and anything else.  Play with this farm <a href="https://play.rust-lang.org/%3Fgist%3Ddf3348ae83c368f6b838%26amp%3Bversion%3Dstable">here</a> . <br><br>  <strong>Conclusion</strong> : <code>Hash</code> can be implemented in all public structures - will not be superfluous.  <code>Default</code> and <code>Debug</code> - to your taste, but desirable.  This will help people using your code not to have problems with incorporating your structures into their own.  In short, if it‚Äôs not a pity, we‚Äôre typing <code>#[derive(...)]</code> and pouring everything from the bounty there. <br><br><a name="algebra"></a><br><h2>  One and Zero </h2><br>  As of this writing (Rust 1.6 Stable), these traits are declared unstable.  However, in all likelihood, in the future they will be able to define vector spaces for arbitrary data structures, when used together with the operations of addition ( <a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a> ) and multiplication ( <a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">Mul</a> ).  To implement these traits, your structures must have the following properties: <br><br><blockquote>  For <strong>One</strong> : use in conjunction with <strong>Mul</strong> - <code>x * T::one() == x</code> <br>  For <strong>Zero</strong> : use in conjunction with <strong>Add</strong> - <code>x + T::zero() == x</code> </blockquote><br>  These traits can be declared using a <code>derive</code> , if all members of the structures also support <code>One</code> or <code>Zero</code> . <br><br>  <strong>Conclusion</strong> : if you do not exclude the possibility that your public structures will ever be used in vector spaces, such as participation in all sorts of algebras there, then it makes sense to implement these traits for the structures.  But so far, any mention of these traits causes the compiler to <a href="https://play.rust-lang.org/%3Fgist%3Dbadcc42a1540b07ed316%26amp%3Bversion%3Dstable">only swear</a> ... <br><br><h1>  The most final varning </h1><br>  If a field that does not implement this treit enters a structure that implements a <code>Trait</code> through <code>derive</code> , your code will fall apart.  And if, because of this, you <em>remove the</em> implementation of your treit, then the code will fall apart from people using your structures.  Therefore, the <strong>golden rule</strong> : <br><br><blockquote>  <strong>The more traits, the greater the responsibility.</strong> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/277461/">https://habr.com/ru/post/277461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277451/index.html">Dynamic data binding in HTML and JS</a></li>
<li><a href="../277453/index.html">Neon: Node + Rust</a></li>
<li><a href="../277455/index.html">How is the "compatibility" of financial transactions on rough IT-examples</a></li>
<li><a href="../277457/index.html">We test the layout correctly</a></li>
<li><a href="../277459/index.html">Automating stock purchases: large transaction processing architecture</a></li>
<li><a href="../277463/index.html">Xeon Phi: Why do coprocessors use to create trading applications</a></li>
<li><a href="../277465/index.html">Initialized controllers in symfony and working with annotations</a></li>
<li><a href="../277467/index.html">The new locker "Locky"</a></li>
<li><a href="../277471/index.html">What's new in Windows Server 2016 RDS. Part 2</a></li>
<li><a href="../277473/index.html">Zabbix 3.0: Problem Prediction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>