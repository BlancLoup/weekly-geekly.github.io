<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real Offline Perfect Forward Secrecy for your products</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi% username%! 


 What could be easier than sending an encrypted message to the other party? 

 We take its public key, its private key, we consider ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real Offline Perfect Forward Secrecy for your products</h1><div class="post__text post__text-html js-mediator-article">  Hi% username%! <br><br><img src="https://habrastorage.org/web/9fe/88a/b35/9fe88ab35e334d53922c5ba0b24063b4.jpg"><br>  <i>What could be easier than sending an encrypted message to the other party?</i> <br><br>  We take its public key, its private key, we consider Diffie-Hellman, after the KDF we drive the result into some AES, and it‚Äôs ready.  But, if one of the private keys is stolen, everything, all the traffic intercepted before, will be decrypted without any problems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will tell you how modern instant messengers and transport protocols are struggling with this, as well as give you a tool for implementing PFS in your products. <br><a name="habracut"></a><br>  To understand PFS, the key point is an ephemeral key pair, then for simplicity, the public key of the ephemeral pair I will simply call the <b>ephemeral key</b> .  The ephemeral key pair is generated immediately before the session is established, lives only until the end of the connection setup process ( <b>handshake</b> ) and is destroyed immediately after use.  This achieves the <b>uniqueness of the</b> session symmetric keys used after the handshake.  About how asymmetric keys turn into symmetric, a little later. <br><br>  Immediately there are several questions about the use of ephemeral keys: <br><br><ol><li>  How to trust the ephemeral key? </li><li>  How to transfer your interlocutor ephemeral key? </li></ol><br>  Consider them in more detail. <br><br><h3>  Confidence in the ephemeral key </h3><br>  Aby what key can not be taken, because it is not tied to the interlocutor at the end of the wire.  We have to authenticate the key and can do it in several ways: <br><br><ol><li>  Sign the ephemeral key.  So does TLS. </li><li>  Use multiple Diffie Hellman operations between different keys.  So does the noise protocol. </li><li>  Combined approach (Signal, Whatsapp). </li></ol><br>  In the first case, everything is clear, before connecting, we generate an ephemeral key pair and sign it with a private key, for example, a certificate.  The client makes sure that the key is ‚Äúfrom where it is necessary‚Äù and uses it. <br><br>  In some cases, you can do without a digital signature.  Depending on the specific pattern, the <a href="https://habrahabr.ru/post/334506/">Noise Protocol</a> ‚Äúmixes‚Äù the DH results between the ephemeral and static keys to a common state.  In this way, connectivity between the main static key and the ephemeral key is achieved. <br><br>  Signal developers have gone a little further.  They decided to almost give up digital signatures, replacing them with several DH, which also occur between different static and ephemeral keys.  Only one of the long-lived ephemeral keys is signed, therefore the scheme is called combined.  It looks like this: <br><br><img src="https://habrastorage.org/web/c72/701/0d5/c727010d57c9452eacebdb779e0dcfdb.png"><br><br>  called <a href="https://whispersystems.org/docs/specifications/x3dh/">X3DH</a> . <br><br>  It uses several types of keys: <br><br><ul><li>  <b>IK</b> - Identity keys.  These are permanent static keys that are generated once. </li><li>  <b>EK</b> is an ephemeral key that is generated by the sender before the session begins. </li><li>  <b>SPk</b> is an ephemeral key signed by Identity with an average lifetime of about a week. </li><li>  <b>OPK</b> is a one-time ephemeral key. </li></ul><br>  We also see 4 DH operations, one of which, with a one-time key, is optional. <br>  DH are held between keys of different types, both ephemeral and static.  The combination of different DH allows you to achieve both mutual authentication and protection against the consequences of the theft of the main static (Identity) private keys. <br><br>  Next, let's talk why we need as many as 2 types of ephemeral keys. <br><br><h3>  Delivery of ephemeral keys </h3><br>  The easiest way is to connect online, when we can transfer the ephemeral key directly during the handshake.  TLS, NoiseSocket do just that.  But what if our interlocutor is offline, and you still need to send a message? <br><br>  You can try using the ECIES schema, <br><br><img src="https://habrastorage.org/web/d77/01e/77b/d7701e77b7ec4e9d84f6907a6e977a5e.png"><br><br>  But then PFS is provided only by the sender, since  it generates an ephemeral pair and sends an ephemeral key with each message.  Theft of the recipient's primary private key makes all protection useless. <br><br>  <b>We need a reliable delivery mechanism to senders of ephemeral keys of recipients regardless of their location in the network!</b> <br><br>  You can ask the client to generate, say, a hundred one-time ephemeral keys and put them on the server.  When the interlocutor wants to start a new session, he will ask the server for the client key, he will give him one and immediately delete it. <br><br>  The sender takes this one-time key, generates an ephemeral pair himself, and makes several DHs as indicated in the diagram above. <br><br>  But what if the one-time ephemeral keys run out and the client does not have time to reload new ones?  Here in this extreme case, and there is a <b>second reusable ephemeral key</b> .  It also provides PFS, but only within not one session, but several. <br><br>  Signal and WhatsApp used to do this.  <b>And now anyone can do</b> . <br><br><h2>  Virgil PFS </h2><br>  We liked the idea of ‚Äã‚Äãpreloading one-time keys to the server and it was decided to make for everyone a universal PFS, similar to the one in Signal.  Since we already have Virgil Cards, it was not difficult to do that.  What are the parts of our PFS? <br><br><h4>  Virgil Cards Service </h4><br>  This is our usual card service.  It stores long-term Identity cards. <br><br><h4>  PFS Service </h4><br>  Responsible for storing and issuing one-time and reusable ephemeral cards signed with private keys of Identity cards. <br><br><h4>  PFS Protocol </h4><br>  The above described X3DH + generation of session symmetric keys + generation of keys for encrypting individual messages. <br><br><h4>  Sdk </h4><br>  IOS, Android and C # (+ Xamarin) are supported.  The SDK is responsible for managing the lifecycle of ephemeral keys, sessions, encryption, and decryption of messages.  All SDK compatible with each other. <br><br>  A little more about the protocol, because besides the possibility of receiving one-time keys from the server, this is the main component of information security. <br><br><h3>  Virgil PFS Protocol </h3><br>  It starts with X3DH on the same principle as in Signal.  After performing DH, we destroy the corresponding private ephemeral keys. <br><br><img src="https://habrastorage.org/web/6be/3e5/704/6be3e570413f4ce986eef070c6b93f0f.png"><br><br>  There are two differences. <br><br><ol><li>  Not just bare keys are used, but Virgil Cards </li><li>  All ephemeral keys are signed by private Identity key </li></ol><br>  Relevant Virgil Cards: <br><br><ul><li>  <b>IC</b> - Identity Card.  Main user card or device. </li><li>  <b>OTC</b> - One Time Card.  Disposable ephemeral card. </li><li>  <b>LTC</b> - Long Term Card, reusable ephemeral card. </li><li>  <b>EK</b> - Ephemeral key, which is transmitted in the first message. </li></ul><br>  Signing the user of all their keys is necessary in order not to have to trust the services of Virgil.  After all, we are not engaged in the transmission of messages, only encryption. <br><br><h4>  Session setup </h4><br>  Alice wants to talk to Bob.  Her actions: <br><br><ol><li>  Get a Bob card from Virgil Cards Service Identity, verify the digital signature of the application.  This is done once. </li><li>  Get from the PFS service bandl ephemeral maps.  Either LTC + OTC, or only LTC if there is no OTC. </li><li>  Generate an ephemeral key pair. </li><li>  Calculate all DH according to the scheme above. </li><li>  Turn these DH into a session. </li></ol><br>  After that, Alice sends Bob the first message containing the following data: <br><br><ul><li>  Alice's Identity Card ID </li><li>  Bob's Identity Card ID (Bob may have several Identity Cards) </li><li>  Bob's Long Term Card ID </li><li>  Bob‚Äôs One Time Card ID (if available) </li><li>  Ephemeral key </li><li>  Signature Ephemeral Key </li></ul><br>  Bob, having received this message, gets the corresponding private OTC, LTC, Identity keys and repeats DH according to the scheme above.  Immediately after this, the private OTC key is destroyed. <br><br>  Further, we can not directly use the results of DH, it is not safe.  Therefore, we run them through Key Derivation, namely <a href="https://en.wikipedia.org/wiki/HKDF">HKDF</a> .  This is a special feature that turns some ‚Äúweak key information‚Äù, in this case, DH results, into ‚Äústrong key information‚Äù by using HMAC-Hash. <br><br>  From the first HKDF, we get 4 values, each 32 bytes: <br><br><ol><li>  The secret of the sender is SKa </li><li>  SKb Recipient Secret </li><li>  Session id key </li><li>  Additional data key </li></ol><br>  Then we get the Session ID and Additional Data, running the Session ID key and the Additional data key each again via HKDF.  This is necessary to remove the dependence of key data on additional service data. <br><br>  Thus, any session consists of four values: <br><br>  2 different secrets for sending and receiving messages, a unique session ID and an additional 32 bytes that will participate as Additional data in the <a href="https://ru.wikipedia.org/wiki/AEAD-%25D1%2580%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D0%25B1%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">AEAD</a> encryption scheme with direct encryption of messages. <br><br>  As I said before, Virgil does not handle messaging.  Therefore, we must add the Session ID to each of them so that our SDK will understand what message to decrypt with the key. <br><br>  I called the first two values ‚Äã‚Äãin the session secrets for a reason.  They are not used directly when encrypting messages, but they are also run through HKDF every time.  The message encryption algorithm is as follows: <br><br><ol><li>  We generate 16 random bytes of salt. </li><li>  We get an individual key and nonce to encrypt the message, banishing the corresponding Secret with salt through HKDF. </li><li>  Encrypt the message with the received key, nonce.  As Additional data we transfer value from session. </li><li>  We send Session ID, salt, ciphertext. </li></ol><br>  Thus, each message is encrypted with its unique key. <br><br><h2>  Management of ephemeral keys and sessions </h2><br>  This turned out to be the most difficult moment, since  it was necessary to find a universal option suitable for most potential developers.  In the end, we seem to have succeeded. <br><br>  There were two problems.  The first is what to do with ephemeral cards that were taken but not used.  We do not delete them immediately, but some time after we learned that they are no longer on the server.  This gives a chance to those messages that have not yet arrived but will soon come. <br><br>  The second is updating sessions.  For greater security, there is a need to periodically create new sessions with the same interlocutor and drop old ones.  If the session ‚Äúleaks‚Äù, then the attacker will be able to decipher only a small amount of data.  So that everything happens transparently, we give some time to old sessions before dropping them forever. <br><br><h2>  Code! </h2><br>  We have made great <a href="https://developer.virgilsecurity.com/docs/java/get-started/perfect-forward-secrecy">learning materials</a> to help you master PFS and embed it in your applications. <br><br><img src="https://habrastorage.org/web/c63/20c/6f9/c6320c6f9f294732a841cfb29d6e798a.png"><br><br>  Hope you enjoyed it.  Questions? </div><p>Source: <a href="https://habr.com/ru/post/337356/">https://habr.com/ru/post/337356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337346/index.html">Waiting for 15 years. Nginx Application Server</a></li>
<li><a href="../337348/index.html">RustGo: Rust call from Go with almost zero overhead</a></li>
<li><a href="../337350/index.html">Use Stream API easier (or do not use at all)</a></li>
<li><a href="../337352/index.html">Time off the hook: turning emotions into allies</a></li>
<li><a href="../337354/index.html">5 myths about personal data</a></li>
<li><a href="../337358/index.html">Great collection of free fonts: the best of the best</a></li>
<li><a href="../337362/index.html">How we form teams and build processes for creating digital banking products</a></li>
<li><a href="../337364/index.html">What the hell is python</a></li>
<li><a href="../337366/index.html">How cash software deals with economic misdemeanors</a></li>
<li><a href="../337368/index.html">Data Science: About love, names and more. Part II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>