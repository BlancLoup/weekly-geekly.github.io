<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WASI Standard: Running WebAssembly Outside the Web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="March 27, we in Mozilla announced the start of standardization of WASI, the WebAssembly system interface (WebAssembly system interface). 

 Why: devel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WASI Standard: Running WebAssembly Outside the Web</h1><div class="post__text post__text-html js-mediator-article">  March 27, we in Mozilla announced the start of standardization of WASI, the WebAssembly system interface (WebAssembly system interface). <br><br>  <b>Why:</b> developers started using WebAssembly outside of the browser, because WASM provides a fast, scalable, secure way to run the same code on all machines.  But we do not yet have a solid foundation for such development.  Outside the browser, you need a way to communicate with the system, that is, a system interface.  And the WebAssembly platform does not have it yet. <br><br>  <b>What:</b> WebAssembly is an assembler for a conceptual, not a physical machine.  It works on different architectures, so the system interface is needed for the conceptual OS to work on different operating systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is what WASI is: this is the system interface for the WebAssembly platform. <br><a name="habracut"></a><br>  We strive to create a system interface that will become a true companion for WebAssembly with maximum portability and security. <br><br>  <b>Who:</b> in the framework of the WebAssembly development group, we organized a subgroup that will be engaged in <a href="https://wasi.dev/">WASI</a> standardization.  We have already gathered interested partners and are looking for new ones. <br><br>  Here are some reasons why we, our partners and supporters consider this important: <br><br>  <b>Sean White, Mozilla's R &amp; D director:</b> <br><blockquote>  ‚ÄúWebAssembly is already changing the way new kinds of attractive content are delivered to people. It helps developers and content creators.  Until now, everything worked through browsers, but with WASI the advantages of WebAssembly will get more users and more devices in different places. ‚Äù </blockquote><br>  <b>Tyler McMullen, CTO Fastly:</b> <br><blockquote>  ‚ÄúWe see WebAssembly as a platform for fast and secure code execution on the edge cloud.  Despite the different environments (edge ‚Äã‚Äãand browsers), thanks to WASI, you don‚Äôt have to port the code to each platform. ‚Äù </blockquote><br>  <b>Miles Borins, Technical Director of the Node Steering Committee:</b> <br><blockquote>  ‚ÄúWebAssembly can solve one of Node‚Äôs biggest challenges: how to get close to native speed and reuse code written in other languages, such as C and C ++, while maintaining portability and security.  Standardizing WASI is the first step to this. ‚Äù </blockquote><br>  <b>Laurie Voss, co-founder of npm:</b> <br><blockquote>  ‚ÄúNpm is extremely excited by the potential of WebAssembly for the npm ecosystem, since it makes it much easier to get native code to run in server-side JavaScript applications.  We look forward to the results of this process. ‚Äù </blockquote><br>  So this is a big event! <br><br>  Currently there are three WASI implementations: <br><br><ul><li>  <a href="https://github.com/CraneStation/wasmtime">wasmtime</a> , Mozilla WebAssembly runtime <br></li><li>  <a href="https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime">Lucet</a> , Fastly WebAssembly Runtime <br></li><li>  <a href="https://wasi.dev/polyfill/">polyfill browser</a> </li></ul><br>  WASI demonstration in action: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ggtEJC0Jv8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Next, we will talk about the Mozilla proposal, how this system interface should work. <br><br><h1>  What is a system interface? </h1><br>  Many say that languages ‚Äã‚Äãlike C give direct access to system resources.  But it is not so.  On most systems, these languages ‚Äã‚Äãdo not have direct access to such things as opening or creating files.  Why not? <br><br>  Because these system resources ‚Äî files, memory, and network connections ‚Äî are too important for stability and security. <br><br>  If one program accidentally spoils the resources of another, it may cause a crash.  Worse, if a program (or user) specifically invades other people's resources, it can steal confidential data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/18d/7df/5a518d7df32af2b475047a1fc7c73958.png"><br><br>  Therefore, we need a way to control which programs and users can access resources.  System developers for a long time have come up with a way to provide such control: rings of protection. <br><br>  With OS protection rings, it essentially sets a security barrier around system resources.  This is the core.  Only it can perform operations such as creating a file, opening a file, or opening a network connection. <br><br>  User programs run outside the kernel in what is called user space.  If a program wants to open a file, it must ask the kernel. <br><br> <a href=""><img src="https://habrastorage.org/webt/1x/6e/vi/1x6evigsjy_wlsk1dk5gei1r5ky.png"></a> <br><br>  This is where the concept of a system call arises.  When a program needs to ask the kernel for some operation, it sends a system call.  The kernel checks the accessing user and sees if he has rights to access this file. <br><br>  On most devices, the only way to access system resources is through system calls. <br><br> <a href=""><img src="https://habrastorage.org/webt/td/1s/e7/td1se7jsbqiagsgy6nid_csyick.png"></a> <br><br>  The operating system provides access to system calls.  But if each OS has its own system calls, don't they need to write different versions of the code?  Fortunately, no.  The problem is solved with the help of abstraction. <br><br>  Most languages ‚Äã‚Äãhave a standard library.  When coding, the programmer does not need to know for which system he is writing.  It just uses the interface.  Then, when compiling, your tool chain chooses which interface implementation to use for which system.  This implementation uses functions from the operating system API, so it is specific to it. <br><br>  This is where the concept of a system interface appears.  For example, if you compile <code>printf</code> for a Windows machine, it will use the Windows API.  If compiled for Mac or Linux, it uses POSIX. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cdc/5c0/587cdc5c03ff566a88a9794dc314fa72.png"><br><br>  However, this creates a problem for WebAssembly.  Here we do not know for which OS to optimize the program even at compile time.  Thus, you cannot use the system interface of any single OS within the implementation of the standard library on WebAssembly. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/443/c36/730/443c3673072b36942ff28f1992ad2095.png"></a> <br><br>  I have already said that WebAssembly is an <a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/">assembler for a conceptual machine</a> , not a real machine.  Similarly, WebAssembly needs a system interface for a conceptual, not a real OS. <br><br>  But there are already runtimes that can run WebAssembly outside of the browser, even without this system interface.  How do they do it?  Let's get a look. <br><br><h1>  How does WebAssembly work now outside the browser? </h1><br>  The first tool to generate WebAssembly code was Emscripten.  It emulates a certain OS system interface on the web - POSIX.  This means that a programmer can use functions from the standard C library (libc). <br><br>  For this, Emscripten uses its own libc implementation.  It is divided into two parts: the first is compiled into the WebAssembly module, and the other is implemented in the ‚ÄúJS-glue‚Äù code.  This JS glue sends calls to the browser that talks to the OS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/a59/857/971a59857adc62742dde95b413cc613a.png"><br><br>  The bulk of the early WebAssembly code is compiled with Emscripten.  Therefore, when people began to want to run WebAssembly without a browser, they started to run Emscripten code. <br><br>  So in these rantaymah should create own implementations for all functions which were in the JS-glue code. <br><br>  But there is a problem.  The interface provided by the JS glue code was not designed as a standard or even a public interface.  For example, for a call like <code>read</code> in a normal API, the JS-glue code uses the <code>_system3(which, varargs)</code> call <code>_system3(which, varargs)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/2de/7a8/52e2de7a84456993baeb32b1852c8da5.png"><br><br>  The first parameter <code>which</code> is an integer that always coincides with the number in the name (in our case 3). <br><br>  The second parameter, <code>varargs</code> lists the arguments.  It is called <code>varargs</code> , because we can have a different number of arguments.  But WebAssembly does not allow a variable number of arguments to be passed to the function.  Therefore, they are transmitted through linear memory, which is not safe and slower than through registers. <br><br>  For Emscripten in the browser, this is normal.  But now runtimes see this as a de facto standard, implementing their own versions of JS glue.  They emulate the internal details of the POSIX emulation layer. <br><br>  This means that they re-implement the code (for example, pass arguments as heap values), which made sense given the Emscripten restrictions, but in these runtimes there are no such restrictions. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e31/181/541/e31181541c0b666d54e43d5c10756088.png"></a> <br><br>  If we build the WebAssembly ecosystem for decades to come, it needs a solid foundation, not crutches.  This means that our actual standard cannot be an emulation emulation. <br><br>  But what principles apply in this case? <br><br><h1>  What principles should the WebAssembly system interface follow? </h1><br>  Two fundamental principles of WebAssembly: <br><br><ul><li>  portability <br></li><li>  security </li></ul><br>  We go beyond the browser, but keep these key principles. <br><br>  However, the POSIX approach and the Unix access control system do not give us the desired result.  Let's see what the problem is. <br><br><h3>  Portability </h3><br>  POSIX provides source code portability.  You can compile the same source code with different versions of libc for different computers. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/255/eb7/51f/255eb751f342075453a6a30ea9f5bd98.png"></a> <br><br>  But WebAssembly must go beyond that.  We need to compile once to run on a whole bunch of different systems.  We need portable binaries. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/07e/06d/94c/07e06d94c4aca3ab4f5599c0c9ac3e10.png"></a> <br><br>  This simplifies the distribution of the code. <br><br>  For example, if the native Node modules are written in WebAssembly, then users do not need to run node-gyp when installing applications with native modules, and developers do not need to configure and distribute dozens of binary files. <br><br><h3>  Security </h3><br>  When code asks the operating system to do input or output, the OS must evaluate the security of this operation, usually using an access control system based on ownership and groups. <br><br>  For example, the program asks to open the file.  A user has a specific set of files to which he has access. <br><br>  When a user starts a program, the program starts on behalf of that user.  If the user has access to the file ‚Äî either he is its owner, or belongs to a group that has access to the file ‚Äî then the program has the same access. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d93/8b9/b2a/d938b9b2af13c33b21ab11057331c413.png"></a> <br><br>  This protects users from each other, which made sense in the old days, when many people worked on the same computer, and administrators controlled the software.  Then the main threat was other users looking into your files. <br><br>  Everything has changed.  Currently, systems, as a rule, are single-user, but use third-party code of unknown reliability.  Now the main threat comes from the code that you run yourself. <br><br>  For example, for the library in your application, a new maintainer started (as often happens in open source).  He may be a sincere activist ... or an attacker.  And if it has access to your system ‚Äî for example, the ability to open any file and send it over the network ‚Äî then this code can cause great damage. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/948/478/dc2/948478dc22fbebc0db26d763782be7a0.png"></a> <br>  <i><font color="gray"><b>Suspicious application</b> : I work for user Bob.</font></i>  <i><font color="gray">Can I open his Bitcoin wallet?</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Core</b> : For Bob?</font></i>  <i><font color="gray">Of course!</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Suspicious app</b> : Great!</font></i>  <i><font color="gray">What about the network connection?</font></i> <br><br>  This is why using third-party libraries is dangerous.  In WebAssembly, security is assured otherwise ‚Äî through a sandbox.  Here the code cannot talk directly to the OS.  But how then to address to system resources?  The host (browser or runtime wasm) sandboxes the functions that the code can use. <br><br>  This means that the host programmatically limits the functionality of the program, not allowing you to simply act on behalf of the user, causing any system calls with full user rights. <br><br>  Having a sandbox in and of itself does not make the system safe ‚Äî the host can still transfer full functionality to the sandbox, in which case it does not provide any protection.  But the sandbox gives at least a theoretical opportunity for hosts to build a more secure system. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/68f/bdc/2d7/68fbdc2d7bf44565e5923226bc2a9004.png"></a> <br>  <i><font color="gray"><b>WA</b> : Please, here are some safe toys for interacting with the OS (safe_write, safe_read).</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>Suspicious application</b> : Oh damn ... and where is my network access?</font></i> <br><br>  In any system interface you need to adhere to these two principles.  Portability facilitates the development and distribution of software, and tools to protect the host and users are absolutely essential. <br><br><h1>  What should such a system interface look like? </h1><br>  Given these two key principles, what should the WebAssembly system interface be? <br><br>  This we will find out in the process of standardization.  However, we have a proposal to start: <br><br><ul><li>  Creating a modular set of standard interfaces <br></li><li>  Let's start with the standardization of the main module wasi-core </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/597/a99/2e1597a9959ff7666a3e77db9d63f12d.png"><br><br>  What will happen in wasi-core?  These are the basics needed by all programs.  The module will cover most of the POSIX functionality, including files, network connections, clocks, and random numbers. <br><br>  Much of the basic functionality will require a very similar approach.  For example, a POSIX file-based approach is provided with open, close, read, and write system calls, and the rest is the additions from above. <br><br>  But wasi-core will not cover all POSIX functionality.  For example, the concept of a process does not fit well into a WebAssembly.  In addition, it is clear that each WebAssembly engine must support process operations, such as <code>fork</code> .  But we also want to make <code>fork</code> standardization possible. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9c9/771/11a/9c977111a2def0f6ae4d5b93b1592d91.png"></a> <br><br>  Languages ‚Äã‚Äãlike Rust will use wasi-core directly in their standard libraries.  For example, <code>open</code> from Rust is implemented when compiling into WebAssembly by calling <code>__wasi_path_open</code> . <br><br>  For C and C ++, we created <a href="https://github.com/CraneStation/wasi-sysroot">wasi-sysroot</a> , which implements libc in terms of the wasi-core functions. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/878/2a0/fa2/8782a0fa23e8d4890cb1964c896db84c.png"></a> <br><br>  We expect compilers, such as Clang, to interact with the WASI API, and complete tool chains, such as the Rust compiler and Emscripten, will use WASI as part of their system implementations. <br><br>  How does custom code call these WASI functions? <br><br>  The runtime in which the code is executed transfers the wasi-core function by placing the object in the sandbox. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/371/e44/995/371e44995aa3c88a2c1886ceb27fab19.png"></a> <br><br>  This provides portability, because each host can have its own wasi-core implementation specifically for its platform: from WebAssembly runtimes, such as Mozilla Wasmtime and Fastly Lucet, to Node or even a browser. <br><br>  It also provides reliable isolation, because the software-based host selects which functions of the wasi-core to sandbox, that is, which system calls to allow it.  This is safety. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e0a/3a6/28b/e0a3a628b861e321db36d64a647bdfd7.png"></a> <br><br>  WASI allows you to enhance and expand security by introducing a power-based protection concept into the system. <br><br>  Usually, if the code needs to open a file, it calls <code>open</code> with the path name in the string.  The OS then checks if the code has the right to such an action (based on the rights of the user running the program). <br><br>  In the case of WASI, when calling a function to access a file, you must pass a file descriptor to which permissions are attached for the file itself or for the directory containing the file. <br><br>  Thus, you cannot have code that accidentally asks you to open <code>/etc/passwd</code> .  Instead, the code can only work with its directories. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/92f/b27/cb0/92fb27cb09092b74fd1ba46d661867c4.png"></a> <br><br>  This allows you to safely allow different system calls to isolated code, since the capabilities of these system calls are limited. <br><br>  And so in every module.  By default, the module does not have access to file descriptors.  But if the code in one module has a file descriptor, it can transfer it to functions called in other modules.  Or create more limited versions of the file descriptor for transfer to other functions. <br><br>  Thus, the runtime passes file descriptors that an application can use in top-level code, and then file descriptors are distributed to the rest of the system as needed. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d80/cb2/f63/d80cb2f63dd1cfa855fc096f36e96ba1.png"></a> <br><br>  This brings WebAssembly closer to the principle of least privilege, where the module gets access only to the minimum set of resources needed to perform its work. <br><br>  This concept comes from authority-based security, as in CloudABI and Capsicum.  One of the problems of these systems is difficult code portability.  But we believe that this problem can be solved. <br><br>  If the code is already using <code>openat</code> with relative file paths, compiling the code will simply work. <br><br>  If the code uses <code>open</code> and the openat-style migration is too sharp, WASI will provide an incremental solution.  With <a href="https://github.com/musec/libpreopen">libpreopen,</a> you create a list of file paths to which the application has legitimate access.  Then use <code>open</code> , but only with these paths. <br><br><h1>  What's next? </h1><br>  We believe that wasi-core is a good start.  It preserves the portability and security of WebAssembly, providing a solid foundation for an ecosystem. <br><br>  But after the full standardization of the wasi-core, other issues need to be resolved, including: <br><br><ul><li>  asynchronous I / O <br></li><li>  file monitoring <br></li><li>  file lock </li></ul><br>  This is just the beginning, so if you have ideas, get <a href="https://wasi.dev/">involved</a> ! </div><p>Source: <a href="https://habr.com/ru/post/446764/">https://habr.com/ru/post/446764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446752/index.html">Tracing Services, OpenTracing and Jaeger</a></li>
<li><a href="../446754/index.html">Cloudy future</a></li>
<li><a href="../446756/index.html">VR Weapons - [RAILGUN TUTORIAL]</a></li>
<li><a href="../446760/index.html">Top 3D Expo 2019 Topics: 3D Metal Printing, Anton Sotov, Samara University</a></li>
<li><a href="../446762/index.html">6. Check Point Getting Started R80.20. Getting Started in SmartConsole</a></li>
<li><a href="../446768/index.html">Nominative typing in TypeScript or how to protect your interface from foreign identifiers</a></li>
<li><a href="../446770/index.html">12 JavaScript tricks that aren't found in most tutorials</a></li>
<li><a href="../446772/index.html">Do not open ports in the world - you will be broken (risks)</a></li>
<li><a href="../446774/index.html">Low poly characters design</a></li>
<li><a href="../446776/index.html">Proof-of-work effective</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>