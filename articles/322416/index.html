<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Choosing the right error handling strategy (parts 1 and 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are two fundamental strategies: correctable error handling (exceptions, error return codes, handler functions) and uncorrectable ( assert() , ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Choosing the right error handling strategy (parts 1 and 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/3ac/3b5/6ab/3ac3b56ab05e46a08faef35c713d4962.jpg"><br><br>  There are two fundamental strategies: correctable error handling (exceptions, error return codes, handler functions) and uncorrectable ( <code>assert()</code> , <code>abort()</code> ).  In which cases which strategy is better to use? <br><a name="habracut"></a><br><h2>  Types of errors </h2><br>  Errors occur for various reasons: the user has entered strange data, the OS cannot give you a file handler, or the code dereferences <code>nullptr</code> .  Each of the described errors requires a separate approach to itself.  For reasons of error, are divided into three main categories: <br><br><ul><li>  <b>User errors:</b> here, the user is the person sitting in front of the computer and really ‚Äúusing‚Äù the program, and not some programmer who is tugging at your API.  Such errors occur when the user does something wrong. </li><li>  <b>System errors</b> appear when the OS cannot complete your request.  In other words, the cause of system errors is the failure of the system API call.  Some arise because the programmer passed bad parameters to the system call, so this is a programmer error rather than a system error. </li><li>  <b>Programmer errors</b> occur when the programmer does not take into account the prerequisites of the API or programming language.  If the API requires you not to call <code>foo()</code> with <code>0</code> as the first parameter, and you did it, the programmer is to blame.  If the user entered <code>0</code> , which was passed to <code>foo()</code> , and the programmer did not write the input data check, then this is also his fault. </li></ul><br>  Each of the described categories of errors requires a special approach to their processing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  User errors </h2><br>  I will make a very loud statement: such errors are not really errors. <br><br>  All users do not comply with the instructions.  A programmer dealing with data entered by people should expect that it is bad data that will be entered.  Therefore, the first thing you need to check them for validity, to inform the user about the detected errors and ask to enter again. <br><br>  Therefore, it does not make sense to apply any processing strategies to user errors.  Input data should be checked as soon as possible so that errors do not occur. <br><br>  Of course, this is not always possible.  Sometimes it is too expensive to check the input data, sometimes it does not allow the code architecture or the division of responsibility.  But in such cases, errors should be treated unambiguously as correctable.  Otherwise, for example, your office program will fall due to the fact that you have pressed the backspace in a blank document, or your game will begin to crash when you try to shoot from a discharged weapon. <br><br>  If you prefer exceptions as a strategy for handling correctable errors, then be careful: exceptions are only for <b>exceptions</b> , which do not include most of the cases when users enter incorrect data.  In fact, it is even the norm, according to many applications.  Use exceptions only when user errors are detected in the depth of the call stack, probably of an external code, when they occur rarely or appear very hard.  Otherwise, it is better to report errors using return codes. <br><br><h2>  System errors </h2><br>  Normally, system errors cannot be predicted.  Moreover, they are non-deterministic and can occur in programs that have previously worked without complaints.  Unlike user errors, which depend solely on the input data, system errors are real errors. <br><br>  But how to handle them as fixable or uncorrectable? <br><br>  It depends on the circumstances. <br><br>  Many people think that a low memory error is unrecoverable.  Often there is not enough memory even to handle this error!  And then you just have to immediately interrupt the execution. <br><br>  But the crash of the program due to the fact that the OS cannot allocate a socket is not very friendly behavior.  So it is better to throw an exception and let <code>catch</code> gently close the program. <br><br>  But throwing an exception is not always the right choice. <br><br>  Someone will even say that it is <b>always</b> wrong. <br><br>  If you want to repeat the operation after it fails, then wrapping a function in a <code>try-catch</code> in a loop is a <b>slow</b> solution.  The correct choice is to return the error code and loop through until the correct value is returned. <br><br>  If you create an API call only for yourself, then simply choose the appropriate path for your situation and follow it.  But if you are writing a library, you do not know what the users want.  Next we analyze the appropriate strategy for this case.  For potentially unrecoverable errors, an ‚Äúerror handler‚Äù is suitable, and for other errors, you must provide two options for the development of events. <br><br>  Please note that you should not use confirmations (assertions) that turn on only in debug mode.  After all, system errors can occur in the release assembly! <br><br><h2>  Programmer bugs </h2><br>  This is the worst kind of mistakes.  To handle them, I try to make my mistakes only related to function calls, that is, with bad parameters.  Other types of programmer errors can only be caught in runtime using debugging macros (assertion macros) scattered around the code. <br><br>  When working with bad parameters there are two strategies: to give them certain or indefinite behavior. <br><br>  If the initial requirement for the function is to prohibit the transfer of bad parameters to it, then if they are transferred, this is considered to be undefined behavior and should be checked not by the function itself, but by the caller.  The function should only do debug assertion. <br><br>  On the other hand, if the absence of bad parameters is not part of the initial requirements, and the documentation determines that the function will throw a <code>bad_parameter_exception</code> when passing a bad parameter to it, then the transfer is a well-defined behavior (throwing an exception or any other <b>correctable</b> error handling strategy) and function should always check it out. <br><br>  As an example, consider the receiving functions (accessor functions) <code><code>std::vector&lt;T&gt;</code></code> : the specification for <code>operator[]</code> says that the index must be within the valid range, and <code>at()</code> tells us that the function will throw an exception if the index does not fall into the range.  Moreover, most implementations of standard libraries provide a debug mode in which the <code>operator[]</code> index is checked, but technically this is an undefined behavior; it is not required to be checked. <br><br>  Note: it is not necessary to throw an exception to get a certain behavior.  As long as it is not mentioned in the initial conditions for the function, it is considered definite.  Everything that is written in the initial conditions should not be checked by a function, this is an undefined behavior. <br><br>  When it is necessary to check only with the help of debugging confirmations, and when - constantly? <br><br>  Unfortunately, there is no definite recipe, the decision depends on the specific situation.  I have only one proven rule that I follow when developing an API.  It is based on the observation that the caller, not the callee, should check the initial conditions.  So, the condition must be ‚Äúverifiable‚Äù for the caller.  Also, the condition "verifiable", if you can easily perform an operation in which the parameter value will always be correct.  If this is possible for a parameter, then the initial condition is obtained, which means that it is checked only by means of debug confirmation (and if it is too expensive, then it is not checked at all). <br><br>  But the final decision depends on many other factors, so it‚Äôs very difficult to give some general advice.  By default, I try to reduce to indefinite behavior and using only confirmations.  Sometimes it is advisable to provide both options, as the standard library does with <code>operator[]</code> and <code>at()</code> . <br><br>  Although in some cases this may be a mistake. <br><br><h2>  About <code>std::exception</code> hierarchy </h2><br>  If you chose exceptions as the strategy for handling correctable errors, it is recommended to create a new class and inherit it from one of the standard library exception classes. <br><br>  I propose to inherit from only one of these four classes: <br><br><ul><li>  <code>std::bad_alloc</code> : for memory allocation failures. </li><li>  <code>std::runtime_error</code> : for common runtime errors. </li><li>  <code>std::system_error</code> (derived from <code>std::runtime_error</code> ): for system errors with error codes. </li><li>  <code>std::logic_error</code> : for programmer errors with a specific behavior. </li></ul><br>  Note that the standard library separates logical (that is, programmer) and runtime errors.  Runtime errors are a broader definition than ‚Äúsystem‚Äù ones.  It describes "errors that are detected only during program execution."  This wording is not very informative.  Personally, I use it for bad parameters, which are not exclusively programmer errors, but may arise from users.  But this can only be determined deep in the call stack.  For example, poor formatting of comments in <a href="https://github.com/foonathan/standardese">standardese</a> results in an exception during parsing, resulting from <code>std::runtime_error</code> .  Later it is caught at the appropriate level and recorded in the log.  But I would not use this class other than <code>std::logic_error</code> . <br><br><h2>  Let's sum up </h2><br>  There are two ways to handle errors: <br><br><ul><li>  as <b>correctable</b> : exceptions or return values ‚Äã‚Äãare used (depending on the situation / religion); </li><li>  as <b>unrecoverable</b> : errors are logged and the program is terminated. </li></ul><br>  Confirmations are a special kind of strategy for handling uncorrectable errors, only in debug mode. <br><br>  There are three main sources of error, each requires a special approach: <br><br><ul><li>  <b>User errors</b> should not be treated as errors at the top levels of the program.  Everything a user enters must be checked accordingly.  This can be treated as errors only at lower levels, which do not interact with users directly.  Corrective error handling strategy is applied. </li><li>  <b>System errors</b> can be handled as part of either of the two strategies, depending on the type and severity.  Libraries should work as flexibly as possible. </li><li>  <b>Programmer errors</b> , i.e. bad parameters, can be prohibited by initial conditions.  In this case, the function should only use verification with debug confirmations.  If we are talking about a fully defined behavior, then the function should be reported in an prescribed way about the error.  I try to follow the default scenario with undefined behavior and define the function to check the parameters only when it is too difficult to do on the side of the caller. </li></ul><br><h2>  Flexible error handling techniques in C ++ </h2><br>  Sometimes something does not work.  Users enter data in an invalid format, the file is not detected, the network connection fails, the system runs out of memory.  All these are errors, and they need to be processed. <br><br>  This is relatively easy to do in high-level functions.  You know exactly <b>why</b> something went wrong, and you can handle it accordingly.  But in the case of low-level functions, things are not so simple.  They do not know <b>what</b> went wrong, they know only about the <b>fact of the</b> failure and must report it to the one who caused them. <br><br>  In C ++, there are two main approaches: error return codes and exceptions.  Today, the use of exceptions is widespread.  But some cannot / think that they cannot / do not want to use them - for various reasons. <br><br>  I will not take sides.  Instead, I will describe techniques that will satisfy the proponents of both approaches.  Especially techniques useful to developers of libraries. <br><br><h2>  Problem </h2><br>  I am working on a <a href="https://github.com/foonathan/memory">foonathan / memory</a> project.  This solution provides various classes of memory allocation (allocator classes), so as an example, consider the structure of the allocation function. <br><br>  For simplicity, take <code>malloc()</code> .  It returns a pointer to the allocated memory.  If memory allocation fails, then <code>nullptr</code> returned, that is, <code>NULL</code> , that is, an erroneous value. <br><br>  There are drawbacks to this solution: you need to check <b>every</b> <code>malloc()</code> call.  If you forget to do this, then allocate a non-existent memory.  In addition, by its nature, error codes are transitive: if you call a function that can return an error code, and you cannot ignore it or process it, then you must also return an error code. <br><br>  This leads us to a situation where normal and erroneous code branches alternate.  Exceptions in this case look more appropriate solution.  Thanks to them, you will be able to handle errors only when you need it, and otherwise - rather quietly send them back to the caller. <br><br>  This can be regarded as a disadvantage. <br><br>  But in such situations, exceptions also have a very big advantage: the memory allocation function either returns valid memory or returns nothing at all.  This is an ‚Äúall or nothing‚Äù function, the return value will always be valid.  This is a useful consequence of Scott Meier‚Äôs ‚Äú <a href="http://programmer.97things.oreilly.com/wiki/index.php/Make_Interfaces_Easy_to_Use_Correctly_and_Hard_to_Use_Incorrectly">Make interfaces hard to use correctly</a> ‚Äù <a href="http://programmer.97things.oreilly.com/wiki/index.php/Make_Interfaces_Easy_to_Use_Correctly_and_Hard_to_Use_Incorrectly">principle</a> . <br><br>  Given the above, it can be argued that you should use exceptions as an error handling mechanism.  This opinion is shared by most C ++ developers, including me.  But the project that I do is a library that provides memory allocators, and it is intended for real-time applications.  For most developers of such applications (especially for igrodelov) the use of exceptions is the exception. <br><br>  Pun Detected <br><br>  To respect this development team, my library is better off without exceptions.  But I and many others like them for the elegance and simplicity of error handling, so for the sake of other developers my library is better to use exceptions. <br><br>  So what to do? <br><br>  The ideal solution: the ability to enable and disable exceptions as desired.  But, taking into account the nature of the exceptions, one cannot simply change them in places with error codes, since we will not have an internal error check code - the entire internal code is based on the assumption of the transparency of exceptions.  And even if inside we could use error codes and convert them into exceptions, this would deprive us of most of the advantages of the latter. <br><br>  Fortunately, I can determine what you are doing when you discover a memory shortage error: most often you log this event and interrupt the program, since it cannot work correctly without memory.  In such situations, exceptions are simply a way to transfer control to another part of the code that logs and interrupts the program.  But there is an old and effective way to transfer control: a function pointer (function pointer), that is, a handler function. <br><br>  If you have exceptions enabled, you just throw them.  Otherwise, call the handler function and then abort the program.  This will prevent the use of the handler function, which will allow the program to continue to run as usual.  If not interrupted, a violation of the required postcondition of the function will occur: always return a valid pointer.  After all, the execution of this condition can be used to build the work of another code, and indeed this is normal behavior. <br><br>  I call this approach exception handling and stick with it when working with memory. <br><br><h2>  Solution 1: Exception Handler </h2><br>  If you need to handle an error in an environment where the most common behavior is to ‚Äúlog and terminate,‚Äù you can use an exception handler.  This is a handler function that is called instead of throwing an exception object.  It is fairly easy to implement even in already existing code.  To do this, put the processing control in the exception class and wrap the <code>throw</code> expression in the macro. <br><br>  First, we supplement the class and add functions for setting up and, possibly, requesting a handler function.  I suggest doing it the same way the standard library handles <code>std::new_handler</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_fatal_error</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//  ,      ,   , //       using handler = void(*)( ... ); //  - handler set_handler(handler h); //    handler get_handler(); ... //   };</span></span></code> </pre> <br>  Since this is within the scope of the exception class, you do not need to name it in any special way.  Great, it's easier for us. <br><br>  If exceptions are included, conditional compilation can be used to remove the handler.  If you want, also write the usual mixed class (mixin class), giving the required functionality. <br><br>  The exception constructor is elegant: it calls the current handler function, passing it the required arguments from its parameters.  And then combines with the subsequent <code>throw</code> macro: <br><br><pre> <code class="cpp hljs">If```cpp <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXCEPTIONS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THROW(Ex) throw (Ex) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THROW(Ex) (Ex), std::abort() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs">&gt;   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>   [foonathan/compatiblity](https:<span class="hljs-comment"><span class="hljs-comment">//github.com/foonathan/compatibility).     : ```cpp THROW(my_fatal_error(...))</span></span></code> </pre> <br>  If you have support for exceptions, an exception object will be created and thrown, as usual.  But if support is turned off, an exception object will still be created, and - this is important - only after that the call to <code>std::abort()</code> will occur.  And since the constructor calls the handler function, it works as it should: you get a configuration point for error logging.  Thanks to calling <code>std::abort()</code> after the constructor, the user cannot break the postcondition. <br><br>  When I work with memory, with exceptions enabled, I also have a handler enabled, which is called when an exception is thrown. <br><br>  So with this technique you will still have a certain degree of customization available, even if you turn off exceptions. ,  ,       ,   .    ,      ,    . <br><br><h2>         ? </h2><br>             .     ? <br><br>   ‚Äî .   ,      ,    .        ,      . <br>    :   .    ,    . ,   ,    ,  ‚Äî . <br><br> ,     ,          . <br><br>       .       : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(..., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;error_code)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>;</code> </pre> <br>        <code>nullptr</code>   <code>error_code</code>   .     <code>nullptr</code> ,   .  ,         : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> error_code = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = try_malloc(..., error_code); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> malloc_error(error_code); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>      ,     ,   .           .  ,  ,       (overload)    . <br><br>        ,       . ,       ,    .           ,   . <br><br><h2>  2:    </h2><br>    ,     .    ,    . <br><br>       ,       .             ‚Äî  <code>nullptr</code>   , ‚Äî        ,      . <br><br> <b></b> ,     <code>errno</code>  -  <code>GetLastError()</code> ! <br><br>          ,      <code>std::optional</code>  - . <br><br>   (exception overload)  ‚Äî   ‚Äî        ,    .    ,      . <br><br><h2> <code>std::system_error</code> </h2> <br>           ++ 11. <br><br>    (non-portable)   <code>std::error_code</code> ,      .               ,   <code>std::error_condition</code> .      <a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html"></a> .  ,        <code>std::error_code</code> .        : <code>std::system_error</code> .   <code>std::error_code</code>         . <br><br>         ,    -.   ‚Äî    ‚Äî    ,   . <br><br> ,          .        . <br><br><h2> <code>std::expected</code> </h2> <br>    ,      ,   ,       .  ,   ‚Äî      . <br><br>      ! <br><br>  <a href="http://wg21.link/n4109">‚Ññ 4109</a>  : <code>std::expected</code> .   ,        .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt; try_malloc(...);</code> </pre> <br>    <code>std::expected</code>   -null  ,    ‚Äî <code>std::error_code</code> .        .  <code>std::expected</code>        . <br><br><h2>  Conclusion </h2><br>    ,       .        :    ,  ‚Äî . <br><br>     ‚Äî       .  ,   ,   callback,    .     ,          .      ,          .        . <br><br>    ‚Äî    ,   ,   .     ,     ,      .   :       . </div><p>Source: <a href="https://habr.com/ru/post/322416/">https://habr.com/ru/post/322416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322402/index.html">Cisco Spark Cloud Collaboration Solution: Overview and Configuration</a></li>
<li><a href="../322404/index.html">Training with reinforcements: from Pavlova to slot machines</a></li>
<li><a href="../322406/index.html">Asynchronous alternative for Kotlin in the face of Vert.x</a></li>
<li><a href="../322408/index.html">How IT professionals work. Semen Bagreev, Rambler Digital Solutions, Python / Ruby Development Manager</a></li>
<li><a href="../322414/index.html">Will data scientists soon be replaced by automated algorithms and artificial intelligence?</a></li>
<li><a href="../322418/index.html">The horror story about coding standards</a></li>
<li><a href="../322420/index.html">3 steps to an interactive prototype</a></li>
<li><a href="../322422/index.html">One possible problem when working with RS232</a></li>
<li><a href="../322424/index.html">A series of video tutorials on Git for beginners</a></li>
<li><a href="../322426/index.html">How to bring a business online and do not go broke: digest of useful materials for beginners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>