<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Easy to use wrapper over LoadLibrary () and GetProcAddress ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preamble 
 The use of dynamically linked libraries (DLLs) is known to imply one of two ways to connect: load-time linking and run-time linking . In th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Easy to use wrapper over LoadLibrary () and GetProcAddress ()</h1><div class="post__text post__text-html js-mediator-article"><h4>  Preamble </h4><br>  The use of dynamically linked libraries (DLLs) is known to imply one of two ways to connect: <i>load-time linking</i> and <i>run-time linking</i> .  In the latter case, you need to use the API provided by the operating system to load the required module (library) and search for the address of the required procedure in it.  There are many wrappers, but, unfortunately, all I have encountered are very complicated and overloaded with excess code.  The proposed solution was originally intended to call functions stored in a DLL from executable modules (EXE), it is characterized by relative ease of implementation, and (more importantly) ease of use in client code. <br><a name="habracut"></a><br>  The solution using the pure Win32 API looks like this (pratic, this is a repetition of a fragment from MSDN): <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">some_proc_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPWSTR)</span></span></span></span>; HINSTANCE hlib = LoadLibrary(_T(<span class="hljs-string"><span class="hljs-string">"some.dll"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">myproc_t</span></span> proc_addr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hlib) { proc_addr = (<span class="hljs-keyword"><span class="hljs-keyword">some_proc_t</span></span>) GetProcAddress(hlib, <span class="hljs-string"><span class="hljs-string">"SomeProcName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (proc_addr) { result = proc_addr(<span class="hljs-string"><span class="hljs-string">L"send some string to DLL function"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Successfully called DLL procedure with result %d"</span></span>, result); } FreeLibrary(<span class="hljs-string"><span class="hljs-string">"some.dll"</span></span>); }</code> </pre> <br>  This article offers an easy-to-use wrapper over these system calls.  Usage example: <br><br><pre> <code class="hljs cpp">ntprocedure&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(LPWSTR)&gt; some_proc_(<span class="hljs-string"><span class="hljs-string">"SomeProcName"</span></span>, _T(<span class="hljs-string"><span class="hljs-string">"some.dll"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = some_proc_(<span class="hljs-string"><span class="hljs-string">L"send some string to DLL function"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Successfully called DLL procedure with result %d"</span></span>, result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Failed to call DLL procedure"</span></span>); }</code> </pre><br>  As you can see from the listing, all that needs to be done is to create an <b>ntprocedure</b> object with template parameters that correspond to the type of the function being called, passing in the constructor its name and the library name. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Implementation </h4><br>  Before proceeding to the description of the implementation of the wrapper, I‚Äôll give a small header file with trivial declarations that many will find useless, which is easy to get rid of, but are used by me in the code. <br><br><div class="spoiler">  <b class="spoiler_title">File common.h</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> once <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"tchar.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;string&gt; <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NS_BEGIN_</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>) namespace <span class="hljs-type"><span class="hljs-type">A</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NS_BEGIN_A_</span></span> namespace { <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NS_END_</span></span> } <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">NO_EXCEPT_</span></span> throw() <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">THROW_</span></span>(<span class="hljs-type"><span class="hljs-type">E</span></span>) throw(<span class="hljs-type"><span class="hljs-type">E</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">PROHIBITED_</span></span> = delete //============================================================================= typedef std::basic_string&lt; <span class="hljs-type"><span class="hljs-type">TCHAR</span></span>, std::char_traits&lt;<span class="hljs-type"><span class="hljs-type">TCHAR</span></span>&gt;, std::allocator&lt;<span class="hljs-type"><span class="hljs-type">TCHAR</span></span>&gt; &gt; tstring;</code> </pre><br></div></div><br>  We will think about how to ensure that the template class being developed behaves as a function at the calling point and can support an arbitrary number and type of arguments.  The first thing that comes to mind is to use a generalized functor.  The authors of the implementations of such wrappers known to me do just that.  It uses either a partial specialization of the functor pattern depending on the number of arguments, or multiple overloading of the function call operator.  The case is usually not complete without the help of macros.  Fortunately, in C ++ 11, templates with a variable number of arguments appeared that greatly simplify life: <br><br><pre> <code class="hljs lisp">R operator () (<span class="hljs-name"><span class="hljs-name">Args</span></span> ... args)</code> </pre><br>  In fact, in our case, you can do much easier, namely, use the cast operator instead of the function call operator.  If <b>T</b> is a type of function pointer, and <b>address</b> is a variable that stores its address, you can define the following statement: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T&gt;(address); }</code> </pre><br>  Below is the complete code for the header file "ntprocedure.h". <br><br><div class="spoiler">  <b class="spoiler_title">Ntprocedure.h file</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">#pragma once #include <span class="hljs-string"><span class="hljs-string">"common.h"</span></span> #include &lt;memory&gt; #include &lt;string&gt; #include &lt;type_traits&gt; NS_BEGIN_(ntutils) NS_BEGIN_(detail) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ntmodule</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ntprocedure_base</span></span></span><span class="hljs-class"> </span></span>{ ntprocedure_base(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ntprocedure_base&amp;) PROHIBITED_; void <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ntprocedure_base&amp;) PROHIBITED_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ntprocedure_base(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; a_proc_name, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tstring&amp; a_lib_name); <span class="hljs-comment"><span class="hljs-comment">// Constructor. virtual ~ntprocedure_base() = 0; // Destructor. FARPROC WINAPI address(); // Get the procedure address. const std::string&amp; name() const; // Get the procedure name. private: std::string m_name; std::shared_ptr&lt;ntmodule&gt; m_module; }; NS_END_ template&lt;typename T&gt; class ntprocedure : public detail::ntprocedure_base { public: typedef typename std::remove_pointer&lt;T&gt;::type callable_t; typedef callable_t *callable_ptr_t; ntprocedure(const std::string&amp; a_proc_name, const tstring&amp; a_lib_name) : ntprocedure_base(a_proc_name, a_lib_name), m_function(nullptr) { } // Constructor. virtual ~ntprocedure() { } // Destructor. operator callable_ptr_t() { if (!m_function) { m_function = reinterpret_cast&lt;callable_ptr_t&gt;(address()); } return m_function; } // Return stored function to invoke. private: callable_ptr_t m_function; }; NS_END_</span></span></code> </pre><br></div></div><br>  A couple of points that the attentive reader noticed - the address of the procedure is stored in the <b>m_function</b> variable and is calculated once, and the second point is that a shared pointer to an object of the <b>ntmodule</b> class is stored in the base class.  It is not difficult to guess that it stores information about the loaded module.  Using <b>shared_ptr</b> allows you to automatically unload a module after destroying all the procedure objects that use it. <br><br><div class="spoiler">  <b class="spoiler_title">Ntmodule.h file</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">#pragma once #include <span class="hljs-string"><span class="hljs-string">"common.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"resource_ptr.h"</span></span> #include &lt;list&gt; #include &lt;memory&gt; NS_BEGIN_(ntutils) NS_BEGIN_(detail) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ntmodule</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public std::enable_shared_from_this</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ntmodule</span></span></span><span class="hljs-class">&gt; </span></span>{ ntmodule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ntmodule&amp;) PROHIBITED_; void <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ntmodule&amp;) PROHIBITED_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: typedef std::list&lt;ntmodule*&gt; container_t; ntmodule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tstring&amp; a_name); <span class="hljs-comment"><span class="hljs-comment">// Constructor. ~ntmodule(); // Destructor. const tstring&amp; name() const; // Get the module name. FARPROC WINAPI address(const std::string&amp; a_name); // Get the procedure address. std::shared_ptr&lt;ntmodule&gt; share(); // Share this object. static container_t&amp; cached(); // Return the reference to the cache. private: tstring m_name; hmodule_ptr m_handle; }; NS_END_ NS_END_</span></span></code> </pre><br></div></div><br>  Consider the definition of the class ntmodule: <br><br><div class="spoiler">  <b class="spoiler_title">Ntmodule.cpp file</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"ntmodule.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"ntprocedure.h"</span></span> #include &lt;cassert&gt; #include &lt;exception&gt; ntutils::detail::ntmodule::ntmodule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tstring&amp; a_name) : m_name(a_name) { assert(!a_name.empty()); cached().push_back(this); } ntutils::detail::ntmodule::~ntmodule() { cached().remove(this); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tstring&amp; ntutils::detail::ntmodule::name() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name; } FARPROC WINAPI ntutils::detail::ntmodule::address( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; a_name ) { assert(!a_name.empty()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_handle) { m_handle.reset(::LoadLibrary(m_name.c_str())); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_handle) { std::string err(<span class="hljs-string"><span class="hljs-string">"LoadLibrary failed"</span></span>); throw std::runtime_error(err); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handle ? ::GetProcAddress(m_handle, a_name.c_str()) : <span class="hljs-number"><span class="hljs-number">0</span></span>; } std::shared_ptr&lt;ntutils::detail::ntmodule&gt; ntutils::detail::ntmodule::share() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shared_from_this(); } ntutils::detail::ntmodule::container_t&amp; ntutils::detail::ntmodule::cached() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> container_t* modules = new container_t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *modules; }</code> </pre><br></div></div><br>  As you can see, pointers to all used modules are stored in a static list.  This provides caching.  The constructor of the <b>ntmodule</b> class places a pointer to its object in the list, and the destructor deletes it.  Completely clarify the picture definition class ntprocedure. <br><br><div class="spoiler">  <b class="spoiler_title">Ntprocedure.cpp file</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"stdafx.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"ntmodule.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"ntprocedure.h"</span></span> #include &lt;cassert&gt; #include &lt;exception&gt; ntutils::detail::ntprocedure_base::ntprocedure_base( const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; a_proc_name, const tstring&amp; a_lib_name ) : m_name(a_proc_name), m_module(nullptr) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(!a_proc_name.empty()); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(!a_lib_name.empty()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto module : ntmodule::cached()) { // Perform case insensitive comparison: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lstrcmpi(module-&gt;name().c_str(), a_lib_name.c_str())) { m_module = module-&gt;share(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_module) { m_module = std::make_shared&lt;ntmodule&gt;(a_lib_name); } } ntutils::detail::ntprocedure_base::~ntprocedure_base() { } FARPROC WINAPI ntutils::detail::ntprocedure_base::address() { FARPROC addr = m_module-&gt;address(m_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addr) { std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> err(<span class="hljs-string"><span class="hljs-string">"GetProcAddress failed"</span></span>); throw std::runtime_error(err); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addr; } const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; ntutils::detail::ntprocedure_base::name() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name; }</code> </pre><br></div></div><br>  In the <b>ntprocedure_base</b> constructor, the <b>module</b> is searched for in the static list by its name.  If such a module is found, then calling module-&gt; <i>share ()</i> creates a shared pointer based on the pointer in the list, but if there is no such module yet, a new object is created. <br><br>  Please note that for each module we use for the first time, we call <i>LoadLibrary ()</i> , not relying on the <i>GetModuleHandle ()</i> function and only then we control the created objects using <b>shared_ptr</b> .  This makes it safe to use the created wrapper together in the same project with code that uses direct calls to <i>LoadLibrary ()</i> and <i>FreeLibrary ()</i> . <br><br>  That's all.  Oh yes, the <b>resouce_ptr</b> type appears in the code.  This is nothing more than a RAII wrapper over such types as HANDLE, HMODULE, and so on.  For those to whom intereno, here is the implementation: <br><br><div class="spoiler">  <b class="spoiler_title">Resource_ptr.h file</b> <div class="spoiler_text"><pre> <code class="hljs rust">#pragma <span class="hljs-keyword"><span class="hljs-keyword">once</span></span> #include <span class="hljs-string"><span class="hljs-string">"common.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"windows.h"</span></span> #include &lt;cassert&gt; #include &lt;memory&gt; NS_BEGIN_(ntutils) template&lt;typename HTag_&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource_close</span></span></span></span> { void operator()(typename HTag_::handle_t) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NO_EXCEPT_; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_tag</span></span></span></span> { typedef HANDLE resource_t; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hmodule_tag</span></span></span></span> { typedef HMODULE resource_t; }; template&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource_close</span></span></span></span>&lt;handle_tag&gt; { void operator()(handle_tag::resource_t a_handle) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NO_EXCEPT_ { <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> status = !!::CloseHandle(a_handle); assert(status); } }; template&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource_close</span></span></span></span>&lt;hmodule_tag&gt; { void operator()(hmodule_tag::resource_t a_handle) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NO_EXCEPT_ { <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> status = !!::FreeLibrary(a_handle); assert(status); } }; template&lt; typename RTag_, typename RTag_::resource_t RInvalid_, typename RFree_ = resource_close&lt;RTag_&gt; &gt; class resource_ptr { typedef typename RTag_::resource_t resource_t; typedef RFree_ deletor_t; resource_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resource_ptr&amp;) PROHIBITED_; void operator=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resource_ptr&amp;) PROHIBITED_; public: resource_ptr() NO_EXCEPT_ : m_resource(RInvalid_) { } resource_ptr(resource_t a_resource) NO_EXCEPT_ : m_resource(a_resource) { } <span class="hljs-comment"><span class="hljs-comment">// Constructor. explicit operator bool() const NO_EXCEPT_ { return m_resource &amp;&amp; m_resource != RInvalid_; } // Operator bool(). operator const resource_t&amp;() const NO_EXCEPT_ { return m_resource; } // Get the stored handle value. void reset(resource_t a_resource = resource_t()) NO_EXCEPT_ { resource_t old = m_resource; m_resource = a_resource; if (old != resource_t() &amp;&amp; old != RInvalid_) { m_deletor(old); } } ~resource_ptr() NO_EXCEPT_ { if (m_resource != resource_t() &amp;&amp; m_resource != RInvalid_) { m_deletor(m_resource); } } // Destructor. private: resource_t m_resource; deletor_t m_deletor; }; typedef resource_ptr&lt;handle_tag, INVALID_HANDLE_VALUE&gt; handle_ptr; typedef resource_ptr&lt;hmodule_tag, NULL&gt; hmodule_ptr; NS_END_</span></span></code> </pre><br></div></div><br>  This is exactly all.  Thank you for your attention, I will be glad to hear your comments! </div><p>Source: <a href="https://habr.com/ru/post/266809/">https://habr.com/ru/post/266809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266799/index.html">Configuring Siebel Email Marketing Server</a></li>
<li><a href="../266801/index.html">Publish Android library in jCenter</a></li>
<li><a href="../266803/index.html">Old code: why is it so</a></li>
<li><a href="../266805/index.html">King's Bounty III: Advanced remake of the original game under DOS in Javascript / HTML5</a></li>
<li><a href="../266807/index.html">Asterisk and Truecaller. Determining the name of an unknown caller for incoming calls</a></li>
<li><a href="../266811/index.html">How a relational database works</a></li>
<li><a href="../266813/index.html">Why we are engaged in translation of the book from English on the GitHub platform</a></li>
<li><a href="../266817/index.html">Kotlin and its almost language constructs</a></li>
<li><a href="../266821/index.html">Java Programmer Cheat Sheet 2: Three hundred and fifty of the most popular non-mobile Java opensource projects on github</a></li>
<li><a href="../266823/index.html">At the junction of ERP and ECM: how we automated the logistics process</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>