<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript promises</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, and once again all of the past holidays. Everyday work is gaining momentum and with them the information hunger tormenting us is growi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript promises</h1><div class="post__text post__text-html js-mediator-article">  <i>Hello everyone, and once again all of the past holidays.</i>  <i>Everyday work is gaining momentum and with them the information hunger tormenting us is growing.</i>  <i>The world of development of the front end does not sleep and prepares us many surprises in the coming year, and believe me, no one will be bored.</i>  <i>One of the new features that browser developers are preparing for us in conjunction with groups of developers writing specifications - JavaScript Promises (hereinafter referred to as Promises, please do not hit hard) - the asynchronous code writing pattern that many people are fond of gains native support.</i>  <i>What is the promise and what they eat can be read in the following translation (slightly loose) of the great <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">article by</a> <a href="http://jakearchibald.com/">Jake Archibald</a> .</i> <br><br><a name="habracut"></a><br><br>  Ladies and gentlemen, get ready for a great event in the world of web development ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      [Drumroll] <br><br>  Promises have become native in JavaScript! <br><br>  [Everywhere the roar of salutes, the crowd delighted] <br><br>  At the moment, you can be attributed to one of the following categories: <br><ul><li>  People are jubilant around, but you can not understand what is the reason for the celebration.  Perhaps you still can not fully catch up with what these ‚ÄúPromises‚Äù are.  You try to shrug, but tons of colorful glittering confetti put your weight on your shoulders.  If so, don't worry, it took me years of exhausting work, until I stopped worrying about understanding this thing.  Probably you should just start <a href="https://habr.com/ru/post/209662/">from here</a> . </li><li>  You're yelling.  You used these things from promises before, but you weren‚Äôt allowed to fall asleep that all the implementations have a slightly different API.  What API will provide us with the official implementation in JavaScript?  Then you probably <a href="https://habr.com/ru/post/209662/">come here</a> . </li><li>  You are in the know of all affairs, and you maliciously giggle at the mass of these simpletons, galloping around you, as if this is news to them.  Take a moment to enjoy your coolness, and then with a confident step, follow immediately to the <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">API reference</a> . </li></ul><br><br><h4><a name="1"></a>  Why is everyone dancing around? </h4><br>  JavaScript is single-threaded, and this means that two pieces of code cannot be executed at the same time, but will work one by one.  In browsers, JavaScript shares a stream with the execution of other operations.  The list of these operations differs from browser to browser, but for the most part, JavaScript is in the same queue as content rendering, style update, and custom action handling (such as text selection and interaction with form fields).  Performing one of these operations slows down the entire queue. <br><br>  As a human being, you are multithreaded.  You can beat the keys with all your fingers and listen to the conversation on the phone of a colleague sitting at the next table.  The only blocking function built into us is sneezing.  All current activity will be suspended for the time of sneeze.  It is a bit annoying when you drive a car and at the same time speak on the phone, when suddenly sneeze attacks you.  And you would not want that the code written by you also suffered from this problem. <br><br>  Probably, to protect yourself from this, you used an event model and a series of callbacks.  For example: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.img-1'</span></span>); img1.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,   }); img1.addEventListener('error', function() { // ,   });</span></span></code> </pre> <br><br>  There is no blocking code.  We took the image, hung a couple of listeners on it, that's all.  Further JavaScript can stop its execution until the moment until one of the events fires. <br><br>  Unfortunately, in the example above, it is likely that events will happen before we start listening to them.  Therefore, we will have to file this example using the <code>complete</code> images property: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.img-1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loaded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,   } if (img1.complete) { loaded(); } else { img1.addEventListener('load', loaded); } img1.addEventListener('error', function() { // ,   });</span></span></code> </pre><br><br>  Bad job, I tell you.  All the same, it will not give us a chance to catch pictures, the download of which ended in error until the moment when we had the opportunity to listen to them.  DOM politely does not give us this opportunity.  We are also trying to load one image, but imagine if we need to catch the end of the load of a pack of images. <br><br><h4>  Events are not always the best choice. </h4><br>  Listeners are a great thing when we need to catch a lot of recurring events on one element - keyup, touchstart, etc.  With these types of events, you don‚Äôt worry too much about what happens before you hook handlers.  But when you need to catch, for example, asynchronous loading with an indefinite outcome (success / failure), ideally, I would like to have something like this: <br><br><pre> <code class="javascript hljs"> img1.callThisIfLoadedOrWhenLoaded(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }).orIfFailedCallThis(function() { //  }); // ‚Ä¶ whenAllTheseHaveLoaded([img1, img2]).callThis(function() { //   }).orIfSomeFailedCallThis(function() { //     });</span></span></code> </pre><br><br>  This is exactly what promises are responsible for, but only under more distinct and semantic names.  If the HTML image had a <code>ready</code> method that returns a promise, we could do the following: <br><br><pre> <code class="javascript hljs">img1.ready().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }, function() { //    }); // ‚Ä¶ Promise.all([img1.ready(), img2.ready()]).then(function() { //   }, function() { //      });</span></span></code> </pre><br><br>  At their core, promises are a bit like events except for: <br><br><ul><li>  A promise can be completed only once, either by success or by mistake, and no other is given.  It cannot be executed twice. </li><li>  If the promise is fulfilled, and you only after that give him a callback, he will work, regardless of the fact that the event has already happened a long time ago. </li></ul><br><br>  This is extremely convenient for asynchronous requests, since  you are not interested when it happened exactly there, but it is interesting to process the results of what happened. <br><br><h4><a name="2"></a>  Promise Terminology </h4><br>  <a href="https://twitter.com/domenic">Domenik Denikol</a> read the first draft of this article and gave me a stake for the terminology used.  As punishment, he made me read a hundred times the provisions on possible ‚Äú <a href="">States and Exodus of Promises</a> ‚Äù, and write an apology letter to my parents.  Despite this, I still got mixed up, and I came to the following basic concepts: <br><br>  A promise may be: <br><br><ul><li>  <b>fulfilled</b> - successfully completed </li><li>  <b>rejected</b> - completed with an error </li><li>  <b>pending</b> - not completed </li><li>  <b>settled</b> - completed with any outcome </li></ul><br><br>  The specification also uses the term <code>thenable</code> to describe a promise of a similar object that has a <code>then</code> method.  But this term reminds me of former English football manager <a href="http://en.wikipedia.org/wiki/Terry_Venables">Teri Venables</a> , so I will use it as seldom as possible. <br><br><h4>  Promises are built into JavaScript! </h4><br>  Promises already surround us for some time in the form of libraries, such as these: <br><br><ul><li>  <a href="https://github.com/kriskowal/q">Q</a> </li><li>  <a href="https://github.com/cujojs/when">when</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">Winjs</a> </li><li>  <a href="">RSVP.js</a> </li></ul><br><br>  The promises from the libraries above and embedded in JavaScript follow the behavior described in the standardized <a href="https://github.com/promises-aplus/promises-spec">Promises / A +</a> specification.  If you use jQuery, there is something close in spirit called <a href="http://api.jquery.com/category/deferred-object/">Deffered</a> .  As if there were no, the deffered cards are slightly incompatible with the Promises / A + specification, which makes them <a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/">less suitable</a> , so keep your ear sharp.  JQuery also has a <a href="http://api.jquery.com/Types/">type of Promise</a> , but this is just a subset of Deffered fields with the same problems. <br><br>  Although all of these promise implementations follow the standard, their API is different.  The native promises API is most similar to RSVP.js. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,   , ‚Ä¶ if (/* ..    */) { resolve("!"); } else { reject(Error("")); } });</span></span></code> </pre><br><br>  The promise constructor takes one argument ‚Äî a callback function with two parameters: <code>resolve</code> and <code>reject</code> .  Everything is simple, inside the callback you perform any asynchronous operations, then you call <code>resolve</code> in case of success, or <code>reject</code> in case of failure. <br><br>  Like <code>throw</code> in good old JavaScript, rejects do not have to pass an error object.  The advantage of creating an Error object is that debugging code, having a call stack trace in the console, is much more pleasant. <br><br>  Further, the promise can be used as follows: <br><br><pre> <code class="javascript hljs">promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); <span class="hljs-comment"><span class="hljs-comment">// " !" }, function(err) { console.log(err); // : "" });</span></span></code> </pre><br><br>  The promise standardization started in DOM as ‚ÄúFutures‚Äù, was later renamed ‚ÄúPromises‚Äù, and finally moved to the JavaScript specification.  The idea of ‚Äã‚Äãrealizing promises, primarily in JavaScript, separate from the document object model, is beautiful because they can be available in non-browser environments such as Node.js. <br><br>  Although they have turned purely into a JavaScript feature, the DOM does not hesitate to use them to the fullest.  In fact, an all new DOM API tied to asynchrony will use Promises.  Now it is happening with <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html">Quota Management</a> , <a href="http://dev.w3.org/csswg/css-font-load-events/">Font Load Events</a> , <a href="">ServiceWorker</a> , <a href="http://webaudio.github.io/web-midi-api/">Web MIDI</a> , <a href="https://github.com/whatwg/streams">Streams</a> , and other API's. <br><br><h4>  Browser Support </h4><br>  At the moment, support for promises in browsers, frankly, is slightly limited. <br><br>  There is in Chrome'e.  Download <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Canary</a> , there promises are included by default.  Otherwise, if you are a soldier from the ranks of supporters of Firefox, download the latest <a href="http://nightly.mozilla.org/">nightly build</a> , it also has promises. <br><br>  At the moment, nowhere is the realization of the promises fully completed.  You can track the development of Firefox on <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D918806">bugzilla</a> , and the Chrome <a href="http://www.chromestatus.com/features/5681726336532480">innovations board</a> to keep up with the latest developments. <br><br>  In order to bring the work of promises to the proper form or add promises to other browsers and Node.js, use a <a href="">polyfil</a> . <br><br><h4>  Compatible with other libraries </h4><br>  The promises JavaScript API does not do without the <code>then</code> method, as it should be for a Promise-like object (in Promise terminology it is also called <code>thenable</code> ).  There is also a <code>Promise.cast</code> method that erases the boundaries between embedded and custom Promise-like objects.  So, if you use a library that returns promises of type Q, that's fine, they will work fine with native JavaScrip promises. <br><br>  But, as I warned, jQuery Deferreds are slightly ... different.  Fortunately, you can bring them to the standard ones: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsPromise = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.cast($.ajax(<span class="hljs-string"><span class="hljs-string">'/whatever.json'</span></span>));</code> </pre><br><br>  Here jQuery'rivsky <code>$.ajax</code> returns Deferred.  But as long as he has a <code>then</code> method, <code>Promist.cast</code> can turn it into a real promise.  Be that as it may, at times Deffered passes too many arguments to its callback: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jqDeferred = $.ajax(<span class="hljs-string"><span class="hljs-string">'/whatever.json'</span></span>); jqDeferred.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response, statusText, xhrObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }, function(xhrObj, textStatus, err) { // ... });     JS     : jsPromise.then(function(response) { // ... }, function(xhrObj) { // ... });</span></span></code> </pre><br><br>  Fortunately, in most cases this is what you need, and you get access to what you need.  It's also important to know that jQuery should not convention pass the error object to <code>reject</code> . <br><br><h4>  Asynchronous code gets easier </h4><br>  So, let's encode a couple of things.  Suppose we want: <br><br><ol><li>  Show rotating icon for load indication </li><li>  Request some JSON for a story that contains a title and a collection of URLs for each chapter. </li><li>  Add heading to the page </li><li>  Request all chapters </li><li>  Show them all </li><li>  Hide the download indicator </li></ol><br><br>  ... and also notify the user if something went wrong along the way.  We want to stop the indicator after an error in order not to make the user dizzy from perpetual rotation. <br><br>  Of course, you do not want to dynamically load content, which is <a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/">faster to give as HTML</a> , but our template is good when working with third-party APIs: you make a lot of requests, then work with data, when you get them all. <br><br>  Before we begin, let's see how we pull data from the network. <br><br><h4>  XMLHttpRequest enlists the promise </h4><br>  Older APIs will be updated using promises, if it is possible without losing backward compatibility.  <code>XMLHttpRequest</code> first candidate, but for now let's write a simple function for making a GET request: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . return new Promise(function(resolve, reject) { //   XHR  var req = new XMLHttpRequest(); req.open('GET', url); req.onload = function() { //      404'  //     if (req.status == 200) { //      resolve(req.response); } else { // ,     //       reject(Error(req.statusText)); } }; //    req.onerror = function() { reject(Error("Network Error")); }; //   req.send(); }); }</span></span></code> </pre><br><br>  Now let's use it: <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, response); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, error); });</code> </pre><br><br>  Now we can make HTTP requests without typing in <code>XMLHttpRequest</code> , which makes me very happy, because  The nauseous form of <code>XMLHttpRequest</code> 'camel's notation poisons my life. <br><br><h4>  Call chain </h4><br>  <code>then</code> this is not the end of the story, you can link calls <code>then</code> for end-to-end transformation of return values ‚Äã‚Äãor perform additional asynchronous actions one by one. <br><br><h5>  Pipelining of values </h5><br>  You can modify the value of the pipeline simply by returning a new one: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val); <span class="hljs-comment"><span class="hljs-comment">// 1 return val + 2; }).then(function(val) { console.log(val); // 3 });</span></span></code> </pre><br><br>  For a more practical example, let's go back to: <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, response); });</code> </pre><br><br>  The answer came to us in JSON format, but we need plain text to display the content.  We can set the <code>responseType</code> our answer, but we can also send a stroll through the wonderful world of promises: <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(response); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  JSON!"</span></span>, response); });</code> </pre><br><br>  By the way, <code>JSON.parse</code> takes one argument and returns the processed value, and we can simply pass a reference to it: <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  JSON!"</span></span>, response); });</code> </pre><br><br>  In fact, we can easily sketch the <code>getJSON</code> sugar function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(url).then(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse); }</code> </pre><br><br>  <code>getJSON</code> still returns the promise after it pulls out the data and parses the JSON response. <br><br><h5>  Asynchronous Event Queue </h5><br>  You can also connect <code>then</code> calls to perform asynchronous actions sequentially. <br><br>  When you return something from the <code>then</code> callback, a little bit of magic happens.  If you return any value, this value will be passed to the callback function next <code>then</code> .  And if you return something like a promise, the next will <code>then</code> wait for it and call the callback only when it is fulfilled.  For example: <br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getJSON(story.chapterUrls[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chapter1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>, chapter1); });</code> </pre><br><br>  Here we make an asynchronous request to <code>story.json</code> , and when we receive a set of URLs in the response, we request for the first one.  Here we clearly see how far an apple can roll away from the apple tree, the advantage of promises over the usual pattern of callbacks hurts the eyes.  You can take out the logic of requesting an article to a separate method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storyPromise; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChapter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ storyPromise = storyPromise || getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storyPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getJSON(story.chapterUrls[i]); }) } <span class="hljs-comment"><span class="hljs-comment">//     : getChapter(0).then(function(chapter) { console.log(chapter); return getChapter(1); }).then(function(chapter) { console.log(chapter); });</span></span></code> </pre><br><br>  We do not load <code>story.json</code> until the first call to <code>getChapter</code> , and the following calls to <code>getChapter</code> re-use the promise of loading the story that has already been fulfilled and do not make additional requests.  Oh, those Promises! <br><br><h4>  Error processing </h4><br>  As we saw earlier, <code>then</code> takes two arguments, one for successful completion, the other is called in case of an error (fulfill and reject in the terminology of promises): <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, response); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, error); });</code> </pre><br><br>  You can also use <code>catch</code> : <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, response); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, error); });</code> </pre><br><br>  There is nothing special about this method, it‚Äôs just more readable sugar for <code>then(undefined, func)</code> .  Note that the two pieces of code above are not the same, the latter is equivalent to the following: <br><br><pre> <code class="javascript hljs"> get(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, response); }).then(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>, error); });</code> </pre><br><br>  This, at first glance, a small difference is actually a very powerful concept.  A rejection of the promise (rejections) will be passed down the <code>then</code> call chain (or <code>catch</code> , which is almost the same) until the first error handler is encountered.  In the case of <code>then(func1, func2)</code> , <code>func1</code> and <code>func2</code> will never be called both.  But in the chain of <code>then(func1).catch(func2)</code> , both functions can be called if the promise returned from <code>func1</code> fails (reject).  Joke with the following piece of code: <br><br><pre> <code class="javascript hljs">asyncThing1().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncThing2(); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncThing3(); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncRecovery1(); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncThing4(); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncRecovery2(); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Don't worry about it"</span></span>); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All done!"</span></span>); });</code> </pre><br><br>  The error handling process is very similar to the standard <code>try/catch</code> , the error that occurred in the <code>try</code> block is immediately passed to the <code>catch</code> .  Here is a block diagram of what is happening in the code above (I love block diagrams): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df1/6fc/f31/df16fcf31e613eda34ee5cd25777977b.gif" alt="image"><br><br>  Follow the green arrows, in the case of a successfully fulfilled promise and in red, in case of failure. <br><br><h5>  JavaScript exceptions and promises </h5><br>  Error handling can occur not only when you explicitly refuse (reject) a promise, but also implicitly when an exception is generated inside the constructor callback. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// JSON.parse     //  JSON,     reject': resolve(JSON.parse("This ain't JSON")); }); jsonPromise.then(function(data) { //     : console.log("!", data); }).catch(function(err) { //   : console.log("!", err); });</span></span></code> </pre><br><br>  This means that it is best to do all the work related to the promise inside the callback function that you pass to the constructor, and all errors will be automatically intercepted by the function that you use to handle the failure of the promise. <br><br>  The same will happen when an exception is generated in the <code>then</code> callback: <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>).then(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    , '/'     JSON //   JSON.parse   console.log("!", data); }).catch(function(err) { //   : console.log("!", err); });</span></span></code> </pre><br><br><h5>  Error handling in practice </h5><br>  In the case of our chaptered chapter history, we can use <code>catch</code> to alert the user about the error: <br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getJSON(story.chapterUrls[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chapter1</span></span></span><span class="hljs-function">) </span></span>{ addHtmlToPage(chapter1.html); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ addTextToPage(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.spinner'</span></span>).style.display = <span class="hljs-string"><span class="hljs-string">'none'</span></span>; });</code> </pre><br><br>  If the request to <code>story.chapterUrls[0]</code> fails (http 500 or the user has gone offline), all subsequent callbacks called upon success will not be executed, such as the JSON parser included in <code>getJSON</code> , the callback adding the first chapter to the page , too, will be ignored.  Execution will immediately go to the first error handling callback.  As a result, the user will see the message ‚ÄúIt is impossible to display the chapter‚Äù if in any of the previous callbacks something goes wrong. <br><br>  As in the case of the standard <code>try/catch</code> error will be intercepted, and the program will continue its execution, so we will successfully hide the loading indicator, which is what we need.  Here‚Äôs how it would look in a synchronous blocking version: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> story = getJSONSync(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chapter1 = getJSONSync(story.chapterUrls[<span class="hljs-number"><span class="hljs-number">0</span></span>]); addHtmlToPage(chapter1.html); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { addTextToPage(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.spinner'</span></span>).style.display = <span class="hljs-string"><span class="hljs-string">'none'</span></span>;</code> </pre><br><br>  Perhaps you want to catch the error a little earlier, for example, to log what is happening.  To do this, simply regenerate the error in this place.  We can do this in our <code>getJSON</code> method: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(url).then(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"getJSON  "</span></span>, url, err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; }); }</code> </pre><br><br>  So, we managed to bring out one chapter, but we want to see them all.  Let's do it. <br><br><h4>  Parallelism and queue - take the best of both </h4><br>  Thinking asynchronously is not so easy.  If you are at a dead end, try to write the code as if it were synchronous: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> story = getJSONSync(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>); addHtmlToPage(story.heading); story.chapterUrls.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chapterUrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chapter = getJSONSync(chapterUrl); addHtmlToPage(chapter.html); }); addTextToPage(<span class="hljs-string"><span class="hljs-string">"All done"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { addTextToPage(<span class="hljs-string"><span class="hljs-string">"- : "</span></span> + err.message); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.spinner'</span></span>).style.display = <span class="hljs-string"><span class="hljs-string">'none'</span></span>;</code> </pre><br><br>  It <a href="http://www.html5rocks.com/en/tutorials/es6/promises/sync-example.html">works</a> !  But all actions are performed synchronously and block the browser at the time of loading.  In order to make this code asynchronous, we will use <code>then</code> to perform tasks one after another. <br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ addHtmlToPage(story.heading); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">       story.chapterUrls }).then(function() { //    ! addTextToPage(" "); }).catch(function(err) { //   ,     addTextToPage("- : " + err.message); }).then(function() { //     document.querySelector('.spinner').style.display = 'none'; });</span></span></code> </pre><br><br>  But how do we go round all the chapters?  This will not work: <br><br><pre> <code class="javascript hljs">story.chapterUrls.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chapterUrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   getJSON(chapterUrl).then(function(chapter) { //      addHtmlToPage(chapter.html); }); });</span></span></code> </pre><br><br>  <code>forEach</code> has nothing to do with asynchrony, and our chapters will be added to the page in random order as it loads, approximately, as it was written ‚ÄúPulp Fiction‚Äù.  We do not have ‚ÄúPulp Fiction‚Äù, so let's fix it ... <br><br><h5>  Put everything in line </h5><br>  We want to turn our <code>chaptersUrls</code> array into a line of promises.  We can do this as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     var sequence = Promise.resolve(); //      story.chapterUrls.forEach(function(chapterUrl) { //       sequence = sequence.then(function() { return getJSON(chapterUrl); }).then(function(chapter) { addHtmlToPage(chapter.html); }); });</span></span></code> </pre><br><br>  This is the first time we have met the <code>Promise.resolve</code> factory method, which creates an immediate fulfilled promise with the value that you give to it.  If you give him something like a promise (something that has a <code>then</code> method), he will return a copy of it.  If you call <code>Promise.resolve</code> without an argument, as in our example, it returns a successfully fulfilled promise with the value undefined. <br><br>  There is also a reverse method <code>Promise.reject(val)</code> , which returns a promise, completed with an error, with the value you give it (or <code>undefined</code> ). <br><br>  We can make the code a bit more neat using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>array.reduce</code></a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      story.chapterUrls.reduce(function(sequence, chapterUrl) { //       return sequence.then(function() { return getJSON(chapterUrl); }).then(function(chapter) { addHtmlToPage(chapter.html); }); }, Promise.resolve());</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the same thing happens as in the previous example, but we do not need to allocate a separate variable for the queue after the cycle. Our reducing callback is called for each element in the array. Our initial queue, transmitted at the first iteration, is </font></font><code>Promise.resolve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but with each subsequent call of the callback, the result of the previous call is passed to it. </font></font><code>array.reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is very convenient to use when you need to cast an array to a single value, for example, a promise, as in our case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's put it all together ...</font></font><br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ addHtmlToPage(story.heading); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> story.chapterUrls.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sequence, chapterUrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sequence.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶   return getJSON(chapterUrl); }).then(function(chapter) { //      addHtmlToPage(chapter.html); }); }, Promise.resolve()); }).then(function() { //   ! addTextToPage(" "); }).catch(function(err) { //   ,    addTextToPage("- : " + err.message); }).then(function() { //       document.querySelector('.spinner').style.display = 'none'; });</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And </font></font><a href="http://www.html5rocks.com/en/tutorials/es6/promises/async-example.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> happened! </font><font style="vertical-align: inherit;">We have a full asynchronous version of our idea. </font><font style="vertical-align: inherit;">But we will not stop there. </font><font style="vertical-align: inherit;">At the moment, loading our page looks like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f18/237/fe2/f18237fe29e2f14be41d0e939d0ec124.gif" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browsers have long been able to load many things at the same time, and we lose in performance by loading chapters one by one. </font><font style="vertical-align: inherit;">What we want to do is to have all the chapters loaded at the same time, and then we will process them when they are all available to us. </font><font style="vertical-align: inherit;">Fortunately, the API gives us this opportunity right out of the box:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(arrayOfPromises).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arrayOfResults</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... });</span></span></code> </pre><br> <code>Promise.all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts an array of promises and returns one promise that will be fulfilled only when all promises are completed successfully. </font><font style="vertical-align: inherit;">This general promise will return to the callback an </font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array of each results in the order in which you gave them.</font></font><br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ addHtmlToPage(story.heading); <span class="hljs-comment"><span class="hljs-comment">//        return Promise.all( //     //     getJSON story.chapterUrls.map(getJSON) ); }).then(function(chapters) { //        ‚Ä¶ chapters.forEach(function(chapter) { // ‚Ä¶     addHtmlToPage(chapter.html); }); addTextToPage(" "); }).catch(function(err) { addTextToPage("- : " + err.message); }).then(function() { document.querySelector('.spinner').style.display = 'none'; });</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the connection, the load may be much faster than when you load the chapters </font></font><a href="http://www.html5rocks.com/en/tutorials/es6/promises/async-all-example.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one by one</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in this example there is less code than in our previous attempt. Chapters can be loaded in random order, but they will appear on the screen in the desired sequence. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a5/7c9/f31/7a57c9f31885fc8c0970221f2f3115b1.gif" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No matter how it was, we can still slightly improve our perceived performance. When the first chapter arrives, we can add it to the page, which will allow the user to start reading while the remaining chapters are uploaded. If the third chapter comes before everyone else, we would not want to display it because the user will not understand that the first couple of chapters have been missed. Therefore, we will, if possible, display all the chapters in sequence as they are loaded.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To implement this, we will request JSON's for all our chapters at the same time, and then create a queue to add them to the document: </font></font><br><br><pre> <code class="javascript hljs">getJSON(<span class="hljs-string"><span class="hljs-string">'story.json'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">story</span></span></span><span class="hljs-function">) </span></span>{ addHtmlToPage(story.heading); <span class="hljs-comment"><span class="hljs-comment">//     //     getJSON //   ,     . return story.chapterUrls.map(getJSON) .reduce(function(sequence, chapterPromise) { //        , //       return sequence.then(function() { return chapterPromise; }).then(function(chapter) { addHtmlToPage(chapter.html); }); }, Promise.resolve()); }).then(function() { addTextToPage("All done"); }).catch(function(err) { addTextToPage("Argh, broken: " + err.message); }).then(function() { document.querySelector('.spinner').style.display = 'none'; });</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so we killed </font></font><a href="http://www.html5rocks.com/en/tutorials/es6/promises/async-best-example.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two birds with one stone</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We simultaneously request all the content, but with a slow connection, the user has the opportunity to see the first portion a little earlier. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4a/e75/f22/b4ae75f225db970ff6fba5bc00ca688d.gif" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this primitive example, the chapters are displayed almost instantly, the real gain from this technique can be seen on the data of a much larger volume. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeating all of the above in the style of callbacks and Node.js events is not so easy and will double the amount of code approximately </font></font><a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anyway, this is not the end of the story of promises. </font><font style="vertical-align: inherit;">Let's try to see how they will work in tandem with other new features of ES6 ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small bonus: promises and generators </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we take a look at a small bundle of new features of ES6, but you don‚Äôt need them to understand and start using promises today. </font><font style="vertical-align: inherit;">Take it as a trailer for the upcoming blockbuster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6 also gives us </font></font><a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:generators"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generators</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">They give us the opportunity to exit a function at any point, like return does, but later we can continue executing the same state from the same point.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { i += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the asterisk symbol in front of the name of the declared function, it indicates that it should be a generator. </font><font style="vertical-align: inherit;">The keyword </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is our return / restore point. </font><font style="vertical-align: inherit;">We can use the above function, for example, like this:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> adder = addGenerator(); adder.next().value; <span class="hljs-comment"><span class="hljs-comment">// 0 adder.next(5).value; // 5 adder.next(5).value; // 10 adder.next(5).value; // 15 adder.next(50).value; // 65</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what advantages do generators give us when working with promises? </font><font style="vertical-align: inherit;">Count up, you can use their behavior to write asynchronous code that looks like synchronous. </font><font style="vertical-align: inherit;">Don't worry too much about understanding each line of the following example. </font><font style="vertical-align: inherit;">It describes the function that enables us to use </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to wait for the fulfillment of the promise.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generatorFunc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">continuer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">verb, arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = generator[verb](arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(err); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.done) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.cast(result.value).then(onFulfilled, onRejected); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generator = generatorFunc(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onFulfilled = continuer.bind(continuer, <span class="hljs-string"><span class="hljs-string">"next"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onRejected = continuer.bind(continuer, <span class="hljs-string"><span class="hljs-string">"throw"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> onFulfilled(); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... it is very similar to the similar </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function from Q</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , just adapted to native promises. </font><font style="vertical-align: inherit;">With it, we can take our last example of displaying chapters and turn it into this:</font></font><br><br><pre> <code class="javascript hljs">spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 'yield' effectively does an async wait, // returning the result of the promise let story = yield getJSON('story.json'); addHtmlToPage(story.heading); // Map our array of chapter urls to // an array of chapter json promises. // This makes sure they all download parallel. let chapterPromises = story.chapterUrls.map(getJSON); for (let chapterPromise of chapterPromises) { // Wait for each chapter to be ready, then add it to the page let chapter = yield chapterPromise; addHtmlToPage(chapter.html); } addTextToPage("All done"); } catch (err) { // try/catch just works, rejected promises are thrown here addTextToPage("Argh, broken: " + err.message); } document.querySelector('.spinner').style.display = 'none'; });</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code works the same way as before, but it has become much easier to read. </font></font><a href="http://www.html5rocks.com/en/tutorials/es6/promises/async-generators-example.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will work today in Chrome Canary if you enable Enable experimental JavaScript in </font></font><code>about:flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This example combines a lot of features ES6: promises, generators </font></font><code>let</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>for-of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And it shows how we can write simple asynchronous code with normal </font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The future is near.</font></font></div><p>Source: <a href="https://habr.com/ru/post/209662/">https://habr.com/ru/post/209662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209650/index.html">Mobile game: where is the money?</a></li>
<li><a href="../209652/index.html">What nobody says to newbies</a></li>
<li><a href="../209654/index.html">DipTrace. Innovations</a></li>
<li><a href="../209656/index.html">3D Scanner for iPad</a></li>
<li><a href="../209660/index.html">Romanian bitcoin millionaire paid OpenBSD debts</a></li>
<li><a href="../209664/index.html">How to increase the effectiveness of the development method of Kuklachev</a></li>
<li><a href="../209666/index.html">Creating reliable iSCSI storage on Linux, part 2</a></li>
<li><a href="../209668/index.html">Career Architecture</a></li>
<li><a href="../209670/index.html">Sale of books!</a></li>
<li><a href="../209672/index.html">UpGrade gift - To beauty salon for BTC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>