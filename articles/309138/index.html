<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning OpenGL ES2 for Android Lesson ‚Ññ4. Textures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before you start 

 ¬ªIf you are new to OpenGL ES, I recommend first learning the previous 3 lessons: one / two / three 
 The basics of the code used i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning OpenGL ES2 for Android Lesson ‚Ññ4. Textures</h1><div class="post__text post__text-html js-mediator-article">  <b>Before you start</b> <br><br>  ¬ªIf you are new to OpenGL ES, I recommend first learning the previous 3 lessons: <a href="http://androidalwaysdream.blogspot.com/2016/03/opengl-es-2-android-1-opengl.html">one</a> / <a href="http://androidalwaysdream.blogspot.com/2016/07/opengl-es-2-android-2.html">two</a> / <a href="http://androidalwaysdream.blogspot.com/2016/08/opengl-es-2-android-3.html">three</a> <br>  The basics of the code used in this article are taken <a href="http://startandroid.ru/ru/uroki/vse-uroki-spiskom/406-urok-175-opengl-tekstury.html">from here</a> and <a href="http://andmonahov.blogspot.com/2012/10/opengl-es-20_13.html">from here</a> . <br><br>  The result of this lesson will be a dolphin jumping over the surface of the sea. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/3f0/061/131/3f006113178845b38c66510b0ab51903.gif"></div><br><a name="habracut"></a><br><h3>  Little about textures </h3><br>  A texture is a raster image that is superimposed on the surface of a polygonal model to give it a color, color, or illusion of relief.  The use of textures can be easily imagined as a drawing on the surface of a sculpture image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/96a/bdc/483/96abdc483b7f409ca13062ccfc6e34f1.jpg"></div><br>  The use of textures also makes it possible to reproduce small details of the surface, the creation of which by polygons would be excessively resource intensive.  For example, scars on the skin, folds on clothes, small stones and other objects on the surface of walls and soil. <br><br>  The quality of the textured surface is determined by texels - the number of pixels per minimum unit of texture.  Since the texture itself is an image, the resolution of the texture and its format play a large role, which subsequently affects the speed and quality of graphics in the application. <br><br><h3>  Texture coordinates </h3><br>  In OpenGL, texture coordinates are usually given in coordinates (s, t) or (u, v) instead of (x, y).  (s, t) is a texel texture, which is then converted to a polygon. <br><br>  In most computer coordinate imaging systems, the Y axis is downward and X is to the right, therefore the upper left corner corresponds to the image at the point (0, 0). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e92/fcc/edc/e92fccedc3f249e5839035a59b619225.jpg"></div><br>  We must remember that for some android systems, memory will only work with textures, the sides of which are multiples of 2 to the power n.  Therefore, you need to strive for the atlas with textures to be of the appropriate sizes in pixels, for example, 512x512 or 1024x512.  Also, if you do not use the POT texture (POT - Power Of Two, that is, the power of two), you will not be able to use tiling or automatic mipmap generation.  In this case, tiling refers to multiple repetitions of a single texture.  Remember, the bottom right corner always has coordinates (1,1), even if the width is twice the height.  This is called normalized coordinates. <br><br>  Many small textures are often used in applications, and switching from one texture to another is a relatively slow process.  Therefore, in such situations it is advisable to use one large image instead of many small ones.  Such an image is called a texture atlas.  Sub-textures are mapped onto an object using a UV transform, and the coordinates in the atlas determine which part of the image to use. <br><br>  Since in our application there are three textures (sky, sea and dolphin), they are combined into one atlas of png size 1024x1024. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/41d/804/991/41d804991a144afa867f2a1eeb0c6f08.png"></div><br>  As you can see, I added another dolphin image (in the lower right corner).  Then you can play and connect it instead of the one on the left.  This atlas is very poorly made, as there is a lot of free space left.  There are algorithms and programs that allow you to pack images in an optimal way.  For example, as in the photo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3e4/07c/01f/3e407c01f0ba4be196b80192ed937a1c.jpg"></div><br>  The weight (size of the memory occupied) of the texture can be defined in this way: multiply byte per pixel of height and pixel width, thus a 32-bit texture of size 1024 by 1024 takes 4 * 1024 * 1024 = 4'194'304 bytes. <br><br>  The 16-bit texture of 1024 to 1024 only takes 2MB, so it‚Äôs worth considering whether to use 32-bit images or not. <br><br>  There is hardware texture compression, which usually allows you to reduce the weight of textures by four times.  However, now these questions are not the main ones, just passing information for reflection. <br><br>  In this tutorial, we will use only the GL_TEXTURE_2D method, which allows you to put a texture on the plane (there is also GL_TEXTURE_CUBE_MAP, which works with the texture of an expanded cube consisting of 6 squares). <br><br><h3>  How to wear a texture? </h3><br>  Before putting on, find out what. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/417/f63/95b/417f6395b9394d1abcdb4c4ed3bf7987.png"></div><br>  One rectangle (consisting of two triangles) will lie in the x0y plane, we will wear a sky texture on it.  To do this, in the private void prepareData () method of the OpenGLRenderer class, create an array of coordinates float [] vertices, where we will enter the coordinates of not only the triangles, but also the coordinates of the corresponding texture. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//coordinates for sky -2, 4, 0, 0, 0, -2, 0, 0, 0, 0.5f, 2, 4, 0, 0.5f, 0, 2, 0, 0, 0.5f, 0.5f,</span></span></code> </pre> <br>  The first three numbers of the line are the coordinates of the upper left corner of the sky (-2, 4, 0), the next two numbers are the coordinates of the texel point (0,0), which correspond to our vertex of the triangle.  Pay attention to the second point (second line), which coincides with the lower left edge of the sky (-2, 0, 0), for it coordinates of the texel point (0, 0.5f), i.e.  s = 0 (left edge of texel), and t = 0.5, since the sky texture takes up only half of the texel vertically.  Then we set the third point (upper right edge of the sky) and the fourth point to draw two triangles using the GL_TRIANGLE_STRIP method (see the previous lesson). <br><br>  I first decided to make the second plane (sea) perpendicular to the first (sky), but then slightly increased the angle, lowering the front edge of the sea for the beauty of the front view on the device. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//coordinates for sea -2, 0, 0, 0.5f, 0, -2, -1, 2, 0.5f, 0.5f, 2, 0, 0, 1, 0, 2,-1, 2, 1, 0.5f,</span></span></code> </pre><br>  Notice how the coordinates that cut us from the atlas of the sea have changed.  I placed the image of a dolphin on a plane that is parallel to the sky and shifted to us along the 0Z axis by 0.5 units. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//coordinates for dolphin -1, 1, 0.5f, 0, 0.5f, -1, -1, 0.5f, 0, 1, 1, 1, 0.5f, 0.5f, 0.5f, 1, -1, 0.5f, 0.5f, 1,</span></span></code> </pre><br>  If there is a desire to change the dolphin to another, then it must be done here.  So, we have passed the first step and made the correspondence between the vertices of the triangles and the points of the texel. <br><br><h3>  Second step or how textures are loaded </h3><br>  Before describing the loading of textures, you need to deal with such a concept as a texture slot.  It is to him that we connect the texture, with the help of it we can make various manipulations with it and change its parameters. <br><br>  You can select the current slot for operation as follows: <br><br><pre> <code class="java hljs">GLES20.glActiveTexture(GLES20.GL_TEXTUREx);</code> </pre> <br>  where GLES20.GL_TEXTUREx is the number of the selected slot, for example GLES20.GL_TEXTURE0, <br>  the constants are written for 32 textures (last GL_TEXTURE31). <br><br>  To connect the texture to the slot, use the procedure <br><br><pre> <code class="java hljs">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture_id);</code> </pre> <br>  Where: the first parameter is the texture type, the second is the texture reference. <br><br>  This procedure attaches a texture to the current slot that was previously selected by GLES20.glActiveTexture (). <br><br>  That is, in order to attach a texture to a specific slot, you need to call two procedures: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GLES20</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.glActiveTexture</span></span>(_); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GLES20</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.glBindTexture</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GLES20</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GL_TEXTURE_2D</span></span>, __);</code> </pre> <br>  It is important to remember that you cannot connect one texture to multiple slots at the same time.  If you switched it to another slot and did not install the texture for the slot to which it was previously connected, then an attempt to read will most likely lead to the application crash. <br><br>  As soon as we placed our graphic file texture.png in the resource folder of the drawable project, the system automatically assigned it the id number (the resource identifier is an integer that is a link to this resource).  Resource identifiers are stored in the R.java file. <br><br>  The TextureUtils class has a loadTexture method.  This method takes as an input the resource id of the image, and the output returns the id of the created texture object that will contain this image. <br><br>  So, first we give the context and the resource identifier of the graphic file as public arguments to the public static int loadTexture (Context context, int resourceId) { <br><br>  Then we create an empty array of one element.  In this array, OpenGL ES will write the free number of the texture, which is called the textureI textures <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] textureIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br>  Then we generate a free name for the texture, which will be written to textureIds [0] <br>  glGenTextures (1, textureIds, 0); <br><br>  The first parameter determines how many texture objects we want to create.  Usually we create only one.  The next parameter is the name of the texture where OpenGL ES will write the id of the generated texture objects.  The last parameter simply tells OpenGL ES, from which point in the array to start writing id. <br><br>  We check if nothing is written, then return zero. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textureIds[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The inScaled flag is enabled by default and should be disabled if we need a non-scalable version of the bitmap. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BitmapFactory.Options options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapFactory.Options(); options.inScaled = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;</code> </pre> <br>  We load image in Bitmap from a resource <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Bitmap bitmap = BitmapFactory.decodeResource( context.getResources(), resourceId, options);</code> </pre> <br>  The texture object is still empty.  This means that it still does not have any graphic data.  Load our bitmap image.  To do this, we first need to bind the texture.  In OpenGL ES, the binding of something means that we want OpenGL ES to use this particular object for all subsequent calls until we change the binding again.  In this case, we want to bind the texture of the object.  To do this, we use the glBindTexture () method.  As soon as we tie the texture, we can manage its properties, such as image data. <br><br>  Selecting the active texture slot <br><br><pre> <code class="java hljs">glActiveTexture(GL_TEXTURE0);</code> </pre> <br>  Make a texture named textureIds [0] current <br><br><pre> <code class="java hljs">glBindTexture(GL_TEXTURE_2D, textureIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br>  Create texture transparency.  If you do not write these two lines, our dolphin will be on a black opaque background, as in the screenshot above. <br><br><pre> <code class="java hljs">GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA); GLES20.glEnable(GLES20.GL_BLEND);</code> </pre><br>  There is one more detail that we need to determine before we can use a texture object.  It is connected with the fact that our triangle can occupy more or less pixels on the screen compared to how many pixels there are in the indicated texture zone.  For example, on the screen, we can use much more pixels compared to what was transferred from the texture zone.  Naturally, it can be the other way around: we use fewer pixels on the screen than on the selected texture zone.  The first case is called magnification, and the second is minification.  In each of these, we need to tell OpenGL ES how to increase or decrease the texture.  In OpenGL ES terminology, the corresponding mechanisms are called minification and magnification filters.  These filters are properties of the texture object, just like the image data itself.  To install them, you first need to check if the texture object is bound using glBindTexture ().  If so, set them as follows: <br><br><pre> <code class="java hljs">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);</code> </pre> <br>  About the influence of filters on the image can be read <a href="http://www.learnopengles.com/tag/mipmap/">here</a> . <br><br>  We rewrite Bitmap in memory of the video card <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GLUtils</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GLES20</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GL_TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">bitmap</span></span>, 0);</code> </pre> <br>  We delete Bitmap from memory, since  the picture has already been rewritten to video memory <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">bitmap</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.recycle</span></span>();</code> </pre> <br>  And finally, we call the glBindTexture method again, in which GL_TEXTURE_2D is passed 0 to the texture slot. Thus, we untie our texture object from this slot. <br><br><pre> <code class="java hljs">glBindTexture(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> textureIds[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Once again, we first placed the texture object in the GL_TEXTURE_2D slot, <br><br><pre> <code class="java hljs">glBindTexture(GL_TEXTURE_2D, textureIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br>  then they performed all the operations with it, then freed the slot.  As a result, the texture object is now configured, ready to work, and not tied to any texture slot. <br><br><h3>  Shader texture access </h3><br>  In previous lessons we wrote shaders in the program body itself as line objects.  It is convenient to take them to a separate resource, as suggested <a href="http://startandroid.ru/ru/uroki/vse-uroki-spiskom/406-urok-175-opengl-tekstury.html">here</a> .  Thus, in the res project folder, a raw folder is created in which two vertex_shader.glsl and fragment_shader.glsl files are laid.  Here are their contents. <br><br>  <u>vertex_shader.glsl</u> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec4 a_Position; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> mat4 u_Matrix; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec2 a_Texture; <span class="hljs-attribute"><span class="hljs-attribute">varying</span></span> vec2 v_Texture; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_Position</span></span> = u_Matrix * a_Position; <span class="hljs-attribute"><span class="hljs-attribute">v_Texture</span></span> = a_Texture; }</code> </pre> <br>  Here we, as before, calculate the final coordinates (gl_Position) for each vertex using the matrix.  And in the a_Texture attribute, we receive data on texture coordinates, which we immediately write in varying variable v_Texture.  This will allow us in the fragment shader to obtain interpolated data on texture coordinates. <br><br>  <u>fragment_shader.glsl</u> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">precision</span></span> mediump float; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_TextureUnit; <span class="hljs-attribute"><span class="hljs-attribute">varying</span></span> vec2 v_Texture; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_TextureUnit, v_Texture); }</code> </pre> <br>  First, set the average accuracy of calculations <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>;</code> </pre> <br>  There is a special type of uniform in GLSL called sampler2D.  Samplers can only be declared in a fragment shader. <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D u_TextureUnit;</code> </pre> <br>  In it, we have a uniform variable u_TextureUnit, into which we get the slot number of the texture, which contains the texture we need.  Pay attention to the type of the variable.  Let me remind you that from the application we passed 0 to this variable as an integer.  Those.  the number passed to the shader (0 in our case) indicates which slot of the texture to watch. <br><br>  In varying variable v_Texture come interpolated texture coordinates from the vertex shader.  And the shader knows which point of the texture should be displayed at the current point of the triangle. <br><br>  It remains to use the texture coordinates and the texture itself to get the final fragment.  This will execute the texture2D method, and in gl_FragColor we will get the color of the desired point from the texture. <br><br>  Download sources <a href="https://github.com/AlwaysDream">from here</a> .  Good luck and all the best! <br><br>  Main sources: <br>  " <a href="https://www.opengl.org/sdk/docs/">Www.opengl.org/sdk/docs/</a> <br>  ¬ª <a href="http://startandroid.ru/ru/uroki/vse-uroki-spiskom/406-urok-175-opengl-tekstury.html">Startandroid.ru</a> <br>  " <a href="http://andmonahov.blogspot.com/2012/10/opengl-es-20_13.html">Andmonahov.blogspot.com</a> <br>  ¬ª <a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html">Developer.android.com/reference</a> <br>  ¬ª <a href="">Www.opengl.org</a> <br>  " <a href="http://www.learnopengles.com/tag/mipmap/">Www.learnopengles.com</a> <br>  ¬ª <a href="http://4pda.ru/forum/lofiversion/index.php%3Ft418429-50.html">W3bsit3-dns.com/forum/lofiversion</a> <br>  ¬ª <a href="https://developer.android.com/guide/topics/graphics/opengl.html">Developer.android.com/guide</a> </div><p>Source: <a href="https://habr.com/ru/post/309138/">https://habr.com/ru/post/309138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309126/index.html">How to work with MS Access in Linux</a></li>
<li><a href="../309128/index.html">Automating the maintenance of correspondence between the names of layers in the editor and code using CodeDom</a></li>
<li><a href="../309130/index.html">Communication Arrangements</a></li>
<li><a href="../309132/index.html">Once again about the benefits of backups or the story of my failure</a></li>
<li><a href="../309136/index.html">ADM interface - what is ‚ÄúTetrad‚Äù</a></li>
<li><a href="../309142/index.html">Private unstructured types and type reuse</a></li>
<li><a href="../309144/index.html">About alignment of memory on ARM processors on a simple example</a></li>
<li><a href="../309150/index.html">Constants do not change: a small excursion into the depths of dotNet</a></li>
<li><a href="../309152/index.html">Review of computer vision problems in medicine</a></li>
<li><a href="../309154/index.html">Some examples of the practical use of RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>