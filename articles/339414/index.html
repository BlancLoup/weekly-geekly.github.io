<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Promises in ES6: Patterns and Anti-Patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, when I started working at Node.js, I was horrified by what is now known as ‚Äú hell callbacks ‚Äù. But then from this hell to get out was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Promises in ES6: Patterns and Anti-Patterns</h1><div class="post__text post__text-html js-mediator-article">  A few years ago, when I started working at Node.js, I was horrified by what is now known as ‚Äú <a href="http://callbackhell.com/">hell callbacks</a> ‚Äù.  But then from this hell to get out was not so easy.  However, these days Node.js includes the latest, most interesting JavaScript features.  In particular, Node, starting with <a href="http://node.green/">version 4</a> , supports promises.  They allow you to get away from complex structures consisting of callbacks. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/339414/"><img src="https://habrastorage.org/getpro/habr/post_images/f98/f3a/de7/f98f3ade7e3ecc4b3c691067bef890d0.jpeg" alt="image"></a> <br><br>  Using promises instead of callbacks leads to writing more concise code that is easier to read.  However, to someone who is not familiar with them, they may not seem particularly clear.  In this article I want to show the basic templates of working with promises and share a story about the problems that their inept use can cause. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Please note that here I will use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> .  If you are not familiar with them, it is worth saying that they are made easy, but in this case I advise you to read the <a href="http://exploringjs.com/es6/ch_arrow-functions.html">material</a> about their features. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Patterns</font> </h2><br>  In this section, I will talk about promises, and how to use them correctly, demonstrating several patterns of their use. <br><br><h3>  <font color="#3AC1EF">‚ñçUse of promises</font> </h3><br>  If you use a third-party library that already supports promises, it‚Äôs pretty easy to use them.  Namely, you need to pay attention to two functions: <code>then()</code> and <code>catch()</code> .  For example, we have an API with three methods: <code>getItem()</code> , <code>updateItem()</code> , and <code>deleteItem()</code> , each of which returns a promise: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>) }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> {   item.amount++   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">update</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">1</span></span>); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error while working on item 1'</span></span>); })</code> </pre> <br>  Each <code>then()</code> call creates another step in the chain of promises.  If an error occurs anywhere in the chain, the <code>catch()</code> block is called, which is located behind the failed section.  The <code>then()</code> and <code>catch()</code> methods can either return a value or a new promise, and the result will be passed to the next <code>then()</code> operator in the chain. <br><br>  Here, for comparison, the implementation of the same logic using callbacks: <br><br><pre> <code class="hljs coffeescript">api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; item.amount++; api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, update)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   api.deleteItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   }) }) })</code> </pre> <br>  The first difference of this code fragment from the previous one is that in the case of callbacks, we must include error handling at each step of the process, instead of using a single block to handle all errors.  The second problem with callbacks is more related to style.  A block of code representing each of the steps is horizontally aligned, which makes it difficult to perceive the sequence of operations that is obvious when looking at the code based on promises. <br><br><h3>  <font color="#3AC1EF">‚ñç Conversion of callbacks into promises</font> </h3><br>  One of the first techniques that is useful to study when moving from callbacks to promises is to convert callbacks to promises.  The need for this may arise if, for example, you work with a library that still uses callbacks, or with your own code written with their use.  Going from callbacks to promises is not so difficult.  Here is an example of converting a Node <code>fs.readFile</code> function based on callbacks into a function that uses promises: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFilePromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   fs.readFile(filename, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, (err, data) =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err);     <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resolve(data);   }) }) } readFilePromise(<span class="hljs-string"><span class="hljs-string">'index.html'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e))</code> </pre> <br>  The cornerstone of this feature is the <code>Promise</code> designer.  It takes a function, which, in turn, has two parameters - <code>resolve</code> and <code>reject</code> , which are also functions.  Inside this function, all the work is done, and when we complete it, we call <code>resolve</code> if successful, and <code>reject</code> if an error has occurred. <br><br>  Note that the result must be caused by one thing - either <code>resolve</code> or <code>reject</code> , and this call must be executed only once.  In our example, if <code>fs.readFile</code> returns an error, we pass this error to <code>reject</code> .  Otherwise, we pass the file data to <code>resolve</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Conversion of values ‚Äã‚Äãinto promises</font> </h3><br>  In ES6, there are a couple of convenient helper functions for creating promises from ordinary values.  These are <code>Promise.resolve()</code> and <code>Promise.reject()</code> .  For example, you may have a function that needs to return a promise, but which handles some cases synchronously: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFilePromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filename) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Filename not specified"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filename === <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'&lt;h1&gt;Hello!&lt;/h1&gt;'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>}) }</code> </pre> <br>  Note that you can pass anything (or nothing) when calling <code>Promise.reject()</code> , however, it is recommended that you always pass an <code>Error</code> object to this method. <br><br><h3>  <font color="#3AC1EF">‚ñç Simultaneous execution of promises</font> </h3><br>  <code>Promise.all() ‚Äî</code> a convenient method for simultaneously executing an array of promises.  For example, let's say we have a list of files that we want to read from the disk.  Using the previously created <code>readFilePromise</code> function, the solution to this problem may look like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> filenames = [<span class="hljs-string"><span class="hljs-string">'index.html'</span></span>, <span class="hljs-string"><span class="hljs-string">'blog.html'</span></span>, <span class="hljs-string"><span class="hljs-string">'terms.html'</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(filenames.map(readFilePromise)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">files</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'index:'</span></span>, files[<span class="hljs-number"><span class="hljs-number">0</span></span>]);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'blog:'</span></span>, files[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'terms:'</span></span>, files[<span class="hljs-number"><span class="hljs-number">2</span></span>]); })</code> </pre> <br>  I will not even try to write equivalent code using traditional callbacks.  Suffice to say that such a code will be confusing and error prone. <br><br><h3>  <font color="#3AC1EF">‚ñçSecondary promises</font> </h3><br>  Sometimes the simultaneous execution of several promises can lead to trouble.  For example, if you try to get a lot of resources from the API using <code>Promise.all</code> , this is an API, after a while, when you exceed the limit on the frequency of calls to it, it may well start to generate <a href="httpstatuses.com/429">error 429</a> . <br><br>  One solution to this problem is to run the promises sequentially, one after the other.  Unfortunately, in ES6 there is no simple analogue of <code>Promise.al</code> l to perform such an operation (I would like to know why?), But the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce%3Fv%3Db">Array.reduce</a> method can help us here: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemIDs = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; itemIDs.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise, itemID</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(itemID)); }, <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve());</code> </pre> <br>  In this case, we want to wait for the current call to <code>api.deleteItem()</code> before making the next call.  This code demonstrates a convenient way of processing the operation, which would otherwise have to be rewritten using <code>then()</code> for each element identifier: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">2</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">3</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">4</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">5</span></span>));</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Promise Racing</font> </h3><br>  Another handy helper function that exists in ES6 (although I don‚Äôt use it very often) is <code>Promise.race</code> .  As well as <code>Promise.all</code> , it accepts an array of promises and executes them simultaneously, however, it is returned from it as soon as any of the promises is completed or rejected.  The results of other promises are discarded. <br><br>  For example, let's create a promise that completes with an error after some time, setting a limit on the operation to read a file represented by another promise: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(reject, ms); }) } <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([readFilePromise(<span class="hljs-string"><span class="hljs-string">'index.html'</span></span>), timeout(<span class="hljs-number"><span class="hljs-number">1000</span></span>)]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Timed out after 1 second"</span></span>))</code> </pre> <br>  Please note that other promises will continue to run - you just will not see their results. <br><br><h3>  <font color="#3AC1EF">‚ñç Interception of errors</font> </h3><br>  The usual way to trap errors in promises is to add a <code>.catch()</code> block to the end of the chain, which will intercept errors that occur in any of the preceding <code>.then()</code> blocks: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> {   item.amount++;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'failed to get or update item'</span></span>); })</code> </pre> <br>  The <code>catch()</code> block is called here if either <code>getItem</code> or <code>updateItem</code> fails.  But what if we don‚Äôt need joint error handling and need to handle errors occurring in <code>getItem</code> separately?  To do this, just insert another <code>catch()</code> block immediately after the block with the <code>getItem ‚Äî</code> call <code>getItem ‚Äî</code> it can even return another promise: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> api.createItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, {<span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>})) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> {   item.amount++;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'failed to update item'</span></span>); })</code> </pre> <br>  Now, if <code>getItem()</code> fails, we intervene and create a new item. <br><br><h3>  <font color="#3AC1EF">‚ñçFlashing errors</font> </h3><br>  The code inside the <code>then()</code> expression should be perceived as if it were inside a <code>try</code> block.  Both the <code>return Promise.reject()</code> call <code>return Promise.reject()</code> and the <code>throw new Error()</code> call will execute the next <code>catch()</code> block. <br><br>  This means that runtime errors also trigger <code>catch()</code> blocks, so when it comes to error handling, you should not make assumptions about their source.  For example, in the following code snippet, we can expect the <code>catch()</code> block to be called only to handle errors that occurred during <code>getItem</code> , but, as the example shows, it also responds to runtime errors that occur inside the <code>then()</code> expression: <br><br><pre> <code class="hljs pgsql">api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(item =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> item.<span class="hljs-keyword"><span class="hljs-keyword">owner</span></span>;   console.log(item.<span class="hljs-keyword"><span class="hljs-keyword">owner</span></span>.name); }) .catch(e =&gt; {   console.log(e); // Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> undefined })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçDynamic Promise Chains</font> </h3><br>  Sometimes you need to construct a chain of promises dynamically, that is, by adding additional steps when certain conditions are met.  In the following example, before reading the specified file, we, if necessary, create a lock file: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFileAndMaybeLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, createLockFile</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> promise = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (createLockFile) {   promise = promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> writeFilePromise(filename + <span class="hljs-string"><span class="hljs-string">'.lock'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> readFilePromise(filename)); }</code> </pre> <br>  In this situation, you need to update the <code>promise</code> value, using the construction of the form <code>promise = promise.then(/*...*/)</code> .  Associated with this example is what we will discuss below in the ‚ÄúMultiple .then () call‚Äù section. <br><br><h2>  <font color="#3AC1EF">Anti-patterns</font> </h2><br>  Promises are a neat abstraction, but working with them is full of pitfalls.  Here we look at some of the typical problems that I have encountered while working with promises. <br><br><h3>  <font color="#3AC1EF">‚ñç Reconstruction of hell callbacks</font> </h3><br>  When I started to switch from callbacks to promises, I found that it was hard to give up some old habits, and I found myself investing promises in each other just like callbacks: <br><br><pre> <code class="hljs javascript">api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> {   item.amount++;   api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item)     .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">update</span></span></span><span class="hljs-function"> =&gt;</span></span> {       api.deleteItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)         .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deletion</span></span></span><span class="hljs-function"> =&gt;</span></span> {           <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done!'</span></span>);         })     }) })</code> </pre> <br>  In practice, such structures are not required almost never.  Sometimes one or two levels of nesting can help group related tasks, but nested promises can almost always be rewritten as a vertical chain consisting of <code>.then()</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçLack of return command</font> </h3><br>  A common and harmful mistake I encountered is that they forget about calling <code>return</code> in the promise chain.  For example, can you find an error in this code? <br><br><pre> <code class="hljs javascript">api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> {   item.amount++;   api.updateItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, item); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">update</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.deleteItem(<span class="hljs-number"><span class="hljs-number">1</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deletion</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done!'</span></span>); })</code> </pre> <br>  The error is that we did not place a call to <code>return</code> before <code>api.updateItem</code> on line 4, and this particular block <code>then()</code> resolved immediately.  As a result, <code>api.deleteItem()</code> is likely to be called before the <code>api.updateItem()</code> call is completed. <br><br>  In my opinion, this is a major problem with ES6 promises, and it often leads to their unpredictable behavior.  The problem is that <code>then()</code> can return either a value or a new <code>Promise</code> object, but it can also return <code>undefined</code> .  Personally, if I were in charge of the JavaScript pre-API API, I would have provided for a run-time error if the <code>.then()</code> block returned <code>undefined</code> .  However, this is not implemented in the language, so now we only need to be careful and perform an explicit return from any promise we create. <br><br><h3>  <font color="#3AC1EF">‚ñç Multiple call .then ()</font> </h3><br>  In accordance with the documentation, it is possible to call <code>.then()</code> many times in the same promise, and callbacks will be called in the same order in which they are registered.  However, I have never seen a real reason for doing so.  Such actions can lead to incomprehensible effects when using return values ‚Äã‚Äãof promises and when handling errors: <br><br><pre> <code class="hljs pgsql">let p = Promise.resolve(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); p.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; <span class="hljs-string"><span class="hljs-string">'b'</span></span>); p.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(result =&gt; { console.log(result) // <span class="hljs-string"><span class="hljs-string">'a'</span></span> }) let q = Promise.resolve(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); q = q.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; <span class="hljs-string"><span class="hljs-string">'b'</span></span>); q = q.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(result =&gt; { console.log(result) // <span class="hljs-string"><span class="hljs-string">'b'</span></span> })</code> </pre> <br>  In this example, since we do not update the value of <code>p</code> on the next call to <code>then()</code> , we will never see the return of <code>'b'</code> .  Promis <code>q</code> more predictable; we update it every time by calling <code>then()</code> . <br><br>  The same applies to error handling: <br><br><pre> <code class="hljs coffeescript">let p = Promise.resolve(); p.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; {<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"whoops!"</span></span>)}) p.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello!'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'hello!'</span></span> }) let q = Promise.resolve(); q = q.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; {<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"whoops!"</span></span>)}) q = q.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      })</code> </pre> <br>  Here we expect an error to be issued that will interrupt the execution of the promise chain, but since the value of <code>p</code> not updated, we end up in the second <code>then()</code> . <br><br>  The multiple <code>.then()</code> call allows you to create several new independent promises from the original promise, however, I still have not managed to find a real use for this effect. <br><br><h3>  <font color="#3AC1EF">‚ñç Mixing callbacks and promises</font> </h3><br>  If you are using a library based on promises, but are working on a project based on callbacks, it‚Äôs easy to fall into another trap.  Avoid calling callbacks from <code>then()</code> or <code>catch() ‚Äî</code> blocks <code>catch() ‚Äî</code> otherwise, the promis will absorb all of the following errors, processing them as part of the promise chain.  Here is an example of wrapping a promise into a callback, which, at first glance, may seem quite suitable for practical use: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getThing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, item))   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> callback(e)); } getThing(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, thing</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(thing); })</code> </pre> <br>  The problem here is that in case of an error, we will get a warning "Unhandled promise rejection", despite the fact that the <code>catch()</code> block is present in the chain.  This is because the <code>callback()</code> is called both inside <code>then()</code> and inside <code>catch()</code> , which makes it part of the promise chain. <br><br>  If you absolutely need to wrap a promise in a callback, you can use the <code>setTimeout</code> , or <code>process.nextTick</code> function in Node.js to exit the promise: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getThing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ api.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, item)))   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> callback(e))); } getThing(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, thing</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(thing); })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçUncoordinated errors</font> </h3><br>  Error handling in JavaScript is a weird thing.  It supports the classic <code>try/catch</code> paradigm, but it does not support error handling in the called code by its calling construct, as it is done, for example, in Java.  However, in JS it is common to use callbacks, the first parameter of which is the error object (this callback is also called ‚Äúerrback‚Äù).  This forces the construct calling the method to at least consider the possibility of an error.  Here is an example with the <code>fs</code> library: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'index.html'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); })</code> </pre> <br>  When working with promises, it is easy to forget that errors must be explicitly handled.  This is especially true in those cases when it comes to operations that are susceptible to errors, such as commands for working with the file system or for accessing databases.  In the current environment, if you do not intercept the rejected promis, in Node.js you can see a rather ugly warning: <br><br><pre> <code class="hljs vhdl">(node:<span class="hljs-number"><span class="hljs-number">29916</span></span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-literal"><span class="hljs-literal">Error</span></span>: whoops! (node:<span class="hljs-number"><span class="hljs-number">29916</span></span>) DeprecationWarning: Unhandled promise rejections are deprecated. <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> the future, promise rejections that are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> handled will terminate the Node.js <span class="hljs-keyword"><span class="hljs-keyword">process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a non-zero <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> code.</code> </pre> <br>  To avoid this, do not forget to add <code>catch()</code> to the end of the promise chain. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We looked at some patterns and anti-patterns of using promises.  I hope you found something useful here.  However, the topic of promises is quite extensive, so here are a few links to additional resources: <br><br><ul><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Materials on promisam from Mozilla</a> <br></li><li>  <a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">Introduction to promises from Google</a> <br></li><li>  <a href="http://www.datchley.name/es6-promises/">Promise Review by Dave Atchley</a> <br></li><li>  <a href="http://www.datchley.name/promise-patterns-anti-patterns/">Here</a> and <a href="https://hackernoon.com/javascript-promises-best-practices-anti-patterns-b32309f65551">now</a> - additional materials on patterns and anti-patterns <br></li></ul><br>  Dear readers!  How do you use promises in your Node.js projects? </div><p>Source: <a href="https://habr.com/ru/post/339414/">https://habr.com/ru/post/339414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339404/index.html">We are improving communication between employers and applicants at My Circle (correspondence + company contact persons)</a></li>
<li><a href="../339406/index.html">C / C ++ code optimization</a></li>
<li><a href="../339408/index.html">Integration in Mars IS Service Service Desk Royal Canin</a></li>
<li><a href="../339410/index.html">Virtualization and Security</a></li>
<li><a href="../339412/index.html">What taxes you need to pay when displaying revenue from applications in Apple iTunes</a></li>
<li><a href="../339416/index.html">Android and sound: how to do it right</a></li>
<li><a href="../339418/index.html">DevOops 2017: report review</a></li>
<li><a href="../339420/index.html">Django ORM - slow? Optimize (hardcore)</a></li>
<li><a href="../339422/index.html">The 3 main processes that the CRM system must automate. Automate the conversion process. Part 2</a></li>
<li><a href="../339424/index.html">Aytreking: available solutions and their features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>