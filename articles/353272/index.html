<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>7 principles for designing container-based applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the end of last year, Red Hat published a report describing the principles that containerized applications have to comply with, striving to become ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>7 principles for designing container-based applications</h1><div class="post__text post__text-html js-mediator-article">  At the end of last year, Red Hat <a href="https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper">published a</a> report describing the principles that containerized applications have to comply with, striving to become an integral part of the ‚Äúcloud‚Äù world: ‚ÄúFollowing these principles will ensure application readiness for automation on cloud-based applications such as Kubernetes "- believe in Red Hat.  And we, having studied this document, agree with their conclusions, and therefore we decided to share them with the Russian-speaking IT community. <br><br><img src="https://habrastorage.org/webt/kc/6i/wh/kc6iwhtpqlgvva0qcebt8fcfogy.png"><br><br>  <i>Please note that this article is <b>not a</b> literal translation of the original document ( <a href="https://www.redhat.com/cms/managed-files/cl-cloud-native-container-design-whitepaper-f8808kc-201710-v3-en.pdf">PDF</a> ) prepared by <a href="https://developers.redhat.com/blog/author/bibryam/">Bilgin Ibryam</a> - an architect from Red Hat, an active participant in several Apache projects and the author of the books Camel Design Patterns and Kubernetes Patterns - but presents its main points. in a rather free manner.</i> <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a rule, with cloud-based (cloud native) applications, failures can be foreseen, and their operation and scaling is possible even when the underlying infrastructure has problems.  To make this possible, platforms designed to run such applications impose certain obligations and restrictions on the applications launched in them.  In short, the application is not enough just to put in a container and run - the possibility of its effective orchestration in platforms like Kubernetes requires additional efforts.  What are they? <br><br><h2>  Red Hat's approach to cloud native applications </h2><br>  The ideas proposed here are inspired by various other works (for example, <br>  <a href="https://12factor.net/">The Twelve-Factor App</a> ), covering many areas: from source code management to application scalability models.  However, the scope of the principles discussed here is limited to the design of containerized applications based on microservices for cloud native platforms like Kubernetes. <br><br>  In the description of all principles, the container image is used as the primary primitive, and the container orchestration platform is used as the target environment for its launch.  Following these principles is intended to ensure that (prepared in accordance with them) containers will receive full support in most orchestration engines, i.e.  will be serviced by the scheduler, scaled and monitored automatically.  Principles are listed in random (rather than priority) order. <br><br><h3>  1. Single Concern Principle (SCP) </h3><br>  In many ways, SCP is similar to the Single Responsibility Principle (SRP) <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">principle</a> in <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID</a> , which means that each class must have one <i>responsibility</i> .  The motivation behind the SRP - there must be only one reason that can lead to a class change. <br><br>  The word ‚Äúconcern‚Äù <i>(translated as ‚Äúconcern‚Äù, ‚Äúconcern‚Äù, ‚Äúinterest‚Äù, ‚Äútask‚Äù)</i> emphasizes that <i>concern</i> is a higher level of abstraction than <i>responsibility</i> , which better describes the range of container tasks (compared to the class).  If the main motivation for SRP is the only reason for a change, then for SCP it is the ability to reuse the container image and its substitutability.  If you create a container that is responsible for one task, and it solves it completely, the likelihood of reusing this image grows in other circumstances. <br><br>  In general, the principle of SCP says that each container should solve a single problem and do it well. <i>A classic from UNIX philosophy - <a href="https://en.wikipedia.org/wiki/Unix_philosophy">DOTADIW comes to mind</a> , ‚ÄúDo one thing and do it well‚Äù - <b>comment</b></i> .  If microservice needs to be responsible for many problems, you can use patterns such as sidecar- and init-containers to combine multiple containers into a single deployable platform (under), where each container will continue to be engaged in the only task. <br><br><img src="https://habrastorage.org/webt/65/i5/29/65i529339yrmo0_aclj0liraabm.png"><br><br><h3>  2. High Observability Principle (HOP) </h3><br>  Containers - a unified way to pack and run applications that turns them into a ‚Äúblack box‚Äù.  However, any container must provide application programming interfaces (APIs) for the environment in which it runs, making it possible to monitor the state and behavior of the container.  This is a necessary condition for the possibility of automating container updates and maintaining its life cycle. <br><br>  From a practical point of view, a containerized application should provide at least (at least!) An API for various checks of its state: <i>liveness</i> and readiness.  It is even better if other ways are offered to monitor the state of the application - in particular, logging important events in STDERR and STDOUT for their subsequent aggregation with utilities like Fluentd and Logstash, integration with tools for assembling metrics: OpenTracing, Prometheus, etc. <br><br><img src="https://habrastorage.org/webt/mw/v2/l0/mwv2l0u_flaeiwdcafssz0g4vaw.png"><br><br>  The conclusion is: treat your application as a black box, but implement all the necessary APIs that help the platform monitor and manage the application as well as possible. <br><br><h3>  3. Life-cycle Conformance Principle (LCP) </h3><br>  If HOP speaks of providing APIs from which the platform can ‚Äúread‚Äù, then the LCP is the other side: your application should be able to learn about events from the platform.  And even more: not only to learn about them, but also to react to them - hence the name of this principle <i>(‚Äúconformance‚Äù is translated as ‚Äúcomply‚Äù, ‚Äúagree‚Äù, ‚Äúobey the rules‚Äù)</i> . <br><br>  The management platform may have many events that will help in managing the life cycle of the container, but some of them are more important than others.  For example, for the process to shut down correctly, the application needs to receive a message with the appropriate signal (SIGTERM) in order to avoid an urgent termination of work through SIGKILL.  There are other significant events - for example, PostStart and PreStop, which are necessary for the application to ‚Äúwarm up‚Äù at the beginning of its operation or, conversely, freeing resources at the end. <br><br><h3>  4. Image Immutability Principle (IIP) </h3><br>  In containerized applications <i>immutability is</i> laid down: they are collected once, after which they are launched without changes in different environments.  This implies the use of external tools for storing the data used in their work, as well as the creation / use of various configurations for different environments.  Any change in a containerized application should result in building a new container image that will be used in all environments.  The same principle, known as the immutable infrastructure, is used to manage the server infrastructure. <br><br><img src="https://habrastorage.org/webt/fp/gx/j3/fpgxj3tklkr4o1azimmzzwcca7c.png"><br><br><h3>  5. Process Disposability Principle (PDP) </h3><br>  One of the main reasons for switching to containerized applications is that containers should be as short-lived as possible and ready to be replaced with another container at any time.  There may be a lot of reasons to replace the container: status checking, backscaling <i>(scale down) of an</i> application, migration to another host, lack of resources ... <br><br>  Therefore, containerized applications need to keep their state distributed and redundant.  In addition, the application must quickly start and stop and even be ready for a sudden (and complete) hardware failure.  Another useful practice in the implementation of this principle is the creation of small containers, since  containers run automatically on different hosts, and their smaller size will speed up startup time (since they must first be physically copied to the host system). <br><br><h3>  6. Self-Containment Principle (S-CP) </h3><br>  The container should contain everything needed at the time of assembly, relying only on the presence of the Linux kernel (all additional libraries "appear" at the time of assembly).  In addition to libraries, this also means the need to contain executable environments of programming languages, an application platform (if used), and any other dependencies for running a containerized application.  The only exception here is configurations that will be different in different environments and should be provided during launch (for example, <code>ConfigMap</code> in Kubernetes). <br><br><img src="https://habrastorage.org/webt/bk/hz/r7/bkhzr7xo2lw30irm91i8eihjwwi.png"><br><br>  Some applications consist of multiple containerized components.  For example, a containerized web application may require a container with a database.  This principle does not propose to merge containers: just the container with the database should have everything necessary for its operation, and the container with the web application for the operation of the web application (web server, etc.). <br><br><h3>  7. Runtime Confinement Principle (RCP) </h3><br>  The S-CP principle considers containers from the perspective of build time and the resulting binary with its contents, but a container is not a one-dimensional black box lying on a disk.  Other container ‚Äúdimensions‚Äù appear when it is launched ‚Äî these are ‚Äúdimensions‚Äù of the consumption of memory, processor and other resources. <br><br><img src="https://habrastorage.org/webt/xw/o0/ks/xwo0ks_3e7sufblk0yrw3ffwshy.png"><br><br>  Any container must declare its resource requirements and pass this information to the platform, since its requests to the CPU, memory, network, disk affect how the platform performs scheduling, autoscaling, resource management, and provides a general SLA level for the container.  In addition, it is important that the application fit into the resources allocated to it.  In the event of a shortage of resources, the platform is less likely to stop or migrate such containers. <br><br><h2>  Other recommendations </h2><br>  In addition to these principles, less fundamental, but often useful, container practices are also offered: <br><br><ul><li>  Aim for small looks.  Delete temporary files and avoid installing unnecessary packages.  This reduces not only the size of the container, but also the build time and the time it takes to transfer data over the network when copying images. </li><li>  Support any UID.  Avoid using the sudo command or a specific user / UID requirement to start the container. </li><li>  Mark important ports.  Their designation using the <code>EXPOSE</code> command simplifies the use of images for both people and software. </li><li>  Use volumes for persistent data (such that must be saved after container destruction). </li><li>  Identify metadata in images - using tags, labels, annotations.  This simplifies their further use by developers. </li><li>  Synchronize the host and image.  Some containerized applications may require synchronization with the host for certain attributes (for example, time and machine ID). </li></ul><br>  Links to additional resources on patterns and best practices on the topic: <br><br><ul><li>  <a href="https://www.slideshare.net/luebken/container-patterns">Container Patterns</a> <i>(Matthias Luebken)</i> ; </li><li>  <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices">Best practices for writing Dockerfiles</a> <i>(Docker)</i> ; </li><li>  <a href="http://docs.projectatomic.io/container-best-practices">Container Best Practices</a> <i>(Project Atomic)</i> ; </li><li>  <a href="https://docs.openshift.com/enterprise/3.0/creating_images/guidelines.html">OpenShift Enterprise 3.0 Creating Images Guidelines</a> <i>(Red Hat)</i> ; </li><li>  <a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf">Design patterns for container-based distributed systems</a> <i>(Brendan Burns, David Oppenheimer)</i> ; </li><li>  <a href="https://leanpub.com/k8spatterns/">Kubernetes Patterns</a> <i>(Bilgin Ibryam, Roland Hu√ü)</i> ; </li><li>  <a href="https://12factor.net/">The Twelve-Factor App</a> <i>(Adam Wiggins)</i> . </li></ul><br><h2>  PS from translator </h2><br>  Some of these principles - in particular, Image Immutability Principle (IIP), which we called as ‚ÄúOne image to rule them all‚Äù, and Self-Containment Principle (S-CP) - were described in our report ‚Äú <a href="https://habrahabr.ru/company/flant/blog/345116/">Best Practices CI / CD with Kubernetes and GitLab</a> ‚Äù <i>(click on the text and full video)</i> . <br><br>  Read also in our blog: <br><br><ul><li>  ‚ÄúThe <a href="https://habrahabr.ru/company/flant/blog/347518/">Death of Microservice Madness in 2018</a> ‚Äù; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/350928/">CNCF Guide to Open Source Solutions (and more) for cloud native</a> "; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/346418/">How many developers think Continuous Integration is not needed?</a>  "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> " <i>(video of the report, which includes an introduction to the technical device Kubernetes).</i> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/353272/">https://habr.com/ru/post/353272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353262/index.html">JS DevDay: about titanium, workers and hybrids</a></li>
<li><a href="../353264/index.html">Kubernetes developers answer questions from Reddit users</a></li>
<li><a href="../353266/index.html">The latest version of updates for our superpowers. Review of the book by Dan Roham "Draw to win"</a></li>
<li><a href="../353268/index.html">JPoint 2018: Debriefing</a></li>
<li><a href="../353270/index.html">Five Myths about Data Science</a></li>
<li><a href="../353274/index.html">Tips and Tricks for an IT Administrator: Deploying a Different OS with Windows Deployment Services</a></li>
<li><a href="../353276/index.html">UI tests in iOS project. Is there a profit and why are they being introduced at all?</a></li>
<li><a href="../353280/index.html">Nagios-traffic light from the Chinese blocks</a></li>
<li><a href="../353282/index.html">Hackers attacked Poloniex users with a fake mobile application</a></li>
<li><a href="../353284/index.html">The smallest computer in the world, an energy efficient chip and other innovations for IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>