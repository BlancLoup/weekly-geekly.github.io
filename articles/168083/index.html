<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Combining C ++ and Python. Subtleties Boost.Python. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boost.Python is in all respects a wonderful library that fulfills its purpose for 5+, whether you want to make a C ++ module for Python or if you want...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Combining C ++ and Python. Subtleties Boost.Python. Part one</h1><div class="post__text post__text-html js-mediator-article">  Boost.Python is in all respects a wonderful library that fulfills its purpose for 5+, whether you want to make a C ++ module for Python or if you want to build a Python script binding for a native application written in C ++. <br>  The most difficult thing in Boost.Python is an abundance of subtleties, since C ++ and Python are two languages ‚Äã‚Äãfull of possibilities, and therefore at the junction they have to take into account all the nuances: pass an object by reference or value, give Python a copy of an object or an existing class, convert to the internal Python type or to the wrapper written in C ++, how to pass the object constructor, overload the operators, hang non-existent in C ++, but are necessary in Python methods. <br>  I do not promise that in my examples I will describe all the subtleties of the interaction of these fundamental languages, but I will try to immediately cover as many frequently used examples as possible so that you don‚Äôt climb into every documentation for every little thing and see all the necessary basics here, or at least get a basic idea about them . <br><a name="habracut"></a><br><h4>  Table of contents </h4><br><ul><li>  <a href="http://habrahabr.ru/post/168083/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168083/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168083/">Part one</a> </li><li>  <a href="http://habrahabr.ru/post/168233/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168233/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168233/">Part two</a> </li><li>  <a href="http://habrahabr.ru/post/168827/">Type conversion to Boost.Python.</a>  <a href="http://habrahabr.ru/post/168827/">We do the conversion between the usual types of C + + and Python</a> </li><li>  <a href="http://habrahabr.ru/post/169639/">Exception travel between C ++ and Python or "Back and forth"</a> </li></ul><br><h4>  Introduction </h4><br>  We presume that you already have a handy toolkit for building a dynamically linked library in C ++, and also a Python interpreter installed. <br>  You will also need to download the <a href="http://www.boost.org/users/download/">Boost</a> library, and then compile it, following the instructions for your <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/windows.html">Windows</a> or <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/unix-variants.html">Linux</a> operating <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/windows.html">system</a> . <br>  In a nutshell, on Windows, all actions are reduced to two lines on the command line.  Unzip the downloaded Boost archive to any place on the disk, go there in the command line and type in succession two commands: <br><pre><code class="bash hljs">bootstrap b2 --build-type=complete stage</code> </pre> <br>  To build x64, add the argument <b>address-model = 64</b> <br>  If you already have a Boost library, but you did not install Python, or you downloaded and installed a fresh Python interpreter and want to build only Boost.Python, this is done with the additional key <b>--with-python</b> <br>  That is, the entire line for building only Boost.Python with 64-bit addressing looks like this: <br><pre> <code class="bash hljs">b2 --build-type=complete address-model=64 --with-python stage</code> </pre><br>  It is worth noting that the x64 assembly should be ordered if you have Python x64 installed.  Also, modules for it will need to be assembled with 64-bit addressing. <br>  The <b>--with-python</b> key will save you a lot of time if you from the Boost library have nothing but Boost.Python functionality. <br>  If you have several interpreters installed, I highly recommend reading the detailed documentation on building <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/building.html">Boost.Python</a> <br>  After the build, you will have the Boost.Python libraries compiled in the Boost \ stage \ lib folder, we will need them very soon. <br><br><h4>  We configure the project on a C ++ </h4><br>  We create a project to create a dynamically linkable library in C ++, I suggest calling it example. <br>  After creating the project, you need to specify additional INCLUDE <u>Python \ include</u> directories and <u>Boost</u> root, as well as directories for searching the <u>Python \ libs</u> and <u>Boost \ stage \ lib</u> libraries <br>  Under Windows, in the settings of Post-build events you should also set the renaming of $ (TargetPath) into a module with the example.pyd extension in the project root. <br>  It may also be worth copying the assembled Boost.Python libraries to the directory with the module being built. <br>  Connecting the module after running the interpreter in the same directory will be reduced to one command: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre><br>  Do not forget about the build for x64 if you build for 64-bit Python. <br><br><h4>  Normal class with simple fields. </h4><br>  So, let's get our new project three files at once: <br>  some.h <br>  some.cpp <br>  wrap.cpp 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In some.h and some.cpp files we describe some wonderful class Some, which we wrap for Python in the example module in the wrap.cpp file ‚Äî for this, you should include &lt;boost / python.hpp&gt; in the wrap.cpp file and use the BOOST_PYTHON_MODULE macro (example ) {...}, also for brevity, it is not at all superfluous to use using namespace boost :: python.  In general, our future module will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/python.hpp&gt; ... using namespace boost::python; ... BOOST_PYTHON_MODULE( example ) { ... } ...</span></span></span></span></code> </pre><br><br>  In the file some.h we should build the declaration of our wonderful class.  To explain most of the basic mechanisms, we need only two fields: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mID; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> mName;</code> </pre><br>  Suppose a class contains a description of something that has a name and an integer identifier.  Oddly enough, this simple class will cause a lot of difficulties, due mainly to the standard string class, method overloads, a constant reference, and the NOT_AN_IDENTIFIER static property, which of course we will also introduce: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NOT_AN_IDENTIFIER = <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br>  Of course, this constant is needed as an identifier for the object created by the default constructor, we also describe another constructor that defines both fields: <br><pre> <code class="cpp hljs"> Some(); Some( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> some_id, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; name );</code> </pre><br>  In the file some.cpp we will describe the implementation of these constructors, I will not describe the implementation in the future, but let's write the constructors together: <br><pre> <code class="cpp hljs">Some::Some() : mID(NOT_AN_IDENTIFIER) { } Some::Some( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> some_id, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; name ) : mID(some_id), mName(name) { }</code> </pre><br>  Simultaneously with the appearance of the Some class, the Python class wrapper will appear in the wrap.cpp file: <br><pre> <code class="cpp hljs">BOOST_PYTHON_MODULE( example ) { class_&lt;Some&gt;( <span class="hljs-string"><span class="hljs-string">"Some"</span></span> ) .def( init&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;( args( <span class="hljs-string"><span class="hljs-string">"some_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) ) ) ; }</code> </pre><br>  It uses shameless optical illusion and the template boost :: python :: class_, which creates a class description for Python in the specified module using Python C-API, which is terribly complex and incomprehensible when describing methods, and therefore completely hidden behind the declaration of the simple def () method on every line. <br>  The default constructor and the copy constructor are created for the default object, unless otherwise indicated, but we will touch upon this a little lower. <br>  Already, you can assemble a module, import it from the Python interpreter, and even create an instance of the class, but we still cannot read its properties or call methods until it is physically absent. <br>  Let's fix it, create the ‚Äúrichest‚Äù API of our class miracle.  Here is the full code of our header file some.h: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; using std::string; class Some { public: static const int NOT_AN_IDENTIFIER = -1; Some(); Some( int some_id, string const&amp; name ); int ID() const; string const&amp; Name() const; void ResetID(); void ResetID( int some_id ); void ChangeName( string const&amp; name ); void SomeChanges( int some_id, string const&amp; name ); private: int mID; string mName; };</span></span></span></span></code> </pre><br><br>  Since the implementation of the methods has also turned out to be rather short, let's quote the code some.cpp: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some.h"</span></span></span><span class="hljs-meta"> Some::Some() : mID(NOT_AN_IDENTIFIER) { } Some::Some( int some_id, string const&amp; name ) : mID(some_id), mName(name) { } int Some::ID() const { return mID; } string const&amp; Some::Name() const { return mName; } void Some::ResetID() { mID = NOT_AN_IDENTIFIER; } void Some::ResetID( int some_id ) { mID = some_id; } void Some::ChangeName( string const&amp; name ) { mName = name; } void Some::SomeChanges( int some_id, string const&amp; name ) { mID = some_id; mName = name; }</span></span></code> </pre><br>  Well, it's time to describe the wrapper in the wrap.cpp file: <br>  The first method Some :: ID () turns around without any problems: <br><pre> <code class="cpp hljs"> .def( <span class="hljs-string"><span class="hljs-string">"ID"</span></span>, &amp;Some::ID )</code> </pre><br>  But the second with the result in the form of a constant link to the string already shows that everything is not so simple: <br><pre> <code class="cpp hljs"> .def( <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, &amp;Some::Name, return_value_policy&lt;copy_const_reference&gt;() )</code> </pre><br>  As you can see, you can specify how Python should interpret the return value if the method in C ++ returns a pointer or reference.  The fact is that the atrocious Garbage Collector (GC) loves to delete everything that is unattended, so no one will give you a simple way to declare a return pointer or reference method, it will sadly end at the compilation stage, because the GC should know what to do with the returned value. for the developer it will be very sad if he starts to delete the contents of an object in C ++.  There are several options for <a href="http://wiki.python.org/moin/boost.python/CallPolicy">return_value_policy for different cases</a> , the most important of which are as follows: <br><ul><li>  <b>copy_non_const_reference</b> - creates a new object in Python that contains a <b>non-</b> constant object reference in C ++, does not require a wrapper for a class from C ++ (example: string does not have a wrapper, only a converter to Python str) </li><li>  <b>copy_const_reference</b> - creates a new object in Python that contains a constant object reference in C ++, does not require wrappers for a class from C ++ (example: the same string) </li><li>  <b>manage_new_object</b> - creates a new object in Python using a class wrapper from C ++, the content is deleted upon completion </li><li>  <b>reference_existing_object</b> - creates a new object in Python using a class wrapper from C ++, the content remains at the end </li></ul><br>  Understanding how this or that return_value_policy works in detail comes with time, experiment, try, read the documentation and tamper.  For a standard string, the reference is almost always <b>copy_const_reference</b> or <b>copy_non_const_reference</b> depending on the constancy of the return, just remember, because  String by value is converted at the Python level into an object of the built-in class <b>str</b> , and by reference you must explicitly specify <b>return_value_policy</b> . <br><br>  I intend to overload the Some :: ResetID method to complicate the task of passing a pointer to a method in .def (): <br><pre> <code class="cpp hljs"> .def( <span class="hljs-string"><span class="hljs-string">"ResetID"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (Some::*)() &gt;( &amp;Some::ResetID ) ) .def( <span class="hljs-string"><span class="hljs-string">"ResetID"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (Some::*)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) &gt;( &amp;Some::ResetID ), args( <span class="hljs-string"><span class="hljs-string">"some_id"</span></span> ) )</code> </pre><br><br>  As you can see, you can specify with what name the method argument will be created in Python.  As you know, the name of the argument in Python is more important than in C ++.  I recommend to specify the names of the arguments for each wrapper method that takes parameters: <br><pre> <code class="cpp hljs"> .def( <span class="hljs-string"><span class="hljs-string">"ChangeName"</span></span>, &amp;Some::ChangeName, args( <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) ) .def( <span class="hljs-string"><span class="hljs-string">"SomeChanges"</span></span>, &amp;Some::SomeChanges, args( <span class="hljs-string"><span class="hljs-string">"some_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) )</code> </pre><br><br>  It remains to describe the constant property NOT_AN_IDENTIFIER with a static property: <br><pre> <code class="cpp hljs"> .add_static_property( <span class="hljs-string"><span class="hljs-string">"NOT_AN_IDENTIFIER"</span></span>, make_getter( &amp;Some::NOT_AN_IDENTIFIER ) )</code> </pre><br>  Here we use the special function boost :: python :: make_getter, which generates a get-function by class property. <br>  This is what our wrapper looks like: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/python.hpp&gt; #include "some.h" using namespace boost::python; BOOST_PYTHON_MODULE( example ) { class_&lt;Some&gt;( "Some" ) .def( init&lt;int,string&gt;( args( "some_id", "name" ) ) ) .def( "ID", &amp;Some::ID ) .def( "Name", &amp;Some::Name, return_value_policy&lt;copy_const_reference&gt;() ) .def( "ResetID", static_cast&lt; void (Some::*)() &gt;( &amp;Some::ResetID ) ) .def( "ResetID", static_cast&lt; void (Some::*)(int) &gt;( &amp;Some::ResetID ), args( "some_id" ) ) .def( "ChangeName", &amp;Some::ChangeName, args( "name" ) ) .def( "SomeChanges", &amp;Some::SomeChanges, args( "some_id", "name" ) ) .add_static_property( "NOT_AN_IDENTIFIER", make_getter( &amp;Some::NOT_AN_IDENTIFIER ) ) ; }</span></span></span></span></code> </pre><br>  If you write a simple test script like this (Python 3.x): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * s = Some() print( <span class="hljs-string"><span class="hljs-string">"s = Some(); ID: {ID}, Name: {Name}"</span></span>.format(ID=s.ID(),Name=s.Name()) ) s = Some(<span class="hljs-number"><span class="hljs-number">123</span></span>,<span class="hljs-string"><span class="hljs-string">'asd'</span></span>) print( <span class="hljs-string"><span class="hljs-string">"s = Some(123,'asd'); ID: {ID}, Name: {Name}"</span></span>.format(ID=s.ID(),Name=s.Name()) ) s.ResetID(<span class="hljs-number"><span class="hljs-number">234</span></span>); print(<span class="hljs-string"><span class="hljs-string">"s.ResetID(234); ID:"</span></span>,s.ID()) s.ResetID(); print(<span class="hljs-string"><span class="hljs-string">"s.ResetID(); ID:"</span></span>,s.ID()) s.ChangeName(<span class="hljs-string"><span class="hljs-string">'qwe'</span></span>); print(<span class="hljs-string"><span class="hljs-string">"s.ChangeName('qwe'); Name:'%s'"</span></span> % s.Name()) s.SomeChanges(<span class="hljs-number"><span class="hljs-number">345</span></span>,<span class="hljs-string"><span class="hljs-string">'zxc'</span></span>) print( <span class="hljs-string"><span class="hljs-string">"s.SomeChanges(345,'zxc'); ID: {ID}, Name: {Name}"</span></span>.format(ID=s.ID(),Name=s.Name()) )</code> </pre><br>  We will see the conclusion: <br><pre> <code class="python hljs">s = Some(); ID: <span class="hljs-number"><span class="hljs-number">-1</span></span>, Name: <span class="hljs-string"><span class="hljs-string">''</span></span> s = Some(<span class="hljs-number"><span class="hljs-number">123</span></span>,<span class="hljs-string"><span class="hljs-string">'asd'</span></span>); ID: <span class="hljs-number"><span class="hljs-number">123</span></span>, Name: <span class="hljs-string"><span class="hljs-string">'asd'</span></span> s.ResetID(<span class="hljs-number"><span class="hljs-number">234</span></span>); ID: <span class="hljs-number"><span class="hljs-number">234</span></span> s.ResetID(); ID: <span class="hljs-number"><span class="hljs-number">-1</span></span> s.ChangeName(<span class="hljs-string"><span class="hljs-string">'qwe'</span></span>); Name:<span class="hljs-string"><span class="hljs-string">'qwe'</span></span> s.SomeChanges(<span class="hljs-number"><span class="hljs-number">345</span></span>,<span class="hljs-string"><span class="hljs-string">'zxc'</span></span>); ID: <span class="hljs-number"><span class="hljs-number">345</span></span>, Name: <span class="hljs-string"><span class="hljs-string">'zxc'</span></span></code> </pre><br><br><h4>  Pythonize class wrapper </h4><br>  So, the class with all the methods wrapped, but happiness did not come.  If you try to execute Some (123, 'asd') from the Python command line, you will not see descriptions of the fields and the object in general, since we did not get the __repr__ method, as well as the conversion to the string, the same print (Some (123, 'asd' )) It will be terribly non-informative, since we did not get the __str__ method.  It is also obvious that it does not make sense to work with properties through methods on C ++ on Python, we do not have the ability to start property in C ++, you can and need to start them in Python.  However, how do we attach methods to a ready-made C ++ class intended for Python? <br>  Very simple: remember that in Python, methods are no different from functions that take a reference to self, the class instance, as the first parameter.  We start such functions directly in wrap.cpp in C ++ and describe them as methods in a wrapper: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>string Some_Str( Some const&amp; ); string Some_Repr( Some const&amp; ); ... BOOST_PYTHON_MODULE( example ) { class_&lt;Some&gt;( <span class="hljs-string"><span class="hljs-string">"Some"</span></span> ) ... .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span>( <span class="hljs-string"><span class="hljs-string">"__str__"</span></span>, Some_Str ) .<span class="hljs-keyword"><span class="hljs-keyword">def</span></span>( <span class="hljs-string"><span class="hljs-string">"__repr__"</span></span>, Some_Repr ) ...</code> </pre><br>  The functions themselves can be described for example like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_Str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; some )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> output; output &lt;&lt; <span class="hljs-string"><span class="hljs-string">"{ ID: "</span></span> &lt;&lt; some.ID() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", Name: '"</span></span> &lt;&lt; some.Name() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' }"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output.str(); } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_Repr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; some )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Some: "</span></span> + Some_Str( some ); }</code> </pre><br><br>  The properties of the identifier and the name are even simpler, since the set and get methods for them are already described in the class: <br><pre> <code class="cpp hljs"> .add_property( <span class="hljs-string"><span class="hljs-string">"some_id"</span></span>, &amp;Some::ID, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (Some::*)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) &gt;( &amp;Some::ResetID ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"name"</span></span>, make_function( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; (Some::*)() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &gt;( &amp;Some::Name ), return_value_policy&lt;copy_const_reference&gt;() ), &amp;Some::ChangeName )</code> </pre><br><br>  When describing the properties, however, there were two subtle points: <br>  1. For the set-method of the property some_id there was an explicit cast to the type of the method that accepts an int, since  There is another method overload. <br>  2. For the get-method of the name property, we used the construction boost :: python :: make_function, which allowed us to hang return_value_policy on the result of the method that returns a constant reference to string. <br><br>  We execute print (Some (123, 'asd')) and just Some (123, 'asd') from the command line after from example import * and see what is suspiciously similar to the built-in Python dict: {ID: 123, Name: 'asd' } <br>  Why not get the property initializing a copy of Some from the standard dict and back? <br>  Let's get another pair of pitonistic functions and get the as_dict property: <br><pre> <code class="cpp hljs">... <span class="hljs-function"><span class="hljs-function">dict </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_ToDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_FromDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some&amp;, dict </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span></span>; ... BOOST_PYTHON_MODULE( example ) { class_&lt;Some&gt;( <span class="hljs-string"><span class="hljs-string">"Some"</span></span> ) ... .add_property( <span class="hljs-string"><span class="hljs-string">"as_dict"</span></span>, Some_ToDict, Some_FromDict ) ; ... } ... <span class="hljs-function"><span class="hljs-function">dict </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_ToDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; some )</span></span></span><span class="hljs-function"> </span></span>{ dict res; res[<span class="hljs-string"><span class="hljs-string">"ID"</span></span>] = some.ID(); res[<span class="hljs-string"><span class="hljs-string">"Name"</span></span>] = some.Name(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some_FromDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Some&amp; some, dict </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span><span class="hljs-function"> </span></span>{ src.has_key( <span class="hljs-string"><span class="hljs-string">"ID"</span></span> ) ? some.ResetID( extract&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( src[<span class="hljs-string"><span class="hljs-string">"ID"</span></span>] ) ) : some.ResetID(); some.ChangeName( src.has_key( <span class="hljs-string"><span class="hljs-string">"Name"</span></span> ) ? extract&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;( src[<span class="hljs-string"><span class="hljs-string">"Name"</span></span>] ) : <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>() ); }</code> </pre><br>  Here we used the class boost :: python :: dict, for access at the C ++ level to the standard dict Python. <br>  There are also classes for accessing str, list, tuple, they are called respectively.  Classes behave in C ++ in the same way as in Python in terms of operators, only return for the most part boost :: python :: object, from which you still need to extract the value through the function boost :: python :: extract. <br><br><h4>  In conclusion, the first part </h4><br>  In the first part, a completely standard class with a default constructor and a default copy constructor was considered.  Despite some subtleties with working with strings, and overloading methods, the class is quite standard. <br>  Working with Boost.Python is quite simple, the wrapper of any function is usually reduced to a single line that looks like a similar method declaration in Python. <br>  In the next part, we will learn how to wrap classes that are not so trivially created, create a class based on the structure, wrap enum, and learn about other important return_value_policy &lt;reference_existing_object&gt; in practice. <br>  In the third part, we will consider type converters to standard Python types directly without wrappers using the example of an array of bytes.  Let's learn to forward exceptions of a certain type from C ++ to Python and back. <br>  The topic is quite extensive. <br><br><h4>  Link to the project </h4><br>  The draft of the first part for Windows is laid out <a href="http://www.megafileupload.com/en/file/389466/example-7z.html">here</a> . <br>  The MSVS v11 project is configured to build with Python 3.3 x64.  The compiled .dll Boost.Python of the appropriate version is attached. <br>  But nothing prevents you from collecting the files some.h, some.cpp, wrap.cpp with any other build tool with reference to any other version of Python. <br><br><h4>  useful links </h4><br>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/">Boost.Python Documentation</a> <br>  <a href="http://wiki.python.org/moin/boost.python/CallPolicy">Policies return values ‚Äã‚Äãby reference in Boost.Python</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/windows.html">Getting Started with Boost for Windows</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/unix-variants.html">Getting started with Boost for * nix</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/building.html">Boost.Python build subtleties</a> </div><p>Source: <a href="https://habr.com/ru/post/168083/">https://habr.com/ru/post/168083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168073/index.html">Hi, JavaFX! Let's get acquainted?</a></li>
<li><a href="../168075/index.html">Working with structures or how I learned to write readable code</a></li>
<li><a href="../168077/index.html">Hor + vert + FOV, or adaptive field of view</a></li>
<li><a href="../168079/index.html">The story of a single SQL injection</a></li>
<li><a href="../16808/index.html">Loveplanet.ru launched the service "Video"</a></li>
<li><a href="../168085/index.html">Development of GPS tracker from scratch and 512 months warranty</a></li>
<li><a href="../168087/index.html">Supercomputer for 1 billion euros: a simulation of the human brain</a></li>
<li><a href="../168089/index.html">Qt 5.0.1 and Qt Creator 2.6.2 released</a></li>
<li><a href="../16809/index.html">Nasdaq compiles the dot-com index</a></li>
<li><a href="../168091/index.html">LiveReload on Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>