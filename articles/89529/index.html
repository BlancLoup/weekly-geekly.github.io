<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Weak events in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 Recently, in a project where I work, we are faced with a memory leak problem. After reading a lot of articles, from stories on memor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Weak events in C #</h1><div class="post__text post__text-html js-mediator-article"><h3>  From translator </h3><br>  Recently, in a project where I work, we are faced with a memory leak problem.  After reading a lot of articles, from stories on memory management in .NET to practical recommendations on the correct release of resources, I also came across an article that tells how to use events correctly.  I want to present her translation. <br>  This is a topic from the sandbox with which I got here on Habr. <br><br><a name="habracut"></a><br><h3>  Introduction </h3><br>  When using ordinary events in C #, subscribing to an event creates a link from the object containing the event to the subscriber object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1e/777/1f0/d1e7771f0c1b6883f028f63feaa887c0.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the source object lives longer than the subscriber object, memory leaks are possible: in the absence of other references to the subscriber, the source object will still refer to it.  Therefore, the memory that the subscriber occupies cannot be freed by the garbage collector. <br><br>  There are many approaches to solve this problem.  In this article some of them will be considered, the advantages and disadvantages are discussed.  I divided all approaches into two parts: in one, we will assume that the source of the event is an already existing class with a regular event;  in the other, we will change the original object itself to look at the work of various methods. <br><br><h3>  What are the events? </h3><br>  Many developers think that events are a list of delegates.  This is not true.  As you know, delegates can be multicast - contain links to several functions at once: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">EventHandler</span></span> eh = Method1; <span class="hljs-attribute"><span class="hljs-attribute">eh</span></span> += Method2;</code> </pre> <br>  What then are the events?  They are similar to properties: inside they contain a delegate field, access to which is denied directly.  A delegate's public field (or public property) can cause the list of event handlers to be cleared by another object, or that the event will be triggered externally ‚Äî while we only want to call it from the original object. <br><br>  Properties are a pair of get / set methods.  Events are a pair of add / remove methods. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { ... } }</code> </pre><br>  Only methods for adding and removing handlers should be public.  In this case, other classes will not be able to get a list of handlers, will not be able to clear it, or trigger an event. <br><br>  Sometimes the short syntax of declaring events in C # is misleading: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent;</code> </pre><br>  In fact, this compilation of the record takes place in: <br><br><pre> <code class="hljs pgsql">private EventHandler _MyEvent; //    <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> event EventHandler MyEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(this) { _MyEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } remove { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(this) { _MyEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br>  In C #, events are implemented by default using synchronization, using for it objects in which they are declared.  You can verify this with the help of the disassembler - the add and remove methods are marked with the attribute [MethodImpl (MethodImplOptions.Synchronized)], which is equivalent to synchronization using the current instance of the object. <br><br>  Subscribing and unsubscribing from an event is a thread safe operation.  However, the thread-safe event call is left to the discretion of the developers, and quite often they do it incorrectly: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MyEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) MyEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); <span class="hljs-comment"><span class="hljs-comment">//     NullReferenceException   , //            </span></span></code> </pre><br>  Another common option is to preserve the delegate in a local variable. <br><br><pre> <code class="hljs kotlin">EventHandler eh = MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) eh(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty);</code> </pre><br>  Is this code thread safe?  It depends.  According to the memory model described in the C # language specification, this example is not thread-safe: the JIT compiler, by optimizing the code, can delete local variables.  However, the .NET runtime (starting with version 2.0) has a stronger memory model, and in it this code is thread-safe. <br><br>  The correct solution, according to the ECMA specification, is to assign a local variable in the lock (this) block or use a volatile-field to store the reference to the delegate. <br><br><pre> <code class="hljs kotlin">EventHandler eh; lock (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { eh = MyEvent; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) eh(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty);</code> </pre><br><h3>  Part 1: Weak events on the subscriber side </h3><br>  In this part, we will assume that we have a normal event (with reference to handlers), and any unsubscription of it should be made on the side of subscribers. <br><br><h4>  Solution 0: Just unsubscribe </h4><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { eventSource.Event += OnEvent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeregisterEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { eventSource.Event -= OnEvent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  Simple and effective, something you should use whenever possible.  However, it is not always possible to provide a call to the DeregisterEvent method after the object is no longer used.  You can try to use the Dispose method, although it is usually used for unmanaged resources.  The finalizer will not work in this case: the garbage collector will not call it, because the source object refers to our subscriber! <br><br>  <strong>Benefits</strong> <br>  Easy to use if using an object implies calling Dispose. <br><br>  <strong>disadvantages</strong> <br>  Explicit memory management is complex.  The Dispose method may also be forgotten. <br><br><h4>  Solution 1: Unsubscribe from the event after calling it. </h4><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { eventSource.Event += OnEvent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InUse) { eventSource.Event -= OnEvent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre><br>  Now we don‚Äôt need to worry if anyone will tell us that the subscriber object is no longer in use.  We ourselves check this after calling the event.  However, if we cannot use solution 0, then, as a rule, it is impossible to determine from the object itself whether it is used.  And given the fact that you are reading this article, you have probably come across one of these cases. <br><br>  It should be noted that this solution is already losing to decision 0: if the event is not triggered, then we will get a memory leak taken by the subscriber.  Imagine that many objects subscribed to the SettingsChanged static event.  Then all these objects will not be removed by the garbage collector until the event works - and this may never happen. <br><br>  <strong>Benefits</strong> <br>  Not. <br><br>  <strong>disadvantages</strong> <br>  Memory leak if event is not triggered.  It is also difficult to determine if the object is in use. <br><br><h4>  Solution 2: Weak Link Wrapper </h4><br>  This solution is almost identical to the previous one, except that we place the code of the event handler in a wrapper class, which then redirects the call to a subscriber object accessible via a <a href="http://msdn.microsoft.com/ru-ru/library/system.weakreference.aspx">weak reference</a> .  Using a weak link, you can easily check whether a subscriber object still exists. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70f/070/d75/70f070d75ef2880c68c1c3b021c8db08.png"><br><br><pre> <code class="hljs cs">EventWrapper ew; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ew = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventWrapper(eventSource, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventWrapper</span></span> { SourceObject eventSource; WeakReference wr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SourceObject eventSource, ListenerObject obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventSource = eventSource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(obj); eventSource.Event += OnEvent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { ListenerObject obj = (ListenerObject)wr.Target; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) obj.OnEvent(sender, e); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Deregister(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deregister</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { eventSource.Event -= OnEvent; } }</code> </pre><br>  <strong>Benefits</strong> <br>  Allows the garbage collector to free the memory occupied by the subscriber. <br><br>  <strong>disadvantages</strong> <br>  A leak of memory taken up by the wrapper if the event never works.  Writing wrapper classes for each event is a bunch of duplicate code. <br><br><h4>  Solution 3: Unsubscribe from the event in the finalizer </h4><br>  In the previous example, we stored a reference to the EventWrapper and had a public method Deregister.  We can add a finalizer (destructor) to the subscriber and use it to unsubscribe from the event. <br><pre> <code class="hljs 1c"><span class="hljs-symbol"><span class="hljs-symbol">~ListenerObject() { ew.Deregister()</span></span>; }</code> </pre><br>  This method will save us from memory leaks, but you have to pay for it: the garbage collector spends more time removing objects with finalizers.  When a subscriber object stops referring to anyone (except for weak links), it will outlive the first garbage collection and be transferred to a higher generation.  Then the garbage collector will call the finalizer, and only after that the object can be removed at the next garbage collection (already in the new generation). <br><br>  It should also be noted that finalizers are called in a separate thread.  This can cause an error if the subscription / unsubscribe event is implemented in a non-thread safe manner.  Remember that the default implementation of events in C # is not thread-safe! <br><br>  <strong>Benefits</strong> <br>  Allows the garbage collector to free the memory occupied by the subscriber.  There is no memory leak taken by the wrapper. <br><br>  <strong>disadvantages</strong> <br>  Having a finalizer increases the time that an unused object will be in memory before it is deleted.  A thread-safe event implementation is required.  Lots of duplicate code. <br><br><h4>  Solution 4: Reuse wrapper </h4><br>  The code below contains a wrapper class that can be reused.  Using lambda expressions, we pass a different code: to subscribe to an event, unsubscribe from it, and to transfer the event to a private method. <br><pre> <code class="hljs coffeescript">eventWrapper = WeakEventHandler.Register( eventSource, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, eh)</span></span></span><span class="hljs-function"> =&gt;</span></span> s.Event += eh, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   (s, eh) =&gt; s.Event -= eh, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  (me, sender, args) =&gt; me.OnEvent(sender, args) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   );</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/9b7/1a6/c359b71a617d1e28c5ae2e85f42ead19.png"><br><br>  The returned eventWrapper instance has only one public method - Deregister.  We need to be careful when writing lambda expressions: since they are compiled into delegates, they can also contain references to objects.  That is why the subscriber returns as me.  If we wrote (me, sender, args) =&gt; this.OnEvent (sender, args), then the lambda expression would be attached to the this variable, thereby triggering the creation of a closure.  And since the WeakEventHandler contains a reference to the delegate causing the event, this would result in a ‚Äústrong‚Äù (normal) link from the wrapper to the subscriber.  Fortunately, we have the opportunity to check whether the delegate has captured any variables: for such lambda expressions, the compiler will create instance methods;  otherwise, the methods will be static.  WeakEventHandler checks for this using the Delegate.Method.IsStatic flag and throws an exception if the lambda expression was not written correctly. <br><br>  This approach allows reuse of the wrapper, but still requires its own wrapper class for each delegate type.  Since you can actively use System.EventHandler and System.EventHandler, if there are many different types of delegates, you will want to automate all of this.  To do this, you can use code generation or the System.Reflection.Emit space types. <br><br>  <strong>Benefits</strong> <br>  Allows the garbage collector to free the memory occupied by the subscriber.  Not a very large amount of additional code. <br><br>  <strong>disadvantages</strong> <br>  Leakage of memory occupied by the wrapper in case the event never works. <br><br><h4>  Solution 5: WeakEventManager </h4><br>  WPF has built-in support for subscriber-side weak events through the WeakEventManager class.  It works like previous solutions using wrappers, except that a single instance of WeakEventManager serves as a wrapper between multiple event sources and multiple subscribers.  Due to the fact that there is only one instance of the object, WeakEventManager avoids memory leaks even if the event is not triggered: subscribing to another event can clear the list of old subscriptions.  These cleanups are done by the WPF dispatcher in threads that are running the WPF message loop. <br><br>  WeakEventManager also has an additional limitation: it requires the sender parameter to be set correctly.  If you use it for the button.Click event, then only events with sender == button will be passed to subscribers.  Some event implementations may attach handlers to other events: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Event { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { anotherObject.Event += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { anotherObject.Event -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br>  Such events cannot be used in WeakEventManager. <br><br>  One WeakEventManager per event, one instance per stream.  A recommended template for defining such events with code blanks can be found in the <a href="http://msdn.microsoft.com/en-us/library/aa970850.aspx">WeakEvent Templates article</a> in MSDN. <br><br>  Fortunately, we can simplify this with the help of Generics: <br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonClickEventManager</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeakEventManagerBase</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonClickEventManager</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> StartListening(Button source) { source.Click += DeliverEvent; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> StopListening(Button source) { source.Click -= DeliverEvent; } }</code> </pre><br>  Notice that DeliverEvent takes as arguments (object, EventArgs), while the Click event provides arguments (object, RoutedEventArgs).  In C # there is no support for converting between types of delegates, however there is support for <a href="http://blogs.msdn.com/ericlippert/archive/2007/10/19/covariance-and-contravariance-in-c-part-three-member-group-conversion-variance.aspx">contra parsing when creating delegates from a group of methods</a> . <br><br>  <strong>Benefits</strong> <br>  Allows the garbage collector to free the memory occupied by the subscriber.  The memory occupied by the wrapper can also be freed. <br><br>  <strong>disadvantages</strong> <br>  The method is not quite suitable for applications where there is no graphical interface, because the implementation is bound to WPF. <br><br><h3>  Part 2: Weak events on the source side </h3><br>  In this section, we will look at how to implement weak events by modifying the original object containing the event.  All solutions proposed below have an advantage over the implementation of weak events on the subscriber side: we can easily make subscription / unsubscribe thread-safe. <br><br><h4>  Solution 0: Interface </h4><br>  WeakEventManager is worth mentioning in this part.  As a wrapper, it joins regular events (the subscriber side), but it can also provide weak events to clients (the original object side). <br><br>  There is an IWeakEventListener interface.  Subscribers implementing this interface will be referenced by the source object via a weak reference, and called the implemented method ReceiveWeakEvent. <br><br>  <strong>Benefits</strong> <br>  Simple and effective. <br><br>  <strong>disadvantages</strong> <br>  When an object is subscribed to a multitude of events, in the implementation of ReceiveWeakEvent you will have to write a bunch of checks on the event and source types. <br><br><h4>  Solution 1: Weak delegate reference </h4><br>  This is another approach used in WPF: CommandManager.InvalidateRequery looks like a normal event, but it is not.  It contains a weak reference to the delegate, so subscribing to a static event does not result in a memory leak. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e8/7f2/346/3e87f2346f3a1b17c29f08c4bf16b58a.png"><br><br>  This is a simple solution, but event subscribers can easily forget about it or misunderstand: <br><pre> <code class="hljs objectivec">CommandManager.InvalidateRequery += OnInvalidateRequery; <span class="hljs-comment"><span class="hljs-comment">//  CommandManager.InvalidateRequery += new EventHandler(OnInvalidateRequery);</span></span></code> </pre><br>  The problem is that the CommandManager contains only a weak reference to the delegate, and the subscriber does not contain any references to the delegate at all.  Therefore, during the next garbage collection, the delegate will be deleted and OnInvalidateRequery will no longer work, even if the subscriber object is still in use.  For the fact that the delegate will live in memory, the subscriber must be responsible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/571/8af/6a7/5718af6a761bdb5577cbf8228ed09506.png"><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Listener</span></span> { EventHandler strongReferenceToDelegate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterForEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { strongReferenceToDelegate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler(OnInvalidateRequery); CommandManager.InvalidateRequery += strongReferenceToDelegate; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnInvalidateRequery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> {...} }</code> </pre><br>  <strong>Benefits</strong> <br>  The memory occupied by delegates is freed. <br><br>  <strong>disadvantages</strong> <br>  If you forget to put a ‚Äústrong‚Äù reference to the delegate, then the event will be triggered before the first garbage collection.  This can be difficult to find errors. <br><br><h4>  Solution 2: Object + Forwarder </h4><br>  While WeakEventManager was adapted for solution 0, the WeakEventHandler wrapper is adapted to this solution: registering the &lt;object, ForwarderDelegate&gt; pair. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/121/ae0/c56/121ae0c56301fe4710f7278d2b9596c7.png"><br><pre> <code class="hljs coffeescript">eventSource.AddHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(me, sender, args)</span></span></span><span class="hljs-function"> =&gt;</span></span> ((ListenerObject)me).OnEvent(sender, args));</code> </pre><br>  <strong>Benefits</strong> <br>  Simple and effective. <br><br>  <strong>disadvantages</strong> <br>  Unusual way to register events;  The redirect lambda expression requires type conversion. <br><br><h4>  Solution 3: SmartWeakEvent </h4><br>  The SmartWeakEvent shown below provides an event that looks like a normal .NET event, but keeps a weak link to the subscriber.  So  there is no need to keep a ‚Äústrong‚Äù reference to the delegate. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { eventSource.Event += OnEvent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  We define the event: <br><br><pre> <code class="hljs cs">SmartWeakEvent&lt;EventHandler&gt; _event = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SmartWeakEvent&lt;EventHandler&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Event { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { _event.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { _event.Remove(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _event.Raise(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); }</code> </pre><br>  How it works?  Using the properties Delegate.Target and Delegate.Method, each delegate is divided into a target object (stored using a weak reference) and MethodInfo.  When an event is triggered, the method is invoked using reflection. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/202/144/f5a/202144f5a274f063bf0bb12852962e19.png"><br><br>  The vulnerability of this method is that someone can attach an anonymous method as an event handler. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localVariable = <span class="hljs-number"><span class="hljs-number">42</span></span>; eventSource.Event += <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { Console.WriteLine(localVariable); };</code> </pre><br>  In this case, the target object is a closure that can be immediately removed by the collector, since  there are no links to it.  However, SmartWeakEvent can recognize such cases and throws an exception, so you should not have any problems debugging, because the event handler is decoupling earlier than you think. <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">d</span></span>.Method.DeclaringType.GetCustomAttributes(<span class="hljs-name"><span class="hljs-name">typeof</span></span>(<span class="hljs-name"><span class="hljs-name">CompilerGeneratedAttribute</span></span>), false).Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) throw new ArgumentException(...)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  <strong>Benefits</strong> <br>  It looks really like a weak event;  There is practically no redundant code. <br><br>  <strong>disadvantages</strong> <br>  The implementation of methods through reflection is rather slow.  It does not work with partial permission, since it performs private methods. <br><br><h4>  Solution 4: FastSmartWeakEvent </h4><br>  The functionality and usage is similar to the solution with SmartWeakEvent, but the performance is much higher. <br><br>  Here are the test results for an event with two delegates (one refers to an instance method, the other to a static one): <br><br>  Normal ("strong") event ... 16 948 785 calls per second <br>  Smart weak event‚Ä¶ 91,960 calls per second <br>  Fast smart weak event ... 4 901 840 calls per second <br><br>  How it works?  We no longer use reflection to perform the method.  Instead, we compile the method (similar to the method in the previous solution) during program execution using System.Reflection.Emit.DynamicMethod. <br><br>  <strong>Benefits</strong> <br>  Looks like a real weak event;  There is practically no redundant code. <br><br>  <strong>disadvantages</strong> <br>  It does not work with partial permission, since it performs private methods. <br><br><h3>  suggestions </h3><br><ul><li>  Use WeakEventManager for everything that runs in the GUI thread in WPF applications (for example, for user controls that subscribe to events of model objects) </li><li>  Use FastSmartWeakEvent if you want to provide a weak event. </li><li>  Use WeakEventHandler if you want to subscribe to an event. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/89529/">https://habr.com/ru/post/89529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../89520/index.html">New cars HTC. Arrival to Russia</a></li>
<li><a href="../89521/index.html">Chrome learns to sync the installed theme. Like everything else</a></li>
<li><a href="../89522/index.html">Hooray!</a></li>
<li><a href="../89525/index.html">T-shirt Battle City</a></li>
<li><a href="../89526/index.html">3d jesus</a></li>
<li><a href="../89531/index.html">Compact FULL HD camcorder HD DV200</a></li>
<li><a href="../89532/index.html">are there iphone developers in rf</a></li>
<li><a href="../89533/index.html">"Acoustics for 10,000 euros" at home - the results of KM2009, "Acoustics"</a></li>
<li><a href="../89537/index.html">Changes regarding selector: visited in Firefox</a></li>
<li><a href="../89541/index.html">Mnogubuff for GMail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>