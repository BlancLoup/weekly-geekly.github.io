<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary of the previous parts 
 Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="We continue the adventure." width="300" height="350" align="left"><h3>  Summary of the previous parts </h3><br>  Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a desire to write our own implementation of the C ++ 11 standard library on top of the C ++ 98 / C ++ 03 library supplied with the compiler. <br><br>  Were implemented <b>static_assert</b> , <b>noexcept</b> , <b>countof</b> , as well as, after considering all the non-standard defines and features of the compilers, there was information about the functionality that is supported by the current compiler.  Included is its own implementation of <b>nullptr</b> , which is selected at compile time. <br><br>  The time has come for <b>type_traits</b> and all this ‚Äúspecial patterned magic‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Link to GitHub with the result today for the impatient and non-readers: <br><br><blockquote>  <b><a href="https://github.com/oktonion/stdex">Commits and constructive criticism are welcome</a></b> </blockquote><br>  Immerse yourself in the world of "template magic" C ++. <br><a name="habracut"></a><br><h4>  Table of contents </h4><br>  <a href="https://habr.com/post/417027/">Introduction</a> <br>  <a href="https://habr.com/post/417027/">Chapter 1. Viam supervadet vadens</a> <br>  <a href="https://habr.com/post/417099/">Chapter 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://habr.com/post/417295/">Chapter 3. Finding the perfect implementation of nullptr</a> <br>  <b>Chapter 4. C ++ Template "Magic"</b> <br>  .... <b>4.1 Starting small</b> <br>  .... <a href="https://habr.com/post/417949/">4.2 How many we get wonderful errors are compiled by the log</a> <br>  .... <a href="https://habr.com/post/418347/">4.3 Pointers and all-all-all</a> <br>  .... <a href="https://habr.com/post/420365/">4.4 What else is needed for the template library</a> <br>  Chapter 5 <br>  ... <br><br><h3>  Chapter 4. C ++ Template "Magic" </h3><br>  Having finished with the C ++ 11 keywords and all define-dependent ‚Äúswitches‚Äù between their implementations, I began to fill in <b>type_traits</b> .  To tell the truth, I already had quite a few template classes, similar to the standard ones, which had already been working in projects for quite a long time and therefore it was necessary to bring all this into the same form, as well as to add the missing functionality. <br><br><img src="https://habrastorage.org/webt/g_/vn/rg/g_vnrg9in04st7-ysvmivnbablo.png" alt="image" width="300" height="200" align="left">  Honestly tell you that I am inspired by template programming.  Especially the realization that all this variety of options: calculations, code branching, conditions, checking for errors is performed during the compilation process and does not cost anything to the final program at the execution stage.  And since templates in C ++ are in essence a <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">Turing-complete programming language</a> , I was in anticipation of how gracefully and relatively easy it would be to implement the part of the standard associated with programming on templates.  But, in order to immediately destroy all illusions, I will say that the whole theory about Turing completeness is broken about the concrete implementation of patterns in compilers.  And this part of writing the library instead of elegant solutions and "tricks" of template programming turned into a fierce struggle with compilers, despite the fact that everyone "collapsed" in its own way, and it‚Äôs good if you‚Äôve lost your own internal compiler error, or even crashes raw exceptions.  GCC (g ++) showed itself best of all; it stoically ‚Äúchewed on‚Äù all patterned constructions and only cursed (in the case) in places where there was not enough explicit <b>typename</b> . <br><br><h4>  4.1 Starting small </h4><br>  I started with simple templates for <i>std :: integral_constant</i> , <i>std :: bool_constant</i> and similar small templates. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Val</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integral_constant</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// convenient template for integral constant types static const _Tp value = Val; typedef const _Tp value_type; typedef integral_constant&lt;_Tp, Val&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; typedef integral_constant&lt;bool, true&gt; true_type; typedef integral_constant&lt;bool, false&gt; false_type; template&lt;bool Val&gt; struct bool_constant : public integral_constant&lt;bool, Val&gt; {}; // Primary template. // Define a member typedef @c type to one of two argument types. template&lt;bool _Cond, class _Iftrue, class _Iffalse&gt; struct conditional { typedef _Iftrue type; }; // Partial specialization for false. template&lt;class _Iftrue, class _Iffalse&gt; struct conditional&lt;false, _Iftrue, _Iffalse&gt; { typedef _Iffalse type; };</span></span></code> </pre> <br>  On the basis of <i>conditional,</i> you can enter convenient templates for logical operations {"and", "or", "not"} over types (And all these operations are considered right at the compilation stage! Great, isn't it?): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_type</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//typedef void void_type; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _or_ : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _or_&lt;_B3, _B4&gt; &gt; &gt;::type { }; template&lt;&gt; struct _or_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _or_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _or_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B1, _B2&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _or_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _B3&gt; &gt;::type { }; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _and_; template&lt;&gt; struct _and_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _and_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _and_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B2, _B1&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _and_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _and_&lt;_B2, _B3&gt;, _B1&gt;::type { }; template&lt;class _Pp&gt; struct _not_ { static const bool value = !bool(_Pp::value); typedef const bool value_type; typedef integral_constant&lt;bool, _not_::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; }</span></span></code> </pre><br><blockquote>  Three points deserve attention here: <br><br>  1) It is important to put a space between the angle brackets ('&lt;' and '&gt;') of templates everywhere, since before C ++ 11 the standard didn‚Äôt specify how to interpret '&gt;&gt;' and '&lt;&lt;' in <i>_or _ &lt;_ B2, _or _ &lt;_ B3, _B4 &gt;&gt;</i> , and therefore almost all compilers interpreted this as a bit shift operator, which leads to a compilation error. <br><br>  2) In some compilers (Visual Studio 6.0 for example) there was a bug, which consisted in the fact that it was impossible to use the <b>void</b> type as a template parameter.  For these purposes, a separate <i>void_type</i> type is introduced in the excerpt above to replace the <b>void</b> type where a default parameter value is required. <br><br>  3) Very old compilers (Borland C ++ Builder for example) had a crookedly implemented <b>bool</b> type, which in some situations ‚Äúsuddenly‚Äù turned into <b>int</b> ( <b>true</b> -&gt; 1, <b>false</b> -&gt; 0), and also did not display types of constant static variables <b>bool</b> (and not only them), if they were contained in the template classes.  Because of all this mess in the end for a completely innocuous comparison in the style of <i>my_template_type :: static_bool_value == <b>false, the</b></i> compiler could easily produce an enchanting <i>cannon</i> <i>cast 'undefined type' to int (0)</i> or something like that.  Therefore, you should always try to explicitly specify the type of values ‚Äã‚Äãfor comparison, thereby helping the compiler to decide which types it has. </blockquote><br><br>  Let's add more work with <b>const</b> and <b>volatile</b> values.  First, a trivially implemented <i>remove_</i> ... where we simply specialize the template for certain type modifiers - if the compiler is required to type into a template with a modifier, having reviewed all the specializations (recall the SFINAE principle from the <a href="https://habr.com/post/417295/">previous chapter</a> ) of the template, choose the most suitable (with the explicit indication of the desired modifier) : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// remove top level const qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_const&lt;const _Tp&gt; { // remove top level const qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_const&lt;const volatile _Tp&gt; { // remove top level const qualifier typedef volatile _Tp type; }; // remove_volatile template&lt;class _Tp&gt; struct remove_volatile { // remove top level volatile qualifier typedef _Tp type; }; template&lt;class _Tp&gt; struct remove_volatile&lt;volatile _Tp&gt; { // remove top level volatile qualifier typedef _Tp type; }; // remove_cv template&lt;class _Tp&gt; struct remove_cv { // remove top level const and volatile qualifiers typedef typename remove_const&lt;typename remove_volatile&lt;_Tp&gt;::type&gt;::type type; };</span></span></code> </pre><br>  And then we implement <i>add_</i> templates ... where everything is already a bit more complicated: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_const_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_const_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_volatile_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_volatile_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunction</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_cv_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_cv_helper</span></span></span><span class="hljs-class">&lt;_Tp, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; } <span class="hljs-comment"><span class="hljs-comment">// add_const template&lt;class _Tp&gt; struct add_const: public detail::_add_const_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_const&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; }; // add_volatile template&lt;class _Tp&gt; struct add_volatile : public detail::_add_volatile_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_volatile&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; }; // add_cv template&lt;class _Tp&gt; struct add_cv : public detail::_add_cv_helper&lt;_Tp, is_function&lt;_Tp&gt;::value&gt; { }; template&lt;class _Tp&gt; struct add_cv&lt;_Tp&amp;&gt; { typedef _Tp &amp; type; };</span></span></code> </pre><br>  Here we will carefully handle reference types separately in order not to lose the link.  Just do not forget about the types of functions that can not be made <b>volatile</b> or <b>const in</b> principle, because we leave them "as is".  I can say that all this looks very simple, but this is the case when the ‚Äúdevil is in the details,‚Äù or rather, ‚Äúthe bugs are in the details of the implementation.‚Äù <br><br>  The end of the first part of the fourth chapter.  In the <a href="https://habr.com/post/417949/">second part</a> I will talk about how hard the template programming is given to the compiler, and there will also be more cool template "magic".  Oh, and also - why <b>long long is</b> not an <b>integral constant</b> in the opinion of some compilers to this day. <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/417547/">https://habr.com/ru/post/417547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417537/index.html">"Your game is boring", or how to raise the already high retention of the first day</a></li>
<li><a href="../417539/index.html">Google fined a record $ 5 billion for violating antitrust laws in Europe</a></li>
<li><a href="../417541/index.html">The Apollo mission talks with NASA Mission Control Center are digitized.</a></li>
<li><a href="../417543/index.html">A Chinese university student was nearly expelled due to his father‚Äôs low ‚Äúsocial rating‚Äù</a></li>
<li><a href="../417545/index.html">Information technology has its own special atmosphere.</a></li>
<li><a href="../417549/index.html">Ask Ethan: how big is the entire unobserved whole universe?</a></li>
<li><a href="../417551/index.html">CRISPR supporters advocate egalitarian access to gene editing</a></li>
<li><a href="../417553/index.html">Open webinar "CSS preprocessors"</a></li>
<li><a href="../417555/index.html">Announcement of the Cargo Cult seminar in Moscow: Marketing strikes back</a></li>
<li><a href="../417557/index.html">Overview of Laser CNC LaserSolid machines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>