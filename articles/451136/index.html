<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Presented by .NET 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On May 6, it was announced that the next release after .NET Core 3.0 would be .NET 5. This will be the next big release in the .NET family. 

 In the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Presented by .NET 5</h1><div class="post__text post__text-html js-mediator-article">  On May 6, it was announced that the next release after <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-5/">.NET Core 3.0</a> would be .NET 5. This will be the next big release in the .NET family. <br><br>  In the future, there will be only one .NET, and you can use it for development for Windows, Linux, macOS, iOS, Android, tvOS, watchOS, WebAssembly and other platforms. <br><br>  We will introduce the new .NET API, the capabilities of the runtime environment, and the capabilities of the language as part of .NET 5 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/ug/w7/zj/ugw7zjo96o89vjb_yzl1usznvju.png"><br><a name="habracut"></a><br>  Since the launch of the .NET Core project, we have added about 50,000 .NET Framework APIs to the platform.  .NET Core 3.0 came close to the .NET Framework 4.8 by its capabilities, thanks to which Windows Forms, WPF and Entity Framework 6 became available. .NET 5 took over the baton, it was based on <a href="https://docs.microsoft.com/en-us/dotnet/core/">.NET Core</a> and all the best from the <a href="https://www.mono-project.com/">Mono</a> project, resulting in It turned out to be a single platform that can be used for all of your modern .NET code. <br><br>  We intend to release .NET 5 in November 2020, and the first preview version will be available in the first half of 2020.  The platform will be available along with future updates of Visual Studio 2019, Visual Studio for Mac and Visual Studio Code. <br><br><h3>  .NET 5 = .NET Core vNext </h3><br>  .NET 5 is the next step in .NET Core.  The project aims to improve .NET in several key aspects: <br><br><ul><li>  Create a unified execution environment and framework that can be used everywhere, with the same runtime behavior and development experience. </li><li>  Extend the capabilities of .NET with best practices from the .NET Core, .NET Framework, Xamarin and Mono. </li><li>  Build a product from a single code base over which developers (from Microsoft and the community) can work together and expand it, which will improve all possible scenarios. </li></ul><br>  This new project and direction will completely change the situation with .NET.  Thanks to .NET 5, your code and project files will look consistent, regardless of the type of application you are creating.  From each application, you will have access to the same executing environment, the same API, and language features, including new <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/">performance improvements</a> , which are embedded into corefx almost daily. <br><br>  Everything that you like about the .NET Core has been preserved: <br><br><ul><li>  Open source and focus on the GitHub community. </li><li>  Cross-platform implementation. </li><li>  Support for using specific platform-specific features, such as Windows Forms and WPF under Windows, as well as native bindings for each native platform from Xamarin. </li><li>  High performance. </li><li>  Side-by-side installation. </li><li>  Small size of project files (SDK-style). </li><li>  Command Line Interface (CLI) with extensive capabilities. </li><li>  Integration with Visual Studio, Visual Studio for Mac and Visual Studio Code. </li></ul><br>  Innovations: <br><br><ul><li>  You will have more performance environment (more on this below). </li><li>  The ability to call Java code from .NET 5 will be available on all platforms. </li><li>  Calling Objective-C and Swift code from .NET 5 will be supported in several operating systems. </li><li>  CoreFX will be expanded to support static .NET compilation (ahead-of-time - AOT), to reduce resource consumption (footprints) and to support more operating systems. </li></ul><br>  .NET Core 3.0 will be available in September of this year, and .NET 5 - in November 2020.  After that we are going to release the main versions of .NET once a year, every November: <br><br><img src="https://habrastorage.org/webt/cp/3o/4y/cp3o4yir2ib5ihl6ctyc_pnfxss.png"><br><br>  We are missing the fourth version, because users may have confusion with the .NET Framework, which has long been released in version 4.x.  In addition, we wanted to make clear that .NET 5 is the future of the .NET platform. <br><br>  We also decided to take advantage of the opportunity and simplify the order of names.  We believe that if only one .NET will be developed, we will not need an explanatory term ‚ÄúCore‚Äù.  The short title is simpler, it says that the capabilities and behavior of .NET 5 are unified.  If you want, you can continue to use the name ‚Äú.NET Core‚Äù. <br><br><h3>  Runtime environments </h3><br>  <a href="https://github.com/mono/mono">Mono</a> is the original cross-platform implementation of .NET.  It began as an open-source alternative to the .NET Framework, and later, with the growing popularity of iOS and Android devices, we reoriented it to the mobile segment.  Mono is an execution environment used as part of Xamarin. <br><br>  <a href="https://github.com/dotnet/coreclr">CoreCLR</a> is the <a href="https://github.com/dotnet/coreclr">execution</a> environment used as part of the .NET Core.  It was initially focused on supporting cloud applications, including the largest services at Microsoft, and today it is also used for desktop Windows applications, IoT, and machine learning. <br><br>  The .NET Core and Mono runtimes have a lot in common (yet, both of them are .NET runtimes), but each has its own unique capabilities.  Therefore, it makes sense to give you the opportunity to choose the experience of use that you need.  Now we are working to make CoreCLR and Mono pluggable replacements for each other.  The process will be as simple as switching the assembly to choose between different options of the runtime environment. <br><br>  In the following chapters, I will describe our key plans for .NET 5. They will help you understand how we are going to develop two runtimes simultaneously and at the same time separately. <br><br><h3>  High performance and productivity </h3><br>  From the very beginning, .NET relied on a <a href="https://ru.wikipedia.org/wiki/JIT-%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">JIT compiler</a> to convert <a href="https://ru.wikipedia.org/wiki/Common_Intermediate_Language">Intermediate</a> Language code into optimized machine code.  We have created the industry's best JIT runtime with very high performance, while allowing developers to write code easily and quickly. <br><br>  JIT compilers are well suited for long-running clouds and client-side scripts.  They are able to generate code that takes into account the features of the hardware configuration, including specific processor instructions.  JIT can <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/">also generate methods at runtime</a> , this technique allows you to compile at high speeds, while at the same time creating a finely tuned version of the code if some methods are used frequently. <br><br>  Our efforts to speed up the ASP.NET Core work, as <a href="https://www.techempower.com/benchmarks/">reflected in the TechEmpower</a> benchmark <a href="https://www.techempower.com/benchmarks/">results</a> , are a good example of JIT capabilities and are our contributions to CoreCLR.  We tried to prepare <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">.NET Core for the use of containers</a> , this demonstrates the ability of the runtime environment to dynamically adapt to limited environments. <br><br>  Developer tools are another area in which JIT has proven itself, for example, dotnet watch or ‚Äúedit and continue‚Äù mode.  To use the tools, it is often required to repeatedly compile and load code in the same process without restarting, and this should be done very quickly. <br><br>  Developers using the .NET Core or .NET Framework primarily rely on JIT.  So it should seem familiar to them. <br><br>  A standard approach for most .NET 5 workloads is to use the CoreCLR runtime with JIT.  Two important exceptions are iOS and Blazor client (WebAssembly), they require native pre-ahead (of-time) compilation. <br><br><h3>  Fast start-up, low CPU usage (footprint) and reduced memory consumption </h3><br>  As part of the Mono project, most efforts were focused on the mobile segment and game consoles.  The main feature and result of this project is the AOT compiler for .NET, developed on the basis of the <a href="http://llvm.org/">LLVM</a> compiler.  Mono's AOT compiler allows you to build .NET code into a single native executable code that can work on any machine, just like C ++ code.  Precompiled (AOT) applications can run efficiently with limited resources (small places), and, if necessary, sacrifice performance for the sake of their launch. <br><br>  The <a href="https://blazor.net/">Blazor</a> project <a href="https://blazor.net/">is</a> already using Mono AOT and is one of the first to switch to .NET 5. We use it as one of the ways to prove our plans. <br><br>  There are two types of AOT solutions: <br><br><ul><li>  Requiring full AOT compilation. </li><li>  Solutions where most of the code is AOT-compiled, but still allow using JIT or an interpreter for code patterns that are not friendly with AOT (for example, generics). </li></ul><br>  Mono AOT supports both types.  The AOT of the first type is needed for iOS and some game consoles, mainly due to security requirements.  Solutions of the second type are more preferable because they have all the advantages of AOT without its disadvantages. <br><br>  The .NET Native is an AOT compiler that we use for Windows UWP applications.  It refers to the first type of AOT-solutions.  In this particular implementation, we have limited the .NET API and the features available to you.  This helped us understand that AOT solutions should cover the full range of .NET APIs and patterns. <br><br>  AOT compilation will remain necessary for iOS, WebAssembly and some game consoles.  We will make it optional for applications that are embedded in hardware (appliance-like), for which a quick launch and / or low CPU consumption is required. <br><br><h3>  Basics and similar requirements </h3><br>  It is critical for us to continue to develop as a platform with controls for launch, performance, memory consumption, reliability and diagnostics.  At the same time, it is advisable to focus our efforts.  We will work more on improving performance and reliability in CoreCLR, as well as on improving startup and reducing the file size of the Mono AOT compiler.  It seems to us a good combination.  Performance and reliability go hand in hand, as does startup speed with a decrease in file size. <br><br>  It is advisable to invest different resources in improving some characteristics, but not in improving others. <br><br>  Diagnostic capabilities should be the same for the entire .NET 5, this applies to both functionality and performance.  It is also important to support the same processors and operating systems (with the exception of iOS and WebAssembly). <br><br>  We will continue to optimize .NET 5 for all types of workloads and scripts for which it makes sense.  The greatest emphasis will be placed on optimizations, especially in cases where different loads impose similar requirements. <br><br>  All .NET 5 applications will use the <a href="https://github.com/dotnet/corefx">CoreFX</a> framework.  We will make sure that CoreFX works well where it is not used today, mainly Xamarin Blazor client tasks. <br><br>  All .NET 5 applications can be built using the <a href="https://github.com/dotnet/cli">.NET CLI</a> , so that in all projects you will have a single command line toolkit. <br><br>  C # will evolve with .NET 5. Developers who write .NET 5 applications will get access to the latest version of C # and its properties. <br><br><h3>  The birth of the project </h3><br>  As a technical team, we gathered in December 2018 in Boston to start this project.  Leading architects from the .NET team (Mono / Xamarin and .NET Core) and <a href="https://unity.com/">Unity</a> spoke about the various technical possibilities and directions for the development of architecture. <br><br>  Now we move the project as a team.  Since December, we have made great progress in several projects: <br><br><ul><li>  A minimum level was determined, which defines the interaction between the runtime environment and the managed code layer, in order to make&gt; 99% CoreFX common code. </li><li>  MonoVM can now use CoreFX and its class libraries. </li><li>  We drove all CoreFX tests on MonoVM using its implementation. </li><li>  Launched ASP.NET Core 3.0 applications on MonoVM. </li><li>  Launched MonoDevelop and Visual Studio for Mac on CoreCLR. </li></ul><br>  The pursuit of a single .NET implementation raises important questions.  What will be the final framework?  Will the NuGet package compatibility rules remain the same?  What load will the .NET 5 SDK support out of the box?  How do you write code for a specific architecture?  Do we need .NET Standard?  We are currently working on all of this and will soon be able to share project documentation with you so that you can read it and give feedback. <br><br><h3>  Conclusion </h3><br>  The .NET 5 project is an important and inspiring new direction for .NET.  You will see that .NET will become easier, but at the same time it will be used more widely, will gain more opportunities.  All new development features will become part of .NET 5, including new versions of C #. <br><br>  We have a bright future ahead in which you can use the same .NET API and languages ‚Äã‚Äãfor a wide range of applications, operating systems and processor architectures.  You can easily change the configuration of the assembly, building applications as you wish - in Visual Studio, Visual Studio for Mac, Visual Studio Code, Azure DevOps or from the command line. </div><p>Source: <a href="https://habr.com/ru/post/451136/">https://habr.com/ru/post/451136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451118/index.html">Testing is not for beginners</a></li>
<li><a href="../451120/index.html">About the difficulties when porting Dead Cells to mobile platforms</a></li>
<li><a href="../451124/index.html">Developing proteins in the cloud using Python and Transcriptic or How to create any protein for $ 360</a></li>
<li><a href="../451126/index.html">Toolbox for researchers - release one: self-organization and data visualization</a></li>
<li><a href="../451132/index.html">Consumer Driven Contracts or Gitlab CI through the eyes of QA test automation</a></li>
<li><a href="../451144/index.html">Antiquities: technology in TV advertising</a></li>
<li><a href="../451146/index.html">Accelerate webpack build with webpack</a></li>
<li><a href="../451148/index.html">Object Oriented Programming in Graphic Languages</a></li>
<li><a href="../451150/index.html">Catch Me If You Can. Manager Version</a></li>
<li><a href="../451152/index.html">Resistor in the gate circuit or how to do it right</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>