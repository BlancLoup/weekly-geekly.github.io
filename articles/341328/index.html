<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tale about resistors and neon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Calculation of DC circuits on the fingers, or let's assume the DAC for the ternary logic 
 But for starters neon, what kind of Russian does not love t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tale about resistors and neon</h1><div class="post__text post__text-html js-mediator-article"><h2>  Calculation of DC circuits on the fingers, or let's assume the DAC for the ternary logic </h2><br><h3>  But for starters neon, what kind of Russian does not love them? </h3><br>  So, again I am with my triple glands, but in this article they act as a background, today there is an article about resistors.  I had a few handkerchiefs in which I could insert gas discharge lamps like IN-12 or IN-15, but I didn't want to make the clock :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c2/3da/6df/6c23da6df50b986c3b4b516100f9bd60.jpg"><br><a name="habracut"></a><br>  The simplest scarves carry a pair of sk6812 LEDs to illuminate the balloon, a dozen transistors and their 595e shift registers.  This is how a handkerchief looks like, carrying one lamp on itself, but at the same time they can be assembled into a long sausage to achieve the desired number of lamps: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a6/322/dd7/6a6322dd7f11a60b13ae5d792fc2eb25.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thanks <a href="https://habrahabr.ru/users/ikaktys/" class="user_link">ikaktys</a> for the help!  At the same time with the neon-women I threw up and soldered the ternary counter, which I had previously collected on the breadboard and <a href="https://habrahabr.ru/post/328162/">described in detail</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e96/f26/fa7/e96f26fa753c8a996a7b68529145c2e6.jpg"><br><br>  I remind you that my ternary counter uses a balanced ternary number system, which is represented by three voltage levels (-5, 0 and 5 volts).  Its state is indicated by two-color LEDs: red is a negative value, extinguished is zero, and green is a positive value. <br><br>  It would seem that this is quite enough, why are there neonas?  One of my friends, who is very sincerely interested in where the threefold path will lead me, turned out to be color blind!  Thus, I had to think about an alternative to two-color LEDs.  And here the neon box lies, and the decimal display is convenient. <br><br><h3>  Cross the horror and hedgehog, or how to make friends binary and ternary logic </h3><br>  Since I have, as is known, arduino of the brain, I manage the neonks with the help of arduin.  That is, the neon driver works on binary logic, and I need to output information based on the ternary one.  I was too lazy to gossip about the decoders, and since I already have an arduin, I decided to simply get the ternary signal into the ADC of the arduin, good, it has more than enough free legs.  Then we just look at which third of the ADC area is the current line, and this will give us the threefold value inside the arduin. <br><br>  Only one bad luck: the Arduin wants to measure the analog signal between the ground and five volts, and the ternary signal has a variation from minus five to five.  By the way, it is necessary to measure arduine voltage from -5 to 5 V in other areas.  For example, recently I needed to measure the current in the DC motor windings, and the hall sensor gave me a signal from -5 to 5. <br><br>  That is, I need to scale the voltage level twice and move it to the positive area.  The easiest way to do this is to hang each ternary line according to such a resistor divider: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e5/9f7/6b6/3e59f76b66ba7adc373785a30c6dfcbc.png"><br><br>  The ternary signal enters Vin (from -5 to +5 V), the Arduin power is Vref (5 V), and the Vout starts up on the arduine's ADC.  This raises the question of how to select the necessary resistor values ‚Äã‚Äãso that Vout is located in the working area of ‚Äã‚Äãthe ADC (from 0 to 5 V). <br><br>  Probably, there are people who can do this almost in the mind, but I don‚Äôt belong to them, and I know physics only at the school level.  My secret knowledge is that you do not need to lick the outlet.  But I can read, therefore, after reading Wikipedia, we arm ourselves with Ohm‚Äôs law, Kirchhoff‚Äôs law and the ability to solve linear equations. <br><br>  <b>First, let's set the task as follows: knowing the resistances R1, R2 and R3, as well as the voltages Vref and Vin, find the current flowing through each resistor, and at the same time the output voltage Vout.</b> <br><br>  Let us arbitrarily choose the direction of current flow (indicated by the arrow) through each resistor.  If we ‚Äúmade a mistake‚Äù with the choice of direction, then just the current strength will turn out to be negative. <br><br>  Then we write <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%259A%25D0%25B8%25D1%2580%25D1%2585%25D0%25B3%25D0%25BE%25D1%2584%25D0%25B0">the Kirchhoff's law for the chain node</a> (the one that is marked with a bold black dot in the diagram): the sum of the flowing currents equals the sum of the incoming currents, that is, I1 + I3 = I2. <br><br>  Then the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%259A%25D0%25B8%25D1%2580%25D1%2585%25D0%25B3%25D0%25BE%25D1%2584%25D0%25B0">second Kirchhoff rule</a> for a closed loop tells us that the sum of the voltages across the resistors is equal to the total emf of the loop. <br><br>  We can choose two circuits, one with a common voltage Vref, the second with a voltage Vin.  We write all three equations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f3/676/6a6/0f36766a64520a3d991557820d8d6e3b.png"><br><br>  Let's rewrite the same system in a matrix form, I‚Äôm lazy to solve it with my own hands, and in the software for symbolic matrix calculations it is obviously more convenient: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ac/d90/530/8acd90530bbcf18a2360684368f44fbb.png"><br><br>  And then the desired currents I1, I2 and I3 can be found by reversing the 3x3 matrix of our system: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/86b/721/f0e86b721990a9537a25aede75a40a6f.png"><br><br>  Then the output voltage Vout can be found through the newly found I2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/77f/381/82e/77f38182e9f670a4d7b92307d023abe2.png"><br><br>  <b>This is fine, but in general our task is not to find Vout from known resistances and Vin, but on the contrary, knowing the range of Vin, choose resistance so that Vout fits between zero and Vref.</b> <br><br>  Let's substitute 5 volts of arduin power supply instead of Vref in our equations, choose arbitrarily R1 resistor at 100kOhm (we have the same voltage divider, so we can choose one of the resistors ourselves).  Then we write down two equations: for Vin = -5, Vout should be equal to zero, and for Vin = 5, Vout should be equal, for example, 4.9 V. That is, we got the following system of equations, I didn‚Äôt simplify anything specifically: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b97/cff/308/b97cff308a3be2ee10e2213d613ab8b6.png"><br><br>  In general, a polynomial equation is obtained; you can count it by hands, but why?  I will consider it in sage, <a href="http://sagecell.sagemath.org/%3Fz%3DeJx1jz-PgzAMxfdK9x0Qk1O5iKRl6OCBkTUDS8SdihTUSPxpIdD2258Jd-pyt0SO_X7v2ctlhFhL1Ar1EUvXYznMHsvRNrH42OXUXfzonmCMxINEWaHZ1ClX6YZVFSvrt3IdsdP6sk2YTtfhAflvUXNREOSJ6xc7ThbEvhbJ5Lpb65rXVzO3LawSRYWRFfv9cIXirr1LglNyJuL_XisG53ryzs_eAsdSlIX1KUMtSaafmQiUIkij6F_q8BcVUg0nIvPhjqFd7Luz3S--AVANXMo%3D%26lang%3Dsage">here</a> you can execute the code below: <br><br><pre><code class="python hljs">var(<span class="hljs-string"><span class="hljs-string">"R1,R2,R3,Vin,Vout,Vref"</span></span>) A=matrix([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>],[R1,R2,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,R2,R3]]) b=matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>],[Vin],[Vref]]) I=(A.inverse()*b).simplify_full() I2=I[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] eq1=(<span class="hljs-number"><span class="hljs-number">4.9</span></span>==(I2*R2).substitute(Vin= <span class="hljs-number"><span class="hljs-number">5</span></span>,Vref=<span class="hljs-number"><span class="hljs-number">5</span></span>,R1=<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">5</span></span>)) eq2=(<span class="hljs-number"><span class="hljs-number">0</span></span> ==(I2*R2).substitute(Vin=<span class="hljs-number"><span class="hljs-number">-5</span></span>,Vref=<span class="hljs-number"><span class="hljs-number">5</span></span>,R1=<span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">5</span></span>)) solve([eq1,eq2],R2,R3)</code> </pre> <br>  Here is the output of the solve command: <br><br> <code>[[R2 == 0, R3 == 0], [R2 == 2450000, R3 == 100000]]</code> <br> <br>  Our resistors must have strictly positive values ‚Äã‚Äãof the ratings, so we discard the obviously impossible answers.  Total, the solver tells us that if we choose R1 = R3 = 100 kŒ© and R2 = 2.45 megaoma, then when powering Vref = 5 V, the input voltage range Vin = [- 5 V, + 5 V] will be displayed in the Vout node in range [0 V, 4.9 V].  Hooray! <br><br>  <i>A question for attentive readers: why did I choose the output range of 0-4.9 V, and not 0-5 V?</i> <br><br>  Here is the code I use: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000L #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include &lt;util/delay.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;avr/pgmspace.h&gt; // PSTR /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// #define INPUT2(port,pin) DDR ## port &amp;= ~_BV(pin) #define OUTPUT2(port,pin) DDR ## port |= _BV(pin) #define CLEAR2(port,pin) PORT ## port &amp;= ~_BV(pin) #define SET2(port,pin) PORT ## port |= _BV(pin) #define READ2(port,pin) ((PIN ## port &amp; _BV(pin))?1:0) #define INPUT(x) INPUT2(x) #define OUTPUT(x) OUTPUT2(x) #define CLEAR(x) CLEAR2(x) #define SET(x) SET2(x) #define READ(x) READ2(x) #define WRITE(x,b) ((b)?(SET2(x)):(CLEAR2(x))) #define SK6812_DATA_PIN B,0 #define SHIFT_595_DATA_PIN B,1 #define SHIFT_595_CLOCK_PIN B,2 #define SHIFT_595_LATCH_PIN B,3 // IN12b: 0 1 2 3 4 5 6 7 8 9 . // IN15a: √é¬º n % √ê≈∏ k M m + - P nc uint16_t nixie_pins[] = {(1&lt;&lt;8), (1&lt;&lt;11), (1&lt;&lt;9), (1&lt;&lt;3), (1&lt;&lt;4), (1&lt;&lt;5), (1&lt;&lt;0), (1&lt;&lt;7), (1&lt;&lt;2), (1&lt;&lt;6), (1&lt;&lt;10)}; void push_nixie_symbol(uint8_t i) { uint16_t data = nixie_pins[i]; for (int8_t j=15; j&gt;=0; j--) { CLEAR(SHIFT_595_CLOCK_PIN); _delay_us(10); if ((data&gt;&gt;j)&amp;1) { SET(SHIFT_595_DATA_PIN); } else { CLEAR(SHIFT_595_DATA_PIN); } _delay_us(10); SET(SHIFT_595_CLOCK_PIN); _delay_us(10); } } void clock_nixie_latch() { SET(SHIFT_595_LATCH_PIN); _delay_us(10); CLEAR(SHIFT_595_LATCH_PIN); _delay_us(10); } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// void adc_init() { ADMUX = (1&lt;&lt;REFS0); // AREF = AVcc ADCSRA = (1&lt;&lt;ADEN)|(1&lt;&lt;ADPS2)|(1&lt;&lt;ADPS1)|(1&lt;&lt;ADPS0); // ADC Enable and prescaler of 128 } uint16_t adc_read(uint8_t ch) { ch &amp;= 7; // prevent ch being &gt;7 ADMUX = (ADMUX &amp; 0xF8) | ch; // clear 3 lower bits before ORing ADCSRA |= (1&lt;&lt;ADSC); // start single convertion while (ADCSRA &amp; (1&lt;&lt;ADSC)); // wait for the conversion to complete return ADC; } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// void uart_write(char x) { while ((UCSR0A &amp; (1&lt;&lt;UDRE0))==0); // wait for empty receive buffer UDR0 = x; // send } uint8_t uart_char_is_waiting() { // returns 1 if a character is waiting, 0 otherwise return (UCSR0A &amp; (1&lt;&lt;RXC0)); } char uart_read() { while (!uart_char_is_waiting()); char x = UDR0; return x; } int uart_putchar(char c, FILE *stream __attribute__((unused))) { uart_write(c); return 0; } int uart_getchar(FILE *stream __attribute__((unused))) { return uart_read(); } void uart_init() { UBRR0H = 0; // For divisors see table 19-12 in the atmega328p datasheet. UBRR0L = 16; // U2X0, 16 -&gt; 115.2k baud @ 16MHz. UCSR0A = 1&lt;&lt;U2X0; // U2X0, 207 -&gt; 9600 baud @ 16Mhz. UCSR0B = 1&lt;&lt;TXEN0; // Enable the transmitter. Reciever is disabled. UCSR0C = (1&lt;&lt;UDORD0) | (1&lt;&lt;UCPHA0); fdevopen(&amp;uart_putchar, &amp;uart_getchar); } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// #define ASM_STRIP_PIN2(port,pin) "I" (_SFR_IO_ADDR(PORT ## port)), "I" (pin) #define ASM_STRIP_PIN(x) ASM_STRIP_PIN2(x) void __attribute__((noinline)) led_strip_write(uint8_t *colors, uint16_t count) { cli(); while (count--) { asm volatile( "ld __tmp_reg__, %a0+\n" "rcall led_strip_send_byte%=\n" "ld __tmp_reg__, %a0+\n" "rcall led_strip_send_byte%=\n" "ld __tmp_reg__, %a0+\n" "rcall led_strip_send_byte%=\n" "rjmp led_strip_asm_end%=\n" "led_strip_send_byte%=:\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "rcall led_strip_send_bit%=\n" "ret\n" "led_strip_send_bit%=:\n" "sbi %2, %3\n" "rol __tmp_reg__\n" "nop\n" "nop\n" "brcs .+2\n" "cbi %2, %3\n" "nop\n" "nop\n" "nop\n" "nop\n" "nop\n" "brcc .+2\n" "cbi %2, %3\n" "ret\n" "led_strip_asm_end%=: " : "=b" (colors) : "0" (colors), ASM_STRIP_PIN(SK6812_DATA_PIN) ); } sei(); _delay_us(80); } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// #define LED_COUNT 8 uint8_t red[] = {0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0}; uint8_t green[] = {128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0,128,0,0}; uint8_t gray[] = {128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128}; int main(void) { OUTPUT(SHIFT_595_DATA_PIN); OUTPUT(SHIFT_595_CLOCK_PIN); OUTPUT(SHIFT_595_LATCH_PIN); OUTPUT(SK6812_DATA_PIN); CLEAR(SHIFT_595_DATA_PIN); CLEAR(SHIFT_595_CLOCK_PIN); CLEAR(SHIFT_595_LATCH_PIN); CLEAR(SK6812_DATA_PIN); adc_init(); uart_init(); FILE uart_stream = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW); stdin = stdout = &amp;uart_stream; while(1) { uint16_t v0 = adc_read(0); uint16_t v1 = adc_read(1); uint16_t v2 = adc_read(2); int8_t t0 = v0&lt;341 ? -1 : (v0&gt;682 ? 1 : 0); int8_t t1 = v1&lt;341 ? -1 : (v1&gt;682 ? 1 : 0); int8_t t2 = v2&lt;341 ? -1 : (v2&gt;682 ? 1 : 0); int8_t value = t0+t1*3+t2*9; uint8_t ns0 = abs(value)%10; uint8_t ns1 = abs(value)/10; if (!ns1) ns1 = 10; uint8_t ns2 = value&gt;0?7:(value&lt;0?8:10); if (value&gt;0) { led_strip_write(green, LED_COUNT); } else if (value&lt;0) { led_strip_write(red, LED_COUNT); } else { led_strip_write(gray, LED_COUNT); } push_nixie_symbol(ns0); push_nixie_symbol(ns1); push_nixie_symbol(ns2); clock_nixie_latch(); fprintf_P(&amp;uart_stream, PSTR("%d,%d,%d,%d, %d %d %d\r\n"), adc_read(0), adc_read(1), adc_read(2), value, ns2, ns1, ns0); _delay_ms(100); } return 0; }</span></span></span></span></code> </pre></div></div><br>  But the video of the work of my ternary counter with a decimal display of the current value on the lamps, it clearly shows three identical dividers instituted on the arduine ADC: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3ijeF--3y5Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  I am not very confused by the binary nature of the display, it does not compromise the work of my ternary calculator, since neonas are not an obligatory element, the main output is provided by two-color LEDs. <br><br><h2>  Complicate the problem, go to the DAC </h2><br><h3>  Digital-to-analog binary code conversion </h3><br>  First, let's remember the resistor R-2R matrix for a binary DAC, it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1fb/068/417/1fb0684176d0759dd6547c13982bf6c0.png"><br><br>  <a href="https://en.wikipedia.org/wiki/Resistor_ladder">The theory</a> tells us that if we choose R4 = R5 = R, and R1 = R2 = R3 = R6 = 2R, then, applying three bits of the binary number to the inputs V1, V2, V3, we get an analog level on the Vout node the entrance. <br><br>  Reading the encyclopedia is good, but how were these denominations of R and 2R obtained?  Let's find them yourself.  So, the topology of the DAC is given to us, as before, arbitrarily choose the direction of current flow through each resistor. <br><br>  The calculation method is exactly the same as in the previous example: first, we calculate the current for given resistors, and then we write several equations that connect Vout with inputs V1, V2 and V3, which will give us the necessary values. <br><br>  So, we have three nodes and three contours, as a result, six equations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/6dd/d26/8ff6ddd2697938444c3f0d15c1268e84.png"><br><br>  Rewrite in matrix form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/011/623/5a5/0116235a57a13515b86549984d3d2263.png"><br><br>  And then the strength of the currents can be found by reversing the 6x6 matrix: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/812/0ae/3868120ae018b8aab851a0ed1ec246d1.png"><br><br>  Vout can be obtained as the sum of the voltage drops across three resistors: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f92/17e/99f/f9217e99f39448f5b8777d8ccecee951.png"><br><br>  For clarity, let me show you how Vout looks like a function of R1, R2, R3, R4, R5, R6 and V1, V2, V3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d16/337/21d/d1633721d503efb9531cf8220b5c91ee.png"><br><br>  Pretty unpleasant expression, right?  Well, God be with him, we will not count hands.  So, for given resistor ratings, we have seven non-zero combinations of input voltages at our DAC.  They must match seven different Vout values.  This will give seven equations, deciding which, we get the desired values ‚Äã‚Äãof resistors. <br><br>  As before, we will consider it in sage, here‚Äôs the code that <a href="http://sagecell.sagemath.org/%3Fz%3DeJyFUk1vgzAMvVfqn-jJdB5LCB-7-MCRaw65IDQViapIdGx8bfv3cwJIqGrVw3Psl_dsK8p06uCgJeoAtUIdoo5Qx2gkmgCNOnj7XUrX09DVv5DnAgVKfJV8iAJzW6wEl45eCHcrtj0dw2McvRB6tQhbFzys3AyzjgVG2RDYIJ2uv7Q_kK5JyUlGkPr151R1fQXesfT8vr5-NfX57-M8Ng2wZL8zLUGWRwU3Per4JcvDOY04VXMa3jG6IaZ1LarvhCB5eycyrd-PZT_UwzhUYCTZR7NBkfQ8q4wJ4rtKcauMCKLHPcVGGRKEj3tulYpAPdlTzMqAIHiy56KUBPLJnk7Jb9Y2UwU5W5AHMBQjZESMmJEUN7-Obf-dv7Bz%26lang%3Dsage">can be run in the browser</a> . <br><br><pre> <code class="python hljs">var(<span class="hljs-string"><span class="hljs-string">"R1,R2,R3,R4,R5,R6,V1,V2,V3"</span></span>) A=matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R3,R4,R5,R6],[<span class="hljs-number"><span class="hljs-number">0</span></span>,R2,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R5,R6],[R1,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R6]]) b=matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>],[V3],[V2],[V1]]) I=(A.inverse()*b).simplify_full() Vo=(I[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R6+I[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R5+I[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R4).simplify_full() eq7=(<span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">1</span></span>,V3=<span class="hljs-number"><span class="hljs-number">1</span></span>)) eq6=(<span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">0</span></span>,V2=<span class="hljs-number"><span class="hljs-number">1</span></span>,V3=<span class="hljs-number"><span class="hljs-number">1</span></span>)) eq5=(<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">0</span></span>,V3=<span class="hljs-number"><span class="hljs-number">1</span></span>)) eq4=(<span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">0</span></span>,V2=<span class="hljs-number"><span class="hljs-number">0</span></span>,V3=<span class="hljs-number"><span class="hljs-number">1</span></span>)) eq3=(<span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">1</span></span>,V3=<span class="hljs-number"><span class="hljs-number">0</span></span>)) eq2=(<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">0</span></span>,V2=<span class="hljs-number"><span class="hljs-number">1</span></span>,V3=<span class="hljs-number"><span class="hljs-number">0</span></span>)) eq1=(<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">0</span></span>,V3=<span class="hljs-number"><span class="hljs-number">0</span></span>)) solve([eq1,eq2,eq3,eq4,eq5,eq6,eq7],R2,R3,R4,R5,R6)</code> </pre><br>  Here is the output of the solve command (I threw out all the solutions with negative and zero resistors) with my hands: <br><br> <code>[R2 == r11, R3 == r12, R4 == -1/2*r11 + r12, R5 == -1/2*R1 + r11, R6 == R1]</code> <br> <br>  This means that we can select (almost) arbitrarily the resistors R1, R2, R3, and our DAC will work correctly.  If we take them all three of the same denomination, then we get the well-known R-2R matrix. <br><br><h3>  Digital-to-analog conversion of the ternary code </h3><br>  And now we come to the most interesting, to the development of a digital-to-analog converter for a ternary balanced system.  As far as I know, nobody has done this yet, few fools :) <br><br>  In general, the resistor matrix works great for a binary code, but what happens if it sends a ternary signal to the input?  If V1 = V2 = V3 = -1, then the output of the matrix will be approximately -1, if V1 = V2 = V3 = 0, then the output is zero, and if V1 = V2 = V3 = 1, then the output is approximately 1. Then there is, in the first approximation, the matrix works as we need.  Let's try adjusting resistors to make it work quite well. <br><br>  The topology of the matrix remains the same, the expression for Vout does not change, we only need to adjust the system of equations to search for nominal values.  If earlier we had 7 equations, now it will be 13. Let's try! <br><br><pre> <code class="python hljs">var(<span class="hljs-string"><span class="hljs-string">"R,R1,R2,R3,R4,R5,R6,V1,V2,V3"</span></span>) A=matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R3,R4,R5,R6],[<span class="hljs-number"><span class="hljs-number">0</span></span>,R2,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R5,R6],[R1,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,R6]]) b=matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>],[V3],[V2],[V1]]) I=(A.inverse()*b).simplify_full() Vo=(I[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R6+I[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R5+I[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*R4).simplify_full() Vo=Vo.substitute(R1==R,R2==R,R3==R) eq13=(<span class="hljs-number"><span class="hljs-number">26</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq12=(<span class="hljs-number"><span class="hljs-number">24</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">0</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq11=(<span class="hljs-number"><span class="hljs-number">22</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq10=(<span class="hljs-number"><span class="hljs-number">20</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">0</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq09=(<span class="hljs-number"><span class="hljs-number">18</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">0</span></span>,V2= <span class="hljs-number"><span class="hljs-number">0</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq08=(<span class="hljs-number"><span class="hljs-number">16</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">0</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq07=(<span class="hljs-number"><span class="hljs-number">14</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq06=(<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">0</span></span>,V2=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq05=(<span class="hljs-number"><span class="hljs-number">10</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V2=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">1</span></span>)) eq04=( <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">0</span></span>)) eq03=( <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">0</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">0</span></span>)) eq02=( <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1=<span class="hljs-number"><span class="hljs-number">-1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">1</span></span>,V3= <span class="hljs-number"><span class="hljs-number">0</span></span>)) eq01=( <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">27</span></span>==Vo.substitute(V1= <span class="hljs-number"><span class="hljs-number">1</span></span>,V2= <span class="hljs-number"><span class="hljs-number">0</span></span>,V3= <span class="hljs-number"><span class="hljs-number">0</span></span>)) sln=solve([eq01,eq02,eq03,eq04,eq05,eq06,eq07,eq08,eq09,eq10,eq11,eq12,eq13],R4,R5,R6) show(sln)</code> </pre><br>  As usual, this code can be <a href="http://sagecell.sagemath.org/%3Fz%3DeJx9k02PgjAQhu8m_gfiqbiD2w9APfTg0WsPXIjZSIJZEpRdi-7uv9-Zigma1gMv7fDMO52WXvdnNjNgBBgJRoFJwWRgcigEFBIKNYunk40-7vtz88vKkgMHAYnAF99BSZN7AKcuPATcVz72dBEs48JDwNxTOM13WKwaFaOM4SkUiSQRjttqtlk0p2t9tjWL51W8sM3xq20Ofx-HS9syRKaTotNsW2Y7tJib_G1bprdhhkN1G6aeREwruoW9VLZv-ktfMyO0xl2SThWqc6-_hdJM5u9yqZ8SCqEj2kGnCjWOHS-RTwM89_ACeennE58_R56_XA8f83ytmVi9XM8jv0I-0G_i818iH-rX8cnD-nmOfKDf23qe-Az5QL-Jzz_VLAr1O95PPvB4vlHofLmHx_ONAv0mPn883yjU73g_HT-d2Pakbddea1ZSMlBFEkWSkmQkOcmSZEWyBvozSChDUIbA63S_l-hsP7sfhubxP6zTE3Y%3D%26lang%3Dsage">run in a browser.</a> <br><br>  Well listen, and the system has a solution, if we take R1 = R2 = R3 = R, R4 = R5 = 4 / 3R and R6 = 2R, then we will have a real three-way DAC! <br><br><h2>  Theory by theory but let's test in practice </h2><br>  In order to check the operation of the DAC, we take the same most ternary counter that I described a little earlier.  Clock counter will be triangular saw, the scheme is available <a href="http://www.piclist.com/images/www/hobby_elec/e_ckt16.htm">here.</a>  And we will drive three digits of our meter to the three inputs of the ternary DAC.  Here is the test pattern: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/338/c24/a01/338c24a01bad744419ac44bb1aa40e17.jpg"><br><br>  On the breadboard top are clock triangles, then a counter, on the breadboard bottom is a resistor matrix.  In this matrix there are three resistors, I chose 1 kŒ©, 1.33 kŒ© and 2 kŒ©.  A three-digit counter counts from -13 to +13, at the output I expect to see a ladder from (approximately) -5 V to (approximately) +5 V. I poke with an oscilloscope: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/492/49a/cea49249a8a144a142018b870912a282.jpg"><br><br>  It is clearly seen that each clock triangle generates another step for us.  Works! <br><br><h2>  Bonus: how much can you trust math software? </h2><br>  Today we cheerfully considered crocodiles all sorts of software good.  In general, how much can you trust what we have counted?  I consider everyone to work a lot, find bugs in almost all mathematical packages.  Here, for example, since we are talking about sage, a screenshot I took two and a half years ago when I sent a bugreport: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/996/d87/020/996d870205aa9c58658d73ebf9905687.png"><br><br>  Who is right, the numerical integral of the function f or its symbolic calculation?  They even have a different sign!  Now the yard is the end of 2017, you can <a href="http://sagecell.sagemath.org/%3Fz%3DeJxVjEEKwjAQRfeCdxi66SRGqFkKPYmIxJDIQJqEZCx6e4O1BXfvfeZNLhQZZlcqpYhiv5tNwZ7Vq2_sYYRKEVlIwyZq1HJRddTSptrocGp3-fvEr9DF5-QKWROgqXsUE87QKdjm2zqjV4PKJC7DdYvre7qnQPa__Qm7liAvlfgAAkU8UQ%3D%3D%26lang%3Dsage">check the current state of things</a> .  Versions are replaced, and the error is still in place.  Therefore <b>, of course, it is possible to use mathematical software, but it is necessary to check the results in the same way as after outputting formulas on paper</b> . </div><p>Source: <a href="https://habr.com/ru/post/341328/">https://habr.com/ru/post/341328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341318/index.html">Bad Rabbit showed: ransomware encrypts backup data</a></li>
<li><a href="../341320/index.html">What is wrong with vulnerabilities in C # projects?</a></li>
<li><a href="../341322/index.html">unCAPTCHA: using google services to bypass google reCAPTCHA</a></li>
<li><a href="../341324/index.html">End-to-end analytics in practice: more profit, cheaper advertising</a></li>
<li><a href="../341326/index.html">How to impose service metrics and not screw it up</a></li>
<li><a href="../341330/index.html">Free Joker 2017 webcast: Java 9, Concurrency, GC, Spring and, of course, puzzle players</a></li>
<li><a href="../341332/index.html">An overview of tools for comparing data in PostgreSQL</a></li>
<li><a href="../341334/index.html">DotNext + SpbDotNet + MskDotNet</a></li>
<li><a href="../341336/index.html">Review of the reports of the conference Mobius 2017 Moscow - leap of faith in mobile technology</a></li>
<li><a href="../341338/index.html">Bitcoin and Security Software Wallets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>