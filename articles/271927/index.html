<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Works and Copies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fifth article in the series "Theory of Categories for Programmers." The previous articles have already been published on Habr√© in the tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Works and Copies</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/257/ef2/101/257ef2101177d334d05615244cd560a2.jpg" height="300" width="285">  <i>This is the fifth article in the series "Theory of Categories for Programmers."</i>  <i>The previous articles have already been published on Habr√© in the translation of <a href="https://habrahabr.ru/users/monnoroch/" class="user_link">Monnoroch</a> :</i> <br>  <a href="http://habrahabr.ru/post/245797/">0. Category Theory for Programmers: Preface</a> <br>  <a href="http://habrahabr.ru/post/246009/">1. Category: essence of composition</a> <br>  <a href="http://habrahabr.ru/post/247765/">2. Types and functions</a> <br>  <a href="http://habrahabr.ru/post/248257/">3. Categories, large and small</a> <br>  <a href="http://habrahabr.ru/post/249113/">4. Categories Claisley</a> <br><br>  <i>At KDPV, piglet Peter starts one tractor in each category object.</i> <br><br><h2>  Follow the arrows </h2><br>  Ancient Greek playwright Euripides wrote "Every man is like his environment."  This is also true for category theory.  You can select a specific category object only by describing the nature of its relationship with other objects (and yourself), where relationships are morphisms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To define objects in terms of their relationships, category theory resorts to the so-called.  <em>universal designs</em> .  To do this, you can choose a certain pattern, a diagram of objects and morphisms of a certain shape, and consider all the constructions suitable for it in the category under consideration.  If the pattern is fairly common and the category is large enough, then it is likely that there will be a lot of constructions found.  The idea of ‚Äã‚Äãa universal construction is to streamline the construction according to some law and choose the most appropriate one. <br><br>  This process can be compared to a search on the net.  User request is our template.  If the request is not very specific, then the search system will return a set of suitable documents, only some of which are relevant.  To exclude irrelevant answers, the user refines the request, which increases the accuracy of the search.  In the end, the search engine ranks matches and, if lucky, the desired result will be at the very top of the list. <br><a name="habracut"></a><br><h2>  Initial (initial) object </h2><br>  The simplest pattern consists of a single object.  Obviously, every object of the category fits under it, and there are a lot of them.  To select the most suitable, you need to enter a hierarchy on them.  The only thing we have is morphisms.  If we imagine morphisms as arrows, then it may turn out that a comprehensive chain of arrows extends from one end of the category to the other.  This is true in ordered categories, for example, in partial orders.  We say that object <em>a</em> precedes object <em>b</em> if there is an arrow (morphism) from <em>a</em> to <em>b</em> .  It would be natural to call the initial object that precedes everything else (i.e., there is an arrow from it into any other category object).  It is clear that, generally speaking, the initial object may not be.  However, it is much worse that there can be more than one objects satisfying the previous definition.  How to clarify our definition?  The clue is given by ordered categories: there is no more than one arrow between two objects (there is only one way to be more or less than another object).  This leads us to the following definition: <br><blockquote>  <strong>The initial object</strong> is an object from which exactly one morphism emanates from any category object. <br></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/ef2/101/257ef2101177d334d05615244cd560a2.jpg" height="300" width="285"></div><br>  In fact, even such a definition does not guarantee the uniqueness of the initial object (if it exists).  However, it guarantees uniqueness up to <em>isomorphism</em> .  Isomorphism is a very important concept for category theory, we will return to it soon. <br><br>  Consider a few examples.  The initial object in a partially ordered set is its smallest element.  Some partially ordered sets, such as all integers (both positive and negative), do not have an initial object. <br><br>  In the category of sets, the initial object is the empty set.  Recall that the empty set corresponds to the <code>Void</code> type in Haskell (there is no corresponding type in C ++) and the only polymorphic function from <code>Void</code> to any other type called <code>absurd</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">absurd</span></span> :: <span class="hljs-type"><span class="hljs-type">Void</span></span> -&gt; a</code> </pre> <br>  The existence of such a function makes <code>Void</code> initial object of the category of sets. <br><br><h2>  Terminal object </h2><br>  Let's continue experimenting with a template from a single object, but change the ranking method.  We say that the object <em>a</em> follows the object <em>b</em> if there exists a morphism from <em>b</em> to <em>a</em> (pay attention to the change of direction).  We are interested in the latest category object.  For reasons of uniqueness, we define it like this: <br><blockquote>  <strong>A terminal object</strong> is an object into which exactly one morphism comes from any category object. <br></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/c6b/dbc/766c6bdbc0b3df267b71e446e155c639.jpg" width="300" height="298"></div><br>  Again, the terminal object is unique up to isomorphism, which will soon be proved.  First, however, consider a few examples.  In a partially ordered set, the terminal object (if it exists) is the largest object.  In the category of sets, the terminal object is a singleton.  Recall that a singleton corresponds to a <code>void</code> type in C ++ and a type <code>()</code> in Haskell and is a type populated by exactly one value, implicit in C ++ and explicit in Haskell, denoted by the same literal <code>()</code> .  It was previously established that there is a single pure function from any type in <code>()</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">unit</span></span> :: a -&gt; () unit _ = ()</code> </pre> <br>  so all the requirements for the terminal object are met. <br><br>  Note that in this case the uniqueness condition is critically important, since there are other sets (in fact, all sets except the empty one) that have incoming morphisms from any other type.  For example, there is a function with values ‚Äã‚Äãof type <code>Bool</code> ( <em>predicate</em> ), defined for any type of argument: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">yes</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> yes _ = <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br>  However, <code>Bool</code> not a terminal object, because there is at least one more function from any type in <code>Bool</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">no</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> no _ = <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br>  The requirement of uniqueness of morphisms gives us the necessary accuracy, narrowing the set of suitable terminal objects to one. <br><br><h2>  Duality </h2><br>  It is impossible not to notice the symmetry between the definitions of the initial and terminal objects.  The whole difference lies in the direction of morphisms.  For any category C, you can define a <em>dual category</em> C <sup>op</sup> simply by reversing all the arrows.  The dual category automatically satisfies the definition of the category, if we simultaneously redefine the composition together with the reversal of the arrows.  If the composition of the original morphisms <code>f::a-&gt;b</code> and <code>g::b-&gt;c</code> was <code>h::a-&gt;c</code> with <code>h=g‚àòf</code> , then the composition of the inverted morphisms <code>f_op::b-&gt;a</code> and <code>g_op::c-&gt;b</code> will be <code>h_op::c-&gt;a</code> with <code>h_op=f_op‚àòg_op</code> .  Note that the inversion of the identical arrow coincides with itself. <br><br>  Duality is a very important property of categories, doubling the category-theoretic productivity.  For any construction there is a dual one, and by proving one theorem, you get a second one for free.  Dual category constructions often have the prefix ‚Äúco‚Äù: works and coproducts, monads and comonads, cones and cocoons, limits and sets, etc. However, it does not make sense to consider co-designs, because the double-facing arrow coincides with the original one, that, for example, kokomonadah coincide with the monad. <br><br>  So, the terminal object is the initial object in the dual category. <br><br><h2>  Isomorphisms </h2><br>  Programmers are well aware that determining equality is not so easy.  What does it mean that two objects are equal?  Should they occupy the same memory area (pointer equality)?  Or is it enough that the values ‚Äã‚Äãof all their components coincide?  Are two complex numbers considered equal if one of them is given by the real and imaginary components, and the other by the argument and module?  One might hope that mathematicians possess sacred knowledge about the definition of equality, but this is not so.  In mathematics, there are also many types of equality, as well as a weaker concept of isomorphism and even weaker equivalence. <br><br>  Intuitively, objects are isomorphic, if they have the same appearance, are externally indistinguishable: any part of one object is in one-to-one correspondence with some part of another object;  according to the readings of the measuring instruments available to us, the objects are exact copies of each other.  Mathematically, this means that there are reciprocal mappings from object <em>a</em> to object <em>b</em> and from object <em>b</em> to object <em>a</em> .  Category theory generalizes mappings to morphisms.  Isomorphism is a reversible morphism or, in other words, a pair of morphisms inverse to each other. <br><br>  The concept of reversibility is expressed in terms of composition and unitary morphism: the morphism <em>g</em> is inverse to <em>f</em> if their composition is a unit morphism.  In fact, this is not one, but two conditions, since there are two ways of composition of a pair of morphisms: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> . g = id g . f = id</code> </pre> <br>  When we say that the initial (terminal) object is unique up to isomorphism, it means that any two initial (terminal) objects are isomorphic.  This is easy to demonstrate.  Suppose that i <sub>1</sub> and i <sub>2</sub> are initial objects in the same category.  Since i <sub>1 is</sub> initial, there exists a unique morphism <em>f</em> from i <sub>1</sub> to i <sub>2</sub> .  Similarly, since i <sub>2 is</sub> initial, there exists a unique morphism <em>g</em> from i <sub>2</sub> to i <sub>1</sub> .  What can be said about the composition of these morphisms? <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/a84/9a7/662a849a7ae8451322495b44ed2e3680.jpg" width="150" height="94"></div><br>  The composition <em>g</em> ‚àò <em>f</em> must be a morphism from i <sub>1</sub> to i <sub>1</sub> .  But i <sub>1</sub> is the initial object, so that there is exactly one morphism from i <sub>1</sub> to i <sub>1</sub> and, since the beginning and end of the arrow are the same, this vacancy is already occupied by a single morphism.  Therefore, they must coincide: the morphism <em>g</em> ‚àò <em>f</em> is unit.  Similarly, the morphism <em>f</em> ‚àò <em>g</em> also coincides with the unit one, since there can be only one morphism from i <sub>2</sub> to i <sub>2</sub> .  Thus, <em>f</em> and <em>g are</em> mutually inverse, and the two initial objects are isomorphic. <br><br>  Note that our proof of the uniqueness of the initial object up to isomorphism essentially used the uniqueness of the morphism from the initial object to itself.  However, is it important that the morphisms <em>f</em> and <em>g are</em> also unique?  The fact is that in fact we have proved a more rigorous statement: the initial object is unique up to a <em>unique</em> isomorphism.  Generally speaking, there can be more than one isomorphism between two objects, but not in this case.  ‚ÄúUniqueness up to a single isomorphism‚Äù is an important feature of all universal constructions. <br><br><h2>  Artworks </h2><br>  The following universal construction is a work.  We are already familiar with the Cartesian product of two sets consisting of the set of all possible pairs.  What is the pattern that connects a set-product with sets of factors?  If we reveal it, we can generalize the concept of a work to other categories. <br><br>  Associated with the Cartesian product are two functions ( <em>projectors</em> ) acting from the set-product into the corresponding set factor.  In Haskell, these functions are called <code>fst</code> and <code>snd</code> and select the first and second elements of the pair, respectively: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fst</span></span> :: (a, b) -&gt; a fst (x, y) = x snd :: (a, b) -&gt; b snd (x, y) = y</code> </pre> <br>  Here, the functions are defined by matching the argument with the pattern: the pattern matches any pair <code>(x, y)</code> and extracts its components into variables <code>x</code> and <code>y</code> . <br><br>  These definitions can be simplified using dashes: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fst</span></span> (x, _) = x snd (_, y) = y</code> </pre> <br>  In C ++, we will use template functions, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fst</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">&lt;A, B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.first; }</code> </pre> <br>  With the help of this (seemingly scarce) information about a work, we will try to construct a pattern corresponding to it from objects and morphisms in the category of sets.  This pattern will consist of factor objects <em>a</em> and <em>b</em> , object <em>c,</em> and projecting morphisms <em>p</em> and <em>q</em> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p</span></span> :: c -&gt; a q :: c -&gt; b</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/0c7/5be/6c10c75bee876f1299b36cfb90dd54b2.jpg" width="150" height="99"></div><br>  All objects <em>c</em> that satisfy this pattern will be considered as candidates for the product.  There can be a lot of such objects. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/8e9/7c0/fa58e97c04f25832865647ad0e18deb3.jpg" width="150" height="76"></div><br>  As an example, we take two types as factors, namely <code>Int</code> and <code>Bool</code> , and consider a sample of candidates for their work. <br><br>  Here is the first one: <code>Int</code> .  Can <code>Int</code> be considered as a candidate for <code>Int</code> and <code>Bool</code> ?  Yes, maybe here are the relevant projectors: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> px = x q :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> q _ = <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br>  It looks suspicious, but it fits the pattern. <br><br>  Here is another candidate: <code>(Int, Int, Bool)</code> .  This is a tuple of three elements.  Here is the corresponding pair of projecting morphisms (we again use pattern matching): <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p</span></span> :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> p (x, _, _) = x q :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> q (_, _, b) = b</code> </pre> <br>  The attentive reader may have noticed that the first candidate is too small - he covers only the <code>Int</code> -component of the work, and the second one is too large, because it includes a clearly fictitious <code>Int</code> -component. <br><br>  We have so far considered only the first component of the universal design - the template, but did not say anything about the second - about the ranking.  We need a way to compare two candidates that match the pattern, namely object <em>c</em> with projectors <em>p</em> and <em>q</em> and object <em>c</em> 'with projectors <em>p</em> ' and <em>q</em> '.  I would like to suppose that <em>c is</em> better than <em>c</em> 'if there exists a morphism <em>m</em> from <em>c</em> ' to <em>c</em> , but this is too weak a condition.  It is also necessary to require that the projectors <em>p</em> and <em>q</em> be better (more universal) than <em>p</em> 'and <em>q</em> '.  This means that <em>p</em> 'and <em>q</em> ' can be reconstructed from <em>p</em> and <em>q</em> with the help of <em>m</em> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p'</span></span> = p . m q' = q . m</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/f8e/4dd/987f8e4dd908bf03f7bd3cd5eb449387.jpg" width="150" height="122"></div><br>  A number theory expert would say that <em>m</em> is a divisor (factor) of <em>p</em> 'and <em>q</em> '.  Imagine natural numbers instead of morphisms and multiplication instead of composition: then <em>m</em> will be a common divisor of <em>p</em> 'and <em>q</em> '.  Further in similar situations we will say that <em>m</em> factorizes <em>p</em> 'and <em>q</em> '. <br><br>  For the training of intuition, we show that a pair <code>(Int, Bool)</code> with two canonical projectors <code>fst</code> and <code>snd</code> definitely better than the candidates discussed above. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/800/299/e06800299a2d92c3d7c3c7d15c9c476d.jpg" width="212" height="150"></div><br>  The mapping <code>m</code> for the first candidate is: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) mx = (x, <span class="hljs-type"><span class="hljs-type">True</span></span>)</code> </pre> <br>  Indeed, both projectors <code>p</code> and <code>q</code> can be reconstructed as: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">px</span></span> = fst (mx) = x qx = snd (mx) = <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br>  The morphism <code>m</code> for the second example is also uniquely defined: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m</span></span> (x, _, b) = (x, b)</code> </pre> <br>  We showed that <code>(Int, Bool)</code> better than both candidates.  We show that the converse is false.  Is it possible to find some morphism <code>m'</code> , which will allow to recover <code>fst</code> and <code>snd</code> by <code>p</code> and <code>q</code> ? <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fst</span></span> = p . m' snd = q . m'</code> </pre> <br>  In the first example, <code>q</code> always returns <code>True</code> , but at the same time there are pairs in which <code>False</code> is the second component.  So you can't restore <code>snd</code> by <code>q</code> . <br><br>  In the second example, things are different: we have enough information after <code>p</code> and <code>q</code> to restore <code>fst</code> and <code>snd</code> , but the factorizing morphism <code>m'</code> is ambiguous.  Indeed, since both <code>p</code> and <code>q</code> ignore the second element of the tuple, morphism <code>m'</code> can put anything there: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m'</span></span> (x, b) = (x, x, b)</code> </pre> <br>  or <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m'</span></span> (x, b) = (x, <span class="hljs-number"><span class="hljs-number">42</span></span>, b)</code> </pre> <br>  etc. <br><br>  Summarizing the above, for a given type <code>c</code> with projectors <code>p</code> and <code>q</code> there exists a unique morphism <code>m</code> from <code>c</code> to the Cartesian product <code>(a, b)</code> , which factorizes <code>p</code> and <code>q</code> .  In fact, <code>m</code> simply combines them in a pair: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m</span></span> :: c -&gt; (a, b) mx = (px, qx)</code> </pre> <br>  This makes the Cartesian product <code>(a, b)</code> best candidate and completes the consideration of this universal construction for the category of sets. <br><br>  Now let's forget about the sets and define the product of two objects in an arbitrary category using the same universal construction.  Such a product (if exists) is unique up to a unique isomorphism. <br><blockquote>  <strong>The product of</strong> objects <em>a</em> and <em>b</em> is such an object equipped with two projectors <em>c</em> , that for any other object equipped with projectors <em>c</em> 'there exists a unique morphism <em>m</em> from <em>c</em> ' to <em>c</em> , factoring these projectors. <br></blockquote><br>  The function (higher order) that builds a factorizing morphism on two projectors is sometimes called a <em>factorizer</em> .  In our case, it looks like: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">factorizer</span></span> :: (c -&gt; a) -&gt; (c -&gt; b) -&gt; (c -&gt; (a, b)) factorizer pq = \x -&gt; (px, qx)</code> </pre> <br><h2>  Copies </h2><br>  Like any construction of the theory of categories, the work has a twin called coproduct.  If we reverse the arrows in the product template, we obtain an object <em>c</em> , equipped with two <em>embeddings</em> <code>i</code> and <code>j</code> , with morphisms from <em>a</em> and <em>b</em> to <em>c</em> . <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">i</span></span> :: a -&gt; c j :: b -&gt; c</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/184/01d/5dc/18401d5dc8d0ccfc1083e25423761e18.jpg" width="150" height="94"></div><br>  We also need to reverse the ranking order: now the object <em>c</em> will be considered better than the object <em>c</em> ', equipped with the attachments <em>i</em> ' and <em>j</em> ', if there exists a morphism <em>m</em> from <em>c</em> to <em>c</em> ', which factorizes the attachments: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">i'</span></span> = m . i j' = m . j</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/c46/506/c3dc46506e39421ec80dcebabf1bc734.jpg" width="150" height="125"></div><br>  The best of such objects, possessing a unique morphism into all other objects that correspond to a pattern, is called coproduct and, if it exists, is unique up to a single isomorphism. <br><blockquote>  <strong>The copying of</strong> objects <em>a</em> and <em>b</em> is an object <em>c</em> equipped with two embeddings, such that for any other object equipped with embeddings <em>c</em> ', there exists a unique morphism <em>m</em> from <em>c</em> to <em>c</em> ' that factorizes these embeddings. <br></blockquote><br>  In the category of sets, coproduct is a <em>disjoint union</em> .  The element of the disjoint union <em>a</em> and <em>b</em> is either the element <em>a</em> or the element <em>b</em> .  If two sets intersect, then the disjoint union contains both copies of the common part.  The elements of a disjoint union can be considered labeled as source sets. <br><br>  For a programmer, coproduct is a marked union of two types.  C ++ supports unlabeled unions;  the task of tracking which member of the union is valid lies on the programmer‚Äôs shoulders.  To create a tagged union, you need to define a label - an enumeration - and combine it with the union.  For example, the marked union <code>int</code> and <code>char const *</code> might look like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contact</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { isPhone, isEmail } tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> phoneNum; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * emailAddr; }; };</code> </pre> <br>  Two attachments can be implemented either as constructors or as functions.  For example, here is the first attachment as a <code>PhoneNum</code> function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Contact </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhoneNum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ Contact c; c.tag = isPhone; c.phoneNum = n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br>  This function inserts an <code>int</code> into <code>Contact</code> . <br><br>  Marked union is also called <code>variant</code> , the generalized implementation of which is in the boost library ( <code>boost::variant</code> ). <br><br>  In Haskell, you can make a tagged union of any data types by separating the constructors with a vertical bar.  The above <code>Contact</code> written as: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Contact</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PhoneNum</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailAddr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br>  Here, <code>PhoneNum</code> and <code>EmailAddr</code> serve both as constructors (attachments) and as labels for pattern matching (see below).  For example, this is how you can build <code>Contact</code> by phone number: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">helpdesk</span></span> :: <span class="hljs-type"><span class="hljs-type">Contact</span></span>; helpdesk = <span class="hljs-type"><span class="hljs-type">PhoneNum</span></span> <span class="hljs-number"><span class="hljs-number">2222222</span></span></code> </pre> <br>  Unlike the canonical implementation of the work, embedded in Haskell syntax as a primitive pair, the canonical implementation of coproduct is not a special language construct, but an ordinary data type <code>Either</code> from the standard library: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Either</span></span> ab = <span class="hljs-type"><span class="hljs-type">Left</span></span> a | <span class="hljs-type"><span class="hljs-type">Right</span></span> b</code> </pre> <br>  This data type is parametrized by two types <code>a</code> and <code>b</code> and has two constructors: <code>Left</code> , which accepts type <code>a</code> , and <code>Right</code> , which accepts type <code>b</code> . <br><br>  By analogy with the factorizer for the product, the factorizer for the coproduct can also be defined.  For a given candidate for coproduction in the form of type <code>c</code> with two embeddings <code>i</code> and <code>j</code> we construct a factorizing morphism: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">factorizer</span></span> :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> ab -&gt; c factorizer ij (<span class="hljs-type"><span class="hljs-type">Left</span></span> a) = ia factorizer ij (<span class="hljs-type"><span class="hljs-type">Right</span></span> b) = jb</code> </pre> <br><h2>  Asymmetry </h2><br>  Above, we considered two pairs of dual definitions: first, the definition of a terminal object can be obtained from the definition of the initial object by reversing the arrows, secondly, the definition of coproduct from the definition of work is obtained in the same way.  However, in the category of sets, the initial object is fundamentally different from the terminal one, and the coproduct is different from the product.  Below it will be shown that the product behaves as an multiplication with a terminal object playing the role of a unit, and coproduct is similar to addition, where instead of zero it is the initial object.  In particular, for finite sets, the number of elements in the product is the product of the numbers of elements in the original sets, and the number of elements in the coproduct is equal to the sum of the original quantities. <br><br>  This shows that the category of sets is not symmetric with respect to the inversion of arrows. <br><br>  Note that despite the fact that a single arrow emanates from any empty set into any other set (the <code>absurd</code> function), there is not a single morphism included in it.  A singleton (a set of one element) has not only a single arrow entering into it from any set, but also outgoing arrows into each non-empty set.  As we saw earlier, these arrows outgoing from the terminal object play an important role in the choice of elements of other sets (there are no elements in the empty set, so there is nothing to choose). <br><br>  A relationship with a singleton is what distinguishes a piece from a coproduct.  Consider a singleton consisting of a single element <code>()</code> as an object that corresponds to the product pattern.  We equip it with two projectors: let <code>p</code> and <code>q</code> be functions from a singleton to each of the components of the product.  Both of them choose fixed elements in the corresponding sets.  Since the product is universal, there exists a (unique) morphism <code>m</code> from a singleton to a product.  This morphism selects an element from the set of the product, that is, a fixed pair, and factorizes the projectors: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p</span></span> = fst . m q = snd . m</code> </pre> <br>  If we substitute the single element of singleton <code>()</code> into these equations, we get: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">p</span></span> () = fst (m ()) q () = snd (m ())</code> </pre> <br>  Since <code>m ()</code> is an element of the product chosen by the morphism <code>m</code> , these equations mean that the element <code>p ()</code> chosen by the projector <code>p</code> from the first set is the first component of the pair chosen by <code>m</code> .  Similarly, <code>q ()</code> is equal to the second component.  This is fully consistent with the interpretation of the elements of the set-product as pairs of elements from the multipliers. <br><br>  However, for such a copy, such a simple interpretation does not exist.        ,     ,         ,     .        (  ,    ,         ).          .         ( )         ( ). <br><br>        ;   ,        <strong>Set</strong> .     .    . <br><br>           (     <em></em> ),       . ,           .        ‚Äî        .   ,       ,   . <br><br>      ,               . ,           <code>()</code> .     <code>unit</code> .        ,    . <br><br>    ,     , . .   ,  .    ,  ,         .     ‚Äî    ,  . <br><br><h2>  </h2><br><ol><li> ,         . </li><li>        ? :   . </li><li>        ? </li><li>   <code>Either</code>  Haskell      (   Haskell). </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Show what </font></font><code>Either</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is more appropriate to copy than </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, equipped with two attachments:</font></font><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">int</span></span> i(int n) { return n; } int j(bool b) { return b ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hint: define function </font></font><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">int</span></span> m(<span class="hljs-type"><span class="hljs-type">Either</span></span> const &amp; e);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which factorizes </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>j</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Continued) Argue why </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with two attachments </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>j</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may not be preferable </font></font><code>Either</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Continued) How about such an investment? </font></font><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">int</span></span> i(int n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) return n; return n + <span class="hljs-number"><span class="hljs-number">2</span></span>; } int j(bool b) { return b ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offer the unsuccessful candidate for coproducts for </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will be worse </font></font><code>Either</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because it allows several morphisms in </font></font><code>Either</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ol><br><h2>  Literature </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Catsters, </font></font><a href="https://www.youtube.com/watch%3Fv%3DupCSDIO9pjc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Products and Coproducts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video.</font></font><br><br><h2>  Thanks </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The author is grateful to Gershom Bazerman for reviewing the post before publication and fruitful discussions. </font></font></div><p>Source: <a href="https://habr.com/ru/post/271927/">https://habr.com/ru/post/271927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271911/index.html">Equivalent transformations of Maxwell equations (ps)</a></li>
<li><a href="../271913/index.html">We test the quality of VoIP passing through common channels (Windows)</a></li>
<li><a href="../271915/index.html">.NET-hardcore in Moscow</a></li>
<li><a href="../271919/index.html">The digest of interesting materials for the mobile developer # 131 (November 23-29)</a></li>
<li><a href="../271921/index.html">Record a video call from the browser: we hoped to file a week</a></li>
<li><a href="../271929/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ187 (November 23 - 29, 2015)</a></li>
<li><a href="../271931/index.html">How is the rendering frame in GTA V</a></li>
<li><a href="../271935/index.html">What is under the hood of travel startups or why does a programmer need to go to Hack`n`Roll</a></li>
<li><a href="../271937/index.html">5 major risks in custom software development</a></li>
<li><a href="../271939/index.html">Asterisk + LUA: quick start</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>