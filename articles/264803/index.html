<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplify the for-cycle index: range-based version</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By the will of fate, I had the opportunity to tackle one task of automation using a Python script. Studying the basic constructions, I was most intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplify the for-cycle index: range-based version</h1><div class="post__text post__text-html js-mediator-article">  By the will of fate, I had the opportunity to tackle one task of automation using a Python script.  Studying the basic constructions, I was most interested in the following code: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) : do_stuff()</code> </pre> <br>  Convenient, readable, succinctly (fashionable, stylish, youth)!  Why not arrange the same cycle in C ++?  What came of it - under the cut. <br><a name="habracut"></a><br><h4>  Attempt the first - macros </h4><br>  Much has been written about the disadvantages of macros.  And the main rule says: "If you can implement something without using macros, do so."  But <a href="http://habrahabr.ru/post/246971/">sometimes the</a> use of macros is justified. <br>  Macros are often used to extend a language with non-standard constructions ‚Äî for example, to enter a perpetual loop keyword for more readable code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> infinite_loop while(true) infinite_loop { do_stuff(); }</span></span></code> </pre><br>  By the way, we also wondered about the implementation of a non-standard cycle.  What if you try to implement this business using macros.  Like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define ranged_for(var, min, max, step) for(auto var = (min); var &lt; (max); var += (step) ) int main() { ranged_for(i, 0, 10, 1) { std::cout &lt;&lt; i &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br>  Of course, this code performs its task, but the goal is more than not achieved - instead of making the code more readable and concise, we have rather confused it more. <br><br>  In addition, there are several other disadvantages: <br><ul><li>  <i>Unreadable names.</i>  Macros are autochange.  If you use simple names in the name and arguments of the macro, then there is a great chance of collisions with the user code.  A case in point is the collision of the <i>min</i> \ <i>max</i> macro from <i>Windows.h</i> with the functions of the standard library <i>std :: min</i> \ <i>std :: max</i> .  Therefore, it is often necessary to use unreadable names in order to avoid the described problem. </li><li>  <i>No overload.</i>  Macros are autochange.  If you write several macros with the same name, only one of them will be available.  Therefore, it is impossible to write several versions of the same macro.  And we would like to just like in Python. </li></ul><br>  And what can I say - it is absolutely not similar to the example from Python. <br><br><h4>  Attempt two - collection function generator </h4><br>  If you carefully read the <i>range ()</i> <a href="http://pythonicway.com/education/basics/5-range">documentation</a> from Python, you can see that <i>range ()</i> generates a list of all values ‚Äã‚Äãin the range at once.  We will do the same and write a function that will return <i>std :: vector</i> where each element is an index value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; range(T min, T max, T step) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_unsigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned&lt;T&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_unsigned &amp;&amp; min &gt; max) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>((max - min) / step); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_unsigned &amp;&amp; size &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, min); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; values.reserve(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (step &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T i = min; i &gt; max; i += step) { values.push_back(i); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T i = min; i &lt; max; i += step) { values.push_back(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; range(T min, T max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range&lt;T&gt;(min, max, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; range(T max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range&lt;T&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, max); }</code> </pre><br>  Given the new syntax for enumerating collection values ‚Äã‚Äãin the C ++ 11 standard, it is possible to write the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : range&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : range&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : range&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : range&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : range&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Vooot, this is already similar to what we want to achieve.  Now it reads "Over all i in the range from 0 to 10".  Agree, it sounds better than ‚ÄúFrom i to 0, while less than 10, increase by 1‚Äù.  As a result, the output of the program will be as follows: <br><br><blockquote>  [0 1 2 3 4 5 6 7 8 9] <br>  [0 1 2 3 4 5 6 7 8 9] <br>  [0 2 4 6 8] <br>  [] <br>  [10 9 8 7 6 5 4 3] <br></blockquote><br><br>  This solution has an obvious disadvantage, which follows from the definition - excessive consumption of resources for this operation.  And the greater the range of values, the more resources the intermediate link consumes.  In Python, to solve this problem, there is an <i>xrange ()</i> function that allows you to generate values ‚Äã‚Äãon the fly. <br><br>  Unfortunately, function generators are not available to us, so we will have to look for another solution. <br><br><h4>  Attempt third, final - pseudo-collection </h4><br>  In order for a custom collection class to support passage using <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based loops</a> , there is nothing to do ‚Äî implement the begin () and end () functions that return iterators to the beginning and end of the collection, respectively.  Additionally, you must implement the class of the iterator itself.  But what if you implement a class that the collection will be only at the interface level, but the internal implementation will not store all the values, but will generate them as necessary? <br><br>  Then a simplified implementation of our class might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">range</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: range(T _min, T _max, T _step = T(<span class="hljs-number"><span class="hljs-number">1</span></span>)) : m_min(_min), m_max(_max), m_step(_step) { } T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m_min + index * m_step); } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;size_type&gt;((m_max - m_min) / m_step); } range_iterator&lt;range&lt;T&gt;&gt; begin() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range_iterator&lt;range&lt;T&gt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, m_min); } range_iterator&lt;range&lt;T&gt;&gt; end() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range_iterator&lt;range&lt;T&gt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, m_min + size() * m_step); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T m_min; T m_max; T m_step; };</code> </pre><br>  All that needs to be stored is the boundaries of the range and pitch.  Then any element of the range can be obtained using simple arithmetic (see <i>operator []</i> ).  The main work is assigned to the iterator class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">range_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T range_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> range_iterator&lt;range_type&gt; self_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::value_type value_type; range_iterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range_type* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range, value_type start_value) : m_range(range), m_value(start_value) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } value_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } self_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_value += m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } self_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">self_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((m_range == other.m_range) &amp;&amp; (equals&lt;value_type&gt;(m_value, other.m_value, m_range-&gt;step()))); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !((*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) == other); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R a, R b, R e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a == b; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(a - b) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(e); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(a - b) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(e); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range_type* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_range; value_type m_value; };</code> </pre><br>  I think in addition it is necessary to clarify the presence of the <i>equals ()</i> function.  Suppose we have a non-integer range, and, say, from 0 to 10 in increments of 0.1.  Comparing iterators is based on comparing current values ‚Äã‚Äãfrom a range stored in each of them.  But comparing floating point numbers in C ++ is just not possible.  More details why you can read <a href="http://habrahabr.ru/post/112953/">here</a> .  Let me just say that if you compare "head on", then most likely the cycle will be infinite.  The best way is to compare the difference with the permissible absolute error.  This is implemented in the <i>equals ()</i> function.  In this case, the absolute error is the step of the range. <br><br>  Now we can really write the cycle in the form we need and at the same time do not spend much on overhead. <br><br>  Full version of the code: <br><div class="spoiler">  <b class="spoiler_title">range.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">range_iterator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_access_iterator_tag, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T range_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> range_iterator&lt;range_type&gt; self_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_access_iterator_tag iterator_category; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::value_type value_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::size_type size_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::difference_type difference_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::pointer pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::const_pointer const_pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::reference reference; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> range_type::const_reference const_reference; range_iterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range_type* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range, value_type start_value) : m_range(range), m_value(start_value) { } range_iterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; range_iterator(self_type&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; range_iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range_iterator&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ~range_iterator() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } value_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } self_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_value += m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } self_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">self_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } self_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--() { m_value -= m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } self_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">self_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } self_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(difference_type n) { <span class="hljs-function"><span class="hljs-function">self_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; tmp.m_value += m_range-&gt;step() * n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } self_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(difference_type n) { m_value += n * m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } self_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-(difference_type n) { <span class="hljs-function"><span class="hljs-function">self_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; tmp.m_value -= n * m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } self_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=(difference_type n) { m_value -= n * m_range-&gt;step(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((m_range == other.m_range) &amp;&amp; (equals&lt;value_type&gt;(m_value, other.m_value, m_range-&gt;step()))); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !((*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) == other); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a, T b, T e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a == b; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(a - b) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(e); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(a - b) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(e); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range_type* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_range; value_type m_value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">range</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"Template type should be a integral-type"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T* pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T* const_pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T&amp; reference; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; const_reference; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> difference_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> range&lt;value_type&gt; self_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">range_iterator</span></span></span><span class="hljs-class">&lt;self_type&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::reverse_iterator&lt;iterator&gt; reverse_iterator; range(value_type _min, value_type _max, value_type _step = value_type(<span class="hljs-number"><span class="hljs-number">1</span></span>)) : m_min(_min), m_max(_max), m_step(_step) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_step == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invalid_argument(<span class="hljs-string"><span class="hljs-string">"Step equals zero"</span></span>); } } range(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; range(self_type&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; range&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ~range() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; _obj) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m_max == _obj.max()) &amp;&amp; (m_min == _obj.min()) &amp;&amp; (m_step == _obj.step()); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> self_type&amp; _obj) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == _obj); } value_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](size_type _index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _DEBUG </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_index &gt; size()) { throw std::out_of_range(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Index out-of-range"</span></span></span><span class="hljs-meta">); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return (m_min + (_index * m_step)); } bool empty() const { bool is_empty = ((m_max </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; m_min) &amp;&amp; (m_step &gt; 0)); is_empty |= ((m_max &gt; m_min) &amp;&amp; (m_step &lt; 0)); return is_empty; } size_type size() const { if (empty()) { return 0; } return static_cast&lt;size_type&gt;((m_max - m_min) / m_step); } value_type min() const { return m_min; } value_type max() const { return m_max; } value_type step() const { return m_step; } iterator begin() const { iterator start_iterator(this, m_min); return start_iterator; } iterator end() const { iterator end_iterator(this, m_min + size() * m_step); return end_iterator; } reverse_iterator rbegin() const { reverse_iterator start_iterator(end()); return start_iterator; } reverse_iterator rend() const { reverse_iterator end_iterator(begin()); return end_iterator; } private: value_type m_min; value_type m_max; value_type m_step; };</span></span></span></span></code> </pre><br><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/264803/">https://habr.com/ru/post/264803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264793/index.html">Brief history of the emergence of Mathematica</a></li>
<li><a href="../264795/index.html">When size matters</a></li>
<li><a href="../264797/index.html">I can do without Git, yeah</a></li>
<li><a href="../264799/index.html">Introduction to High Frequency Trading (HFT)</a></li>
<li><a href="../264801/index.html">Contingency Tables: Log Linear Models and Markov Networks</a></li>
<li><a href="../264805/index.html">Test lab v.8 - pentest laboratory, built on the basis of a real corporate network</a></li>
<li><a href="../264807/index.html">Does the amount of data on the complexity of the development. Accounting in the anthill</a></li>
<li><a href="../264811/index.html">Clustering graphs and searching for communities. Part 2: k-medoids and modifications</a></li>
<li><a href="../264815/index.html">As we raised the IT infrastructure [from the bottom]</a></li>
<li><a href="../264819/index.html">Asterisk Manager Interface in dialplan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>