<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Debug as a process</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is believed that the development takes about 10% of the time, and debugging - 90%. Perhaps this statement is exaggerated, but any developer would a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Debug as a process</h1><div class="post__text post__text-html js-mediator-article">  It is believed that the development takes about 10% of the time, and debugging - 90%.  Perhaps this statement is exaggerated, but any developer would agree that debugging is an extremely resource-intensive process, especially in large multi-threaded systems. <br><br>  Thus, the optimization and systematization of the debugging process can bring significant benefits in the form of man-hours saved, increasing the speed of solving problems and, ultimately, increasing the loyalty of your users. <br><br><img src="https://habrastorage.org/webt/lm/eb/rk/lmebrkzzdxjbw-vsbub7ybrlxjq.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://dotnext-piter.ru/2018/spb/people/6arcrxmk6kgkkmkcssoe0a/">Sergey Schegrikovich</a> (dotmailer) at the <a href="https://dotnext-piter.ru/">DotNext 2018</a> conference <a href="https://dotnext-piter.ru/">Piter</a> suggested looking at debugging as a process that can be described and optimized.  If you still do not have a clear search plan for bugs - under the cut video and text interpretation of the report of Sergey. <br><br>  (And at the end of the post, we added the appeal of <a href="https://twitter.com/jonskeet">John Skit</a> to all the workers, be sure to take a look) <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Paxi4K5Om1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  My goal is to answer the question: how to fix bugs effectively and what should be the focus.  I think the answer to this question is a process.  The process of debugging, which consists of very simple rules, and you know them well, but probably use them unconsciously.  Therefore, my task is to systematize them and by example show how to become more effective. <br><br>  We will develop a common language of communication during debugging, as well as see a direct path to finding the main problems.  In my examples, I will show what happened because of a violation of these rules. <br><br><h2>  Debugging Utilities </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/292/518/f94/292518f94ecd468e034d8ec952398980.png"><br>  Of course, any debugging is impossible without debugging utilities.  My favorites are: <br><br><ul><li>  <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg">Windbg</a> , which in addition to the debugger itself, has a rich functionality for studying memory dumps.  A memory dump is a slice of the process state.  In it you can find the value of the fields of objects, call-stack, but, unfortunately, the memory dump is static. <br></li><li>  <a href="https://blogs.msdn.microsoft.com/dotnet/2012/10/09/improving-your-apps-performance-with-perfview/">PerfView</a> is a profiler written on top of <a href="https://docs.microsoft.com/ru-ru/windows/desktop/ETW/event-tracing-portal">ETW technology</a> . <br></li><li>  <a href="https://live.sysinternals.com/">Sysinternals</a> is a utility written by <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%2583%25D1%2581%25D1%2581%25D0%25B8%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B8%25D1%2587,_%25D0%259C%25D0%25B0%25D1%2580%25D0%25BA">Mark Russinovich</a> , which allows you to dig a little further into the device of the operating system. <br></li></ul><br><h2>  Falling service </h2><br>  Let's start with an example from my life in which I will show how the haphazardness of the debugging process leads to inefficiency. <br><br>  Probably everybody has such a thing when you come to a new company in a new team for a new project, from the very first day you want to inflict irreparable benefits.  So it was with me.  At that time, we had a service that took html to the input, and issued pictures to the output. <br><br>  The service was written under .Net 3.0 and it was a long time ago.  This service had a small feature - it fell.  Fell often, about once every two to three hours.  We fixed it elegantly - put it in the properties of the restart service after the fall. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/b02/1a2/0ccb021a20b6c50d1639cd3e2bef7c28.png"><br><br>  The service was not critical for us and we could survive it.  But I joined the project and the first thing I decided to do was fix it. <br><br>  Where do .NET developers go if something doesn't work?  They go to the EventViewer.  But there I did not find anything, except the record that the service fell.  There were no native bug reports, no call stack. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be3/bdf/2fe/be3bdf2fe39777092ad0f2989e35d92e.png"><br><br>  There is a proven tool for what to do next - we wrap the whole <code>main</code> in <code>try-catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); }</code> </pre><br>  The idea is simple: <code>try-catch</code> will work, will log us a mistake, we will read it and fix the service.  We compile, deploy to production, service drops, there is no error.  Add another <code>catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); }</code> </pre><br>  We repeat the process: the service crashes, there are no errors in the logs.  The last thing that can help is <code>finally</code> , which is always called. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { LogEndOfExecution(); }</code> </pre><br>  We compile, deploy, the service crashes, there are no errors.  Three days pass behind this process, now the thought is coming that we should finally start thinking and doing something else.  You can do a lot of things: try to reproduce the error on the local machine, watch memory dumps and so on.  It seemed like two more days and I would fix this bug ... <br><br>  Two weeks passed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1eb/f02/0c3/1ebf020c3dde595f5423fd8247c3137b.png"><br><br>  I looked in PerformanceMonitor, where I saw a service that crashes, then rises, then crashes again.  This condition is called <i>despair</i> and looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/e07/904/98be07904a35b99130ba9ddf871af47f.png"><br><br>  In this variety of tags, are you trying to understand where the problem really is?  After several hours of meditation, the problem suddenly shows up: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/379/2ba/caa/3792bacaa7c418f5fcffa318729bf1a0.png"><br><br>  The red line is the number of native handles owned by the process.  A native handle is a link to an operating system resource: file, registry, registry key, mutex, and so on.  For some strange coincidence, the fall in the growth of the number of handles coincides with the moments of the drop in service.  This suggests that there is a handle leak somewhere. <br><br>  We take a memory dump, open it in WinDbg.  We start to execute commands.  Let's try to look at the queue of finalizing those objects that should be released by the application. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">000</span></span>&gt; !FinalizeQueue</code> </pre><br>  At the very end of the list, I found a web browser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6f/aa5/eb3/d6faa5eb38c3b7a4429e55d7f8af655e.png"><br>  The solution is simple - take WebBrowser and call <code>dispose</code> for it: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webBrowser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebBrowser()) { <span class="hljs-comment"><span class="hljs-comment">// Processing ... } }</span></span></code> </pre><br>  The conclusions from this story can be made as follows: two weeks is too long and too long to find an undistorted <code>dispose</code> ;  The fact that we have found a solution to the problem is luck, since there was not any particular approach, there was no systematic approach. <br><br>  After that, I had a question: how to debug effectively and what to do? <br><br>  To do this, you need to know all three things: <br><br><ol><li>  Debugging rules <br></li><li>  Algorithm for finding errors. <br></li><li>  Proactive debugging techniques. <br></li></ol><br><h2>  Debugging rules </h2><br><ol><li>  Repeat the error. <br></li><li>  If you have not corrected the error, then it is not corrected. <br></li><li>  Understand the system. <br></li><li>  Check the plug. <br></li><li>  Divide and rule. <br></li><li>  Freshen up <br></li><li>  This is your bug. <br></li><li>  Five why. <br></li></ol><br>  These are fairly clear rules that describe themselves. <br><br>  Repeat the error.  Very simple rule, because if you can not repeat the error, then perhaps there is nothing to fix.  But there are different cases, especially for bugs in a multi-threaded environment.  We somehow had a mistake that appeared only on Itanium processors and only on production servers.  Therefore, the first task in the debugging process is to find a test bench configuration on which the error would be reproduced. <br><br>  If you have not corrected the error, then it is not corrected.  Sometimes it happens like this: there is a bug in the bug tracker that appeared half a year ago, no one has seen it for a long time, and there is a desire to just close it.  But at this moment we miss the chance for knowledge, the chance to understand how our system works and what really happens to it.  Therefore, any bug is a new opportunity to learn something, to learn more about your system. <br><br>  Understand the system.  Brian Kernigan said once that if we were so smart to write this system, then we need to be doubly smart to debug it. <br><br>  A small example to the rule.  Our monitoring draws graphics: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/bfa/85b/4cfbfa85be2cf375741646b55aa373e6.png"><br>  This is a graph of the number of requests processed by our service.  Once looking at it, we came up with the idea that it would be possible to increase the speed of the service.  In this case, the graph will rise, it may be possible to reduce the number of servers. <br><br>  Optimization of web-performance is done simply: we take PerfView, we start it on the production machine, it removes the trace within 3-4 minutes, we take this trace to the local machine and begin to study it. <br><br>  One of the statistics PerfView shows is the garbage collector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/ed0/c3f/d3aed0c3f4d3c6de77840aa9ffc10004.png"><br><br>  Looking at these statistics, we saw that the service spends 85% of its time on garbage collection.  You can see in PerfView exactly where this time is spent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/cd2/e4a/bb5cd2e4a54d4f71d832482217233281.png"><br><br>  In our case, this is the creation of strings.  The correction suggests itself: we replace all strings with StringBuilders.  Locally we get a performance boost of 20-30%.  Deploy to production, we look at the results in comparison with the old schedule: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/d63/21d/060d6321d41fa993d80d7b9d19d2d95c.png"><br><br>  The rule "Understand the system" is not only about how to understand how your system interacts, how messages go, but about how to model your system. <br><br>  In the example, the graph shows the bandwidth.  But if you look at the whole system from the point of view of queuing theory, it turns out that the throughput of our system depends on only one parameter - on the rate at which new messages arrive.  In fact, the system simply did not have more than 80 messages at a time, so optimizing this schedule will not work. <br><br>  Check the plug.  If you open the documentation of any home appliance, then it will surely be written there: if the appliance does not work, check that the plug is plugged in.  After several hours in the debugger, I often find myself thinking that I just had to recompile it, or simply pick up the latest version. <br><br>  The rule ‚Äúcheck plug‚Äù is about facts and data.  Debugging does not start with running WinDbg or PerfView on production machines; it starts with checking facts and data.  If the service does not respond, maybe it just is not running. <br><br>  Divide and rule.  This is the first and probably the only rule that includes debugging as a process.  It is about hypotheses, their nomination and verification. <br><br>  One of our services did not want to stop. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f2/cff/169/4f2cff1697473f917e815384d773149a.png"><br><br>  We make a hypothesis: perhaps in the project there is a cycle that processes something endlessly. <br><br>  You can test the hypothesis in different ways, one of the options is to take a memory dump.  From the dump, we pull out the call-stack of all threads using the <code>~*e!ClrStack</code> .  We start to look and see three streams. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a54/35b/1d3a5435b697646daaf802e2bd838c7e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f3/185/6b2/2f31856b23147722d7b3e534689572f8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/ac7/760/d0fac7760f4e8e201d0f028c4deae23e.png"><br><br>  The first thread is in the Main, the second is in the <code>OnStop()</code> handler, and the third thread is waiting for some internal tasks.  Thus, our hypothesis is not justified.  There is no looping, all threads are waiting for something.  Most likely, deadlock. <br><br>  Our service works as follows.  There are two tasks - initialization and working.  The initialization opens the connection to the database, the worker starts processing the data.  The connection between them occurs through a common flag, which is implemented using <code>TaskCompletionSource</code> . <br><br>  We make the second hypothesis: perhaps we have a deadlock of one task to the second.  To check this, you can view each task separately through WinDbg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/536/1cf/c0f5361cf09ba6cd40d9a72e6d5dfb06.png"><br><br>  It turns out that one of the tasks fell, and the second did not.  In the project we saw the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  It means that the initialization task opens a connection and then sets <code>TaskCompletionSource</code> to true.  And what if Exception falls here?  Then we do not have time to set <code>SetResult</code> to true, so the fix to this bug was: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { _initLock.SetException(ex); }</code> </pre><br>  In this example, we put forward two hypotheses: about an infinite loop and about deadlock.  The rule "divide and conquer" helps to localize the error.  By successive approximations, such problems are solved. <br><br>  The most important thing about this rule is hypotheses, because over time they turn into patterns.  And depending on the hypothesis, we apply different actions. <br><br>  Freshen up  This rule is that you just need to get up from the table and walk, drink water, juice or coffee, do anything, but most importantly - to distract from their problems. <br><br>  There is a very good method called "duck".  According to the method, we must tell our <i>duckwork</i> about the problem.  As a <i>duck</i> you can use a colleague.  Moreover, he does not have to answer, it is enough to listen and agree.  And often, after the first problems are discussed, you yourself find a solution. <br><br>  This is your bug.  I will tell about this rule on an example. <br><br>  There was a problem with one <code>AccessViolationException</code> .  Looking in the call-stack, I saw that it arose when we generated a LinqToSql query inside the sql client. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd2/849/7a6/fd28497a66853c5bcf17eaa9d978524a.png"><br><br>  For this bug it was clear that the integrity of the memory was violated somewhere.  Fortunately, at that time we already used the change management system.  In the end, after a couple of hours, it became clear what happened: we put .Net 4.5.2 on our production machines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/bc8/438/f24bc84388e43df0ad4e7af27c0bbc24.png"><br><br>  Accordingly, we send a bug to Microsoft, they review it, we communicate with them, they fix the bug in .Net 4.6.1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/c39/535/44ac39535a874ff0ea0f599a55f07252.png"><br><br>  For me, this resulted in 11 months of work with Microsoft support, of course, not daily, but just 11 months passed from start to fix.  In addition, we sent them dozens of gigabytes of memory dumps, we put hundreds of private builds to catch this error.  And all this time, we could not tell our customers that Microsoft was to blame, not us.  Therefore, the bug is always yours. <br><br>  Five why.  We use Elastic in our company.  Elastic is good for log aggregation. <br><br>  You come to work in the morning, and Elastic lies. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/c80/09b/1a1c8009b49f9c288b3c4b29daf194cc.png"><br><br>  The first question is why does Elastic lie?  Almost immediately it became clear - Master Nodes fell.  They coordinate the work of the entire cluster and, when they fall, the entire cluster stops responding.  Why didn't they get up?  Probably should be autostart?  Looking for an answer, found - does not match the version of the plugin.  Why did Master Nodes fall at all?  OOM Killer killed them.  This is such a thing on linux-machines that, in the event of a shortage of memory, closes unnecessary processes.  Why is there not enough memory?  Because the update process started, which follows from the system logs.  Why did it work before, but not now?  But because we added new nodes a week earlier, accordingly, Master Nodes took more memory to store indexes and cluster configurations. <br><br>  Questions "why?" Help find the root of the problem.  In the example, we could turn away from the correct path many times, but the full fix looks like this: updating the plugin, starting services, increasing memory and making a note for the future, that next time, when adding new nodes to the cluster, you need to make sure that the Master has enough memory Nodes. <br><br>  Applying these rules reveals real problems, shifts your focus to solving these problems, and helps you communicate.  But it would be even better if these rules formed the system.  And there is such a system, it is called a debugging algorithm. <br><br><h2>  Debugging algorithm </h2><br>  I first read about the debugging algorithm in John Robbins‚Äôs book Debugging Applications.  It describes the debugging process as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/2af/a07/f1e2afa078f2ab8587467660b25df052.png"><br><br>  This algorithm is useful for its internal cycle - working with a hypothesis. <br><br>  With each turn of the cycle, we can check ourselves: do we know more about the system or not?  If we put forward hypotheses, check them, they don‚Äôt work, we don‚Äôt learn anything new about the system‚Äôs work, then it‚Äôs probably time to freshen up.  Two actual questions for this moment: what hypotheses have you already tested and what hypothesis are you testing now. <br><br>  This algorithm agrees very well with the debugging rules that we talked about above: repeat the error - this is your bug, describe the problem - understand the system, formulate a hypothesis - divide and rule, test the hypothesis - check the plug, make sure that five are corrected. <br><br>  For this algorithm, I have a good example.  On one of our web services, there was an exception. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/a57/d71/206a57d711a7c783c9f22389120d1bf8.png"><br><br>  Our first thought is not our problem.  But according to the rules, this is still our problem. <br><br>  First, we repeat the mistake.  For every thousand requests there is approximately one <code>StructureMapException</code> , so we can reproduce the problem. <br><br>  Secondly, we try to describe the problem: if the user makes an http request to our service at the moment when StructureMap tries to make a new dependency, then an exception occurs. <br><br>  Thirdly, we hypothesize that StructureMap is a wrapper and there is something inside that throws an internal exception.  We test the hypothesis using procdump.exe. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">procdump</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-e</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">StructureMap</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">w3wp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span></code> </pre><br>  It turns out that inside lies a <code>NullReferenceException</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/773/500/2da773500ffd18d1c28b91f6ff5b45e3.png"><br><br>  Exploring the call-stack of this exception, we understand that it occurs inside the object-builder in StructureMap itself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fd/347/8fc/5fd3478fc54df6295244471a33560a3d.png"><br><br>  But <code>NullReferenceException</code> is not the problem itself, but the consequence.  You need to understand where it occurs and who generates it. <br><br>  We put forward the following hypothesis: for some reason our code returns the null dependency.  Considering that in .Net all objects in memory are located one by one, if we look at the objects on the heap that lie before a <code>NullReferenceException</code> , then they may indicate to us the code that generated the exception. <br><br>  In WinDbg there is a command - List Near Objects <code>!lno</code> .  It shows that an object of interest to us is a lambda function, which is used in the following code. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompoundInterceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindInterceptor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { CompoundInterceptop interceptor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_locker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interceptorArray = _interceptors.FindAll(i =&gt; i.MatchesType(type)); interceptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompoundInterceptor(interceptorArray); _analyzedInterceptors.Add(type, interceptor); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor; }</code> </pre><br>  In this code, we first check if there is a value in the <code>Dictionary</code> in the <code>_analyzedInterceptors</code> , if we don‚Äôt find it, then we add a new value inside the <code>lock</code> . <br><br>  In theory, this code can never return null.  But the problem here is in <code>_analyzedInterceptors</code> , which uses a regular <code>Dictionary</code> in a multi-threaded environment, rather than a <code>ConcurrentDictionary</code> . <br><br>  The root of the problem is found, we have updated to the latest version of StructureMap, we are sure, we are convinced that everything has been fixed.  The last step of our algorithm is ‚Äúlearn and tell‚Äù.  In our case, it was a search in the code of all <code>Dictionary</code> , which are used in lock'e and check that all of them are used correctly. <br><br>  So, the debugging algorithm is an intuitive algorithm that significantly saves time.  He focuses on the hypothesis - and this is the most important thing in debugging. <br><br><h2>  Proactive debugging </h2><br>  At its core, proactive debugging answers the question ‚Äúwhat happens when a bug appears‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/718/900/7aa71890010a8c32900fa5b01e0b690a.png"><br><br>  The importance of proactive debugging techniques can be seen in the bug life cycle diagram. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be0/f6f/06c/be0f6f06cb0c810ca6b19cb861d998c4.png"><br><br>  The problem is that the longer the bug lives, the more resources (time) we spend on it. <br><br>  The debugging rules and the debugging algorithm focus us on the moment when the bug is found and we can think of what to do next.  In fact, we want to shift our focus at the time of the creation of the bug.  I believe that we should do the Minimum Debuggable Product (MDP), that is, such a product that has the minimum necessary set of infrastructure for efficient debugging in production. <br><br>  MDP consists of two things: a fitness function and a USE method. <br><br>  Fitness features.  They were popularized by Neil Ford and co-authors in the book ‚ÄúBuilding Evolutionary Architectures‚Äù.  At its core, fitness functions, according to the authors of the book, look like this: there is an application architecture that we can cut at different angles, obtaining such architectural properties as <i>maintainability</i> , <i>performance</i> , etc., and for each such cut we must write a test - fitness -function.  Thus, the fitness function is a test for architecture. <br><br>  In the case of MDP, the fitness function is a debuggability check.  To write such tests, you can use anything: NUnit, MSTest, and so on.  But, since debugging is often work with external tools, I‚Äôll show using Powershell unit testing framework using an example.  Its plus here is that it works well with the command line. <br><br>  For example, inside the company we agree that we will use specific libraries for logging;  when logging we will use specific patterns;  pdb symbols should always be given to the symbol server.  This will be the conventions that we will test in our tests. <br><br><pre> <code class="hljs pgsql">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains line numbers in PDBs'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-ChildItem -<span class="hljs-type"><span class="hljs-type">Path</span></span> . -Recurse -<span class="hljs-keyword"><span class="hljs-keyword">Include</span></span> @("*.exe", "*. dll ") ` | <span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> { &amp;symchk.exe /v "$_" /s "\\network\" *&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> } ` | <span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> { $_ -<span class="hljs-keyword"><span class="hljs-keyword">like</span></span> "*Line nubmers: TRUE*" } ` | Should -<span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  This test verifies that all pdb symbols were given to the symbol server and were given correctly, that is, those that contain line numbers inside.  To do this, we take the compiled version of the production, find all the exe-and dll-files, skip all these binaries through the utility syschk.exe, which is included in the package "Debugging tools for windows".  The syschk.exe utility checks the binary with the symbol server and, if it finds a pdb file, prints a report about it.  In the report we are looking for the string "Line numbers: TRUE".  And in the final check that the result was not "null or empty". <br><br>  Such tests must be built into the continuous deployment pipeline.  After having passed the integration tests and unit tests, the fitness functions are launched. <br><br>  I will show another example of checking the necessary libraries in the code. <br><br><pre> <code class="hljs pgsql">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains package for logging'</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-ChildItem -<span class="hljs-type"><span class="hljs-type">Path</span></span> . -Recurse -<span class="hljs-type"><span class="hljs-type">Name</span></span> "packages.config" ` | <span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>-Content "$_" } ` | <span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> { $_ -<span class="hljs-keyword"><span class="hljs-keyword">like</span></span> "*nlog*" } ` | Should -<span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> ‚ÄìBeNullOrEmpty } }</code> </pre><br>  In the test, we take all the packages.config files and try to find the nlog libraries in them.  Similarly, we can verify that the correlation id field is used inside the nlog field. <br><br>  USE methods.  The last thing MDP consists of is the metrics that need to be collected. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will demonstrate with the example of the USE method, which was popularized by Brendan Gregg. </font><font style="vertical-align: inherit;">The idea is simple: if there is a problem in the code, it is enough to take three metrics: utilization (use), saturation (saturation), errors (errors), which will help you understand where the problem is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some companies, such as Circonus (they make monitoring soft), </font><font style="vertical-align: inherit;">build </font><font style="vertical-align: inherit;">their </font></font><a href="https://www.circonus.com/2017/08/system-monitoring-with-the-use-dashboard/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dashboards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the form of designated metrics. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/f58/382/70af583826e562f796fb0473c520db15.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look in detail, for example, in memory, then use is the amount of free memory, saturation is the number of disk accesses, errors are any errors that have appeared. </font><font style="vertical-align: inherit;">Therefore, to make products that are convenient for debugging, you need to collect USE metrics for all features and all parts of the subsystem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you take any business feature, then, most likely, it can be divided into three metrics: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use - request processing time. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saturation - the length of the queue. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Errors - any exceptions. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example, let's look at the graph of the number of processed requests that one of our systems makes. </font><font style="vertical-align: inherit;">As you can see, the last three hours the service did not process requests. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/f89/7ab/6ccf897ab0758b344dfc940eb9be548b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first hypothesis that we have done is that the service has dropped and we need to restart it. </font><font style="vertical-align: inherit;">When checking it turns out that the service is working, it uses 4-5% CPU. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9a3/f4a/7e19a3f4a52547627e150401b0f1e7e7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second hypothesis is that an error falls inside the service that we do not see. </font><font style="vertical-align: inherit;">Let's use the etrace utility.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">etrace</span></span> --kernel Process<span class="hljs-regexp"><span class="hljs-regexp"> ^</span></span> --where ProcessName=Ex5-Service<span class="hljs-regexp"><span class="hljs-regexp"> ^</span></span> --clr Exception</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The utility allows you to subscribe to real-time ETW-events and display them on the screen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/d13/52b/f1ad1352bc6e02e3a660f64ce90fdc87.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See that falls </font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But the second question is, why is it not in the logs? </font><font style="vertical-align: inherit;">The answer is quickly - we intercept it, try to clean up the memory, wait a bit and start working again.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ShouldContinue()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Do(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException) { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); GC.CollectionCount(<span class="hljs-number"><span class="hljs-number">2</span></span>); GC.WaitForPendingFinalizers(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following hypothesis - someone eats all the memory. </font><font style="vertical-align: inherit;">According to the memory dump, the most objects are in the cache.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, String&gt; _items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime _nextClearTime = DateTime.UtcNow; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_nextClearTime &lt; DateTime.UtcNow) { _nextClearTime = DateTime.UtcNow.AddHours(<span class="hljs-number"><span class="hljs-number">1</span></span>); _items.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[key]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the code it is clear that every hour the cache should be cleared. </font><font style="vertical-align: inherit;">But the memory was not enough, they did not even reach the cleaning. </font><font style="vertical-align: inherit;">Let's look at an example of the USE cache metric. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/174/634/0c6174634447a3bd1af03adf10c14cbe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graph immediately shows that the memory has increased, errors immediately began. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the conclusions about what proactive debugging is.</font></font><br><br><ul><li>  ‚Äî    .  , ,    ‚Äî    .    ‚Äî    ,      -.     ,       . <br></li><li>     .             ;  Exception ,   ,     -   . <br></li><li> Minimum Debuggable Product ‚Äî  ,          . <br></li></ul><br><h2> ,    ? </h2><br><ol><li>   . <br></li><li>  . <br></li><li>  . <br></li></ol><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time our sponsor is Jon Skeet. </font><font style="vertical-align: inherit;">Even if you are not going to Moscow for a new </font></font><a href="https://dotnext-moscow.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the video is worth watching (John tried very hard).</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p2SQbq-umy4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/420793/">https://habr.com/ru/post/420793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420783/index.html">Dependency management, events and patterns Observer and Mediator</a></li>
<li><a href="../420785/index.html">Work as an IT specialist in the Far East - Sakhalin Region</a></li>
<li><a href="../420787/index.html">Telecom operators were accused of too high tariffs for mass SMS-mailing</a></li>
<li><a href="../420789/index.html">(A | a) architecture: why is this a non-standard metap for developers of high-load systems</a></li>
<li><a href="../420791/index.html">Home robots: what to buy. Overview of available commercial robots for home</a></li>
<li><a href="../420795/index.html">Analyst Misconceptions</a></li>
<li><a href="../420797/index.html">Learning can not be postponed or not only by machine learning is a person alive</a></li>
<li><a href="../420799/index.html">MPS 2018.2: Generator Tests, GitHub Plugin, VCS Aspect, Migration Notifications, and More</a></li>
<li><a href="../420803/index.html">3D printing lessons. Plastic savings when printing non-functional models from 3Dtool</a></li>
<li><a href="../420805/index.html">[Translation] When to use parallel streams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>