<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hilbert curve vs Z-order</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have repeatedly heard the opinion that of all sweeping curves . It is the Hilbert curve that is most promising for spatial indexing. It is motivated...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hilbert curve vs Z-order</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/09/59e309392b501692453703.png"></div><br>  I have repeatedly heard the opinion that of all <a href="https://en.wikipedia.org/wiki/Space-filling_curve">sweeping curves</a> .  It <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2593%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D0%25B0">is the Hilbert curve</a> that <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2593%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D0%25B0">is</a> most promising for spatial indexing.  It is motivated by the fact that it does not contain discontinuities and therefore, in a sense, is ‚Äúwell-arranged.‚Äù  Is this so in reality and what does spatial indexing mean here, let's figure it out under the cat. <br><a name="habracut"></a><br>  The final article from the cycle: <br><br><ul><li>  <a href="https://habrahabr.ru/post/319096/">Why does not the rectilinear approach work when</a> <a href="https://habrahabr.ru/post/319096/"><br></a>  <a href="https://habrahabr.ru/post/319096/">spatial indexing by sweeping curves</a> </li><li>  <a href="https://habrahabr.ru/post/319810/">Algorithm Presentation</a> </li><li>  <a href="https://habrahabr.ru/post/323192/">3D and obvious optimizations</a> </li><li>  <a href="https://habrahabr.ru/post/331420/">8D and prospects in OLAP</a> </li><li>  <a href="https://habrahabr.ru/post/302606/">3D on the sphere, what it looks like</a> </li><li>  <a href="https://habrahabr.ru/post/338088/">3D sphere, benchmarks</a> </li><li>  <a href="https://habrahabr.ru/post/339060/">How about indexing non-point objects?</a> </li></ul><br>  The Hilbert curve has a remarkable property - the distance between two consecutive points on it is always equal to one (the current detail step, more precisely).  Therefore, the data with not very different values ‚Äã‚Äãof the Hilbert curve are located close to each other (the opposite, by the way, is wrong - the neighboring points of Moget differ greatly in meaning).  For the sake of this property it is used, for example, for <br><br><ul><li>  downscaling ( <a href="http://people.csail.mit.edu/jaffer/Color/CSDR">color palette management</a> ) </li><li>  increase locality of access in multidimensional indexing ( <a href="https://drum.lib.umd.edu/handle/1903/804">here</a> ) </li><li>  in antenna construction ( <a href="http://repository.upenn.edu/cgi/viewcontent.cgi%3Farticle%3D1010%26context%3Dese_papers">here</a> ) </li><li>  table clustering ( <a href="https://www.redbooks.ibm.com/redbooks/pdfs/sg248213.pdf">DB2</a> ) </li></ul><br>  As for spatial data, the properties of the Hilbert curve allow to increase the locality of links and improve the efficiency of the database cache, as <a href="https://www.ibm.com/developerworks/data/library/techarticle/dm-0510stolze/index.html">here</a> , where before using the table it is recommended to supplement it with a column with the calculated value and sort by this column. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In spatial search, the Hilbert curve is present in <a href="https://en.wikipedia.org/wiki/Hilbert_R-tree">Hilbert R-trees</a> , where the main idea (very roughly) - when it comes time to split a page into two descendants - we sort all the elements on the page by centroid values ‚Äã‚Äãand divide in half. <br><br>  But we are more interested in another property of the Hilbert curve ‚Äî it is a self-similar sweeping curve.  That allows to use it in an index on the basis of the B-tree.  We are talking about the method of numbering the discrete space. <br><br><ul><li>  Let a discrete space of dimension N be given. </li><li>  Suppose also that we have some way of numbering all points of this space. </li><li>  Then, for indexing point objects, it is enough to place in the index on the basis of the B-tree the numbers of points to which these objects fall. </li><li>  Search in such a spatial index depends on the method of numbering and ultimately comes down to a sample by index from the ranges of values. </li><li>  Sweeping curves are good for their self-similarity, which allows for the generation of a relatively small number of such subintervals, while other methods (for example, a similarity of the lower-case scanning) require a huge number of subqueries, which makes such spatial indexing ineffective. <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/0e/59e30e7caf56f133185573.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/0e/59e30ece6d04d309182255.png"></div><br>  So where does this intuitive feeling come from, that the Hilbert curve is good for spatial indexing?  Yes, there are no gaps in it, the distance between any consecutive points is equal to the sampling step.  So what?  What is the relationship between this fact and potentially high performance? <br><br>  At the very <a href="https://habrahabr.ru/company/2gis/blog/302606/">beginning,</a> we formulated a rule - a ‚Äúgood‚Äù numbering method minimizes the total perimeter of index pages.  We are talking about the pages of the B-tree, on which data will eventually appear.  In other words, index performance is determined by the number of pages to read.  The smaller pages on average for a query of the reference size, the higher the (potential) index performance. <br><br>  From this point of view, the Hilbert curve looks very promising.  But this intuitive sensation cannot be smeared on bread, so we will conduct a numerical experiment. <br><br><ul><li>  consider 2 and 3-dimensional spaces </li><li>  take square / cubic requests of different sizes </li><li>  for a series of random queries of the same type and size, we calculate the average / variance of the number of visible pages in a series of 1000 queries </li><li>  let us proceed from the fact that there is a point at each node of space.  You can jot down random data and check for it, but then there would be questions about the quality of this random data.  And so we have a completely objective indicator of ‚Äúsuitability‚Äù, albeit far from any real data set. </li><li>  200 elements are placed on the page, it is important that this would not be a power of two, which would lead to a degenerate case </li><li>  compare the Hilbert curve and the Z-curve </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/10/59e3105842c38015122244.png"></div><br>  This is how it looks like graphs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/11/59e3112877bd1276826858.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/12/59e312155a5e0917411743.png"></div><br>  Now it is worth at least out of curiosity to see how with a fixed request size (2D 100X100) the number of read pages behaves, depending on the page size. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/12/59e312b8108dc322517140.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/13/59e313240d5c1821852987.png"></div><br>  The ‚Äúpits‚Äù in the Z-order are well visible, corresponding to sizes 128, 256 and 512. And there are ‚Äúpits‚Äù in 192, 384, 768. Not so big. <br><br>  As we can see, the difference can reach 10%, but almost everywhere it is within the statistical error.  Nevertheless, the Hilbert curve everywhere behaves better than the Z-curve.  Not much, but better.  Apparently, this 10% is the upper estimate of the potential effect that can be achieved by switching to the Hilbert curve.  Is the game worth the candle?  Let's try to find out. <br><br><h3>  Implementation. </h3><br>  The use of the Hilbert curve in spatial search encounters a number of difficulties.  For example, the very calculation of a key from 3 coordinates takes (from the author) about 1000 clock cycles, approximately 20 times longer than the same for zcurve.  Perhaps there is some more effective method, in addition, there is an opinion that reducing the number of pages read will pay off any complication of work.  Those.  A drive is a more expensive resource than a processor.  Therefore, we will focus primarily on reading buffers, and we just take note of the times. <br><br>  As for <a href="https://habrahabr.ru/post/319810/">the</a> search <a href="https://habrahabr.ru/post/319810/">algorithm</a> .  In short, it is based on two ideas - <br><br><ol><li>  The index is a B-tree with its page organization.  If we want logarithmic access to the first issuing element, then we should use the ‚Äúdivide and conquer‚Äù strategy like a binary search.  Those.  it is necessary on each iteration on average to divide equally the query into subqueries. <br><br>  But unlike the binary search, in our case, the splitting does not halve the number of disposable elements, but occurs according to the geometric principle. <br><br>  From the self-similarity of sweeping curves, it follows that if we take a square (cubic) lattice emerging from the origin with a step to a power of two, then any elementary cube in this lattice contains one interval of values.  Consequently, by dissecting the search query by the nodes of this lattice, the initial arbitrary subquery can be divided into continuous intervals.  Then each of these intervals is read from the tree. </li><li>  If this process is not stopped, it will cut the original request down to intervals from one element, this is not what we would like.  The stopping criterion is as follows - the query is cut into subqueries until it completely fits on one page of the B-tree.  Once fit - it is easier to read the whole page and filter unnecessary.  How to find out what fit?  We have the minimum and maximum points of the subquery, as well as the current and last points of the page. <br><br>  Indeed, at the beginning of the processing of a subquery, we do a search in the B-tree of the minimum point of the subquery and get a leaf page on which the search stopped and the current position in it. </li></ol><br>  All this is equally true for the Hilbert curve and for the Z-order.  But: <br><br><ul><li>  order is broken for the Hilbert curve - the lower left point of the query is not necessarily less than the upper right (for the two-dimensional case) </li><li>  moreover, it is not necessary to have a maximum at all and / or the minimum of the subquery is in one of its corners, it does not necessarily lie within the request </li><li>  therefore, the real range of values ‚Äã‚Äãcan be much wider than the search query, at worst, this is the entire extent of the layer, if you managed to get into the area around the center </li></ul><br>  This leads to the fact that it is necessary to modify the original algorithm. <br>  For a start, the interface for working with the key has changed. <br><br><ul><li>  <i>bitKey_limits_from_extent</i> - this method is called once at the beginning of the search to determine the true boundaries of the search.  At the input it takes the coordinates of the search extent, gives the minimum and maximum values ‚Äã‚Äãof the search range. </li><li>  <i>bitKey_getAttr</i> - the input takes the interval of values ‚Äã‚Äãof the subquery and also the original coordinates of the search query.  Returns the mask of the following values. <ul><li>  <i>baSolid</i> - this subquery lies entirely inside the search extent, it is not necessary to split it, but you can put the values ‚Äã‚Äãfrom the interval entirely into the output </li><li>  <i>baReadReady</i> - the minimum key for the interval of the subquery lies inside the search extent, you can search in the B-tree.  In the case of zcurve, this bit is always set. </li><li>  <i>baHasSmth</i> - if this bit is not set, this subquery is entirely outside the search query and should be ignored.  In the case of a Z-order, this bit is always set. </li></ul></li></ul><br>  The modified search algorithm looks like this: <br><br><ol><li>  We create a queue of subqueries, initially in this queue a single element - the extent (as well as the minimum and maximum range keys), found by calling <i>bitKey_limits_from_extent</i> </li><li>  While the queue is not empty: <br><ol><li>  We get item from the top of the queue </li><li>  Get information about it using <i>bitKey_getAttr</i> </li><li>  If <i>baHasSmth</i> is not cocked, ignore this subquery. </li><li>  If <i>baSolid</i> is cocked, we read the whole range of values ‚Äã‚Äãright into the resultset and proceed to the next subquery. </li><li>  If <i>baReadReady</i> is cocked, perform a search in the B-tree by the minimum value in the subquery </li><li>  If baReadReady is not set or the stop criterion does not work for this request (it does not fit on one page) <br><ol><li>  Calculate the minimum and maximum values ‚Äã‚Äãof the subquery range </li><li>  Find the discharge key, which will cut </li><li>  We get two subqueries </li><li>  We place them in a queue, first the one with larger values, then the second </li></ol></li></ol></li></ol><br>  Consider the example of the query in the extent [524000,0,484000 ... 525000,1000,485000]. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/17/59e3179847e03588775265.png"></div><br>  This is how the execution of a request for a Z-order looks like - nothing more. <br>  Subqueries - all generated subqueries, results - found points, <br>  lookups - requests to the B-tree. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/18/59e318d2e2bb8703330554.png"></div><br>  Since the range crosses 0x80000, the starting extent is obtained in the size of the entire extent of the layer.  All the most interesting merged in the center, we will consider in more detail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e3/1a/59e31a883accc713716627.png"></div><br>  ‚ÄúClusters‚Äù of subqueries on borders draw attention to themselves.  The mechanism of their occurrence is approximately as follows - let's say, another cut cut off a narrow strip from the search extent border, for example, width 3. Moreover, there are not even points in this strip, but we don‚Äôt know.  We can check only at the moment when the minimum value of the subquery range falls within the search extent.  As a result, the algorithm will cut the strip down to subqueries of sizes 2 and 1 and only then will it be able to query the index to make sure that there is nothing there.  Or have it. <br><br>  This does not affect the number of pages read, all such passes through the B-tree fall on the cache, but the amount of work done is impressive. <br><br>  Well, it remains to find out how many pages were actually read and how long it took.  The following values ‚Äã‚Äãare obtained on the same data and in the same way as <a href="https://habrahabr.ru/post/323192/">before</a> .  Those.  100 000 000 random points in [0 ... 1 000 000, 0 ... 0, 0 ... 1 000 000]. <br><br>  The measurements were conducted on a modest virtual machine with two cores and 4 GB of RAM, so the times have no absolute value, but the numbers of the read pages can still be trusted. <br><br>  The times are shown on the second runs, on the heated server and the virtual machine.  The number of buffers read is on a freshly raised server. <br><table><tbody><tr><th>  NPoints </th><th>  Nreq </th><th>  Type </th><th>  Time (ms) </th><th>  Reads </th><th>  Hits </th></tr><tr><td>  one </td><td>  100,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  .36 <br>  .38 <br>  .63 </td><td>  1.13307 <br>  1.83092 <br>  1.16946 </td><td>  3.89143 <br>  3.84164 <br>  88.9128 </td></tr><tr><td>  ten </td><td>  100,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  .38 <br>  .46 <br>  .80 </td><td>  1.57692 <br>  2.73515 <br>  1.61474 </td><td>  7.96261 <br>  4.35017 <br>  209.52 </td></tr><tr><td>  100 </td><td>  100,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  .48 <br>  .50 ... 7.1 * <br>  1.4 </td><td>  3.30305 <br>  6.2594 <br>  3.24432 </td><td>  31.0239 <br>  4.9118 <br>  465.706 </td></tr><tr><td>  1,000 </td><td>  100,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  1.2 <br>  1.1 ... 16 * <br>  3.8 </td><td>  13.0646 <br>  24.38 <br>  11.761 </td><td>  165.853 <br>  7.89025 <br>  1357.53 </td></tr><tr><td>  10,000 </td><td>  10,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  5.5 <br>  4.2 ... 135 * <br>  14 </td><td>  65.1069 <br>  150.579 <br>  59.229 </td><td>  651.405 <br>  27.2181 <br>  4108.42 </td></tr><tr><td>  100,000 </td><td>  10,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  53.3 <br>  35 ... 1200 * <br>  89 </td><td>  442.628 <br>  1243.64 <br>  424.51 </td><td>  2198.11 <br>  186.457 <br>  12807.4 </td></tr><tr><td>  1,000,000 </td><td>  1,000 </td><td>  zcurve <br>  rtree <br>  hilbert </td><td>  390 <br>  300 ... 10000 * <br>  545 </td><td>  3629.49 <br>  11394 <br>  3491.37 </td><td>  6792.26 <br>  3175.36 <br>  36245.5 </td></tr></tbody></table>  Where <br>  <b>Npoints</b> - the average number of points in the output <br>  <b>Nreq</b> - the number of requests in the series <br>  <b>Type</b> - ' <i>zcurve</i> ' - corrected algorithm with hypercubes and parsing numeric, using its internal structure ,; '  <b>rtree</b> '- gist only 2D rtree;  ' <b>hilbert</b> ' is the same algorithm as for zcurve, but for the Hilbert curve, (*) - in order to compare the search time, it was necessary to reduce the series by 10 times in order for the pages to fit into the cache <br>  <b>Time</b> (ms) - the average query time <br>  <b>Reads</b> - the average number of reads per request.  <b>The most important column.</b> <br>  <b>Shared hits</b> - the number of calls to buffers <br><br>  * - the spread of values ‚Äã‚Äãis caused by high instability of the results, if the required buffers were successfully in the cache, then the first number was observed, in the case of mass slips - the second.  In fact, the second number is typical of the declared Nreq, the first is 5-10 times smaller. <br><br><h3>  findings </h3><br>  It is a little surprising that the ‚Äúknee-length‚Äù assessment of the advantages of the Hubert curve gave a fairly accurate assessment of the real state of affairs. <br><br>  It is seen that on requests where the size of the issue is comparable or more than the page size, the Hubert curve starts to behave better in terms of the number of misses by the cache.  Winning, however, is a few percent. <br><br>  On the other hand, the integral operation time for the Hilbert curve is about twice as bad as that of the Z-curve.  Suppose the author chose not the most efficient way to calculate the curve, for example, something could be done more accurately.  But after all, the calculation of the Hilbert curve is objectively heavier than the Z-curve, in order to work with it, you really need to take substantially more actions.  The feeling is that to play this slowdown with a few percent of the gain in reading the pages will not succeed. <br><br>  Yes, it can be said that in a highly competitive environment, each page reading costs more than tens of thousands of key calculations.  But after all, the number of successful hits in the cache at the Hilbert curve is noticeably larger, and they go through serialization and in the competitive environment are also worth something. <br><br><h3>  Total </h3><br>  The epic narrative about the possibilities and features of spatial and / or multidimensional indices based on self-similar sweeping curves built on B-trees has come to an end. <br><br>  During this time (except that we implement such an index), we found out that in comparison with the R-tree traditionally used in this area <br><br><ul><li>  it is smaller (objectively - due to the better average page fill) </li><li>  faster build </li><li>  does not use heuristics (i.e. it is an algorithm) </li><li>  not afraid of dynamic changes </li><li>  on small and medium requests it works faster. <br>  It plays on large queries (only when there is an excess of memory for the page cache) - where hundreds of pages are involved. <br>  In this case, the R-tree is faster because  filtration occurs only on the perimeter, the processing of which with sweeping curves is noticeably heavier. <br>  Under normal conditions of competition for memory and on such requests, our index is noticeably faster than the R-tree. </li><li>  Without changing the algorithm works with keys of any (reasonable) dimension </li><li>  It is possible to use heterogeneous data in one key, for example, time, object class and coordinates.  At the same time, there is no need to configure any heuristics, in the worst case, if the data ranges are very different, it will result in performance. </li><li>  Spatial objects ((multidimensional) intervals) are treated as points, spatial semantics is processed within the boundaries of search extents. </li><li>  Interval and exact data can be mixed in one key, again, all semantics are taken out, the algorithm does not change </li><li>  All this does not require intervention in the syntax of SQL, the introduction of new types, ... <br>  If you want, you can write a wrapping extension PostgreSQL. </li><li>  And yes, <a href="https://github.com/bmuratshin/zcurve">laid out</a> under the BSD license, allowing for almost complete freedom of action. <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/340100/">https://habr.com/ru/post/340100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340086/index.html">When to be kind is beneficial</a></li>
<li><a href="../340088/index.html">Caution! Angry dog! Or how to tame the registration form</a></li>
<li><a href="../340090/index.html">Simple loading animation in Material Design (CSS3)</a></li>
<li><a href="../340092/index.html">Microsoft Bot Framework + IBM Watson = ... bi-linguistic bot</a></li>
<li><a href="../340096/index.html">Another post "why Agile does not work" (with pictures)</a></li>
<li><a href="../340104/index.html">Western Digital released the first 14 terabyte HDD</a></li>
<li><a href="../340106/index.html">How we drove drug dealers out of the runet</a></li>
<li><a href="../340108/index.html">Accelerate the vagrant shared-folder on the Windows host (UPD. Not everything is so smooth)</a></li>
<li><a href="../340110/index.html">Cocos2d-x - Scenes and special types of nodes</a></li>
<li><a href="../340114/index.html">Monitoring of all web project layers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>