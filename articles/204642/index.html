<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Debugging native code for Android: manual and automated testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the development and growth of the popularity of the Android OS, the number and variety of devices under its control is steadily increasing. Due t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Debugging native code for Android: manual and automated testing</h1><div class="post__text post__text-html js-mediator-article">  With the development and growth of the popularity of the Android OS, the number and variety of devices under its control is steadily increasing.  Due to differences in architecture, purpose, and optimization, the speed and stability of the executable code can vary significantly.  Therefore, to ensure stability and optimization of applications and operating systems, especially using features of a specific architecture, platform, or code ported from other platforms, special attention should be paid to the process of debugging code for Android.  In this article we will talk about the key points and features of working with native-code for Android.  Anyone who is interested in this manual, please under the cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12d/ac2/648/12dac26488114f0db75082ea14bb4cbf.png" alt="image"></div><br><br><a name="habracut"></a>  Back in 2007, Google released a new generation of operating systems - <a href="http://www.openhandsetalliance.com/press_110507.html">Android</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img align="left" src="https://habrastorage.org/getpro/habr/post_images/1e3/d5d/e26/1e3d5de2637a8953c212475a2ab5fe47.png">  Its appearance has made a real revolution in the market of mobile devices, suppressing the hegemony of Microsoft Widows Mobile, Apple iOS and Symbian OS, in consequence of becoming the most popular and mass operating system for mobile systems in the world.  Until now, the popularity of the system <a href="http://habrahabr.ru/company/apps4all/blog/146683/">continues</a> .  Over the past six years, Android has greatly expanded and evolved, and the range of supported devices continues to grow.  Now this operating system is used not only in mobile phones, but also in tablets, TVs, music players, cameras, laptops, nettops and other exotic things, including military equipment.  The fillings of these devices can differ quite noticeably from each other: over the past years, the list of supported architectures has expanded from ARM to MIPS and x86, support has been provided for various peripherals, not to mention the evolving Android API. <br><br>  Such a huge number of different devices, despite their functional and architectural differences, are controlled by the same system, minus platform-specific libraries and optimizations for specific devices.  It is quite natural that Android assemblies and even application libraries often differ from each other, often even depending on the vendor, since performance requirements only increase in the face of fierce competition from the growing market for Android devices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/1dc/3e3/9bb1dc3e3e20b1160fbe6fbbbded5fc3.png"></div><br><br>  Nevertheless, ensuring unification and cross-platform, application speed is one of the priorities of today's market for high-performance applications and system assemblies.  This, first of all, means increased requirements for the operating system itself, which is able to work and do it efficiently on various hardware, as well as high demands on Android applications. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/98b/ae8/ea398bae87272f0f3d01cb72d4b92961.jpg"></div><br><br>  One of the most effective solutions for optimizing and accelerating the operation of applications, the system and its components is optimization at the native, native-level.  In other words, the use of optimized, often hardware-dependent libraries and code for the applications and system, and in a global sense - a number of libraries supplied for each of the target platforms.  Such a variety of hardware platforms, different operating system versions, API platforms, and requirements for ensuring stable and fast operation of applications requires considerable efforts to test applications and libraries for specific configurations. <br><br>  Nevertheless, one of the most convenient tools for Android developers is still the Android NDK - <a href="http://developer.android.com/tools/sdk/ndk/index.html">Android Native Development Kit</a> , which includes almost everything needed to develop and debug applications, libraries, and the system itself. <br><br>  In this article, I will discuss its use for testing and debugging Android native code and testing automation using the example of such a framework as <a href="http://www.gnu.org/software/dejagnu/">DejaGnu</a> . <br>  Android is developing very dynamically, and now DejaGnu comes with almost everything needed for a quick start of testing, both with and without Android NDK.  The main objective of this article will be a story about the nuances and features of testing for Android and some of the pitfalls that engineers may encounter. <br><habracut><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/88e/1e6/575/88e1e657591849dd7f68b5935175e2e1.png">  For a start, a small remark: Android, as you know, is a Unix-like operating system, very similar to regular Linux or BSD, and most Android source code follows a license, <a href="http://source.android.com/source/licenses.html">ASL2.0</a> .  Who worked with Android, knows that a considerable number of Android modules have moved from BSD to a greater extent than from Linux.  However, everything related to native-code and architecture, if not to go into details, is very close and known to all those who used Linux.  Therefore, it is quite possible to use exactly the same or similar tools for developing and debugging code as for Unix-like systems.  In the case of compilers, these are gcc, clang (llvm), icc and others.  The same can be said about the whole GCC toolchain and some other utilities that are either already ported or not very difficult to port. <br><br>  The main reason for including native code or using native libraries in native applications is the desire to increase performance or reuse previously written C / C ++ / ASM code from a Linux / Unix-like system. <br><br>  <b>Advantages of using native code</b> : <br>  ‚Ä¢ High performance <br>  ‚Ä¢ Direct use of CPU / HW features <br>  ‚Ä¢ Ability to reuse existing Linux code <br><br>  <b>Disadvantages of using native code</b> : <br>  ‚Ä¢ Individual setting for CPU / HW <br>  ‚Ä¢ Insufficient support for system libraries <br><br>  Pros and cons require thorough testing, both in terms of code quality, stability, and in terms of its performance on different platforms.  In spite of the fact that one of the postulates of Android is independence from hardware, in order to work on various configurations, in fact, native-code applications are supplied in so-called fat binary (apk, including native-code / libraries for all possible hardware configurations). under which the application will work).  Despite the fact that, ideally, the NDK compiler should create functionally equivalent code for different configurations and, therefore, the libraries for fat binary (or system ones for the image) should be equivalent - this, unfortunately, does not always correspond to reality and requires testing, especially when it comes to optimization (Neon and SSE for example) and the use of third-party libraries. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/007/64f/2d400764fa709bd75f0cec8554636863.png"></div><br><br>  In addition, with the development of the Android OS and devices under its control, various versions of the OS, the delivery of this OS, as well as the specifics of the devices, change regularly.  In some cases, it is justified for the developer to use some kind of optimizations or another compiler to build native code.  Evaluating the performance, correctness and stability of this code on various configurations is the task of the tester who is engaged in Android Native testing. <br>  The process of building, debugging and testing native applications for Android is not much different from the same process on Linux, with the only difference that we collect binary files (executable and libraries) not on Android, but on the host (Linux, MacOS, Windows) and execute on an Android device (physical or emulator).  Therefore, adb - the Android Debug Bridge, which is part of the <a href="http://developer.android.com/tools/sdk">Android SDK</a> , is a universal means of communicating a host with an Android device.  For building and debugging applications, it is advisable to use the toolchain and API that we need, as well as, if necessary (for c ++), the version of the stdc ++ library that interests us. <br><br>  Android native builds can vary by: <br><ol><li>  API versions used: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/61e/586/e4961e58640c72bbf9d39b2da442e2b9.png"></div></li><li>  versions of libstdc ++ used: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/632/661/452/6326614529fe14c8407eaca7fa8fa4d7.png"></div></li><li>  device architecture (target): <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00c/06c/262/00c06c262873e26564c0933abd72b6ca.png"></div></li><li>  bit depth (32, 64 or x32) target: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/277/06d/a5a27706d8e7e1f799064a00daf6f32e.png"></div></li><li>  build host and bit depth: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/8df/67b/2a28df67b19e2ebafbd14dbe73889ec7.png"></div></li></ol><br><br>  However, from the point of view of the developer and the tester, there should be no differences between the resulting code depending on the build host, and it is not necessary to use different configurations of build hosts for testing and testing. <br>  The number of options for testing grows threateningly, and this does not take into account the optimization of the CPU instructions: neon, core-avx2, core-i7, atom, slm;  by size \ speed and other.  All this Cartesian product of variants of the obtained code (source and binary) is the starting point for testing.  In the case when the purpose of testing is the device itself or some custom build of Android, then, quite likely, the main significant difference will be the bionic library - an analogue of the libc library for Android. <br><br>  Having finished the introductory theory, it's time to move on to practice. <br><br><h4>  Tools for manual assembly and testing </h4><br><br>  All the necessary tools are included in the delivery of <a href="http://developer.android.com/tools/sdk/ndk/index.html">Android NDK</a> , which is for 32 and 64 bits under Linux, MacOS, Windows. <br><br><h5>  Creating and running the application </h5><br><br><h6>  gcc </h6><br><pre><code class="bash hljs">bash-4.2$ <span class="hljs-comment"><span class="hljs-comment">#   hello_world.c bash-4.2$ cat ./hello_world.c #include &lt;stdio.h&gt; int main(void) { printf(‚ÄúHello, World!\n‚Äù); return 0; } bash-4.2$ #   Android,  gcc 4.7  x86,  18 bash-4.2$ /users/NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gcc ‚Äìsysroot=/users/NDK_current/platforms/android-18/arch-x86 ./hello_world.c -o ./hello_world.exe bash-4.2$ echo $? 0 bash-4.2$ #,  bash-4.2$ #  bash-4.2$ ./hello_world.exe bash-4.2$ #,     bash-4.2$ #     bash-4.2$ adb devices List of devices attached 0146AFFC18020012 device bash-4.2$ #,   -    bash-4.2$ adb -s 0146AFFC18020012 shell echo 'Hello, Android!' Hello, Android! bash-4.2$ #,       bash-4.2$ export ANDROID_SERIAL=0146AFFC18020012 bash-4.2$ #   bash-4.2$ adb shell echo 'Hello, Android!' Hello, Android! bash-4.2$ #- ,      bash-4.2$ adb push ./hello_world.exe /data/local/ bash-4.2$ #- ,   bash-4.2$ adb shell /data/local/hello_world.exe Hello, World! bash-4.2$ #adb ,   ,    ,    bash-4.2$ adb shell ‚Äú/data/local/hello_world.exe &amp;&amp; echo $?‚Äù Hello, World! 0 bash-4.2$ #,          bash-4.2$ #   ,        bash-4.2$ #  ,        (linux, mac, windows) bash-4.2$ #   ,   -     bash-4.2$ #  ,    -static /users//NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gcc ‚Äìsysroot=/users/ /NDK_current/platforms/android-18/arch-x86 -static ./hello_world.c -o ./hello_world.exe bash-4.2$ echo $? 0 bash-4.2$ #,      -         bash-4.2$ ./hello_world.exe Hello, World! bash-4.2$ echo $? 0 bash-4.2$ #,           bash-4.2$</span></span></code> </pre> <br><br><h6>  g ++ </h6><br><br><pre> <code class="bash hljs">bash-4.2$ <span class="hljs-comment"><span class="hljs-comment">#      g++ bash-4.2$ cat ./hello_world.C #include &lt;iostream&gt; int main(void) { std::cout &lt;&lt; ‚ÄúHello, World!\n‚Äù; return 0; } bash-4.2$ #    STL,  bash-4.2$ #          bash-4.2$ #    ,     bash-4.2$ # ,   -l%STL_LIB%      ! bash-4.2$ #    _shared,   _static  bash-4.2$ #    g++ -L, -I     ‚Äì gnustl/stlport/gabi bash-4.2$ /users/ /NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-g++ ‚Äìsysroot=/users/NDK_current/platforms/android-18/arch-x86 -I/users/NDK_current/sources/cxx-stl/gnu-libstdc++/4.7/include -I/users/NDK_current/sources/cxx-stl/gnu-libstdc++/4.7/libs/x86/include -L/users//NDK_current/sources/cxx-stl/gnu-libstdc++/4.7/libs/x86 ./hello_world.C -o ./hello_world.exe -lgnustl_shared bash-4.2$ echo $? 0 bash-4.2$ #,      -    /   /  bash-4.2$ adb push ./hello_world.exe /data/local/ bash-4.2$ #- ,   bash-4.2$ adb shell ‚Äú/data/local/hello_world.exe &amp;&amp; echo $?‚Äù soinfo_link_image(linker.cpp:1635): could not load library ‚Äúlibgnustl_shared.so‚Äù needed by ‚Äú/data/local/hello_world.exe‚Äù; caused by load_library(linker.cpp:745): library ‚Äúlibgnustl_shared.so‚Äù not foundCANNOT LINK EXECUTABLE bash-4.2$ # ,    bash-4.2$ #libgnustl_shared.so     Android,       bash-4.2$ adb push /users//NDK_current/sources/cxx-stl/gnu-libstdc++/4.7/libs/x86/libgnustl_shared.so /data/local/libgnustl_shared.so bash-4.2$ #,   ,    LD_LIBRARY_PATH bash-4.2$ adb shell ‚Äúexport LD_LIBRARY_PATH=/data/local/:$LD_LIBRARY_PATH &amp;&amp; /data/local/hello_world.exe &amp;&amp; echo $\?‚Äù Hello, World! 0 bash-4.2$ #       ‚Äì /system/lib bash-4.2$ # bash-4.2$ adb shell ‚Äú/data/local/hello_world.exe &amp;&amp; echo $\?‚Äù Hello, World! 0 bash-4.2$</span></span></code> </pre> <br>  If the host and target architectures coincide (usually x86) and root privileges, it is quite possible to use a cunning trick with launching Android x86 binaries on the host if desired.  To do this, you must explicitly use the dynamic linker for Android on the system (/ system / bin / linker), as well as use the non-stripped version of the bionic in the ways (LD_LIBRARY_PATH).  See the example Makefile: ( <a href="">https://android.googlesource.com/platform/bionic/+/master/tests/Android.mk</a> : bionic-unit-tests-run-on-host). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ----------------------------------------------------------------------------- # Run the unit tests built against x86 bionic on an x86 host. # ----------------------------------------------------------------------------- ifeq ($(HOST_OS)-$(HOST_ARCH),linux-x86) ifeq ($(TARGET_ARCH),$(filter $(TARGET_ARCH),x86 x86_64)) ifeq ($(TARGET_ARCH),x86) LINKER = linker else LINKER = linker64 endif # gtest needs ANDROID_DATA/local/tmp for death test output. # Make sure to create ANDROID_DATA/local/tmp if doesn't exist. # bionic itself should always work relative to ANDROID_DATA or ANDROID_ROOT. bionic-unit-tests-run-on-host: bionic-unit-tests $(TARGET_OUT_EXECUTABLES)/$(LINKER) $(TARGET_OUT_EXECUTABLES)/sh if [ ! -d /system -o ! -d /system/bin ]; then \ echo "Attempting to create /system/bin"; \ sudo mkdir -p -m 0777 /system/bin; \ fi mkdir -p $(TARGET_OUT_DATA)/local/tmp cp $(TARGET_OUT_EXECUTABLES)/$(LINKER) /system/bin cp $(TARGET_OUT_EXECUTABLES)/sh /system/bin ANDROID_DATA=$(TARGET_OUT_DATA) \ ANDROID_ROOT=$(TARGET_OUT) \ LD_LIBRARY_PATH=$(TARGET_OUT_SHARED_LIBRARIES) \ $(TARGET_OUT_DATA_NATIVE_TESTS)/bionic-unit-tests/bionic-unit-tests endif endif</span></span></code> </pre><br><br>  Such a trick, for example, is relevant for the execution of binary files without an emulator (in the absence of a 64-bit image or using -mx32). <br><br><h5>  GCOV and profiles </h5><br><pre> <code class="bash hljs">bash-4.2$ <span class="hljs-comment"><span class="hljs-comment"># ,  , - ,          bash-4.2$ #, ,   coverage  bash-4.2$ # ,     ,         bash-4.2$ #     ,   -fprofile-dir=%android_exec_dir% bash-4.2$ #  ,  ,  GCOV_PREFIX  GCOV_PREFIX_STRIP bash-4.2$ #   ,    env      adb ( shell   adb shell %command% bash-4.2$ /users//NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gcc ‚Äìsysroot=/users//NDK_current/platforms/android-18/arch-x86 ./gcov-1.c -fprofile-arcs -fprofile-dir=. -ftest-coverage -lm -o ./gcov-1.exe bash-4.2$ adb push ./gcov-1.exe /data/local/gcov-1.exe bash-4.2$ #adb shell ‚Äúexport GCOV_PREFIX=/data/local &amp;&amp; export GCOV_PREFIX_STRIP=13 &amp;&amp; /data/local/gcov-1.exe &amp;&amp; echo $\?‚Äù bash-4.2$ unset GCOV_PREFIX &amp;&amp; unset GCOV_PREFIX_STRIP &amp;&amp; cd /data/local &amp;&amp; ./gcov-1.exe &amp;&amp; echo $\?‚Äù 0 bash-4.2$ adb shell ls /data/local/gcov-1.gcda /data/local/gcov-1.gcda bash-4.2$ #  bash-4.2$ adb pull /data/local/gcov-1.gcda . bash-4.2$ ls ./gcov-1.gcda ./gcov-1.gcda bash-4.2$ #  NDK  gcov,   ,   bash-4.2$ /users/NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gcov gcov-1.gcda File 'gcov-1.c' Lines executed:100.00% of 6 Creating 'gcov-1.c.gcov' bash-4.2$</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/26d/f41/3a5/26df413a58747eb0876a25cfb79f6807.png" alt="image"></div><br><br><h5>  Debug \ debugging: gdb / logcat </h5><br><br><pre> <code class="bash hljs">bash-4.2$ <span class="hljs-comment"><span class="hljs-comment">#  NDK     , , gdb bash-4.2$ #        -g,      bash-4.2$ /users /NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gcc ‚Äìsysroot=/users/NDK_current/platforms/android-18/arch-x86 ./hello_world.c -o ./hello_world.exe bash-4.2$ adb push ./hello_world.exe /data/local/hello_world.exe bash-4.2$ adb shell gdbserver :5039 /data/local/hello_world.exe &amp; Process /data/local/hello_world.exe created; pid = 29744 Listening on port 5039 bash-4.2$ adb forward tcp:5039 tcp:5039 bash-4.2$ /users/NDK_current/toolchains/x86-4.7/prebuilt/linux-x86/bin/i686-linux-android-gdb hello_world.exe Remote debugging from host 127.0.0.1 libthread_db:td_ta_new: Probing system for platform bug. libthread_db:td_ta_new: Running as root, nothing to do. Hello, World! Child exited with status 0 GDBserver exiting bash-4.2$ cat test.gdb set sysroot /users/igveresx set solib-absolute-prefix /users/igveresx/symbols/ set solib-search-path /users/igveresx/symbols/lib set auto-solib-add on target remote :5039 stepi stepi c Quit bash-4.2$ #       logcat bash-4.2$ adb logcat *:E &gt;logcat.log &amp; bash-4.2$ tail -5 logcat.log E/Intel PowerHAL( 2093): Error in reading vsync hint E/Intel PowerHAL( 2093): Error reading from /sys/devices/system/cpu/cpufreq/interactive/vsync_count: No such file or directory E/Intel PowerHAL( 2093): Error in reading vsync count E/Intel PowerHAL( 2093): Error reading from /sys/devices/system/cpu/cpufreq/interactive/touch_event: No such file or directory E/Intel PowerHAL( 2093): Error in reading vsync hint bash-4.2$ #      kernel bash-4.2$ adb shell dmesg | tail -5 &lt;6&gt;[245665.256198] intel_mdf_battery msic_battery: vbus_volt:4974 &lt;6&gt;[245665.265332] intel_mdf_battery msic_battery: vbatt:4116250 temp:300 &lt;4&gt;[245669.213759] kct_daemon: loop. &lt;4&gt;[245673.213561] kct_daemon: loop. &lt;4&gt;[245677.213379] kct_daemon: loop. bash-4.2$ adb shell 'cat /proc/kmsg' &gt;kmsg.log bash-4.2$ tail -5 kmsg.log &lt;4&gt;[245673.213561] kct_daemon: loop. &lt;4&gt;[245677.213379] kct_daemon: loop. &lt;4&gt;[245681.213248] kct_daemon: loop. &lt;4&gt;[245685.213083] kct_daemon: loop. &lt;4&gt;[245689.212932] kct_daemon: loop. bash-4.2$</span></span></code> </pre> <br><br><h4>  Test Automation </h4><br>  To automate testing, you can use a framework such as dejagnu.  Since February 2013, DejaGnu has included the board androideabi, which allows testing native-code on Android via adb. <br><img align="left" src="http://habrastorage.org/storage3/030/0f6/2bd/0300f62bd94720978d4b31e9701c1ebf.png"><br>  In general, everything is similar to what was described above, with the exception of some nuances. <br><br>  For many dejagnu tests, host / target checks for triplets are crucial.  For example, at least in order to understand whether it is possible to run a binary file on a device, the host = target = build (native) check is often performed.  However, in our case, generally speaking, <i>build_triplet is</i> not equal to <i>target_triplet</i> , but at the same time, we are quite capable of performing and receiving results on Android.  In addition, you should take into account the fact that by default NDK uses the <b>‚Äìfpic</b> flag, which also affects the ability to run tests and their results (check effective-target pic / nonpic).  In the case of <i>static</i> linking, it should be borne in mind that, perhaps, not everything will also meet expectations (the static, dynamic libraries can differ from each other and generate different code ( <i>-fpic / -fpie</i> ). Also, some tests are critical to launch directories or specify a directory for results; and before launching a binary file, change the directory to the desired one.In addition, during the transfer of a binary file to a device, launch rights can be reset (due to the rights to the folder or the rights to the file system ), so it is also worth convincing  sya that the executable file is set executable bit. In addition, the best solution for testing organization is the use of non-sd-card and ram-disk with the correct permissions to avoid rapid wear of the first. <br><br>  To run testing on Android, it‚Äôs enough to run with the host installed dejagnu: <br><br><blockquote>  <b>runtest ‚Äìtarget_board = androideabi</b> </blockquote><br><br>  You should make sure that you have explicitly specified the <b><i>ADB_SERIAL</i></b> variable corresponding to the serial number of your device. <br>  However, it is much more convenient and pleasant to run testing through the local configuration file - site.exp <br><br>  For example, the configuration file to run <a href="http://gcc.gnu.org/">gcc</a> testsuite: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rootme ‚Äú.‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> tmpdir ‚Äú.‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> srcdir ‚Äú/path/to/gcc_%version%_release/gcc/testsuite‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> CFLAGS ‚Äú‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> CXXFLAGS ‚Äú‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GDB ‚Äú/path/to/GDB_UNDER_TEST‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GCOV_UNDER_TEST ‚Äú/path/to/GCOV_UNDER_TEST‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GCC_UNDER_TEST ‚Äú/path/to/GCC_UNDER_TEST‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GXX_UNDER_TEST ‚Äú/path/to/GXX_UNDER_TEST‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GFORTRAN_UNDER_TEST ‚Äúno‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> OBJC_UNDER_TEST ‚Äúno‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> libiconv ‚Äú‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> HOSTCC ‚Äúgcc‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> HOSTCFLAGS ‚Äú‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> TESTING_IN_BUILD_TREE 1 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> GMPINC ‚Äú‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ENABLE_LTO 1 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> HAVE_LIBSTDCXX_V3 1 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> host_triplet i686-pc-linux-gnu <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> build_triplet i686-pc-linux-gnu <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> target_triplet i686-pc-linux-android-gnu <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> target_alias i686-pc-linux-android <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> android_tmp_dir ‚Äú/temporary/folder/on/device/with/executable/permissions‚Äù <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> bridge_tmp_dir ‚Äú/temporary/folder/on/device/with/executable/permissions‚Äù append boards_dir ‚Äú/path/to/share/dejagnu/baseboards‚Äù</code> </pre> <br>  and to run the same gcc: <br><br><pre> <code class="hljs sql">export ADB_SERIAL=$ANDROID_SERIAL make -j $parallel <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> DEJAGNU=/<span class="hljs-keyword"><span class="hljs-keyword">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/site.exp RUNTESTFLAGS=‚Äù‚Äìtarget_board=androideabi‚Äù</code> </pre> <br><br>  Note: Please note that you should make sure that during the launch of the gcc check, someone will not <i>rub the</i> variable <i>GCC_EXEC_PREFIX</i> , and that it is unset. <br><br>  It is worth noting that you should specify not only the path to the compiler, but you should keep in mind everything that we did above manually, namely, to specify: <br><ul><li>  sysroot </li><li>  paths to libraries and header files </li><li>  flags and link libraries (at least for libstdc ++) </li></ul><br><br>  Based on this, the best solution is to use an executable file wrapper from the toolchain (wrapper-binaryname), of the following form: <br><br><h6>  wrapper-gcc </h6><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash /path/to/NDK_folder/toolchains/$arch-%compiler_version%/prebuilt/linux-x86/bin/%arch_prefix%-linux-android-gcc ‚Äìsysroot=/path/to/NDK_folder/platforms/android-${device_platform}/arch-$arch ‚Äú$@‚Äù</span></span></code> </pre><br><br><h6>  wrapper-g ++ </h6><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash echo $@ | grep ‚Äù \-nostdlib‚Äù 1&gt;/dev/null 2&gt;/dev/null if [ $? != 0 ]; then echo $@ | grep ‚Äù \-static‚Äù 1&gt;/dev/null 2&gt;/dev/null if [ $? != 0 ]; then /path/to/NDK_folder/toolchains/$arch-%compiler_version%/prebuilt/linux-x86/bin/%arch_prefix%-linux-android-g++ ‚Äìsysroot=/path/to/NDK_folder/platforms/android-${device_platform}/arch-$arch -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/include -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch/include -L/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch ‚Äú$@‚Äù -lgnustl_shared else /path/to/NDK_folder/toolchains/$arch-%compiler_version%/prebuilt/linux-x86/bin/%arch_prefix%-linux-android-g++ ‚Äìsysroot=/path/to/NDK_folder/platforms/android-${device_platform}/arch-$arch -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/include -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch/include -L/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch ‚Äú$@‚Äù -lgnustl_static fi else /path/to/NDK_folder/toolchains/$arch-%compiler_version%/prebuilt/linux-x86/bin/%arch_prefix%-linux-android-g++ ‚Äìsysroot=/path/to/NDK_folder/platforms/android-${device_platform}/arch-$arch -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/include -I/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch/include -L/path/to/NDK_folder/sources/cxx-stl/%stl lib folder%/%compiler version%/libs/$arch ‚Äú$@‚Äù fi</span></span></code> </pre><br><br>  If necessary, if you need to get some data from Android, then we can use the <b><i>remote_upload</i></b> function ( <b><i>adb_upload% target_board%% source%% dest%</i></b> ).  This functionality should be provided by testsuite. <br><br><h4>  Profiling, performance testing </h4><br><br>  In this article, the details of collecting and using profiles will not be discussed in detail, but for Android, the most common profiling tools are: <br><ul><li>  perf </li><li>  oprofile </li><li>  sep </li></ul><br>  For example, having a static perf assembly, just run: <br><br><pre> <code class="bash hljs">adb push perf /data/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/ adb shell <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /data/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> chmod 777 perf perf record ./coremark.exe 0√ó0 0√ó0 0√ó66 0 7 1 2000 <span class="hljs-comment"><span class="hljs-comment"># or any arguments required # data saved at ./perf.data&lt;/li&gt; export PAGER=cat # otherwise it will look for ‚Äúless‚Äù perf report</span></span></code> </pre><br><br>  Performance testing on Android can be performed not only with the help of benchmarks working through Dalvik, but also at the native-level, i.e.  using benchmarks compiled by the same Android NDK.  As an example: <a href="http://www.spec.org/">SPEC</a> , <a href="http://www.eembc.org/">EEMBC</a> , <a href="http://www.eembc.org/coremark/">CoreMark</a> . <br><br><img src="http://habrastorage.org/storage3/193/048/29f/19304829ff94fed910a3935a01d49c56.gif"><img src="http://habrastorage.org/storage3/b30/156/399/b30156399f744502e2481a479f5c2381.png"><img src="http://habrastorage.org/storage3/17e/ee6/a41/17eee6a41dfd5857e4d0463acaf65158.jpg"><br><br>  I will not dwell on the nuances of porting frameworks for Android (they are similar to the methods described above), but it is worth noting that the principle of using adb to work with devices or emulators is also the basis, as well as critical attention to the processes taking place on devices. <br>  You need to make sure that the result is affected: <br><ul><li>  processor mode </li><li>  applications running in the background </li><li>  clean startup and errors (which can and should be tracked through logcat / dmesg) </li></ul><br><br>  Relevant results can be obtained only on deterministic devices (if we are not talking about obtaining a profile of real use of the device and application).  Therefore, before starting it is necessary to make sure that: <br><ul><li>  All non-essential services and applications are disabled. </li><li>  The device is used exclusively </li><li>  The device is hard set mode </li></ul><br><br>  For example, for testing CPUs, a typical practice is to set all processor cores and frequencies to an equal value and fix them.  If necessary, disable all cores, in addition, on which the testing takes place. <br><br><pre> <code class="bash hljs">adb shell <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> userspace &gt; /sys/devices/system/cpu/cpuX/cpufreq/scaling_governor <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 2000000 &gt; /sys/devices/system/cpu/cpuX/cpufreq/scaling_max_freq <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 2000000 &gt; /sys/devices/system/cpu/cpuX/cpufreq/scaling_min_freq</code> </pre><br><br>  Make sure that the value <br>  <b><i>/ sys / devices / system / cpu / cpuX / cpufreq / online</i></b> is also installed correctly depending on the benchmark \ profile and \ or testing needs. <br>  Just by making sure that everything works in the right mode (cat / proc / cpuinfo) you can begin testing and analysis. <br><br>  To simplify the work and debug the native-code, for Android there is a set of utilities <a href="http://www.busybox.net/">busybox</a> , which is not included in the Android package by default (since it is supplied under the GPL 2.0 license). <br> <code>[, [[, ar, arp, awk, base64, basename, bbconfig, beep, blkid, blockdev, bootchartd, bunzip2, bzcat, bzip2, cal, cat, catv, chat, chattr, chgrp, chmod, chown, chpst, chroot, chrt, chvt, cksum, clear, cmp, comm, cp, cpio, crond, crontab, cttyhack, cut, dc, dd, deallocvt, depmod, devmem, diff, dirname, dmesg, dnsd, dos2unix, dpkg, dpkg-deb, du, dumpkmap, echo, ed, egrep, env, envdir, envuidgid, expand, expr, fakeidentd, false, fbset, fbsplash, fdflush, fdformat, fdisk, fgconsole, fgrep, find, findfs, flash_lock, flash_unlock, flashcp, flock, fold, free, freeramdisk, fsync, ftpd, ftpget, ftpput, fuser, getopt, grep, gunzip, gzip, halt, hd, hdparm, head, hexdump, httpd, hwclock, ifconfig, ifdown, ifup, init, inotifyd, insmod, install, iostat, ip, ipaddr, ipcalc, iplink, iproute, iprule, iptunnel, klogd, less, linuxrc, ln, loadkmap, losetup, lpd, lpq, lpr, ls, lsattr, lsmod, lsof, lspci, lsusb, lzcat, lzma, lzop, lzopcat, makedevs, makemime, man, md5sum, mdev, mesg, mkdir, mkfifo, mknod, mkswap, mktemp, modinfo, modprobe, more, mpstat, mv, nbd-client, nc, netstat, nice, nmeter, nohup, od, openvt, patch, pidof, ping, pipe_progress, pmap, popmaildir, poweroff, powertop, printenv, printf, ps, pscan, pstree, pwd, pwdx, raidautorun, rdev, readlink, readprofile, realpath, reboot, reformime, renice, reset, resize, rev, rm, rmdir, rmmod, route, rpm, rpm2cpio, rtcwake, run-parts, runsv, runsvdir, rx, script, scriptreplay, sed, sendmail, seq, setconsole, setkeycodes, setlogcons, setserial, setsid, setuidgid, sha1sum, sha256sum, sha3sum, sha512sum, showkey, sleep, smemcap, softlimit, sort, split, start-stop-daemon, strings, stty, sum, sv, svlogd, switch_root, sync, sysctl, tac, tail, tar, tcpsvd, tee, telnet, telnetd, test, tftp, tftpd, time, timeout, top, touch, tr, traceroute, true, ttysize, tunctl, tune2fs, udpsvd, uname, uncompress, unexpand, uniq, unix2dos, unlzma, unlzop, unxz, unzip, uptime, usleep, uudecode, uuencode, vconfig, vi, volname, watch, wc, wget, which, whoami, whois, xargs, xz, xzcat, yes, zcat</code> <br> <br>  Using the approach described in the article, you can quickly and easily port testing from Linux to Android, create from scratch and debug for various hardware configurations and emulators with the least amount of time. </habracut></div><p>Source: <a href="https://habr.com/ru/post/204642/">https://habr.com/ru/post/204642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204628/index.html">250 lines of code recognizing the date in Russian</a></li>
<li><a href="../204630/index.html">Webinar "User Experience in an Agile Process - When the Real World Comes Knocking" from Danish interface designer Trifork A / S Janne Yul Jansen</a></li>
<li><a href="../204632/index.html">Go 1.2 release</a></li>
<li><a href="../204636/index.html">How ESET handles state-sponsored malware</a></li>
<li><a href="../204638/index.html">Work with OpenCV. Part 1. Installation and Hello World</a></li>
<li><a href="../204644/index.html">Google Compute Engine is now available for everyone.</a></li>
<li><a href="../204646/index.html">2GIS for Blackberry 10</a></li>
<li><a href="../204648/index.html">CassandraConf.ru program</a></li>
<li><a href="../204650/index.html">The creative crisis of modern television</a></li>
<li><a href="../204652/index.html">Hot Dot Parallax Engine MIT License</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>