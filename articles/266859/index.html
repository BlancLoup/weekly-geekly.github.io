<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Non-intersecting sets and mysterious function of Ackermann</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It will be a simple data structure - a system of disjoint sets . Briefly: non-intersecting sets are given (for example, connected components of a grap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Non-intersecting sets and mysterious function of Ackermann</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/35e/6ec/625/35e6ec62557d4301881d8b2aa82610b6.png" align="left">  It will be a simple data structure - a <i>system of disjoint sets</i> .  Briefly: non-intersecting sets are given (for example, connected components of a graph) and by two elements x and y you can: 1) find out whether x and y are in the same set;  2) combine the sets containing x and y.  The structure itself is very simple to implement and has been described many times in various places (for example, there is a good article on <a href="http://habrahabr.ru/post/104772/">Habr√©</a> and elsewhere).  But this is one of those amazing algorithms that doesn't cost anything to write, but it‚Äôs hard to figure out why it works effectively.  I will try to present a relatively simple proof of the exact estimate for the time of operation of this data structure, invented by Zeydel and Sharir in 2005 (it is different from the horror that many could see elsewhere).  Of course, the structure itself will also be described, and along the way we will understand, and here the inverse function of Akkerman, which many people only know about, is sooooo slowly growing. <br><a name="habracut"></a><br><h2>  The system of disjoint sets </h2><br>  Imagine that for some reason you had to maintain a set of n points with two queries: Union (x, y), which connects the points x and y with an edge, and IsConnected (x, y), which checks the points x and y is it possible to pass from x along the edges to y.  How to solve this problem? <br><br>  First, it is reasonable to think not about points, but about connected components.  <i>A connected component</i> is a set of points in which from each point one can go along the edges to each other of the same set.  Then Union (x, y) is simply a union of components containing x and y (if they are not in the same component), and IsConnected (x, y) is a test of whether x and y are in the same component. <br><br>  Secondly, it is convenient to select in each component one particular <i>selected</i> vertex taken at random.  Let Find (x) return the selected vertex from the component containing x.  Using Find (x), the IsConnected (x, y) function reduces to a simple comparison of Find (x) and Find (y): IsConnected (x, y) == (Find (x) == Find (y)).  When two components are merged into one with Union, the selected vertex of one of the merged components ceases to be selected, because the selected vertex in one component is always the same. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we abstract away from the original problem and reduce it to solving another, more general task: we have a set of non-intersecting sets that can be combined with Union and have a dedicated element obtained using Find.  Formally, the structure can be described as follows: there is an initial set of singleton sets {x <sub>1</sub> }, {x <sub>2</sub> }, ..., {x <sub>n</sub> } with such operations: <br><br><ul><li>  Union (x, y) merges sets containing the elements x and y; </li><li>  Find (x) returns the selected element from the set containing the element x, i.e.  if we take any y from the same set as x, then Find (y) = Find (x).  Find is needed so that you can find out whether two elements are in the same set. </li></ul><br>  Systems of non-intersecting sets, or rather, their implementation about which will be discussed further, were invented at the dawn of computer science.  Sometimes this structure is called Union-Find.  Systems of non-intersecting sets have many applications: they play a central role in the Kraskal algorithm for finding the minimum skeleton, are used in building the so-called dominator tree (a natural thing when analyzing a code), make it easy to monitor connectivity components in a graph, etc.  I‚Äôll say right away, even though this article contains a brief description of the implementation of the very structure of disjoint sets, for a detailed discussion of the applications of these structures and implementation details, it is better to read the already cited sources <a href="http://habrahabr.ru/post/104772/">in Habr√©</a> and <a href="http://e-maxx.ru/algo/dsu">in Maxim Ivanov</a> .  But it was always interesting to me to find out how that unusual estimate for the operating time of the systems of non-intersecting sets is obtained, which is not even easy to understand.  So, the main goal of this article is the theoretical substantiation of the effectiveness of the Union-Find structures. <br><br>  How to implement sets with Union-Find operations?  The first thing that comes to mind is to store sets in the form of directed trees (see figure).  Every tree is a multitude.  The selected element of the set (the one that the Find function returns) is the root of the tree.  To merge trees, you just need to attach the root of one tree to another. <br><br><img src="https://habrastorage.org/files/e8f/be1/c2d/e8fbe1c2dcff4eb0bb3bb51dfcc324cb.png"><br><br>  Find (x) simply goes up from x along the arrows until it reaches the root, and returns the root.  But if you leave everything as it is, you will easily get "bad" trees (such as a long "chain"), on which Find spends a lot of time.  That is, "high" trees to us to anything. <br><br>  <i>The height of the</i> vertex x is the maximum length of the path from a sheet to x.  For example, in the figure above, the height y - 2, x - 1, z - 0. After some thought, you can provide each vertex with a height.  We will call these heights <i>ranks</i> (looking ahead, I will say that these things are not called heights, as expected, because in the future the trees will be rearranged and the ranks will no longer exactly match the heights).  Now, when two trees are combined, the lower tree will be picked up to the higher one (see the figure below). <br><br><img src="https://habrastorage.org/files/9aa/7fe/3ea/9aa7fe3eaad34d8f843a0a07a989afec.png"><br><br>  We realize it!  Nodes-elements are defined as: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elem</span></span></span><span class="hljs-class"> {</span></span> elem *link; <span class="hljs-comment"><span class="hljs-comment">//    int rank; //  double value; //-    };</span></span></code> </pre> <br>  Initially, x.link = 0 and x.rank = 0 is performed for each x element.  You can already write a merge function and a preliminary version of the Find function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Union</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem *x, elem *y)</span></span></span><span class="hljs-function"> </span></span>{ x = Find(x); y = Find(y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != y) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x-&gt;rank == y-&gt;rank) y-&gt;rank++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x-&gt;rank &gt; y-&gt;rank) swap(x, y); x-&gt;link = y; } } <span class="hljs-function"><span class="hljs-function">elem *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem *x)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   Find { return x-&gt;link ? Find(x-&gt;link) : x; }</span></span></span></span></code> </pre><br>  Even this implementation is already quite effective.  To see this, we prove a couple of simple lemmas. <br><br>  <i><b>Lemma 1.</b> In the Union-Find implementation with rank optimization, each tree with the root x contains ‚â•2 <sup>x-&gt; rank</sup> vertices.</i> <br><br>  <i>Evidence.</i>  For trees consisting of one vertex x, x-&gt; rank = 0 and it is clear that the statement of the lemma is fulfilled.  Let Union join trees with roots x and y, for which the statement of the lemma holds, that is,  trees with roots x and y contain ‚â•2 <sup>x-&gt; rank</sup> and ‚â•2 <sup>y-&gt; rank</sup> vertices, respectively.  A problem may occur if x joins y and the rank of y increases.  But this happens only if x-&gt; rank == y-&gt; rank.  Let r be the rank of y before the union.  Therefore, a new tree with a root y contains ‚â•2 <sup>x-&gt; rank</sup> + 2 <sup>r</sup> = 2 2 <sup>r</sup> = 2 <sup>r + 1</sup> vertices.  And this was required to prove. <br><br>  <i><b>Lemma 2.</b> In a Union-Find with rank optimization, the rank of each vertex x is equal to the height of the tree with root x.</i> <br><br>  <i>Evidence.</i>  When the algorithm is just starting to work and all the sets are singleton, for each vertex x-&gt; rank = 0, which undoubtedly is the height.  Let Union join two trees with roots x and y and let the heights of these trees be exactly equal to the corresponding ranks x-&gt; rank and y-&gt; rank.  We show that even after the union, the ranks are equal to the heights.  If x-&gt; rank &lt;y-&gt; rank, then x will be hooked to y and, obviously, the height of the tree with the root y will not change;  Union doesn't really change y-&gt; rank.  The case x-&gt; rank&gt; y-&gt; rank is similar.  If x-&gt; rank == y-&gt; rank, then after joining x to y, the height y will increase by one;  and Union just increases y-&gt; rank by one.  What was required. <br><br>  From Lemma 1 it follows that the rank of any vertex cannot be greater than log n (all logarithms are base 2), where n denotes the number of elements.  And from Lemma 2 it follows that the height of any tree does not exceed log n.  This means that each Find operation is performed in O (log n).  Therefore, m Union-Find operations are performed in O (m log n). <br><br>  Is it even more effective?  The second optimization comes to the rescue.  When performing an ascent in the Find procedure, we simply redirect all the passed vertices to the root (see the figure).  Worse from this just will not.  But it turns out to be much better. <br><br><img src="https://habrastorage.org/files/bc8/c45/e4d/bc8c45e4dcdc4c76b3c82cf220da6fe8.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">elem * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x-&gt;link ? (x-&gt;link = Find(x-&gt;link)) : x; }</code> </pre><br>  So, we have a sequence of m operations Union and Find on n elements and we need to estimate how much time it works.  Could it be O (m log n)?  Or O (m log log n)?  Or all the same O (m)? <br><br>  Intuitively, it seems that the algorithm with the second optimization should be more efficient.  And so it is, but to prove it is not so easy.  Having a little analyzed, we can assume that the algorithm is linear, i.e.  a sequence of m operations Union and Find alternately performed for O (m).  But no matter how you try, to prove it strictly will not work, because it is not.  The first complete proof of the exact upper and lower bounds was given by Taryan in 1975 and this boundary is ‚Äúalmost‚Äù O (m), but, unfortunately, not O (m).  Then came work in which it was proved that, in principle, it is impossible to obtain O (m).  Honestly, I could not figure out all this;  even a counterexample, showing that Union-Find is slower than O (m), is rather difficult to understand.  But fortunately, in 2005, Seidel and Sharir received a new relatively ‚Äúunderstandable‚Äù proof of the upper limit.  Their article is called ‚ÄúTop-down analysis of path compression‚Äù.  It is their result in a little more simplified form that I will try to explain here.  Finding "understandable" proof of the lower bound can be considered as an unsolved problem. <br><br>  Is it so bad that we did not grow together with O (m)?  Actually, all this is only of purely theoretical interest, because the ‚Äúalmost‚Äù O (m) obtained by Tarjan is indistinguishable from O (m) in all conceivable input data (it will soon become clear why).  I‚Äôll say right away that there is <i>no</i> evidence that this is <i>not</i> O (m) (I just don‚Äôt quite understand it myself), so one may get the impression that it can be a little more and ... But it is impossible.  At least, despite some failed attempts, it was not possible to find critical errors in Taryan‚Äôs work and a series of related works.  A well-known attempt in the article ‚ÄúThe Union-Find Problem is Linear,‚Äù according to the author himself, is mistaken, quote: ‚ÄúThis paper has an error and has been retracted.  It should simply be deleted from Citeseer.  Baring that, I am submitting this "correction". ". <br><br><h2>  Stars, Stars, Stars </h2><br>  What are these functions that give ‚Äúalmost‚Äù O (m)?  Consider some function f such that f (n) &lt;n for all n&gt; 1, but f (n) tends to infinity.  The function f grows slowly: its entire graph is below the graph of the function g (n) = n.  We define the <i>iteration</i> operator <i>*</i> , which makes a slow function f <sup>*</sup> super slow function f <sup>*</sup> : <br><br>  f <sup>*</sup> (n) = min {k: f (f (... f (n))) &lt;2, where f is taken k times} <br><br>  That is, f <sup>*</sup> (n) shows how many times it is necessary to compress the number n with the operations f (n)&gt; f (f (n))&gt; f (f (f (n)))&gt; ... to get a constant of less than two. <br><br>  A couple of examples to get comfortable.  If f (n) = n-2, then f <sup>*</sup> (n) = [n / 2] (the integer part of dividing by two).  If f (n) = n / 2, then f <sup>*</sup> (n) = [log n] (the integer part of the binary logarithm).  If f (n) = log n, then what is f <sup>*</sup> (n) = log <sup>*</sup> n?  The log <sup>*</sup> n function is called <i>iterated logarithm</i> .  Having written a little bit on paper, one can prove that log <sup>*</sup> n = O (log log n), log <sup>*</sup> n = O (log log log n) and generally log <sup>*</sup> n = O (log log ... log n) for any number logs.  To imagine how slow the iterated logarithm is, just look at the value of log <sup>*</sup> 2 <sup>65536</sup> = 5. <br><br>  In the following, it will be shown that the execution time of Union-Find m operations can be estimated as O (m log <sup>*</sup> n) and, moreover, we can derive the estimates O (m log <sup>**</sup> n), O (m log <sup>***</sup> n) and so on to some limit function O (m Œ± (m, n)) defined below.  In general, I believe that for modern practical applications O (m log log n) is almost indistinguishable from O (m).  And O (m log <sup>*</sup> n) is not at all distinguishable from O (m), what to say about O (m log <sup>**</sup> n) and others.  Now you can imagine why we are talking about "almost" O (m). <br><br><h2>  O (m log <sup>*</sup> n) score </h2><br>  Obtaining an O (m log <sup>*</sup> n) estimate is the main part of the proof.  After that, an exact estimate will be obtained almost immediately.  To make it easier, we take one unimportant assumption: m ‚â• n. <br><br>  Without limiting the generality of reasoning, we will assume that the Union operation always takes as its input ‚Äúroots‚Äù of sets, i.e.  Union is called like this: Union (Find (x), Find (y)).  Then Union is executed for O (1).  This restriction is all the more natural, because Union (x, y) is the first thing that calls Find (x) and Find (y).  This means that in the analysis we will be interested only in Find operations. <br><br>  Continue to simplify.  Imagine that Find operations are not performed at all and the user somehow guesses where the roots of the sets are.  The sequence of the Union-s builds a forest F (forest - a lot of trees).  By Lemma 2 in F, the rank of each vertex x is the height of the subtree with root at x.  It follows that the rank of each vertex is less than the rank of the parent of this vertex.  For us, this observation is important. <br><br>  Now let's return the Find sequence to the system.  One can imagine that the first Find runs along a path in F and performs a <i>path compression</i> operation in F, in which each vertex of the path becomes a scion of the vertex in the ‚Äúhead‚Äù of the path (see the figure).  In this case, the head of the path is not necessarily the root of F. In other words, let's agree that in a sense, all the Union were executed in advance, and now on the forest F, the paths corresponding to Find are compressed during the normal course of the algorithm.  Then the second Find runs along some path already in the modified forest (in the source forest F, this path could not exist at all) and again compresses the path.  And so on. <br><br>  It is important to note that after compression the paths do not change.  Therefore, we call ranks, not heights, because in a modified forest, ranks may no longer correspond to heights. <br><br><img src="https://habrastorage.org/files/26c/a0b/5e5/26ca0b5e5cbe4accac48af5ced63a2cc.png"><br><br>  Now we can clearly articulate what we are proving.  There is a sequence of forests F = F <sub>1</sub> , F <sub>2</sub> , ..., F <sub>m</sub> and a sequence of contractions of the paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m</sub> in the forests F <sub>1</sub> , F <sub>2</sub> , ..., F <sub>m</sub> , respectively.  Compressing the path P <sub>1</sub> in forest F <sub>1</sub> gets forest F <sub>2</sub> , compressing path P <sub>2</sub> into F <sub>2</sub> receives F <sub>3,</sub> and so on.  (And, for example, the path P <sub>k</sub> could not yet exist in the forest F and appeared only after compressing the paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>k-1</sub> ) It is necessary to estimate the sum of the lengths of the paths P <sub>1</sub> , P <sub>2</sub> , ... , P <sub>m</sub> (path length is the number of edges in the path).  So we get an estimate for the execution time of m operations Find, because the length of the compressible path is just the number of operations ‚Äúlinking‚Äù the vertices in the corresponding Find. <br><br>  In fact, we set out to prove an even more general statement than is necessary, because not every sequence of compression paths corresponds to the sequence of operations of Union-Find.  But these nuances do not interest us. <br><br>  So, there is a forest F and a sequence of squeezing paths in it in the sense that was given to it above, i.e.  there is a sequence of forests F = F <sub>1</sub> , F <sub>2</sub> , ..., F <sub>m</sub> and a sequence of contractions of the paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m</sub> in them.  Let T (m, n) denote the sum of the lengths of compressible paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m</sub> in the worst case, when the sum of the lengths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m is</sub> maximal.  The task is to estimate T (m, n).  This is a purely combinatorial problem and all the non-trivial proofs of the effectiveness of Union-Find naturally come to one sense or another in this construction. <br><br><h4>  Evaluation of the length of the compressible path </h4><br>  The first essentially nontrivial step in the reasoning is the introduction of an additional parameter.  The forest rank F is the maximum among the ranks of the vertices F. By T (m, n, r) we denote, similarly to T (m, n), the sum of the lengths of the compressed paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m</sub> in the worst case when the sum of the lengths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m is</sub> maximal, and the initial forest has a rank not greater than r.  It is clear that T (m, n) = T (m, n, n), because the rank of any forest with n vertices is less than or equal to n.  The parameter r will be needed for recursive reduction of the evaluation problem for forest F to subtasks on subfields F. <br><br>  Let d = log r.  We divide the forest F into two non-intersecting forests F <sup>+</sup> and F <sup>-</sup> : the ‚Äúupper forest‚Äù F <sup>+</sup> consists of vertices with rank&gt; d, and the ‚Äúlower forest‚Äù F <sup>-</sup> consists of all the other vertices (see figure).  This split was noticed in the first proofs of estimates for Union-Find in connection with the following fact: it turns out that the upper forest F <sup>+</sup> contains significantly fewer vertices than F <sup>-</sup> . <br><br>  The basic idea is to estimate roughly the lengths of the contractions of the paths lying in F <sup>+</sup> (this can be done because F <sup>+ is</sup> very small), and then recursively evaluate the lengths of the contractions of the paths in F <sup>-</sup> .  That is, informally, our goal is to derive the recursion T (m, n, r) ‚â§ T (m, n, d) + (the lengths of the paths that are not included in F <sup>-</sup> ).  We begin to move towards this goal with the formalization of what F <sup>+ is</sup> ‚Äúvery small‚Äù.  Denote by | F '|  the number of vertices in an arbitrary forest F '. <br><br><img src="https://habrastorage.org/files/922/a15/e87/922a15e87f18434ab7c303e0e63e3faa.png"><br><br>  <i><b>Lemma 3.</b> Let F <sup>+</sup> be a forest consisting of vertices of F of rank&gt; d.</i>  <i>Then | F <sup>+</sup> |</i>  <i>&lt;| F |</i>  <i>/ 2 <sup>d</sup> .</i> <br><br>  <i>Evidence.</i>  Fix some t&gt; d.  Let us estimate how many in F <sup>+</sup> vertices of rank t.  In F, by Lemma 2, the rank of a vertex is equal to the height of a tree with a root at a given vertex.  Hence, a parent of a vertex with rank t necessarily has a rank&gt; t.  Thus, subtrees F with roots with rank t do not intersect (see figure below).  A tree with a root of rank t by Lemma 1 contains ‚â•2 <sup>t</sup> vertices.  Hence, there are ‚â§n / 2 <sup>t</sup> vertices with rank t.  Running t along d + 1, d + 2, ..., we find that the number of vertices in F <sup>+ is</sup> bounded above by the infinite sum n / 2 <sup>d + 1</sup> + n / 2 <sup>d + 2</sup> + n / 2 <sup>d + 3</sup> + ... By the summation formula for the geometric progression we find that this sum is equal to n / 2 <sup>d</sup> .  What was required. <br><img src="https://habrastorage.org/files/d98/bd8/615/d98bd86154084fdc81383995492f556c.png"><br><br>  From here on, for brevity, we will denote n <sup>+</sup> = | F <sup>+</sup> |  and n <sup>-</sup> = | F <sup>-</sup> |. <br><br>  The second nontrivial step in the argument.  We divide the set of paths P <sub>1</sub> , P <sub>2</sub> , ..., P <sub>m</sub> into three subsets (see figure): <br><br><ul><li>  P <sup>+</sup> - paths entirely contained in F <sup>+</sup> ; </li><li>  P <sup>-</sup> are paths entirely contained in F <sup>-</sup> ; </li><li>  P <sup>+ -</sup> - paths that have vertices from both F <sup>+</sup> and F <sup>-</sup> . </li></ul><br><img src="https://habrastorage.org/files/03c/233/c98/03c233c9885048c2ade207942adf1183.png"><br><br>  Each path from the P <sup>+ set is</sup> divided into two paths: the upper path in F <sup>+</sup> (white vertices in the figure below to the left) and the lower path in F <sup>-</sup> (green vertices in the figure below to the left).  We just shove the upper paths into the many P <sup>+</sup> paths.  Denote by m <sup>+ the</sup> number of paths in the set thus obtained, i.e.  m <sup>+</sup> = | P <sup>+</sup> |  + | P <sup>+ -</sup> |  (in contrast to the analogous designation | F '| for forests, | P | denotes the number of paths in the set P, and not the total number of vertices in them).  Denote m <sup>-</sup> = | P <sup>-</sup> |.  Then: <br><br>  T (m, n, r) ‚â§ T (m <sup>+</sup> , n <sup>+</sup> , r) + T (m <sup>-</sup> , n <sup>-</sup> , d) + (the sum of the lengths of the lower parts of the paths from P <sup>+ -</sup> ). <br><br><img src="https://habrastorage.org/files/945/345/d3f/945345d3ff064b5984b7370b64172bd6.png"><br><br>  Let us estimate the sum of the lengths of the lower parts of the paths from P <sup>+ -</sup> .  Let P be the lower part of the path from P <sup>+ -</sup> (green vertices in the figure above).  All the vertices in P, except for the head, before the linking had parents from F <sup>-</sup> (the head always has a parent from F <sup>+</sup> ), and after the linking they have a parent from F <sup>+</sup> (see the figure above).  Therefore, each vertex of F <sup>-</sup> can participate in some lower part of the path from P <sup>+ -</sup> as a non-head one only once.  It turns out that the sum of the lengths of the lower parts of the paths from the P <sup>+ - is</sup> less than or equal to | P <sup>+ -</sup> |  + n <sup>-</sup> (one unit for each head vertex plus one unit for each vertex from F <sup>-</sup> ).  Note that | P <sup>+ -</sup> |  ‚â§ m <sup>+</sup> .  Therefore, the sum of the lengths of the lower parts of the paths from P <sup>+ -</sup> does not exceed m <sup>+</sup> + n <sup>-</sup> . <br><br>  Important note: in the reasoning done, it was unimportant that the rank F <sup>is</sup> less than or equal to d = log r;  instead of log r could be any other value.  If you get to this place, congratulations, we have just proved the central lemma. <br><br>  <i><b>The central lemma.</b></i>  <i>Let F <sup>+</sup> be a forest of vertices from F with ranks&gt; d, and F <sup>-</sup> be the forest of the remaining vertices from F. The notation m <sup>+</sup> , m <sup>-</sup> , n <sup>+</sup> , n <sup>- is</sup> defined by analogy.</i>  <i>Then the recursion is valid: T (m, n, r) ‚â§ T (m <sup>+</sup> , n <sup>+</sup> , r) + T (m <sup>-</sup> , n <sup>-</sup> , d) + m <sup>+</sup> + n <sup>-</sup> .</i> <i><br></i> <br><br>  As already mentioned, since the F <sup>+</sup> forest is very small, the length of the paths in it can be estimated by rough methods.  Do this.  Obviously, the compression of a path of length k in F <sup>+</sup> performs a k-1 vertex linking;  that is, the k-1 vertex "rises" up the tree.  The height F <sup>+</sup> does not exceed r and therefore each vertex can rise no more than r times.  This means that m <sup>+</sup> path compression performs at most rn <sup>+</sup> linking (i.e., ‚Äúlifting‚Äù of vertices).  Hence we conclude that the sum of the lengths m <sup>+ of the</sup> contractions of the paths in F <sup>+ is</sup> bounded above by the number rn <sup>+</sup> + m <sup>+</sup> (one for each lift of the vertex and one for the head of each path).  By Lemma 3, we obtain rn <sup>+</sup> ‚â§ rn / 2 <sup>d</sup> = rn / 2 <sup>log r</sup> = n.  As a result, we obtain T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ n + m <sup>+</sup> .  Using the central lemma, we derive the recursion: <br><br>  T (m, n, r) ‚â§ T (m <sup>+</sup> , n <sup>+</sup> , r) + T (m <sup>-</sup> , n <sup>-</sup> , log r) + m <sup>+</sup> + n <sup>-</sup> ‚â§ <br>  ‚â§ n + m <sup>+</sup> + T (m <sup>-</sup> , n, log r) + m <sup>+</sup> + n = <br>  = 2n + 2m <sup>+</sup> + T (m <sup>-</sup> , n, log r). <br><br>  Now, recursively, we will continue to act in the same spirit on forest F <sup>‚Äî</sup> just as we acted on forest F, that is,  just open the recursion: <br>  T (m, n, r) ‚â§ (2n + 2m <sup>+</sup> ) + T (m <sup>-</sup> , n, log r) ‚â§ <br>  ‚â§ (2n + 2m <sup>+</sup> ) + (2n + 2m <sub>0</sub> <sup>+</sup> ) + T (m <sub>0</sub> <sup>-</sup> , n, log log r) ‚â§ <br>  ‚â§ (2n + 2m <sup>+</sup> ) + (2n + 2m <sub>0</sub> <sup>+</sup> ) + (2n + 2m <sub>1</sub> <sup>+</sup> ) + T (m <sub>1</sub> <sup>-</sup> , n, log log r) ‚â§ <br>  ‚â§ ... <br>  Here m <sub>0</sub> <sup>+</sup> , m <sub>1</sub> <sup>+</sup> , ... are the values ‚Äã‚Äãcorresponding to m <sup>+</sup> at various levels of recursion.  It is clear that m <sup>+</sup> + m <sub>0</sub> <sup>+</sup> + m <sub>1</sub> <sup>+</sup> + ... ‚â§ m (see the figure below).  The recursion depth is the number of times you need to prologize r to get a constant.  But this is log <sup>*</sup> r!  As a result, we derive T (m, n, r) ‚â§ 2m + 2n log <sup>*</sup> r. <br><br><img src="https://habrastorage.org/files/0ff/e35/8e7/0ffe358e71cb4dd08b2dc41bc190902c.png"><br><br><h2>  The final solution with Ackermann inverse function </h2><br>  If we analyze the findings more closely, we can see that, in general, the value of log r played a role only in the disclosure of the expression T (m <sup>+</sup> , n <sup>+</sup> , r) to get T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ n + m <sup>+</sup> .  This was achieved using Lemma 3 and naive reasoning, proving that T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ rn <sup>+</sup> + m <sup>+</sup> .  But in the previous section, we got a better estimate: T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 2m <sup>+</sup> + 2n <sup>+</sup> log <sup>*</sup> r.  Let's redefine our main characters, ‚Äúlowering‚Äù the forest F <sup>-</sup> : F <sup>+</sup> is a forest of vertices F with rank&gt; log <sup>*</sup> r, and F <sup>-</sup> is a forest of remaining vertices with rank ‚â§ log <sup>*</sup> r.  By analogy, we define the parameters m <sup>+</sup> , m <sup>-</sup> , n <sup>+</sup> , n <sup>-</sup> . <br><br>  By Lemma 3, we obtain n <sup>+</sup> &lt;n / 2 <sup>log * r</sup> , i.e.  the F <sup>+</sup> forest is still ‚Äúsmall‚Äù compared to F <sup>-</sup> (at first it seemed to me even counterintuitive).  In the previous section, we established that T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 2m <sup>+</sup> + 2n <sup>+</sup> log <sup>*</sup> r.  Hence, taking into account that 2 (n / 2 <sup>x</sup> ) x ‚â§ n for any integer x ‚â• 1, we derive T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 2m <sup>+</sup> + 2 (n / 2 <sup>log * r</sup> ) log <sup>*</sup> r ‚â§ 2m <sup>+</sup> + n.  This is almost like the estimate T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ n + m <sup>+</sup> obtained earlier!  Applying the central lemma, we obtain a recursion: <br><br>  T (m, n, r) ‚â§ T (m <sup>+</sup> , n <sup>+</sup> , r) + T (m <sup>-</sup> , n <sup>-</sup> , log <sup>*</sup> r) + m <sup>+</sup> + n <sup>-</sup> . <br><br>  Opening T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 2m <sup>+</sup> + n, we transform recursion: <br><br>  T (m, n, r) ‚â§ T (m <sup>+</sup> , n <sup>+</sup> , r) + T (m <sup>-</sup> , n <sup>-</sup> , log <sup>*</sup> r) + m <sup>+</sup> + n <sup>-</sup> ‚â§ <br>  ‚â§ 2m <sup>+</sup> + n + T (m <sup>-</sup> , n <sup>-</sup> , log <sup>*</sup> r) + m <sup>+</sup> + n <sup>-</sup> ‚â§ <br>  ‚â§ 3m <sup>+</sup> + 2n + T (m <sup>-</sup> , n, log <sup>*</sup> r). <br><br>  Now open a couple of levels of recursion: <br><br>  T (m, n, r) ‚â§ (3m <sup>+</sup> + 2n) + T (m <sup>-</sup> , n, log <sup>*</sup> r) ‚â§ <br>  ‚â§ (3m <sup>+</sup> + 2n) + (3m <sub>0</sub> <sup>+</sup> + 2n) + T (m <sub>0</sub> <sup>-</sup> , n, log <sup>*</sup> log <sup>*</sup> r) ‚â§ <br>  ‚â§ (3m <sup>+</sup> + 2n) + (3m <sub>0</sub> <sup>+</sup> + 2n) + (2m <sub>1</sub> <sup>+</sup> + 2n) + T (m <sub>1</sub> <sup>-</sup> , n, log <sup>*</sup> log <sup>*</sup> log <sup>*</sup> r) ‚â§ <br>  ‚â§ ... <br><br>  Here, as in the last section, m <sub>0</sub> <sup>+</sup> , m <sub>1</sub> <sup>+</sup> , ... are the values ‚Äã‚Äãcorresponding to m <sup>+</sup> at various recursion levels.  It is clear that m <sup>+</sup> + m <sub>0</sub> <sup>+</sup> + m <sub>1</sub> <sup>+</sup> + ... ‚â§ m.  The recursion depth is log <sup>**</sup> r.  As a result, T (m, n, r) ‚â§ 3m + 2n log <sup>**</sup> r.  Very good estimate.  But is it possible to do this trick once more, using the estimate just obtained T (m, n, r) ‚â§ 3m + 2n log <sup>**</sup> r?  Yes! <br><br>  I will omit the details this time.  By ‚Äúlowering‚Äù the forest F <sup>-</sup> to the rank of log <sup>**</sup> r, one can again, using Lemma 3, obtain T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 3m <sup>+</sup> + n.  This is almost like the estimated estimate T (m <sup>+</sup> , n <sup>+</sup> , r) ‚â§ 2m <sup>+</sup> + n.  Then, using this estimate and the central lemma, we derive T (m, n, r) ‚â§ 4m + 2n log <sup>***</sup> r. <br><br>  You can continue further by ‚Äúlowering‚Äù F to the rank of log <sup>***</sup> r.  In general, having done this procedure k times for any natural k, one can obtain the following estimate: <br><table><tbody><tr><td>  T (m, n, r) ‚â§ km + 2n log <sup>** ... *</sup> r, where the number of stars is k-1. <br></td></tr></tbody></table><br>  It remains to optimize this recurrence relation.  The more stars, the smaller the 2n log <sup>** ... *</sup> r term, but the greater the km.  Equilibrium is reached at some k.  But we will act more rudely: we will turn the term n log <sup>** ... *</sup> r into 2m.  Before this final step, instead of r everywhere, we substitute n - the upper bound for the rank of the source forest F (although by Lemma 1, we could set r = log n, but not the essence).  We introduce the following function: <br><table><tbody><tr><td>  Œ± (m, n) = min {k: n log <sup>** ... *</sup> n &lt;2m, where the number of stars is k}. <br></td></tr></tbody></table><br>  The function Œ± (m, n) is called the <i>inverse function of Ackermann</i> .  Recall that we are only interested in the case of m ‚â• n.  By definition, Œ± (m, n), the expression n log <sup>** ... *</sup> n, in which Œ± (m, n) stars, is less than 2m.  Actually, we introduced the function Œ± (m, n) to get such an effect with a minimum of stars.  Maybe it was not immediately noticeable, but we just proved that m Union-Find operations are performed in O (m Œ± (m, n)). <h3>  Tadam! </h3><br><br><h2>  A little about the reverse function of Ackermann </h2><br>  If you have seen Ackermann‚Äôs inverse function before, then most likely the definition was different (more obscure), but giving asymptotically the same function as a result.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The original definition of Ackermann, which Tarjan uses, personally does not tell me anything about this function (in this case, for the area for which Ackermann himself introduced his function, the definition was natural). The definition proposed by Zaydel and Sharir (and just given) reveals the ‚Äúsecret meaning‚Äù of Akkerman‚Äôs inverse. I also add that, strictly speaking, ‚Äúthe function inverse to the Ackermann function‚Äù is an incorrect name, because Œ± (m, n) is a function of two variables and it cannot be ‚Äúinverse‚Äù to any function. Therefore, it is sometimes said that Œ± (m, n) is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akkerman's pseudoinverse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I will not give the function of Ackermann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now a little bit of analysis. The maximum Œ± (m, n) is reached at m = n. Even very small deviations (for example, m ‚â• n log </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*****</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n) make Œ± (m, n) constant. </font><font style="vertical-align: inherit;">The function Œ± (n, n) grows slower than log </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">** ... *</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n for any number of stars. </font><font style="vertical-align: inherit;">By the way, the definition of Œ± (n, n) looks like the definition of iteration: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Œ± (n, n) = min {k: log </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">** ... *</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n &lt;2, where the number of stars is k}. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this is not the limit and there are functions that grow even slower, for example, log Œ± (n, n). </font><font style="vertical-align: inherit;">Another thing is surprising: Œ± (m, n) arises when analyzing such a natural algorithm. </font><font style="vertical-align: inherit;">Even more surprisingly, there is evidence that it is impossible to improve the resulting O (m Œ± (m, n)) estimate.</font></font></div><p>Source: <a href="https://habr.com/ru/post/266859/">https://habr.com/ru/post/266859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266847/index.html">Mikrotik: small utility. Part 1</a></li>
<li><a href="../266849/index.html">Book about viruses</a></li>
<li><a href="../266851/index.html">Start loving go</a></li>
<li><a href="../266853/index.html">Return fix and other improvements in Vivaldi 1.0.275.3 fix</a></li>
<li><a href="../266857/index.html">FAS has recognized Google as violator of antitrust laws</a></li>
<li><a href="../266861/index.html">Hash array mapped trie</a></li>
<li><a href="../266863/index.html">Jet9 test results and service commissioning</a></li>
<li><a href="../266865/index.html">QuadBraces - based on the MODx parser</a></li>
<li><a href="../266869/index.html">New ‚Äúservice‚Äù from Ubiquiti - replenishment in the model range UniFi AC</a></li>
<li><a href="../266871/index.html">Deploy JetBrains Hub + Youtrack + Upsource + Nginx on your Debian 8 server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>