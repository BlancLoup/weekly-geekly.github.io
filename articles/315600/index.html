<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Virtual events in C #: something went wrong</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I was working on a new C # -diagnostics of V3119 for the PVS-Studio static analyzer. The purpose of diagnostics is to identify potentially u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Virtual events in C #: something went wrong</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/6c7/ea3/42c/6c7ea342c1f14774b73f299b16cdd4af.png" align="left">  Recently, I was working on a new C # -diagnostics of V3119 for the PVS-Studio static analyzer.  The purpose of diagnostics is to identify potentially unsafe constructions in C # source code associated with the use of virtual and redefined events.  Let's try to figure out what is wrong with virtual events in C #, how exactly diagnostics work, and why Microsoft does not recommend using virtual and redefined events? <br><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  I think the reader is familiar with the virtuality mechanisms in C #.  The easiest to understand is the example of how virtual methods work.  In this case, virtuality allows you to perform one of the overrides of the virtual method in accordance with the <b>type of</b> object <b>execution time</b> .  I will illustrate this mechanism with a simple example: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"AF"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"AG"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"BF"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"BG"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); A a = b; aF(); bF(); aG(); bG(); }</code> </pre> <br>  As a result of execution, the console will display: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs">BF BF AG BG</code> </pre> <br>  All right  Since both objects <i>a</i> and <i>b</i> have the <b>runtime type</b> <i>B</i> , calling the virtual method <i>F ()</i> for both of these objects will result in calling the redefined method <i>F () of</i> class <i>B.</i> On the other hand, by the <b>type of compile time,</b> objects <i>a</i> and <i>b</i> are different, respectively, having types <i>A</i> and <i>B.</i>  Therefore, calling the <i>G ()</i> method for each of these objects results in calling the appropriate method for class <i>A</i> or <i>B.</i>  More details about the use of the <i>virtual</i> and <i>override</i> keywords can be found, for example, <a href="https://msdn.microsoft.com/en-us/library/9fkccyh4.aspx">here</a> . <br><br>  Similarly to methods, properties and indexers, <a href="https://msdn.microsoft.com/en-US/library/awbftdfh.aspx">events</a> can also be declared virtual: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> ....</code> </pre> <br>  This can be done both for "simple" and for explicitly implementing accessors <i>add</i> and <i>remove</i> events.  At the same time, working with virtual events and redefined in derived classes, it would be logical to expect from them behavior similar to, for example, virtual methods.  However, it is not.  Moreover, <a href="https://msdn.microsoft.com/en-us/library/hy3sefw3.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">MSDN in</a> plain text <b>does not recommend the</b> use of virtual and redefined events: ‚ÄúDo not declare events.  It is unpredictable whether it‚Äôs going to be a subscribing to the base class event. <br><br>  But we will not immediately give up and try to still implement the "... declare virtual classes". <br><br><h2>  Experiments </h2><br>  As a first experiment, we will create a console application containing the declaration and use of two virtual events in the base class (with implicit and explicit implementations of the <i>add</i> and <i>remove</i> accessors), and also containing a derived class that overrides these events: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { _myCustomEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { _myCustomEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Action _myCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooBase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MyEvent?.Invoke(); _myCustomEvent?.Invoke(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Child</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { _myCustomEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { _myCustomEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action _myCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooChild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MyEvent?.Invoke(); _myCustomEvent?.Invoke(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Child child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Child(); child.MyEvent += () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"child.MyEvent handler"</span></span>); child.MyCustomEvent += () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"child.MyCustomEvent handler"</span></span>); child.FooChild(); child.FooBase(); }</code> </pre> <br>  The output of the program will be the output to the console of two lines: <br><br><pre> <code class="cs hljs">child.MyEvent handler child.MyCustomEvent handler</code> </pre> <br>  Using a debugger or test output, it is easy to make sure that when <i>child.FooBase () is</i> called, the value of both <i>MyEvent</i> and <i>_myCustomEvent variables</i> is <i>null,</i> and the program does not "fall" only by using the conditional access operator when trying to trigger <i>MyEvent? .Invoke events ( )</i> and <i>_myCustomEvent? .Invoke ()</i> . <br><br>  So the MSDN warning was not in vain.  It really does not work!  Subscribing to virtual events of an object that has the runtime type of the derived class <i>Child</i> does not lead to a simultaneous subscription to the events of the base class <i>Base</i> . <br><br>  In the case of an implicit event implementation, the compiler automatically creates accessor methods for it <i>add</i> and <i>remove</i> , as well as a delegate field that is used for subscription or unsubscribe.  The problem, apparently, is that in case of using a virtual event, the base and child classes will have individual (non-virtual) delegate fields associated with this event. <br><br>  In the case of an explicit implementation, this is done by the developer, who can take into account this feature of the behavior of virtual events in C #.  In the above example, I did not take into account this feature by declaring the <i>_myCustomEvent</i> delegate <i>property</i> as <i>protected</i> in the base and derived classes.  Thus, I actually repeated the implementation provided by the compiler automatically for virtual events. <br><br>  Let us try to achieve the expected behavior of the virtual event with the help of the second experiment.  To do this, we use a virtual and redefined event with an explicit implementation of the accessors <i>add</i> and <i>remove</i> , as well as the associated <b>virtual</b> property delegate.  Let's slightly change the program text from the first experiment: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { _myCustomEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { _myCustomEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Action _myCustomEvent { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//&lt;= virtual public void FooBase() { MyEvent?.Invoke(); _myCustomEvent?.Invoke(); } } class Child : Base { public override event Action MyEvent; public override event Action MyCustomEvent { add { _myCustomEvent += value; } remove { _myCustomEvent -= value; } } public override Action _myCustomEvent { get; set; } //&lt;= override public void FooChild() { MyEvent?.Invoke(); _myCustomEvent?.Invoke(); } } static void Main(...) { Child child = new Child(); child.MyEvent += () =&gt; Console.WriteLine("child.MyEvent handler"); child.MyCustomEvent += () =&gt; Console.WriteLine("child.MyCustomEvent handler"); child.FooChild(); child.FooBase(); }</span></span></code> </pre> <br>  The result of the program: <br><br><pre> <code class="cs hljs">child.MyEvent handler child.MyCustomEvent handler child.MyCustomEvent handler</code> </pre> <br>  Pay attention to the fact that two handlers occurred for the <i>child.MyCustomEvent</i> event.  In debug mode, it is easy to determine that now when calling <i>_myCustomEvent? .Invoke ()</i> in the <i>FooBase ()</i> method, the delegate <i>_myCustomEvent value is</i> not <i>null</i> .  Thus, we only managed to achieve the expected behavior for virtual events by using events with explicitly implemented accessors <i>add</i> and <i>remove</i> . <br><br>  You will say that all this, of course, is good, but we are talking about some synthetic examples from the theoretical field, and let these virtual and redefined events remain there.  I will give the following comments: <br><br><ul><li>  You may be in a situation where you will be forced to use virtual events.  For example, inheriting from an abstract class in which an abstract event with an implicit implementation is declared.  As a result, you will receive in your class a redefined event that you may be using.  There is nothing dangerous in this until the moment you decide to inherit from your class and redefine this event again. <br><br></li><li>  Such designs are rare, but still occur in real projects.  I made sure of this after I implemented the C # -diagnosis of <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> for the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer.  The diagnostic rule searches for declarations of virtual or redefined events with implicit implementation that are used in the current class.  It is considered unsafe that such constructions are found and the class may have heirs, and the event can be redefined (not <i>sealed</i> ).  That is, when a situation is hypothetically possible with the redefinition of a virtual or already redefined event in a derived class.  The warnings found in this way are listed in the next section. </li></ul><br><h2>  Examples from real projects </h2><br>  To test the performance of the PVS-Studio analyzer, we use a pool of test projects.  After adding a new rule V3119, dedicated to virtual and redefined events, to the analyzer, the entire project pool was checked.  Let us analyze the warnings received. <br><br><h3>  Roslyn </h3><br>  Previously, <a href="http://www.viva64.com/ru/b/0363/">an article</a> was devoted to checking this project with PVS-Studio.  Now I‚Äôll just give you a list of analyzer warnings related to virtual and redefined events. <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'Started' may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  GlobalOperationNotificationServiceFactory.cs 33 <br><br>  <b>PVS-Studio analyzer warning</b> : <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'Stopped' may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  GlobalOperationNotificationServiceFactory.cs 34 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NoOpService</span></span> : <span class="hljs-title"><span class="hljs-title">AbstractGlobalOperationNotificationService</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Started; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;GlobalOperationEventArgs&gt; Stopped; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NoOpService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> started = Started; <span class="hljs-comment"><span class="hljs-comment">//&lt;= var stopped = Stopped; //&lt;= } .... }</span></span></code> </pre> <br>  In this case, we most likely deal with the situation of the forced redefinition of virtual events.  The base class <i>AbstractGlobalOperationNotificationService is</i> abstract and contains the definition of the <i>Started</i> and <i>Stopped</i> abstract events: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AbstractGlobalOperationNotificationService</span></span> : <span class="hljs-title"><span class="hljs-title">IGlobalOperationNotificationService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Started; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;GlobalOperationEventArgs&gt; Stopped; .... }</code> </pre> <br>  Further use of the overridden <i>Started</i> and <i>Stopped</i> events is not entirely clear, since the delegates are simply assigned to the local variables <i>started</i> and <i>stopped</i> in the <i>NoOpService</i> method and are not used at all.  Nevertheless, this situation is potentially unsafe, which the analyzer warns about. <br><br><h3>  SharpDevelop </h3><br>  The verification of this project was also previously described in the <a href="http://www.viva64.com/ru/b/0359/">article</a> .  I will give a list of received alerts V3119 analyzer. <br><br>  <b>PVS-Studio analyzer warning</b> : <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'ParseInformationUpdated' may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  CompilableProject.cs 397 <br><br><pre> <code class="cs hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;ParseInformationEventArgs&gt; ParseInformationUpdated = <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> {}; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnParseInformationUpdated</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... SD.MainThread.InvokeAsyncAndForget (<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { ParseInformationUpdated(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); }); <span class="hljs-comment"><span class="hljs-comment">//&lt;= } ....</span></span></code> </pre> <br>  Detected using overridden virtual event.  The danger will trap us in the case of inheritance from the current class and override the <i>ParseInformationUpdated</i> event in a derived class. <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'ShouldApplyExtensionsInvalidated' event may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  DefaultExtension.cs 127 <br><br><pre> <code class="cs hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;DesignItemCollectionEventArgs&gt; ShouldApplyExtensionsInvalidated; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReapplyExtensions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICollection&lt;DesignItem&gt; items</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldApplyExtensionsInvalidated != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ShouldApplyExtensionsInvalidated(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-comment"><span class="hljs-comment">//&lt;= new DesignItemCollectionEventArgs(items)); } } ....</span></span></code> </pre> <br>  Re-detected use of overridden virtual event. <br><br><h3>  Space engineers </h3><br>  And this project was previously tested with PVS-Studio.  The result of the check is given in the <a href="http://www.viva64.com/ru/b/0376/">article</a> .  New diagnostics V3119 issued 2 warnings. <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling virtual event 'OnAfterComponentAdd' may lead to unpredictable behavior.  Consider Implementing event accessors explicitly.  MyInventoryAggregate.cs 209 <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling virtual event OnBeforeComponentRemove 'may lead to unpredictable behavior.  Consider Implementing event accessors explicitly.  MyInventoryAggregate.cs 218 <br><br><pre> <code class="cs hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;MyInventoryAggregate, MyInventoryBase&gt; OnAfterComponentAdd; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;MyInventoryAggregate, MyInventoryBase&gt; OnBeforeComponentRemove; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AfterComponentAdd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnAfterComponentAdd != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { OnAfterComponentAdd(....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } .... public void BeforeComponentRemove(....) { .... if (OnBeforeComponentRemove != null) { OnBeforeComponentRemove(....); } } ....</span></span></code> </pre> <br>  Here we are dealing with declaring and using not redefined, but virtual events.  In general, the situation is no different from those previously discussed. <br><br><h3>  RavenDB </h3><br>  The RavenDB project is a so-called ‚ÄúNoSQL‚Äù (or document-oriented) database.  Its detailed description is available on the <a href="http://ravendb.net/">official website</a> .  The project is developed using .NET and its source codes are available on <a href="https://github.com/ravendb/ravendb">GitHub</a> .  Checking RavenDB with the PVS-Studio analyzer revealed three warnings V3119. <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'AfterDispose' may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  DocumentStore.cs 273 <br><br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/w/v3119/">V3119</a> Calling overridden event 'AfterDispose' may lead to unpredictable behavior.  Consider implementing event accessors explicitly or use the 'sealed' keyword.  ShardedDocumentStore.cs 104 <br><br>  Both of these warnings are issued for similar code fragments.  Consider one of these fragments: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DocumentStore</span></span> : <span class="hljs-title"><span class="hljs-title">DocumentStoreBase</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler AfterDispose; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> afterDispose = AfterDispose; <span class="hljs-comment"><span class="hljs-comment">//&lt;= if (afterDispose != null) afterDispose(this, EventArgs.Empty); } .... }</span></span></code> </pre> <br>  The <i>AfterDispose</i> event <i>overridden</i> in the <i>DocumentStore</i> class is declared as abstract in the <i>DocumentStoreBase</i> base abstract class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DocumentStoreBase</span></span> : <span class="hljs-title"><span class="hljs-title">IDocumentStore</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler AfterDispose; .... }</code> </pre> <br>  As in the previous examples, the analyzer warns us of potential danger if the <i>AfterDispose</i> virtual event is redefined and used in the <i>DocumentStore-</i> derived classes. <br><br>  <b>PVS-Studio analyzer warning:</b> Calling virtual event 'Error' may lead to unpredictable behavior.  Consider Implementing event accessors explicitly.  JsonSerializer.cs 1007 <br><pre> <code class="cs hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;ErrorEventArgs&gt; Error; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { EventHandler&lt;ErrorEventArgs&gt; error = Error; <span class="hljs-comment"><span class="hljs-comment">//&lt;= if (error != null) error(....); } ....</span></span></code> </pre> <br>  Here is the announcement and use of a virtual event.  Again, there is a risk of undefined behavior. <br><br><h2>  Conclusion </h2><br>  I think this is the end of our research and the conclusion that you really should not use implicitly implemented virtual events.  Due to the nature of their implementation in C #, the use of such events can lead to undefined behavior.  In case you still have to use redefined virtual events (for example, when inheriting from an abstract class), this should be done with caution using explicitly given <i>add</i> and <i>remove</i> accessors.  You can also use the <i>sealed keyword</i> when declaring a class or event.  And, of course, you should use static code analysis tools, for example, <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> . <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0453/"><img src="https://habrastorage.org/files/a93/b92/8e5/a93b928e5b2e4ad6b0b247a63f47be92.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Khrenov.  <a href="http://www.viva64.com/en/b/0453/">Virtual events in C #: something went wrong</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/315600/">https://habr.com/ru/post/315600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315590/index.html">I invite you to a virtual reality party ‚ÄúNew Year's VR-Today‚Äù, December 10</a></li>
<li><a href="../315592/index.html">5 tips to improve game animations</a></li>
<li><a href="../315594/index.html">Linux subsystem files cannot be created, modified, or deleted using Windows tools.</a></li>
<li><a href="../315596/index.html">Webinar: Asterisk and Databases</a></li>
<li><a href="../315598/index.html">Deep Learning Program</a></li>
<li><a href="../315602/index.html">Founder's advice. As an online service of Egor Egereva transforms the event-market of Russia</a></li>
<li><a href="../315604/index.html">How we did the interactive quest for RailsClub</a></li>
<li><a href="../315606/index.html">C ++ 17 and C ++ 2a: news from the ISO meeting in Issaqua</a></li>
<li><a href="../315608/index.html">CSP bypass using Google Chrome extensions</a></li>
<li><a href="../315610/index.html">Security Week 46: OAuth 2.0 bypass, low-voltage ICMP DDoS, iOS privacy and loxcreen bypass</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>