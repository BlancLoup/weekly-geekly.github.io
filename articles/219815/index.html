<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Digital Image Stabilization from Stationary Cameras - Correlation Approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I decided to write this article after reading the article ‚Äú Massively parallel image stabilization ‚Äù, which describes an algorithm for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Digital Image Stabilization from Stationary Cameras - Correlation Approach</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  I decided to write this article after reading the article ‚Äú <a href="http://habrahabr.ru/post/214027/">Massively parallel image stabilization</a> ‚Äù, which describes an algorithm for image stabilization from PTZ cameras.  The fact is that at one time I had implemented an algorithm for image stabilization from stationary cameras, which is used in the <a href="http://synesis.ru/other-products/ip-videoserver-mb2">MagicBox IP video server</a> and some other products of <a href="http://synesis.ru/">Synesis</a> , in which I currently work.  The algorithm turned out quite successful in its speed characteristics.  In particular, it is very effectively implemented algorithm for finding the offset of the current image relative to the background.  This efficiency made it possible to use its main elements (of course, with some modifications) to accompany objects, as well as to check them for immobility. <br><br>  The stabilization algorithm includes the following main elements: the detection of an offset for the current frame, the compensation of a given offset, and the periodic updating of the background against which stabilization occurs.  Below I will paint in detail each of them. <br><img src="https://habrastorage.org/getpro/habr/post_images/e40/3b0/e91/e403b0e9170b9fef2134127bb6334aa4.jpg"><br>  Fig.  1 Image stabilization is sometimes very useful. <br><br><a name="habracut"></a><br><h4>  Offset detection of the current frame </h4><br>  The basic approach on which the correlation approach is based on the definition of bias can be briefly described as follows: <br>  1) Take the central part of the background image.  The amount of indentation is determined by the maximum possible offset that we want to determine.  The central part should not be too small, otherwise the correlation function (see below) will not have enough data for stable operation. <br>  2) In the current frame, a part of the same size is selected, but offset from the center of the picture. <br>  3) For each offset, a certain metric is calculated that describes the correlation of the central part of the background and the current image.  For this, for example, the sum of squared differences for each point of these two images or, for example, the sum of absolute differences for each point can be used. <br>  4) The offset, for which the correlation is maximal (less than the sum of quadratic differences or the sum of absolute differences), will be the desired offset. <br><img src="https://habrastorage.org/getpro/habr/post_images/08b/1ea/2be/08b1ea2befd563dbc5070b4a740d68e7.png"><br>  Fig.  2 Offset of the current frame relative to the background. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Naturally, if such an approach is applied in the forehead, then the speed of the algorithm will be catastrophically low, even though the speed of the correlation functions may be very high.  This is not surprising, since we will need to go through all the options for a possible displacement of images relative to each other (the complexity of the algorithm can be estimated as O (n ^ 2), where n is the number of image points). <br><br>  The first optimization is the use of not exhaustive search of all possible options, but using the gradient descent method: at the beginning, the correlation is calculated in the 3x3 region for zero offset, then the offset with the maximum correlation is selected and the process is repeated until a local maximum is detected.  This method is much faster, but in the worst case of large displacements, it will have O (n ^ 1.5) complexity, which is also not acceptable. <br><img src="https://habrastorage.org/getpro/habr/post_images/2d5/bd4/264/2d5bd42642c0052ced19c5012ccddda2.png"><br>  Fig.3 Search for the maximum of the correlation function.  Gradient descent. <br><br>  The way out of this situation is the use of multiscale images (each zoom level reduces the image twice).  Now we will look for the local maximum of the correlation for the maximum scale, and then on a smaller scale, we will consistently refine it.  Thus, the complexity of the algorithm is reduced to O (n), which is already quite acceptable. <br><img src="https://habrastorage.org/getpro/habr/post_images/b23/b25/cf9/b23b25cf990cc2ba4230a97161b7ad8f.png"><br>  Fig.4 Multiscale image. <br><br><h4>  Subpixel accuracy </h4><br>  If you compensate for the camera shake with pixel accuracy, then the stabilized image will still twitch quite noticeably.  Fortunately, this can be fixed.  If you carefully analyze the vicinity of the correlation function near the maximum (see Fig. 3), you can see that the values ‚Äã‚Äãof the function are not symmetric about the maximum, which means that the maximum is not located at point (3, 2), somewhere between it, and point (1, 4).  If we approximate the behavior of the correlation function near the maximum by the paraboloid <b>A * x ^ 2 + B * x * y + C * y ^ 2 + D * x + E * y + F = 0</b> , then the task of refining the coordinates of the maximum will be reduced to selecting such parameters of the paraboloid, at which its deviation from the actual values ‚Äã‚Äãat known points is minimal.  Experience suggests that the accuracy of the refinement thus obtained will be of the order of 0.1‚Äì0.2.  When compensating for jitter with such accuracy, the stabilized image is almost no twitching. <br><br><h4>  Offset compensation </h4><br>  The offset compensation for the whole shift is performed as follows: shift the current image to the found shift with the opposite sign.  Empty areas near the edge fill background.  For subpixel shift, we perform compensation by bilinear interpolation.  In this case, however, a slight blur of the stabilized image is possible.  If this is critical, then bicubic interpolation can be applied. <br><br><h4>  Background update </h4><br>  As a background, you can use just any previous frame.  However, the quality of stabilization is noticeably improved if an image averaged over many frames is used as a background.  It is advisable to update the background periodically to compensate for possible changes in illumination on the scene.  When updating the background, you need to make sure that the background value is quite contrasting and non-uniform.  Otherwise, the correlation function will not have a clear maximum, which greatly reduces the accuracy of the stabilizer.  It is also highly undesirable to have moving objects in the background. <br><br><h4>  Work in tandem with motion detector </h4><br>  If the stabilizer is paired with a motion detector, then the background update process for it is greatly simplified.  Usually the motion detector already has in its composition a background averaged over many frames, relative to which it determines the presence of motion.  The same background can be used for stabilizer operation.  The stabilized image from the stabilizer in turn reduces the number of false alarms of the motion detector.  You can also use the fact that the movement detector in its work process receives a mask of areas with the presence of movement.  This mask obtained by the motion detector in the past frame can be used when calculating the correlation function to exclude areas with motion.  Which also has a positive effect on the image stabilizer. <br><br><h4>  Pros of the proposed approach: </h4><br>  1) High speed algorithm.  In particular, for image stabilization with a resolution of 1280x720 in BGRA32 format on a Core i7-4470 processor (1 core is involved), the algorithm requires 1.5 milliseconds. <br>  2) Camera jitter compensation with sub-pixel accuracy. <br><br><h4>  Disadvantages of the proposed approach </h4><br>  1) Image stabilization in the current implementation is possible only for stationary cameras. <br>  2) Only the spatial shift of the camera is detected and compensated; the camera rotations are not compensated. <br>  3) The background must be sufficiently clear and non-uniform, otherwise the correlation function will have nothing to catch on.  Therefore, stabilization will work poorly in the dark or in fog. <br>  4) The background must be fixed.  The work of the stabilizer against the background of traveling waves is also impossible. <br><br><h4>  Notes on practical implementation </h4><br>  To begin with, we note that to determine the shift, it is quite enough to use only a gray image, the color characteristics have almost no effect on accuracy, but naturally slow down the calculations. <br><br>  When implementing a stabilizer, it is desirable to use optimized functions for working with images.  I used the <a href="http://sourceforge.net/projects/simd/">Simd</a> library for this purpose.  In particular, you can find: <br>  1) SimdAbsDifferenceSum and SimdAbsDifferenceSumMasked - for calculating the correlation function. <br>  2) SimdReduceGray2x2, SimdReduceGray3x3, SimdReduceGray4x4 and SimdReduceGray5x5 - for building multi-scale images. <br>  3) SimdBgrToGray - for gray image. <br>  4) SimdShiftBilinear - to compensate for the shift. <br><br><h4>  View the result of the algorithm </h4><br>  Example 1: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/i4sPR3bjP8I%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700253&amp;usg=ALkJrhjbfPD-2WbwnBMUFnZwWp_iIhI5AA" frameborder="0" allowfullscreen=""></iframe><br><br>  Example 2: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/OMVCcaM2G8A%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700253&amp;usg=ALkJrhjCSOvR3DPrtTUdgQ8RGn0g2tQMQA" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/219815/">https://habr.com/ru/post/219815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219803/index.html">Microcontrollers of AVR, MSP430, STM32 families and my subjective impressions</a></li>
<li><a href="../219807/index.html">New SkySat-1 HD Video: Las Vegas in All its Beauty</a></li>
<li><a href="../219809/index.html">Securely using the HTTP IfModifiedSince header in PCL libraries</a></li>
<li><a href="../219811/index.html">The advantage of the new configuration DELL PE R920 with SSDs on NVME EXPRESS FLASH PCIE</a></li>
<li><a href="../219813/index.html">Wordpress release 3.9 ‚ÄúSmith‚Äù</a></li>
<li><a href="../219819/index.html">Brain Overclock or Internal Consciousness Virtualization</a></li>
<li><a href="../219821/index.html">DevCon 2014: announcement of the second wave of speakers and reports</a></li>
<li><a href="../219823/index.html">Panoramas of the Arctic appeared on Yandex.Maps</a></li>
<li><a href="../219827/index.html">Camera and microscope - how to do it</a></li>
<li><a href="../219831/index.html">Ubuntu 14.04 LTS (Trusty Tahr) is available for download!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>