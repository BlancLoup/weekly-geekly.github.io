<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to find out the year of release of the song on the set of audio characteristics?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Scalable Machine Learning course on Apache Spark recently completed, covering the use of MLlib for machine learning. The course consisted of video...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to find out the year of release of the song on the set of audio characteristics?</h1><div class="post__text post__text-html js-mediator-article">  The <a href="https://www.edx.org/course/scalable-machine-learning-uc-berkeleyx-cs190-1x">Scalable Machine Learning</a> course on Apache Spark recently completed, covering the use of MLlib for machine learning.  The course consisted of video lectures and practical tasks.  Laboratory work needed to be done at PySpark, and since I‚Äôd more often come across scala in my work, I decided to resolve the main labs in this language, and at the same time learn the material better.  Of course, there are no big differences. Basically, this is what PySpark actively uses <a href="http://docs.scipy.org/doc/numpy/reference/index.html">NumPy</a> , and in the version with scala <a href="https://github.com/scalanlp/breeze">Breeze is</a> used. <br><br>  The first two workshops covered the study of the basic operations of linear algebra in NumPy and familiarity with the apache spark, respectively.  Actually machine learning began with the third laboratory work, it is disassembled below. <br><a name="habracut"></a><br>  This laboratory work is aimed at studying the linear regression method (one of the teaching methods with the teacher).  We will use part of the data from the <a href="http://labrosa.ee.columbia.edu/millionsong/">Million Song Dataset</a> .  Our goal is to find the best model that predicts the year of a song based on a set of audio characteristics using the linear regression method. <br><br>  This laboratory work includes the following steps: <br>  1. Reading, parsing and data processing <br>  2. Creating and evaluating the base model <br>  3. Implementation of the basic linear regression algorithm, training and model evaluation <br>  4. Finding a model using MLlib, setting up hyper parameters <br>  5. Add dependencies between characteristics 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  1. Reading, parsing and data processing </h4><br>  Raw data is currently stored in a <a href="https://drive.google.com/file/d/0B7o28oVJ-RWhMkJ0VkZlVjg0UEE/edit%3Fpli%3D1">text file</a> and consists of lines of this type: <br><pre><code class="scala hljs"><span class="hljs-number"><span class="hljs-number">2001.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.884123733793</span></span>,<span class="hljs-number"><span class="hljs-number">0.610454259079</span></span>,<span class="hljs-number"><span class="hljs-number">0.600498416968</span></span>,<span class="hljs-number"><span class="hljs-number">0.474669212493</span></span>,<span class="hljs-number"><span class="hljs-number">0.247232680947</span></span>,<span class="hljs-number"><span class="hljs-number">0.357306088914</span></span>,<span class="hljs-number"><span class="hljs-number">0.344136412234</span></span>,<span class="hljs-number"><span class="hljs-number">0.339641227335</span></span>,<span class="hljs-number"><span class="hljs-number">0.600858840135</span></span>,<span class="hljs-number"><span class="hljs-number">0.425704689024</span></span>,<span class="hljs-number"><span class="hljs-number">0.60491501652</span></span>,<span class="hljs-number"><span class="hljs-number">0.419193351817</span></span></code> </pre> <br>  Each line starts with a label (year of release of the song), and then the audio characteristics of the recording are separated by a comma. <br><br>  The first thing we start with is: present the data in the form of RDD: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SparkContext</span></span>(<span class="hljs-string"><span class="hljs-string">"local[*]"</span></span>, <span class="hljs-string"><span class="hljs-string">"week3"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawData: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = sc.textFile(<span class="hljs-string"><span class="hljs-string">"millionsong.txt"</span></span>)</code> </pre><br>  Let's see how many records we have: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numPoints = rawData.count() println(numPoints) &gt; <span class="hljs-number"><span class="hljs-number">6724</span></span></code> </pre><br>  To better understand the data provided to us, let's visualize them by building a heat map for at least some of the observations.  Since  characteristics range from 0 to 1, then let the closer the value is to one, the darker the shade of gray will be, and vice versa. <br><br><img src="https://habrastorage.org/files/221/763/0db/2217630db88d485a8a5f291de68bc075.png"><br><br>  In MLlib, a training sample (more precisely, its elements) should be stored in a special <a href="http://spark.apache.org/docs/latest/api/scala/">LabeledPoint</a> object, which consists of a label (label) and a set of characteristics (features) belonging to this label.  In our case, the label will be the year, and the characteristics will be the audio data of the recording. <br><br>  We write a function that, at the input, will receive one line from our data set and return the finished labeledPoint. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.mllib.regression.<span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.mllib.linalg.<span class="hljs-type"><span class="hljs-type">Vectors</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsePoint</span></span></span></span>(line: <span class="hljs-type"><span class="hljs-type">String</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sp = line.split(',') <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>(sp.head.toDouble, <span class="hljs-type"><span class="hljs-type">Vectors</span></span>.dense(sp.tail.map(_.toDouble))) }</code> </pre><br>  Let's translate our data into a working version: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedDataInit: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>] = rawData.map(parsePoint)</code> </pre><br>  Now let's examine the labels and find the range of years in which our data fit;  To do this, you need to find the maximum and minimum year. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onlyLabels = parsedDataInit.map(_.label) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> minYear = onlyLabels.min() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> maxYear = onlyLabels.max() println(<span class="hljs-string"><span class="hljs-string">s"max: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$maxYear</span></span></span><span class="hljs-string">, min: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$minYear</span></span></span><span class="hljs-string">"</span></span>) &gt; max: <span class="hljs-number"><span class="hljs-number">2011.0</span></span>, min: <span class="hljs-number"><span class="hljs-number">1922.0</span></span></code> </pre><br>  As we can see, the labels are located between 1922 and 2011.  In learning tasks, it is often natural to shift the values ‚Äã‚Äãso that they start from scratch.  Let's create a new RDD that will contain objects with labels offset by 1922.0. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedData = parsedDataInit.map(x =&gt; <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>(x.label - minYear, x.features))</code> </pre><br>  We have almost finished preparing the data, and all we have to do is split the data into 3 subsets: <br><ul><li>  <b>training sample</b> - it is on it that we will train our model </li><li>  <b>test sample</b> - on this data we will check how well the trained model predicts the result </li><li>  <b>test sample</b> - this set will simulate new data and help us truthfully evaluate the best model </li></ul><br>  For this purpose, spark has a <a href="http://spark.apache.org/docs/latest/api/scala/">randomSplit</a> method: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weights = <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> seed = <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> splitData: <span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>]] = parsedData.randomSplit(weights, seed).map(_.cache()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedTrainData = splitData(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedValData = splitData(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedTestData = splitData(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nTrain = parsedTrainData.count() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nVal = parsedValData.count() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nTest = parsedTestData.count() println(nTrain, nVal, nTest, nTrain + nVal + nTest) println(parsedData.count()) &gt;(<span class="hljs-number"><span class="hljs-number">5402</span></span>,<span class="hljs-number"><span class="hljs-number">622</span></span>,<span class="hljs-number"><span class="hljs-number">700</span></span>,<span class="hljs-number"><span class="hljs-number">6724</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">6724</span></span></code> </pre><br><h4>  2. Creating and evaluating the base model </h4><br>  Let's try to come up with a simple model with which we could compare the accuracy of the models obtained in the future.  In the simplest case, the model can predict the average value of the year, regardless of the incoming data.  Let's calculate this value: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> averageTrainYear = parsedTrainData.map(_.label).mean() println(averageTrainYear) &gt; <span class="hljs-number"><span class="hljs-number">53.68659755646054</span></span></code> </pre><br>  To evaluate how well our model works, let's use the square root of the root-mean-square error ( <a href="http://statistica.ru/glossary/general/srednekvadraticheskaya-oshibka/">RMSE</a> ) as an estimate <br><img src="https://habrastorage.org/files/469/6ca/b11/4696cab11f3c4c74990277f2c891d8df.png">  . <br><br>  In our case, y <sub>i</sub> is the label-year, and y <sub>i</sub> <sub>with a cap</sub> is the year predicted by the model.  First, we implement a function that calculates the square of the difference between the label and prediction and the function that will calculate the RMSE: <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squaredError</span></span></span></span>(label: <span class="hljs-type"><span class="hljs-type">Double</span></span>, prediction: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = math.pow(label - prediction, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcRMSE</span></span></span></span>(labelsAndPreds: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[(<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>)]) = math.sqrt(labelsAndPreds.map(x =&gt; squaredError(x._1, x._2)).sum() / labelsAndPreds.count())</code> </pre><br>  Now we can calculate the RMSE of our data based on the predictions of the base model.  To do this, we prepare new RDD containing tuples with observed and forecast years. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> labelsAndPredsTrain = parsedTrainData.map(x =&gt; x.label -&gt; averageTrainYear) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseTrainBase = calcRMSE(labelsAndPredsTrain) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> labelsAndPredsVal = parsedValData.map(x =&gt; x.label -&gt; averageTrainYear) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseValBase = calcRMSE(labelsAndPredsVal) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> labelsAndPredsTest = parsedTestData.map(x =&gt; x.label -&gt; averageTrainYear) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseTestBase = calcRMSE(labelsAndPredsTest) &gt; <span class="hljs-type"><span class="hljs-type">Base</span></span> model: <span class="hljs-type"><span class="hljs-type">Baseline</span></span> <span class="hljs-type"><span class="hljs-type">Train</span></span> <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">496</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> <span class="hljs-type"><span class="hljs-type">Validation</span></span> <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> <span class="hljs-type"><span class="hljs-type">Test</span></span> <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Note that each RMSE received can be interpreted as an average prediction error for a given set (in terms of number of years) <br><br><h4>  3. Implementation of the basic linear regression algorithm, training and model evaluation </h4><br>  Now that we have a base model and its evaluation, we can check whether the linear regression method can offer us a better result than the previous one. <br><br>  Recall the gradient descent step formula for linear regression: <br>  w <sub>i + 1</sub> = w <sub>i</sub> - Œ± <sub>i</sub> * ‚àë (w <sub>i</sub> <sup>T</sup> * x <sub>j</sub> - y <sub>j</sub> ) * x <sub>j</sub> . <br><br>  Where i is the iteration number and j is the observation ID. <br><br>  First, let's implement a function that calculates the term for this update (w <sup>T</sup> * x - y) * x: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> breeze.linalg.{ <span class="hljs-type"><span class="hljs-type">DenseVector</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gradientSummand</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>], lp: <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>): <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span>(lp.features.toArray) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = lp.label <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wx: <span class="hljs-type"><span class="hljs-type">Double</span></span> = weights.t * x (wx - y) * x }</code> </pre><br>  Go ahead: we need to implement a function that will take the calculated weights of the model and the observed values, and give the tuple (the observed value, the predicted value). <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLabeledPrediction</span></span></span></span>(weights: <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>], observation: <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>): (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-type"><span class="hljs-type">BreezeDenseVector</span></span>(observation.features.toArray) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = observation.label <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> prediction: <span class="hljs-type"><span class="hljs-type">Double</span></span> = weights.t * x (y, prediction) }</code> </pre><br>  It‚Äôs time to implement the Gradient descent method: <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linregGradientDescent</span></span></span></span>(trainData: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>], numIters: <span class="hljs-type"><span class="hljs-type">Int</span></span>) = { <span class="hljs-comment"><span class="hljs-comment">//    val n = trainData.count() // -  val d = trainData.first().features.size //     (  d ) val w = BreezeDenseVector.zeros[Double](d) val alpha = 1.0 val errorTrain = BreezeDenseVector.zeros[Double](numIters) for (i &lt;- 0 until numIters) { val labelsAndPredsTrain = trainData.map(x =&gt; getLabeledPrediction(w, x)) errorTrain(i) = calcRMSE(labelsAndPredsTrain) val gradient: BreezeDenseVector[Double] = trainData.map(x =&gt; gradientSummand(w, x)).reduce((dv1, dv2) =&gt; dv1 + dv2) val alpha_i = alpha / ( n * math.sqrt(i+1) ) w -= alpha_i * gradient } (w, errorTrain) }</span></span></code> </pre><br>  Well, everything is ready!  It now remains to train our linear regression model on the entire training sample and evaluate its accuracy on a test sample: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numIters = <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (weightsCustom, errorTrainCustom) = linregGradientDescent(parsedTrainData, numIters = numIters) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> labelsAndPreds = parsedValData.map(lp =&gt; getLabeledPrediction(weightsCustom, lp)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseValLRCustom = calcRMSE(labelsAndPreds) &gt; <span class="hljs-type"><span class="hljs-type">Custom</span></span> <span class="hljs-type"><span class="hljs-type">Linear</span></span> regression algorithm <span class="hljs-type"><span class="hljs-type">Weights</span></span> = <span class="hljs-type"><span class="hljs-type">DenseVector</span></span>(<span class="hljs-number"><span class="hljs-number">22.429559050840954</span></span>, <span class="hljs-number"><span class="hljs-number">20.57848949803509</span></span>, <span class="hljs-number"><span class="hljs-number">-0.38069311013701224</span></span>, <span class="hljs-number"><span class="hljs-number">8.286892767462648</span></span>, <span class="hljs-number"><span class="hljs-number">5.725188813272974</span></span>, <span class="hljs-number"><span class="hljs-number">-4.547779089973534</span></span>, <span class="hljs-number"><span class="hljs-number">15.494323154076804</span></span>, <span class="hljs-number"><span class="hljs-number">3.7888305696294986</span></span>, <span class="hljs-number"><span class="hljs-number">10.205862111138764</span></span>, <span class="hljs-number"><span class="hljs-number">5.877745123091225</span></span>, <span class="hljs-number"><span class="hljs-number">11.13061973187094</span></span>, <span class="hljs-number"><span class="hljs-number">3.6849419014146703</span></span>) <span class="hljs-type"><span class="hljs-type">Baseline</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">CustomLR</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">341</span></span></code> </pre><br>  At each iteration, we considered the RMSE for the training sample and now we can track how the algorithm behaved: for this we construct two graphs.  The first is the logarithm of the error from the iteration number for all 50 iterations, and the second is the actual error value for the last 44 iterations. <br><br><img src="https://habrastorage.org/files/048/f3d/447/048f3d4477924952a2fc62d1a38d3c3f.png"><br><br><img src="https://habrastorage.org/files/a92/469/ad2/a92469ad278f4c9c8fd9a005dd126cc7.png"><br><br>  We clearly achieved improvements: now our predictions are wrong, on average, not by 21 years, but only by 18. It should be noted that if the number of iterations is increased to 500, then the error will be 16,403. <br><br><h4>  4. Finding a model using MLlib, setting up hyper parameters </h4><br>  Well, now it looks much better.  However, let's see if we can improve the situation using the free term (constant, intercept) and regularization.  To do this, we will use the ready-made class LinearRegressionWithSGD, which essentially implements the same algorithm as we implemented, but more efficiently, with various additional functionality, such as stochastic gradient descent, the ability to add a free member, as well as L1 and L2 regularization. <br><br>  To begin with, we will implement a function that will help configure the model: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.mllib.regression.<span class="hljs-type"><span class="hljs-type">RidgeRegressionWithSGD</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tuneModel</span></span></span></span>(numIterations: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">500</span></span>, stepSize: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, regParam: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">1e-1</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">RidgeRegressionWithSGD</span></span>() model.optimizer .setStepSize(stepSize) .setNumIterations(numIterations) .setRegParam(regParam) model.setIntercept(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  We used RidgeRegressionWithSGD, because this is a wrapper with an already specified type of L2 regularization, just as we could use LinearRegressionWithSGD, but then we would have to add one more line <br> <code>model.optimizer.setUpdater(new SquaredL2Updater)</code> <br> <br>  Run the algorithm: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ridgeModel = tuneModel(numIterations = <span class="hljs-number"><span class="hljs-number">500</span></span>, stepSize = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, regParam = <span class="hljs-number"><span class="hljs-number">1e-1</span></span>).run(parsedTrainData) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weightsRidge = ridgeModel.weights <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> interceptRidge = ridgeModel.intercept <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseValRidge = calcError(ridgeModel, parsedValData) &gt; <span class="hljs-type"><span class="hljs-type">RidgeRegressionWithSGD</span></span> weights = [<span class="hljs-number"><span class="hljs-number">16.49707401343799</span></span>,<span class="hljs-number"><span class="hljs-number">15.090143596016913</span></span>,<span class="hljs-number"><span class="hljs-number">-0.33882414671890876</span></span>,<span class="hljs-number"><span class="hljs-number">6.21399054657087</span></span>,<span class="hljs-number"><span class="hljs-number">3.9399959912276765</span></span>,<span class="hljs-number"><span class="hljs-number">-3.326873353072514</span></span>,<span class="hljs-number"><span class="hljs-number">11.219894673155363</span></span>,<span class="hljs-number"><span class="hljs-number">2.605614334247694</span></span>,<span class="hljs-number"><span class="hljs-number">7.368594539065305</span></span>,<span class="hljs-number"><span class="hljs-number">4.352602095699236</span></span>,<span class="hljs-number"><span class="hljs-number">7.936294197372791</span></span>,<span class="hljs-number"><span class="hljs-number">2.597979499976716</span></span>] intercept = <span class="hljs-number"><span class="hljs-number">13.40151357030002</span></span> &gt; <span class="hljs-type"><span class="hljs-type">RidgeRegressionWithSGD</span></span> validation <span class="hljs-type"><span class="hljs-type">RMSE</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">CustomLR</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">341</span></span> <span class="hljs-type"><span class="hljs-type">RidgeLR</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">924</span></span></code> </pre><br>  The result is comparable to our implementation (and if we recall that with an equal number of iterations, we got 16.4, then the result is not so good), but we can probably improve the result by trying different values ‚Äã‚Äãof the regularization.  Let's see what happens if the regularization parameter is taken 1e-10, 1e-5 and 1. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestRMSE = rmseValRidge <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestRegParam = <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestModel = ridgeModel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (regParam &lt;- <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1e-10</span></span>, <span class="hljs-number"><span class="hljs-number">1e-5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> model = tuneModel(regParam = regParam).run(parsedTrainData) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseVal = calcError(model, parsedValData) println(<span class="hljs-string"><span class="hljs-string">f"regParam = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$regParam</span></span></span><span class="hljs-string">%.0e, RMSE = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$rmseVal</span></span></span><span class="hljs-string">%.3f"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rmseVal &lt; bestRMSE) { bestRMSE = rmseVal bestRegParam = regParam bestModel = model } } &gt; regParam = <span class="hljs-number"><span class="hljs-number">1e-10</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">292</span></span> regParam = <span class="hljs-number"><span class="hljs-number">1e-05</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">292</span></span> regParam = <span class="hljs-number"><span class="hljs-number">1e+00</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">23</span></span>,<span class="hljs-number"><span class="hljs-number">179</span></span> &gt; <span class="hljs-type"><span class="hljs-type">Best</span></span> model weights = [<span class="hljs-number"><span class="hljs-number">29.417184432817606</span></span>,<span class="hljs-number"><span class="hljs-number">31.186800575308965</span></span>,<span class="hljs-number"><span class="hljs-number">-17.37215928935944</span></span>,<span class="hljs-number"><span class="hljs-number">8.288971260120093</span></span>,<span class="hljs-number"><span class="hljs-number">5.111705048981693</span></span>,<span class="hljs-number"><span class="hljs-number">-22.61199371516979</span></span>,<span class="hljs-number"><span class="hljs-number">25.231243109503467</span></span>,<span class="hljs-number"><span class="hljs-number">-4.989933439427709</span></span>,<span class="hljs-number"><span class="hljs-number">6.709806469376133</span></span>,<span class="hljs-number"><span class="hljs-number">-0.08589332350175394</span></span>,<span class="hljs-number"><span class="hljs-number">9.958713420381914</span></span>,<span class="hljs-number"><span class="hljs-number">-6.252319073419468</span></span>] intercept = <span class="hljs-number"><span class="hljs-number">16.170147238736043</span></span> regParam = <span class="hljs-number"><span class="hljs-number">1.0E-10</span></span> &gt; <span class="hljs-type"><span class="hljs-type">Grid</span></span> validation <span class="hljs-type"><span class="hljs-type">RMSE</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">LR0</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">341</span></span> <span class="hljs-type"><span class="hljs-type">LR1</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">924</span></span> <span class="hljs-type"><span class="hljs-type">LRGrid</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">292</span></span></code> </pre><br>  It remains to check how the model behaves if you change the step value (alpha) and the number of iterations.  We will take the regularization parameter for the one that gave the best value, let the step be 1e-5, 10, and the number of iterations 500 and 5. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (alpha &lt;- <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1e-5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (numIter &lt;- <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> model = tuneModel(numIterations = numIter, stepSize = alpha, regParam = bestRegParam).run(parsedTrainData) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseVal = calcError(model, parsedValData) println(<span class="hljs-string"><span class="hljs-string">f"alpha = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$alpha</span></span></span><span class="hljs-string">%.0e, numIters = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$numIter</span></span></span><span class="hljs-string">, RMSE = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$rmseVal</span></span></span><span class="hljs-string">%.3f"</span></span>) } } &gt; alpha = <span class="hljs-number"><span class="hljs-number">1e-05</span></span>, numIters = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">56</span></span>,<span class="hljs-number"><span class="hljs-number">912</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1e-05</span></span>, numIters = <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">56</span></span>,<span class="hljs-number"><span class="hljs-number">835</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1e+01</span></span>, numIters = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">351471078</span></span>,<span class="hljs-number"><span class="hljs-number">741</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1e+01</span></span>, numIters = <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-type"><span class="hljs-type">RMSE</span></span> = <span class="hljs-number"><span class="hljs-number">3696615731186115000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span>,<span class="hljs-number"><span class="hljs-number">000</span></span></code> </pre><br>  So, we can conclude that with a small step, the algorithm very slowly approaches the minimum, and with a large one it diverges altogether, and very quickly. <br><br><h4>  5. Add dependencies between characteristics </h4><br>  So far, we have used only those characteristics that were provided to us.  For example, if we only had 2 x <sub>1</sub> and x <sub>2</sub> characteristics, then the model would be: <br>  w <sub>0</sub> + w <sub>1</sub> x <sub>1</sub> + w <sub>2</sub> x <sub>2</sub> . <br><br>  However, nothing prevents us from creating additional characteristics: returning to our example, we could come up with a more complex model: <br>  w <sub>0</sub> + w <sub>1</sub> x <sub>1</sub> + w <sub>2</sub> x <sub>2</sub> + w <sub>3</sub> x <sub>1</sub> x <sub>2</sub> + w <sub>4</sub> x <sub>2</sub> x <sub>1</sub> + w <sub>5</sub> x <sub>1</sub> <sup>2</sup> + w <sub>6</sub> x <sub>2</sub> <sup>2</sup> <br><br>  Let's do it;  for this we need to implement a function that would multiply in pairs the values ‚Äã‚Äãof the characteristics and return a new set combined with the original one. <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoWayInteractions</span></span></span></span>(lp: <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> features: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] = lp.features.toArray.toList <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> two = (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x &lt;- features; y &lt;- features) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (x,y)).map(x =&gt; x._1 * x._2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inter = two ::: features <span class="hljs-type"><span class="hljs-type">LabeledPoint</span></span>(lp.label, <span class="hljs-type"><span class="hljs-type">Vectors</span></span>.dense(inter.toArray)) }</code> </pre><br>  Now let's create a new model, for this we need to apply the function described above to our datasets: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trainDataInteract = parsedTrainData.map(twoWayInteractions) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> valDataInteract = parsedValData.map(twoWayInteractions) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testDataInteract = parsedTestData.map(twoWayInteractions)</code> </pre><br>  Well, then we must repeat the search for hyper parameters for the new model, since the settings found earlier may not give the best result.  But we will not repeat this here, but we will immediately substitute the optimal ones. <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> modelInteract = tuneModel(regParam = bestRegParam).run(trainDataInteract) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rmseValLRInteract = calcError(modelInteract, valDataInteract) &gt; <span class="hljs-type"><span class="hljs-type">Interact</span></span> validation <span class="hljs-type"><span class="hljs-type">RMSE</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">LR0</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">341</span></span> <span class="hljs-type"><span class="hljs-type">LR1</span></span> = <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">924</span></span> <span class="hljs-type"><span class="hljs-type">LRGrid</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">292</span></span> <span class="hljs-type"><span class="hljs-type">LRInteract</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span></code> </pre><br>  And finally, let's evaluate our new model on test data.  Please note that we did not use test data to select the best model.  Therefore, our estimate gives an unbiased estimate of how the resulting model will work on new data.  Now we can see how the new model is better than the base one. <br><pre> <code class="scala hljs"> &gt; <span class="hljs-type"><span class="hljs-type">Test</span></span> validation <span class="hljs-type"><span class="hljs-type">RMSE</span></span> <span class="hljs-type"><span class="hljs-type">Baseline</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-type"><span class="hljs-type">LRInteract</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">905</span></span></code> </pre><br>  Well, that's all, the final assessment certainly does not look particularly good, but definitely better than the one we started with. </div><p>Source: <a href="https://habr.com/ru/post/264193/">https://habr.com/ru/post/264193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264179/index.html">Writing a bot for Tox messenger</a></li>
<li><a href="../264181/index.html">RPC, Messaging, REST: Terminology</a></li>
<li><a href="../264185/index.html">Modern Adaptec RAID controllers from A to Z. Part 2</a></li>
<li><a href="../264189/index.html">Implementation of the wave algorithm for finding the shortest path to dynamically moving objects in unity3d on C # in a 2d game</a></li>
<li><a href="../264191/index.html">Interpolation of data: we connect points so that it was beautiful</a></li>
<li><a href="../264195/index.html">Hybrid Conf - the first conference on programmatic-advertising in Russia</a></li>
<li><a href="../264197/index.html">HDD sled - cost effective grain</a></li>
<li><a href="../264199/index.html">Triggers and Background Jobs in Windows Store Applications</a></li>
<li><a href="../264201/index.html">Intervals in C ++, part 1: Intervals with limiters</a></li>
<li><a href="../264207/index.html">Is there a problem with the MTS mobile traffic in some regions, or the skis do not travel?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>