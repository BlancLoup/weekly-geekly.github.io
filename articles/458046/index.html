<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cheat Sheet by Gradle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As it seems to me, most people start to deal with gradle only when something needs to be added to the project or something suddenly breaks down - and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cheat Sheet by Gradle</h1><div class="post__text post__text-html js-mediator-article"><p>  As it seems to me, most people start to deal with gradle only when something needs to be added to the project or something suddenly breaks down - and after solving the problem of "overwork", the experience is safely forgotten.  Moreover, many examples on the Internet are similar to the spetsspecialized spells that do not add an understanding of what is happening: </p><br><pre><code class="java hljs">android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> defaultConfig { applicationId <span class="hljs-string"><span class="hljs-string">"com.habr.hello"</span></span> minSdkVersion <span class="hljs-number"><span class="hljs-number">20</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> } buildTypes { release { minifyEnabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } } }</code> </pre> <br><p>  I'm not going to describe in detail what each line is needed above - these are particular details of the implementation of the android plugin.  There is something more valuable - understanding how everything is organized.  The information is scattered on various sites / official documentation / source code of the hail and plug-ins to it - in general, this is a little more universal knowledge that you don‚Äôt want to forget. </p><br><p>  Further text can be viewed as a cheat sheet for those who only master gradle or have already forgotten. </p><a name="habracut"></a><br><h2 id="poleznye-ssylki">  useful links </h2><br><ul><li>  <a href="https://docs.gradle.org/current/userguide/getting_started.html">Official documentation</a> Quite voluminous, but in some places details may not be enough. </li><li>  <a href="https://github.com/gradle/gradle">source code on github</a> , <a href="https://docs.gradle.org/current/javadoc/">javadoc</a> - due to the dynamic typing in groovy, the development environment can not always give a list of available fields / methods, and the short names of the methods and the types of arguments (Closure closure) cannot always be understood why they are needed. </li><li>  <a href="https://habr.com/en/post/167227/">An article on Habr√© with a bunch of examples</a> is a translation of the second chapter of the book "Building and testing with gradle".  The book can also be read, it is in the public domain. </li><li>  <a href="https://habr.com/en/company/jugru/blog/342914/">one more article about buildSrc</a> </li></ul><br><h1 id="konsol">  Console </h1><br><p>  Android studio / IDEA diligently hides the gradle commands from the developer, and even when the build.gradle changes, the files start to blunt or reload the project. </p><br><p>  In such cases, calling the gradle from the console is much easier and faster.  Wrapper for gradle usually goes along with the project and works great in linux / macos / windows, except that in the latter one should call the bat-file instead of the wrapper. </p><br><h2 id="vyzov-zadach">  Challenge tasks </h2><br><pre> <code class="plaintext hljs">./gradlew tasks</code> </pre> <br><p>  writes accessible tasks. </p><br><pre> <code class="plaintext hljs">./gradlew subprojectName:tasks --all</code> </pre> <br><p>  You can display the tasks of a separate subproject, and with the <code>--all</code> option all the tasks, including the minor ones, will be displayed. </p><br><p>  You can call any task, all tasks on which it depends will be called. </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDevelopDebug</code> </pre> <br><p>  If you are too lazy to write the name entirely, you can throw out small letters: </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDD</code> </pre> <br><p>  If the grad will not be able to unambiguously guess which particular task was meant, then it will display a list of suitable options. </p><br><h2 id="logging">  Logging </h2><br><p>  The amount of information output to the console when the task is started is highly dependent on the level of logging. <br>  In addition to the default, there is <code>-q, -w, -i, -d</code> , well, or <code>--quiet, --warn, --info, --debug</code> by increasing the amount of information.  On complex projects, the output from -d may take up more megabytes, and therefore it is better to save it immediately to a file and already look there by searching for keywords: </p><br><pre> <code class="bash hljs">./gradlew app:build -d &gt; myLog.txt</code> </pre> <br><p>  If an exception is thrown somewhere, for the stacktrace option is <code>-s</code> . </p><br><p>  You can write yourself to the log: </p><br><pre> <code class="java hljs">logger.warn(<span class="hljs-string"><span class="hljs-string">'A warning log message.'</span></span>)</code> </pre> <br><p>  logger is an implementation of SLF4J. </p><br><h2 id="groovy">  Groovy </h2><br><p>  What is happening in the <code>build.gradle</code> files is just groovy code. </p><br><p>  Groovy as a programming language for some reason is not very popular, although, as it seems to me, it is in itself worthy of at least a little learning.  Language was born in 2003 and slowly developed.  Interesting features: </p><br><ul><li>  Virtually any java code is a valid groovy code.  It helps to write working code intuitively. </li><li>  At the same time, along with static, dynamic typing is supported in the group, instead of <code>String a = "a"</code> you can safely write <code>def a = "a"</code> or even <code>def map = ['one':1, 'two':2, 'list' = [1,false]]</code> </li><li>  There are closures for which you can dynamically determine the execution context.  Those <code>android {...}</code> blocks take closures and then execute them for some object. </li><li>  There is an interpolation of the lines <code>"$a, ${b}"</code> , multiline-lines <code>"""yep, ${c}"""</code> , and the usual java-lines are framed in single quotes: <code>'text'</code> </li><li>  There is a semblance of extension-methods.  In the standard language collection there are already methods like any, every, each, findAll.  Personally, the names of the methods seem unusual, but the main thing is that <a href="http://docs.groovy-lang.org/next/html/documentation/working-with-collections.html">they exist</a> . </li><li>  Delicious syntactic sugar, the code becomes much shorter and easier.  You can not write brackets around the function arguments, for the declaration of lists and hash plates nice syntax: <code>[a,b,c], [key1: value1, key2: value2]</code> </li></ul><br><p>  In general, why languages ‚Äã‚Äãlike Python / Javascript soared, and Groovy is not - a mystery to me.  For its time, when jambda wasn‚Äôt even in java, and alternatives like kotlin / scala just appeared or didn‚Äôt exist yet, Groovy should have looked like a really interesting language. </p><br><p>  It is the flexibility of the groovy syntax and dynamic typing that made it possible to create concise DSLs in gradle. </p><br><p>  Now in the official Gradle documentation, the examples are duplicated on Kotlin, and it seems like it is planned to switch to it, but the code no longer looks so simple and becomes more like ordinary code: </p><br><pre> <code class="java hljs">task hello { doLast { println <span class="hljs-string"><span class="hljs-string">"hello"</span></span> } }</code> </pre> <br><p>  vs </p><br><pre> <code class="kotlin hljs">tasks.register(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) { doLast { println(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) } }</code> </pre> <br><p>  However, the renaming to Kradle is not planned yet. </p><br><h2 id="stadii-sborki">  Build stages </h2><br><p>  They are divided into initialization, configuration, and execution. </p><br><p>  The idea is that gradle collects an acyclic dependency graph and only causes the necessary minimum of them.  If I understand correctly, the initialization stage occurs at the moment when the code from build.gradle is executed. </p><br><p>  For example, such: </p><br><pre> <code class="java hljs">copy { from source to dest }</code> </pre> <br><p>  Or this: </p><br><pre> <code class="java hljs">task epicFail { copy{ from source to dest } }</code> </pre> <br><p>  Perhaps this is not obvious, but the above will inhibit initialization.  In order not to copy files at each initialization, you need a <code>doLast{...}</code> or <code>doFirst{...}</code> block in the task - then the code will turn into a closure and it will be called at the moment of the task execution. </p><br><pre> <code class="java hljs">task properCopy { doLast { copy { from dest to source } } }</code> </pre> <br><p>  or so </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">properCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Copy)</span></span></span><span class="hljs-function"> </span></span>{ from dest to source }</code> </pre> <br><p>  In the old examples, instead of <code>doLast</code> , the <code>&lt;&lt;</code> operator can be found, but it was later abandoned due to non-obviousness of the behavior. </p><br><pre> <code class="java hljs">task properCopy &lt;&lt; { println(<span class="hljs-string"><span class="hljs-string">"files copied"</span></span>) }</code> </pre> <br><h2 id="tasksall">  tasks.all </h2><br><p>  What is funny, with <code>doLast</code> and <code>doFirst</code> you can hang some actions on any tasks: </p><br><pre> <code class="kotlin hljs">tasks.all { doFirst { println(<span class="hljs-string"><span class="hljs-string">"task </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> started"</span></span>) } }</code> </pre> <br><p>  The IDE suggests that <code>tasks</code> have the <code>whenTaskAdded(Closure ...)</code> method, but the <code>all(Closure ...)</code> method works much more interestingly - the closure is called for all existing tasks, as well as for new tasks when they are added. </p><br><p>  Create a task that prints dependencies of all tasks: </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dependsOn</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p>  or so: </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { Task task -&gt; println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.name}</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.dependsOn}</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p>  If <code>tasks.all{}</code> called at runtime (in the <code>doLast</code> block), then we will see all the tasks and dependencies. <br>  If you do the same without <code>doLast</code> (i.e., during initialization), then the printed tasks may not have enough dependencies, since they have not been added yet. </p><br><p>  Oh yes, addictions!  If another task should depend on the results of our implementation, then it is worth adding a dependency: </p><br><pre> <code class="java hljs">anotherTask.dependsOn properCopy</code> </pre> <br><p>  Or even like this: </p><br><pre> <code class="kotlin hljs">tasks.all{ task -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task.name.toLowerCase().contains(<span class="hljs-string"><span class="hljs-string">"debug"</span></span>)) { task.dependsOn properCopy } }</code> </pre> <br><h2 id="inputs-outputs-i-inkrementalnaya-sborka">  inputs, outputs and incremental build </h2><br><p>  A normal task will be called every time.  If you specify that a task based on file A generates file B, then gradle will skip the task if these files have not changed.  Moreover, gradle does not check the date of the file change, but its contents. </p><br><pre> <code class="kotlin hljs">task generateCode(type: Exec) { commandLine <span class="hljs-string"><span class="hljs-string">"generateCode.sh"</span></span>, <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> inputs.file <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span> output.file <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> }</code> </pre> <br><p>  Similarly, you can specify the folder, as well as some values: <code>inputs.property(name, value)</code> . </p><br><h2 id="task-description">  task description </h2><br><p>  When you call <code>./gradlew tasks --all</code> standard tasks have a beautiful description and are somehow grouped.  For your tasks, this is added very simply: </p><br><pre> <code class="kotlin hljs">task hello { group <span class="hljs-string"><span class="hljs-string">"MyCustomGroup"</span></span> description <span class="hljs-string"><span class="hljs-string">"Prints 'hello'"</span></span> doLast{ print <span class="hljs-string"><span class="hljs-string">'hello'</span></span> } }</code> </pre> <br><h3 id="taskenabled">  task.enabled </h3><br><p>  you can "turn off" the task - then its dependencies will still be caused, but she herself will not. </p><br><pre> <code class="java hljs">taskName.enabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br><h2 id="neskolko-proektov-moduley">  several projects (modules) </h2><br><p>  <a href="https://guides.gradle.org/creating-multi-project-builds/">multi-project builds in documentation</a> </p><br><p>  In the main project you can arrange several more modules.  For example, this is used in android projects - there is almost nothing in the root project, the android plugin is enabled in the subproject.  If you want to add a new module, you can add another one, and there, for example, also connect the android plugin, but use other settings for it. </p><br><p>  Another example: when publishing a project using jitpack, the root project describes with what settings to publish a child module that may not even be aware of the fact of publication. </p><br><p>  Child modules are specified in settings.gradle: </p><br><pre> <code class="java hljs">include <span class="hljs-string"><span class="hljs-string">'name'</span></span></code> </pre> <br><p>  You can read more about the dependencies between projects <a href="https://docs.gradle.org/current/userguide/multi_project_builds.html">here.</a> </p><br><h2 id="buildsrc">  buildSrc </h2><br><p>  If <code>build.gradle</code> lot of code in <code>build.gradle</code> or it is duplicated, it can be put into a separate module.  You need a folder with the magic name <code>buildSrc</code> , in which you can place the code on groovy or java.  (well, more correctly, in <code>buildSrc/src/main/java/com/smth/</code> code, tests can be added to <code>buildSrc/src/test</code> ).  If you want something else, for example, to write your task on scala or use any dependencies, then you need to create <code>build.gradle</code> directly in <code>build.gradle</code> and specify the necessary dependencies / enable plugins in it. </p><br><p>  Unfortunately, with the project in <code>buildSrc</code> IDE can be stupid with hints, there you have to write imports and classes / tasks from there <code>build.gradle</code> will also need to import from there to the usual <code>build.gradle</code> .  Write <code>import com.smth.Taskname</code> - not difficult, you just need to remember this and not wrestle with why the task from <code>buildSrc</code> not found). </p><br><p>  For this reason, it is convenient to first write something that works directly in <code>build.gradle</code> , and only then transfer the code to <code>buildSrc</code> . </p><br><h2 id="svoy-tip-zadachi">  Own type of task </h2><br><p>  The task is inherited from <code>DefaultTask</code> , in which there are many, many fields, methods and other things.  <a href="">AbstractTask code, from which the DefaultTask is inherited.</a> </p><br><p>  Useful points: </p><br><ul><li>  instead of manually adding <code>inputs</code> and <code>outputs</code> you can use fields and annotations to them: <code>@Input, @OutputFile</code> , etc. </li><li>  The method that will be run when the task is executed: <code>@TaskAction</code> . </li><li>  convenient methods like <code>copy{from ... , into... }</code> can still be called, but you have to explicitly call them for the project: <code>project.copy{...}</code> </li></ul><br><p>  When for our task someone in <code>build.gradle</code> writes </p><br><pre> <code class="java hljs">taskName { ... <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre> <br><p>  the task calls the <code>configure(Closure)</code> method. </p><br><p>  I'm not sure that this is the right approach, but if the task has several fields, the mutual state of which is difficult to control by getters-setters, then it seems quite convenient to redefine the method as follows: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure closure)</span></span></span></span>{ def result = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>().configure(closure) <span class="hljs-comment"><span class="hljs-comment">//    / - return result; }</span></span></code> </pre> <br><p>  And even if you write </p><br><pre> <code class="java hljs">taskName.fieldName value</code> </pre> <br><p>  then the <code>configure</code> method will still be called. </p><br><h2 id="svoy-plagin">  Own plugin </h2><br><p>  Like a task, you can write your own plugin that will customize something or create tasks.  For example, what happens in <code>android{...}</code> is completely merit <del>  dark magic </del>  Android plugin, which in addition creates a whole bunch of tasks like app: assembleDevelopDebug for all possible combinations of flavor / build type / dimenstion.  There is nothing difficult in writing your own plugin, for a better understanding you can see the code of other plugins. </p><br><p>  There is a third step - you can not place the code in the <code>buildSrc</code> , but make it a separate project.  Then, using <a href="https://jitpack.io/">https://jitpack.io</a> or something else, publish the plugin and connect it similarly to the rest. </p><br><h2 id="the-end">  The end </h2><br><p>  In the examples above, there may be typographical errors and inaccuracies.  Write in a personal note or mark with <code>ctrl+enter</code> - correct.  It is better to take concrete examples from the documentation, and to look at this article as a list of how to do it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/458046/">https://habr.com/ru/post/458046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458030/index.html">Functional JavaScript: five ways to find the arithmetic average of array elements and the .reduce () method</a></li>
<li><a href="../45804/index.html">The unifying power of user experience</a></li>
<li><a href="../458040/index.html">From Moscow to Tomsk. The story of one move</a></li>
<li><a href="../458042/index.html">How I organized machine learning trainings at NSU</a></li>
<li><a href="../458044/index.html">Provincial IS - Stagnation or Development?</a></li>
<li><a href="../458048/index.html">Delegation as a tool manager</a></li>
<li><a href="../458050/index.html">How did the Mobius 2019 Piter (and a little about the next Mobius)</a></li>
<li><a href="../458052/index.html">AMA with Habr v.10. Last * issue</a></li>
<li><a href="../458062/index.html">UserGate Platform Overview</a></li>
<li><a href="../458070/index.html">PVS-Studio for Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>