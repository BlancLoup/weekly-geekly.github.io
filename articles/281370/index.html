<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Leaks do not violate memory safety</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Errors of access to memory and memory leaks are two categories of errors that attract the most attention, so much effort is aimed at preventing or at ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Leaks do not violate memory safety</h1><div class="post__text post__text-html js-mediator-article"><p>  Errors of access to memory and memory leaks are two categories of errors that attract the most attention, so much effort is aimed at preventing or at least reducing their number.  Although their name suggests similarity, they are diametrically opposed in some way, and the solution of one of the problems does not save us from the second.  The wide distribution of managed languages ‚Äã‚Äãconfirms this idea: they prevent some memory access errors by taking over the job of freeing memory. <br><br>  Simply put: a <strong>memory access violation is some kind of action with incorrect data, and a memory leak is the <em>absence of</em> certain action with correct data</strong> .  In tabular form: </p><br><pre><code class="hljs 1c">     OK     <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    OK</code> </pre> <br><p>  The best programs perform only actions from OK cells: they manipulate correct data and do not manipulate incorrect ones.  Eligible programs may also contain some valid, but unused data (memory leaks), and bad ones try to use incorrect data. <br><br>  When a language promises <em>safe</em> memory handling, as Rust does, it does not guarantee the impossibility of memory <em>leaks</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><a name="habracut"></a><br><h4>  Effects </h4><br><p>  The most important difference between memory access errors and leaks in practice is manifested in the potential consequences: the former lead to very serious problems, while the latter are simply annoying. <br><br>  Memory security is a key element of any other form of security / validity.  If the program makes errors with memory, it is difficult to give any guarantees about its behavior, since the possibility of memory damage is not excluded.  Attackers can use memory access errors in such a program to <a href="https://ru.wikipedia.org/wiki/Heartbleed">read confidential keys directly from server memory</a> or execute arbitrary code on your computer. <br><br>  On the other hand, a memory leak in the worst case will lead to a denial of service: a useful program will crash due to using too much memory, and the computer may stop responding because of its deficit.  This situation may also be caused by an attacker, but methods to combat this have long been developed.  Of course, the denial of service is very annoying and in some places is a critical problem, but potential memory access errors are no less, and maybe more, a problem.  In addition, given the unpredictability of possible memory access errors, this may still lead to a denial of service. <br><br>  As a result, most programming languages ‚Äã‚Äãprefer to put up with memory leaks (assuming no release or cleaning of data after the last use), but not with memory access errors.  Thus, most "safe" languages ‚Äã‚Äãensure that the programs written in them do not contain such errors, unless you consciously decide to bypass the restrictions (for example, using the <code>ctypes</code> module in Python or the <code>unsafe</code> keyword in Rust).  As for leaks, they are trying to fight them (as a rule), but they do not give any guarantees. <br><br></p><br><h4> <code>delete free</code> </h4> <br><p>  Memory access errors occur for several reasons, but one category stands out when we discuss memory management.  I will quote Wikipedia: </p><br><blockquote>  Errors of working with dynamic memory - incorrect use of dynamic memory and pointers: </blockquote><br><ul><li>  Hanging pointers - pointers that store the address of the object that was deleted. </li><li>  Double release - a <code>free</code> call can prematurely delete a new object located at the same address.  If the address has not been reused, then other problems may arise, especially in the allocators that use free lists. </li><li>  Incorrect release - passing an incorrect address to the <code>free</code> function can spoil the heap. </li><li>  A reference to the null pointer will lead to the exclusion or abnormal termination of the program in most environments, but it may also cause data corruption in the operating system kernel or in systems with no memory protection or using a large negative offset. </li></ul><br><br><p>  In this list, only a reference to the null pointer is not caused by an incorrect freeing of memory (by calling the <code>free</code> function to mark unused memory and return to the operating system).  Thus, all these problems can be avoided simply by never causing <code>free</code> : if the memory is never released, then there will be no problems associated with it.  Referring to the table above: removing the release of memory, we remove the column "incorrect data" - all data will always be correct. <br><br>  Of course, a simple ban on calling <code>free</code> has its drawbacks (although it has advantages, apart from the lack of problems with freeing memory: there are no difficulties with understanding the data lifetime, which simplifies writing many parallel algorithms).  In particular, it becomes problematic to write programs so that they do not exhaust all available memory.  However, computers, unlike people, are not mistaken, so perhaps we can pass the <code>free</code> call onto their shoulders ... <br><br></p><br><h4>  Leak optimization </h4><br><p>  Much of the modern code is written in languages ‚Äã‚Äãdesigned to ensure the security of working with memory, such as Java, Javascript, Python or Ruby.  They do without an explicit <code>free</code> call and automatically manage memory (hence the name "managed languages") using the garbage collector built into the language runtime environment. <br><br>  In fact, garbage collection is a way to provide the programmer and program with the illusion of infinite memory and get rid of the need to carefully track the moment when memory can be freed.  You focus on the logic of the subject area, and the garbage collector automatically frees the guaranteed unused portions of memory.  Virtually all garbage collectors conservatively determine data that can be deleted if they are not referenced (so the garbage collector must track or have access to all memory allocations). <br><br>  It is worth noting that high-quality implementations of the garbage collector provide additional benefits: memory allocation is usually implemented as a simple pointer shift in the presence of generations of objects, and the capabilities of the moving garbage collector improve cache locality (which is especially useful, given that access to data and this is done by a pointer in most managed languages).  However, these features are not relevant to the topic of the article. <br><br>  In practice, programmers almost never have to think about the fact that memory is not infinite, but the safety of working with memory, as desired, is ensured.  In high-performance code, you often have to resort to all sorts of tricks (for example, object pools that help avoid memory allocation with frequent creation and deletion of objects) in order to circumvent the inefficiency of garbage collection.  It is also possible that the data due to <a href="https://en.wikipedia.org/wiki/Lapsed_listener_problem">forgotten links</a> live longer than necessary. <br><br>  Nevertheless, the goal is achieved even with the practical problems: the absence of free calls guarantees the absence of (some) problems with memory. <br><br></p><br><h4>  Less abstractions </h4><br><p>  I can not fail to mention an alternative to automatic memory management: instead of trying to get rid of the ‚ÄúIncorrect data‚Äù column as a whole, you can guarantee only the absence of memory security problems.  <a href="https://www.rust-lang.org/">The programming language Rust</a> does exactly that. <br><br>  This approach eliminates the need for manual release of resources, although the <a href="http://doc.rust-lang.org/std/mem/fn.drop.html"><code>drop</code></a> function allows you to call the destructor ahead of time.  Unlike C and C ++, at the compilation stage, Rust prohibits further use of such incorrect data and prevents errors. <br><br>  However, this model does not guarantee the absence of leaks: the revised table for Rust (and languages ‚Äã‚Äãwith the same principle) still has the Memory Leak cell. </p><br><pre> <code class="hljs 1c">      OK  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    OK</code> </pre> <br><p>  Many do not see the difference between "memory leaks" and "memory security."  Having heard that Rust guarantees the safety of working with memory, they simply expect protection against leaks and do not understand that this language can do things that modern C ++ does not know about low-level programming.  <strong>Rust does not allow access memory errors, but does not exclude leaks.</strong> </p><br><h4> <code>std::mem::forget</code> </h4> <br><p>  And finally, in Rust there is a function <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>forget</code></a> , which marks the data as released, preventing further access to it, but does not cause a destructor, which potentially leads to a memory leak.  For a long time, this function was marked as unsafe, that is, Rust implicitly implied that memory leaks are something that a programmer must consciously choose, similar to the security of working with memory.  In practice, however, pointers with reference counting or interlocking of threads can lead to leaks.  As a result, the <code>forget</code> function was <a href="">made safe</a> by focusing on preventing memory access errors, although making all possible efforts to combat leaks, however, like all other languages. <br><br>  Like modern C ++, Rust does a pretty good job: managing resources based on RAII, namely destructors, are <a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">powerful tools</a> for managing memory ( <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">and not only that</a> ), especially in combination with the default movement semantics used in Rust.  Lack of leakage is not guaranteed for two reasons: </p><br><ul><li>  It is not easy to give a formal definition of a memory leak (at least, the usefulness of such a definition depends on the context). </li><li>  There are relatively rare boundary cases that, apparently, cannot be statically prevented without overhead. </li></ul><br><p>  The standard library Rust <a href="">expects</a> that leaks are safe, although they can lead to incorrect operation.  In other words, you can get undesirable behavior if the data is not released, but the consequences are less destructive than segmentation fault or memory corruption. </p></div><p>Source: <a href="https://habr.com/ru/post/281370/">https://habr.com/ru/post/281370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281354/index.html">Implementation of monitoring and integration testing information system using Scalatest. Part 2</a></li>
<li><a href="../281356/index.html">Simple automation of the management of acts of marriage on SharePoint with examples and pictures</a></li>
<li><a href="../281358/index.html">JetBrains is looking for a technical evangelist with Java experience</a></li>
<li><a href="../281360/index.html">.Net Client for mail.ru cloud</a></li>
<li><a href="../281362/index.html">New Cisco Aironet IEEE 802.11ac Wave 2 Access Points</a></li>
<li><a href="../281372/index.html">Linux / Mumblehard botnet unmounted using ESET</a></li>
<li><a href="../281374/index.html">Visual Studio 2015 Standard Library and Telemetry</a></li>
<li><a href="../281376/index.html">Why did Citrix not become the ‚Äúnew Red Hat‚Äù in the virtualization market? Part 2</a></li>
<li><a href="../281378/index.html">Is a new Yandex, Parallels or Nginx now in Russia? Easily</a></li>
<li><a href="../281380/index.html">Develop HTML5 games in Intel XDK. Part 1. Introduction to the XDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>