<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vision-based SLAM: monocular SLAM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue a series of lesson articles on visual SLAM with a lesson on working with its monocular variants. We have already talked about installing a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vision-based SLAM: monocular SLAM</h1><div class="post__text post__text-html js-mediator-article">  We continue a series of lesson articles on visual SLAM with a lesson on working with its monocular variants.  We have already <a href="http://habrahabr.ru/company/singularis/blog/277109/">talked about installing and configuring the environment</a> , and also conducted a general overview in the <a href="http://habrahabr.ru/company/singularis/blog/276595/">article on quadcopter navigation</a> .  Today we will try to understand how different SLAM algorithms using a single camera work, consider their differences for the user and give recommendations on the application. <br><img src="https://habrastorage.org/files/a48/55c/8f3/a4855c8f3f6447339f5fa858e3c0e73c.png"><br><a name="habracut"></a><br><br>  For a more detailed analysis of the details today, we limit ourselves to two implementations of monocular SLAM: ORB SLAM and LSD SLAM.  These algorithms are the most advanced in their class from open-source projects.  <a href="http://www.robots.ox.ac.uk/~gk/PTAM/">PTAM is</a> also very common, but it is not as cool as, for example, ORB SLAM. <br><br><h2>  Retrieving Calibration Parameters </h2><br>  All monocular SLAM algorithms require accurate camera calibration.  We did this in the <a href="http://habrahabr.ru/company/singularis/blog/277109/">last lesson</a> , now we will extract the camera parameters.  For the camera model we use, we need to extract the camera matrix (fx, fy, cx, cy) and 5 parameters of the distortion function (k1, k2, p1, p2, k3).  Go to the ~ / .ros / camera_info directory and open the YAML file with the camera settings.  The contents of the file will look something like this (instead of ardrone_front there will be another name): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Calibration file</b> <div class="spoiler_text"><code>image_width: 640 <br> image_height: 360 <br> camera_name: ardrone_front <br> camera_matrix: <br> rows: 3 <br> cols: 3 <br> data: [569.883158064802, 0, 331.403348466206, 0, 568.007065238522, 135.879365106014, 0, 0, 1] <br> distortion_model: plumb_bob <br> distortion_coefficients: <br> rows: 1 <br> cols: 5 <br> data: [-0.526629354780687, 0.274357114262035, 0.0211426202132638, -0.0063942451330052, 0] <br> rectification_matrix: <br> rows: 3 <br> cols: 3 <br> data: [1, 0, 0, 0, 1, 0, 0, 0, 1] <br> projection_matrix: <br> rows: 3 <br> cols: 4 <br> data: [463.275726318359, 0, 328.456687172518, 0, 0, 535.977355957031, 134.693732992726, 0, 0, 0, 1, 0] <br></code> </div></div><br>  We are interested in the camera_matrix and distortion_coefficients fields, they contain the necessary values ‚Äã‚Äãin the following format: <br><br> <code>camera_matrix: <br> rows: 3 <br> cols: 3 <br> data: [fx, 0, fy, 0, cx, cy, 0, 0, 1] <br> <br> distortion_coefficients: <br> rows: 1 <br> cols: 5 <br> data: [k1, k2, p1, p2, k3] <br></code> <br>  Save these values, they will be useful to us further. <br><br><h2>  ORB SLAM </h2><br><h3>  Principle of operation </h3><br>  The ORB SLAM algorithm is generally not very different in how it works from other visual SLAMs.  Features are extracted from images.  Further, using the <a href="http://en.wikipedia.org/wiki/Bundle_adjustment">Bundle Adjustment</a> algorithm, features from different images are arranged in 3D space, while at the same time setting the camera position at the time of shooting.  However, there are features.  In all cases, a single <a href="http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_orb/py_orb.html">feature</a> detector is used - <a href="http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_orb/py_orb.html">ORB (Oriented FAST and Rotated BRIEF)</a> .  This is a very fast detector (which makes it possible to achieve real-time without using a GPU), and the resulting ORB descriptors of features with a high degree are invariant to the angle of view, camera rotation and illumination.  This allows the algorithm to track loop closures with high accuracy and reliability, and also provides high reliability during relocalization.  The algorithm ultimately belongs to the class of so-called feature-based.  ORB SLAM builds a sparse map of the area, but it is possible to build a dense map based on images of key frames.  A closer look at the algorithm can be in the <a href="http://webdiis.unizar.es/~raulmur/MurMontielTardosTRO15.pdf">article developers</a> . <br><br><h3>  Launch </h3><br>  We did not describe the installation process of the ORB SLAM in the previous lesson, so we‚Äôll dwell on this here.  In addition to the already installed environment, we will need to install <a href="http://github.com/stevenlovegrove/Pangolin">Pangolin</a> (do not clone the repository in the ROS workspace): <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/stevenlovegrove/Pangolin.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> Pangolin mkdir build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build cmake -DCPP11_NO_BOOST=1 .. make -j</code> </pre><br>  Next, install the ORB SLAM itself (again, you should not clone the sources into the workspace): <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/raulmur/ORB_SLAM2.git ORB_SLAM2 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ORB_SLAM2 chmod +x build.sh ./build.sh</code> </pre><br>  To use the package in ROS, you must add the path to the binaries in ROS_PACKAGE_PATH (replace PATH with the path where you installed ORB SLAM): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ROS_PACKAGE_PATH=<span class="hljs-variable"><span class="hljs-variable">${ROS_PACKAGE_PATH}</span></span>:PATH/ORB_SLAM2/Examples/ROS &gt;&gt; ~/.bashrc <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/.bashrc</code> </pre><br>  Now we need to enter the camera calibration data and the ORB SLAM settings into the settings file itself.  Go to the Examples / Monocular directory and copy the TUM1.yaml file: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> Examples/Monocular cp TUM1.yaml our.yaml</code> </pre><br>  Open the copied file our.yaml and replace the camera calibration parameters with those obtained above, and also set the FPS: <br><br><div class="spoiler">  <b class="spoiler_title">Configuration file</b> <div class="spoiler_text"> <code>%YAML:1.0 <br> <br> #-------------------------------------------------------------------------------------------- <br> # Camera Parameters. Adjust them! <br> #-------------------------------------------------------------------------------------------- <br> <br> # Camera calibration and distortion parameters (OpenCV) <br> Camera.fx: 563.719912 <br> Camera.fy: 569.033809 <br> Camera.cx: 331.711374 <br> Camera.cy: 175.619211 <br> <br> Camera.k1: -0.523746 <br> Camera.k2: 0.306187 <br> Camera.p1: 0.011280 <br> Camera.p2: 0.003937 <br> Camera.k3: 0 <br> <br> # Camera frames per second <br> Camera.fps: 30.0 <br> <br> # Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale) <br> Camera.RGB: 1 <br> <br> #-------------------------------------------------------------------------------------------- <br> # ORB Parameters <br> #-------------------------------------------------------------------------------------------- <br> <br> # ORB Extractor: Number of features per image <br> ORBextractor.nFeatures: 1000 <br> <br> # ORB Extractor: Scale factor between levels in the scale pyramid <br> ORBextractor.scaleFactor: 1.2 <br> <br> # ORB Extractor: Number of levels in the scale pyramid <br> ORBextractor.nLevels: 8 <br> <br> # ORB Extractor: Fast threshold <br> # Image is divided in a grid. At each cell FAST are extracted imposing a minimum response. <br> # Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST <br> # You can lower these values if your images have low contrast <br> ORBextractor.iniThFAST: 20 <br> ORBextractor.minThFAST: 7 <br> <br> #-------------------------------------------------------------------------------------------- <br> # Viewer Parameters <br> #-------------------------------------------------------------------------------------------- <br> Viewer.KeyFrameSize: 0.05 <br> Viewer.KeyFrameLineWidth: 1 <br> Viewer.GraphLineWidth: 0.9 <br> Viewer.PointSize:2 <br> Viewer.CameraSize: 0.08 <br> Viewer.CameraLineWidth: 3 <br> Viewer.ViewpointX: 0 <br> Viewer.ViewpointY: -0.7 <br> Viewer.ViewpointZ: -1.8 <br> Viewer.ViewpointF: 500 <br></code> <br></div></div><br>  Save the file.  Now we can run ORB SLAM (execute three commands in different tabs of the terminal): <br><br><pre> <code class="bash hljs">roscore</code> </pre><br><pre> <code class="bash hljs">rosrun usb_cam usb_cam_node _video_device:=dev/video0 ‚Üê    </code> </pre><br><pre> <code class="bash hljs">rosrun ORB_SLAM2 Mono ../../Vocabulary/ORBvoc.txt our.yaml /camera/image_raw:=/usb_cam/image_raw</code> </pre><br>  If everything went well, then you should see two windows: <br><br><img src="https://habrastorage.org/files/57f/10e/922/57f10e92242d4f38be167197788472fb.png"><br><br>  Move the camera a little in the image plane to initialize the SLAM: <br><br><img src="https://habrastorage.org/files/c14/7a5/468/c147a5468d8c4096b7922e22f8f5c608.png"><br><br>  All this is great, but ORB SLAM was developed as a ROS-independent package.  The binary we run is actually just an example of using the algorithm in ROS.  According to unclear logic, the developers did not include the publication of the trajectory of movement in this example, and only save it as a text file KeyFrameTrajectory.txt after the work is completed.  Although such a publication will take a few lines of code. <br><br><h3>  Settings </h3><br>  The algorithm provides very few parameters for configuration, and they are very accurately described in the startup file, as described above. <br><br><h3>  When to use ORB SLAM? </h3><br>  If you need a fast algorithm that should work, for example, onboard, and the environment does not contain large flat monochromatic objects - then ORB SLAM is perfect for you. <br><br><h2>  LSD SLAM </h2><br><h3>  Principle of operation </h3><br>  We have already briefly touched on the principle of LSD SLAM in the <a href="http://habrahabr.ru/company/singularis/blog/276595/">article on navigation experiences AR.Drone</a> .  A more detailed analysis of the algorithm clearly does not fit into the format of the lesson, you can read about it in the <a href="http://vision.in.tum.de/_media/spezial/bib/engel14eccv.pdf">article of the developers</a> . <br><br><h3>  Launch </h3><br>  After you have installed LSD SLAM (guided by the previous lesson), you need to prepare to start: <br><br><ol><li>  Camera calibration file camera.cfg <br>  Create a camera.cfg file in the ~ / ros_workspace / rosbuild / package / lsd_slam / lsd_slam_core / calib directory <br>  and copy the calibration parameters into the first line of camera.cfg using this sample (note that the fifth distortion parameter is not used): <br><br> <code>fx fy cx cy k1 k2 p1 p2 <br> 640 360 <br> crop <br> 640 480 <br></code> <br>  In the next line, set the width and height of the original image, and leave the last lines unchanged. <br><br></li><li>  Launch file lsd_slam.launch <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">launch</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pkg</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"usb_cam"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"usb_cam_node"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"camera"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">output</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"screen"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"video_device"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/dev/video0"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lsd_slam_node"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"live_slam"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pkg</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lsd_slam_core"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">args</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/image:=usb_cam/image_raw _calib:=$(find lsd_slam_core)/calib/camera.cfg"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">output</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"screen"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"minUseGrad"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"10"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cameraPixelNoise"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KFUsageWeight"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"14"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KFDistWeight"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"14"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"useAffineLightningEstimation"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"True"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"relocalizationTH"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.1"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"useFabMap"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"True"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image_view_node"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pkg</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">args</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image:=usb_cam/image_raw"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">respawn</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">launch</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></li></ol><br><br>  Run LSD SLAM (from the folder with the startup file): <br><br><pre> <code class="bash hljs">roslaunch lsd_slam.launch</code> </pre><br>  If everything worked out, you should see two windows: <br><br><img src="https://habrastorage.org/files/b59/278/207/b59278207d9f4742bc2e29743dde53a1.png"><br><br>  Also launch the point cloud viewer from the LSD SLAM distribution (in another terminal window): <br><br><pre> <code class="bash hljs">rosrun lsd_slam_viewer viewer</code> </pre><br>  The viewer should look something like this: <br><br><img src="https://habrastorage.org/files/cca/351/a83/cca351a8320d40e9bade1a185ec496ac.png"><br><br><h3>  Settings </h3><br><br>  The algorithm provides several parameters for configuration, the most important ones are these: <br><br><ul><li>  <b>minUseGrad</b> is the minimum intensity gradient for creating a new 3D point.  The smaller the value, the better the algorithm works with monochromatic objects and the denser the map.  However, the lower this value, the more clearly the camera rectification errors affect the quality of the SLAM.  In addition, lower values ‚Äã‚Äãsignificantly reduce the performance of the algorithm. </li><li>  <b>cameraPixelNoise</b> - noise of pixel intensity values.  It must be set to a value greater than the actual noise of the matrix in order to take into account the errors of sampling and interpolation. </li><li>  <b>useAffineLightningEstimation</b> - you can try to enable it to fix problems with auto exposure. </li><li>  <b>useFabMap</b> - enables openFabMap to search for loops. </li></ul><br><h3>  Recommendations </h3><br><ol><li>  Run the algorithm on a productive CPU.  Unlike ORB SLAM, LSD SLAM places significant demands on hardware.  In addition, the algorithm must work in real-time, otherwise an acceptable SLAM quality is out of the question. </li><li>  Calibrate the camera as accurately as possible.  Direct methods, which include LSD SLAM, are very sensitive to the quality of calibration. </li><li>  If possible, use the global-shutter camera.  Rolling shutter can be used (in fact, we used only this type of shutter), but the results will be worse. </li></ol><br><h3>  When to use LSD SLAM? </h3><br>  If you need a dense terrain map (for example, to build an obstacle map), or the environment does not contain enough features (features), that is, it includes weakly textured large objects, and your platform provides sufficient computational capabilities, then LSD SLAM will suit you. <br><br><h2>  Feature-based vs.  Direct </h2><br>  Comparing monocular algorithms based on features with the so-called direct algorithms that use the entire image, the creator of LSD SLAM Jacob Engel showed the following table at one of his presentations (our translation): <br><table><caption>  Comparison of Multiple SLAM Algorithms </caption><tbody><tr><th align="center">  Feature-based </th><th align="center">  Direct </th></tr><tr><td>  Use only features (for example, corners) </td><td>  Use full image </td></tr><tr><td>  Faster </td><td>  Slower (but well parallelized) </td></tr><tr><td>  Easy to remove noise (outliers) </td><td>  Not easy to remove noise </td></tr><tr><td>  Resistant to rolling shutter </td><td>  Not resistant to rolling shutter </td></tr><tr><td>  Use a small amount of information from the images </td><td>  Use more complete information </td></tr><tr><td>  Do not require complex initialization </td><td>  Require good initialization </td></tr><tr><td>  over 20 years of intensive development </td><td>  about 4 years of research </td></tr></tbody></table><br>  It's hard to add something. <br><br><h2>  General recommendations for use </h2><br>  All monocular algorithms have a set of similar requirements and limitations, namely: <br><br><ol><li>  The need for accurate camera calibration.  Not so critical for feature-based algorithms. </li><li>  The inability to determine the scale without the help of external sensors or user. </li><li>  Camera requirements: high FPS + wide viewing angle.  These parameters are associated with each other, and with the maximum speed of movement of the camera. </li></ol><br>  Based on these features and our experience in using such algorithms, we conclude that monocular SLAM should be used when: <br><br><ol><li>  You are strictly limited to one camera; </li><li>  You have the opportunity to assess the scale of localization and maps from external sources or to solve your problem the scale does not matter; </li><li>  camera characteristics meet the above requirements and allow for accurate calibration and rectification of the image. </li></ol><br><br>  This concludes today's lesson, next time we will look at SLAM algorithms using stereo cameras and depth cameras. <br><br><h2>  Sources </h2><br>  <a href="http://habrahabr.ru/company/singularis/blog/277109/">Previous lesson - installation and configuration of the environment</a> <br>  <a href="http://vision.in.tum.de/research/vslam/lsdslam">LSD SLAM Developer Site</a> <br>  <a href="http://webdiis.unizar.es/~raulmur/orbslam/">Developer site ORB SLAM</a> </div><p>Source: <a href="https://habr.com/ru/post/277537/">https://habr.com/ru/post/277537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277525/index.html">Bidirectional rendering with diacritics support</a></li>
<li><a href="../277527/index.html">The benefits of big data technology in everyday life</a></li>
<li><a href="../277529/index.html">Fake Novella: a small game, the development of which taught me a lot and another ban from Google</a></li>
<li><a href="../277533/index.html">Creating a user interface for Blend4Web (Part 1)</a></li>
<li><a href="../277535/index.html">Robotic arm control with Intel RealSense cameras</a></li>
<li><a href="../277539/index.html">Yelp, Wunderlist and GIPHY introduced new type applications</a></li>
<li><a href="../277541/index.html">Another approximation by polynomial of a function of several variables</a></li>
<li><a href="../277543/index.html">Clean code architecture and development through testing in PHP</a></li>
<li><a href="../277545/index.html">Game design f2p games or how not to make mistakes</a></li>
<li><a href="../277559/index.html">How Relap.io is organized - a service that issues 30 billion recommendations per month</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>