<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Semantics exactly-once in Apache Kafka</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Yuri Lilekov, I work in Server Team Badoo. The other day I came across a rather interesting article about exactly-once semantics at ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Semantics exactly-once in Apache Kafka</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/97d/253/d74/97d253d74c3f4d95be72eb594fd91f1e.png"></p><br><p>  <em>Hello!</em>  <em>My name is Yuri Lilekov, I work in Server Team Badoo.</em>  <em>The other day I came across a rather interesting article about exactly-once semantics at Apache Kafka, which I gladly translated for you.</em> </p><a name="habracut"></a><br><p>  Finally, it happened that the Kafka community had been waiting for so long: in Apache Kafka <a href="https://kafka.apache.org/downloads">version 0.11</a> , exactly-once semantics appeared (‚Äústrictly one-time delivery‚Äù).  In this post I will tell you about the following points: </p><br><p>  - what is exactly-once semantics in Apache Kafka; <br>  - why this problem is complex; <br>  - how new idempotency and transaction properties allow streaming exactly-once-streaming processing using the Kafka Streams API. </p><br><h3 id="exactly-once--deystvitelno-slozhnaya-problema">  Exactly once - really hard problem </h3><br><p>  I guess what each of you now thought: delivery exactly-once is impossible.  For practical use it is too expensive (or correct me if I am mistaken).  You are not alone in such thoughts.  Some of my colleagues admit that shipping exactly-once is one of the most difficult problems in distributed applications. </p><br><p><img src="https://habrastorage.org/web/801/21e/c10/80121ec10f454ebf98569ffdc7233d9c.png"></p><br><p>  So, someone made it clear that he considers delivery exactly-once with a high probability impossible! </p><br><p><img src="https://habrastorage.org/web/a04/f4a/891/a04f4a891f7e4a6794627f93e50f52ab.png"></p><br><p>  I do not deny that the delivery-exactly-once semantics (and support for stream processing in the same mode) is a really difficult task.  But I also witnessed for more than a year how talented Confluent engineers together with the open-source community worked hard on solving this problem at Apache Kafka.  So let's move on to the overview of message passing semantics. </p><br><h3 id="obzor-semantiki-peredachi-soobscheniy">  An overview of message passing semantics </h3><br><p>  Computers that form a distributed system can always fail, regardless of other system participants.  In the case of Kafka, a separate broker may fail, or a network error may occur, while the producer sends a message to the topic.  And depending on the actions of the producer to handle the failure, you can get different semantics. </p><br><h4 id="semantika-at-least-once-hotya-by-odin-raz">  The semantics at least once ("at least once"). </h4><br><p> If the producer receives confirmation from the broker Kafka, and at the same time <code>acks=all</code> , this means that the message was recorded in the Kafka topic strictly once.  But if the producer does not receive confirmation after the timeout expires or receives an error, he may try to send the message again, considering that it was not recorded in the Kafka topic.  If the broker fails just before sending a confirmation, but after the message has been successfully written to the Kafka topic, this repeated attempt to send will result in the message being written and sent to the final consumer twice.  Everyone will be satisfied with the tirelessness of the dealer, but this approach leads to duplication of work and incorrect results. </p><br><h4 id="semantika-at-most-once-ne-bolee-odnogo-raza">  Semantics at most once ("no more than once"). </h4><br><p>  If the producer does not resend the message after the timeout or receipt of an error, the message may not be recorded in the Kafka topic, and, therefore, it will not be delivered to the consumer.  In most cases, messages will be delivered, but to avoid the possibility of duplication, we assume that sometimes messages do not reach. </p><br><h4 id="semantika-exactly-once-strogo-odnokratnaya-dostavka">  Semantics exactly once (‚Äústrictly one-time delivery‚Äù). </h4><br><p>  Even when the producer again tries to send a message, the message is delivered strictly once.  The semantics of exactly once is the most desirable guarantee, but at the same time the least understood.  The reason is that it requires interaction between the messaging system itself and the application that generates and receives messages.  For example, if after a successful receipt of a message you rewind the Kafka-consumer to the previous position, then again you will receive everything from there to the last message.  This clearly shows why the messaging system and the client application must interact with each other for the exactly-once semantics to work. </p><br><h3 id="sboi-kotorye-nuzhno-obrabatyvat">  Crashes to handle </h3><br><p>  The description of the difficulties of supporting the semantics of exactly-once will begin with a simple example. </p><br><p>  Suppose a single-threaded application-producer sends the message ‚ÄúHello, Kafka‚Äù to a Kafka topic consisting of one section with the name ‚ÄúEoS‚Äù Next, suppose that a single instance of the consumer application at the other end takes data from the topic and displays a message.  If you are lucky and there are no failures, then everything will work fine, and the message ‚ÄúHello, Kafka‚Äù will be recorded once in the section of the ‚ÄúEoS‚Äù topic.  The consumer receives the message, processes it and fixes its position, thereby reporting the completion of processing - and the consumer application will not receive this message again, even in case of its failure and reboot. </p><br><p>  But we all know well that one cannot always count on luck.  As scaling progresses, even the most unlikely failure scenarios occur periodically. </p><br><ol><li><p>  <strong>Broker failure.</strong>  Kafka is a highly available, stable and reliable system in which every message recorded in a section is saved and replicated n-th times.  Therefore, Kafka can withstand n-1 broker failures, which means that the section is available as long as at least one broker is available.  The Kafka replication protocol ensures that if the message was once successfully written to the master replica, it will be replicated to all available replicas. </p><br></li><li><p>  <strong>Crash RPC "producer broker"</strong> .  The sustainability of Kafka depends on the producer, who receives confirmation from the broker.  Failure to receive confirmation does not necessarily mean failure of the request itself.  The broker may ‚Äúfall‚Äù after the message is recorded, but before the confirmation is sent to the producer.  He can also "fall" before writing a message to the topic.  Since the producer has nowhere to know the cause of the failure, he is forced to assume that the message was not successfully recorded, and will make another attempt.  In some cases, this will lead to duplication of the message in the Kafka section log, and the end user will receive this message more than once. </p><br></li><li>  <strong>Client failure</strong> .  When delivered exactly-once, the likelihood of customer failure must also be considered.  But how can we know that this is a client failure, and not just a temporary separation from a broker or an application pause?  It is necessary to reliably distinguish between permanent failure and temporary.  In theory, the broker should discard messages from the zombie producer.  The same applies to the consumer: as soon as a new client instance appears, it should be able to recover from any state in which the failed instance was and begin processing from the right place.  This means that the resulting positions must always be synchronized with the generated data. </li></ol><br><h3 id="obyasnenie-semantiki-exactly-once-v-apache-kafka">  Explanation of exactly-once semantics in Apache Kafka </h3><br><p>  Prior to version 0.11.x, Apache Kafka supported for each section the semantics of delivery at least once and delivery with preservation of order.  As can be seen from the above example, this means that repeated attempts to send a message by the producer could lead to its duplication.  In the new semantics of exactly-once, we strengthened the semantics of Kafka data processing in three different but interrelated ways. </p><br><h4 id="idempotentnost-semantika-exactly-once-s-sohraneniem-poryadka-dostavki-dlya-kazhdogo-razdela">  Idempotency: exactly-once semantics with preservation of the delivery order for each section </h4><br><p>  <em>An idempotent</em> operation is an operation that, when executed multiple times, produces the same result as a single operation.  The send operation by the producer is now idempotent.  In case of an error, forcing the producer to try again, the message that was repeatedly sent by the producer will be recorded once in the Kafka broker log.  With respect to a single section, idempotent producer sending operations save us from the possibility of duplicate messages due to producer or broker errors. </p><br><p>  To enable this function and get the semantics exactly-once for each section (that is, no duplication, no data loss and preservation of the delivery order), simply set <code>enable.idempotence=true</code> in the settings of the producer. </p><br><p>  So how does this feature work?  ‚ÄúUnder the hood,‚Äù it works similarly to the TCP: each message packet sent to Kafka will contain a sequence number with which the broker will be able to eliminate data duplication.  But unlike TCP, which is guaranteed to perform deduplication only in the conditions of a temporary connection in memory, the sequence number is stored in the replicated log.  Therefore, even in the event of a master replica failure, any broker that assumes this role also recognizes whether the newly submitted data is a duplicate. </p><br><p>  The overhead of this approach is relatively small: only a few additional numeric fields for each batch of messages.  Further you will see that this feature very slightly reduces performance compared to the non-idempotent producer. </p><br><h4 id="tranzakcii-atomarnye-zapisi-v-neskolkih-razdelah">  Transactions: Atomic Records in Multiple Sections </h4><br><p>  Kafka now supports atomic notation in several sections using new transactional APIs.  This allows the producer to send message packets in several sections so that either all messages from the package will be visible to any consumer, or none of them will be visible to anyone.  This function also allows you to shift the consumer in one transaction with the data that you have processed, and, therefore, makes possible the through-semantics of exactly-once.  Here is a snippet with sample code that demonstrates the use of the transactional API: </p><br><pre> <code class="hljs swift">producer.initTransactions(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { producer.beginTransaction(); producer.send(record1); producer.send(record2); producer.commitTransaction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">ProducerFencedException</span></span> e) { producer.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">KafkaException</span></span> e) { producer.abortTransaction(); }</code> </pre> <br><p>  This example shows how you can use the new Producer API to send atomic messages to a set of topic sections.  It is worth noting that the Kafka topic section can simultaneously contain messages, both being part of a transaction and not being. </p><br><p>  Therefore, from the consumer‚Äôs point of view, there are two ways to read transactional messages expressed through the <code>isolation level</code> ‚Äî the consumer‚Äôs setting: </p><br><ol><li><p>  <code>read_committed</code> : in addition to reading messages that are not part of a transaction, it is possible to read those that are part of a transaction after the transaction commit. </p><br></li><li>  <code>read_uncommitted</code> : all messages are read in offset order without waiting for a transaction commit;  This option is similar to the existing semantics of Kafka-consumer. </li></ol><br><p>  To use a transaction, you need to configure the consumer to set the required <code>isolation level</code> , use the new Producer API and set the producer configuration parameter Transactional ID as some unique ID (it is needed to ensure the continuity of the transaction state when the application restarts). </p><br><h4 id="to-chto-nuzhno-potokovaya-exactly-once-obrabotka-v-apache-kafka">  What you need: streaming Exactly-once-processing in Apache Kafka </h4><br><p>  Thanks to the Streams API in Apache Kafka, streaming exactly-once processing is now available based on idempotency and atomicity.  In order for your streaming application to use this semantics, it is enough to specify <code>processing.guarantee=exactly_once</code> in the configuration.  As a result, all processing will be performed strictly once.  This applies both to the processing and to the recreated state created by the data processing task and recorded back to Kafka. </p><br><p>  <em>‚ÄúThat's why the exactly-once-guarantee guarantees provided by the Streams API at Kafka are the strongest among all the guarantees offered today by streaming processing systems.</em>  <em>It provides end-to-end exactly-once-guarantees for a streaming processing application, starting from reading data from Kafka, from any state recreated in Kafka by a streaming application, before writing to Kafka the final result.</em>  <em>Stream processing systems, in which support for recreated states relies only on external data systems, weaken the guarantees of streaming exactly-once-processing.</em>  <em>Even when they use Kafka as a source for processing and need to recover from a failure, they can only switch their Kafka positions for overconsumption and message processing.</em>  <em>But they cannot roll back the associated state in the external system, which leads to incorrect results in the case of non-idempotency of the state update. ‚Äù</em> </p><br><p>  Let me add some more details.  We usually care if the streaming application receives the correct response, even if one of the instances drops during processing.  The right decision when restoring a failed instance is to continue processing in the same state as before the failure. </p><br><p>  So, stream processing is a simple ‚Äúread-process-write‚Äù operation in the Kafka topic.  The consumer reads the message from the topic, the processing logic converts them, or changes the state maintained by the processor, and the producer writes the result to another Kafka topic.  Streaming exactly-once-processing is simply the ability to perform a single-read-process-write operation once.  In this situation, getting the correct answer means just not to miss any incoming message or not to duplicate the output data.  And this is exactly the mode of operation that consumers expect from a streaming exactly-once-processor. </p><br><p>  In addition to the considered simplest failure scenario, there are many others. <br>  A stream handler can take input from several source topics, the order of which differs with multiple runs.  Therefore, if you restart your streaming handler, which took data from several source topics, you can get other results. <br>  A streaming handler can send output to several target topics.  If a producer cannot perform atomic recording in several topics, then its output may be incorrect in case of failure of recording in some (not all) sections. </p><br><p>  The stream handler can aggregate or combine multiple input data using the state management tools provided by the Streams API.  If one of the stream handler instances fails, then you should be able to roll back to the state recreated by this stream handler instance.  When you restart an instance, you also need to be able to continue processing and recreate its state. </p><br><p>  The stream processor can search for more complete information in an external database or by accessing the service updated from the outside.  The dependency on the external service makes the stream handler completely non-deterministic.  If an external service changes its internal state between two launches, it will lead to incorrect transfer of results.  But with proper processing, this should not be the reason for getting completely wrong results - just the output of the stream processor will be related to the valid output. </p><br><p>  Failure and restart, especially in combination with non-deterministic operations and changes in the persistent state, calculated by the application, can lead not only to duplication, but also to incorrect results.  For example, if the number of events seen is calculated at one processing stage, then duplication can lead to an incorrect calculation at the next stage.  Therefore, we need to determine the meaning of the phrase "stream exactly-once-processing." </p><br><p>  This also applies to the consumption from the topic, and to recreating the intermediate state in the Kafka topic and sending it to it.  Not all possible calculations in the message are performed using the Streams API, some of them (for example, depending on external service or consumption from several source topics) are basically non-deterministic. </p><br><p>  <em>‚ÄúWith regard to streaming exactly-once-processing guarantees for deterministic operations, you need to make sure that the output of the read-process-write operation will be the same as if the stream processor saw each message strictly once ‚Äî as if uninterruptedly working.‚Äù</em> </p><br><h4 id="stop-tak-chem-zhe-vsyo-taki-yavlyaetsya-potokovaya-exactly-once-obrabotka-dlya-nedeterminirovannyh-operaciy">  Stop, so what exactly is streaming exactly-once-processing for non-deterministic operations? </h4><br><p>  All this makes sense for deterministic operations, but what does streaming exactly-once processing mean when the processing logic itself is non-deterministic?  Suppose that the same streaming handler, counting the number of incoming events, will be modified to count only those events that satisfy the conditions dictated by the external service.  This operation is non-deterministic in nature, since external conditions can vary from launch to launch of a streaming handler, potentially leading to different results.  So how do we understand streaming-exactly-once-processing guarantees for such operations? </p><br><p>  <em>"With regard to streaming exactly-once-processing guarantees for non-deterministic operations, you need to make sure that the output of the read-process-write operation belongs to a subset of the valid output data generated by the combination of valid non-deterministic input data."</em> </p><br><p>  So, in our example of a streaming handler, with the current value of the counter 31 and the value of the incoming event 2, only 31 or 33: 31 can be valid output data if the input event is rejected as indicated by external conditions, and 33 if it is not rejected. </p><br><p>  This article only superficially deals with streaming exactly-once-processing in the Streams API.  In the next post on this topic will be described in more detail about the guarantees, as well as a comparison of the guarantees exactly-once in other systems of stream processing. </p><br><h3 id="garantii-exactly-once-v-kafka-deystvitelno-li-oni-rabotayut">  Guarantees exactly once in Kafka: do they really work? </h3><br><p>  Any major work like this always raises the question ‚ÄúDoes this feature work as promised?‚Äù To answer it, let's consider its correctness (as we designed, built and tested this feature) and performance. </p><br><h4 id="skrupuleznyy-dizayn-i-process-proverki">  Scrupulous design and verification process </h4><br><p>  Correctness and performance start with a reliable architecture.  We started working on it and prototypes about three years ago on LinkedIn.  We also did this for more than a year at Confluent, trying to find an elegant way to bring idempotency and transactional requirements into a complete package.  We have compiled a <a href="https://docs.google.com/document/d/11Jqy_GjUGtdXJK94XGsEIK7CP1SnQGdp2eF0wSw9ra8/edit">60-page description</a> covering all aspects of the architecture, ranging from high-level messaging to the routine details of the implementation of each data structure and RPC.  This process has been going on for nine months under the scrutiny of the public, during which time the architecture has greatly improved thanks to community feedback. </p><br><p>  For example, thanks to the open-source discussion, we have replaced the buffering of transactional readings on the part of the consumer with smarter filtering in the server part, thus avoiding possible large performance problems.  We also improved the interaction of transactions with compressed topics and expanded security capabilities. </p><br><p>  As a result, we have come to a simple architecture, which is largely based on the reliable Kafka primitives. </p><br><ol><li>  Our transaction log is a Kafka topic with corresponding guarantees of stability. </li><li>  Our new <em>transaction coordinator</em> (who manages the state of transactions for the producer) works in a broker and, of course, uses a leader selection algorithm to handle failures. </li><li>  For streaming applications created using the Kafka Streams API, we took advantage of the fact that Kafka topics are the ‚Äúsource of truth‚Äù for storing states and inbound positions.  Therefore, we were able to ‚Äútransparently‚Äù put this data into transactions, which are atomically written into several sections, which means that within the framework of the operations ‚Äúread-process-write‚Äù we provided guarantees exactly-once for the streams. </li></ol><br><p>  ,                  . </p><br><h4 id="iterativnyy-process-razrabotki">    </h4><br><p>       ,         .            .          ,      . </p><br><p>      15 000  ,         ,            .     :          NTP-    .      :    Kafka    ,   ,        ¬´¬ª       ,  ,       . </p><br><p>          ,   ,       . </p><br><h4 id="horoshaya-novost-kafka-ostalsya-takim-zhe-bystrym">  : Kafka    ! </h4><br><p>        ;  ,       exactly-once       -  ,        .        ,   .       ,        (~1            ).       .     ,  100 ,     : </p><br><p> 3%     ,      (in-order)  at least once ( <code>acks=all, max.in.flight.requests.per.connection=1</code> ), <br>  20%     ,     at most once     ( <code>acks=1, max.in.flight.requests.per.connection=5</code> ),   . </p><br><p>       exactly-once      . ,      <a href="https://issues.apache.org/jira/browse/KAFKA-5494">KAFKA-5494</a> ,    ,               ,   at most once    .   ,         .   ,  <a href="https://docs.google.com/spreadsheets/d/1dHY6M7qCiX-NFvsgvaE0YoVdNq26uA8608XIh_DUpI4/edit">  </a> ,     . </p><br><p>         ,       ,    exactly-once.         Kafka   exactly-once,      Kafka,            .  ,                 .      . ,      10         35% .      <a href="https://docs.google.com/spreadsheets/d/1dHY6M7qCiX-NFvsgvaE0YoVdNq26uA8608XIh_DUpI4/edit"></a> Kafka  ,  / :      20%      50% ‚Äì . <strong>      Kafka 0.11,       exactly-once.</strong> </p><br><p>        exactly-once    Streams API.      100  (      )     15% ( )  30% ( ).       30           1   .        ,           .          . </p><br><p> ,      ,             ,  Kafka   .    ‚Äì       exactly-once    Apache Kafka.  ,     exactly-once,            .             Apache Kafka. </p><br><h3 id="eto-chto-volshebnaya-pyl-kotoruyu-ya-mogu-raspylit-na-svoyo-prilozhenie">  ,  ,       ? </h3><br><p> ,  .   exactly-once ‚Äì   ,      ,     .     API,  ,            ,     . </p><br><p>      .    ‚Äì  ,     ,        ,         .        .         Kafka.         exactly-once . </p><br><h3 id="dopolnitelnye-resursy">  Additional resources </h3><br><p>           ,   exactly-once-  Apache Kafka 0.11,   ,     . </p><br><p>       exactly-once,    <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98%2B-%2BExactly%2BOnce%2BDelivery%2Band%2BTransactional%2BMessaging">KIP-98</a> ,     ,  <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-129:%2BStreams%2BExactly-Once%2BSemantics">KIP-129</a> ,     exactly-once .         ,     <a href="https://docs.google.com/document/d/11Jqy_GjUGtdXJK94XGsEIK7CP1SnQGdp2eF0wSw9ra8/edit">-</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333046/">https://habr.com/ru/post/333046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333034/index.html">Upsource 2017.2 released with support for external code inspections, Python, NPM, and more</a></li>
<li><a href="../333036/index.html">Yubikey 4 - purchase, delivery and receipt</a></li>
<li><a href="../333038/index.html">Experience Tutu.ru: how the schedule of trains</a></li>
<li><a href="../333040/index.html">WPF and Box2D. How I did physics with WPF</a></li>
<li><a href="../333042/index.html">Neuro Theater: ITMO University technologies help to create the ‚Äúart of new media‚Äù</a></li>
<li><a href="../333056/index.html">How I created a printer installation system at work</a></li>
<li><a href="../333132/index.html">Information Security Europe: trends in the global information security market that you will not read about from Gartner</a></li>
<li><a href="../333274/index.html">With the new (IT) "year" you, friends</a></li>
<li><a href="../333336/index.html">What is Display Rate and how does it affect the revenue of your application?</a></li>
<li><a href="../333338/index.html">Which firewall is the best? Leaders among UTM and Enterprise Firewalls (Gartner 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>