<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Man in the middle" using revoked certificates. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our previous article described the basic mechanisms for checking the status of certificates (checking whether a certificate has been revoked). In this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Man in the middle" using revoked certificates. Part 2</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/4c5/cad/041/4c5cad0410714528a64da31d0307f389.jpg"></div><br>  Our <a href="https://habrahabr.ru/company/neobit/blog/325490/">previous article</a> described the basic mechanisms for checking the status of certificates (checking whether a certificate has been revoked).  In this article we will answer the following questions: <br><br>  1. How are certificate status verification mechanisms implemented in modern Web browsers? <br>  2. <s>Who is to blame?</s>  Why are they implemented that way? <br>  3. <s>What to do</s> ?  What are the prospects? <br><br>  This article will be useful to those who are interested in understanding the mechanisms used in practice for checking the status of certificates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On Habr√© already wrote on this topic (for example, <a href="https://habrahabr.ru/post/332730/">here</a> and <a href="https://habrahabr.ru/company/eset/blog/220003/">here</a> ), we in this article decided to give an even more detailed description of the checks performed by modern browsers, more relevant information about their settings, and, finally, a description of how you can fix the current situation in the future. <br><a name="habracut"></a><br><h2>  <b>Certificate status checks implemented in Web browsers</b> </h2><br>  The mechanisms for checking the status of certificates implemented in modern Web browsers are a combination of the <a href="https://habrahabr.ru/company/neobit/blog/325490/">previously</a> described basic mechanisms (CRL, OCSP, OCSP stapling) and their modifications.  The combination of basic mechanisms is carried out to ensure redundancy: if one of the sources of information about the status of a certificate becomes unavailable, then a backup one is used.  For example, OCSP may be used as the main mechanism for checking the status of certificates, but if the OCSP server is unavailable or the server fails, the CRL loading for the client will be more time-consuming. <br><br>  To understand the basic problem of checking the status of certificates implemented in modern browsers, it suffices to consider the following <a href="https://www.anti-malware.ru/analytics/Threats_Analysis/man-in-the-middle-attack">man-in-the-middle attack</a> scenario. <br><br><img align="left" src="https://habrastorage.org/web/4e8/835/5d2/4e88355d21f04cc1967af5ec3359a146.jpg"><br><br>  The server's private key has been compromised.  The server owner revoked the compromised key certificate, generated a new key pair and received a new certificate. <br>  The intruder seized the revoked private key and server certificate.  In this scenario, we deliberately do not say how he accomplished this: as a result of the compromise of the server itself or as a result of the compromise of the certification center (CA).  This is done to demonstrate how browsers behave in both situations. <br><br>  The intruder, the ‚Äúman in the middle‚Äù, controls all traffic coming from the client.  He may intercept or block this traffic, may attempt to respond to the client on behalf of other network services. <br><br>  The client‚Äôs web browser, when attempting to establish a TLS connection with the server, connects to the ‚Äúman in the middle‚Äù.  "Man in the middle" is presented by the server using a revoked certificate without an attached OCSP response (aka <a href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP stapling</a> ).  The intruder blocks requests from the client to all OCSP servers and CRL distribution points (aka <a href="https://ru.wikipedia.org/wiki/CDP">CDP</a> ).  The intruder also blocks the client‚Äôs attempts to update the Web browser or its components (for example, the black lists of ‚ÄúCRLSets‚Äù or ‚ÄúOneCRL‚Äù, which will be discussed later). <br><br>  Man-in-the-middle blocking of requests to all OCSP servers and CRL distribution points, firstly, supports the initial condition according to which an intruder could compromise both the server and the CA, and, secondly, most fully demonstrates certificate status checks, performed by modern browsers. <br><br>  The following is a description of the status checks for certificates performed by various Windows web browsers.  For other platforms, details of checks may vary slightly. <br><br><h3>  <b><i>Mozilla firefox</i></b> </h3><br>  The behavior of Mozilla Firefox version 54 (the most relevant at the time of this writing) for such an attack differs depending on the type of server certificate: DV or EV.  By issuing a DV-certificate (domain validated), CA only confirms that the owner of the key specified in the certificate controls the domain specified in the certificate.  Most certifications are DV.  EV certificate (extended validation) confirms not only the domain ownership, but also the identity of the domain owner.  Such certificates require additional checks from the CA, because they are much more expensive and less common. <br><br>  Checking the status of DV certificates performed by Firefox is described in the following diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d72/250/9bc/d722509bc3be4c0cb910180e9bd54b69.jpg"></div><br><br>  The scheme for simplicity does not show the interaction with the cache of previously received OCSP responses, because we assume that they either do not exist (because of an attack or because the server is accessed for the first time in quite a long time), or they are outdated and talk about That the certificate is not revoked.  In the second case, the browser behavior is trivial: the connection will be allowed. <br><br>  So, the browser checks the status of the server certificate chain (intermediate CA certificates and the server certificate itself).  To check the status of intermediate CA certificates, use the OneCRL blacklist stored locally on the client, containing information about revoked certificates collected from various CRL distribution points.  The status of the blacklist is maintained using the CRL aggregator, a separate remote service that works as follows: <br><br>  <b>1.</b> The aggregator periodically polls a certain set of CRL distribution points. <br>  <b>2.</b> From the received CRLs, selects the most critical information about revoked certificates (for example, certificates revoked due to the compromised private key). <br>  <b>3.</b> Updates based on this information to blacklists in browsers. <br><br>  The CRL aggregator and, as a result, the contents of the OneCRL blacklist is controlled by Mozilla.  ‚ÄúOneCRL‚Äù does not cover all revoked certificates, but only certificates of some intermediate CAs and a small number of server certificates.  This is done to reduce the size of the black list.  The current list of ‚ÄúOneCRL‚Äù can be found <a href="https://crt.sh/mozilla-onecrl">here</a> . <br><br>  To check the status of the server certificate, information obtained from ‚ÄúOneCRL‚Äù, attached OCSP responses or responses obtained as a result of an OCSP request is used.  The diagram shows the check of the presence of the attached OCSP response for the server certificate only, because Firefox does not support the attached OCSP responses for intermediate CA certificates ( <a href="https://tools.ietf.org/html/rfc6961">RFC 6961</a> ). <br><br>  It is important that if none of the sources of information on the status of the certificate is available, then the certificate is <b>not considered revoked</b> .  In other words, the test is performed in <b>soft fail</b> mode.  Thus, the attack "man in the middle" is successful.  It does not matter whose key was compromised initially, the key of the server itself or the CA. <br><br>  In addition, it is worth noting that the client-side of the OCSP protocol, implemented in Firefox, does not support one-time random codes (nonce) and, therefore, OCSP responses are not protected against replay attacks. <br><br>  A similar situation arises when checking EV certificates.  The only difference is that the browser additionally performs OCSP requests for intermediate CA certificates: <br><br><img align="left" src="https://habrastorage.org/web/11e/1bf/640/11e1bf6400a4426fb7ea344607439e2d.jpg"><br><br>  You can change the browser behavior and enable the <b>hard fail</b> mode (i.e., prohibiting the establishment of a TLS connection in cases where certificate status information is not available) by setting the "security.OCSP.require" option in the browser settings ("about: config") to true: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9c2/057/122/9c20571223944460801abcc6d84b279e.jpg"></div><br><br>  It should be noted that this setting does not activate the use of the OCSP protocol for intermediate CA certificates in cases where the server presents a DV certificate. <br><br>  For the end user, <b>hard fail</b> in Firefox looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f6c/2e1/ca1/f6c2e1ca12af42ffa560188b037a4507.jpg"></div><br><br>  Note that the man-in-the-middle attack is still possible! .. The intruder is required to conduct an OCSP replay replay attack, sending the old OCSP response generated before the certificate was revoked.  However, this attack can only be carried out until the ‚Äúold‚Äù OCSP response expires.  At the same time, the OCSP response can be quite long.  Often it is equal to a week. <br><br><h3>  <b><i>Microsoft Internet Explorer / Edge</i></b> </h3><br>  Microsoft Internet Explorer version 11 and Microsoft Edge version 40 browsers behave the same for DV and EV certificates: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/322/e71/cc9/322e71cc9c7f4e23bf9dc93ad2627446.jpg"></div><br><br>  In the scheme, as before, for simplicity, the interaction with the cache of previously received OCSP responses and CRLs is not shown, although a <a href="https://windoh.wordpress.com/2011/04/23/crl-caching-in-windows-and-a-little-bit-about-ocsp-caching-too/">separate article</a> can be devoted to this. <br><br>  For each checked certificate in the chain in the absence of attached OCSP responses, an OCSP request is executed.  At the same time, Internet Explorer and Edge do not support attached OCSP responses for intermediate CA certificates ( <a href="https://tools.ietf.org/html/rfc6961">RFC 6961</a> ) and do not protect OCSP responses from replay attacks.  If the OCSP server is not available, then an attempt is made to load the CRL. <br><br>  The check is also performed in <b>soft fail</b> mode.  Thus, the man-in-the-middle attack is also successful and it also does not matter whose key was compromised initially, the key of the server itself or the CA. <br><br>  You can change the behavior of Internet Explorer, for example, by setting the registry key value <i>"HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Internet Explorer \ Main \ FeatureControl \ FEATURE_WARN_ON_SEC_CERT_REV_FAILED \ iexplore.exe"</i> to 1. Then, if there is no information about the certificate status, the connection will still be allowed, however A small warning will appear in the address bar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/735/750/76a/73575076a8764881870828b272034408.jpg"></div><br><br>  For Edge, no such settings were found. <br><br><h3>  <b><i>Google Chrome / Cromium</i></b> </h3><br>  Google Chrome and Chromium version 59 browsers behave as follows when checking DV certificates: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/5ce/dd6/35a/5cedd635a8bb4375b56893d53bb9a5b8.jpg"></div><br><br>  The checks performed by Chrome are similar to those performed by Firefox, with the exception that Chrome refused to perform OCSP requests when checking DV certificates.  ‚ÄúCRLSets‚Äù in Chrome is similar to ‚ÄúOneCRL‚Äù in Firefox (strictly speaking, the ‚ÄúCRLSets‚Äù mechanism appeared even earlier) and has the same problems of incompleteness and lack of control to the end user. <br><br>  OCSP requests are used when checking EV certificates (here the picture becomes almost identical to what we observed for Firefox): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2c6/8ef/35d/2c68ef35d85843a08b18c51df3bc17a1.jpg"></div><br><br>  Like other browsers, Chrome and Chromium operate in <b>soft fail</b> mode.  Attached OCSP responses for intermediate CA certificates ( <a href="https://tools.ietf.org/html/rfc6961">RFC 6961</a> ) and protection of OCSP responses against replay attacks are not supported. <br><br>  You can change the behavior of Chrome and Chromium by making changes to the group policy ( <a href="https://www.chromium.org/administrators/windows-quick-start">instructions here</a> ) and by including the following options: <br><br><img src="https://habrastorage.org/web/527/305/5aa/5273055aa944471bacc9c99386a26a65.jpg"><br><br>  Equivalent tuning is possible under Linux ( <a href="http://dev.chromium.org/administrators/linux-quick-start">here</a> ). <br><br>  After making these changes, Chrome and Chromium will perform checks similar to those done by Internet Explorer (in the absence of attached OCSP responses, they will start performing OCSP requests with a rollback to downloading the CRL for the entire certificate chain), but in <b>hard ail</b> mode, i.e. ., if OCSP servers and CRL distribution points are unavailable, the connection will be prohibited: <br><br><img src="https://habrastorage.org/web/d2f/09e/66a/d2f09e66a1e2428a88d800a2f651722e.jpg"><br><br>  It should be noted once again that the ‚Äúman in the middle‚Äù attack is still possible.  The intruder is required to block the OCSP and carry out the CRL replay attack, sending the ‚Äúold‚Äù CRL generated before the certificate was revoked.  However, this attack can only be carried out until the ‚Äúold‚Äù CRL expires.  In this case, the validity of the CRL can be quite long.  For example, the CRL for a ‚Äúwww.google.com‚Äù certificate is valid for a week. <br><br><h3>  <b><i>Other browsers and platforms</i></b> </h3><br>  For other popular browsers and platforms, the situation is the same: everywhere certificates status checks are performed in <b>soft fail</b> mode, or not at all.  You can read more <a href="https://habrahabr.ru/company/eset/blog/220003/">here</a> or <a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Defective-By-Design----Certificate-Revocation-Behavior-In-Modern-Browsers/">here</a> . <br><br><h2>  <b>Why now everything works that way?</b> </h2><br>  This is well written <a href="https://www.imperialviolet.org/2014/04/19/revchecking.html">in the blog of Adam Langley</a> .  The absence of <b>hard fail</b> and the rejection of the explicit execution of OCSP requests on the client side are due to the following factors: <br><br><ul><li>  CA infrastructure will be a single point of failure.  The inaccessibility of the OCSP server can cause a denial of service to a whole segment of the Internet.  CA infrastructure becomes a new target for DDoS; </li><li>  Increased cost of the support center infrastructure.  CA is required to buy channels with greater bandwidth and provide protection against DDoS; </li><li> reduced reliability of TLS connections in unstable or noisy networks (for example, mobile networks); </li><li>  The volume of traffic is increased and a large bandwidth is required, which is critical, again, for mobile clients; </li><li>  problems using OCSP together with a captive portal.  Passwords are usually transmitted over TLS, however, a TLS connection cannot be established and authenticated until answers are received from OCSP servers.  You can't send OCSP requests, because OCSP servers (at least for intermediate CA certificates) are usually on the Internet, and there is no access to them at this stage.  This problem can be solved with the help of attached OCSP responses, but checking the status of intermediate certificates currently still requires sending OCSP requests, since no browser supports attached OCSP responses for intermediate CA certificates ( <a href="https://tools.ietf.org/html/rfc6961">RFC 6961</a> ). </li></ul><br>  In this case, a complete rejection of the explicit execution of OCSP requests on the client side does not occur, since it can still protect from the ‚Äúman in the middle‚Äù in cases when it is ‚Äúclose‚Äù to the server ‚Äúfar‚Äù from the client, i.e. Access to TLS traffic, but cannot block OCSP: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9c2/8c7/984/9c28c7984736424aa5cd7b6c70a5b601.jpg"></div><br><br><h2>  <b>What are the prospects?</b> </h2><br>  The obvious conclusion from all of the above: the status checks for the certificates in browsers do not work, and this is not news.  At the same time, it is simply impossible to take and go to <b>hard fail</b> for objective reasons. <br><br>  Is there a practical solution to this problem?  After analyzing and putting together many of the already proposed partial solutions to this problem (in particular, the extension of TLS feature certificates, short-term certificates, CRL aggregators, etc., which will be described in detail below), we bring to your attention our idea of ‚Äã‚Äãhow verification of the status of certificates should occur in practice. <br><br>  The basis is the assertion that not all services require online verification of the status of certificates.  For most services, the overhead associated with ensuring strict online status checks for certificates in <b>hard fail</b> mode does not pay back the risks associated with a man-in-the-middle attack using revoked certificates.  In other words, in terms of checking the status of certificates, services are divided into two types: <br><br>  <b>1. The</b> minority for which strict online status checks of certificates in <b>hard fail</b> mode will be carried out. <br>  <b>2. The</b> majority for which online status checks of certificates will not be performed at all (other protection measures will be taken). <br><br>  Browsers can distinguish such services by the presence of a special extension in the server certificate.  Depending on the type of service, the client will either perform a ‚Äúparanoid‚Äù verification of the status of certificates, or will not perform it at all.  Now more about each of these two schemes. <br><br><h3>  <b><i>The paranoid scheme of checking the status of certificates for a minority</i></b> </h3><br>  In 2015, the specification of the new X.509 standard certificate extension, called the <a href="https://tools.ietf.org/html/rfc7633">‚ÄúTLS feature‚Äù</a> (in the early stages of the development of the standard also known as ‚ÄúOCSP must staple‚Äù), was published.  This certificate extension allows you to capture in the certificate those TLS protocol options that the TLS server that presents this certificate will support.  Such an option of the TLS protocol in particular is the attached OCSP responses.  An example of a certificate with this extension is schematically shown below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d24/684/2d4/d246842d42a7441ca42b79dc0156994a.jpg"></div><br><br>  The certificate has an extension ‚ÄúTLS Feature‚Äù (highlighted in red), indicating that the TLS server must support the attached OCSP responses specified in <a href="https://tools.ietf.org/html/rfc6066">RFC 6066</a> (‚ÄúStatus Request (Version 1)‚Äù), and a newer version of this option ( ‚ÄúStatus Request (Version 2)‚Äù), as specified in <a href="https://tools.ietf.org/html/rfc6961">RFC 6961</a> ‚Äî multiple attached OCSP responses.  The new version of this TLS protocol option allows you to attach OCSP responses for intermediate TC certificates. <br><br>  For example, if, when connecting a client that supports the ‚ÄúStatus Request (Version 1)‚Äù option, the server ‚Äúwww.example.com‚Äù together with its certificate shown in the figure above did not send the message ‚ÄúClientHello‚Äù of the handshake protocol attached OCSP response version 1, then the TLS connection setup is terminated with an error.  Thus, a ‚Äúman in the middle‚Äù using a revoked certificate of this kind will not be able to discard the attached OCSP response indicating that this certificate has been revoked. <br><br>  Since we are building a ‚Äúparanoid‚Äù certificate status verification scheme, in addition to using certificates with the ‚ÄúTLS Feature‚Äù extension, the following should also be noted: <br><br>  <b>1.</b> Attached OCSP responses should be protected from replay attacks (random one-time codes should be used).  Even when using certificates with such an extension, the offender has a window for attack, determined by the OCSP response time: it is still possible to carry out a replay attack and send the old OCSP response received before the certificate was revoked. <br>  <b>2. The</b> ‚ÄúStatus Request (Version 2)‚Äù option should be used.  This option allows you to attach OCSP responses for all certificates in a chain, not just for a server certificate.  This allows you to completely abandon the explicit execution of OCSP requests on the client side and all its inherent and previously described shortcomings. <br><br>  So, in the end, the ‚Äúparanoid‚Äù scheme for checking the status of certificates is based on the following: <br><br><ul><li>  The TLS server uses a certificate with the ‚ÄúTLS Feature‚Äù extension, which requires the server to support the TLS ‚ÄúStatus Request (Version 1)‚Äù and ‚ÄúStatus Request (Version 2)‚Äù options; </li><li>  TLS-client and TLS-server should use attached OCSP-responses protected by random one-time codes from replay attacks; </li><li>  if the TLS client supports the ‚ÄúStatus Request (Version 1)‚Äù option, but does not support the ‚ÄúStatus Request (Version 2)‚Äù option, having received a certificate with the ‚ÄúTLS Feature‚Äù extension from the server, it must explicitly perform OCSP requests (using random one-time codes) for intermediate CA certificates in <b>hard fail</b> mode. </li></ul><br>  With all this, this verification scheme, as already mentioned, will have the following disadvantages: <br><br><ul><li>  increasing the load on the OCSP servers of the TC; </li><li>  vulnerability to DDoS attacks on servers TC. </li></ul><br>  The solution to the first problem can be the resumption of TLS connections using the <a href="https://tools.ietf.org/html/rfc5246">session ID</a> or <a href="https://tools.ietf.org/html/rfc5077">session ticket</a> mechanisms.  These mechanisms are protected from the considered man-in-the-middle attack and allow you to resume a previously established TLS connection without sending certificates and, accordingly, without executing requests to the OCSP servers of the CA.  With this approach, reducing the load on OCSP servers will occur at the cost of storing additional information necessary to resume the connection on the client and the server (or only the client). <br><br>  As a solution to the second problem on the server, you can alternately use several certificates issued by independent CAs.  In this case, while the OCSP servers of one CA will be ‚Äúlying‚Äù due to DDoS, the TLS server will use an alternative certificate issued by another CA that is not under attack.  Using multiple certificates will also allow you to balance the load between CAs. <br><br>  In order to assess how the client side (under Windows) is ready for a transition to a bright future, you can look at the following table: <br><br><img src="https://habrastorage.org/web/bf5/fd5/92a/bf5fd592a31b4941a8ef4c6222785b76.jpg"><br><br><h3>  <b><i>Scheme for most</i></b> </h3><br>  As mentioned earlier, for most services, the overhead associated with ensuring strict online checks on the status of certificates in <b>hard fail</b> mode does not pay back the risks associated with the man-in-the-middle attack using revoked certificates.  In this case, it is better not to defend against this attack, but to minimize the time interval during which this attack will be possible.  For this purpose, certificates with a short period of validity (for example, 1-2 days) are used. <br><br>  Thus, most services will use certificates without the ‚ÄúTLS Feature‚Äù extension, but with a short validity period.  For such certificates, online status checks for certificates will not be performed at all.  Instead, there will be frequent updates of rapidly aging certificates. <br><br>  We add that using certificates with a short period of validity is equivalent to using certificates with the ‚ÄúTLS Feature‚Äù extension, which requires the use of attached OCSP responses, together with attached OCSP responses that are not protected from replay attacks (i.e. OCSP responses cached on TLS server).  At the same time, certificates with a short period of validity are slightly more effective in terms of saving traffic and the number of operations required to verify a certificate. <br><br>  The approach with the use of certificates with a short term of validity has a number of advantages, but it is of little use for CA certificates.  To check the status of such certificates, you can use periodically updated blacklists similar to ‚ÄúCRLSets‚Äù and ‚ÄúOneCRL‚Äù, but giving users more control over the CRL aggregators.  Users, for example, should be able to add new polled CRL distribution points.  This is important because some organizations deploy their own non-public CAs for internal use.  The solution may be the possibility of using private CRL aggregators.  In this case, you will need to develop an open protocol for interaction between the client and the CRL aggregator, ensuring compatibility between clients and aggregators of various vendors. <br><br><h2>  <b>Total</b> </h2><br><img align="left" src="https://habrastorage.org/web/e90/e37/591/e90e37591d48451aa9a33217eaba59f3.jpg">  Well, so far everything is not very good: verification of the status of certificates in modern browsers really does not work. <br><br>  However, there is still light at the end of the tunnel, and the situation is gradually, albeit slowly, moving towards the best. </div><p>Source: <a href="https://habr.com/ru/post/334714/">https://habr.com/ru/post/334714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334702/index.html">Development under Sailfish OS in the eyes of an iOS developer</a></li>
<li><a href="../334704/index.html">Unified Style Language</a></li>
<li><a href="../334708/index.html">Practical examples of attacks inside the GSM network</a></li>
<li><a href="../334710/index.html">Dagger 2. Subcomponents. Best practice</a></li>
<li><a href="../334712/index.html">Character development for the game "Allods Online"</a></li>
<li><a href="../334716/index.html">Create offline facial recognition with an accuracy of 99.38% in Python and Node.js</a></li>
<li><a href="../334718/index.html">The first Mail.Ru Group specialization is Coursera, the largest educational platform.</a></li>
<li><a href="../334720/index.html">Search for Go packages on PowerShell</a></li>
<li><a href="../334722/index.html">Digest of grocery design, July 2017</a></li>
<li><a href="../334724/index.html">Virtuozzo: What are the real benefits of distributed storage?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>