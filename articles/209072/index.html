<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Containerization on Linux in detail - LXC and OpenVZ. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 In the last article we started talking about the advantages of container insulation (containerization), now I would like to delve into the t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Containerization on Linux in detail - LXC and OpenVZ. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  In the last <a href="http://habrahabr.ru/company/FastVPS/blog/208650/)">article</a> we started talking about the advantages of container insulation (containerization), now I would like to delve into the technical aspects of the implementation of containers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f6/9da/b2f/4f69dab2fe79261c4718fdac83f71a5f.jpg"><br><a name="habracut"></a><br><h4>  Linux Containerization </h4><br>  For Linux, there are at least three container implementations: <br><ul><li>  Linux upstream containers (namespaces + cgroups) </li><li>  Linux VServer </li><li>  Openvz </li></ul><br>  Wait, where is the LXC and what is the Linux upstream containers with namespaces and cgroups?  If we are discussing the Linux kernel subsystem, which is responsible for isolating sets of processes from each other, then calling it LXC is categorically wrong for the reason that LXC is a proper name, the name <a href="http://linuxcontainers.org/">of the utility set is</a> only for managing the Linux kernel subsystems, and not for ensuring containers in the core! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The mechanisms that enable containers inside the kernel are called namespaces (here‚Äôs a good <a href="http://lwn.net/Articles/531114/">overview of</a> this functionality).  In addition, for the limitations of various container resources (the amount of memory used, the load on the disk, the load on the central processor) are responsible for the kernel mechanism - cgroups ( <a href="https://www.kernel.org/doc/Documentation/cgroups/">overview</a> ).  And in turn, I decided to combine both of these technologies under the name Linux upstream containers, that is, containers from the current version of the Linux kernel with kernel.org. <br><br>  If we talk about user space, such packages as LXC, systemd-nspawn and even vzctl (a utility from the OpenVZ project) are engaged exclusively in creating / deleting namespacs and configuring cgroups for them. <br><br><habracut><br><h4>  What is OpenVZ? </h4><br>  If with Linux upstream containers everything is more or less clear, since they are included in the Linux kernel, then OpenVZ will require explanations.  OpenVZ is an open source <a href="http://openvz.org/">project</a> developed by Parallels (formerly known as SwSoft) since 2005 (for more than 8 years) and engaged in the development and support of production ready solutions for containerization based on the Linux kernel (patches are superimposed on the cores from RHEL). <br><br>  This project consists of two parts - a Linux kernel with patches from the Parallels company (vzkernel), as well as a set of utilities for managing the kernel (vzctl, vzlist, etc.).  Since the modified kernel from OpenVZ is built on the basis of the Red Hat Enterprise Linux kernel, it is logical to assume that the recommended OS for OpenVZ is RedHat or CentOS.  Also, a lot of work has been done recently to provide OpenVZ support for Debian 7 Wheezy, but for my part, I still recommend using OpenVZ exclusively on CentOS 6. <br><br>  At the moment there are more than 25 thousand servers in the world (it is worth noting that due to the peculiarities of statistics collection, the data are somewhat underestimated) with the OpenVZ installed, you can see detailed statistics here: <a href="https://stats.openvz.org/">https://stats.openvz.org/</a> <br><img src="https://habrastorage.org/getpro/habr/post_images/98a/d84/b68/98ad84b6842892910a56a4d35f501dae.png"><br><h4>  OpenVZ development history </h4><br>  For the OpenVZ project, the following development milestones can be identified: <br><ul><li>  OpenVZ for RHEL4 (closed by EOL) </li><li>  OpenVZ for RHEL5 </li><li>  OpenVZ for RHEL6 </li><li>  OpenVZ for RHEL7 (while being written) </li></ul><br>  I, unfortunately, cannot comment on the differences between the RHEL4 / RHEL5 versions, because I have not even seen the RHEL 4 version.  But the differences in RHEL 5 and 6 are extremely significant, the most important aspect in them is that the solid part of the OpenVZ patch was removed and instead the OpenVZ project switched to using standard Linux kernel mechanisms - namespace and cgroups, in future versions this work will continue and in the bright future, OpenVZ will not require anything other than a set of utilities for its work, all the required kernel functionality will be in the Linux upstream. <br><br><h4>  Linux upstream containers development history </h4><br>  Two fundamental technologies underpin the Linux upstream containers - these are namespaces and cgroups.  The namespaces framework in the form of a mount namespace was first <a href="http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html">introduced</a> in 2000 by the well-known developer Al Viro (Alexander Viro).  In turn, the cgroup framework was developed by Google, with the participation of engineers Paul Menage and Rohit Seth. <br><br>  Also, a great contribution to the development of new subsystems of namespaces / cgroups was made by the developers of the OpenVZ project.  In particular, the <a href="http://lwn.net/Articles/259217/">PID</a> and Net namespaces were developed in the context of the OpenVZ project.  In addition, the Criu framework was recently transferred to the stable phase for serializing / deserializing sets of running Linux processes <a href="http://lwn.net/Articles/572125/">lwn.net/Articles/572125</a> , it was also developed in the context of solving tasks for OpenVZ. <br><br>  If you want to evaluate the contribution yourself, I propose two documents - a <a href="http://www.linuxfoundation.org/publications/linux-foundation/who-writes-linux-2013">report</a> on the contribution of companies to the core development in 2013 and a similar <a href="http://go.linuxfoundation.org/who-writes-linux-2012">report</a> for 2012: Parallels has a contribution of 0.7% and 0.9% there, respectively.  It may seem that 1% is not enough, I would like to remind you that the size of edits per year reaches several million lines. <br><br>  If you already use OpenVZ and you have something to tell (bugs) or what to share (patches), then you are <a href="https://bugzilla.openvz.org/">welcome to</a> OpenVZ <a href="https://bugzilla.openvz.org/">bug tracker.</a> Each of your running reports improves the stability and quality of the project for all its users! <br><br><h4>  Technical implementation of the container insulation subsystem </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/8e0/7b5/54b8e07b555279356e58ae94b30ab63d.jpg"><br><br>  Here I would like to follow the path through which, I am sure, every system administrator who was tasked with ‚Äúisolating users from each other‚Äù within the same Linux server passed through. <br><br>  So, let's say we have two web applications that belong to different clients (pay attention, I don‚Äôt use the term  users ‚Äôhere so that there‚Äôs no confusion with Linux users) and don‚Äôt have to interfere with each other (for example, when hacking overload, exhaustion of resources) and even more so on the physical server itself. <br><br>  Let's take the sequence of steps taken in the form of a list: <br><br><ol><li>  You can run applications from different Linux users.  Thus, the security of the file system of a neighboring application will be controlled solely by the system of rights to Linux files and folders, and if the configuration is incorrect, it may be possible to compromise files.  Also, all the service files of the physical server will be accessible to both applications, which can also lead to data leakage and subsequent compromise of the entire system.  This method does not solve all the problems and you need something more advanced. </li><li> To increase the security of the file system, we will try to use the chroot functionality, which allows you to ‚Äúlock‚Äù the process inside a specific folder, from which it will be very difficult for it to get out.  To do this, we need to create a complete set of system files (for example, through debootstrap) for each of the applications and put them in separate file hierarchies.  Thus, each application will have its own file hierarchy that does not intersect with a friend.  But if the process inside the chroot works as the root user (there are quite a lot of such processes), then using standard mechanisms (multiple chroot) he can get out of the chroot and get into the file system of the physical server, which, of course, is not acceptable.  This option also does not suit us. </li><li>  In addition to chroot Linux, the Linux mount namespace subsystem has been around for a very long time, which provides broader functionality, but with full protection so that it cannot be pulled out.  In containerization it is used.  Since it is no longer possible to describe our actions in detail without invoking the C code, I will limit myself to their formal description.  So, we have solved the problems of isolating ordinary file systems. </li><li>  Now suppose that each of the applications uses a fixed port, for example, 443d.  What should we do if there is only 1 IP address on the server and it is attached to the physical server?  Of course, first we need two additional IP addresses, one for each service.  We will have to assign both of them to the physical server and configure for each application an explicit listening on its IP address.  But what if one of the applications is hacked and tries to start listening on a port on the IP of the physical server or on the IP of the neighbor in order to compromise access?  He will succeed and no one will prevent him from doing this.  How to deal with this?  Here the namespaces will help us again - namely, the network namespace, through which each of the containers (perhaps they can already be called that way!) Gets a strictly fixed separate IP address (as well as the space of sockets, ports, and the routing table).  This will ensure complete isolation at the level of sockets, IP addresses and ports from the neighbor.  No mutual influence is now possible. </li><li>  And now let's get a little into the jungle of processes and remember that, for example, the Apache web server uses semaphores very actively, and the PHP APC opcode accelerator very often uses shm memory.  What happens if one process takes and even clears the memory of the neighbor, which is clearly visible to him?  Or read it and retrieve any sensitive data?  Strongly unpleasant event that reduces all our tricks on isolation to nothing.  But there is a solution - IPC namespace, which isolates semaphores, queues, mutexes, shm memory for IPC and IPC Sys V in the form that each container only sees its own IPC resources and no one else.  Hooray!  Problem solved. </li><li>  At this stage, we have almost everything fine, but the problem remains with the fact that from the container we see all the processes of the physical server, as well as the processes of the neighbor.  Often, processes disclose passwords or other important information in their names, so this possibility is extremely undesirable.  In addition, if we want to start a process with a fixed PID, which is already occupied by a neighboring container or host system - this will not work, since Linux requires a unique PID for all processes.  To get rid of this behavior, we use the PID namespace, which for each container will create a completely isolated (from the physical server and from the neighbor) PID numbering system, which in turn makes it possible to start, for example, several processes with a PID equal to 1. Stop, and What process on Linux has such a PID?  Correct init!  In our ‚Äúself-made insulation‚Äù we have reached the stage when we can run a full-fledged system, and not just one process inside the container!  Hooray! </li><li>  But our happiness in launching a full-fledged Linux in the container will be incomplete, since the hostnames will coincide in both containers with the hostname of the physical server, which can, for example, when working on ssh lead to unpleasant consequences and a lot of software checks the correctness of the hostname and its consistency IP address of the machine.  It also needs to be isolated; this is done with a namespace with a very non-intuitive name - UTS, which only allows you to set each container with its own unique hostname. </li></ol><br>  So, to implement the isolation of the base systems, we needed the following namespaces: <br><ul><li>  Mount </li><li>  Network </li><li>  Pid </li><li>  UTS </li><li>  IPC </li></ul><br>  Of course, the path was very thorny and the implementation of these subsystems in the kernel went in a slightly different sequence, but now they are all available and gathered in such a wonderful picture called Linux upstream containers! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/e76/340/0e6e763406c1f4be5b7521885d9ea461.jpg"><br><br><h4>  What to expect in the continuation? </h4><br><ul><li>  Technical implementation of the container hardware resource limiting subsystem </li><li>  Common problems when using containers </li><li>  The advantages of OpenVZ over standard Linux containerization </li><li>  Problem from the user space </li><li>  findings </li></ul><br>  Thank you for staying with us!  In the coming days we will prepare and publish the continuation of the series! <br><br>  Separately, I would like to thank Andrey Wagin <a href="http://habrahabr.ru/users/avagin/">avagin</a> for his help in editing particularly complex technical issues. <br><br>  Respectfully, <br>  CTO hosting company <a href="http://fastvps.ru/">FastVPS</a> <br>  Pavel Odintsov </habracut></div><p>Source: <a href="https://habr.com/ru/post/209072/">https://habr.com/ru/post/209072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209060/index.html">Samsung branded retail in the province: we test and wonder</a></li>
<li><a href="../209062/index.html">IT Tree with Hackspace</a></li>
<li><a href="../209066/index.html">The programmer remembers his mistakes</a></li>
<li><a href="../209068/index.html">Programmer gets investment: our experience</a></li>
<li><a href="../209070/index.html">Chinese moon rover sent new photos</a></li>
<li><a href="../209074/index.html">Raising the Thunderbolt Ethernet Adapter on XenServer</a></li>
<li><a href="../209076/index.html">Tasks for the developer Yandex.Music for iOS</a></li>
<li><a href="../209078/index.html">What is Teradata?</a></li>
<li><a href="../209080/index.html">Black Friday. How did it all really</a></li>
<li><a href="../209084/index.html">Containerization on Linux in detail - LXC and OpenVZ Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>