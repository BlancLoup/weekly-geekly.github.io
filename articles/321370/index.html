<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why VIPER is a bad choice for your next application.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is a free translation of the article Why VIPER is a bad choice for your next application by Sergey Petrov 


 Over the last year, everyone f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why VIPER is a bad choice for your next application.</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/a0b/84d/23a/a0b84d23a78a4863b3f2c1ec8fbb136b.jpg"></div><br><p>  <i>This post is a free translation of the article <a href="https://medium.com/%40Pr0Ger/why-viper-is-a-bad-choice-for-your-next-application-725f4e16fbee">Why VIPER is a bad choice for your next application</a> by <a href="https://medium.com/%40Pr0Ger">Sergey Petrov</a></i> </p><br><p>  Over the last year, everyone felt like a VIPER.  This architecture really inspires developers.  But most of the articles are, in fact, rather biased.  They only show the steepness of this architectural pattern, keeping silent about its negative sides.  But he has no less problems (and maybe even more) than others.  And in this article I will try to explain why VIPER is not at all as good as they say about it, and why it is not suitable for most of your applications. </p><br><p><a name="habracut"></a>  Some articles on the comparison of architectures, as a rule, state that VIPER is completely different from other MVC architectures.  But in fact, VIPER is just a normal MVC, where the controller is divided into two parts: interactor and presenter.  View remained in place, and the model was renamed to entity.  Router deserves special attention: yes, other architectures do not mention this part in their abbreviations, but it is also present in them: implicitly (when you call <code>pushViewController</code> - you create a simple router) or more obvious (as an example - FlowCoordinators). </p><br><p>  Let's talk about the "buns" that VIPER offers us (I will refer to <a href="">this book</a> ).  Let's look at goal number two, which deals with SRP (the principle of shared responsibility).  It sounds rude, but what kind of crank you need to be to consider this an advantage?  You get paid for solving problems, not for matching fashionable words.  Yes, you still use TDD, BDD, unit testing, Realm or SQLite, dependency injection, and many, many other things, but you use all this not just for the sake of use, but to solve customer problems. </p><br><h1>  Testing. </h1><br><p>  This is another interesting aspect and a very important task.  On the good side, it would be possible to write a separate article about testing, because many people talk about it, but very few people really test their applications, and even fewer people do it correctly. </p><br><p>  One of the main reasons is that there are no good examples.  You can find quite a few articles on how to write a unit test <code>assert 2 + 2 == 4</code> , but you will not find real examples (nevertheless, <a href="https://github.com/artsy/">Artsy</a> keeps its applications in open-source, and you should look at their projects). </p><br><p>  VIPER proposes to separate all logic into many smaller classes with divided responsibilities.  This should make testing easier, but not always.  Yes, writing a unit test for a simple class is easy, but most of these tests do not test anything.  Let's look, for example, at most <a href="">of the</a> presenter <a href="">methods</a> : they are only proxies between the view and other components.  You can write tests for this proxy, this will increase the test coverage of your code, but these tests are useless.  And you will have a side effect: you must update these useless tests after each change to the code. </p><br><p>  The right approach to testing should include testing the interactor and the presenter right away, because these two parts are strongly related to each other.  In addition, since we divide logic into two classes, we need a lot more tests than one class.  This is a simple combinatorics: class <code>A</code> has 4 possible states, and class <code>B</code> 6, respectively, their combination has 24 possible states, and you need to test them. </p><br><p>  The correct approach to simplify testing is the purity of the code, instead of simply separating the complex code into a bunch of classes. </p><br><p>  Oddly enough, testing a view is easier than testing some areas of business logic.  A view is only a collection of certain properties and inherits the appearance of these properties.  You can use <a href="https://github.com/facebook/ios-snapshot-test-case">FBSnapshotTestCase</a> to compare their state with appearance.  This thing still doesn‚Äôt handle some special cases like custom transitions, but how often do you use them? </p><br><h1>  Ovingengineering in design. </h1><br><blockquote>  <i>VIPER is what happens when former Javists break into the world of iOS.</i>  <i>- n0damage, <a href="https://www.reddit.com/r/iOSProgramming/comments/5pcebg/viper_how_strictly_do_you_guys_follow_this_or/dcqa1uj/">comment on reddit</a></i> </blockquote><p>  Honestly, can anyone look at <a href="">this</a> and say: "Yes, these additional classes and protocols really improve my understanding of what is happening in my application." </p><br><p>  Imagine a simple task: there is a button that launches an update from the server and there is a twist with the data received from the server.  Guess how many classes / protocols will be affected by this change?  Yes, at least 3 classes and 4 protocols will be modified to implement such a simple function.  Does anyone remember how Spring started with some abstractions and ended up with <code>AbstractSingletonProxyFactoryBean</code> ?  I have always dreamed of a " <a href="https://docs.spring.io/spring/docs/2.5.x/javadoc-api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html">convenient superclass of proxy factories for proxy factories that create only singletons</a> " in my code. </p><br><h4>  Excess components </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/197/f36/e44/197f36e440854c278c4fcb57fd0e3858.png"></div><br><p>  <i>(The redundant code is not as harmless as I used to think. It gives a false signal about its necessity.)</i> </p><br><p>  As I mentioned earlier, the presenter is usually a rather stupid class that simply transfers calls from view to interaction (something like <a href="">that</a> ).  Yes, sometimes it contains complex logic, but basically it‚Äôs just a redundant component. </p><br><h4>  "DI-Friendly" number of protocols </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b2f/07d/4df/b2f07d4df80742d79a74feed752292d2.png"></div><br><p>  <i>(An ugly code is easy to recognize and its cost is easy to estimate. This is not true if the abstraction is wrong.)</i> </p><br><p>  There is a general confusion with this abbreviation: VIPER implements the principles of SOLID, where DI is ‚Äúdependency <i>inversion</i> ‚Äù, not ‚Äú <i>injection</i> ‚Äù (not ‚Äú <i>injection</i> ‚Äù).  Dependency injection is a special case of the "Inversion of Control" pattern, which is certainly related, but different from dependency inversion. </p><br><p>  Inversion of dependencies is about the separation of modules of different levels by entering abstractions between them.  For example, the UI module should not be directly dependent on the network module.  Inversion of control is another.  This is when a module (usually from a library that we cannot change) delegates something to another module, which is usually provided to the first module as a dependency.  Yes, when you implement the data source for your <code>UITableView</code> you use the IoC principle.  Using similar names for different high-level things is a source of confusion. </p><br><p>  Let's go back to VIPER.  There are many protocols (at least 5) between classes within a single module.  And all of them are not necessary.  Presenter and interactor are not modules from different layers.  Applying the IoC principle can make sense, but ask yourself: how often do you have at least two presenters for one view?  I‚Äôm sure most of you will say never.  So why is it necessary to create this bunch of protocols that we will never use? </p><br><p>  In addition, because of these protocols, you cannot easily navigate through the code in the IDE.  After all, <code>cmd+click</code> will throw you into the protocol, instead of the implementation. </p><br><h4>  Performance issues </h4><br><p>  This is a key point, but many simply do not worry about it, or simply underestimate the impact of bad architectural decisions. </p><br><p>  I will not talk about the Typhoon framework (which is very popular for introducing dependencies in the world of objective-c).  Of course, it has some impact on performance, especially when using automatic injection, but VIPER does not require its use.  Instead, I would talk about runtime and application launch, and how VIPER slows down your application literally everywhere. </p><br><p>  <b>Application launch time.</b>  This topic is rarely discussed, but it is important.  After all, if your application starts very slowly, users will not use it.  At the last WWDC just talked about <a href="https://developer.apple.com/videos/play/wwdc2016/406/">optimizing the launch time of applications</a> .  The start time of your application depends on the number of classes in it.  If you have 100 classes - this is normal, the delay will be invisible.  However, if your application has only 100 classes - do you really need this complex architecture?  But if your application is huge, for example, you are working on a Facebook application ( <a href="http://quellish.tumblr.com/post/126712999812/how-on-earth-the-facebook-ios-application-is-so">18K classes</a> ), then the difference will be noticeable: about one second.  Yes, the ‚Äúcold start‚Äù of your application will take 1 second only to load all the class metadata and nothing else, you correctly understood. </p><br><p>  <b>Rantime calls.</b>  It is more complicated and mainly applied only to the Swift compiler (since Objective-C runtime has more features and the compiler cannot safely perform optimizations).  Let's talk about what happens ‚Äúunder the hood‚Äù when you call a method (I say ‚Äúcall‚Äù and not ‚Äúsend a message‚Äù because the second is not always correct for Swift).  There are three types of calls in Swift (from fast to slow): static, table of calls and sending messages.  The latter is the only one that is used in Objective-C, and it is used in Swift when compatibility with Objective-C code is required, or when the method is declared as <code>dynamic</code> .  Of course, this part of the runtime will be highly optimized and <a href="https://opensource.apple.com/source/objc4/objc4-437/runtime/Messengers.subproj/">recorded in an assembler</a> for all platforms.  But what if we can avoid this overhead by giving the compiler an idea of ‚Äã‚Äãwhat exactly will be called during compilation?  This is exactly what the Swift compiler does with static and call table.  Static calls are fast, but the compiler cannot use them without 100% confidence in the types.  And when the type of our variable is a protocol, the compiler is forced to use calls using tables.  This is not too slow, but one millisecond is here, one is there, and now the total execution time grows by more than one second, compared to what could be achieved with pure Swift code.  This point is related to the previous protocols, but I think it is better to separate the concern about the number of unused protocols from messing around with the compiler. </p><br><h4>  Weak separation of abstractions </h4><br><blockquote>  <i>There should be one, and preferably only one, obvious way to do this.</i> </blockquote><p>  One of the most popular questions from the VIPER community is: "where should I take X?"  It turns out that on the one hand there are many rules on how to do everything correctly, and on the other, many decisions are based on someone's opinion.  These can be complex cases, such as handling <code>CoreData</code> using an <code>NSFetchedResultsController</code> , or <code>UIWebView</code> .  But even common cases, such as using <code>UIAlertController</code> , are a topic of discussion.  Let's take a look: <a href="">here the</a> router interacts with our alert, and <a href="">here</a> it shows a twist.  You can answer that this simple alert is a special case of an alert with no action other than closing. </p><br><blockquote>  <i>Special cases are not enough to break the rules.</i> </blockquote><p>  That's right, but why do we have <a href="">a</a> <i>factory</i> <a href="">here</a> to create such alerts?  As a result, we have a mess even with <code>UIAlertController</code> .  Do you want that? </p><br><h4>  Code generation </h4><br><blockquote>  <i>Readability matters.</i> </blockquote><p>  How can this be an architectural problem?  It‚Äôs just generating heaps of classes from a template instead of writing them by hand.  What is the problem here?  The problem is that most of the time you <i>read the</i> code, not write it.  So you read the template code mixed with your code most of your time.  Is it good?  I do not think. </p><br><h1>  Conclusion </h1><br><p>  I do not intend to discourage you from using VIPER at all.  There may well be applications that only benefit from it.  However, before you start developing your application, you should ask yourself a couple of questions: </p><br><ol><li><p>  Will this application have a long life cycle? </p><br></li><li><p>  Are the requirements stable enough?  Otherwise, you will encounter endless refactoring even with minor changes. </p><br></li><li>  Are you really testing your apps?  Be honest with yourself. </li></ol><br><p>  Only if you answered "yes" to all three questions, <i>could</i> VIPER be a good choice for your application. </p><br><p>  And finally, the last thing: you have to make your own decisions.  Do not just blindly trust any guy from the Medium (or Habr) who says "Use X, X is cool."  This guy might be wrong too. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/321370/">https://habr.com/ru/post/321370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321360/index.html">Technosphere Mail.Ru - three years</a></li>
<li><a href="../321362/index.html">Testing Ethereum smart contracts on the example of DAO</a></li>
<li><a href="../321364/index.html">Lightshot client for Ubuntu Linux (and not only)</a></li>
<li><a href="../321366/index.html">NetApp ONTAP & VMware vVOL</a></li>
<li><a href="../321368/index.html">Andrew Un's draft of The Thirst for Machine Learning, Chapters 1-7</a></li>
<li><a href="../321372/index.html">Why Zuckerberg chasing a ghost</a></li>
<li><a href="../321374/index.html">Configuring the launch of the GRUB bootloader menu when installing Linux from Windows on one computer with a GPT partition table</a></li>
<li><a href="../321376/index.html">Facebook shareholders want to remove Zuckerberg from the chair of the board of directors</a></li>
<li><a href="../321378/index.html">How to work with JIT</a></li>
<li><a href="../321380/index.html">RethinkDB: very much alive. Now under the wing of the Linux Foundation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>