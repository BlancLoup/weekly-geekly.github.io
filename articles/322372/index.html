<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write simple DSL on Kotlin in 2 steps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DSL (Domain-specific language) - language specialized for a specific application ( Wikipedia ) 


 The article ‚Äú Why Kotlin sucks, ‚Äù in which the auth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write simple DSL on Kotlin in 2 steps</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/0bf/1c8/549/0bf1c8549faa41aa8c95d1c8cdfffa76.png" alt="image"></p><br><p>  <strong><em>DSL (Domain-specific language) - language specialized for a specific application</em></strong> ( <em>Wikipedia</em> ) </p><br><p>  The article ‚Äú <a href="https://habrahabr.ru/post/322256">Why Kotlin sucks,</a> ‚Äù in which the author complains that Kotlin ‚Äúhas no syntax for describing structures,‚Äù pushed me to write this post.  For some time programming on Kotlin I got the impression that if it is impossible in it, but I really want it, then it is possible.  And I decided to try to write my DSL to describe the data structure.  That's what came out of it. </p><a name="habracut"></a><br><h2 id="disclaimer">  Disclaimer </h2><br><p>  Despite the fact that I would like to really get DSL for describing the structures, the purpose of the article I first of all want to put the <strong>explanation (with examples) of</strong> the features of the Kotlin language, with the help of which writing this DSL itself becomes possible.  Well, a simple DSL, of course, we will write :) </p><br><h2 id="sintaksis">  Syntax </h2><br><p>  For simplicity, or because of some personal preference, I want the syntax of my future DSL to describe the data structure to be similar to JSON.  In short, the syntax implies the following: </p><br><ul><li>  each structure field has a name and is written as a string </li><li>  the value of each field can be any object, including another nested structure. </li></ul><br><h2 id="shag-0-snachala-byla-pustota">  Step 0. At first there was emptiness </h2><br><p>  We need to start from something and we will start by forcing us to compile an empty structure of the form: </p><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  It's not hard to do this, you just need to declare a function </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>){ }</code> </pre> <br><p>  The <code>struct(...)</code> function takes as a parameter another function that returns <code>Unit</code> and so far does nothing more.  But this function reveals to us an important Kotlin chip, which will help us in writing DSL: if the last argument of the function is another function, then it can be declared outside the brackets "(...)".  If a function has only 1 argument, and this argument is a function, then parentheses can be omitted. </p><br><p>  Thus, our <code>struct {}</code> code is equivalent to the <code>struct({})</code> code, only shorter. </p><br><p>  Well, we have an empty structure!  Actually, no, we only have a <code>struct</code> function that does not even return anything.  It is necessary that she returned at least something: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> //  , </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">     Kotlin fun struc</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) : Struct { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Struct() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> struct = struct { } }</code> </pre> <br><p>  Now we really have some empty object of the Struct class. </p><br><h2 id="shag-1-potom-byli-dannye">  Step 1. Then there was the data. </h2><br><p>  It's time to add some content.  I tried to find a way to make the view construct work. </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-string"><span class="hljs-string">"field1"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"field2"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  I could not achieve an exact match, but it turned out to make as many as 3 alternative syntaxes, which, if desired, can be used simultaneously :) </p><br><pre> <code class="hljs pgsql">struct { s("field1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) s("field2" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) s("field3" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> struct { s("field3.1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>) }) }  struct { +{ "field1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } +{ "field2" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> } +{ "field3" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> struct { +{ "field3.1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> } } } }  struct( "field1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, "field2" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, "field3" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> struct( "field1.1" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> ) )</code> </pre> <br><p>  Note that in the third case it was necessary to use parentheses, not curly ones, but in it the least number of characters. </p><br><p>  So how to make it work?  First, the data in the Struct class must be stored somewhere.  I chose <code>hashMap&lt;String, Any&gt;()</code> , since the structure field is a string, and the value is any object. </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> children = hashMapOf&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>&gt;() }</code> </pre> <br><p>  Secondly, this data needs to be added somehow to the structure.  Recall that everything inside the curly braces after the word <code>struct</code> is a function that we passed to the <code>struct(...)</code> argument.  So, in order to manipulate a <code>Struct</code> object <code>Struct</code> we need to access this object inside the passed function.  And we can do it! </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Struct { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> struct = Struct() struct.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct }</code> </pre> <br><p>  We changed the type of the <code>init</code> function to <code>Struct.() -&gt; Unit</code> .  This means that the function passed must be a function of the <code>Struct</code> class or its extension function.  With such a function declaration, we can perform <code>struct.init()</code> , and this, in turn, means that inside the <code>init()</code> function, we will access an instance of the <code>Struct</code> class through, for example, <code>this</code> . </p><br><p>  For example, now we have the right to write such code: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children.put(<span class="hljs-string"><span class="hljs-string">"field1"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this -   Struct,        struct() }</span></span></code> </pre> <br><p>  It already works, but it is a little similar to language of the description of data structure.  Add support for designs </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span></span>{ +{ <span class="hljs-string"><span class="hljs-string">"field1"</span></span> to <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  <code>"field1" to 1</code> is the equivalent of <code>Pair&lt;String, Any&gt;("field1", 1)</code> .  It is wrapped in braces, which is a lambda function.  The last line of the lambda function defines the type of value it returns, and the value itself.  In other words, <code>{ "field1" to 1 }</code> is a lambda that returns <code>Pair&lt;String, Any&gt;</code> . </p><br><p>  With lambda finished, but what is this "+" in front of her?  And this is a redefined unary operator "+", by calling which we add the pair obtained from the lambda to our structure.  Its implementation looks like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> children = hashMapOf&lt;String, Any&gt;() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(()</span></span></span></span> -&gt; Pair&lt;String, Any&gt;).unaryPlus() { <span class="hljs-comment"><span class="hljs-comment">//    +   val pair = this.invoke() //      children.put(pair.first, pair.second) //  } }</span></span></code> </pre> <br><p>  Next, let's deal with the support of the syntax of the form: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span></span>{ s(<span class="hljs-string"><span class="hljs-string">"a"</span></span> to <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><p>  There are no lambdas here, immediately creating the <code>Pair</code> object and some kind of "s" in front of it.  Actually "s" is also an operator, but already infix.  Where did he come from?  So I wrote it myself, here it is: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> children = hashMapOf&lt;String, Any&gt;() <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Struct.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(that: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Pair</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children.put(that.first, that.second) } }</code> </pre> <br><p>  It returns nothing, but adds the pair passed to it in our data structure.  The letter "s" I chose just like that, the name of the operator can be any.  By the way, <code>to</code> in the expression <code>"field1" to 1</code> is also an infix operator that returns a <code>Pair("field1", 1)</code> </p><br><p>  Finally, add support for the third syntax.  The most concise, but the most boring in terms of implementation. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>( <span class="hljs-string"><span class="hljs-string">"field1"</span></span> to <span class="hljs-number"><span class="hljs-number">1</span></span> )</code> </pre> <br><p>  It's not hard to guess that <code>"field1" to 1</code> is just an argument to the function <code>struct(...)</code> .  To be able to pass multiple pairs, we will declare this argument as <code>vararg</code> </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Pair</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Struct { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> struct = Struct() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { struct.children.put(pair.first, pair.second) } struct.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct }</code> </pre> <br><h2 id="shag-2-i-poluchilsya-dsl">  Step 2. And get a DSL? </h2><br><p>  We have learned to describe the structure, but it is not worth a damn if we don‚Äôt give an opportunity to work with it.  We don't want to write code like this: <code>struct.children.get("field")</code> , we don‚Äôt want to know anything about <code>children</code> .  We want to immediately refer to the fields of our structure.  For example, like this: <code>val value = struct["field1"]</code> .  And we can teach our DSL this trick if we define another operator for our Struct class :) </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Struct</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> children = hashMapOf&lt;String, Any&gt;() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> children[s] } }</code> </pre> <br><p>  Yes, this is the "get" <strong>operator</strong> (namely the <strong>operator</strong> , not the getter), which is automatically called when the object is accessed using square brackets. </p><br><h2 id="itogo">  Total </h2><br><p>  We can say that we did DSL.  Let not perfect, with obvious shortcomings in the form of the impossibility to automatically deduce the type of each field, but it turned out.  Probably, if you practice for some time, you can find ways to improve it.  Maybe readers have ideas? </p><br><p>  An example of the code can be viewed <a href="">at the link.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322372/">https://habr.com/ru/post/322372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322362/index.html">Red Hat acquires 3scale, which develops API management systems, and intends to open source code of products</a></li>
<li><a href="../322364/index.html">RTM Cybergroup specializes in stealing funds from Russian companies</a></li>
<li><a href="../322366/index.html">Analytical data outside Wrike analytics</a></li>
<li><a href="../322368/index.html">CSS for Swift: using styles for any subclass of UIView</a></li>
<li><a href="../322370/index.html">Genetic Algorithms and Turing Machine</a></li>
<li><a href="../322374/index.html">Three-letter service quality</a></li>
<li><a href="../322376/index.html">Elixir and Angular 2 without Hello, world !, or Implementing work with the tree directory, part 1</a></li>
<li><a href="../322378/index.html">Warm up before the weekend: Raspberry Pi, Arduino and free evening</a></li>
<li><a href="../322380/index.html">NSRegularExpression and NSDataDetector - Quick Start</a></li>
<li><a href="../322384/index.html">Video of reports from Go 1.8 release party Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>