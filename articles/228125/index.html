<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive programming for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fault tolerance, responsiveness, focus on events and scalability are the four principles of today's popular reactive programming . It is following the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive programming for Android</h1><div class="post__text post__text-html js-mediator-article">  Fault tolerance, responsiveness, focus on events and scalability are the four principles of today's popular <a href="http://www.reactivemanifesto.org/">reactive programming</a> .  It is following them that the backend of large systems is created with the simultaneous support of tens of thousands of connections. <br><br>  Responsiveness, simplicity, flexibility and extensibility of the code - the principles that can be assigned to a reactive UI. <br><br>  Surely, if you combine reactive backend and UI, you can get a quality product.  That's what we tried to do by developing <a href="http://apps.2gis.ru/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_reactive">2GIS Dialer</a> - dialers that work through the API and at the same time should remain fast and convenient. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e60/07e/f0a/e6007ef0a3536578e7adb8fa8bbe08dc.png"><br><a name="habracut"></a><br><br><h4>  Why do we need reactive programming </h4><br>  Consider an example: <br><br><pre><code class="java hljs">requestDataTask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask&lt;Void, Void, JSONObject&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> JSONObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Void... params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String requestResult = apiService.getData(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JSONObject json = JsonUtils.parse(requestResult); lruCache.cacheJson(json); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json; } };</code> </pre> <br>  Everything is simple, we create AsyncTask, in which: <br><br><ol><li>  Make a request to <a href="http://api.2gis.ru/%3Futm_source%3Dnews%26utm_medium%3Dhabr%26utm_campaign%3Dpost_reactive%253C/a%253E">API 2GIS</a> . </li><li>  Create a <code>JSONObject</code> based on the result of the query. </li><li>  Cache <code>JSONObject</code> . </li><li>  Return <code>JSONObject</code> . </li></ol><br>  Such code is found in many projects, it is understandable, and millions of lemmings can not be wrong.  But let's dig a little deeper: <br><br><ol><li>  What to do if <code>Exception</code> dropped somewhere at runtime? </li><li>  <code>doInBackground(Void...)</code> runs in a separate thread, how do we tell the user about a UI error?  To get fields for <code>Exception</code> ? </li><li>  And what to return if the request failed?  <i>null</i> ? </li><li>  And if json is not valid? </li><li>  What should I do if I could not cache the object? </li></ol><br>  And this is not the most difficult example.  Imagine that you need to make another request based on the results of the previous one.  On AsyncTasks, this will be a callback-hell, which, at a minimum, will be unstable to crashes, errors, etc. <br><br>  There are more questions than answers.  On the shortcomings of AsyncTask'ov you can write an entire article, seriously.  But are there any better options? <br><br><h4>  RxJava Framework </h4><br>  Looking back at the principles of reactive programming, we began to look for a solution that would provide: <br><br><ul><li>  lack of freezes and brakes; </li><li>  scalability on smartphone resources; </li><li>  lack of crash; </li><li>  focus on events. </li></ul><br>  That was <a href="https://github.com/Netflix/RxJava">RxJava</a> from the guys from Netflix - the reactive extension, the idea (but not the implementation) of which migrated from the reactive extension for c #. <br><br>  In RxJava, everything revolves around <code>Observable</code> .  <code>Observable</code> is like data streams (they can also be considered as monads) that can receive and transmit this data in any way.  Over <code>Observable</code> you can use operations such as <code>flatmap</code> , <code>filter</code> , <code>zip</code> , <code>merge</code> , <code>cast</code> , etc. <br><br>  A simple example: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Observable,        Iterable final Subscription subscription = Observable.from(Arrays.asList(1, 2, 3, 4, 5)) .subscribeOn(Schedulers.newThread()) //      background .observeOn(AndroidSchedulers.mainThread()) //,     main thread .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { //do something with result } });</span></span></code> </pre><br>  We create an <code>Observable</code> , which in turn gives us numbers from <code>Iterable</code> .  We indicate that the generation and transmission of data will take place in a separate thread, and the processing of the result will be in main thread.  We subscribe to it, and in the subscriber's method we perform any manipulations with each subsequent result. <br><br>  You can make this example more interesting: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Observable,        Iterable final Subscription subscription = Observable.from(Arrays.asList(1, 2, 3, 4, 5)). //      filter(new Func1&lt;Integer, Boolean&gt;() { @Override public Boolean call(Integer integer) { return integer % 2 == 0; //      } }) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { //do something with ONLY EVEN result } });</span></span></code> </pre><br>  Now, specifying the <code>filter</code> operator, we can process only even values. <br><br><h4>  How to use RxJava </h4><br>  Let's return to our first AsyncTask and see how we would solve the problem with the help of reactive programming. <br>  First, create an Observable with the query: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Observable,       Observable.OnSubscribe&lt;String&gt; Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { //   ,     subscriber.onNext(apiService.getData()); //    ,        subscriber.onCompleted(); } });</span></span></code> </pre><br>  Here we create an <code>Observable</code> and specify its behavior.  We make a request and give the result in <code>onNext(...)</code> , after which we say to <code>Subscriber</code> that we ended up by calling <code>onCompleted()</code> . <br><br>  This is understandable: we created <code>Observalble</code> , which is only responsible for getting the <code>String</code> object from the API.  <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> in its purest form. <br>  What if the request failed for some reason?  Then we can call the <code>Observable</code> method <code>retry(...)</code> , which will repeat this <code>Observable</code> n times until it is completed successfully (read, without <code>Exception</code> ).  In addition, we can give <code>Observable</code> 'from another <code>Observable</code> , even if <code>retry()</code> did not help.  If the backend is written crookedly, it would be better for us to close the connection by timeout.  And we have a <code>timeout(...)</code> method for this case.  All together it would look like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = Observable.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.OnSubscribe&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ subscriber.onNext(apiService.getData()); subscriber.onCompleted(); } }) .timeout(<span class="hljs-number"><span class="hljs-number">5</span></span>, TimeUnit.SECONDS) <span class="hljs-comment"><span class="hljs-comment">//     .retry(3) //  3   //   ,        .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends String&gt;&gt;() { @Override public Observable&lt;? extends String&gt; call(Throwable throwable) { //return new observable here, that can rescure us from error } });</span></span></code> </pre><br>  And a bit of refactoring: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = createApiRequestObservable() <span class="hljs-comment"><span class="hljs-comment">// Observable   .timeout(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS) //  .retry(RETRY_COUNT_FOR_REQUEST) // -  .onErrorResumeNext(createRequestErrorHandler()); //   </span></span></code> </pre><br>  Now let's create json.  For this, the result of our first <code>Observable</code> (and there the <code>String</code> ) must be converted.  We use <code>map(...)</code> , and if something suddenly goes wrong, we return another one we need in case of failure, json using <code>onErrorReturn(...)</code> . <br>  Like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = createApiRequestObservable() .timeout(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS) .retry(RETRY_COUNT_FOR_REQUEST) .onErrorResumeNext(createRequestErrorHandler()) <span class="hljs-comment"><span class="hljs-comment">// Observable,    String  JSONObject .map(new Func1&lt;String, JSONObject&gt;() { @Override public JSONObject call(String s) { return JsonUtils.parse(s); } }) //    //   "" json .onErrorReturn(new Func1&lt;Throwable, JSONObject&gt;() { @Override public JSONObject call(Throwable throwable) { return jsonObjectForErrors; } });</span></span></code> </pre><br>  Ok, with json sorted out.  Caching left.  Caching: this is not a result conversion, but an action on it.  For this, <code>Observable</code> has methods <code>doOnNext(...)</code> , <code>doOnEach(...)</code> , etc.  It turns out something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = createApiRequestObservable() .timeout(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS) .retry(RETRY_COUNT_FOR_REQUEST) .onErrorResumeNext(createRequestErrorHandler()) <span class="hljs-comment"><span class="hljs-comment">// Observable,    String  JSONObject .map(new Func1&lt;String, JSONObject&gt;() { @Override public JSONObject call(String s) { return JsonUtils.parse(s); } }) //    //   "" json .onErrorReturn(new Func1&lt;Throwable, JSONObject&gt;() { @Override public JSONObject call(Throwable throwable) { return jsonObjectForErrors; } }) //,    onNext(..)  Observable .doOnNext(new Action1&lt;JSONObject&gt;() { @Override public void call(JSONObject jsonObject) { lruCache.cacheJson(jsonObject); } });</span></span></code> </pre><br>  Again, a little refactor code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = createApiRequestObservable() <span class="hljs-comment"><span class="hljs-comment">// Observable   .timeout(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS) //  .retry(RETRY_COUNT_FOR_REQUEST) // -  .onErrorResumeNext(createRequestErrorHandler()) //    .map(createJsonMapOperator()) // Observable,   JSONObject .onErrorReturn(createJsonErrorHandler()) //    ,   .doOnNext(createCacheOperation()); // JSONObject</span></span></code> </pre><br>  We are almost done.  As in the very first example with RxJava, add a result handler and specify the threads in which to execute. <br>  Final version: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Subscription subscription = createApiRequestObservable() <span class="hljs-comment"><span class="hljs-comment">// Observable   .timeout(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS) //  .retry(RETRY_COUNT_FOR_REQUEST) // -  .onErrorResumeNext(createRequestErrorHandler()) //    .map(createJsonMapOperator()) // Observable,   JSONObject .onErrorReturn(createJsonErrorHandler()) //    ,   .doOnNext(createCacheOperation()); // JSONObject .subscribeOn(Schedulers.newThread()) // , ,     .observeOn(AndroidSchedulers.mainThread()) //   -  main thread .subscribe(subscriber); // </span></span></code> </pre><br>  Let's see what we have achieved here: <br><br><ol><li>  The principle of <b>fault tolerance</b> in action: the result of all operations is always predictable.  We know about all the errors and potentially problem areas that may occur in the code, and have already processed them.  There will be no exceptions. </li><li>  The principle of <b>responsiveness</b> in action: the connection to the database or server will not freeze due to timeout, will try to recover on error and, which is also important, will return the result immediately before caching.  And the caching in <code>doOnNext</code> will be executed in parallel with the processing of the result. </li><li>  The principle of <b>focus on events</b> in action: in the course of the execution of the request and parsing, we always respond to events - events of successful / unsuccessful completion of the request, the json parsing termination event (2 reactions: processing in the UI and processing in the backtrade for caching), etc. .  In addition, you can subscribe to one <code>Observable</code> several times and keep the entire system in a consistent state. </li><li>  The code is easily extensible and requires almost no changes.  If we need to log errors or save stackraces, we can add the <code>doOnError(Throwable thr)</code> method.  You want to filter the results - add a <code>filter</code> statement and implement its behavior. </li></ol><br>  As well as the disadvantages of AsyncTask's, the advantages of this approach, in my opinion, can be listed for a very long time.  The last of the principles of reactive programming, the principle of scalability, we will demonstrate below. <br><br><h4>  RxJava to 2GIS Dialer </h4><br>  Living example: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Observable     final Observable&lt;AggregatedContactData&gt; obs = Observable.combineLatest( createContactsObservable(context), //Observable      createPhonesObservable(context), //Observable      createAccountsObservable(context), //Observable        createJobsObservable(context), //Observable      contactsInfoCombinator() //    Observable  ).onErrorReturn(createEmptyObservable()).cache() //     .subscribeOn(Schedulers.executor(ThreadPoolHolder.getGeneralExecutor())) //       .observeOn(AndroidSchedulers.mainThread()); //     -  main thread</span></span></code> </pre><br><br><ol><li>  Here there is a lot of interesting and more complicated things described above: <br>  The first thing that catches your eye is <code>Observable.combineLatest(...)</code> .  This operator waits for <code>onNext(...)</code> from all <code>Observable</code> passed to it and applies the combining function to all results at once.  It may seem complicated, but the RxJava wiki image will make everything clearer.  The most important thing is that each of the <code>Observable</code> sent to <code>Observable.combineLatest(...)</code> is a <code>CursorObservable</code> , which sends a new cursor to its <code>onNext(...)</code> as it changes in the database.  Thus, a combination function is performed on any update to any of the four cursors, which allows you to always deliver the latest data.  This is the principle of focus on events. </li><li>  If something goes wrong, then we will return what is required based on our needs.  In this case, <code>Collections.emptyList();</code> </li><li>  The <code>cache()</code> operator is very useful if several <code>Subscribers</code> can subscribe to this <code>Observable</code> at once.  If this operator is applied to <code>Observable</code> , then its new subscriber instantly receives data, provided that this data has already been calculated for those who subscribed earlier.  Thus, everyone has the same current data. </li><li>  And here we see the principle of scalability: in <code>subscribeOn(...)</code> I give the thread pool to 4 threads so that each of my 4 <code>Observable</code> executed in a separate thread in order to maximize speed, RxJava takes care of the rest.  That is, all 4 processors will be involved, with the presence of these. </li></ol><br>  As you can see, the potential of reactive programming is huge, and RxJava functional realizes it sufficiently. <br><br><h4>  The problems we are facing </h4><br>  Everything shown above and much more in one form or another is used in our diler.  And here are the problems we faced: <br><br><ul><li>  OOM problem.  It would be naive to believe that Android can give a lot of threads for multi-threaded work.  With the number of threads greater than 15, even the top smartphones began to ‚Äúreflect‚Äù, and their small counterparts fell <code>OutOfMemoryError</code> with <code>OutOfMemoryError</code> .  The solution was simple.  Enter <code>CachedThreadPool</code> for these cases and the problem is solved. </li><li>  Query caching  This is not about the <code>cache()</code> operator from the example above.  I would like the next request for the same url to be immediately taken from the cache.  There is no such thing in RxJava.  In principle, this is correct, because reactivity and cache are two different things.  Therefore, we wrote our cache. </li></ul><br><h4>  What else? </h4><br>  We saw how cool it was to work responsively with multithreading and querying on Android.  But that's not all.  For example, you can subscribe to a <code>Checkable</code> change or <code>EditText</code> (this is out of the box in RxJava for Android).  Everything is simple, but terribly convenient. <br>  By the way, reactive programming for Java is not limited to one RxJava.  There are other libraries, for example, <a href="https://github.com/BoltsFramework/Bolts-Android">Bolts-Android</a> . <br>  In addition, <a href="http://www.reactive-streams.org/">Reactive-Streams is</a> being actively developed, which is intended to unify work with various jet providers in java. <br><br><h4>  Conclusion </h4><br>  Did we like it?  Definitely.  Reactive applications are really much more resistant to bugs and crashes, the code becomes clear and flexible (if it were lambda, it would be beautiful).  A lot of routine work is shifted to the library, which performs its work better than native Android components.  This allows you to focus on the implementation of things that are really worth considering. <br><br>  Reactive programming is a slightly different way of thinking compared to traditional Android development.  Data streams, functional operators - these complex, at first glance, things turn out to be much easier if you look into it.  It is worth a little work with reactive programming, and the brain begins to rebuild from objects and states to monads and operators on them.  This is such a big, kind, powerful piece of OP in OOP, which makes life and code simpler, and the application is better.  Try, you will not regret. <br><br>  Links that will help you deal with reactive programming or may just be interesting: <br><br><ul><li>  <a href="https://github.com/Netflix/RxJava/wiki">Wikipedia RxJava.</a> </li><li>  <a href="http://mttkay.github.io/blog/2013/08/25/functional-reactive-programming-on-android-with-rxjava/">Very sensible article</a> from the leading SoundHound programmer and RxJava evangelist for Android. </li><li>  <a href="http://www.reactivemanifesto.org/">Jet manifest.</a> </li><li>  <a href="http://www.reactive-streams.org/">Reactive-Streams.</a> </li></ul><br>  A small digression.  If you share our views on programming and creating products, then <a href="http://job.2gis.ru/vacancy/novosibirsk/id/695/">come</a> - we will be glad to see you in the 2GIS Dialer team. </div><p>Source: <a href="https://habr.com/ru/post/228125/">https://habr.com/ru/post/228125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228107/index.html">EMC XtremIO and VDI. Effective, but still raw stuff</a></li>
<li><a href="../228109/index.html">Efficient energy management in the data center</a></li>
<li><a href="../228115/index.html">Disaster Recovery Planning. Part Three - Final</a></li>
<li><a href="../228121/index.html">DIY projection screen</a></li>
<li><a href="../228123/index.html">Online Store Migration: Testing Your Shop on a Different Platform</a></li>
<li><a href="../228131/index.html">The infrastructure processing queues in the social network My World</a></li>
<li><a href="../228135/index.html">Ribs.js - nested attributes, computed fields and binding for Backbone.js</a></li>
<li><a href="../228137/index.html">Charles Herzfield: Director of DARPA and the Godfather of ARPANET</a></li>
<li><a href="../228139/index.html">How we stopped being afraid of Ogre and started making a game on it</a></li>
<li><a href="../228141/index.html">Mojolicious Documentation: Lost Chapters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>