<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deep immersion in test-driven javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many JavaScript frameworks offer their insight into how your code should look. Moreover, it‚Äôs not just about the style; it‚Äôs about the way the scripts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deep immersion in test-driven javascript</h1><div class="post__text post__text-html js-mediator-article">  Many JavaScript frameworks offer their insight into how your code should look.  Moreover, it‚Äôs not just about the style; it‚Äôs about the <i>way</i> the scripts are written.  This is due to the almost absolute democratic nature of JavaScript, yes, this is exactly what multiparadigmenny language with C-like syntax, prototype inheritance, dynamic typing and implementation varying from browser to browser is such.  Therefore, when it comes to test-driven JavaScript, I understand that this is not just a special programming style, but special technical principles for a special framework that allows you to test JS applications. <br><br>  In this article I will argue with myself what the testable JavaScript code is and how much it will cost if I start using it. <br><br>  <b>Attention: long post</b> <br><a name="habracut"></a><br>  Further, I will assume that the reader is somewhat familiar with <a href="http://qunitjs.com/">qUnit</a> and / or <a href="http://pivotal.github.io/jasmine/">Jasmine</a> .  Slightly walk on the tops in 10 minutes, for this article it is enough.  As usual, philosophy and generalization takes much more time and energy.  In fact, for myself, I answered all the questions put in the annotations to this article, I just had to read <a href="http://habrahabr.ru/post/191986/">it</a> and remember what unit tests <a href="http://habrahabr.ru/post/191986/">really</a> are.  The fact is that I never had to deal with front-end unit tests, so I was skeptical about this technology.  I will try to explain the main difficulties below.  I also ask you not to take the article as a manifesto for or against unit-testing client code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, we must remember that testing frameworks are different from each other.  I tried to get rid of the main differences, but no doubt that, for example, Jasmine gives more freedom in writing testable code than qUnit.  Nevertheless, the difficulties described in the article arise both there and there. <br><br>  And so it went. <br><br><h4>  Anonymous functions </h4><br>  The first question was: ‚ÄúOk, but how to test anonymous functions?  What should I do if my code is solid anonymous callbacks and other lambda magic? ‚Äù  The official documentation is quite accessible and explained what to do with asynchronous calls, but none of them was anonymous. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callBack = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ ... } someAsyncFunction(someOptions, callBack);</code> </pre>  and <br><pre> <code class="javascript hljs">someAsyncFunction(someOptions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ ... });</code> </pre><br>  A few different things, agree.  But JavaScript applications are full of such constructs.  Traditional jQuery design <br><br><pre> <code class="javascript hljs">$(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).ready(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// zomg teh lambda application })</span></span></code> </pre><br>  the goal is to prevent the application from running until the DOM is ready.  Or even the usual wrapping of an application into an anonymous function, so as not to clutter up the global namespace: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... })()</code> </pre><br>  It is not very clear how to test these functions if there is no access to them by identifier.  If their whole point is that they do not have access.  It turns out they need to provide access. <br><br><pre> <code class="javascript hljs">$(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).ready(Application) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Application</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// application }</span></span></code> </pre><br>  And now the application can be tested in qUnit like this: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'Application Constructor is loaded'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ok(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Application !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> , <span class="hljs-string"><span class="hljs-string">' '</span></span>); });</code> </pre><br>  But there is one problem.  What if I don't want to clutter up the global namespace?  Unfortunately, at least one name will have to fork out.  At a minimum, there is a practice like <a href="http://xunitpatterns.com/Back%2520Door%2520Manipulation.html">Backdoor Manipulation</a> .  Something similar in JS can be implemented through the global window object, in which you can create a property in which to store a link to the application, for example: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Application</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } window.testBackdoor = { Application : new Application() }; //   Application(),     })(window) //       . var app = window.testBackdoor.Application; test('Application Constructor is loaded', function () { ok(app !== undefined , ' '); });</span></span></code> </pre><br>  Like this.  But we introduce an extra construction and this still does not save us from unnecessary names in the window object.  It is sad.  At this stage, my internal debater asks a reasonable question: actually, why are you testing the application as a whole, where are the <b>unit tests</b> ?  Fair  I am testing the entire application.  But after all, these are the applications on JS most often, they are (almost) always the essence of a whole.  No one will select the application logic from the part that processes the data, connect these modules in different ways, if this is really not a giant application that needs just such an approach.  Not every application needs such things as require.JS. <br><br>  <b>Argument # 1:</b> It is necessary to divide the application into different pieces-models and test them separately, because this is the point of unit tests.  Each unit can have its own namespace (by implementing the entire unit in a separate function) and the problem is solved. <br><br>  <b>Counter Argument # 1:</b> JavaScript is not an OOP language in the classical sense, so that it is possible to test class methods.  The implementation of OOP, which provides the ability to test individual objects in JavaScipt, is fraught with problems of excessive code.  (The statement, to which I will not cite rigorous evidence, just remind you that there are no public and private keys in JS. Moreover, it suffices to recall what classes that are dear to the heart and their inheritance in CoffeeScript turn into when they are translated into JavaScript). <br><br>  But since test-driven JavaScript exists, then there is such a style to organize an object model of the application so that it can be tested ... <br><br><h4>  Inheritance </h4><br><br>  In general, OOP, prototypical inheritance, and so on in JavaScript is a fertile ground for a heated debate, which has no place in this article.  But before you start exploring inheritance in a test-driven context, I recommend reading <a href="http://www.crockford.com/javascript/inheritance.html">Douglas Crockford</a> and Nicholas Zakas in Optimizing JavaScript Applications to keep up with the positive and negative aspects of various ways of organizing inheritance in JavaScript. <br><br>  Probable inheritance is probably one of those parts that pleasantly surprised me because it didn‚Äôt cause unnecessary trouble when I followed the canonical prototype inheritance in JavaScript.  Indeed, if we have access to an object, then we can immediately access its methods and immediately test them up and down.  For example, I add to the prototype of an object a function to calculate the absolute value of a number: <br><br><pre> <code class="javascript hljs">myObject.prototype.abs = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> ? x : -x;} <span class="hljs-comment"><span class="hljs-comment">//        myObject.abs</span></span></code> </pre><br>  All this simplicity comes at the expense of one detail, which many consider to be a significant disadvantage of JavaScript.  This is what the object does not have private and public properties.  They are all available.  Thus, we again arrive at the fact that only those functions and methods accessed can be tested.  One has only to start imitating public and private properties of an object, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myClass</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> that = { <span class="hljs-attr"><span class="hljs-attr">publicMethod</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that; }</code> </pre><br>  Access to the closure of publicMethod is feasible, since an object is returned that contains it as a property.  The problem is that there is no way to get access to the privateMethod function from the outside, although it takes place in the scope of the myClass function, and within all closures of myClass you can refer to it, but for any other scope level there is no access to the function.  Returning to paragraph 1. <br>  This is especially significant when we write applications where a traditional OOP template is used, in which there are several objects with a variety of methods, internal logic and other things where there is no factory method for generating many instances and their inherited instances.  Shortly speaking‚Ä¶ <br><br>  <b>Argument # 2:</b> If you use the traditional JavaScript prototype inheritance, then the entire object model of the application is automatically available for tests without any extra effort. <br><br>  <b>Counter Argument # 2:</b> There are a thousand and one ways to implement inheritance (many of which are quite popular) in JavaScript, which deprive a developer of access to the methods of a class instance. <br><br>  The problem of implementing inheritance and object programming in test-driven JavaScript is that some methods affect the state of the instance as a whole.  How can we test that, at a certain event, the instance changed some internal property that does not depend on other functions, for example, when the cursor hovers over its color, it changes its color?  Provided that we trust those frameworks with the help of which we implement this mapping.  But a lot of things that we do with the help of different frameworks change states and only states. <br><br>  Unfortunately, the ideas of unit testing are at odds with reality.  Nobody (almost no one) develops a model, then writes JavaScript - a script, and then only does a GUI for this case, most often everything happens quite the opposite, the programmer gets the application interface and hears "make it work."  I'm not saying that the first case is impossible or redundant, on the contrary - this is the best way, but alas, the front-end is what is perceived as a development stage that serves to <i>display the</i> work of the back-end. <br><br>  Returning to the topic of system states, I come to the main problem.  Suppose that we absolutely trust every jQuery and are confident that a function that receives a string of the form "# 000000" in the argument will paint the figure in this color and do it without errors.  Suppose that frameworks for working with DOM, and those involved in other mappings, are not as important to test as the functions where the data is processed in the application.  But how to separate one from the other?  How to write pure functions that it makes sense to test without adding side effects there? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ a = x; }</code> </pre><br>  This feature is not clean, alas.  It receives data and changes the state of the system (the value of the variable <code>a</code> ). <br><br><h4>  Pure functions </h4><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">Pure functions</a> are good.  Well, when the functions do not change the state of the system.  When functions receive data, they do something with it and return data.  And they do nothing more. <br>  But in JavaScript there are two nuances. <br>  <i>First</i> : In JavaScript, functions are objects, and systems are in general objects, that is, system states are constructed by functions.  System states are states of functions.  There is no clear separation of the concept object and method.  Everything ultimately merges into zen objects or functions, if you like.  In other words, functions we construct objects, functions we calculate data and transfer them to functions that change the original objects.  <i>(there should be a picture with Xzibit and the caption 'Yo dawg')</i> <br>  <i>Second</i> : Isn't the essence of client-side JavaScripta a side effect?  That is, in the display, in the dynamization.  When was the last time you took some brutal Riemann integral to return the resulting data to the user in the browser console?  I would be very surprised if someone at least once had to solve such tasks on the client side, and without display.  If the application does not have any important logic, but only one mapping, then in essence there is nothing to test here. <br><br>  Here is a pretty textbook example: <br>  It is given an input; it is necessary to initiate validation of the content of the input by a regular expression by the keydown event.  If the entered string is valid, then we paint the input in green, otherwise in red. <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#myPrettyInput"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(___){ ...     }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ ...     } });</code> </pre><br>  To separate data processing (validation) from side effects (changing CSS), you can do the following: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#myPrettyInput"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).val(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regex = ... -  ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(validate(val, regex){ <span class="hljs-comment"><span class="hljs-comment">//     }else{ //     } }); var validate = function(str, rgx){ //    .  true  false };</span></span></code> </pre><br>  On the one hand, what's wrong?  Think about the extra function written?  Indeed, in the first case, most likely if there would be some kind of ugly expression like <code>$(this).val().match(regex).length</code> , and now we have quite a neat function.  It does not matter that in the body of the function the same expression, the main thing it can be tested!  Indeed, on such a simplified example, everything looks quite justified and decent.  It seems that we have achieved testability by selecting only one function, but ... <br><br>  <b>Argument # 3:</b> We got testable code and at any time we can check if our validation works or not by writing as many automated tests as we like.  In addition, we got rid of giant expressions in the event handler. <br><br>  <b>Counter Argument # 3:</b> We entered another variable.  But what if the validation is not so simple, but includes the ajax challenge?  For example, check whether the username is busy.  And in order to realize the separation of side effects from strict data processing, something more is needed than to deduce a function from an event handler. <br><br>  Counter example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> validate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, regex</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_____regexp){ $.ajax({ ... succsess : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -,       //    data } }) } ... }</span></span></code> </pre><br>  Unfortunately, one callback identification is indispensable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> validate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str, regex</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ajax_validate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    data } if(_____regexp){ $.ajax({ ... success : function(data){ if(ajax_validate(data)){ ... - - } } }) } ... }</span></span></code> </pre><br>  Of course, in the previous listing, the ajax_validate function is clean (returns the result of validation, and this is always either true or false), but you can‚Äôt test it anyway, because it is a variable inside validate.  Make it a validate closure?  Stupid solution - from this validate turns into a class, ceases to be clean.  Can then turn all strict checks that return true or false into the closures of any individual module that will be occupied exclusively by all sorts of validations in the application?  In terms of testability - this is quite a satisfactory solution, in terms of modularity, too.  But I hope you have traced how the amount of work has increased.  And I, in fact, did not add anything special to the application.  I ask myself, where is the golden mean? <br><br>  It seems logical to answer the question that you need to put data handlers in one heap, event handlers in another.  So I refuse to test the part that colors the input in the desired color, and I concentrate on making it possible to test the part of the program where it is <i>calculated what color to paint the input</i> .  But again, with the proviso that if the application is not too large / complex / intricate.  If it really is, then it is better, yes, to introduce an extra module, to spend time, but to achieve testability and ease of further use.  And if the application does not require special tricks, I would do this: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#myPrettyInput"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).val(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(validate(val,regex)){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ajaxValidationResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; $.ajax({ ... success : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ajax_validate(data)){ ajaxValidationResult = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   - } } ... }); setTimeout(function(){ if(ajaxValidationResult){ //     }else{ //        ,    setTimeout(arguments.callee, 75); } }) }else{ //    } }); //         var validate = function(str, regex){ ... } var ajax_validate = function(data){ ... }</span></span></code> </pre><br>  For me, this is quite an acceptable ratio of extra work to the benefits of testability.  But the golden mean, I can not call it.  What are my solutions?  In fact, no universal.  Inside JavaScript there are many possibilities built in to make it as testable as you wish.  This is where the functional nature of JavaScript comes up.  Where it is possible to transfer functions in functions and return functions too.  This is convenient in the sense that the application logic can be executed in a fairly free declarative style (this is the part that is not related to unit tests), while those parts of the program that are responsible for processing the data remain testable.  I often use the following scheme: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vehicle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        var somePrivateMethod = function(){ ... } var that = { //       somePublicMethod : function(){ ... } } return that; } function Car(){ //        var that = Vehicle(); //     var that.anotherPublicMethod = function(){ ... } return that; } function IndependentModule(){ // ,       vat that = { independentFunction : function() { ... } } return that; } function Factory(){ var that = { car : Car(), bicycle : Vehicle(), } return that; } window.testBackdoor = { Factory : Factory(), Module : IndependentModule() }; // return { Factory : Factory(), Module : IndependentModule() }; }</span></span></code> </pre><br><br>  In this way, it is possible to access closures of any class.  At the end, I can choose a method of accessing either through a backdoor or simply returning the desired object.  However, such an imitation of public / private methods as a whole does not fulfill the very idea of ‚Äã‚Äãpublic / private methods, but serves only as a demarcation between functions accessible from other areas or not, which is a rather ugly add-in to ensure testability, and not for public separation. and private methods of classical OOP.  In this way it makes more sense to separate the pure functions and functions with side effects.  In addition, it is also necessary to remember that such an organization of the structure of an application is far from the most productive and is more suitable for large multi-connected applications with several modules than for applications that use multiple instances of classes. <br><br>  Returning to the separation of data processing and display, I will say that some libraries force the separation of pure functions from side effects (mostly functional and / or declarative).  Others unfortunately do not particularly support this idea.  Although for the time that I am familiar with JavaScript, I am convinced that nothing is impossible.  The question is completely different.  What effort? <br>  For example, in <a href="http://wmbtrmb.blogspot.ru/2014/01/qunit.html">this article</a> , I am testing a fairly simple application (toy) and because as I use bacon.js - a declarative library, the essence of which is to save the developer from the hell of nested callbacks hanging from the event listeners, I generally managed to bring the application without unnecessary losses to testable mind. <br><br>  <b>Summary:</b> <br>  Unfortunately, nothing more intelligible than a rather banal ‚Äúevery instrument is appropriate in its place‚Äù I cannot say.  I have used qUnit and Jasmine only a few times in testing client code for more or less large applications.  But these were the cases where I had not already written a single line of code already anticipating how exactly in this application I can separate side effects from data processing, and that if I write testable code, the application does not turn into unintelligible stuffing. <br><br>  Finally, I would like to say that the very idea of ‚Äã‚Äãunit testing fits well with the modular essence of NodeJS.  Shooting in this article also test-driven programming on the NodeJS platform would be superfluous, although the topic is definitely exciting.  Therefore, if anyone is interested, I will write about it in the next article. </div><p>Source: <a href="https://habr.com/ru/post/209936/">https://habr.com/ru/post/209936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209924/index.html">Burn after reading</a></li>
<li><a href="../209926/index.html">New beta Yandex. Browser 14.2: improved download manager and view office documents</a></li>
<li><a href="../209928/index.html">The main events of 2013 through the eyes of Chris Graft (Kris Graft), editor in chief of Gamasutra</a></li>
<li><a href="../209932/index.html">Testing Stored Functions with pgTAP</a></li>
<li><a href="../209934/index.html">"Perfect" cluster. Part 2.2: Highly available and scalable web server, the best technologies to guard your business</a></li>
<li><a href="../209940/index.html">Intel Quark. Better late than never</a></li>
<li><a href="../209944/index.html">Who is who: Smart watches</a></li>
<li><a href="../209946/index.html">Bitcoin cryptocurrency began to take in Las Vegas</a></li>
<li><a href="../209948/index.html">Performance testing and OpenStack profiling</a></li>
<li><a href="../209950/index.html">Research security sites on various CMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>