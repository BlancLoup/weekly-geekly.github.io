<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional programming with PHP generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Generators are cool. They make it easy to write iterators by defining functions instead of creating entire classes that implement Iterator . Generator...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional programming with PHP generators</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/jq/79/dc/jq79dcwan-mtwdketkb9fxg-nmi.jpeg"></p><br><p> Generators are cool.  They make it easy to write iterators by defining functions instead of creating entire classes that implement <code>Iterator</code> .  Generators also help create lazy lists and endless streams.  The main difference between the generator function and the usual function is that the normal one can return only once (after that its execution stops), and the generator function can produce several values ‚Äã‚Äãduring execution.  In this case, in the intervals between returns, the execution of the generator is paused until the next start.  Therefore, generators can be used to create lists with lazily generated values, that is, each element in the list is calculated only at the time of demand. </p><a name="habracut"></a><br><p>  A vivid example of the difference between early and lazy generation is the range function, which takes the <code>start</code> and <code>end</code> parameters and then returns a sequence of integer values ‚Äã‚Äãthat begins with <code>start</code> and ends one element before <code>end</code> .  In the case of a regular function, you will have to create a new list, add all the elements to it, and then return the list.  With this approach, <code>range</code> consumes a memory size proportional to the size of the range.  And depending on your environment <code>range(1, 10000000)</code> can tidy up all the memory allocated by the PHP process.  And this happens because of the early creation of the entire list of elements, even before the caller returns. </p><br><p>  Using the generator function, you can create a lazy <code>range</code> that uses a constant amount of memory.  This is achieved using a while loop, which passes the value of the initial parameter and then increments the value of the initial argument.  When the cycle ends, the function reaches the end of its body and returns a value, thereby completing the operation of the generator.  That is, it is enough for the generator function to keep track of which sequence value should be returned, and not to store all values ‚Äã‚Äãin memory.  If we continue the example, then we can create an infinite range generator function that takes only the initial argument.  In this case, we will have a while loop with a predicate that is always true, so the loop never ends.  This allows the calling function itself to decide how many values ‚Äã‚Äãto read from the generator.  And if the infinite generator is called 100 times, then it will generate only 100 values.  If it is no longer called before the calling function is completed, the generator will pause, and eventually the garbage collector will clean it up.  In other words, if you use <code>foreach</code> iterate a generator that creates an infinite stream of values, the generator will iterate endlessly.  The PHP documentation describes well the work of generators and an example with the <code>range</code> function. </p><br><p>  But a more practical illustration: the program needs to get 200,000 objects from the external API, extract some subset of data from each document, and then place each modified object in the repository.  If everything is done immediately, you will have to first create a list of 200,000 objects, then delete the elements from the list and then modify each element before adding it to the repository.  If for these stages to use tools like <code>array_filter</code> and <code>array_map</code> , then at each of the listed operations an intermediate list is created.  By combining generators, you can create a pipeline, each stage of which is calculated in a lazy way.  For example, you can use a generator that is lazy and individually picks up objects from the API.  Such a generator can be used by another generator, which only creates objects that pass a certain test, and already this second generator will be used by the third generator, which creates a modified version of the object received from the API. </p><br><h3 id="generatory-v-php">  PHP generators </h3><br><p>  Since generator functions return objects that implement <code>Iterator</code> , they can be used in the same place as iterators, as is the case with <code>foreach</code> .  Unfortunately, generators cannot be inserted anywhere an array can be used.  This is true, for example, for <code>array_map</code> , <code>array_reduce</code> and <code>array_filter</code> .  It‚Äôs a pity, because I prefer these functions instead of more imperative <code>for</code> and <code>foreach</code> cycles.  In <a href="https://github.com/ifixit">iFixit</a> , <a href="https://github.com/ifixit">we</a> use several <code>Iterator</code> based alternatives instead of arrays that provide the same functionality as <code>array_map</code> , <code>array_filter</code> with <code>array_reduce</code> . </p><br><p>  <em>Note: all of these examples need PHP 7.1 functionality.</em>  <em>In previous versions of the language, the code will not work.</em> </p><br><h3 id="map">  Map </h3><br><pre> <code class="hljs xml"><span class="php"><span class="hljs-meta"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span><span class="php"> </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">declare</span></span></span><span class="php">(strict_types = </span><span class="hljs-number"><span class="php"><span class="hljs-number">1</span></span></span><span class="php">); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** * Like array_map() but over an iterable, and it returns a new iterable with * mapping instead of a mapped array. The callable should take two arguments: * a value to map and its key in the stream. */</span></span></span><span class="php"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="php"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="php"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="php"><span class="hljs-function"><span class="hljs-title">iterator_map</span></span></span></span><span class="hljs-params"><span class="php"><span class="hljs-function"><span class="hljs-params">(callable $cb, iterable $itr)</span></span></span></span><span class="php"><span class="hljs-function">: </span></span><span class="hljs-title"><span class="php"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span></span><span class="php"><span class="hljs-function"> </span></span></span><span class="php">{ </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">foreach</span></span></span><span class="php"> ($itr </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">as</span></span></span><span class="php"> $key =&gt; $value) { </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">yield</span></span></span><span class="php"> $cb($value, $key); } }</span></span></code> </pre> <br><p>  Map converts, or ‚Äúmap‚Äù one list of values ‚Äã‚Äãinto another, applying a transforming function to each value of the input list and adding the result to the output list.  The basis of <code>iterator_map</code> is the same idea, only the function as the second argument contains the result of calling the converter function for each element of the list to be iterated. </p><br><pre> <code class="hljs perl">&lt;?php // assuming range_generator is a range function that returns a // generator <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a list. $bigList = range_generator(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100000000</span></span>); $bigListPlusOne = iterator_map(function($num) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $num + <span class="hljs-number"><span class="hljs-number">1</span></span>; }, $bigList); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> At this point <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> work has been done. // $bigListPlusOne is a generator that will lazily produce // all numbers from <span class="hljs-number"><span class="hljs-number">2</span></span> to <span class="hljs-number"><span class="hljs-number">100000000</span></span> // (<span class="hljs-number"><span class="hljs-number">100000000</span></span> because the end of the range is exclusive)</code> </pre> <br><h3 id="filter">  Filter </h3><br><pre> <code class="hljs xml"><span class="php"><span class="hljs-meta"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span><span class="php"> </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">declare</span></span></span><span class="php">(strict_types = </span><span class="hljs-number"><span class="php"><span class="hljs-number">1</span></span></span><span class="php">); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** * Like array_filter() but over an iterable, and it returns a new iterable with * filtering instead of a filtered array. The callable, if non-null, should * take arguments like iterator_map(). When the callable is null, null values * will be filtered out (NOT falsey values, just x === null). */</span></span></span><span class="php"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="php"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="php"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="php"><span class="hljs-function"><span class="hljs-title">iterator_filter</span></span></span></span><span class="hljs-params"><span class="php"><span class="hljs-function"><span class="hljs-params">(?callable $cb, iterable $itr)</span></span></span></span><span class="php"><span class="hljs-function">: </span></span><span class="hljs-title"><span class="php"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span></span><span class="php"><span class="hljs-function"> </span></span></span><span class="php">{ $cb = $cb ?: </span><span class="hljs-function"><span class="hljs-keyword"><span class="php"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-params"><span class="php"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span></span><span class="php"><span class="hljs-function"> </span></span></span><span class="php">{ </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">return</span></span></span><span class="php"> $x !== </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">null</span></span></span><span class="php">; }; </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">foreach</span></span></span><span class="php"> ($itr </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">as</span></span></span><span class="php"> $key =&gt; $value) { $keep = $cb($value, $key); </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">if</span></span></span><span class="php"> ($keep) { </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">yield</span></span></span><span class="php"> $value; } } }</span></span></code> </pre> <br><p>  Filter takes a list and creates a new one, which includes those elements from the input list, which, when passed to the filter or <strong>predicate</strong> function, generate a ‚Äútrue‚Äù (truthy) value.  At the core of <code>iterator_filter</code> is the same idea, only the function returns only those values ‚Äã‚Äãthat generate true values ‚Äã‚Äãwhen passed to the predicate.  If the value does not generate a ‚Äútrue‚Äù value, the generator does not produce this element and goes to the next of the input <code>iterable</code> until some element generates a ‚Äútrue‚Äù value for the predicate.  Then the filter returns the value and pauses until it is called again. </p><br><h3 id="reduce">  Reduce </h3><br><pre> <code class="hljs xml"><span class="php"><span class="hljs-meta"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span><span class="php"> </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">declare</span></span></span><span class="php">(strict_types = </span><span class="hljs-number"><span class="php"><span class="hljs-number">1</span></span></span><span class="php">); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** * Like array_reduce() but over an iterable, and it returns a single value as * the result of calling $cb over the contents of iterable $itr. * * If $initial is not null, $initial is set to the value of the first element * of the iterable, and $cb is called with the first element as the carry value * and the second element of the array as the current value. */</span></span></span><span class="php"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="php"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="php"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="php"><span class="hljs-function"><span class="hljs-title">iterator_reduce</span></span></span></span><span class="hljs-params"><span class="php"><span class="hljs-function"><span class="hljs-params">(callable $cb, iterable $itr, $initial = null)</span></span></span></span><span class="php"><span class="hljs-function"> </span></span></span><span class="php">{ </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">if</span></span></span><span class="php"> (is_null($initial)) { $initial = $itr-&gt;current(); $itr-&gt;next(); } $carry = $initial; </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">while</span></span></span><span class="php"> ($itr-&gt;valid()) { $carry = $cb($carry, $itr-&gt;current()); $itr-&gt;next(); } </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">return</span></span></span><span class="php"> $carry; }</span></span></code> </pre> <br><p>  Reduce takes a list and an optional initial value, and returns a value that is the result of applying a reducer function to each element.  The convolutional function has a parameter <code>carry</code> , which contains the result of calling this function as applied to the previous element, and also has the parameter <code>current</code> , which is the current element in the iterated sequence.  In some languages, this operation is called folding. </p><br><p>  <code>iterator_reduce</code> slightly different from the previous two functions, since it does not have an <code>iterable</code> return type <code>iterable</code> .  The function can create single values ‚Äã‚Äã- numbers, boolean or lowercase.  All this is useful when you need to get a list or a generator and extract from it grouped or aggregated values, such as the sum of the <code>price</code> properties in the list of <code>Product</code> objects. </p><br><h3 id="sobiraem-vsyo-vmeste">  Putting it all together </h3><br><p>  Now let's take everything discussed together in one small example.  We will retrieve data from an online storage service (let's call it Storeify).  The program's task: to extract all orders of the previous day and calculate the total daily income from the sale. </p><br><p>  In our hypothetical world, there can be from 100 to 1,000,000,000 orders per day, so we cannot just get them all from the API without being charged a huge server account that can simultaneously store orders in memory.  Let's create a generator for lazy retrieving orders from the Storeify API as needed. </p><br><p>  With the help of <code>map</code> , <code>filter</code> and <code>reduce</code> we divide the problem into tasks in order to make it easier to understand the program and accompany it.  Since we only need positions or products in each order, we use <code>iterator_map</code> to return positions, as well as the <code>flatten</code> function to turn the list of position lists into a single list.  After that, select the <code>iterator_filter</code> to filter out those positions that are not products that we analyze.  Next, we take the stream of filtered products and with the help of <code>iterator_reduce</code> turn their <code>price</code> and <code>quantity</code> fields into the total income for this product for the previous day. </p><br><pre> <code class="hljs bash">&lt;?php <span class="hljs-built_in"><span class="hljs-built_in">declare</span></span>(strict_types = 1); /** * Example code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> consuming data from a Store API (called Storeify) and chaining generators * together to filter, map, and eventually reduce all Order data into a * daily revenue total. */ <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getOrdersFromLastDay(): iterable { <span class="hljs-variable"><span class="hljs-variable">$limit</span></span> = 20; <span class="hljs-variable"><span class="hljs-variable">$requestParams</span></span> = [ <span class="hljs-string"><span class="hljs-string">'lastUpdatedAfter'</span></span> =&gt; new DateTime(<span class="hljs-string"><span class="hljs-string">'yesterday'</span></span>), <span class="hljs-string"><span class="hljs-string">'limit'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$limit</span></span>, <span class="hljs-string"><span class="hljs-string">'offset'</span></span> =&gt; 0 ]; <span class="hljs-variable"><span class="hljs-variable">$orders</span></span> = []; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { // Grab a batch of orders from Storeify and yield from that list. <span class="hljs-variable"><span class="hljs-variable">$orders</span></span> = Storeify::getOrders(<span class="hljs-variable"><span class="hljs-variable">$requestParams</span></span>); yield from <span class="hljs-variable"><span class="hljs-variable">$orders</span></span>; <span class="hljs-variable"><span class="hljs-variable">$requestParams</span></span>[<span class="hljs-string"><span class="hljs-string">'offset'</span></span>] += <span class="hljs-variable"><span class="hljs-variable">$limit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!empty(<span class="hljs-variable"><span class="hljs-variable">$orders</span></span>)); } /** * Consumes a generator that produces lists of products * and produces a new generator that yields a flat list * of products. */ <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> flatten(iterable <span class="hljs-variable"><span class="hljs-variable">$itr</span></span>): iterable { foreach (<span class="hljs-variable"><span class="hljs-variable">$itr</span></span> as <span class="hljs-variable"><span class="hljs-variable">$products</span></span>) { yield from <span class="hljs-variable"><span class="hljs-variable">$products</span></span>; } } /** * Assume orders have a Shipping Country and a list of Products * [ * <span class="hljs-string"><span class="hljs-string">'ShipCountry'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'US'</span></span>, * <span class="hljs-string"><span class="hljs-string">'Products'</span></span> =&gt; [ * [ <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Pro Tech Toolkit'</span></span>, <span class="hljs-string"><span class="hljs-string">'price'</span></span> =&gt; 59.95, <span class="hljs-string"><span class="hljs-string">'quantity'</span></span> =&gt; 2], * [ <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'iPhone 6 Battery'</span></span>, <span class="hljs-string"><span class="hljs-string">'price'</span></span> =&gt; 24.99, <span class="hljs-string"><span class="hljs-string">'quantity'</span></span> =&gt; 1] * ] * ] */ <span class="hljs-variable"><span class="hljs-variable">$orders</span></span> = getOrdersFromLastDay(); // Flatten list of orders into list of all products sold. <span class="hljs-variable"><span class="hljs-variable">$allProducts</span></span> = flatten(iterator_map(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-variable"><span class="hljs-variable">$order</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$order</span></span>[<span class="hljs-string"><span class="hljs-string">'Products'</span></span>]; }, <span class="hljs-variable"><span class="hljs-variable">$orders</span></span>)); // Only include <span class="hljs-string"><span class="hljs-string">'Pro Tech Toolkit'</span></span> purchases. <span class="hljs-variable"><span class="hljs-variable">$toolkitProducts</span></span> = iterator_filter(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-variable"><span class="hljs-variable">$product</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$product</span></span>[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] === <span class="hljs-string"><span class="hljs-string">'Pro Tech Toolkit'</span></span>; }, <span class="hljs-variable"><span class="hljs-variable">$allProducts</span></span>); // Up until this point, no work has actually been <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. // <span class="hljs-variable"><span class="hljs-variable">$toolkitProducts</span></span> is a generator can be passed around to other <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span> // as a lazy stream of pro tech toolkit products. // Once iterator_reduce is called, it begins winding its way through // the composed generators and actually pulling down resources from the Store API // and mapping and filtering them. <span class="hljs-variable"><span class="hljs-variable">$dailyToolkitRevenue</span></span> = iterator_reduce(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-variable"><span class="hljs-variable">$total</span></span>, <span class="hljs-variable"><span class="hljs-variable">$toolkit</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$total</span></span> + (<span class="hljs-variable"><span class="hljs-variable">$toolkit</span></span>[<span class="hljs-string"><span class="hljs-string">'price'</span></span>] * <span class="hljs-variable"><span class="hljs-variable">$toolkit</span></span>[<span class="hljs-string"><span class="hljs-string">'quantity'</span></span>]); }, <span class="hljs-variable"><span class="hljs-variable">$toolkitProducts</span></span>, 0);</code> </pre> <br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Perhaps the use of generators in functional programming can be called doping.  Unfortunately, PHP is not an ideal language, but, fortunately, we have all the tools for combining generators with functional concepts like <code>map</code> , <code>filter</code> and <code>reduce</code> . </p><br><h3 id="obnovlenie-20180318">  Update (2018‚Äì03‚Äì18) </h3><br><p>  A commentator from the r / programming branch mentioned the <code>iter</code> library written by a person who implemented PHP generators.  This library implements all the examples from this article and much more, so I highly recommend to feel it if you plan to use generators in your code base. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351818/">https://habr.com/ru/post/351818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351806/index.html">"Calendar tester" for March. Test security</a></li>
<li><a href="../351808/index.html">Using kubernetes to develop blockchain projects on Hyperledger Fabric</a></li>
<li><a href="../351810/index.html">Live broadcast from Vue.js Moscow Meetup # 1</a></li>
<li><a href="../351812/index.html">Analysis of performance tasks with JBreak (part 4)</a></li>
<li><a href="../351816/index.html">The peaceful atom: Japan will build the most powerful supercomputer for nuclear research</a></li>
<li><a href="../351820/index.html">What is in the new JupyterLab for users?</a></li>
<li><a href="../351822/index.html">We open statistics on the sources of views and responses on ‚ÄúMy Circle‚Äù</a></li>
<li><a href="../351824/index.html">A look at Tokio: how this asynchronous event handler works</a></li>
<li><a href="../351826/index.html">A couple of stories about RAID'ersky lawlessness</a></li>
<li><a href="../351828/index.html">Welcome to Badoo PHP Meetup April 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>