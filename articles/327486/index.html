<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Paparazzo. Powerful, stylish, your own. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part of the story of the mediapicker Paparazzo 
 In the first part, we talked about how we came to our media pick-up and how many options we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Paparazzo. Powerful, stylish, your own. Part II</h1><div class="post__text post__text-html js-mediator-article"><hr>  <a href="https://habrahabr.ru/company/avito/blog/326774/">The first part of the story of the mediapicker Paparazzo</a> <hr><br>  In the first part, we talked about how we came to our media pick-up and how many options we‚Äôve touched before, and now it's time to continue the story. <br><br> <a href="https://habrahabr.ru/company/avito/blog/327486/"><img src="https://habrastorage.org/getpro/habr/post_images/879/e7e/59e/879e7e59e3fffe43c7144c3e78fda6a7.png"></a> <br><a name="habracut"></a><br><h2>  Different sources of photos </h2><br>  The next challenge we faced was that the photos in MediaPicker could come from three different sources: <br><br><ul><li>  Photos taken with the camera were saved on a disk in the application folder. <br></li><li>  We could also select photos from the user's photo gallery. <br></li><li>  Finally, when opening an already posted ad for editing, they pulled out of the network. <br></li></ul><br>  Of course, we wanted to have one entity, not three, so that in the code that works with photos, there was no need to make ugly branches, and to protect it from changes, if suddenly some new data source appears. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We have identified 4 actions that need to be performed when working with an image: <br><br><ul><li>  The most frequent action is, of course, the mapping in the interface.  Moreover, it would be nice if we didn‚Äôt have enough for each small thumbnail of a photo, of which there can be quite a lot on the screen, to keep in memory full-sized photos of 3 by 4 thousand pixels. <br><br></li><li>  Next comes the acquisition of the original image - for example, to be sent to a server or saved to disk.  Again, here we want to load the memory as little as possible, and we have a rather compressed representation in the form of NSData - no need to waste system resources to decode a photo from, say, JPEG in bitmap. <br><br></li><li>  It is also sometimes necessary to find out the size of the image, and it is also best to do this in the most optimal way - that is, if it is possible, not to download it completely and not to forget about it for them.  Often, the size can be obtained from the file metadata, or it can be sent to us by the server by a separate property of the JSON structure next to the URL. <br><br></li><li>  Finally, if the image is being downloaded from the network, but at some point we realize that we definitely will not need it (for example, we closed the screen on which it should have appeared), it would be nice to be able to cancel the download. <br></li></ul><br>  Well, of course, due to the fact that the image may not be available locally at the moment when we need it, the API for the first three points must be asynchronous.  In order to display the image in the UI, without loading the memory with redundant data, you need to find out what size we need. <br><br><ol><li>  To do this, you need to know the size of the area in which the display will take place and how we want to use it: whether we want to completely fit the image into it or we can sacrifice some of its parts so that there is no free space inside (similar to the content mode aspectFit and aspectFill in UIView). <br><br></li><li>  Since the API must be asynchronous, we need a handler in which we pass the resulting image to the UIImageView. <br><br></li><li>  It may also happen that we need to upload a photo from the network, but at the same time, we locally have a cached version of the same image, but smaller.  And it turns out that if at boot time we substitute this reduced version into the view, the user will get the impression that the download is faster. <br><br></li><li>  Therefore, the deliveryMode parameter does not interfere either, putting down a progressive value, we kind of say that it is not against the bad versions of the requested picture, and the handler can be called several times as the quality increases.  Best will mean that we want the handler to volunteer only once with the best version of the picture. <br></li></ol><br>  Accordingly, the method of requesting a picture with the listed parameters may look something like this. <br><br><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( viewSize: CGSize, contentMode: ContentMode, deliveryMode: DeliveryMode, handler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UIImage?)</span></span></span></span></span></span> -&gt; ())</code> </pre> <br>  Reduce it by combining the first three parameters in the structure.  This will allow us to add other parameters as needed without changing the method signature. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( options: ImageRequestOptions, handler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UIImage?)</span></span></span></span></span></span> -&gt; ()) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageRequestOptions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contentMode: <span class="hljs-type"><span class="hljs-type">ContentMode</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> deliveryMode: <span class="hljs-type"><span class="hljs-type">DeliveryMode</span></span> }</code> </pre> <br>  The resulting version still needs work.  First, in the handler clouge parameter, the UIImage type is explicitly specified, but we wanted to get rid of UIKit so that this method could be used not only on iOS. <br><br>  Therefore, the UIImage must be replaced with something that can later be turned into a UIImage.  There is a type that meets this criterion and is present on both iOS and macOS - this is a CGImage. <br><br>  Therefore, we create the InitializableWithCGImage protocol. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InitializableWithCGImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(cgImage: <span class="hljs-type"><span class="hljs-type">CGImage</span></span>) }</code> </pre> <br>  By a happy coincidence, UIImage and NSImage already have such initializers, so all we have to do is add empty extensions for these classes, formally describing their compliance with this protocol. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InitializableWithCGImage</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSImage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InitializableWithCGImage</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Replacing the UIImage with this protocol, we obtain such a method signature. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-function">&lt;T: InitializableWithCGImage&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( options: ImageRequestOptions, handler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(T?)</span></span></span></span></span></span> -&gt; ())</code> </pre> <br>  Finally, care should be taken to ensure that the request can be canceled.  To do this, add the ImageRequestId return value to the requestImage method, which will allow us to further identify the request. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-function">&lt;T: InitializableWithCGImage&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( options: ImageRequestOptions, handler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(T?)</span></span></span></span></span></span> -&gt; ()) -&gt; <span class="hljs-type"><span class="hljs-type">ImageRequestId</span></span></code> </pre> <br>  There is one more small change. <br><br>  I said earlier that if you set the deliveryMode value to progressive, the handler can be called several times.  It would be nice inside this handler to understand whether it volunteered with the final or intermediate version of the image.  Therefore, we will transfer to it the ImageRequestResult structure, which, in addition to the image itself, will contain other useful information about the result of the request. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-function">&lt;T: InitializableWithCGImage&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( options: ImageRequestOptions, handler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(ImageRequestResult&lt;T&gt;)</span></span></span></span></span></span> -&gt; ()) -&gt; <span class="hljs-type"><span class="hljs-type">ImageRequestId</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageRequestResult</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image: <span class="hljs-type"><span class="hljs-type">T?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> degraded: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requestId: <span class="hljs-type"><span class="hljs-type">ImageRequestId</span></span> }</code> </pre> <br>  Thus, we have come to the final version of the image request method for displaying it in the interface. <br><br>  Three other methods are simple, two of them are essentially just asynchronous getters. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-function">&lt;T: InitializableWithCGImage&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( options: ImageRequestOptions, resultHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(ImageRequestResult&lt;T&gt;)</span></span></span></span></span></span> -&gt; ()) -&gt; <span class="hljs-type"><span class="hljs-type">ImageRequestId</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fullResolutionImageData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Data?)</span></span></span></span></span></span> -&gt; ()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imageSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(CGSize?)</span></span></span></span></span></span> -&gt; ()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params">: ImageRequestId)</span></span></span></span> }</code> </pre> <br>  Thus, we obtained the ImageSource protocol, which is perfectly suitable for use as a model of our piker, and it only remains to implement it for three possible cases: photos from the disk, from the network and from the user's photo gallery. <br><br><h3>  Photo Gallery </h3><br>  Starting with iOS 8, access to the photo gallery is provided via Photos.framework.  The gallery itself is directly represented in it by the PHPhotoLibrary object, and the photos by the PHAsset objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28d/3cd/fdf/28d3cdfdf14d1c6283369b5a9e67976d.png"><br><br>  To get a photo view that can be displayed in the interface, you need to use PHImageManager, which gives a UIImage output. <br><br>  The method that performs this conversion looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params">: PHAsset, targetSize: CGSize, contentMode: PHImageContentMode, options: PHImageRequestOptions?, resultHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UIImage?, [AnyHashable: </span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">]?)</span></span></span></span></span></span> -&gt; ()) -&gt; <span class="hljs-type"><span class="hljs-type">PHImageRequestID</span></span></code> </pre> <br>  As you can see, it is very similar to the image acquisition method in our own ImageSource protocol: the same target size, content mode, some parameters, asynchronous result handler. <br><br>  This is not surprising, since the first implementation of ImageSource was a wrapper over PHAsset, so we largely repelled from this signature. <br><br>  Unfortunately, in the process of studying the work of PHImageManager, we encountered some slippery moments, so the body of our own requestImage method did not consist of a single call to this standard method, as it might seem. <br><br>  The first of them manifested itself in solving the classical problem of displaying photos in a collection view. <br><br><ol><li>  PHImageManager does not give any guarantees at all about how the resultHandler will be called after the cancellation of the request.  It may or may not be called, but in some cases we will get some UIImage, and in some cases - nil instead of it.  We wanted to simplify the client code so that it would not have to understand what exactly happened. <br><br></li><li>  Therefore, a strict set of call rules for resultHandler for ImageSource appeared, one of which stated that resultHandler should not be called after canceling the query. <br></li></ol><br>  The solution to this problem was quite simple.  The resultHandler of PHImageManager is given as input two parameters: the first is a UIImage, and the second is an info dictionary, which contains all useful information. <br><br><pre> <code class="hljs erlang">//  resultHandler PHImageManager' <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cancelled = (info?[PHImageCancelledKey] as? NSNumber)?.boolValue ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span> || cancelledRequestIds.contains(requestId) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !cancelled { //  <span class="hljs-string"><span class="hljs-string">"ÃÜ"</span></span> resultHandler }</code> </pre> <br>  Among this information is a checkbox by which you can determine whether the request was canceled.  But this flag may not come if the request was canceled after the given call to resultHandler was in the queue.  Therefore, we had to keep within the ImageSource an array of canceled requestId, and check the presence of our request in it. <br><br>  The second problem appeared when we encountered a photo from iCloud, and we needed to show the activity indicator at the time of loading. <br><br>  The only way to track such downloads is to set the progress handler in the PHImageRequestOptions object, which is then passed to PHImageManager when the image is requested. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PHImageRequestOptions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  PHImageManager var progressHandler: PHAssetImageProgressHandler? // ... }</span></span></code> </pre> <br>  We only needed to track the fact of the start and end of the download, so we added two such closure to our own structure with the request parameters.  And if onDownloadStart we just tugged at the first call of the progressHandler, then with onDownloadFinish it was not so simple. <br><br><pre> <code class="hljs coffeescript">struct ImageRequestOptions { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ImageSource var onDownloadStart: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImageRequestId)</span></span></span><span class="hljs-function"> -&gt;</span></span> ())? var onDownloadFinish: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImageRequestId)</span></span></span><span class="hljs-function"> -&gt;</span></span> ())? }</code> </pre> <br>  If we were lucky, and progressHandler told us that the picture was 100% loaded, which corresponds to the value of progress == 1, we called onDownloadFinish in this place. <br><br><pre> <code class="hljs objectivec">phImageRequestOptions.progressHandler = { progress, _, _, _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> progress == <span class="hljs-number"><span class="hljs-number">1</span></span> { callOnDownloadFinish() } }</code> </pre> <br>  However, the trick is that this may not happen, and the last call to the progressHandler will occur on progress less than 100%.  In this case, we are forced to already inside resultHandler'a try to guess whether the download is completed or not. <br><br><pre> <code class="hljs pgsql">//  resultHandler: let degraded: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>?[PHImageResultIsDegradedKey] let looksLikeLastCallback = cancelled || (image != nil &amp;&amp; !degraded) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> looksLikeLastCallback { callOnDownloadFinish() }</code> </pre> <br>  In the info dictionary that comes to us in this callback, there is an IsDegraded flag that indicates whether we have received the final or intermediate version of the image.  So at this stage it is logical to assume that the download is complete, either if we canceled the request, or if the final version of the picture arrived. <br><br>  You can explore the implementation of the ImageSource for photos from disk and from the network in <a href="https://github.com/avito-tech/Paparazzo">the Paparazzo repository</a> . <br><br>  Our mediipiker has already attracted the attention of iOS-developers, including <a href="https://maniacdev.com/2017/03/paparazzo-an-elegant-swift-based-ui-component-for-photo-picking-and-editing">foreign resources</a> .  They note that it perfectly performs the functions assigned to it and is quite elegant and simply implemented.  Now you can freely try it, test it, discuss it.  The Avito team is always happy to answer your questions. <br><br><hr><br>  Useful links: <br><br><ul><li>  <a href="https://habrahabr.ru/company/avito/blog/326774/">Link to Part One</a> <br></li><li>  <a href="https://github.com/avito-tech/Paparazzo">Paparazzo on github</a> <br></li><li>  <a href="https://youtu.be/4x6O0hepp2g">Record of the report</a> Media Picker - to infinity and beyond (CocoaHeads Russia 03/01/2017) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/327486/">https://habr.com/ru/post/327486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327474/index.html">We write the URL, we get a free icon</a></li>
<li><a href="../327476/index.html">How we learned to upgrade Tenzor's 5,000 servers.</a></li>
<li><a href="../327480/index.html">Java and isomorphic React</a></li>
<li><a href="../327482/index.html">How do i write code</a></li>
<li><a href="../327484/index.html">My upgrade byndyusoft.Infrastructure | DDD + CQRS + WebApi</a></li>
<li><a href="../327488/index.html">What is the Cyber-Kill Chain and why should it be taken into account in the protection strategy?</a></li>
<li><a href="../327490/index.html">Powershell Empire and FuzzBunch: exploiting the notorious ETERNALBLUE vulnerability</a></li>
<li><a href="../327492/index.html">‚ÄúIn a year or two, .NET Core will replace Java in the enterprise solution market‚Äù, - Interview with Jon Skeet, Google</a></li>
<li><a href="../327494/index.html">How we optimized Twitter Lite</a></li>
<li><a href="../327498/index.html">How to learn to see the brain. Review of the book "Visual Thinking" by Dan Roem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>