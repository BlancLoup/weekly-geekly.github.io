<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Is there a silver bullet vulnerability analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the comments on my previous article, amarao asked me a very good question . He asked how exactly, using what rules, we are looking for vulnerabilit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Is there a silver bullet vulnerability analysis</h1><div class="post__text post__text-html js-mediator-article">  In the comments on my previous article, <a href="http://habrahabr.ru/users/amarao/" class="user_link">amarao</a> asked me a very good <a href="http://habrahabr.ru/blogs/infosecurity/117218/">question</a> .  He asked how exactly, using what rules, we are looking for vulnerabilities in software.  I will give a part of this question: <br><blockquote>  By what algorithms, by what rules?  Or is it all on a whim "and I know what mim is!"?  In this case, the method does not describe in an even case anything somewhere - I thought, somewhere there is none. </blockquote><br>  With this question, <a href="http://habrahabr.ru/users/amarao/" class="user_link">amarao</a> , voluntarily or involuntarily, draws attention to the problem of objectivity in assessing the vulnerability of software, whether this assessment depends, or does not depend, on the expert conducting it.  The question is very important, and therefore often arises both among security specialists and our clients. <br>  Indeed, if we are not able to objectively assess the safety of the products offered to us, how can we choose one of them that best suits our needs?  All manufacturers, naturally, will swear that it is their product - the safest ever created.  Moreover, each of them, perhaps, will believe in it, and, moreover, to believe with good reason. <br>  It seems that software evaluation by independent companies - for example, certification - can solve this problem.  But if there is no objective means of analysis, then how can we check the quality of the assessment itself?  Indeed, the evaluation of a software product in this case is in itself a product, a service. <br>  Despite the fact that these questions are discussed quite often, I did not see a definite answer to them.  But during my work in this area I have developed certain ideas about the possibilities of modern techniques. <br>  In this article I want to illustrate my next thought: today, there is no vulnerability search <i>algorithm</i> that would guarantee an <i>objective</i> security assessment.  Therefore, the credibility of the product can be based only on the reputation of the experts who conducted its assessment, and on the experience of its operation (in fact, on the reputation of hackers who tried to overcome the defense). <br><a name="habracut"></a><hr><br>  All existing methods for finding vulnerabilities can be divided into two categories: formal and expert. <br>  Formal methods for finding vulnerabilities in software are very closely related to formal development methods.  They are based on the use of languages ‚Äã‚Äãwith a precisely defined meaning for the specification of the product being designed;  mathematical methods for validating the resulting project;  automated program code generation.  During the validation check, an assessment of possible vulnerabilities also occurs. <br>  Expert methods, as the name implies, are based on the knowledge and experience of evaluators.  Despite the fact that, by definition, these methods can hardly be called completely objective, I will start with them. <br><br><h1>  Expert methods </h1><br>  Expert techniques are based on the fact that information systems are created using more or less well-known patterns.  There are architecture patterns, design patterns, code.  Developers use known means and methods of protection.  Programs are written in well-known programming languages, run under common operating systems, use available libraries, access available services.  And the use of each of these patterns opens up the possibility for the emergence of certain vulnerabilities. <br>  So, for example, if the program is written in C, C ++, you can try to find in it an ‚Äúexploitable‚Äù buffer overflow.  If the query language to the program is rather complicated, it may be vulnerable to attack using API abuse methods.  If the program uses the password to authenticate the user, there is a chance to pick it up.  Programs working with DBMS are often vulnerable to SQL injection.  This list, as you can guess, is huge. <br>  A more complex system is decomposed into its component parts.  Further, these parts and their interaction are analyzed. <br>  So in a system consisting of the server and client parts, it is necessary to analyze the server, the client and the protocol of interaction between them.  In this case, it may be useful to separate parts also decompose into components.  For example, the server part often consists of a DBMS and an application server.  In turn, the application server can be implemented in the form of several processes in the operating system;  each process - to use certain libraries. <br>  Actually, the technique is reduced to finding some representation of a program or system in the form of interacting parts.  This presentation should allow, based on the historical information we have, to analyze the vulnerability of each part and the vulnerabilities associated with their interaction. <br>  A good example of an expert approach is the method developed and used by Microsoft.  The method is described, in particular, in the book ‚ÄúThreatModeling‚Äù [ <a href="https://habr.com/ru/post/122132/">1</a> ].  It uses information flow diagrams to analyze the program architecture, attack trees are used to present the results. <br>  Thus, expert methods are based on the ability of a specialist to competently carry out program decomposition and on his knowledge of the vulnerabilities of various types of programs and protocols. <br><br><h1>  Formal methods </h1><br>  In my experience, ‚Äúusing mathematics‚Äù is sometimes perceived with reverence, almost like a magical effect.  Mathematical, formal methods, in the understanding of many, are candidates for the title of "silver bullet", and the results obtained with their use are not perceived critically enough. <br>  Of course, formal methods really allow you to create better software.  They have already found their application in areas where increased requirements for reliability and / or safety are imposed on programs.  Gradually, the areas of their use are expanding, perhaps those who are reading this article are already using at least elements of such methods, or will use them in the future.  I think, over time, the use of formal means will allow both improving the quality of the product received and reducing the costs of its development and support <a href="https://habr.com/ru/post/122132/"><sup>*</sup></a> . <br>  On the other hand, although formal methods provide excellent results, it is necessary to understand their limitations.  Everyone who was engaged in the construction and study of mathematical models, will tell you that any model can give no more than what was originally incorporated into it. <br>  Let's take as an example a very simple model of a very simple program that implements a very simple protocol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Simple example </h2><br>  The program, after starting and initialization, should wait for the connection to be established by the user.  After the connection is established, the program should receive a username and password from the user.  If they turn out to be correct, the program can proceed to transmitting to the user certain information, a document.  After the end of the transfer, the program should break the connection, and proceed to waiting for a new connection. <br>  We want to make sure that using this program an unregistered user will not be able to access information. <br>  One of the possible options to do this is to build an automaton model and investigate it. <br>  The scheme of the automaton simulating this program is presented in the following figure. <br><br><img src="https://habrastorage.org/storage/a35389ae/2ccd982d/06ff57ee/a0fc10eb.png"><br><br>  In this model, only two routes are possible: I ‚Üí II ‚Üí III ‚Üí I and I ‚Üí II ‚Üí I <br>  Having considered all possible routes, we come to the conclusion that it is possible to get into the state in which the document is being read only after having successfully passed the authentication.  This conclusion is a confirmation of the correctness of our project.  Of course, for our simple system, this was obvious; in a more complicated situation, we might have found the ‚Äúwrong‚Äù ways. <br>  If we could find the routes that the system goes through to the document reading state without authentication, this would mean that we found a vulnerability.  Moreover, since we would know which requests should be made in each state in order to make the appropriate transition, we would immediately know the method by which the system can be attacked. <br>  It would seem, here it is - an algorithm for analyzing vulnerabilities.  We created a model, studied it;  At the exit, we got either attack methods or a conclusion about system security.  But note that each model can help us find only certain types of vulnerabilities, in this case, these are errors in the sequence of messages the user exchanges with the program.  And we are building this or that model, because we expect to find vulnerabilities of a certain type. <br>  In asserting the safety of a program based on the study of a mathematical model, we rely on a number of assumptions about the properties of the simulated program, the environment in which it works. <br><br><h2>  Assumptions in the model </h2><br>  Let's discuss some of the assumptions we made when building our simple model. <br>  Probably our most obvious suggestion is that the user who submitted the correct password is registered.  The model does not consider the problem of interception, selection, theft from the user of his password.  In order to evaluate the program from this point of view, additional research would be needed. <br>  There are less obvious assumptions.  For example, the fact that the user receiving the document will be the same user who entered the name and password.  This excludes from consideration all attacks related to session hijacking. <br>  As we have seen, even when examining a very simple program, we are forced to rely on many assumptions.  For more complex systems, this is even more true.  Every time we make a conclusion about the security of a software product or system, we rely on a number of assumptions about the limited capabilities of the attacker. <br>  Some of the assumptions can be verified.  For example, in some cases we might argue that the session will not be intercepted.  This looks quite plausible if the user works with the local keyboard and monitor, and the operating system supports the ‚Äútrusted path‚Äù.  Yes, I almost forgot, probably we still have to assume that the session is automatically terminated if the user gets up from the chair ... <br>  Other assumptions cannot be verified.  Some of them cannot be verified because we do not know the limits of the physical capabilities of the attacker.  For example, its ability to intercept electromagnetic radiation from a computer.  We can assume what means the attacker has, we may even have grounds for confidence in this knowledge.  But we cannot be sure until the end.  Perhaps the situation will change tomorrow in a significant way.  It is possible that the attack means are already in relatively free access, but we still do not know about it. <br>  Some logical assumptions also cannot be verified.  An example of this assumption is the security of the RSA algorithm.  Strict formal evidence of its indestructibility, to my knowledge, does not exist.  This means that tomorrow a hacking technique may appear, and all systems based on the use of this algorithm will become unprotected.  Moreover, we cannot be absolutely sure that no one yet knows how to attack this algorithm.  Of course, there are good reasons to believe that RSA is now safe, but ask yourself the question: if you had a business, at a price of a couple of billions of dollars (which would make it an interesting target), would you put it completely dependent on RSA? <br>  Interestingly, all these assumptions are not related to the fact that we <i>know something</i> ‚Äî how to solve a particular problem ‚Äî but to the fact that we <i>do not know something</i> .  Every time when we have to check one or another of our statements, the question arises: we cannot solve this problem, and no one knows how to do this, or is the method of solution known, but do we not know it? <br>  Anyone who remembers a school course of mathematics at least a little will easily notice that all mathematical models are based on axioms - unproved within the framework of the model itself.  And the difference between a ‚Äúgood‚Äù and a ‚Äúbad‚Äù model can only be in the reliability of the assumptions made.  It is much more difficult to verify the statement ‚Äúno one knows how to do this‚Äù than the statement ‚Äúwe can do it‚Äù.  In this we have to trust the experts. <br>  And we come to the paradoxical, it would seem, conclusion about the subjectivity of formal security models, about their dependence on the experience of an expert. <br><br><h1>  findings </h1><br>  The absence of vulnerabilities cannot be demonstrated, in contrast to how, for example, the functionality of the program or its performance can be demonstrated.  We have to trust the expert opinion. <br>  Even if an expert does not know how to attack this system, this does not mean that it is safe.  Even if no expert knows this, all the same, we cannot be completely sure that there are no such methods. <br>  At the same time, only an expert - or an expert community - can determine which checks need to be done, what efforts are sufficient to make to search for vulnerabilities in the analyzed program.  He can do this on the basis of his knowledge of the methods of attacks on such systems.  And confidence in the results of the audit can only be based on the reputation of the experts who conducted it. <br>  And I want to finish within the logic of the entire article. <br>  Can I say that the Big Opening will not be made tomorrow, as a result of which, everything that was said in this article will turn out to be wrong?  No I can not. <br>  Am I sure that this Big Opening has not been made yet?  I have reason to believe that this has not happened yet.  But I can't be completely sure. <br><br><h1>  Note </h1><br>  * If you are interested in formal approaches in general, without regarding security, then you may be interested in reading the book ‚ÄúUnderstanding formal methods‚Äù [ <a href="https://habr.com/ru/post/122132/">2</a> ]. <br>  Another book is Computer Security.  Art and Science ‚Äù[ <a href="https://habr.com/ru/post/122132/">3</a> ] contains a lot of information about mathematical models in information security, including a separate chapter devoted to formal methods of software security analysis. <br><br><h1>  Literature </h1><br>  1. Frank Swiderski, Window Snyder ‚ÄúThreat Modeling‚Äù, Microsoft Press 2004, ISBN 978-0-7356-1991-3 <br>  2. Jean Francois Monin, Michal G. Hichey (editor) ‚ÄúUnderstanding Formal Methods‚Äù, Springer-Verlag 2003, ISBN 1-85233-247-6 <br>  3. Matt Bishop ‚ÄúComputer Security.  Art and Science ‚Äù, Addison-Wesley 2003, ISBN 0-201-44099-7 </div><p>Source: <a href="https://habr.com/ru/post/122132/">https://habr.com/ru/post/122132/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122126/index.html">Microsoft calls the graphics technology used in Firefox and Chrome dangerous</a></li>
<li><a href="../122127/index.html">Groovy in 15 Minutes Overview</a></li>
<li><a href="../122129/index.html">Character distribution in passwords</a></li>
<li><a href="../122130/index.html">Firefox 5 is released</a></li>
<li><a href="../122131/index.html">Mobile bank (IPhone application concept)</a></li>
<li><a href="../122133/index.html">Billionaire club</a></li>
<li><a href="../122134/index.html">Reading a long article offline</a></li>
<li><a href="../122137/index.html">Wikimedia Foundation updates the technical base, distributing servers for free</a></li>
<li><a href="../122139/index.html">Microsoft received permission to buy Skype from the US Antimonopoly Committee</a></li>
<li><a href="../122140/index.html">Bamboo "speakers" for the iPhone from the domestic designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>