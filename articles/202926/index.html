<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microprocessor software simulation. Transmission</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about how the creators of simulators achieve maximum performance of processor models, while not sacrificing the flexibi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microprocessor software simulation. Transmission</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/291/019/98a/29101998afb0f9ed22f7905dd820030f.jpg" align="right">  In this article I want to talk about how the creators of simulators achieve maximum performance of processor models, while not sacrificing the flexibility and extensibility of a complete solution.  In short, the solution is the coexistence of several engines, the best qualities of which are used at different stages of the model. <br>  The content of this note will be based on my experience in the development of functional simulators, as well as on publications and technical articles describing various simulators and virtual machines: Wind River Simics, VMWare, Qemu, Bochs, and others.  The word ‚Äúfunctional‚Äù in the context of this article means that the accuracy of models is limited by the level of instruction set architecture (ISA). <br><a name="habracut"></a><br><h3>  Interpretation </h3><br>  An ‚Äúinterpreter‚Äù is someone (or something) who translates a text or speech from one language to another ‚Äúon the fly‚Äù.  The meaning of this term is approximately preserved when it is transferred to the field of computer technology.  Original implementations of many programming languages: Basic, Unix Shell, Rexx, PHP, etc. - were interpreters.  Their characteristic feature is the processing of one line of a program written in the input language at a time.  The next line will be converted ( <i>interpreted</i> ) only when the need arises.  For this reason, the term "interpreter" is usually opposed to the concepts of "translator" and "compiler", which process larger blocks of the input language: procedures, files, modules, etc. <br><br><h5>  Work cycle </h5><br>  The algorithm of the simulator that uses interpretation is an infinite loop (for simplicity, here I omit the details related to interrupt handling, events in peripheral devices, etc.), in structure resembling the work of the conveyor of real processors. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d74/13f/01f/d7413f01f47b62791e3cdeafee7f36c3.png"></div><br><br><div class="spoiler">  <b class="spoiler_title">On the number of stages in the pipeline</b> <div class="spoiler_text">  I note that the lengths of the pipelines of real processors are very different.  Simple microcontrollers, for example, PIC, can have only two stages.  The latest generation of Intel Pentium 4 has reached 31 stages. There are incredibly monstrous products, for example, <a href="http://www.linleygroup.com/newsletters/newsletter_detail.php%3Fnum%3D4501">Xelerated Xelerator X10q</a> has 1040 (!) Pipeline stages. </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During one iteration of the cycle, the simulator executes one instruction, sequentially performing the following steps. <br><ol><li>  Fetch - reading machine code from memory. </li><li>  Decode - decoding of the current function enclosed in the instruction, as well as its arguments, the operands. </li><li>  Execute - execution of the function on the arguments. </li><li>  Writeback - write results memory. </li><li>  Advance PC - advances the register of instructions (PC, program counter). </li></ol><br>  Consider each detail. <br><br><h5>  Reading memory instructions </h5><br>  In real computers, RAM is located far enough (in many ways) from the processor.  The code, as well as data is stored in it.  It is required to deliver a portion of the machine code for further processing to the processor, which is done at the Fetch stage.  As in real microprocessors, which have a faster instruction cache in front of the memory, the model can also use caching of previously read instructions.  And again, as in real systems, memory reading may well end with the occurrence of an exception that needs to be simulated. <br><br><h5>  Decoding </h5><br>  The task of a decoder, both hardware and simulated, is to isolate a separate instruction from the sequence of bytes received from the memory and disassemble what it means. <br>  Writing a decoder model is not the easiest thing.  The creator of the simulator has to deal with many features of guest architectures (one of them, inherent to IA-32, <a href="https://habrahabr.ru/users/yulyugin/" class="user_link">yulyugin</a> recently <a href="http://habrahabr.ru/company/intel/blog/200658/">wrote</a> on Habr√©).  The very number of instructions that you need to be able to distinguish can be large. <br>  If writing a simulator begins with reading the documentation for ISA, then creating a decoder in its composition - with a look at the tables of instructions, to get an idea of ‚Äã‚Äãthe scale of the disaster.  I will give a few examples of tables encoding instructions for different architectures.  All of them are taken from official manuals or related materials. <br>  <b>For ARM</b> [3], 32-bit instructions. <br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/bce/2da/fbd/bce2dafbdbf20a581714262ee991300b.png"></div></div><br>  <b>For PowerPC</b> 3.0 [4] <br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/3a5/a06/ee2/3a5a06ee254f16bf8b91a9767ebb1fbc.png"></div></div><br>  <b>For Itanium</b> 2.3 [2].  I always liked the fervent colorfulness of this guide! <br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/81d/842/027/81d84202753fc74a08cd836414abc02f.png"></div></div><br>  <b>For IA-32</b> [5].  A diagram showing all fields used after the introduction of the EVEX prefix. <br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/506/7ff/dd3/5067ffdd31f52b4df1426b92ca07ce78.png"></div></div><br>  A terrible scheme, but she helped me understand what is happening in AVX3. <br><br>  Naturally, the sad manual work of driving the contents of the tables into the code is often preferred to automation - the generation of code according to the description made in a specialized language.  For complex architectures, or in cases where it is necessary to have a common framework for creating simulators of many different systems, the cost of creating such a language and translation tools pays off. <br><br><h5>  Execution </h5><br>  The execution (execute) consists of a direct simulation of the function of an instruction already decoded.  It can be a calculation of the result of an arithmetic or logical operation, reading or writing to memory, changing the current mode of the processor, or passing control to a branch or procedure call. <br>  Each recognized instruction must correspond to a service routine.  In the simplest scheme of the interpreter, its choice is made according to the instruction's operation code (opcode) using the multiple choice construct - the switch - used programming language.  In C, this is a <b>switch statement</b> .  This scheme is called "switched" (switched): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OPERATION1: do_op1(arg1, arg2); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OPERATION2: do_op2(arg1, arg2); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OPERATION3: do_op3(arg1, arg2); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: do_undefined; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  There are several alternatives to the switchable interpretation scheme, characterized by a higher work rate [10], but I will write about them another time. <br>  Like creating a decoder manually, writing service procedures can be tedious, especially if they look alike.  For example, in the command system there may be families of instructions that have the same meaning, but differ in the width of the processed vector and elements, as well as the position of the processed data (in the register or in the memory).  Hands themselves are drawn to the methods of generalized programming.  Or you want to write a code generator that will take over the routine. <br>  Again, the service procedures must be synchronized with the decoder: when editing a set of commands, you should not forget about adding / deleting semantics for their simulation.  Therefore, it is most reasonable to have such a combined description in order to automatically produce both a decoder, and procedures, and (to the heap) a disassembler. <br><br><h5>  Memory entry </h5><br>  Working with simulated memory, even if we consider it only with an accuracy sufficient for the functional model, is also nontrivial.  Many things need to be considered here: a guest scheme for converting virtual addresses into physical ones, the guest system's relation to data alignment, the byte order in a machine word (endianness), access to a memory mapped device (memory mapped input / output), read / write page permissions / execution, optional segmentation (ugh!) ... <br>  Writing or reading memory can lead to an exception, which, as in the case of fetch, must be correctly simulated. <br><br><h5>  PC Promotion </h5><br>  PC (program counter) - a register storing the address of the current instruction.  In different systems and books, it is called differently: IP / EIP / RIP, pc, IP ... For "linear" operations, you just need to move it to the length of the newly processed instruction.  But for branching commands, procedure calls, program interrupts, it will change in a more complex way, corresponding to their semantics. <br><br><h4>  Subtotal </h4><br>  The interpreter is almost always the first type of model created for the new processor architecture.  For this reason, there are a great many, and the enumeration of more or less known would take a lot of space.  Here are just a couple of examples: Bochs [6], Zsim [7].  I would also like to recommend the <a href="http://fms.komkon.org/EMUL8/HOWTO.html">FAQ of</a> Marat Faizullin. <br><br><h3>  Binary broadcast </h3><br>  The main advantage of models based on interpretation is their simplicity.  The main drawback is the low speed of work. <br>  As in the case of high-level languages, you can use a technique historically called translation, but now more often referred to as compilation, to accelerate.  Thus, the name of the language Fortran is an abbreviation for FORmula TRANslator. <br>  Instead of spending time on parsing and executing each instruction every time it meets, you can simply translate a sufficiently long guest code block into an equivalent block of the host machine system.  Then, during the simulation, it is enough to transfer control to it, and it will be executed "without slowing down".  This idea works because, in practice, a code once executed is likely to be executed again soon - after all, programs spend most of the time in cycles of relatively small size. <br>  In the context of simulation, this technique is called ‚Äúbinary translation‚Äù (DT), or ‚Äúbinary translation‚Äù (binary translation).  The concept is very close to ‚Äúcompile execution time‚Äù (just in time compilation, JIT). <br>  Below I will describe one of the simple schemes used in practice. <br><br><h5>  Capsules and Broadcast Blocks </h5><br>  The input of the translation process is a group of machine commands that are nearby (for example, on the same page) and / or are executed sequentially (route).  They are decoded.  Then each guest instruction is associated with a block of host code, called a <i>capsule</i> .  Several capsules are assembled into larger formations, referred to as <i>translation units</i> .  Each of them can have one or more entry points, as well as several places from which management can leave it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53b/c47/a97/53bc47a97b95c3eca128579d7404caac.png"></div><br><br>  The fact that in this equipment is made "iron" in the simulator should make the program.  Therefore, the length of the capsule on average exceeds one instruction, which it is intended to represent. <br><br><div class="spoiler">  <b class="spoiler_title">Can a capsule be shorter?</b> <div class="spoiler_text">  Instructions that during functional simulation do not cause visible architectural effects can be represented by an empty capsule of zero commands, especially if the block of translation is optimized before execution.  Examples: <b>NOP</b> (no-operation) instruction options, data preloading instructions (prefetch), barriers (fence). </div></div><br><br>  Readers familiar with the organization of compilers will feel the similarity of what is happening in DT with compilation.  They will be right: in DT it is possible to distinguish the work of the frontend, phases of optimization and code generation in the back end.  I want to emphasize the differences between DT and compilation from high-level languages. <br><br><h5>  Code detection problem </h5><br>  The machine code contains less information about the program, its structures, than its source code.  The ensuing code discovery task can be divided into several subtasks. <br><ol><li>  In memory, data (variables, arrays, constants, strings, etc.) and the program code that processes them are stored together.  No boundaries between them are indicated.  Binary translation of data blocks (considered as a code!) Is useless: control will never be transferred to them - and even harmful: the time spent on this is wasted. </li><li>  In architectures that allow variable length instructions, the address from which their decoding begins is very important.  Shifting even one byte results in a complete change in the meaning of the sequence. </li><li>  The result of decoding depends on the processor mode.  For example, for the ARM architecture there are actually two sets of instructions - a full 32 bit and a trimmed 16-bit Thumb, the transition between which occurs with the help of the <b>BX</b> command. </li></ol><br><br>  A special case of this problem is the recalculation of the relative offsets for the addresses of the transition of branch instructions.  The figure below shows an example in which the source code block ends with a six-byte jump back.  In the generated code, the instruction boundary to which to go is in a different place. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da2/101/f6a/da2101f6a5c7b6962c0f9f97b9094411.png"></div><br><br><h5>  Self-modifying code </h5><br>  The executable program code and the data they process are located in the same physical memory.  Therefore, it is possible in the execution process to change the machine code.  This is used, for example, by operating systems to load into memory applications and dynamic libraries, polymorphic viruses to hide their presence.  Let's call this situation a self-modifying code (SMC).  In the case of a binary translation, this means that the translation blocks may become obsolete ‚Äî to be made incorrect if the guest code from which they were received has changed. <br><br><div class="spoiler">  <b class="spoiler_title">Have you ever had this?</b> <div class="spoiler_text">  You write the code, you make the change, you launch the application to see how the change affected the execution, but there is no effect.  You rush to figure it out, take it all, but it turns out that you forgot to recompile the application.  There was a desync of the source code and its translation into the machine. </div></div><br><br>  During the simulation, you have to keep track of all the entries in the memory and mark the affected blocks as outdated, requiring repeated translation.  This operation takes some time, so the speed of the model on sections of programs with SMC will be low: the execution of the generated code will often be interrupted for retransmission. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/dab/6f4/860dab6f4a21ac19fb208a97b7280fe9.png"></div><br><br><h5>  Limited optimizations </h5><br>  After assembling the translation unit from the capsules, it may turn out that it can be further converted.  In this case, the new unit will work faster.  This is similar to the use of optimization phases in compilers.  But, if there is a possibility that the result of a block‚Äôs execution after transformation will differ from the original one, then it will have to be abandoned.  Since the machine code often contains less information about the algorithm than it was contained in the source code, the range of optimizations in DT is less than that of the compilation. <br>  To perform a series of transformations, it is necessary to have an intermediate representation for translation blocks, which allows analyzing control and data graphs, as is done in compilers.  The DT scheme with capsules described by me above is not flexible enough for this. <br><br><h4>  Subtotal </h4><br>  In more detail about the binary translation techniques used for simulation needs, you can read in a series of posts on the Intel Developer Zone: <br>  <a href="http://software.intel.com/ru-ru/blogs/2013/09/28/1">Part 1</a> <br>  <a href="http://software.intel.com/ru-ru/blogs/2013/09/29/2">Part 2</a> <br>  <a href="http://software.intel.com/ru-ru/blogs/2013/09/29/3">Part 3</a> <br><br>  A couple of links to simulators known to me, in which the binary translator is the main engine for simulation: SoftSDV [8], the original implementation of Qemu [9]. <br><br><h3>  Direct execution and hardware support </h3><br><br>  An important case in practice is the situation when the guest and host architectures coincide (or almost coincide).  In this case, it becomes possible to significantly simplify the broadcasting - in some cases it comes down to copying the guest code as the master code or even executing it ‚Äúon the spot‚Äù, without duplication.  Such simulation modes have the common name ‚Äúdirect execution‚Äù (direct execution, DEX). <br><br><h5>  General idea </h5><br>  It would seem that if the program is already expressed in the machine language of the host system, it is enough to transfer control to its beginning.  Further the equipment itself with the maximum speed will execute instructions. <br><br><h5>  Why it doesn't work </h5><br>  Of course, this will not work.  The guest application should not be able to determine the fact that it is executed inside the simulator, and even more so to influence its operation, for example, by causing an exception.  I will describe only part of the complications that make the naive DEX scheme untenable. <br><ol><li>  Memory accesses  Guest address space is only part of the memory of the simulator.  The data and code of the simulated system will not necessarily be located at the same addresses at which they were located in reality. </li><li>  Return management.  How can you "force" a simulated application to give control back to the simulator? </li><li>  Privileged instructions.  The simulator operates in the unprivileged mode of the user application, and the guest code may contain instructions for the system modes.  Attempting to execute them will cause the simulator to crash. </li></ol><br>  There are <i>binary instrumentation</i> programs that allow you to "subtly" for the guest application to replace the machine code of selected instructions, for example, <a href="http://pintol.org/">Pin</a> from Intel or <a href="http://dynamorio.org/">DynamoRIO</a> from Hewlett-Packard.  Thus, it is possible to build a simulator that views the guest code and replaces its ‚Äúdangerous‚Äù areas before transferring control to it.  We can say that the instrumentation is a variant of DT, in which almost all the capsules coincide with the original instructions, and only the ‚Äúdifficult‚Äù commands are transformed. <br><br><h5>  Hardware support </h5><br>  Some microprocessors allow you to support the direct execution of the guest code in the sandbox, at the hardware level, performing work on intercepting dangerous operations.  This approach is better than binary instrumentation, both in terms of reliability and speed of operation.  Hardware-supported DEX is virtualization used for simulation needs. <br><br>  I tried to highlight the classic conditions of effective virtualization and the state of affairs in modern systems in my post <a href="http://habrahabr.ru/company/intel/blog/196444/">‚ÄúHardware Virtualization.</a>  <a href="http://habrahabr.ru/company/intel/blog/196444/">Theory, reality and support in processor architectures. ‚Äù</a> <br><br><h5>  Restrictions </h5><br>  Virtualization is the fastest simulation engine considered.  At the same time, it is in some sense the most inflexible, as it is strongly tied to the capabilities of the equipment. <br><ol><li>  Hardware-supported direct execution is not possible if the guest or host architectures do not match.  The ARM code on IA-32 or the PowerPC MIPS program will not magically run. </li><li>  Not all processor modes can be supported inside the guest.  For example, the ancient 16-bit real IA-32 mode is difficult to execute using VMX, if there are no so-called features.  Unrestricted Guest. </li><li>  The high cost of entry and exit to guest mode can kill a speed gain. </li><li>  More difficult to observe and manage the work of guest applications.  It becomes difficult to set breakpoints, to execute step-by-step execution, up to instructions, to change the semantics of individual instructions, etc. </li><li>  The simulator requires an OS kernel / driver module that will switch between modes.  Writing, debugging this module requires specific knowledge and tools. </li></ol><br><br><h4>  Subtotal </h4><br><br>  Quite a large number of simulators use Intel VT-x virtualization hardware support for their needs.  We can mention Wind River Simics, Oracle VirtualBox, Qemu, and VMWare products. <br><br><h3>  Putting it all together </h3><br><br>  So, there are at least three approaches: interpretation, binary translation and direct execution - which can be used to create software models.  I summarize their strengths and weaknesses. <br><br><ul><li>  The ease of implementation in the code.  The easiest to write is the interpreter.  It is difficult to say that it is more difficult to write: DT or DEX - it depends on the properties of the host system. </li><li>  Portability between host architectures.  The interpreter takes the first place: if it is written correctly, its code will be portable.  DT is not far behind, provided that its code generator can be retargeted to another system.  DEX does not work with significant differences in architectures, since  tied to a specific hardware. </li><li>  Easy to add functionality, such as new CPU instructions.  Again the interpreter leads with a margin.  DT requires more effort: it is necessary to write capsules.  DEX does not allow to go beyond the limits of the master equipment;  New instructions will not be recognized. </li><li>  Work speed  Here the interpreter as a whole loses much to the other two engines.  DT is usually also inferior to DEX.  However, remember that the weak side of DT is SMC, and with DEX there are frequent exits from virtualization, for example, on privileged instructions. </li></ul><br><br>  The conclusion is disappointing.  At the same time, the two main conditions - speed and universality - are not satisfied by any scheme.  Moreover, at different stages of the same simulation scenario, any scheme may be preferable. <br>  What to do?  Shift gear depending on driving mode!  Use all three, including each of them, when it is most profitable! <br>  We can formulate some recommendations determining the conditions for switching between modes.  Rather, it is even heuristics. <br><ul><li>  If fast mode is not available, go to a slower one.  For example, not all instructions may be supported by DT or DEX. </li><li>  Switch from a fast model to a slow one if the fast one has ceased to be so.  If SMC is detected, it is better to temporarily disable the DT mode. </li><li>  Postpone the transmission of portions of the code until it becomes clear that this code is ‚Äúhot‚Äù.  Why waste time generating a block that will be executed only a few times? </li><li>  Do not use DEX, if there is a high probability of an early exit on the exception. </li><li>  It is necessary to provide the user with the ability to follow the current simulation speed with splitting into modes.  After all, heuristics are limited in their vision.  Often, only a person can determine the measures necessary to accelerate it. </li></ul><br><br>  The price for speed and flexibility is the need to support actually three independent models.  To catch errors in them, to eliminate "minor" differences in behavior, to stumble upon the strangeness of the implementations of virtualization of different generations of equipment.  In general, try to curb the three-headed Serpent Gorynych. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/b50/fb9/2a1b50fb9d9bc66f9cafde9a4787acd0.jpg"><br>  Ivan Bilibin.  <b>Snake Gorynych</b> .  1912. <br><br><h3>  Conclusion </h3><br>  I want to refer to the textbook [1] that are interested in the internal structure of the software models of computers.  The electronic version of the second edition, as well as the "beta version" of the third is available on <a href="http://iscalare.mipt.ru/materials/course_materials/">the course website "Fundamentals of Software Modeling</a> . <a href="http://iscalare.mipt.ru/materials/course_materials/">"</a> <br><br>  In this note, not a word was said about yet another way to increase the speed of modeling - parallel execution.  The problems associated with building such simulators, and their solutions are described in another series of posts on the Intel Developer Zone: <a href="http://software.intel.com/ru-ru/blogs/2013/09/22/0">0</a> , <a href="http://software.intel.com/ru-ru/blogs/2013/09/22/1">1</a> , <a href="http://software.intel.com/ru-ru/blogs/2013/09/22/2">2</a> , <a href="http://software.intel.com/ru-ru/blogs/2013/09/22/3">3</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Reverse</b> <div class="spoiler_text">  Having looked at the speed-shift knob pictured at the beginning of the article, I suddenly thought: ‚ÄúHmm, what about the reverse?‚Äù In terms of simulation, this means that the flow of virtual time, as well as all the processes taking place in it, are reversed.  The most interesting thing is that it is feasible.  However, this is a topic for a separate post that I plan to prepare someday. </div></div><br><br><h3>  Literature </h3><br>  [1] <b>Fundamentals of computer software simulation</b> : Textbook / Rechistov G.S., Yulyugin E.A., Ivanov A.A., Shishpor P.L., Schelkunov N.N., Gavrilov D.A.  - 2nd ed., Corr.  and add.  - Publishing house of MIPT, 2013. <br>  [2] Intel Corporation.  <b>Intel¬Æ Itanium¬Æ Architecture Software Developer's Manual</b> Rev.  2.3 <br>  [3] ARM Limited.  <b>ARM Architecture Reference Manual</b> - 2005 <br>  [4] IBM Corporation.  <b>PowerPC¬Æ Microprocessor Family for The 64-bit Microprocessors</b> .  Version 3.0 <br>  [5] JCS Adrian et al.  <b>Operands' Systems, Apparatuses, and Methods for Blending</b> .  US Patent Application Publication.  No. 2012/0254588 A1 <br>  [6] D. Mihoka, S. Shwartsman.  <b>Virtualization Without Direct Execution or Designing a Portable Virtual Machine Infrastructure</b> <a href="http://bochs.sourceforge.net/">bochs.sourceforge.net</a> <br>  [7] Yair Lifshitz, Robert Cohn, Inbal Livni, Omer Tabach, Mark Charney, Kim Hazelwood.  <b>Zsim: A Fast Architectural Simulator for ISA Design-Space Exploration</b> <a href="http://www.cs.virginia.edu/kim/docs/wish11zsim.pdf">www.cs.virginia.edu/kim/docs/wish11zsim.pdf</a> <br>  [8] <b>SoftSDV: A Software Development for the IA-64 Architecture</b> / Richard Uhlig, Roman Fishtein, Oren Gershon, Israel Hirsh, Hong Wang // Intel Technology Journal.  - 1999. ‚Äî‚Ññ 14. - ISSN: 1535-766X.  - <a href="https://noggin.intel.com/content">noggin.intel.com/content</a> / softsdv-a-pre-silicon-software-development-environment-for-the-ia-64-architecture / <br>  [9] Fabrice Bellard.  <b>QEMU, a Fast and Portable Dynamic Translator</b> // FREENIX Track: 2005 USENIX Annual Technical Conference.  - 2005. - <a href="http://www.usenix.org/publications/library/proceedings/usenix05/tech/freenix/full_papers/bellard/bellard.pdf">www.usenix.org/publications/library/proceedings/usenix05/tech/freenix/full_papers/bellard/bellard.pdf</a> <br>  [10] James E.Smith, Ravi Nair.  <b>Virtual machines - Versatile Platforms for Systems and Processes</b> .  - Elsevier, 2005. - ISBN: 978-1-55860-910-5. </div><p>Source: <a href="https://habr.com/ru/post/202926/">https://habr.com/ru/post/202926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202912/index.html">Electronic devices can be used in flight in the USA and Europe.</a></li>
<li><a href="../202914/index.html">Report on the launch of programs on users' computers</a></li>
<li><a href="../202918/index.html">November's new items in Opera: version for tablets and synchronization</a></li>
<li><a href="../202922/index.html">We extract gold from old electronics</a></li>
<li><a href="../202924/index.html">Escape from the ‚ÄúOthers‚Äù column: local brands increase market share</a></li>
<li><a href="../202928/index.html">TC MUK announced pre-holiday discount on the course VMware Vsphere Fast Track</a></li>
<li><a href="../202930/index.html">Watson Cookies</a></li>
<li><a href="../202934/index.html">Payoneer and Pond5: new opportunities for stockers</a></li>
<li><a href="../202942/index.html">252 characters minicraft</a></li>
<li><a href="../202944/index.html">Small Javascript programs: where to go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>