<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Single or double precision?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In scientific calculations, we often use floating point numbers. This article is a guide to choosing the right representation of a floa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Single or double precision?</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In scientific calculations, we often use floating point numbers.  This article is a guide to choosing the <i>right</i> representation of a floating-point number.  Most programming languages ‚Äã‚Äãhave two built-in types of accuracy: 32-bit (single precision) and 64-bit (double precision).  In the C language family, they are known as <code>float</code> and <code>double</code> , and here we will use these terms.  There are other types of accuracy: <code>half</code> , <code>quad</code> , etc. I will not focus on them, although there are also many disputes about the choice of <code>half</code> vs <code>float</code> or <code>double</code> vs <code>quad</code> .  So we‚Äôll clarify right away: here we are talking only about 32-bit and 64-bit <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> numbers. <br><br>  The article is also written for those of you who have a lot of data.  If you need several numbers here or there, just use <code>double</code> and do not bother yourself! <br><br>  The article is divided into two separate (but related) discussions: what to use to <i>store</i> your data and what to use in the <i>calculations</i> .  Sometimes it is better to store data in <code>float</code> , and calculations to produce in <code>double</code> . <br><a name="habracut"></a><br>  If you need it, at the end of the article I added a small reminder of how floating-point numbers work.  Feel free to read it first, and then come back here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Data accuracy </h2><br>  32-bit floating-point numbers have an accuracy of about 24 bits, that is, about 7 decimal places, while double-precision numbers have 53 bits, that is, about 16 decimal places.  How much is this?  Here are some rough estimates of what accuracy you get at worst when using <code>float</code> and <code>double</code> to measure objects in different ranges: <br><br><table><tbody><tr><th>  Scale </th><th>  Single precision </th><th>  Double precision </th></tr><tr><td>  Room size </td><td>  micrometer </td><td>  proton radius </td></tr><tr><td>  Earth circumference </td><td>  2.4 meters </td><td>  nanometer </td></tr><tr><td>  Distance to the sun </td><td>  10 km </td><td>  human hair thickness </td></tr><tr><td>  Duration of the day </td><td>  5 milliseconds </td><td>  picosecond </td></tr><tr><td>  The duration of the century </td><td>  3 minutes </td><td>  microsecond </td></tr><tr><td>  Time from the Big Bang </td><td>  millennium </td><td>  minute </td></tr></tbody></table><br>  (example: using <code>double</code> , we can imagine the time since the Big Bang with an accuracy of about a minute). <br><br>  So, if you measure the size of an apartment, then <code>float</code> enough.  But if you want to provide GPS coordinates with an accuracy of less than a meter, you will need a <code>double</code> . <br><br><h2>  Why not always keep everything with double precision? </h2><br>  If you have a lot of RAM, and the execution speed and battery consumption are not a problem - you can stop reading right now and use <code>double</code> .  Goodbye and have a nice day! <br><br>  If the memory is limited, the reason for choosing <code>float</code> instead of <code>double</code> is simple: it takes half as much space.  But even if memory is not a problem, storing data in a <code>float</code> can be much faster.  As I already mentioned, <code>double</code> takes up twice the space than a <code>float</code> , that is, it takes twice the time to place, initialize and copy data if you use <code>double</code> .  Moreover, if you read data in an unpredictable way (random access), then with <code>double</code> you will increase the number of misses by the cache, which slows down reading by about 40% (judging by the <a href="http://www.ilikebigbits.com/blog/2014/4/21/the-myth-of-ram-part-i">practical rule O (‚àöN)</a> , which is confirmed by benchmarks). <br><br><h2>  Impact on single and double precision computing performance </h2><br>  If you have a well-fitted pipeline using SIMD, then you can double the performance of FLOPS by replacing <code>double</code> with <code>float</code> .  If not, the difference may be much smaller, but depends heavily on your CPU.  On an Intel Haswell processor, the difference between <code>float</code> and <code>double</code> small, and on ARM Cortex-A9, the difference is large.  See the comprehensive test results <a href="http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/">here</a> . <br><br>  Of course, if the data is stored in <code>double</code> , then it makes little sense to perform calculations in <code>float</code> .  In the end, why keep such accuracy if you are not going to use it?  However, the opposite is not true: it may be quite reasonable to store data in a <code>float</code> , but to do some or all of the calculations with double precision. <br><br><h2>  When to make calculations with increased accuracy </h2><br>  Even if you store data with single precision, in some cases it is appropriate to use double precision in calculations.  Here is a simple C example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { sum += values[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  If you run this code on ten single precision numbers, you won't notice any problems with precision.  But if you run on a million numbers, you will definitely notice.  The reason is that accuracy is lost when adding large and small numbers, and after adding a million numbers, this situation is likely to occur.  The rule of thumb is this: if you add <i>10 ^ N</i> values, you lose <i>N</i> decimal places of accuracy.  So when you add thousands ( <i>10 ^ 3</i> ) numbers, three decimal places are lost.  If you add a million ( <i>10 ^ 6</i> ) numbers, then six decimal places are lost (and the <code>float</code> only seven!).  The solution is simple: perform calculations in <code>double</code> format instead: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { sum += values[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)sum; }</code> </pre> <br>  Most likely, this code will work as fast as the first one, but the accuracy will not be lost.  Please note that you do not need to store numbers in <code>double</code> to take advantage of the increased accuracy of calculations! <br><br><h2>  Example </h2><br>  Suppose you want to accurately measure a value, but your measuring device (with some kind of digital display) shows only three significant digits.  Measuring a variable ten times produces the following row of values: <br><br><pre> <code class="hljs css">3<span class="hljs-selector-class"><span class="hljs-selector-class">.16</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.16</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.18</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.11</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.14</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.11</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.14</span></span>, 3<span class="hljs-selector-class"><span class="hljs-selector-class">.15</span></span></code> </pre> <br>  To increase accuracy, you decide to add the measurement results and calculate the average.  This example uses a floating-point number in base-10, whose precision is exactly seven decimal places (similar to a 32-bit <code>float</code> ).  With three significant digits, this gives us four additional decimal places for precision: <br><br><pre> <code class="hljs">3.160000 + 3.150000 + 3.160000 + 3.180000 + 3.150000 + 3.110000 + 3.140000 + 3.110000 + 3.140000 + 3.150000 = 31.45000</code> </pre> <br>  In total, there are already four significant digits, with three free ones.  What if you add up a hundred of these values?  Then we get something like this: <br><br><pre> <code class="hljs css">314<span class="hljs-selector-class"><span class="hljs-selector-class">.4300</span></span></code> </pre> <br>  There are still two unused digits left.  If to summarize one thousand numbers? <br><br><pre> <code class="hljs css">3140<span class="hljs-selector-class"><span class="hljs-selector-class">.890</span></span></code> </pre> <br>  Ten thousand? <br><br><pre> <code class="hljs css">31412<span class="hljs-selector-class"><span class="hljs-selector-class">.87</span></span></code> </pre> <br>  So far, so good, but now we use all the decimal places for accuracy.  Continue adding numbers: <br><br><pre> <code class="hljs">31412.87 + 3.11 = 31415.98</code> </pre> <br>  Notice how we shift the smaller number to even out the decimal separator.  We no longer have spare discharges, and we dangerously approached the loss of accuracy.  What if you add up a hundred thousand values?  Then adding new values ‚Äã‚Äãwill look like this: <br><br><pre> <code class="hljs">314155.6 + 3.12 = 314158.7</code> </pre> <br>  Note that the last significant bit of data ( <i>2</i> in <i>3.12</i> ) is lost.  Now the loss of accuracy does occur, since we will continuously ignore the last bit of accuracy of our data.  We see that the problem occurs after adding ten thousand numbers, but up to one hundred thousand.  We have seven decimal places of accuracy, and there are three significant digits in the measurements.  The remaining four digits are four orders of magnitude, which serve as a kind of "numeric buffer".  Therefore, we can safely add four orders of magnitude = <i>10,000</i> values ‚Äã‚Äãwithout losing accuracy, but then problems will arise.  Therefore, the rule is as follows: <br><br>  If your floating point number contains <i>P</i> bits ( <i>7</i> for <code>float</code> , <i>16</i> for <code>double</code> ) accuracy, and in your data <i>S</i> bits of significance, then you have <i>PS</i> bits for maneuver and you can add <i>10 ^ (PS)</i> values ‚Äã‚Äãwithout any problems with accuracy.  So, if we used 16 bits of precision instead of 7, we could add <i>10 ^ (16-3) = 10,000,000,000,000</i> values ‚Äã‚Äãwithout any problems with accuracy. <br><br>  (There are <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">numerically stable ways of adding a large number of values</a> . However, simply switching from <code>float</code> to <code>double</code> much simpler and probably faster). <br><br><h2>  findings </h2><br><ul><li>  Do not use extra precision when storing data. </li><li>  If you add a large amount of data, switch to double precision. </li></ul><br><h2>  Appendix: What is a floating point number? </h2><br>  I found that many do not really understand what floating-point numbers are, so it makes sense to explain briefly.  I‚Äôll skip over the smallest details about bits, INF, NaN, and subnorms, and instead show a few examples of floating-point numbers in base-10.  All the same applies to binary numbers. <br><br>  Here are a few examples of floating point numbers, all with seven decimal places (this is close to a 32-bit <code>float</code> ). <br><br>  <b>1.875545</b> ¬∑ 10 ^ <i>-18</i> = 0.000 000 000 000 000 00 <b>1 875 545</b> <br>  <b>3.141593</b> ¬∑ 10 ^ <i>0</i> = <b>3.141593</b> <br>  <b>2.997925</b> ¬∑ 10 ^ <i>8</i> = <b>299 792 5</b> 00 <br>  <b>6.022141</b> ¬∑ 10 ^ <i>23</i> = <b>602 214 1</b> 000 000 000 000 000 000 <br><br>  The <b>bold</b> part is called the mantissa, and the <i>italicized part</i> is the exponent.  In short, accuracy is stored in the mantissa, and the value is in the exponent.  So how to work with them?  Well, multiplication is simple: multiply the mantissas and add the exponents: <br><br>  <b>1.111111</b> ¬∑ 10 ^ <i>42</i> ¬∑ <b>2.000000</b> ¬∑ 10 ^ <i>7</i> <br>  = ( <b>1.111111 ¬∑ 2.000000</b> ) ¬∑ 10 ^ ( <i>42 + 7</i> ) <br>  = <b>2.222222</b> ¬∑ 10 ^ <i>49</i> <br><br>  Adding is a little trickier: to add two numbers of different sizes, you first need to move the smaller of the two numbers so that the comma is in the same place. <br><br>  <b>3.141593</b> ¬∑ 10 ^ <i>0</i> + <b>1.111111</b> ¬∑ 10 ^ <i>-3</i> = <br>  <b>3.141593</b> + 0.000 <b>1111111</b> = <br>  <b>3.141593</b> + <b>0.000111</b> = <br>  <b>3.141704</b> <br><br>  Notice how we shifted some of the significant decimal places so that the commas match.  In other words, we lose accuracy when we add numbers of different quantities. </div><p>Source: <a href="https://habr.com/ru/post/331814/">https://habr.com/ru/post/331814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331796/index.html">Leaflet 1.xx vs Openlayers 4.xx Part 1. Source Code</a></li>
<li><a href="../331800/index.html">Interesting Factorio Study: Plant Simulator</a></li>
<li><a href="../331802/index.html">About Gaudi, a nineteenth-century developer who achieved all that a developer can accomplish</a></li>
<li><a href="../331806/index.html">"Project Ironman." How to prepare for the "Iron Man" for 500 hours, using the skills of PM</a></li>
<li><a href="../331812/index.html">How to turn the passion of programming in the work</a></li>
<li><a href="../331816/index.html">Creating a React Real-Time VR Application</a></li>
<li><a href="../331818/index.html">And about 3.3 thousand new ways to read Habrahabr and Hiktimes</a></li>
<li><a href="../331820/index.html">Another view on personnel management in retail: the experience of ZOZO RCAM</a></li>
<li><a href="../331822/index.html">Easy performance test of AWS, Google Cloud and Microsoft Azure cloud platforms</a></li>
<li><a href="../331824/index.html">Four questions for choosing a cloud authentication solution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>