<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experience of introducing automation into the process of manual testing on the example of an Android application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A good tester with critical thinking skills cannot be completely replaced by automation. Making it work more efficiently is easy. With this conviction...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experience of introducing automation into the process of manual testing on the example of an Android application</h1><div class="post__text post__text-html js-mediator-article">  <i>A good tester with critical thinking skills cannot be completely replaced by automation.</i>  <i>Making it work more efficiently is easy.</i>  <i>With this conviction, I went to our testing department with a new task, where Pavel and I set about implementing it.</i>  <i>Let's see what came of it.</i> <br><br>  Together with our partners, we actively develop, test and support a family of applications for different platforms: Android, iOS, Windows.  Applications are actively developing, along with which increases the amount of testing, in the first place - regression. <br><br>  We decided to try to simplify and speed up testing by automating most of the test scripts.  At the same time, we did not want to completely abandon the manual testing process, but rather modify it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The implementation of this approach began with one of the Android applications, which I will tell you about.  The article will be interesting to novice authors of UI-tests, primarily for mobile applications, as well as those who want to automate the manual testing process to some extent. <br><br>  Go! <a name="habracut"></a><br><br><h2>  A starting point </h2><br>  For each platform, we have several similar applications running the same basic business process.  However, they differ from each other in a set of small auxiliary functionalities, are implemented under different brands depending on the customer (which is why the interface changes from application to application), and the business process can be customized by adding additional steps. <br><br>  We are faced with certain problems that need to be addressed.  Similar difficulties may arise in a situation other than ours.  For example, if you have one bulky application with difficult business logic, overgrown with many tests. <br><br><h4>  Problem number 1: many regression tests </h4><br>  The sets of test scenarios for each application are both similar and different, which increases the regression and makes it even more boring.  However, all applications need to be tested separately. <br><br>  Given that already running applications are updated regularly, and in the future there will only be more, the total number of tests will inexorably grow. <br><br><h4>  Problem number 2: you need to test on all versions of the mobile OS </h4><br>  An important requirement is the performance of our mobile applications on a wide range of operating system versions.  For example, in the case of Android at the time of writing, these are API levels from 17 to 28. <br><br>  Ideally, we should test on each version of Android, which further ‚Äúweights‚Äù our regression.  The process of direct testing of an application acquires an additional routine, multiplied by the number of devices: installing and launching the application, resetting it to its original state after each individual test, and deleting.  At the same time, to maintain your own device farm rather laboriously. <br><br><h4>  Solution: implement automation in the manual testing process </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  A typical test automation task is to automate regression tests.  So we want to improve the efficiency of the testing process today and prevent the possible consequences of growth tomorrow. <br><br>  At the same time, we are well aware that it is impossible and unnecessary to try to completely eradicate manual testing by automation.  Critical thinking and the human eye is difficult to replace.  On this topic there is a good article in the blog of Michael Bolton The <a href="http://www.developsense.com/blog/2017/11/the-end-of-manual-testing/">End of Manual Testing</a> (or <a href="http://www.software-testing.ru/library/testing/general-testing/2749-the-end-of-manual-testing">translation</a> from Anna Rodionova). <br><br>  We thought that it would be useful to have a set of automated tests that cover the stable parts of the application, and in the future - to write tests for found bugs and new functionality.  At the same time, we want to link autotests with existing test suites in our test management system (we use TestRail), and also give testers the ability to easily run auto tests on cloud physical devices (we chose Firebase Test Lab as the cloud infrastructure). <br><br>  To start and sample, we took one of our Android applications.  It was important to take into account that if the solution was successful, its best practices could be applied to the rest of our applications, including on other platforms. <br><br>  What we want to get in the end: <br><br><ol><li>  Automation of regression testing. </li><li>  Integration with test management system. </li><li>  Possibility of parameterized manual launch of autotests on cloud devices. </li><li>  Ability to reuse the solution in the future. </li></ol><br>  Further, I will separately tell about the implementation of each of these points with a slight immersion in the technical component. <br><br><h2>  General scheme for implementing the solution </h2><br>  But first - the general scheme of what we have done: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="image"><br><br>  Auto tests run in two ways: <br><br><ol><li>  From CI after merge or pull request to master. </li><li>  Tester manually from the Jenkins Job web interface. </li></ol><br>  In the case of a manual launch, the tester needs to either indicate the number of the corresponding build, or download 2 APK from your computer: with the application and with the tests.  This method is needed so that you can run the necessary tests at any time on any available devices. <br><br>  During the execution of tests, their results are sent to TestRail.  This happens in the same way as if the tester did manual testing and recorded the results in the way he was used to. <br><br>  Thus, we left the well-established process of manual testing, but added automation to it, which performs a specific set of tests.  The tester "picks up" what is done automatically, and: <br><br><ul><li>  sees the result of the test cases on each device that have been selected; </li><li>  can recheck any test case manually; </li><li>  performs test cases that are not yet automated, or cannot be optimized for any reason; </li><li>  makes a final decision on the current test run. </li></ul><br>  We now turn to the promised description of the implementation. <br><br><h2>  1. Autotest </h2><br><h4>  Instruments </h4><br>  We used 3 tools to interact with the user interface: <br><br><ul><li>  Espresso. </li><li>  Barista. </li><li>  UI Automator. </li></ul><br>  The main tool and the one with which we started is Espresso.  The main argument in favor of his choice was the fact that Espresso allows you to test the white box method, providing access to Android Instrumentation.  The test code is in the same project as the application code. <br><br>  Access to the Android application code is needed in order to call its methods in tests.  We can prepare our application in advance for a specific test by running it in the desired state.  Otherwise, we need to reach this state through the interface, which deprives the tests of atomicity, making them dependent on each other, and simply eats up a lot of time. <br><br>  During the implementation, another tool was added to Espresso - UI Automator.  Both frameworks are part of <a href="https://android.github.io/android-test/">Google's Android Testing Support Library</a> .  Using the UI Automator, we can interact with various system dialogs or, for example, with Notification Drawer. <br><br>  And the latest in our arsenal was the Barista framework.  It is a wrapper around Espresso, saving you the boilerplate code when implementing common user actions. <br><br>  Bearing in mind the desire to be able to reuse the solution in other applications, it is important to note that the listed tools are intended exclusively for Android applications.  If you do not need access to the code of the application under test, then you will probably prefer to use another framework.  For example, very popular today Appium.  Although with him you can try to get to the application code using backdoors, which is a good <a href="https://habr.com/company/badoo/blog/354296/">article</a> on the Badoo blog.  The choice is yours. <br><br><h4>  Implementation </h4><br>  As a design pattern, we chose Testing Robots, proposed by Jack Wharton in the <a href="https://jakewharton.com/testing-robots/">report of the</a> same name.  The idea of ‚Äã‚Äãthis approach is similar to the common Page Object design pattern, which we use when testing web systems.  Programming language - Java. <br><br>  For each independent fragment of the application, a special robot class is created in which business logic is implemented.  Interaction with each element of the fragment is described in a separate method.  In addition, all the assertions performed in this fragment are described here. <br><br>  Consider a simple example.  The described fragment contains several data entry fields and an action button: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="image"><br><br>  The code of the login functionality test itself: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="image"><br><br>  Here we check the positive scenario when the authentication data entered is correct.  The data itself is submitted to the entrance tests, or default values ‚Äã‚Äãare used.  Thus, the tester has the possibility of parameterization in terms of test data. <br><br>  Such a structure first of all gives the tests excellent readability, when the whole script is broken down into basic execution steps.  We also liked the idea of ‚Äã‚Äãcarrying out asserts into separate methods of the corresponding robot.  An assert becomes the same step, without breaking the overall chain, and your tests still do not know anything about the application. <br><br>  In the aforementioned report, Jake Wharton gives an implementation in the Kotlin language, where finite.  We already tried it on another project and we really liked it. <br><br><h2>  2. Integration with test management system </h2><br>  Prior to the introduction of automation, we conducted all of our testing in the TestRail test management system.  The good news is that there is a fairly good <a href="http://docs.gurock.com/testrail-api2/start">TestRail API</a> , with which we were able to connect test cases already instituted in the system with autotests. <br><br>  During a test run using JUnit <a href="https://junit.org/junit4/javadoc/4.12/org/junit/runner/notification/RunListener.html">RunListener</a> , various events are captured, such as <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , in which we send the results to TestRail.  If you are using AndroidJUnitRunner, then it needs to report your RunListener in a certain way, described in the official <a href="https://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner">documentation.</a> <br><br>  You also need to establish a connection with various TestRail entities by their ID.  So, to link the test with the corresponding test case, we created a simple <code>@CaseId</code> annotation, the use of which is shown in the test implementation example above. <br><br>  The code for the implementation of the annotation itself: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="image"><br><br>  It remains only to get its value in the right place from Description: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="image"><br><br><h2>  3. Manual start of autotests on cloud devices </h2><br><h4>  Start Parameterization in Jenkins Job </h4><br>  To organize the manual start of autotests, we use the <a href="https://github.com/jenkinsci/job-dsl-plugin/wiki/Tutorial---Using-the-Jenkins-Job-DSL">Free-style Jenkins Job</a> .  This option was chosen because the company already had some experience of similar work with Jenkins Job in other areas, in particular, with DevOps-engineers, whom they happily shared. <br><br>  Jenkins Job runs a script based on the data transferred from the web interface.  Thus, the parameterization of test runs is implemented.  In our case, the Bash script initiates the launch of tests on Firebase cloud devices. <br><br>  Parameterization includes: <br><br><ul><li>  Select the desired APK by specifying the number of the corresponding build or download them manually. </li><li>  Enter all kinds of test data. </li><li>  Enter additional custom data for TestRail. </li><li>  Select the cloud physical devices on which tests will be run from the list available in the Firebase Test Lab. </li><li>  Selection of test cases to be executed. </li></ul><br>  Consider the part of the web page of our Jenkins Job on the example of the device selection interface and test cases: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="image"><br><br>  Each element, where you can enter or select any data, is implemented by special Jenkins-plugins.  For example, the device selection interface is made using the <a href="https://wiki.jenkins.io/display/JENKINS/Active%2BChoices%2BPlugin">Active Choices Plugin</a> .  Using the groovy script from Firebase, you get a list of available devices, which is then displayed in the desired form on a web page. <br><br>  After all the necessary data is entered, the corresponding script is launched, the progress of which we can observe in the Console Output section: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="image"><br><br>  From here, the tester, who initiated the test run, can get to the TestRail or Firebase console, which contains a lot of useful information about running tests on each of the selected devices, at the received URLs. <br><br><h4>  Final Test Matrix in Firebase Test Lab </h4><br>  The device matrix in Firebase contains the distribution of tests according to the devices on which they were run: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="image"><br><br>  For each device, you can view the full log, video test run, various performance indicators.  In addition, you can access all the files that may have been created during the execution of tests.  We use this in order to unload from the device indicators of code coverage tests. <br><br>  We chose Firebase, as we already used this service to solve other problems, and we are satisfied with the pricing policy.  If you meet the 30 minutes of net time for testing per day, you do not need to pay at all.  This may be an additional reason why it is important to be able to run only certain tests. <br><br>  You might prefer a different cloud infrastructure that also fits well with your testing process. <br><br><h2>  4. Reuse </h2><br>  How can all this be used in the future?  From the point of view of the code base, this solution is applicable only for Android applications.  For example, during the implementation we have auxiliary classes <code>EspressoExtensions</code> and <code>UiAutomatorExtensions</code> , where we encapsulate various options for interacting with the interface and waiting for the readiness of elements.  This also includes the RunListener class, which is responsible for integrating with the TestRail.  We have already taken them into separate modules and use them to automate other applications. <br><br>  If we talk about other platforms, the experience gained can be very useful in order to build and implement similar processes.  We are now actively engaged in this on the iOS-direction and are thinking about Windows. <br><br><h2>  Conclusion </h2><br>  There are many options for the implementation and use of test automation.  We are of the opinion that automation is primarily a tool that is designed to facilitate the traditional process of ‚Äúhuman‚Äù testing, and not to eradicate it. </div><p>Source: <a href="https://habr.com/ru/post/434252/">https://habr.com/ru/post/434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434236/index.html">Amoeba neural network solved the traveling salesman problem for 8 cities</a></li>
<li><a href="../434238/index.html">Intel OpenVINO on Raspberry Pi: 2018 harvest</a></li>
<li><a href="../434244/index.html">I have an algorithm trader with my mother: we are looking for free frameworks for testing hypotheses and launching in combat mode (Python)</a></li>
<li><a href="../434246/index.html">Apple confirms that some iPad Pros come slightly curved, but it says that this is normal.</a></li>
<li><a href="../434250/index.html">Network Security Trends in 2019</a></li>
<li><a href="../434254/index.html">Chasing the best</a></li>
<li><a href="../434256/index.html">For testing 5G, only two frequency bands are allocated.</a></li>
<li><a href="../434258/index.html">Winter internship for mobile developers at Redmadrobot</a></li>
<li><a href="../434260/index.html">Microsoft is holding a contest of AI agents on the Minecraft platform</a></li>
<li><a href="../434262/index.html">We write and reduce the album under Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>