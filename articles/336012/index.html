<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Support for system errors in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 I have been wondering for a long time whether it is necessary to translate this already known series of articles called System error suppor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Support for system errors in C ++</h1><div class="post__text post__text-html js-mediator-article"><h2>  Foreword </h2><br>  I have been wondering for a long time whether it is necessary to translate this already known series of articles called System error support in C ++ 0x, which tells about <code>&lt;system_error&gt;</code> and error handling.  On the one hand, it was written in 2010 and I simply may be considered necrophilic, but on the other hand, very little information on this topic in RuNet is available and many fairly recent articles refer to this cycle, which suggests that it does not lose its relevance to this day. day. <br><br>  Therefore, I decided that to perpetuate this work <s>in granite</s> on Habr√© would be a good idea. <br><br>  I just want to warn you that I don‚Äôt have the experience of a translator and in general May English is out of trouble.  And chagrin.  So I will be glad to your criticism and suggestions, preferably in a personal. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So let's get started. <br><a name="habracut"></a><br><h2>  Part 1 </h2><br><h3>  Introduction </h3><br>  Among the new functions of the standard library in C ++ 0x there is a small header file called <code>&lt;system_error&gt;</code> .  It provides a set of tools for managing, suddenly, system errors. <br><br>  The main components defined in it are: <br><br><ul><li> <code>class error_category</code> </li> <li> <code>class error_code</code> </li> <li> <code>class error_condition</code> </li> <li> <code>class system_error</code> </li> <li> <code>enum class errc</code> </li> </ul><br>  I had a hand in the design of this module, so in the series of my articles I will try to tell about the reasons for its appearance, its history, and the intended use of its components. <br><br><h3>  Where to get? </h3><br>  Full implementation, as well as support for C ++ 03, is included in <a href="http://www.boost.org/">Boost</a> .  I assume that at the moment this is probably the best proven implementation in terms of portability.  Of course, you should write <code>boost::system::</code> , not <code>std::</code> . <br><br>  The implementation is included in <a href="http://gcc.gnu.org/">GCC</a> 4.4 and later.  However, you must compile your program with the -std = c ++ 0x option to use it. <br><br>  Finally, <a href="https://www.microsoft.com/ru-ru/SoftMicrosoft/VisualStudioExpress.aspx">Microsoft Visual Studio 2010</a> will come with an implementation of these classes <i>[but with limitations]</i> .  The main limitation is that <code>system_category()</code> does not represent a Win32 error as it was intended.  More on what this means will be said later. <br><br>  (Note that these are only implementations of which I know. There may be others). <br><br>  <i>[Translator's note: of course, this information has long been outdated, now <code>&lt;system_error&gt;</code> is an integral part of the modern standard library]</i> <br><br><h3>  Short review </h3><br>  The following are the types and classes defined in <code>&lt;system_error&gt;</code> , in a nutshell: <br><br><ul><li>  <code>class error_category</code> - the base class, used to identify sources of errors, as well as categories of error codes and conditions. </li><li>  <code>lass error_code</code> - represents the specific error value returned by the operation (for example, a system call). </li><li>  <code>class error_condition</code> - something that you want to check and possibly respond to it in your code. </li><li>  <code>class system_error</code> is the exception used to wrap <code>error_code</code> when an error is passed using throw / catch. </li><li>  <code>enum class errc</code> is a set of common error conditions inherited from POSIX. </li><li>  <code>is_error_code_enum&lt;&gt;, is_error_condition_enum&lt;&gt;, make_error_code, make_error_condition</code> is a mechanism for converting enums with error values ‚Äã‚Äãto <code>error_code</code> or <code>error_condition</code> . </li><li>  <code>generic_category()</code> - returns a category object used to classify error codes and conditions based on <code>errc</code> . </li><li>  <code>system_category()</code> - returns the category object used to <i>[classify]</i> error codes originating from the operating system. </li></ul><br><h3>  Principles </h3><br>  This section lists some basic principles that I adhered to when designing a module.  (I can not speak for the rest of the participants).  As with most software projects, some of them were targets from the start, and some arose in the process. <br><br><h4>  Not all errors are exceptional. </h4><br>  Simply put, exceptions are not always the right way to handle errors.  (In some circles this statement is controversial, although I really do not understand why.) <br><br>  For example, in network programming, errors such as are commonly encountered: <br><br><ul><li>  You could not connect to the remote IP address. </li><li>  Your connection has dropped. </li><li>  You tried to open an IPv6 socket, but you do not have available IPv6 network interfaces. </li></ul><br>  Of course, they can be exceptional circumstances, but equally they can be processed as part of the normal flow of control.  If you reasonably expect this to happen, this is not exceptional.  Respectively: <br><br><ul><li>  The IP address is just one of the list of addresses corresponding to the host name.  You want to try to connect to the next address in the list. </li><li>  The network is unreliable.  You want to try to reconnect and surrender only after N failures. </li><li>  Your program may return to using an IPv4 socket. </li></ul><br>  Another requirement, in the case of asio, was a way to pass the result of an asynchronous operation to a completion handler.  In this case, I want the error code to be an argument to the callback handler. <br><br>  (An alternative approach is to provide a means for reconstructing exceptions inside a handler, such as the asynchronous .NET <code>BeginXYZ/EndXYZ</code> . In my opinion, this design adds complexity and makes the API more error-prone.) <br><br>  <i>[Translator's note: now this tool can be <code>std::exception_ptr</code> from C ++ 11]</i> <br><br>  Last but not least, exceptions cannot be used in some areas due to code size and performance limitations. <br><br>  In general, you need to be pragmatic, not dogmatic.  It is best to use any error mechanism in terms of clarity, correctness, limitations and, yes, even personal taste.  Often the correct criterion for deciding between an exception and an error code is the method of use.  This means that the presentation of the system error should support both <i>[options]</i> . <br><br><h4>  Errors come from several sources. </h4><br>  The C ++ 03 standard recognizes errno as the source of error codes.  It is used by stdio functions, some mathematical functions, and so on. <br><br>  On POSIX platforms, many system operations use errno to transmit errors.  POSIX defines additional error codes errno to cover these cases. <br><br>  Windows, on the other hand, does not use errno outside of the standard C library. Windows API calls usually report errors via <code>GetLastError()</code> . <br><br>  When considering network programming, the <code>getaddrinfo</code> family of functions uses its own set of error codes (EAI _...) on POSIX, but shares the ‚Äúnamespace‚Äù <code>GetLastError()</code> in Windows.  Programs that integrate other libraries (for SSL, regular expressions, and so on) will encounter other categories of error codes. <br><br>  Programs must be able to manage these error codes in a consistent manner.  I am particularly interested in the <i>[way]</i> that will allow combining operations to create higher level abstractions.  Combining system calls, <code>getaddrinfo</code> , SSL and regular expressions into one API should not force the user of this API to deal with the ‚Äúexplosion‚Äù of error code types.  Adding a new source of errors to the implementation of this API should not change its interface. <br><br><h4>  The possibility of custom extensions </h4><br>  Standard library users should be able to add their own sources of error.  This feature can be used simply to integrate a third-party library, but it is also associated with the desire to create higher-level abstractions.  When developing a protocol implementation such as HTTP, I want to be able to add a set of error codes that correspond to the errors defined in the RFC. <br><br><h4>  Preservation of the original error code </h4><br>  This was not one of my original goals: I thought the standard would provide a set of well-known error codes.  If the system operation returned an error, the library should translate the error into well-known code (if such a mapping made sense). <br><br>  Fortunately, someone pointed out to me the problem of my approach.  The translation of the error code clears the information: the error returned by the main system call is lost.  This may not be very important from the point of view of the program‚Äôs control flow, but it is very important for supporting the program.  There is no doubt that programmers will use a standardized error code for logging and tracing, and the initial error may be vital for diagnosing problems. <br><br>  This final principle is perfectly combined with my theme for the second part: <code>error_code</code> vs <code>error_condition</code> .  Keep in touch. <br><br><h2>  Part 2 </h2><br><h3>  error_code vs error_condition </h3><br>  Of the 1000+ pages of the C ++ 0x standard, a casual reader should notice one thing: error_code and error_condition look almost identical!  What's happening?  These are the consequences of mindless copy-paste? <br><br><h3>  What matters is what you do about it. </h3><br>  Let's look at the descriptions that I gave in the first part, once again: <br><br><ul><li>  <code>lass error_code</code> - represents the specific error value returned by the operation (for example, a system call). </li><li>  <code>class error_condition</code> - something that you want to check and possibly respond to it in your code. </li></ul><br>  Classes are different because they are intended for different purposes.  As an example, consider a hypothetical function called <code>create_directory()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_directory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; pathname, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code &amp; ec )</span></span></span></span>;</code> </pre> <br>  Which you call as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; create_directory(<span class="hljs-string"><span class="hljs-string">"/some/path"</span></span>, ec);</code> </pre> <br>  The operation can fail for various reasons, for example: <br><br><ul><li>  No rights required. </li><li>  Directory already exists. </li><li>  The path is too long. </li><li>  Parent path does not exist. </li></ul><br>  Whatever the cause of the failure, when the <code>create_directory()</code> function returns control <code>ec</code> will contain an error code specific to the OS.  On the other hand, if the call was successful, then <code>ec</code> will have a zero value.  This is a tribute to tradition (used by errno and <code>GetLastError()</code> ), when zero indicates success, and any other values ‚Äã‚Äãindicate an error. <br><br>  If you are only interested in whether the operation was successful or unsuccessful, you can use the fact that <code>error_code</code> easily converted to <code>bool</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; create_directory(<span class="hljs-string"><span class="hljs-string">"/some/path"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-comment"><span class="hljs-comment">//Success. } else { //Failure. }</span></span></code> </pre> <br>  However, suppose you are interested in checking for the error ‚Äúdirectory already exists‚Äù.  If this error happens, our hypothetical program can continue to work.  Let's try to implement this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; create_directory(<span class="hljs-string"><span class="hljs-string">"/some/path"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ec.value() == EEXIST) <span class="hljs-comment"><span class="hljs-comment">//No! ...</span></span></code> </pre> <br>  This code is incorrect.  It can make money on POSIX platforms, but do not forget that <code>ec</code> will contain a platform-specific error.  On Windows, the error is likely to be <code>ERROR_ALREADY_EXISTS</code> .  (Worse, the code does not check the category of the error code, but we'll talk about this later.) <br><br>  <b>The rule of thumb is that</b> if you call <code>error_code::value()</code> , then you are doing something wrong. <br><br>  So you have a platform- <code>EEXIST</code> error <b>code</b> ( <code>EEXIST</code> or <code>ERROR_ALREADY_EXISTS</code> ) that you want to match with the <i>[platform-independent]</i> error <b>condition</b> (‚Äúdirectory already exists‚Äù).  Yes, that's right, you need <code>error_condition</code> . <br><br><h3>  Comparison error_code and error_condition </h3><br>  Here is what happens when comparing the <code>error_code</code> and <code>error_condition</code> objects (that is, when using the == operator or! = Operator): <br><br><ul><li>  <code>error_code</code> and <code>error_code</code> - the exact match is checked. </li><li>  <code>error_condition</code> and <code>error_condition</code> - an exact match is checked. </li><li>  <code>error_code</code> and <code>error_condition</code> - <b>equivalence</b> is checked. </li></ul><br>  I hope it is now obvious that you should compare your platform- <code>ec</code> error code <code>ec</code> with the <code>error_condition</code> object, which represents the ‚Äúdirectory already exists‚Äù error.  Just for this case, C ++ 0x provides <code>std::errc::file_exists</code> .  This means that you should write: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; create_directory(<span class="hljs-string"><span class="hljs-string">"/some/path"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::file_exists == ec) ...</code> </pre> <br>  This works because the developer of the standard library has determined the equivalence between the error codes <code>EEXIST</code> or <code>ERROR_ALREADY_EXISTS</code> and the error condition <code>std::errc::file_exists</code> .  Later I will show how you can add your own error codes and conditions with corresponding definitions of equivalence. <br><br>  (Note that, to be precise, <code>std::errc::file_exists</code> is one of the enum values ‚Äã‚Äãfrom the <code>enum class errc</code> . For now, you should think of the enumerated values ‚Äã‚Äãof <code>std::errc::*</code> as labels for <code>error_condition</code> constants. In I will explain the next part how it works.) <br><br><h3>  How to find out what conditions you can check? </h3><br>  Some of the new library functions in C ++ 0x have an error condition section.  These sections list the <code>error_condition</code> constants and the conditions under which equivalent error codes are generated. <br><br><h3>  A bit of history </h3><br>  The original <code>error_code</code> class was proposed for TR2 as an auxiliary component in the file system libraries and network libraries.  In that design, the <code>error_code</code> constant was implemented so that it, whenever possible, corresponded to a platform-specific error.  If a match is impossible or there are several matches, the library implementation converts a platform-specific error to standard <code>error_code</code> . <br><br>  In the email discussions, I learned about the value of maintaining the original error code.  Subsequently, the <code>generic_error</code> class was prototyped, but it did not suit me.  A satisfactory solution was found when renaming <code>generic_error</code> to <code>error_condition</code> .  In my experience, naming is one of the most difficult problems in the field of computer science, and choosing a good name is the main job. <br><br>  In the next part, we will look at the mechanism that makes the <code>enum class errc</code> work as a set of constants for <code>error_condition</code> . <br><br><h2>  Part 3 </h2><br><h3>  Enumerated values ‚Äã‚Äãas class constants </h3><br>  As we have seen, the <code>&lt;system_error&gt;</code> header file defines a <code>class enum errc</code> as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">errc</span></span></span><span class="hljs-class"> {</span></span> address_family_not_supported, address_in_use, ... value_too_large, wrong_protocol_type, };</code> </pre> <br>  The enumerated values ‚Äã‚Äãof which are constants for <code>error_condition</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; create_directory(<span class="hljs-string"><span class="hljs-string">"/some/path"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::file_exists == ec) ...</code> </pre> <br>  Obviously, an implicit conversion from <code>errc</code> to <code>error_condition</code> is used here using a single argument constructor.  Simply.  Right? <br><br><h3>  It's not quite that easy. </h3><br>  There are several reasons why it is a bit more complicated: <br><br><ul><li>  The enumerated value indicates the error itself, but to build an <code>error_condition</code> it is also necessary to know the category of the error.  The <code>&lt;system_error&gt;</code> module uses categories to support multiple sources of errors.  A category is an attribute for both <code>error_code</code> and <code>error_condition</code> . </li><li>  The object must be expandable.  That is, users (as well as future extensions of the standard library) should be able to define their own constants. </li><li>  The object must support constants for both <code>error_code</code> and <code>error_condition</code> .  Although the <code>enum class errc</code> provides constants only for <code>error_condition</code> , in other use cases, constants like <code>error_code</code> may be required. </li><li>  Finally, explicit conversion from the enumerated value to <code>error_code</code> or <code>error_condition</code> should be supported.  Ported programs may need to create error codes inherited from <code>std::errc::*</code> . </li></ul><br>  So, although it is true that the line: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::file_exists == ec)</code> </pre> <br>  implicitly converted from <code>errc</code> to <code>error_condition</code> , there are a few more steps. <br><br><h4>  Step 1: Determine whether the enumerated value is an error code or a condition </h4><br>  For registration of types of transfers two templates are used: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_error_code_enum</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_error_condition_enum</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {};</code> </pre> <br>  If a type is registered using <code>is_error_code_enum&lt;&gt;</code> , then it can be implicitly converted to <code>error_code</code> .  Similarly, if a type is registered using <code>is_error_condition_enum&lt;&gt;</code> , it can be implicitly converted to <code>error_condition</code> .  By default, types are registered without conversion (hence the use of <code>false_type</code> above), but the <code>enum class errc</code> registered as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_error_condition_enum</span></span></span><span class="hljs-class">&lt;errc&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {};</code> </pre> <br>  Implicit conversion is performed using conditionally resolved conversion constructors.  This is probably implemented using <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> , but for simplicity you need to think of it as: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error_condition</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//Only available if registered //using is_error_condition_enum&lt;&gt;. template&lt;class ErrorConditionEnum&gt; error_condition(ErrorConditionEnum e); ... }; class error_code { ... //Only available if registered //using is_error_code_enum&lt;&gt;. template&lt;class ErrorCodeEnum&gt; error_code(ErrorCodeEnum e); ... };</span></span></code> </pre> <br>  Therefore, when we write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::file_exists == ec)</code> </pre> <br>  The compiler chooses between these two overloads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; b ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_condition &amp; b );</code> </pre> <br>  It will select the latter, since the <code>error_condition</code> conversion constructor is available, but <code>error_code</code> not. <br><br><h4>  Step 2: match the error value with the error category </h4><br>  The <code>error_condition</code> object contains two attributes: a value and a category.  Now, when we got to the constructor, they need to be initialized correctly. <br><br>  This is achieved thanks to the constructor having the call to the function <code>make_error_condition()</code> . <br>  The ability to custom extension is implemented using the <a href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup">ADL</a> mechanism.  Of course, since <code>errc</code> is located in the <code>std</code> , ADL finds <code>make_error_condition()</code> in the same place. <br><br>  The implementation of <code>make_error_condition()</code> is simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">error_condition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_error_condition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errc e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error_condition ( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(e), generic_category() ); }</code> </pre> <br>  As you can see, this function uses the <code>error_condition</code> constructor with two arguments to explicitly specify both the error value and the category. <br><br>  If we were in the <code>error_code</code> conversion constructor (for a properly registered enumeration type), the called function would be <code>make_error_code()</code> .  The rest of the construction of <code>error_code</code> and <code>error_condition</code> same. <br><br><h3>  Explicit conversion to error_code or error_condition </h3><br>  Although <code>error_code</code> is primarily intended for use with platform-specific errors, portable code may want to create <code>error_code</code> from an enumerated <code>errc</code> value.  For this reason, the [functions] <code>make_error_code(errc)</code> and <code>make_error_condition(errc)</code> .  Portable code can use them as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code &amp; ec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_WIN32) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Windows implementation ... #elif defined(linux) //Linux implementation ... #else //do_foo not supported on this platform ec = make_error_code(std::errc::not_supported); #endif }</span></span></span></span></code> </pre> <br><br><h3>  A little more history </h3><br>  Initially, the <code>error_code</code> constants in <code>&lt;system_error&gt;</code> were defined as objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> error_code address_family_not_supported; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> error_code address_in_use; ... <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> error_code value_too_large; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> error_code wrong_protocol_type;</code> </pre> <br>  The LWG was concerned about the costs due to the large number of global objects and requested an alternative solution.  We investigated the possibility of using <code>constexpr</code> , but in the end it turned out to be incompatible with some other aspects of <code>&lt;system_error&gt;</code> .  Thus, only the conversion from the enumeration remained, since it was the best design available. <br><br>  Next, I'll begin to show how you can add your own error codes and conditions. <br><br><h2>  Part 4 </h2><br><h3>  Creating your own error codes </h3><br>  As I said in the first part, one of the principles of <code>&lt;system_error&gt;</code> is extensibility.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that you can use the mechanism just described to define your own error codes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, I will describe what you need to do. </font><font style="vertical-align: inherit;">As a basis for a working example, suppose you are writing an HTTP library and you need errors that correspond </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2_%25D1%2581%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D1%258F_HTTP"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to HTTP status codes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 1: Determine Error Values </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First you need to define a set of error values. </font><font style="vertical-align: inherit;">If you are using C ++ 0x, you can use the </font></font><code>class enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">same one </font></font><code>std::errc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_error</span></span></span><span class="hljs-class"> {</span></span> continue_request = <span class="hljs-number"><span class="hljs-number">100</span></span>, switching_protocols = <span class="hljs-number"><span class="hljs-number">101</span></span>, ok = <span class="hljs-number"><span class="hljs-number">200</span></span>, ... gateway_timeout = <span class="hljs-number"><span class="hljs-number">504</span></span>, version_not_supported = <span class="hljs-number"><span class="hljs-number">505</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Errors are assigned values ‚Äã‚Äãaccording to HTTP status codes. The importance of this will become apparent when it comes to the use of error codes. Regardless of which values ‚Äã‚Äãyou choose, errors must have non-zero values. As you remember, an object </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses a convention in which zero means success. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use the regular (i.e., C ++ 03 compatible) </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by dropping the keyword </font></font><code>class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> http_error { ... };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b> <code>class enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> differs from the </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fact that the first one encloses the names of the enumerated values ‚Äã‚Äãin the class scope </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[while the second one ‚Äúthrows‚Äù them into the global scope)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To access the enumeration values, you must specify the name of the class, for example </font></font><code>http_error::ok</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can emulate this behavior by wrapping the usual </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namespace </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font><code>namespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> http_error { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">http_error_t</span></span> { ... }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the rest of this example, I will use </font></font><code>enum class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Applying a namespace approach remains as an exercise for the reader. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Translator's note: in fact, they differ not only in scope </font></font><code>enum class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but also prohibits implicit conversion of enumerated values ‚Äã‚Äãto other types]</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 2: Define the class error_category </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An object </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consists of an error value and a category. </font><font style="vertical-align: inherit;">The error category defines what the given enumeration value specifically means. </font><font style="vertical-align: inherit;">For example, 100 may refer to both </font></font><code>http_error::continue_request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>std::errc::network_down</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ENETDOWN in Linux), and maybe something else. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a new category, you need to inherit a class from </font></font><code>error_category</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_category_impl</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, this class will implement only pure virtual functions </font></font><code>error_category</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 3: Give the category a human-readable name. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A virtual function </font></font><code>error_category::name()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must return a string identifying the category:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * http_category_impl::name() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"http"</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This name does not have to be completely unique, as it is used only when writing the error code in </font></font><code>std::ostream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, it would be desirable to make it unique within this program.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 4: Convert Error Codes To Strings </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>error_category::message()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converts the error value to the string describing it:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> http_category_impl::message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ev) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ev) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::continue_request: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Continue"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::switching_protocols: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Switching protocols"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::ok: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::gateway_timeout: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Gateway time-out"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::version_not_supported: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"HTTP version not supported"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown HTTP error"</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you call a function </font></font><code>error_code::message()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in turn, it calls the above virtual function to get an error message. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to remember that these error messages should be autonomous. </font><font style="vertical-align: inherit;">They can be recorded (in a log file, say) at that point in the program where additional context is not available. </font><font style="vertical-align: inherit;">If you wrap an existing API that uses error messages with ‚Äúinserts‚Äù, you will have to create your own messages. </font><font style="vertical-align: inherit;">For example, if the HTTP API uses a message string </font></font><code>"HTTP version %d.%d not supported"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the equivalent offline message will be </font></font><code>"HTTP version not supported"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module</font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not provide any help when it comes to localizing these messages. </font><font style="vertical-align: inherit;">It is likely that messages originating from the error categories of the standard library will be based on the current locale. </font><font style="vertical-align: inherit;">If your program requires localization, I recommend using the same approach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of history: The</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LWG recognized the need for localization, but there was no design that satisfactorily agreed localization with extensibility. Instead of collecting committees to address this issue, the LWG chose not to say anything about the localization of error messages in the standard.)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 5: unique category identification </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The object identifier inherited from </font></font><code>error_category</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is determined by its address. </font><font style="vertical-align: inherit;">This means that when you write:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category &amp; cat1 = ...; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category &amp; cat2 = ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cat1 == cat2) ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The condition </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is evaluated as if you wrote:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(&amp;cat1 == &amp;cat2) ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Following the example set by the standard library, you must provide a function to return a reference to the category object: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function should always return a reference to the same object. </font><font style="vertical-align: inherit;">One way to do this is to define a global object in the source file and return a link to it:</font></font><br><br><pre> <code class="cpp hljs">http_category_impl http_category_instance; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http_category_instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, global variables cause problems with the order of initialization between modules. </font><font style="vertical-align: inherit;">An alternative approach is to use a local static variable:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> http_category_impl instance; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the category object is initialized at first use. </font><font style="vertical-align: inherit;">C ++ 0x also ensures that initialization is thread safe. </font><font style="vertical-align: inherit;">(C ++ 03 did not give such a guarantee). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">History:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the early design stages, we considered using a whole number or string to identify categories. </font><font style="vertical-align: inherit;">The main problem with this approach was to ensure uniqueness in combination with extensibility. </font><font style="vertical-align: inherit;">If a category is identified by a whole number or string, what prevents conflicts between two unrelated libraries? </font><font style="vertical-align: inherit;">Using the same identity. </font><font style="vertical-align: inherit;">Furthermore, it makes it possible to make error and polymorphic polymorphic errors.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 6: Build error_code from enum </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I showed in part 3, the implementation </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires a function with a name </font></font><code>make_error_code()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in order to associate the error value with a category. </font><font style="vertical-align: inherit;">For HTTP errors, this function might look like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_code </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_error_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(http_error e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(e), http_category() ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For completeness, you should also provide an equivalent function for building </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_condition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_error_condition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(http_error e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_condition ( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(e), http_category() ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the implementation </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finds these functions using ADL, you must place them in the same namespace as the type </font></font><code>http_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 7: write for implicit conversion to error_code </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So that the enumerated values </font></font><code>http_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used as constants </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, enable the transformation constructor using the template </font></font><code>is_error_code_enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_error_code_enum</span></span></span><span class="hljs-class">&lt;http_error&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; }</code> </pre> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 8 (optional): define default error conditions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some of the errors you describe may have similar error conditions from </font></font><code>errc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, the HTTP status code 403 Forbidden means the same as </font></font><code>std::errc::permission_denied</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The virtual function </font></font><code>error_category::default_error_condition()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to define an error condition equivalent to a given error code. </font><font style="vertical-align: inherit;">(The definition of equivalence was described in the second part.) For HTTP errors, you can write:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_category_impl</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_condition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default_error_condition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_condition http_category_impl::default_error_condition(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ev) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ev) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> http_error::forbidden: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::permission_denied; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_condition(ev, *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you decide not to redefine this virtual function, it </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will have the same error and category as </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the default behavior, as in the example shown above.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using Error Codes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can use enumerated values </font></font><code>http_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as constants </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, like when setting the error:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server_side_http_handler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ..., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code &amp; ec )</span></span></span><span class="hljs-function"> </span></span>{ ... ec = http_error::ok; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and when checking it: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; load_resource(<span class="hljs-string"><span class="hljs-string">"http://some/url"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(http_error::ok == ec) ...</code> </pre> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Translator's note: it should be noted that with such an implementation, the principle described above will not work - zero value = success - respectively, casting </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will not work either]</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since error values ‚Äã‚Äãare based on HTTP status codes, we can also set </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directly from the response :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_resource</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; url, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code &amp; ec )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//send request ... //receive response ... int response_code; parse_response(..., &amp;response_code); ec.assign(response_code, http_category()); ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you can use this method when wrapping errors created by an existing library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, if you defined an equivalence relation in step 8, you can write:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; data = load_resource(<span class="hljs-string"><span class="hljs-string">"http://some/url"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::permission_denied == ec) ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without having to know the exact source of the error condition. </font><font style="vertical-align: inherit;">As explained in part 2, the original error code (for example, </font></font><code>http_error::forbidden</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is preserved, so no information is lost. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next part, I will show how to create and use </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2>  Part 5 </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating your own error conditions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The extensibility of the module is </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not limited to error codes: </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it can also be expanded.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why create your own error conditions? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To answer this question, let's return to the differences between </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li> <code>lass error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - represents the specific error value returned by the operation (for example, a system call). </font></font></li><li> <code>class error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - something that you want to check and possibly react to it in your code. </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It offers some use cases for custom error conditions: </font></font><br><br><ul><li> <b>  .</b> <br> ,      <code>getaddrinfo()</code> .    :  ¬´     ,   ¬ª   ¬´  ¬ª.  <code>getaddrinfo()</code>      : <br><br><ul><li>   POSIX   <code>EAI_AGAIN</code>  <code>EAI_NONAME</code> , .      ¬´ ¬ª   errno.  ,      <code>error_category</code>  . </li><li>  Windows   <code>WSAEAI_AGAIN</code>  <code>WSAEAI_NONAME</code> .      POSIX,   ¬´ ¬ª <code>GetLastError()</code> . ,     <code>std::system_category()</code>    <code>getaddrinfo()</code>   . </li></ul><br>    ,       ,      (, , <code>name_not_found_try_again</code>  <code>name_not_found</code> ),      API. </li><li> <b>      .</b> <br>    POSIX  errno    .  ,        ,      ,        ,   .          ,     . <br><br> ,      ,       .     ,    <code>open()</code>    .    errno  <code>ENOENT</code> ,    . <br><br>        ,        <code>no_such_file_or_directory</code> .          <code>no_such_entry</code> ,  <code>ENOENT</code> . </li><li> <b>   .</b> <br>         ,           . ,       : <br><br><ul><li> <code>not_enough_memory</code> </li> <li> <code>resource_unavailable_try_again</code> </li> <li> <code>too_many_files_open</code> </li> <li> <code>too_many_files_open_in_system</code> </li> <li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in several places, but the subsequent action is different at each point of use. </font><font style="vertical-align: inherit;">This shows that there is a more general condition: ‚Äúnot enough system resources‚Äù, which you want to check and respond to in your code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A custom error condition </font></font><code>low_system_resources</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be defined so that its equivalence is based on a combination of other error conditions. </font><font style="vertical-align: inherit;">This will allow you to write checks as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(low_system_resources == ec) ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and thus eliminate the repetition of individual checks. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you will see below, the definition is </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar to the definition </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 1: Determine Error Values </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to create </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for error values, similarly </font></font><code>std::errc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">api_error</span></span></span><span class="hljs-class"> {</span></span> low_system_resources = <span class="hljs-number"><span class="hljs-number">1</span></span>, ... name_not_found, ... no_such_entry };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The actual values ‚Äã‚Äãthat you use are not important, but you must make sure that they are different and non-zero. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 2: Define the class error_category </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An object </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consists of an error value and a category. </font><font style="vertical-align: inherit;">To create a new category, you need to inherit a class from </font></font><code>error_category</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">api_category_impl</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equivalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code &amp; code, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 3: Give the category a human-readable name. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A virtual function </font></font><code>error_category::name()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must return a string identifying the category:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * api_category_impl::name() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"api"</span></span>; }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 4: convert error conditions to strings </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>error_category::message()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converts the error value to the string describing it:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> api_category_impl::message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ev) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ev) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> api_error::low_system_resources: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Low system resources"</span></span>; .. } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, depending on your use case, a call </font></font><code>error_condition::message()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may not be likely. </font><font style="vertical-align: inherit;">In this case, you can use the abbreviation and just write:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> api_category_impl::message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ev) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"api error"</span></span>; }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 5: Implement Error Equivalence </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A virtual function is </font></font><code>error_category::equivalent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to determine the equivalence of error codes and conditions. </font><font style="vertical-align: inherit;">There are two overloads of this feature.</font></font> First: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equivalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> code, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_condition &amp; condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to establish equivalence between </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the current category and arbitrary </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Second overload:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equivalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; code, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defines equivalence between </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the current category and arbitrary </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Because you create error conditions, you need to override the second overload. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The definition of equivalence is simple: return </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if you want it to </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be equivalent to your condition, otherwise return </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you intend to abstract from platform-specific errors, you can implement it </font></font><code>error_category::equivalent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> api_category_impl::equivalent(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code &amp; code, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> condition) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(condition) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> api_error::name_not_found: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_WIN32) return code == std::error_code(WSAEAI_NONAME, system_category()); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return code == std::error_code(EAI_NONAME, getaddrinfo_category()); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> ... default: return false; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Obviously, it </font></font><code>getaddrinfo_category()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also needs to be defined somewhere.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checks can be complex, and other constants can also be reused </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> api_category_impl::equivalent(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code &amp; code, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> condition) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(condition) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> api_error::low_system_resources: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::not_enough_memory || code == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::resource_unavailable_try_again || code == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::too_many_files_open || code == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::too_many_files_open_in_system; ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> api_error::no_such_entry: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::errc::no_such_file_or_directory; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 6: unique category identification </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You must define a function to return a reference to the category object: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which always returns a link to the same object. </font><font style="vertical-align: inherit;">As with error codes, you can use a global variable:</font></font><br><br><pre> <code class="cpp hljs">api_category_impl api_category_instance; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api_category_instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or you can use static thread-safe variables from C ++ 0x: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_category &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_category</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> api_category_impl instance; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 7: Build error_condition from enum </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An implementation </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires a function with a name </font></font><code>make_error_code()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in order to associate an error value with a category:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">error_condition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_error_condition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api_error e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_condition ( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(e), api_category() ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To complete the picture, you also need to define an equivalent function for the construction </font></font><code>error_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I will leave this as an exercise for the reader.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 8: write for implicit conversion to error_condition </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, in order for enumerated values ‚Äã‚Äãto </font></font><code>api_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be used as constants </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, enable the transform constructor using a template </font></font><code>is_error_condition_enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_error_condition_enum</span></span></span><span class="hljs-class">&lt;api_error&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use of error conditions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now enumerated values </font></font><code>api_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used as constants </font></font><code>error_condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as those defined in </font></font><code>std::errc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code ec; load_resource(<span class="hljs-string"><span class="hljs-string">"http://some/url"</span></span>, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(api_error::low_system_resources == ec) ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have said several times, the original error code is preserved and information is not lost. </font><font style="vertical-align: inherit;">It does not matter whether the error code came from the operating system or from the HTTP library with its own category of errors. </font><font style="vertical-align: inherit;">Your custom error conditions will work equally well anyway. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next, probably the last, part I will explain how to create APIs that use </font></font><code>&lt;system_error&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2>  Afterword </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alas, despite the promises of the author, the cycle of articles was not completed. </font><font style="vertical-align: inherit;">The next part did not come out. </font><font style="vertical-align: inherit;">And it is unlikely to come out.</font></font></div><p>Source: <a href="https://habr.com/ru/post/336012/">https://habr.com/ru/post/336012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335998/index.html">How to make a project on the recognition of handwritten numbers with additional training online. Hyde for not quite beginners</a></li>
<li><a href="../336000/index.html">Myriads of running C # tasks</a></li>
<li><a href="../336002/index.html">How to complete the first project</a></li>
<li><a href="../336006/index.html">Liscript - web REPL: kisses, bikes and excavators</a></li>
<li><a href="../336010/index.html">React Native: from simple animation to interactive at 60 FPS</a></li>
<li><a href="../336016/index.html">CrowdSourcing Accelerator</a></li>
<li><a href="../336018/index.html">Change of consumer preferences: in search of the ideal drive with support for the NVMe protocol</a></li>
<li><a href="../336020/index.html">30+ tools for professional development of Android applications</a></li>
<li><a href="../336022/index.html">Say no to solidity: how we made the CPA platform</a></li>
<li><a href="../336024/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ276 (August 14 - 20, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>