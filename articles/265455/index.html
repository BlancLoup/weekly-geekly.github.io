<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reversible Cyrillic transliteration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhaps someone else remembers writing SMS, and sometimes letters, in “transliteration.” But why transliteration today, when everywhere is already uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reversible Cyrillic transliteration</h1><div class="post__text post__text-html js-mediator-article">  Perhaps someone else remembers writing SMS, and sometimes letters, in “transliteration.”  But why transliteration today, when everywhere is already unicode?  Unfortunately, inherited applications go out of service much slower than we would like.  For example, today scanners are used that do not allow the Cyrillic alphabet in the names of patients.  Given that the information system used by the same department perfectly understands the Cyrillic alphabet.  And the tomograph operator needs not only to call the patient for research, but also to correctly write down his last name in some documents.  Similar situations may occur in different places. <br><br>  That is, the problem arises to somehow transfer the text data to the legacy system in order to: <br><ul><li>  the person - the operator of the inherited system was able to read the received text "by sound" </li><li>  if necessary, it would be possible to unambiguously restore the original Cyrillic text </li></ul><br>  To avoid being bored, let's add more detailed requirements related to compatibility and simplicity for a person: <br><ol><li>  use only letters in the narrow sense, without punctuation and diacritical elements (this will also save the register) </li><li>  convert each original letter independently of the rest (without complications like “at the beginning / end of a word”, etc.) </li><li>  replacements as short as possible, ideally single-letter </li><li>  inverse transformation rules are as simple as possible, for example, replacements must meet <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B8%25D0%25B5_%25D0%25A4%25D0%25B0%25D0%25BD%25D0%25BE">the Fano condition</a> </li><li>  close to sound substitutions, in the view of the "ordinary person" - in practice, it is a kind of mixture of Latin, English, French, German and, sometimes, Spanish phonetics </li></ol><br>  Of course, the listed requirements are not quite (except for the first two), but rather heuristics. <br><br>  You can find many ready-made options for translating the Cyrillic alphabet into Latin.  But among them there was nothing that would satisfy all the requirements to an acceptable degree.  Either uses accented characters as standards, then throws out letters (usually “b”), then offer irreversible (u -&gt; shch) or phonetically wild (w -&gt; w) replacement options, or have other <a href="http://www.drdobbs.com/windows/a-brief-history-of-windows-programming-r/225701475">fatal flaws</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So we make our bike.  Actually, you need to create a correspondence table, and describe the algorithm for converting there and back. <br><a name="habracut"></a><br><h2>  Table </h2><br>  Let's start with all the obvious one-letter replacements: <br><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td></td><td></td><td>  Z </td><td>  I </td><td></td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><br>  Remembering the requirement of possible short replacements, and since for “C” we use “S”, with a clear conscience we use the symbol “C” for “C”. <br><br>  For the remaining letters, the tradition (and simply the lack of Latin characters) tells us to use two-letter combinations.  For simplicity, the direct and, in particular, the inverse transformation, it would be good if the combinations form characters that are not used outside the combinations.  By Fano's condition, such a special character should be at the beginning of the combination, but the tradition is too strong and we will write the letter “H” at the end of the combination.  But, if the “H” symbol is not used separately and the conversion algorithm is allowed to “return” (in fact, remember) to the previous input symbol, for the postfix combinations, the “inverted” analogue of Fano condition can be considered fulfilled.  That is, the algorithm will be able to uniquely determine them. <br><br>  The special symbol for consonants is the same everywhere - “H”.  And for vowels, there are two options: "Y" and "J".  Although “Y” is more familiar, it is also often used separately, for “Y” or for “Y”.  And "J" is rather perceived as a purely auxiliary character. <br><br>  Resolved, use for vowels "J".  And by the way, the freed "Y" is used for "Y". <br><br>  Since “J” is now a special character, it cannot be used for “”, and only “ZH” remains.  Similarly, for “X” you cannot use “H”, and only “KH” remains. <br><br>  Now we can write down common and selected combinations and single characters: <br><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td></td><td>  <b>Zh</b> </td><td>  Z </td><td>  I </td><td>  <b>Y</b> </td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td>  <b>KH</b> </td><td>  <b>C</b> </td><td>  <b>CH</b> </td><td>  <b>SH</b> </td><td></td><td></td><td></td><td></td><td>  <b>EH</b> </td><td>  <b>JU</b> </td><td>  <b>Ja</b> </td></tr></tbody></table><br>  The common and good (in the sense of our requirements) replacements ended here, and we are embarking on the unsteady ground of “gag”, analogies and compromises. <br><br>  Let's start with "Y".  "Y" is already busy (remember about reversibility), and phonetically it is a bad substitute.  Let's look at the solution for "E" (taken, by the way, from ISO / R 9, 1968).  By analogy, "Y" should be replaced by "IH".  It is strange that this option has not met anywhere. <br><br>  With “Yo” the situation is also strange.  There is a clear, but not suitable for us option "E".  And there is a phonetic option "JO".  But in the Russian alphabet "E" is not accidentally made on the basis of "E", and not "O".  "E" often alternates with "E", for example, "Kl <b>yo</b> n - kle new", and never alternates with "O".  This results in another heuristic - the “alphabetic” (non-phonetic and non-graphic) proximity of letters.  As a result, for "E" we construct a replacement for "JE". <br>  Let's pause: <br><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td>  <b>Je</b> </td><td>  Zh </td><td>  Z </td><td>  I </td><td>  Y </td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td>  KH </td><td>  C </td><td>  CH </td><td>  SH </td><td></td><td></td><td>  <b>Ih</b> </td><td></td><td>  EH </td><td>  JU </td><td>  Ja </td></tr></tbody></table><br>  How nice it would be to stop at this and say that the problem was solved in the first approximation.  But there are still three letters, without which it can not do.  For the remaining letters there are no adequate options.  Signs are usually replaced with apostrophes, and literal substitutions are either just arbitrary or “witty,” like “b” -&gt; “q”.  For "U", a replacement without accents is usually 3 - 4 characters long, and there will still be problems with it. <br><br>  After long searches and sufferings, I had to stop at this reasoning: for letters that do not correspond to sounds, you cannot use letters for which sounds exist.  And we are left with only “special” symbols for the formation of combinations.  But according to Fano's condition they cannot be used separately, the combinations will become ambiguous. <br><br>  Exit - use a combination of special characters with each other.  This, apparently, will complicate the conversion algorithm a little more, but it seems possible to preserve uniqueness. <br><br>  For a hard sign (it’s only a separator), the replacement of “HH” seems intuitively appropriate (it cannot be read like a pause, a separation). <br><br>  And for a soft sign, the chain of associations (“J” -&gt; iroded vowels -&gt; softening of the previous consonant) + (“H” -&gt; division) leads to the replacement of “JH”. <br><br>  You can not call a beautiful decision, but among rotten apples, the choice is not great. <br><br>  Unfortunately, such a choice makes it impossible to use the replacement “Sh” -&gt; “SHH”.  The sequence "SHH" will mean "", and this combination is found in Russian (for example, "congress").  Here again there are no nice decisions, and it is necessary to look for at least somehow motivated.  The sound “” is close to the softened “”, and by analogy with the soft sign, this can be represented by the prefix “J”.  I understand that now I refer to myself that the code is still 3 and not standard.  But, as they say, "other writers we have for you are not." <br><br>  As a result: <br><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td>  Je </td><td>  Zh </td><td>  Z </td><td>  I </td><td>  Y </td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td>  KH </td><td>  C </td><td>  CH </td><td>  SH </td><td>  <b>Jsh</b> </td><td>  <b>HH</b> </td><td>  Ih </td><td>  <b>Jh</b> </td><td>  EH </td><td>  JU </td><td>  Ja </td></tr></tbody></table><br><h2>  Algorithm </h2><br>  Converting from Cyrillic to Latin is trivial.  We do not pay attention to the register for brevity. <br><div class="spoiler">  <b class="spoiler_title">Java code</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cyr2lat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ch){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"B"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"V"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"G"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"D"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"E"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"JE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ZH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Z"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"I"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Y"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"K"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"L"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"M"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"N"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"P"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"R"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"S"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"T"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"U"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"F"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"KH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"SH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"JSH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"HH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"IH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"JH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"EH"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"JU"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"JA"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String.valueOf(ch); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cyr2lat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>{ StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(s.length()*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch: s.toCharArray()){ sb.append(cyr2lat(ch)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } }</code> </pre> </div></div><br>  For example, the result of a couple of well-known pangrams: <br><blockquote>  Shirokaja ehlektrifikacija juzhnihkh guberniy dast mojshnihy tolchok podhhjemu seljhskogo khozjaystva. <br>  Shheshjh zhe ejshje ehtikh mjagkikh francuzskikh bulok da vihpey chaju. <br></blockquote><br>  It does not look very good, but the main purpose of this variant of transliteration is still the full name: <br><blockquote>  Aleksandr Ivanovich Lebedjh <br>  Georgiy Konstantinovich ZHukov <br></blockquote><br>  Inverse transformation is much more interesting.  Especially considering that it would be good to explain it to a person (not from IT) for execution “in mind”. <br>  Apparently, it is necessary to start with special cases. <br><ul><li>  As we read from left to right, the first thing we pay attention to the symbol "J".  Behind him must go one of the five characters: "E", "H", "U", "A" or "S" (for "S" should in this case be necessarily more "H"), and it turns out what's in the table for two or three letter combinations. </li><li>  If “J” is not present, we look, whether the letter “H” <i>follows</i> the symbol.  Here is the most difficult moment for attention: in this case <i>there</i> should <i>not</i> be an option when the <i>third</i> character again goes "H" (this is the code "HH").  That is, you need to see and analyze three characters in a row.  This is where the violation of the Fano condition auknulo (well, that once). </li><li>  If neither “J” nor a single “H” in the vicinity of the symbol was found, safely replace it in the table as a separate letter. </li></ul><br>  After a short workout, as practice shows, people are able to perform the inverse transformation manually.  But to force them to do it without special need, of course, is not necessary.  You can also automate (again, for simplicity, only for the string and in uppercase): <br><div class="spoiler">  <b class="spoiler_title">Java code</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lat2cyr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>{ StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; s.length()){<span class="hljs-comment"><span class="hljs-comment">//     .  ,     char ch = s.charAt(i); if(ch == 'J'){ //    i++; //      ch = s.charAt(i); switch (ch){ case 'E': sb.append( ''); break; case 'S': sb.append( ''); i++; //      if(s.charAt(i) != 'H') throw new IllegalArgumentException("Illegal transliterated symbol at position "+i);//      break; case 'H': sb.append( ''); break; case 'U': sb.append( ''); break; case 'A': sb.append( ''); break; default: throw new IllegalArgumentException("Illegal transliterated symbol at position "+i); } }else if(i+1 &lt; s.length() &amp;&amp; s.charAt(i+1)=='H' &amp;&amp; !(i+2 &lt; s.length() &amp;&amp; s.charAt(i+2)=='H')){//  ,      .          . switch (ch){ case 'Z': sb.append( ''); break; case 'K': sb.append( ''); break; case 'C': sb.append( ''); break; case 'S': sb.append( ''); break; case 'E': sb.append( ''); break; case 'H': sb.append( ''); break; case 'I': sb.append( ''); break; default: throw new IllegalArgumentException("Illegal transliterated symbol at position "+i); } i++; //   }else{//   switch (ch){ case 'A': sb.append( ''); break; case 'B': sb.append( ''); break; case 'V': sb.append( ''); break; case 'G': sb.append( ''); break; case 'D': sb.append( ''); break; case 'E': sb.append( ''); break; case 'Z': sb.append( ''); break; case 'I': sb.append( ''); break; case 'Y': sb.append( ''); break; case 'K': sb.append( ''); break; case 'L': sb.append( ''); break; case 'M': sb.append( ''); break; case 'N': sb.append( ''); break; case 'O': sb.append( ''); break; case 'P': sb.append( ''); break; case 'R': sb.append( ''); break; case 'S': sb.append( ''); break; case 'T': sb.append( ''); break; case 'U': sb.append( ''); break; case 'F': sb.append( ''); break; case 'C': sb.append( ''); break; default: sb.append(ch); } } i++; //     } return sb.toString(); }</span></span></code> </pre></div></div><br><h2>  Total </h2><br>  It would seem that a simple and long-solved problem, and what a space for creativity and discussion. <br><br>  Seriously, it turned out a working algorithm for reversible transliteration of all the letters of the Russian Cyrillic alphabet into Latin letters.  In this case, the result, with a discount on the rigidity of the requirements, is acceptable to read.  Can be used to integrate with legacy systems and libraries, to generate identifiers. <br><br>  I hope someone will find the solution useful, and the path to it will be entertaining. <br><br><h2>  Addition </h2><br>  Based on the discussion in the comments.  Need to be shorter and more formal. <br>  There are <i>no cancellable</i> requirements: <br><ol><li>  As a result of transliteration, <i>only</i> letters of the main Latin should be obtained <i>.</i> <div class="spoiler">  <b class="spoiler_title">(there are 26 of them)</b> <div class="spoiler_text">  abcdefghijklmnopqrstuvwxyz </div></div></li><li>  Transliteration must be <i>completely</i> reversible </li></ol><br>  There are <a href="https://clck.ru/9a9Ft">standards</a> .  None meet the requirements. <br>  It is necessary to choose one standard and modify it minimally, <i>only</i> to meet the requirements. <br>  Modifications are uniquely determined by the chain.  If you do not like the result, write, please, from what point of the chain do you disagree. <br><div class="spoiler">  <b class="spoiler_title">To justify the decisions a bit of theory.</b> <div class="spoiler_text">  <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Transliteration</a> is the exact transmission of <i>characters from</i> one script by characters from another. <br>  Not to be confused with <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2586%25D0%25B8%25D1%258F">phonetic transcription</a> - sound transmission is encouraged, but not guaranteed. <br>  Graphic similarity of symbols has the lowest priority.  For example, the transfer of the letter ha like x is not phonetically acceptable. <br><br>  Transliteration can be thought of as encoding characters in the source alphabet with variable length codes from the characters in the target alphabet.  The code can be: <br><ol><li>  single characters </li><li>  a prefix and the base character following it </li><li>  base character and some postfix following it </li><li>  base character with prefix and postfix </li></ol><br>  The prefix and postfix can be of different lengths, of course, the shorter the better.  And of course, it would be nice to have fewer different prefixes and postfixes. <br>  For Cyrillic and Latin, it is quite possible to confine one prefix and one postfix, both in one character. <br><br>  For the “easy reversibility” of codes, we introduce the following condition: <br><blockquote>  No code should start with a postfix and should not end with a prefix. <br></blockquote><br>  This is my generalization of the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4">prefix code</a> . <br>  If this condition is met, it can be argued that in any fragment of the resulting sequence there will be no long “false codes”.  That is, it is clear that you can cut off the prefix or postfix, and the remaining basic symbol will coincide with a single one. <br>  This can not be avoided and it will have to be remembered.  But it does not happen that a piece of a composite year is considered together with a neighboring single character as an unplanned composite code. <br>  For example, suppose we use the code "S", the code "SH" and the code "HH" (violates the condition, starts with a postfix).  Then in the sequence "SHH" (the third and first codes), you can select the fragment "SH" (corresponds to the second code). <br>  For prefixes, the violation of the “easy reversibility” condition is not so unpleasant (the difference is because the analysis goes from left to right).  But it also complicates the perception "by eye" - with a cursory review, we read the word as a whole, and not consistently, and we can "catch hold of" a random combination. <br>  A particular consequence of the condition introduced is the prohibition of the use of the prefix or postfix as single characters. <br><br>  For Cyrillic and Latin, postfix is ​​without the “H” variants. <br>  The prefix is ​​“Y” or “J”.  If you use the prefix "Y", it can not be used to transfer "Y" or "Y".  That is, for two letters (a "» "is quite frequent) you will have to come up with non-standard ones, far from phonetics, and most likely long codes. <br>  There is no problem with "J".  We didn’t want to use this symbol separately. <br></div></div><br>  I. Choose a starting standard. <br>  The most phonetically correct, of course, is BGN.  But BGN is fundamentally (even deliberately) not reversible. <br>  Closest to the base Latin and to reversibility, in my opinion, “GOST 16876-71 / table 2”, and we choose it. <div class="spoiler">  <b class="spoiler_title">...?</b> <div class="spoiler_text">  Ask why the “GOST 7.79-2000 / system B” is not relevant now.  Mainly for “X” -&gt; “X” and “Y” -&gt; “J”.  Well, today relevant - and tomorrow, as the previous GOST. </div></div><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td>  JO </td><td>  Zh </td><td>  Z </td><td>  I </td><td>  <b>Jj</b> </td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td>  KH </td><td>  C </td><td>  CH </td><td>  SH </td><td>  SHH </td><td>  <b>″</b> </td><td>  <b>Y</b> </td><td>  <b>′</b> </td><td>  EH </td><td>  JU </td><td>  Ja </td></tr></tbody></table><br>  The scheme is not perfect in terms of our requirements.  Have to change. <br>  Ii.  The first striking "JJ".  Why this is bad, you can see in the "theoretical" spoiler.  We follow the rule “look at BGN in any incomprehensible situation”.  That is, "Y" -&gt; "Y". <br>  Iii.  Now left without the code "Y".  BGN does not help.  There is a phonetic analogy in the “I-S” and “E-E” pairs.  To obtain the code of the letter "E", the standard adds a postfix to the code "E".  We also do: “Y” -&gt; “IH”. <br>  Iv.  Non-letter replacements for “b” and “b” remain.  In order not to destroy phonetics, we can use only prefixes and postfixes. <br>  V. Note that no one has forbidden (in the "theoretical" spoiler) to use postfix as a base character in combination with the prefix (at least), and vice versa.  That is, we have the codes "JH", "JHH" and "JJH". <br>  Vi.  It remains to distribute this wealth.  The most frequent “b” is the shortest code: “b” -&gt; “jh”. <br>  VII.  “Kommersant” has no sound, “H” is easier not to voice when reading.  So, choose from the remaining code, where more “H”: “” -&gt; “JHH”. <br><br>  Happened: <br><table><tbody><tr><td>  BUT </td><td>  B </td><td>  AT </td><td>  R </td><td>  D </td><td>  E </td><td>  Yo </td><td>  F </td><td>  H </td><td>  AND </td><td>  Th </td><td>  TO </td><td>  L </td><td>  M </td><td>  H </td><td>  ABOUT </td><td>  P </td><td>  R </td><td>  WITH </td><td>  T </td><td>  Have </td><td>  F </td><td>  X </td><td>  C </td><td>  H </td><td>  Sh </td><td>  U </td><td>  B </td><td>  S </td><td>  B </td><td>  Uh </td><td>  YU </td><td>  I </td></tr><tr><td>  A </td><td>  B </td><td>  V </td><td>  G </td><td>  D </td><td>  E </td><td>  JO </td><td>  Zh </td><td>  Z </td><td>  I </td><td>  <b>Y</b> </td><td>  K </td><td>  L </td><td>  M </td><td>  N </td><td>  O </td><td>  P </td><td>  R </td><td>  S </td><td>  T </td><td>  U </td><td>  F </td><td>  KH </td><td>  C </td><td>  CH </td><td>  SH </td><td>  SHH </td><td>  <b>Jhh</b> </td><td>  <b>Ih</b> </td><td>  <b>Jh</b> </td><td>  EH </td><td>  JU </td><td>  Ja </td></tr></tbody></table><br>  The “SHH” code is the only one using postfix length 2. But the total code length is only 3, the letter is rare.  Reversibility is not violated (and even “easy reversibility”). <br>  There is nothing more in the standard to touch. <br><br><div class="spoiler">  <b class="spoiler_title">Java code for illustration</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> tools; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.Character.toUpperCase; <span class="hljs-comment"><span class="hljs-comment">/** *      * Created by vladimir on 25.08.15. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lat2cyr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>{ StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; s.length()){<span class="hljs-comment"><span class="hljs-comment">//     .  ,     char ch = s.charAt(i); boolean lc = Character.isLowerCase(ch); //    ch = toUpperCase(ch); if(ch == 'J'){ //    i++; //      ch = toUpperCase(s.charAt(i)); switch (ch){ case 'O': sb.append(ch('', lc)); break; case 'H': if(i+1 &lt; s.length() &amp;&amp; toUpperCase(s.charAt(i+1))=='H') { //    ( JHH) sb.append(ch('', lc)); i++; //   }else{ sb.append(ch('', lc)); } break; case 'U': sb.append(ch('', lc)); break; case 'A': sb.append(ch('', lc)); break; default: throw new IllegalArgumentException("Illegal transliterated symbol '"+ch+"' at position "+i); } }else if(i+1 &lt; s.length() &amp;&amp; toUpperCase(s.charAt(i+1))=='H' ){//  ,      .          . switch (ch){ case 'Z': sb.append(ch('', lc)); break; case 'K': sb.append(ch('', lc)); break; case 'C': sb.append(ch('', lc)); break; case 'S': if(i+2 &lt; s.length() &amp;&amp; toUpperCase(s.charAt(i+2))=='H') { //     sb.append(ch('', lc)); i++; //    }else{ sb.append(ch('', lc)); } break; case 'E': sb.append(ch('', lc)); break; case 'I': sb.append(ch('', lc)); break; default: throw new IllegalArgumentException("Illegal transliterated symbol '"+ch+"' at position "+i); } i++; //   }else{//   switch (ch){ case 'A': sb.append(ch('', lc)); break; case 'B': sb.append(ch('', lc)); break; case 'V': sb.append(ch('', lc)); break; case 'G': sb.append(ch('', lc)); break; case 'D': sb.append(ch('', lc)); break; case 'E': sb.append(ch('', lc)); break; case 'Z': sb.append(ch('', lc)); break; case 'I': sb.append(ch('', lc)); break; case 'Y': sb.append(ch('', lc)); break; case 'K': sb.append(ch('', lc)); break; case 'L': sb.append(ch('', lc)); break; case 'M': sb.append(ch('', lc)); break; case 'N': sb.append(ch('', lc)); break; case 'O': sb.append(ch('', lc)); break; case 'P': sb.append(ch('', lc)); break; case 'R': sb.append(ch('', lc)); break; case 'S': sb.append(ch('', lc)); break; case 'T': sb.append(ch('', lc)); break; case 'U': sb.append(ch('', lc)); break; case 'F': sb.append(ch('', lc)); break; case 'C': sb.append(ch('', lc)); break; default: sb.append(ch(ch, lc)); } } i++; //     } return sb.toString(); } public static String cyr2lat(char ch){ switch (ch){ case '': return "A"; case '': return "B"; case '': return "V"; case '': return "G"; case '': return "D"; case '': return "E"; case '': return "JO"; case '': return "ZH"; case '': return "Z"; case '': return "I"; case '': return "Y"; case '': return "K"; case '': return "L"; case '': return "M"; case '': return "N"; case '': return "O"; case '': return "P"; case '': return "R"; case '': return "S"; case '': return "T"; case '': return "U"; case '': return "F"; case '': return "KH"; case '': return "C"; case '': return "CH"; case '': return "SH"; case '': return "SHH"; case '': return "JHH"; case '': return "IH"; case '': return "JH"; case '': return "EH"; case '': return "JU"; case '': return "JA"; default: return String.valueOf(ch); } } public static String cyr2lat(String s){ StringBuilder sb = new StringBuilder(s.length()*2); for(char ch: s.toCharArray()){ char upCh = toUpperCase(ch); String lat = cyr2lat(upCh); if(ch != upCh){ lat = lat.toLowerCase(); } sb.append(lat); } return sb.toString(); } /** *      */ private static char ch(char ch, boolean toLowerCase){ return toLowerCase? Character.toLowerCase(ch): ch; } /** *  */ public static void main(String[] args) { String s1 = cyr2lat("  "); String s2 = cyr2lat(" "); String s3 = cyr2lat("         "); String s4 = cyr2lat("         ."); String s5 = cyr2lat("                                "); System.out.println(s1); System.out.println(s2); System.out.println(s3); System.out.println(s4); System.out.println(s5); System.out.println(); System.out.println(lat2cyr(s1)); System.out.println(lat2cyr(s2)); System.out.println(lat2cyr(s3)); System.out.println(lat2cyr(s4)); System.out.println(lat2cyr(s5)); } }</span></span></code> </pre></div></div><br>  The code is given only for experiments and a descriptive description of the inverse transform algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">For industrial needs of transliteration, there are appropriate solutions (although there is no ready-made solution for requirements 1 and 2).</b> <div class="spoiler_text">  From industry standards, transliteration is included in the <a href="http://cldr.unicode.org/">Unicode Common Locale Data Repository Project (CLDR)</a> . <br>  There is a very powerful implementation including CLDR: <a href="http://site.icu-project.org/">International Components for Unicode</a> . <br>  Specifically, the Java version of ICU: <a href="">ICU4J</a> . <br>  There is a framework for describing and performing transliteration (and much more). <br>  For Russian Cyrillic there are ready-made implementations: <br>  1. ISO 9. Reversible, but with diacrites. <br>  2. BGN.  Without diacrites, but with punctuation marks and irreversible. <br>  There is an "indefinite plan" to add GOST. <br>  If there is time and energy to figure it out, I will do and lay out the implementation of my scheme using ICU4J. <br></div></div><br><br>  Thanks to constructive criticism in the comments, the decision has changed.  My understanding of the problem has become deeper.  I thought about the "adult" implementation. <br>  Thanks to all!  Habr makes things better. </div><p>Source: <a href="https://habr.com/ru/post/265455/">https://habr.com/ru/post/265455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265445/index.html">Windows 10 through 10. Issue # 1. How to increase the visibility and frequency of installations</a></li>
<li><a href="../265447/index.html">Did spammers appear in Telegram?</a></li>
<li><a href="../265449/index.html">How I use PostCSS</a></li>
<li><a href="../265451/index.html">CSS3 hover effects. Step by step tutorial</a></li>
<li><a href="../265453/index.html">We write voice IVR menu in TCL language using Cisco IVR API</a></li>
<li><a href="../265457/index.html">Protection of negotiations. Anti-bugs and field indicators</a></li>
<li><a href="../265459/index.html">Depla: Nginx, Puma and Mina</a></li>
<li><a href="../265461/index.html">Another way to automatically invoke unit tests in the C language</a></li>
<li><a href="../265463/index.html">"I came to eat, and stayed to study at the Technopark." Student stories from our educational projects</a></li>
<li><a href="../265465/index.html">Big Data - the first experience of ED IB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>