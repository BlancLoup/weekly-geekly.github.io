<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The story of an investigation into the strange behavior of XMLHttpRequest in new versions of Firefox</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I. The essence of the problem. 
 The list of basic purposes of XMLHttpRequest, of course, does not include an HTML request, more often this tool inter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The story of an investigation into the strange behavior of XMLHttpRequest in new versions of Firefox</h1><div class="post__text post__text-html js-mediator-article"><h4>  I. The essence of the problem. </h4><br>  The list of basic purposes of XMLHttpRequest, of course, does not include an HTML request, more often this tool interacts with XML, JSON or simple text. <br><br>  However, a bunch of XMLHttpRequest + HTML works well when creating extensions to the browser, which in the background polls for news sites that do not provide a mailing subscription, RSS or other cost-effective APIs or provide these services with some restrictions. <br><br>  When creating multiple extensions for Firefox, I was faced with such a need.  Working with HTML code received from XMLHttpRequest using regular expressions is a very unreliable and cumbersome way.  Getting the DOM from XMLHttpRequest was only possible for the correct XML.  Therefore, you had to follow <a href="https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM">clever tips on the developers website</a> .  However, since Firefox 11, the <a href="https://developer.mozilla.org/en/HTML_in_XMLHttpRequest">ability to directly retrieve DOM from XMLHttpRequest has appeared</a> , and timeout processing has been added to Firefox 12. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I experienced a new opportunity to create mini-indicators of new topics for two small forums, and it turned out to be very convenient (50 lines of code plus the <a href="https://addons.mozilla.org/ru/firefox/addon/custom-buttons/">CustomButtons</a> extension - here‚Äôs a ready-made indicator in five minutes, with timer polls and four states: no news, no news error and timeout; you can read more <a href="http://habrahabr.ru/post/146594/">here</a> ).  Everything worked like a clock. <br><br>  Therefore, I tried to remove from the code of my extensions all the old crutches and introduce a new convenient parsing there.  However, there was a strange problem when working with the <b>rutracker.org</b> site (testing takes place on the last nightly build under Windows XP; I really apologize for all the jambs in the code and the wording: I have no programmer education and my experience in this area is, unfortunately, very small .). <br><br><a name="habracut"></a>  The following simplified code example almost all the time goes into a timeout (to check you need to log in to the site - then it becomes clear why this is significant): <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.mozBackgroundRequest = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://rutracker.org/forum/index.php"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.timeout = <span class="hljs-number"><span class="hljs-number">10000</span></span>; xhr.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE; xhr.responseType = <span class="hljs-string"><span class="hljs-string">"document"</span></span>; xhr.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.responseXML.title); } xhr.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Error!"</span></span>); } xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Timeout!"</span></span>); } xhr.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br><br>  And the snag is in the HTML parsing in the DOM, because the site gives the page without delay and, for example, the following code without parsing works without hesitation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.mozBackgroundRequest = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://rutracker.org/forum/index.php"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.timeout = <span class="hljs-number"><span class="hljs-number">10000</span></span>; xhr.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE; xhr.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.responseText.match(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;title&gt;.+?&lt;\/title&gt;/i</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } xhr.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Error!"</span></span>); } xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"Timeout!"</span></span>); } xhr.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><br>  <a href="http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html">The</a> XMLHttpRequest <a href="http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html">specification</a> states that when parsing HTML / XML into DOM <i>scripts, the XSLT will be applied</i> , that is, scripts are not processed and no resources are loaded (which is confirmed by monitoring HTTP activity with the described requests), so there can be no delay from these sides.  The only catch can be only in the structure of the DOM itself: for some reason, the parsing hangs and creates a pseudo-timeout. <br><br><h4>  Ii.  Additional observations. </h4><br>  Then I created a small script for the DOM statistics and began using it to analyze the problem page. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = content.document; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = doc.documentElement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text_char = root.textContent.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elm_nodes = doc.evaluate(<span class="hljs-string"><span class="hljs-string">".//*"</span></span>, root, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).snapshotLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> txt_nodes = doc.evaluate(<span class="hljs-string"><span class="hljs-string">".//text()"</span></span>, root, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).snapshotLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> com_nodes = doc.evaluate(<span class="hljs-string"><span class="hljs-string">".//comment()"</span></span>, root, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).snapshotLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all_nodes = doc.evaluate(<span class="hljs-string"><span class="hljs-string">".//node()"</span></span>, root, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).snapshotLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max_nst_lv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max_nst_lv_nodes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level = <span class="hljs-number"><span class="hljs-number">1</span></span>, pattern = <span class="hljs-string"><span class="hljs-string">"./node()"</span></span>; level &lt;= <span class="hljs-number"><span class="hljs-number">50</span></span>; level++, pattern += <span class="hljs-string"><span class="hljs-string">"/node()"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elm_num = doc.evaluate(pattern,root,<span class="hljs-literal"><span class="hljs-literal">null</span></span>,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,<span class="hljs-literal"><span class="hljs-literal">null</span></span>).snapshotLength; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elm_num) { max_nst_lv = level; max_nst_lv_nodes = elm_num; } } alert( text_char + <span class="hljs-string"><span class="hljs-string">"\ttext characters\n\n"</span></span> + elm_nodes + <span class="hljs-string"><span class="hljs-string">"\telement nodes\n"</span></span> + txt_nodes + <span class="hljs-string"><span class="hljs-string">"\ttext nodes\n"</span></span> + com_nodes + <span class="hljs-string"><span class="hljs-string">"\tcomment nodes\n"</span></span> + all_nodes + <span class="hljs-string"><span class="hljs-string">"\tall nodes\n\n"</span></span> + max_nst_lv_nodes + <span class="hljs-string"><span class="hljs-string">" nodes in the "</span></span> + max_nst_lv + <span class="hljs-string"><span class="hljs-string">" maximum nesting level\n"</span></span> );</code> </pre><br><br>  Here are some even more puzzling data. <br><br>  1. <a href="http://rutracker.org/forum/index.php">The main page of the forum</a> with javascript disabled has: 49677 characters in text nodes, 4192 HTML elements, 4285 text nodes, 77 comments, total 8554 nodes;  577 nodes at the maximum 25th nesting level of nodes. <br><br>  2. If you leave the forum and load the page for unauthorized users, you‚Äôll get the following statistics: 47831 characters in text nodes, 3336 HTML elements, 4094 text nodes, 73 comments, a total of 7503 nodes;  1136 nodes at the maximum 24th level of nesting nodes.  The structure is clearly simpler and if you try the problem code by leaving the forum (that is, on this page for unauthorized users), then no timeout occurs. <br><br>  3. I tried to load the problem page on the test site and gradually simplify its structure.  For example, if you delete all <code>td</code> elements with class <i>row1</i> (headings of forums and subforums in the table on the main page) and do not change anything else, we get the following statistics: 20,450 characters in text nodes, 1355 HTML elements, 1726 text nodes, 77 comments, 3158 total nodes;  8 nodes at the maximum 25th level of node nesting.  Again, this page, with very few exceptions, does not give timeouts. <br><br>  4. <code>script</code> elements have a very strange meaning.  On the front page there are 19 of them (in the head and body combined, loaded and embedded).  If you delete only these elements, the page ceases to give timeouts.  And if you delete from the end to the beginning, you need to delete everything (even if you leave the first downloadable script in the head, the timeouts continue).  And if you delete from beginning to end, the timeouts stop after deleting the script embedded in the <code>p</code> element of the <i>forum_desc hidden</i> class in the Rules, Basic Instructions, FAQ section, you can leave 6 more scripts after it, and the timeouts will still stop. Only this script does not solve the problem).  And if all 19 scripts are replaced with empty <code>script</code> elements without code and without the <i>src</i> attribute, timeouts remain.  But if these empty elements are replaced with the same empty <code>style</code> elements in the same quantity, the timeouts immediately disappear. <br><br>  5. Using the perl script, I tried to create test HTML with a more or less complex structure (but without <code>script</code> elements).  It turned out a file of almost 10 megabytes in size with the following statistics: 9732505 characters in text nodes, 25004 HTML elements, 25002 text nodes, 1000 comments, a total of 51006 nodes;  1000 nodes at the maximum 27th level of nesting.  It seems that the structure is larger and more complex than the problem page, but it does not cause any timeouts.  It became obvious that the matter is in some ambiguous combination of volume / complexity / specificity of elements. <br><br>  6. It was enough to add <code>script</code> elements to this modeled page, timeouts returned (at least I increased the timeout threshold to a minute in this complex case). <br><br><h4>  Iii.  Create easily reproducible precedent. </h4><br>  I managed to achieve some critical minimum of the problematic structure, commensurate with the structure of the title page of the tracker, with the help of such a PERL script: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(OUTPUT, <span class="hljs-string"><span class="hljs-string">'&gt;:raw:encoding(UTF-8)'</span></span>, <span class="hljs-string"><span class="hljs-string">"test.html"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"Cannot write to test.html: $!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> OUTPUT <span class="hljs-string"><span class="hljs-string">"&lt;!DOCTYPE html PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'&gt;\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;&lt;head&gt;&lt;meta http-equiv='Content-Type' content='text/html; charset=UTF-8'&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"</span></span> . ((<span class="hljs-string"><span class="hljs-string">"&lt;div class='abcd'&gt;abcd"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span> . <span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> . <span class="hljs-string"><span class="hljs-string">"&lt;script type='text/javascript'&gt;var a = 1234;&lt;/script&gt;"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> . <span class="hljs-string"><span class="hljs-string">"&lt;/body&gt;&lt;/html&gt;\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(OUTPUT);</code> </pre><br><br>  Page statistics: 20265 characters in text nodes, 5024 HTML elements, 5022 text nodes, 0 comments, total 10046 nodes;  200 nodes at the maximum 27th level of nesting nodes.  Including 20 simplest <code>script</code> elements.  We get 10 timeouts of 10 attempts. <br><br>  When different attempts are made to simplify the structure or reduce the volume, the probability of timeouts is reduced, but in a rather unpredictable way (none of these simplifications were imposed on the other, before each script it returned to the source code): <br><br>  - move all <code>script</code> elements to the end of the code (despite the fact that nothing else changes and the statistics remain the same): 0 timeouts out of 10 attempts. <br>  - replacing <code>script</code> elements with <code>span</code> elements with one attribute and the same text content (without moving to the end): 0 timeouts out of 10 attempts. <br>  - Script text abbreviations by 3 characters: 7 times out of 10. <br>  - delete the entire contents of the script (only an empty tag remains): 6 timeouts out of 10 attempts. <br>  - reduction of the text of the <code>div</code> elements to one character: 5 timeouts out of 10 attempts. <br>  - complete deletion of the text of the <code>div</code> elements (a blank page is obtained): 7 timeouts out of 10 attempts. <br>  - reduction of the <i>class</i> attribute of <code>div</code> elements to one character: 8 timeouts from 10 attempts. <br>  - removal of the <i>class</i> attribute of the <code>div</code> elements: 1 timeout of 10 attempts. <br>  - reduction of the number of <code>script</code> elements to 2 (in the middle of the code and at the end): again 10 times out of 10 attempts. <br>  - reduction of the number of <code>script</code> elements to 1 (at the beginning of the code): all the same 10 timeouts from 10 attempts (but if you move this element to the end of the code, the timeouts disappear completely). <br>  - reducing the number of <code>div</code> elements (and, accordingly, text nodes) by half while maintaining the maximum level of nesting: 3 timeouts out of 10 attempts. <br>  - halving the maximum level of nesting (the total number of elements and text nodes remains almost the same, but the number of elements at the maximum level of nesting increases twice): 7 timeouts out of 10 attempts. <br>  - reduction of the maximum nesting level to just 3 ( <code>body/div/</code> text or <code>body/script/</code> text) with preservation of the total number of elements: 8 timeouts out of 10 attempts. <br><br><h4>  Iv.  Preliminary conclusions. </h4><br>  In all the cases described, no processor overload was observed, so there is no reason to blame the hardware for hang-ups (as well as network delays: the code is received in a fraction of a second, in the browser the page is rendered in a time much shorter than the timeout).  Obviously, in XMLHttpRequest, some limited resources are allocated for parsing HTML in the DOM, which are exhausted by a different combination of parameters.  And the mysterious role is played by <code>script</code> elements (which are not even executed) and especially their order in the code.  If this is true, it is worth increasing the resources and reducing the strange dependence on the type and order of the elements, since the problem is by no means contrived and arises during the usual development of extensions. <br><br><h4>  V. What's next. </h4><br>  When I first started analyzing the problem and asked for advice on several sites, the administrator suggested a performance bug on forums.mozilla.org and advised sending a message to bugzilla.mozilla.org in the Core :: DOM section with a description of the reproducible situation.  Then I had very little data, and now they are very unclear.  Therefore, I will be grateful for any considerations that allow to specify the problem and articulate it clearly.  Otherwise, you will have to translate all this sheet into English (which, given my level of language and material, will be very difficult) and posting on bugzilla.mozilla.org as it is, which, of course, will be a manifestation of inadequacy to someone else's time. </div><p>Source: <a href="https://habr.com/ru/post/145953/">https://habr.com/ru/post/145953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145945/index.html">Ubuntu kernel updates using bash</a></li>
<li><a href="../145946/index.html">Composer - dependency manager for PHP</a></li>
<li><a href="../145950/index.html">Motorola Solutions buys Psion</a></li>
<li><a href="../145951/index.html">Kinect + DSLR = 3D filming</a></li>
<li><a href="../145952/index.html">Amazon is close to launching an updated music service.</a></li>
<li><a href="../145954/index.html">Feed2Tabs: when you need to frequently open feed articles in separate tabs</a></li>
<li><a href="../145955/index.html">"Liquid perceptron" or hypothesis how to implement real parrality</a></li>
<li><a href="../145956/index.html">Skolkovo on your desk (or the story of how I made an electronic device from scratch)</a></li>
<li><a href="../145957/index.html">"Debriefing" - episode 21 - Eat your dog food and change the awl by two sews</a></li>
<li><a href="../145958/index.html">Resharper and IoC containers: now familiar! or Agent Mulder plugin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>