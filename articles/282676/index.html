<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inheriting tables in Postgresql with Ruby on Rails</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is it and why? 


 Suppose you have a large news publication that has many different types of materials. 


 Each type of material has its own mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inheriting tables in Postgresql with Ruby on Rails</h1><div class="post__text post__text-html js-mediator-article"><p><img src="http://i.imgur.com/mIxcEWe.jpg" alt="Migrating to Postgres Inheritance"></p><br><p>  What is it and why? </p><br><p>  Suppose you have a large news publication that has many different types of materials. </p><br><p> Each type of material has its own model: <code>Topics::Article</code> , <code>Topics::Online</code> , <code>Topics::NewsItem</code> and so on.  They will have the same majority of fields, such as title, cover, text, authors.  The difference is only in a few specific fields, unique for each type of topic. </p><br><p>  Therefore, you do not want to lay them out on separate tables.  In addition to the reluctance to create almost completely repetitive tables, there may be several other reasons for this.  The need for complex samples with different combinations of these types, UNION waterfalls and polymorphism of connecting models as well. </p><br><p>  Under the cat, the experience of organizing similar models within Postgresql, with the result in the form of migration to the inheritance of tables.  Shooting a silver bullet in the foot is also present, but without it. </p><a name="habracut"></a><br><h2>  Single table inheritance </h2><br><p>  The first thing that comes to mind is the classic Single Table Inheritance.  In Rails, it automatically turns on if you inherit one model from another. </p><br><p>  By creating one common Topics table and adding a type field to it, you can store all classes within a single table. </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topic</span></span></span><span class="hljs-class"> &lt; ActiveRecord::Base </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topics::Article</span></span></span><span class="hljs-class"> &lt; Topic </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topics::NewsItem</span></span></span><span class="hljs-class"> &lt; Topic </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> ...</span></span></code> </pre> <br><p>  Common logic (for example, posting material) goes to Topic.  Specific to inherited classes. </p><br><p>  This simple and run-through scheme has problems with scaling.  What if the types of topics are already more than fifteen and each has from two to ten unique fields? </p><br><p>  At this point in the DB, purists frown as if from a severe toothache - imagining a table whose lines are always filled by no more than 15-20%. </p><br><h2>  STI + Jsonb </h2><br><p><img src="http://i.imgur.com/hwubXqs.jpg" alt="STI + Jsonb"></p><br><h3>  Jsonb </h3><br><p>  In Postgresql c 9.4 it is possible to create jsonb type fields.  How can this help us? <br>  By adding a data field of this type to topics, we can store all of our additional fields in json keys. </p><br><p>  Connect in Rails can be this way: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topics::Online</span></span></span><span class="hljs-class"> &lt; Topic </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">store_accessor</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start_at</span></span></span><span class="hljs-class">, :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">live</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  Now you can do this: </p><br><pre> <code class="ruby hljs">online = Topics::Online.new(<span class="hljs-symbol"><span class="hljs-symbol">live:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><pre> <code class="ruby hljs">online.live <span class="hljs-comment"><span class="hljs-comment"># =&gt; true</span></span></code> </pre> <br><p>  Or directly contact json: </p><br><pre> <code class="ruby hljs">online[<span class="hljs-string"><span class="hljs-string">'data'</span></span>][<span class="hljs-string"><span class="hljs-string">'live'</span></span>] <span class="hljs-comment"><span class="hljs-comment"># =&gt; true</span></span></code> </pre> <br><h2>  Jsonb problems </h2><br><p>  The enjoyment of success achieved is quickly overshadowed by crutches. </p><br><h3>  Type conversion </h3><br><p>  In addition to exotic things like arrays and objects (hashes), jsonb suggests using only Number, String and Boolean for all fields. <br>  For other types of fields, you will have to write additional methods.  And if you prefer sugar, then for these fields too. </p><br><p>  Predicates: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">live?</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">live</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">==</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">true</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  More complicated case for datetime: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_at</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Time</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zone</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.is_a?(String) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here you need to parse the string in time and not break.  Because you need to break at the stage of saving data. </p><br><h3>  Validation of input values </h3><br><p>  There is no type validation at the database level; you can easily and naturally save this topic: </p><br><pre> <code class="ruby hljs">online.live = <span class="hljs-string"><span class="hljs-string">'Elvis'</span></span> online.start_at = <span class="hljs-string"><span class="hljs-string">'Presley'</span></span></code> </pre> <br><p>  Existing gems, such as activerecord-typedstore, partially solve the problem of string parsing, but do not cope with checking input values ‚Äã‚Äãat all.  Everything needs to be closed from the application by custom validations. </p><br><h3>  Cumbersome requests </h3><br><p>  Boolean field: </p><br><pre> <code class="ruby hljs">scope live, -&gt; { where(<span class="hljs-symbol"><span class="hljs-symbol">live:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br><pre> <code class="ruby hljs">scope live, -&gt; { where(<span class="hljs-string"><span class="hljs-string">"(params-&gt;&gt;'live')::bool = ?"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br><p>  And now the dates: </p><br><pre> <code class="ruby hljs">scope <span class="hljs-symbol"><span class="hljs-symbol">:by_range</span></span>, -&gt;(start_date, end_date) { where(<span class="hljs-symbol"><span class="hljs-symbol">date:</span></span> start_date..end_date) }</code> </pre> <br><pre> <code class="ruby hljs">scope <span class="hljs-symbol"><span class="hljs-symbol">:by_range</span></span>, lambda { <span class="hljs-params"><span class="hljs-params">|start_date, end_date|</span></span> where( <span class="hljs-string"><span class="hljs-string">"to_date(params-&gt;&gt;'date', 'YYYY-MM-DD') BETWEEN ? AND ?"</span></span>, start_date, end_date ) }</code> </pre> <br><p>  In addition to the general monstrosity, this query will also be slower to work, due to the forced use of <code>to_date</code> Postgres. </p><br><h3>  Uniq </h3><br><p>  Postgres does not know how to do the usual DISTINCT (.uniq) for records with jsonb, you need to do this: </p><br><pre> <code class="ruby hljs">.select(<span class="hljs-string"><span class="hljs-string">'DISTINCT ON (tags.id) tags.*'</span></span>)</code> </pre> <br><h3>  No defaults </h3><br><p>  You have to use different constructions in <code>before_initialize</code> instead of the usual <code>null: false, default: false</code> in the migration. </p><br><h3>  Connections </h3><br><p>  Use rail <code>has_many</code> and <code>belongs_to</code> will not work.  Need to write something of their own. </p><br><p>  At this stage, jsonb received a black mark, and the matter did not reach the trolleybus from a loaf of bread. </p><br><h2>  Migrating to Postgres Inheritance </h2><br><p>  Inheritance of tables appeared in Postgres for a long time (most likely it will not be necessary to update the version) and close to the concept of class inheritance. <br>  Only not classes, but tables, and not in Ruby, but in Postgres. </p><br><p>  You still have a table of topics, but you are expanding it not through a set of additional fields in this very table, but through additional tables containing only fields unique to each class. </p><br><p>  The easiest way to show an example: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> topics ( headline <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, author_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> topics_onlines ( <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) ) INHERITS (topics);</code> </pre> <br><p>  By creating <code>topics_onlines</code> we can work with it as with a regular table, which will have all three fields: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topics::Online</span></span></span><span class="hljs-class"> &lt; Topic </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># headline, author_id, status end</span></span></span></span></code> </pre> <br><p>  It is simple, beautiful and does not require massive rewriting of the code. </p><br><h3>  Postgres Inheritance + Rails </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.tableoid, c.headline, c.author_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> topics c</code> </pre> <br><pre> <code class="sql hljs"> tableoid | headline | author_id <span class="hljs-comment"><span class="hljs-comment">----------+-----------+---------- 139793 | Las Vegas | 2174 139793 | Mariposa | 1953 139798 | Madison | 845</span></span></code> </pre> <br><p>  Parent and child tables are linked inside a Postgre via tableoid.  We will not see any joins by tableoid in explain, it all works inside Postgres. </p><br><p>  From the application, <code>topics_onlines</code> will look like the most common table without inheritance, containing all fields from <code>topics</code> and online-specific fields from <code>topics_onlines</code> . </p><br><p>  And this means that from the side of the rail it is only necessary to write a migration creating tables. <br>  And that table inheritance can be used with any framework. </p><br><h2>  Migration from STI to PGI </h2><br><p>  To take advantage of all this joy you need to write a migration. </p><br><p>  First we need a standard wrapper for sql migration in Rails: </p><br><pre> <code class="sql hljs">class CreateInheritanceTablesForTopics &lt; ActiveRecord::Migration def <span class="hljs-keyword"><span class="hljs-keyword">change</span></span> reversible <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |dir| dir.up <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The code is further inserted in place of the dot.  In order not to throw a code sheet at once, I will show the migration by chunks. </p><br><h3>  Trigger for checking for uniqueness on all topic tables </h3><br><p>  Create, but for now, never use the trigger in Postgresql: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> check_for_topic_dups() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $func$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> topics <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> NEW.id=<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>; IF FOUND THEN RAISE unique_violation USING MESSAGE = 'Duplicate ID: ' || NEW.id; RETURN NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; RETURN NEW; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $func$ LANGUAGE plpgsql;</code> </pre> <br><p>  A trigger causes an error if a topic with such an id already exists.  This is insurance in case something went wrong. </p><br><p>  The most important limitation of PGI is that all child tables do not have indexes and parent table constraints.  That is, in this regard, everything really feels like different physical tables. </p><br><p>  For our conditions, different types of topics cannot repeat the ID, so this trigger was added.  It is optional and needed as insurance. </p><br><h3>  Creating tables </h3><br><pre> <code class="sql hljs">Topic.descendants.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |topic_type| <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> = &lt;&lt;-<span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-comment"><span class="hljs-comment">#{topic_type.pgi_table_name} ( CHECK (type='#{topic_type}') ) INHERITS (topics); CREATE RULE redirect_insert_to_#{topic_type.table_name} AS ON INSERT TO topics WHERE (type='#{topic_type}') DO INSTEAD INSERT INTO #{topic_type.table_name} VALUES (NEW.*); CREATE TRIGGER check_uniquiness_#{topic_type.table_name} BEFORE INSERT ON #{topic_type.table_name} FOR EACH ROW EXECUTE PROCEDURE check_for_topic_dups(); SQL execute(sql) add_index topic_type.table_name, :id end</span></span></code> </pre> <br><ul><li>  Tables are created for each type of topic (metamagic is more for compactness, it is better not to do this in migrations) </li><li>  For each child table, a limit on the topic type is added (only <code>Topics::Online</code> can be inserted into <code>topics_onlines</code> ) </li><li>  If you try to insert a topic with a filled type in topics, it will be redirected to the child table by type </li><li>  We hang on each table a previously created trigger for checking unique IDs. </li><li>  Create indexes for child tables </li></ul><br><p>  Of course, the migration can be put on a strict diet, and all checks can be pulled out into the Rails themselves. </p><br><h2>  Add native fields to inherited tables </h2><br><p>  You can add fields to the new tables using standard migrations: </p><br><pre> <code class="ruby hljs">Class PopulateTopicsTablesWithFields &lt; ActiveRecord::Migration <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_column</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topics_onlines</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_at</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">datetime</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_column</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topics_news</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">, :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">false</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">false</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  If you are not ready to completely get rid of STI, then the necessary table is written in the topic classes: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topics::Online</span></span></span><span class="hljs-class"> &lt; Topic </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table_name</span></span></span><span class="hljs-class"> = :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">topics_online</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  It remains only to change the type of the scheme to sql: </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># config/application.rb config.active_record.schema_format = :sql</span></span></code> </pre> <br><p>  And everything is ready. </p><br><h2>  Speed ‚Äã‚Äã- PGI vs jsonb </h2><br><p><img src="http://i.imgur.com/xeGBlUf.jpg" alt="Speed ‚Äã‚Äã- PGI vs jsonb"></p><br><p>  The final stage would be interesting to evaluate the performance.  Since all this was started for the sake of ease of development, not so much time was devoted to testing the PGI speed, but some conclusions can be made. </p><br><p>  After the migration, two versions of the application were raised, PGI and the old one with jsonb. <br>  More than <code>5_000_000</code> topics in each database. </p><br><h3>  The number of all topics </h3><br><p>  The most synthetic example: </p><br><p>  PGI: </p><br><pre> <code class="ruby hljs">Topics::Topic.count (<span class="hljs-number"><span class="hljs-number">8591.6</span></span>ms) SELECT COUNT(*) FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5316226</span></span></code> </pre><br><p>  Jsonb: </p><br><pre> <code class="ruby hljs">Topics::Topic.count (<span class="hljs-number"><span class="hljs-number">8580.1</span></span>ms) SELECT COUNT(*) FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5316226</span></span></code> </pre> <br><p>  Do not be surprised at the strange number, the topics were created until the place on the ssd ended. </p><br><h3>  Number of topics of one type </h3><br><p>  PGI: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.count * (<span class="hljs-number"><span class="hljs-number">219.5</span></span>ms) SELECT COUNT(*) FROM <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre> <br><p>  Jsonb: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.count * (<span class="hljs-number"><span class="hljs-number">419.0</span></span>ms) SELECT COUNT(*) FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre> <br><h2>  Query on boolean field </h2><br><p>  The index is not used due to high selectivity. </p><br><p>  PGI: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">1376.2</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"megauho"</span></span> = $1 [[<span class="hljs-string"><span class="hljs-string">"megauho"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>]]</code> </pre> <br><p>  Jsonb: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">5819.6</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND ((topics.params-<span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span><span class="hljs-string"><span class="hljs-string">'megauho'</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:bool</span></span> = <span class="hljs-string"><span class="hljs-string">'t'</span></span>)</code> </pre> <br><p>  The difference is significant. </p><br><h2>  Query on boolean field with limit </h2><br><p>  At least already intersects with the real world. </p><br><p>  PGI: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.limit(<span class="hljs-number"><span class="hljs-number">1000</span></span>).explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">9.1</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"megauho"</span></span> = $1 LIMIT <span class="hljs-number"><span class="hljs-number">1000</span></span> [[<span class="hljs-string"><span class="hljs-string">"megauho"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>]]</code> </pre> <br><p>  Jsonb: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.limit(<span class="hljs-number"><span class="hljs-number">1000</span></span>).explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">23.7</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND ((topics.params-<span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span><span class="hljs-string"><span class="hljs-string">'megauho'</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:bool</span></span> = <span class="hljs-string"><span class="hljs-string">'t'</span></span>) LIMIT <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br><p>  There is a difference. </p><br><hr><br><h2>  PGI for low selectivity query </h2><br><p>  Search by index, returns 123 entries out of a million, Index Scan. </p><br><p>  PGI: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.megauho_by_date(<span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span>).explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">6.0</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND <span class="hljs-string"><span class="hljs-string">"topics_sport_onlines"</span></span>.<span class="hljs-string"><span class="hljs-string">"megauho"</span></span> = $1 AND (topics_sport_onlines.date = <span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span>) [[<span class="hljs-string"><span class="hljs-string">"megauho"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>]] QUERY PLAN ---------- * Index Scan using index_type_megauho_date on topics_sport_onlines (cost=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">42</span></span>..<span class="hljs-number"><span class="hljs-number">42.12</span></span> rows=<span class="hljs-number"><span class="hljs-number">20</span></span> width=<span class="hljs-number"><span class="hljs-number">682</span></span>) Index <span class="hljs-symbol"><span class="hljs-symbol">Cond:</span></span> (((type)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span> = <span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>) AND (megauho = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) AND ((date)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span> = <span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">Filter:</span></span> megauho (<span class="hljs-number"><span class="hljs-number">3</span></span> rows)</code> </pre><br><p>  Jsonb: </p><br><pre> <code class="ruby hljs">Gazeta::Topics::Sport::Online.megauho.megauho_by_date(<span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span>).explain * Gazeta::Topics::Sport::Online Load (<span class="hljs-number"><span class="hljs-number">7.7</span></span>ms) SELECT <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.* FROM <span class="hljs-string"><span class="hljs-string">"topics"</span></span> WHERE <span class="hljs-string"><span class="hljs-string">"topics"</span></span>.<span class="hljs-string"><span class="hljs-string">"type"</span></span> IN (<span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span>) AND ((topics.params-<span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span><span class="hljs-string"><span class="hljs-string">'megauho'</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:bool</span></span> = <span class="hljs-string"><span class="hljs-string">'t'</span></span>) AND (topics.params-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'date'</span></span> = <span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span>) QUERY PLAN ---------- * Index Scan using index_type_megauho_date on topics (cost=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">56</span></span>..<span class="hljs-number"><span class="hljs-number">217.61</span></span> rows=<span class="hljs-number"><span class="hljs-number">27</span></span> width=<span class="hljs-number"><span class="hljs-number">948</span></span>) Index <span class="hljs-symbol"><span class="hljs-symbol">Cond:</span></span> (((type)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span> = <span class="hljs-string"><span class="hljs-string">'Gazeta::Topics::Sport::Online'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>) AND ((params -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'date'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>) = <span class="hljs-string"><span class="hljs-string">'2015-12-26'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">Filter:</span></span> ((params -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'megauho'</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:text</span></span>))<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span> rows)</code> </pre><br><ul><li>  PGI is faster. </li><li>  The larger the sample, the faster. </li><li>  For queries using indexes, PGI is still faster, but the difference is less noticeable. </li></ul><br><h2>  Properly preparing jsonb </h2><br><p>  For the task of fully expanding jsonb models can be extremely toxic.  Of course, PGI also has its limitations, but for our tasks they were overcome at one time during the migration. </p><br><p>  Still, jsonb can be useful for weakly structured data from an external source.  These fields do not even need to be defined via the <code>store_accessor</code> , you can simply save them as they are, and then a separate class Builder will collect something useful from them. </p><br><p>  For us, sports broadcasts taken from the external api became such data. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/282676/">https://habr.com/ru/post/282676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282662/index.html">How I left elma</a></li>
<li><a href="../282664/index.html">Installing Joomla 3.5 on Freebsd 10.3</a></li>
<li><a href="../282670/index.html">The digest of interesting materials from the world of MODX # 2</a></li>
<li><a href="../282672/index.html">The benefits of inspections</a></li>
<li><a href="../282674/index.html">How does it feel to be a developer when you're forty</a></li>
<li><a href="../282678/index.html">Python: a programming language created by the community</a></li>
<li><a href="../282680/index.html">Color gap</a></li>
<li><a href="../282682/index.html">Test automation: Acronis Kernel ‚Äúdrone‚Äù</a></li>
<li><a href="../282684/index.html">PHP 7 Checker</a></li>
<li><a href="../282688/index.html">Node.JS v6.0 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>