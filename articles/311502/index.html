<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I read the sensor readings via SNMP (Python + AgentX + systemd + Raspberry Pi) and built another monitor.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 



 Lyrical digression  The article is in the drafts for a couple of weeks, because there was no time to finish the described object. But unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I read the sensor readings via SNMP (Python + AgentX + systemd + Raspberry Pi) and built another monitor.</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a5/81f/10c/6a581f10c0b01a8d0dd3095cafeb3eb4.jpg" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression</b> <div class="spoiler_text">  The article is in the drafts for a couple of weeks, because there was no time to finish the described object.  But under the onslaught of comrades who already covered half of what I wanted to say with my articles, decided to follow the principle of ‚Äúrelease fast, release early <s>, release crap</s> ‚Äù and publish what we have.  Moreover, the development is 80% complete. </div></div><br>  <a href="https://habrahabr.ru/post/255179/">A</a> lot of time has passed since the publication of the article about <a href="https://habrahabr.ru/post/255179/">‚ÄúModerately Universal Control Device‚Äù</a> (and to be exact, more than a year).  Not a lot, but not enough for me to write a normal software stuffing for this device.  It‚Äôs not for beauty, it‚Äôs there - it should collect data from the sensors and make it so that this data will be in the monitoring system (in my case Zabbix) <br><a name="habracut"></a><br><h2>  Part One - software </h2><br>  Since that time, the following has been implemented from the program filling: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Test script to demonstrate that everything connected works </li><li>  Script for zabbiks to collect readings from thermal sensors </li></ul><br>  There were attempts to write separate monitoring tools for ntpd and for gpsd.  A lot of time was spent on super-monitoring, which should have been able to read the config, start the data collection processes from various sources according to the configuration, collect data from these processes and display readings on the screen, at the same time enabling the zabbix to read this data.  In fact, it turned out to implement the process manager, who read the config and spawned the necessary processes, and the drawing on the screen, which turned out to be very cool - even knows how to read the layout from the config and change the screen contents by timer, while collecting data from the processes at the moment they are needed.  There is only one thing in this super monitoring - the actual processes that would collect data.  Well, plus there were ideas to make a system of signals, to assign functions to buttons, to take into account the priorities of different data sources, and so on, but everything came up in free time and the fact that this super monitoring was very bloated and monstrous. <br><br>  For some time I scored on the development of a full-fledged software filling.  Nenuacho, the script works, but the rule ‚Äúworks ‚Äî don't touch it,‚Äù as they say, the holy rule of the administrator.  But that's bad luck - the more you want to monitor, the more scripts you need to write and the more you need to add exceptions to SELinux for zabbiks (I‚Äôm not only a raspi monitor) - in the default policy zabbiksu (like rsyslog, for example) is forbidden to call arbitrary programs, and this is understandable.  I didn‚Äôt want to disable SELinux for Zabbiks at all or to write my own policy for each binary that will be twitching.  So I had to think. <br><br>  And let's understand how to collect data in the monitoring system: <br><br><ul><li>  According to the initiator: <br><br><ul><li>  Active monitoring - monitored node initiates data transfer (push) </li><li>  Passive monitoring - the monitoring node initiates data transfer (pull) </li></ul><br></li><li>  By the method of data collection: <br><br><ul><li>  Through the agent on the monitored node, using only metrics supported by the agent </li><li>  Through the agent on the monitored node, expanding the agent with scripts </li><li>  By SNMP </li><li>  Primitive ping </li><li>  By telnet </li><li>  ‚Ä¶ and so on </li></ul></li></ul><br>  I use pull monitoring, not for religious reasons, but it just happened.  In fact, there is little difference between push and pull, especially at low loads (I did Nagios + NSCA in one of the previous works, I didn‚Äôt notice much difference, I still need to create elements with my hands).  It would be possible to use zabbix_sender, if I already had push-monitoring, but it doesn‚Äôt, and there‚Äôs no court, and it‚Äôs somehow wrong to interfere with one another.  But in the question of which protocol to monitor, the choice seems to be large, but not very much - discovery is supported only through an agent or via SNMP, which leaves us with only two options.  The agent disappears because of the described problem with SELinux.  Voila, we still have pull-monitoring via SNMP. <br><br>  Hurray!  Why cheers then?  Linux seems to have snmpd, but how to make it give what we need, but what does snmpd have no clue about?  It turns out that snmpd has as many as 3 (fundamentally different) ways to give arbitrary data on arbitrary OIDs: <br><br><ul><li>  Running an external script (exec / sh / execfix / extend / extendfix / pass / pass_persist directives) is bad because of potential problems with SELinux and because an uncontrollable bunch of scripts will eventually turn into a dump.  Yes, and they say, pass_persist is all bad with the transfer of binary data.  I don‚Äôt know, maybe I‚Äôm lying shamelessly, but in any case I didn‚Äôt like the idea of ‚Äã‚Äãproducing a million scripts; <br><br></li><li>  Write something on the built-in perl or download .so ‚Äî I don‚Äôt know and don‚Äôt want to know the pearl, I don‚Äôt want to write so-shki, I‚Äôm not a programmer to write in C; <br><br></li><li>  Get data from an external agent (proxy, SMUX, AgentX) - and that sounds good, but loose coupling does not depend on the language.  Let's understand: <br><br><ul><li>  proxy - request an OID from an SNMP agent on the specified host.  It is necessary to implement the entire SNMP protocol, which is absolutely useless to me, and why should I request something from another node, use the network when I want to receive data locally.  I know about the existence of 127.0.0.1, but in any case, implementing SNMP does not smile at all; <br><br></li><li>  SMUX - we need support for the smux protocol in the calling agent, including, and man says that by default net-snmp is going without smux support (and so ntpd will reassemble to support pps, also re-compile net-snmp on raspi).  Yes, and this smux is just a wrapper for SNMP packets, just added the ability for the subagent to register with the agent; <br><br></li><li> AgentX is essentially the same as SMUX, only the protocol is simpler, and the package is easier.  Well compiled by default in net-snmp, which is also nice.  Sounds like our pick. </li></ul></li></ul><br>  I am writing on python, so I went to look for, and if anyone had already implemented the agentx protocol.  And after all there were such good people - <a href="https://github.com/rayed/pyagentx">https://github.com/rayed/pyagentx</a> and <a href="https://github.com/pief/python-netsnmpagent">https://github.com/pief/python-netsnmpagent</a> .  The second project seems to be more lively, but the first one seemed simpler.  I started with the first one (pyagentx), it works and does everything it needs.  But when I began to think, and how to transfer data to this library, I wanted to deal with the second package (python-netsnmpagent).  The problem with pyagentx is that, as it is written, it cannot receive data from calling functions, and therefore, the request for fresh data must occur directly in a function that sends updates to snmpd, which is not always convenient and not always possible.  It was possible, of course, to bud off something of my own and redefine the functions, but in fact I would have to rewrite the class almost as a whole, which I also didn‚Äôt want to do - we‚Äôre working out on the knee, everything should be simple and fast.  However, the reluctance to deal with python-netsnmpagent did win and I found a way to transfer data to the updater from pyagentx, but more on that below. <br><br>  The next question was this: what should the architerature look like?  An attempt to write a dispatcher, forking data sources and reading data from them, was already and did not end very well (see above), so it was decided to abandon the dispatcher implementation.  And so successfully it happened that either I saw an article about systemd somewhere, or just once again, the old desire to deal with it tickled closer, and I decided that systemd would be my dispatcher in my case.  Haters gonna hate, and we will understand, if it is already even on the raspi out of the box. <br><br>  What useful systemd features I found for myself: <br><br><ul><li>  Free demonization - we write a service unit with the type simple (or notify) and we get the daemon without writing a single line of code for this.  Goodbye python-daemon and / or daemonize </li><li>  Automatic restart of fallen units - well, there are no comments, saves from intermittent errors </li><li>  Socket-activation and socket management in general is very nice when someone who wants to write to the socket can do it, even if the one who will read from the socket is not yet ready to do it.  Moreover, the reader can be activated by writing to the socket, which can save some RAM (however, it‚Äôs not that it was missing ...) </li><li>  Template units - if I have a lot of identical sensors, you can spawn a lot of processes from one unit, transfer different parameters to everyone and rejoice </li><li>  (discovered too late, until implemented) units-timers - allow you to periodically start a certain unit.  Why not cron - because cron has a minimum period of 1 minute, and I want to interrogate sensors more often.  Why not sleep () - because active waiting and because the period starts to drift - yes, we pull the sensor every N seconds, but taking into account reading and processing data, the data update period will not be N seconds, but N + x, that is, at each reading the data update period will move down by x </li></ul><br>  With these findings in mind, architecture was drawn: <br><br><ul><li>  systemd opens a socket for communication between sensor processes and a collector process, all sensor processes write to the same socket </li><li>  systemd launches units for sensor processes </li><li>  the sensor process reads data from the sensor, writes it to the socket and goes to sleep (I haven‚Äôt yet found the systemd timer unit) </li><li>  As soon as data from a sensor is written to the socket, systemd starts a collector process, which receives the update from the sensor, magically processes it and stores it in the internal state.  The collector process does not die </li><li>  the collector process generates a separate flow (just a flow, not a process, to avoid IPC between processes, which is somewhat sad in python <i>for this task</i> , I will write below why I think so), in which the internal state is transferred to snmpd using agentx protocol </li></ul><br>  One very bad place is a shared internal state between the flow-collector and the flow-agentx.  But I have forgiven myself, because in the python there is a magic GIL, which solves the issue of synchronization between the two threads.  Although it is, of course, very bad and not on the book.  There was a thought to put the shared state into a separate process and force the process-agentx and the process-collector to work with the state-process through the socket, but it broke me to make another socket, write another unit and so on. <br><br>  Why I did not like IPC in python <i>in relation to this task</i> : <br><br><ul><li>  Queue works fine, but these queues are unnamed, the Queue instance must be passed to the forked process.  In my case this means completely rewriting pyagentx </li><li>  The manager might have solved my problem, but again, this means rewriting pyagentx completely </li><li>  posix / sysv ipc is great, there are named queues, but these queues are limited in size, on some systems they are quite poorly limited (they <a href="http://semanchuk.com/philip/sysv_ipc">write</a> <i>[scroll to ‚ÄúUsage tips‚Äù]</i> , for example, macos have no more than 2KB per queue and even configure not allowed).  Not that I had to run on a bunch of different systems with varying degrees of wretchedness with the implementation of sysv ipc, but I also didn‚Äôt want to do tuning.  I want to immediately and well </li><li>  again posix / sysv ipc - blocking queues, that is, some minimum timeout must be before reading from the queue returns ‚Äúempty‚Äù.  In the case of pyagentx, locking on reading from the queue in update () is very undesirable, and indeed it is poorly </li><li> and again posix / sysv ipc is a problem with queue naming.  Despite the fact that message queues are named, they are named not by name, but by key.  Since the key is not hierarchical or semantically obvious, it is easy to choose a non-unique key.  In the posix / sysv ipc implementation for python, it is possible to generate the queue key automatically, but bad luck - if I could transfer something to pyagentx, I would transfer the Queue there and not suffer.  You can generate a key using ftok, but they <a href="http://semanchuk.com/philip/sysv_ipc">write</a> <i>[scroll to ‚ÄúUsage tips‚Äù]</i> that ftok gives no more certainty that the key is unique than <code>int random() {return 4;}</code> </li><li>  (nothing else came to mind, which would not involve an external queue broker, and the task is not such as to keep the queue broker ‚Äî extra service, an extra headache) </li></ul><br>  dbus looked like a solution to all troubles, and there it is everywhere where systemd is, but the trouble is that pydbus requires GLib&gt; = 2.46 to publish the API, and only 2.42 in raspbian.  dbus-python is deprecated and unsupported.  In short, until the rooster roast in the ass bite, I will share the state in an insecure manner. <br><br>  When using SNMP for your own <s>dirty</s> purposes, there is another catch - how to choose OIDs for your data sets?  For this there is a special branch in private, which is called enterprises - .1.3.6.1.4.1. &lt;Enterprise_id&gt;.  You can get a unique enterprise ID <a href="">from IANA</a> .  When the OID scheme is defined, it would be nice to write a MIB, so as not to forget where everything is, and also to make monitoring systems easier.  An introduction to writing MIBs is <a href="http://www.net-snmp.org/wiki/index.php/Writing_your_own_MIBs">here</a> . <br><br>  At some point, I discovered ntpsnmpd with the corresponding MIB and was glad to be a bald, but when I compiled this miracle, I found that the author bothered only to implement a few top-level constants and at that exhausted.  I did a little poking around in the code and did not fully understand how the author interacted with ntpd (or ntpq) in a clever way to get those constants out, without parrying the output.  One thing I understood for sure - there is no ready-made python API, which means there is nothing to catch, I have to implement this MIB myself. <br><br><div class="spoiler">  <b class="spoiler_title">Five minutes of hate</b> <div class="spoiler_text">  No, well, that's true, really, for all these years, no one has written analogs of ntpd, smartctl, lm_sensors and other utilities without an API?  Nobody screwed snmp-agents to them?  Such analogs that it was not necessary to parse the text output?  No, I understand, unixway and all that, but this is not the case.  Well, it would be possible to display the data in a machine-readable format, but no, everything is <i>only</i> for people.  And judging by the crying on the Internet (Russian and foreign), I'm not the only one so unhappy.  Well, let's say lm_sensors can be forgiven, because the same data can be subtracted from sysfs in machine-readable format, but the rest? <br></div></div><br>  In general, the whole structure works and is very tenacious.  Discovery works in zabbiks, items are created, graphics are drawn, triggers send alerts - what else do you need to be happy?  The code is not finalized yet, so I do not publish it. <br><br><h2>  Part two - hardware </h2><br>  Not everywhere you can stick a unit case, but you don't want to hang snot on the walls either.  There is a very elegant solution - DIN-rail.  Heaps of constructions with a rail are sold on the market, in which it is possible to put the rack and power supply unit (I use the MeanWell DR-15-5), and all sorts of automata-uso-what-is-necessary.  Accordingly, I wanted a DIN rail enclosure for raspi.  These two comrades were considered as candidates - the model from <a href="https://www.modmypi.com/raspberry-pi/cases/din-rail-mount/italtronic-din-rail-raspberry-pi-model-b-plus-case">Italtronic</a> and <a href="https://www.modmypi.com/raspberry-pi/cases/din-rail-mount/raspibox-open-plus-prototyping-din-rail-raspberry-pi-case">RasPiBox</a> .  The advantage of RasPiBox is that there is already a board for prototyping and power is supplied via screw contacts (via a stabilizer on the GPIO), which is convenient, but it can be unsafe.  But it costs more than 3 times more expensive, takes up more space on the rail and does not have a transparent window.  The model from Italtronic is also not perfect - its width is such that all ready-made 16x2 LCD screens do not fit in width, that is, the value of a transparent window drops sharply, but for a low price I was ready to forgive this shortcoming. <br><br>  The case turned out to be quite convenient, it has space for fastenings (or rather, for installation) of two printed circuit boards or a sheet of anything.  I make the substrate from acrylic wrapped in a non-conductive ESD-protective film, I saw with a Dremel: <br><br><img src="https://habrastorage.org/files/88b/97b/825/88b97b82580c410191294d6f8d2abccb.jpg"><br><br>  The boards inside are kept only on the force of friction and on small ledges on both sides, that is, there is no rigid mounting inside.  Despite the apparent magnitude, the case is small and there is not so much space above the raspi itself, especially if you insert the board on the lower level.  And I need a board, because I need to place several LEDs and a board with RTC. <br><br><div class="spoiler">  <b class="spoiler_title">Body photos</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f83/5ec/6d5/f835ec6d5ce7456794642d472d828b22.jpg"><br><img src="https://habrastorage.org/files/2f9/9d3/32d/2f99d332d54440af839bbd118e0bfd43.jpg"><br><img src="https://habrastorage.org/files/357/201/f75/357201f75a864e26933f07d4b5183005.jpg"><br><img src="https://habrastorage.org/files/042/7ac/e21/0427ace2128844739bf3bee7b8409ec9.jpg"><br><img src="https://habrastorage.org/files/a70/b4e/24a/a70b4e24aedd42b29b175708d6464917.jpg"><br><img src="https://habrastorage.org/files/482/486/038/482486038a9f4ff6bb0404f876576384.jpg"><br></div></div><br>  I want to connect temperature and humidity sensors to a new monitor.  For temperature, our choice is ds18b20, it works, but it is worth comparing readings with a calibrated thermometer, a sensor can lie half a degree according to the specification.  To compensate, he added a primitive correction of the readings to a constant in the config, checked it with such a thermometer <br><br><img src="https://habrastorage.org/files/ab5/ab9/3f7/ab5ab93f7e1c402483c9a720b79def8b.jpg"><br><br>  It turned out that my ds18b20 copies do not completely lie to themselves.  But the next sensor is just lying, and as much as 0.6 degrees.  However, again, it depends on the instance - one lied, the other almost did not lie. <br><br>  The humidity was not so simple.  Cheap either does not work with raspi at all (because it is analog), or there are no libraries (I want to immediately and well), or more expensive like aviation cables.  A compromise between convenience and toad was found in the <a href="https://www.adafruit.com/product/2652">Adafruit BME280</a> sensor, which also shows the temperature with pressure as a bonus (but it can lie, as I noted above). <br><br>  If ds18b20 can simply be shrink and rejoice, with VME280 this trick will not work.  There were a lot of ideas about the case - and left as they were, by soldering the wires and filling them with glue snot (the attachment ears are already there, it turns out), and make a mini-case of the same acrylic as the substrate for the components, and fiction something with 3D printer, the benefit is there is one within reach ... But then I remembered about the eggs: <br><br><img src="https://habrastorage.org/files/4b8/6a3/def/4b86a3def76a49258dc63fdedcaf3b1a.jpg"><br><br>  This is the perfect body.  There is enough space for a sensor, you can put a connector, convenient access for maintenance, you can hang it everywhere or just throw it somewhere. <br><br>  Connect the sensors to raspi decided through DB9.  In the USB lines a little, the RJ45 socket did not fit in size.  The egg sensor decided to connect via USB, because in the cabinet there were found remains of cut USB cables - the good should not be lost: <br><br><img src="https://habrastorage.org/files/522/45b/351/52245b35126b43d98511fa121d23a5c1.jpg"><br><br>  To protect the GPIO-comb on the raspi and for the convenience of disassembling the case, I took another comb and soldered to it.  The comb is angular, which gave a little more space vertically, but I didn‚Äôt read it a little and this comb bumped into the resistors for the LEDs.  All, of course, tightly wrapped in heat shrink, but the point that in the future is worth remembering.  As a result, the halves of the case can still be separated, for example, to change the battery in rtc or the raspi itself.  Everything else (more precisely, a flash drive) is available for replacement without opening the case. <br><br><div class="spoiler">  <b class="spoiler_title">Photos of semi-ready and ready</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/6d4/931/302/6d4931302e0a4ff1bb94087163c40bf2.jpg"><br><img src="https://habrastorage.org/files/3a5/4ce/040/3a54ce040a854b17b13e8a6147107eaf.jpg"><br><img src="https://habrastorage.org/files/def/70a/89d/def70a89d9074613825ac7980d5c5acc.jpg"><br><img src="https://habrastorage.org/files/748/04d/fc7/74804dfc76fd447b972f3737c3fc795e.jpg"><br><img src="https://habrastorage.org/files/755/a75/28f/755a7528f0e94cf088e4a54d48ffdd73.jpg"><br></div></div><br>  One recommendation - do not save on the buttons.  I've saved, so the button not only jingles (this can be fought with, the RPI.GPIO library has anti-bounce protection), but it also works only in a very specific position.  I provided a button for software shutdown of the device in case you need to turn off the power (I already killed the FS on the flash drive several times by inaccurately shutting it down), but it turned out that there was not enough to foresee something - you also need to read the documentation.  If you, like me, do not read the documentation, then you should know - overlay gpio_shutdown does not at all what you would assume, but only exposes a high / low level on a pin when disconnecting, so that, for example, an external power supply can go out .  In order to disable raspi by the button, there is a vigorous rpi_power_switch module (but you need to compile it, and for this, kernel-headers are needed) or the user demon <a href="https://github.com/adafruit/Adafruit-GPIO-Halt">Adafruit-GPIO-Halt</a> .  I will have my hostd, which will flash LEDs, and at the same time it will respond to the button. <br><br><h2>  Conclusion </h2><br>  The result was a software and hardware monitoring system that is extensible using up-to-date technologies and is resistant to failures.  Parts of the software can be updated and restarted independently of other parts (thanks to systemd, this did not require any efforts from me as a developer).  And most importantly - it turned out to get a lot of pleasure from the process and from the result.  Well, a small truck of new knowledge was added. <br><br>  Thank you for reading! </div><p>Source: <a href="https://habr.com/ru/post/311502/">https://habr.com/ru/post/311502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311490/index.html">Becoming a leader (in terms of appointment) and being him (in fact) is a task of varying complexity</a></li>
<li><a href="../311492/index.html">Bypassing the detection of virtual machine programs in VMWare</a></li>
<li><a href="../311494/index.html">Random non-randomness in games</a></li>
<li><a href="../311496/index.html">The difference between eastern and western games of the "three in a row" genre</a></li>
<li><a href="../311500/index.html">Routing in the clojure web application</a></li>
<li><a href="../311506/index.html">Writing an extension using the php-cpp library for php7</a></li>
<li><a href="../311512/index.html">Writing Ruby gem for Yandex Direct API</a></li>
<li><a href="../311514/index.html">New life legacy project</a></li>
<li><a href="../311516/index.html">Success on autopilot. 9 habits that changed my life</a></li>
<li><a href="../311518/index.html">Text that does not exist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>