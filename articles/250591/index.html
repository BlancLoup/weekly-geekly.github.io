<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pure-functional REST API on Finagle / Finch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The history of the Finch library began about a year ago ‚Äúin the basements‚Äù of Confettin , where we tried to make a REST API on Finagle . Despite the f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pure-functional REST API on Finagle / Finch</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/62d/e10/1ae/62de101aed5c14b38da7bbf7997368d6.png" alt="Finch"></div><br><br>  The history of the <a href="https://github.com/finagle/finch">Finch</a> library began about a year ago ‚Äúin the basements‚Äù of <a href="http://konfettin.ru/">Confettin</a> , where we tried to make a REST API on <a href="http://twitter.github.io/finagle/">Finagle</a> .  Despite the fact that finagle-http itself is a very good tool, we began to feel an acute shortage of richer abstractions.  In addition, we had special requirements for these abstractions.  They were supposed to be immutable, composable and at the same time very simple.  Simple as a function.  This is how the Finch library appeared, which is a very thin layer of functions and types on top of finagle-http, which makes the development of HTTP (micro | nano) services on finagle-http more pleasant and simple. <br><br>  Six months ago <a href="https://groups.google.com/forum/">, the first stable version of the</a> library was released, and just recently <a href="">, version 0.5.0 was released</a> , which I personally consider to be pre-alpha 1.0.0.  During this time, <a href="https://github.com/finagle/finch">6 companies</a> (three of them are not yet on the official list: <a href="http://mesosphere.com/">Mesosphere</a> , <a href="http://www.sphonic.com/">Shponic</a> and <a href="http://globo.com/">Globo.com</a> ) began using Finch in production, and some of them even became active contributors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This post tells about three whales on which Finch is built: <code>Router</code> , <code>RequestReader</code> and <code>ResponseBuilder</code> . <br><a name="habracut"></a><br><h2> <code>Router</code> </h2> <br>  The <code>io.finch.route</code> package implements the route combinators API, which allows you to build an infinite number of routers, combining them from primitive routers accessible from the box.  <a href="http://www.scala-lang.org/api/2.10.2/index.html">Parser Combinators</a> and <a href="https://github.com/scodec/scodec">scodec</a> use the same approach. <br><br>  In a sense, <code>Router[A]</code> is a function of <code>Route =&gt; Option[(Route, A)]</code> .  <code>Router</code> takes the abstract Route route and returns <code>Option</code> from the remaining route and the extracted value of type <code>A</code>  In other words, <code>Router</code> returns <code>Some(...)</code> in case of success (if the request was able to route it). <br><br>  There are only 4 basic routers: <code>int</code> , <code>long</code> , <code>string</code> and <code>boolean</code> .  In addition, there are routers that do not extract the value from the route, but simply associate it with a sample (for example, routers for HTTP methods: <code>Get</code> , <code>Post</code> ). <br><br>  The following example shows the API for the composition of routers.  The <code>router</code> routes the <code>GET /(users|user)/:id</code> requests and extracts the integer <code>id</code> value from the route.  Pay attention to the operator <code>/</code> (or <code>andThen</code> ), with the help of which we sequentially compose two routers, and also on the operator <code>|</code>  (or <code>orElse</code> ), which allows you to compose two routers in terms of logical <code>or</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> router: <span class="hljs-type"><span class="hljs-type">Router</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">Get</span></span> / (<span class="hljs-string"><span class="hljs-string">"users"</span></span> | <span class="hljs-string"><span class="hljs-string">"user"</span></span>) / int(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)</code> </pre><br>  If the router needs to extract several values, you can use the special type <code>/</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ticket</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, ticketId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r0</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Router</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span> / <span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Get</span></span> / <span class="hljs-string"><span class="hljs-string">"users"</span></span> / int / <span class="hljs-string"><span class="hljs-string">"tickets"</span></span> / int <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1: <span class="hljs-type"><span class="hljs-type">Router</span></span>[<span class="hljs-type"><span class="hljs-type">Ticket</span></span>] = r0 map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a / b =&gt; <span class="hljs-type"><span class="hljs-type">Ticket</span></span>(a, b) }</code> </pre><br>  There is a special type of routers that extract service (Finagle <code>Service</code> ) from the route.  Such routers are called endpoints (in fact, <code>Endpoint[Req, Rep]</code> is just a type alias on <code>Router[Service[Req, Rep]]</code> ).  <code>Endpoint</code> s can be implicitly converted to Finagle services ( <code>Service</code> ), which allows them to be used transparently with the Finagle HTTP API. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> users: <span class="hljs-type"><span class="hljs-type">Endpoint</span></span>[<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>, <span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>] = (<span class="hljs-type"><span class="hljs-type">Get</span></span> / <span class="hljs-string"><span class="hljs-string">"users"</span></span> / long /&gt; <span class="hljs-type"><span class="hljs-type">GetUser</span></span>) | (<span class="hljs-type"><span class="hljs-type">Post</span></span> / <span class="hljs-string"><span class="hljs-string">"users"</span></span> /&gt; <span class="hljs-type"><span class="hljs-type">PostUser</span></span>) | (<span class="hljs-type"><span class="hljs-type">Get</span></span> / <span class="hljs-string"><span class="hljs-string">"users"</span></span> /&gt; <span class="hljs-type"><span class="hljs-type">GetAllUsers</span></span>) <span class="hljs-type"><span class="hljs-type">Httpx</span></span>.serve(<span class="hljs-string"><span class="hljs-string">":8081"</span></span>, users)</code> </pre><br><h2> <code>RequestReader</code> </h2> <br>  The <code>io.finch.request.RequestReader</code> is key in Finch.  Obviously, most of the REST API (without taking into account business logic) is reading and validating the request parameters.  This is <code>RequestReader</code> .  Like everything else in Finch, <code>RequestReader[A]</code> is a <code>HttpRequest =&gt; Future[A]</code> function.  Thus, <code>RequestReader[A]</code> accepts an HTTP request and reads some value of type <code>A</code> from it.  The result is placed in the <code>Future</code> , primarily in order to represent the stage of reading the parameters as an additional <code>Future</code> transformation (as a rule, the first) in the data-flow of the service.  Therefore, if <code>RequestReader</code> returns <code>Future.exception</code> , no further transformations will be performed.  This behavior is extremely convenient in 99% of cases when the service should not do any real work if one of its parameters is invalid. <br><br>  In the following example, <code>RequestReader</code> <code>title</code> reads the required query-string ‚Äútitle‚Äù parameter or returns a <code>NotPresent</code> exception if the parameter is missing in the request. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"title"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Service</span></span>[<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>, <span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(req: <span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { t &lt;- title(req) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Ok</span></span>(<span class="hljs-string"><span class="hljs-string">s"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$t</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$name</span></span></span><span class="hljs-string">!"</span></span>) }</code> </pre> <br>  The <code>io.finch.request</code> package provides a rich set of built-in <code>RequestReader</code> s for reading various information from an HTTP request: starting from query-string parameters and ending with cookies.  All available <code>RequestReader</code> -y are divided into two groups - required (required) and optional (optional).  Required readers read the value or exception <code>NotPresent</code> , optional - <code>Option[A]</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"fname"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondName: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-type"><span class="hljs-type">OptionalParam</span></span>(<span class="hljs-string"><span class="hljs-string">"sname"</span></span>)</code> </pre><br>  As in the case of route combinators, <code>RequestReader</code> provides an API with which you can compose two readers into one.  There are two APIs: monadic (using <code>flatMap</code> ) and applicative (using <code>~</code> ).  While monadic syntax looks familiar, it is highly recommended to use applicative syntax, which allows you to accumulate errors, while the fail-fast nature of monads returns only the first one.  The example below shows both ways of composing a reader. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">firstName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, secondName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">monadic</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">style</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">monadicUser</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { firstName &lt;- <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"fname"</span></span>) secondName &lt;- <span class="hljs-type"><span class="hljs-type">OptionalParam</span></span>(<span class="hljs-string"><span class="hljs-string">"sname"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(firstName, secondName.getOrElse(<span class="hljs-string"><span class="hljs-string">""</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// the applicate style val applicativeUser: RequestReader[User] = RequiredParam("fname") ~ OptionalParam("sname") map { case fname ~ sname =&gt; User(fname, sname.getOrElse("")) }</span></span></code> </pre><br>  Among other things, <code>RequestReader</code> allows <code>RequestReader</code> to read from the request values ‚Äã‚Äãof types other than String.  You can convert the readable value using the <code>RequestReader.as[A]</code> method. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) ~ <span class="hljs-type"><span class="hljs-type">OptionalParam</span></span>(<span class="hljs-string"><span class="hljs-string">"age"</span></span>).as[<span class="hljs-type"><span class="hljs-type">Int</span></span>] map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name ~ age =&gt; <span class="hljs-type"><span class="hljs-type">User</span></span>(fname, age.getOrElse(<span class="hljs-number"><span class="hljs-number">100</span></span>)) }</code> </pre><br>  The basis of the magic of the <code>as[A]</code> method is an implicit <code>DecodeRequest[A]</code> type parameter.  Type-class <code>DecodeRequest[A]</code> carries information about how type <code>A</code> can be obtained from a <code>String</code> .  In case of conversion error, <code>RequestReader</code> will read <code>NotParsed</code> exception.  Out of the box, conversions to <code>Int</code> , <code>Long</code> , <code>Float</code> , <code>Double</code> and <code>Boolean</code> types are supported. <br><br>  JSON support in <code>RequestReader</code> implemented in the same way: we can use the <code>as[Json]</code> method if for <code>Json</code> there is an implementation of <code>DecodeRequest[Json]</code> in the current scope.  In the example below, <code>RequestReader</code> <code>user</code> reads a user that is serialized in JSON format to the body of the HTTP request. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">Json</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredBody</span></span>.as[<span class="hljs-type"><span class="hljs-type">Json</span></span>]</code> </pre><br>  Given the support of the <a href="http://jackson.codehaus.org/">Jackson</a> JSON library, reading JSON objects using <code>RequestReader</code> greatly simplified. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.finch.jackson._ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredBody</span></span>.as[<span class="hljs-type"><span class="hljs-type">User</span></span>]</code> </pre><br>  Validation of request parameters is carried out using the methods <code>RequestReader.should</code> and <code>RequestReader.shouldNot</code> .  There are two ways of validation: using inline rules and using ready-made <code>ValidationRule</code> .  In the example below, the <code>age</code> reader reads the ‚Äúage‚Äù parameter, provided it is greater than 0 and less than 120. Otherwise, the reader will read the <code>NotValid</code> exception. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"age"</span></span>).as[<span class="hljs-type"><span class="hljs-type">Int</span></span>] should(<span class="hljs-string"><span class="hljs-string">"be &gt; than 0"</span></span>) { _ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } should(<span class="hljs-string"><span class="hljs-string">"be &lt; than 120"</span></span>) { _ &lt; <span class="hljs-number"><span class="hljs-number">120</span></span> }</code> </pre><br>  The example above can be rewritten in a more concise style, using ready-made rules from the <code>io.finch.request</code> package and the <code>io.finch.request</code> composers <code>and</code> from the <code>ValidationRule</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">RequestReader</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">RequiredParam</span></span>(<span class="hljs-string"><span class="hljs-string">"age"</span></span>).as[<span class="hljs-type"><span class="hljs-type">Int</span></span>] should (beGreaterThan(<span class="hljs-number"><span class="hljs-number">0</span></span>) and beLessThan(<span class="hljs-number"><span class="hljs-number">120</span></span>))</code> </pre><br><h2> <code>ResponseBuilder</code> </h2> <br>  The <code>io.finch.response</code> package provides a simple API for building HTTP responses.  It is considered common practice to use a specific <code>ResponseBuilder</code> corresponding to the response status code, for example, <code>Ok</code> or <code>Created</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response: <span class="hljs-type"><span class="hljs-type">HttpResponse</span></span> = <span class="hljs-type"><span class="hljs-type">Created</span></span>(<span class="hljs-string"><span class="hljs-string">"User 1 has been created"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// plain/text response</span></span></code> </pre><br>  An important abstraction of the <code>io.finch.response</code> package is type-class <code>EncodeResponse[A]</code> .  <code>ResponseBuilder</code> is able to build HTTP responses from any type <code>A</code> , if for it there is an implicit value <code>EncodeResponse[A]</code> in the current scope.  This is how JSON support is implemented in <code>ResponseBuilder</code> : for each supported library there is an implementation of <code>EncodeResponse[A]</code> .  The following code shows integration with the standard JSON implementation from the <code>finch-json</code> module. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.finch.json._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = <span class="hljs-type"><span class="hljs-type">Ok</span></span>(<span class="hljs-type"><span class="hljs-type">Json</span></span>.obj(<span class="hljs-string"><span class="hljs-string">"name"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// application/json response</span></span></code> </pre><br>  Thus, you can extend the functionality of <code>ResponseBuilder</code> adding implicit <code>EncodeResponse[A]</code> values ‚Äã‚Äãfor the required type to the current scope.  For example, for type <code>User</code> . <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">encodeUser</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EncodeResponse</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>](<span class="hljs-string"><span class="hljs-string">"applciation/json"</span></span>) { u =&gt; <span class="hljs-string"><span class="hljs-string">s"{\"name\" : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${u.name}</span></span></span><span class="hljs-string">, \"id\" : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${u.id}</span></span></span><span class="hljs-string">}"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = <span class="hljs-type"><span class="hljs-type">Ok</span></span>(<span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// application/json response</span></span></code> </pre><br><h2>  Conclusion </h2><br>  Finch is a very young project that is definitely not a ‚Äúsilver bullet‚Äù devoid of ‚Äúcritical flaws‚Äù.  This is only a tool that some developers consider effective for the tasks they are working on.  I hope that this publication will become a starting point for Russian-speaking programmers who have decided to use / try Finch in their projects. <br><br><ul><li>  <a href="https://github.com/finagle/finch">Finch on github</a> </li><li>  <a href="https://finagle.github.io/blog/2014/12/10/rest-apis-with-finch">Post on Finagle blog</a> </li><li>  <a href="https://github.com/finagle/finch/tree/master/demo/src/main/scala/io/finch/demo">Demo</a> </li><li>  <a href="">User Guide</a> </li><li>  <a href="https://gitter.im/finagle/finch">Gitter chat</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/250591/">https://habr.com/ru/post/250591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250581/index.html">RefluxJS - an alternative look at Flux architecture from Facebook</a></li>
<li><a href="../250583/index.html">What version of java are you using?</a></li>
<li><a href="../250585/index.html">The challenge of 64 coins, two prisoners and one chessboard</a></li>
<li><a href="../250587/index.html">How to find out the location of a user, knowing only his email address</a></li>
<li><a href="../250589/index.html">Angular Light + Object.observe</a></li>
<li><a href="../250593/index.html">Lectures Technopark. Programming in management. The story of one student Baumanki</a></li>
<li><a href="../250597/index.html">Hackers made one of the largest bank robberies in history</a></li>
<li><a href="../250599/index.html">Sharing Cryptodisks on PC and Android</a></li>
<li><a href="../250601/index.html">The picture of the world is complete: HabraDarkAge began to support TMfeed.ru</a></li>
<li><a href="../250603/index.html">Hibernate: lazy loading, inheritance and instanceof</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>