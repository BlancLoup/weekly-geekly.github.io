<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I saved a few lives with optimization and a little about working at Zeptolab</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 23derevo before speaking at Mobius asked me to talk a little about the client development process in Zeptolab. 



 To begin with, we write ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I saved a few lives with optimization and a little about working at Zeptolab</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  <a href="http://habrahabr.ru/users/23derevo/" class="user_link">23derevo</a> before speaking at Mobius asked me to talk a little about the client development process in Zeptolab. <br><br><img src="https://habrastorage.org/files/5d5/481/c50/5d5481c50ef64895b185a6537706b1fd.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To begin with, we write in C ++ and in our framework; from any client device, we need only the OpenGL context.  Then we build our interface from scratch, our controls and so on.  Accordingly, in order to take a developer into a team, in theory, it is enough for him to know the advantages.  In practice, this is a bit wrong. <br><br><a name="habracut"></a><br><br><h1>  About work </h1><br>  I came to Zeptolab even when we had three developers: CTO, iOS-developer and Android-developer.  Before that, I studied at ShAD Yandex and, in parallel with work, sawed the base of customs documentation with the possibility of rich formatting, storing files and images - in general, a kind of MSDN, only for customs needs.  Until now, it is used, and until now, it is just beginning to find analogs. <br><br>  I had no super cool technological knowledge, I was engaged in graphics, wrote small projects on OpenGL, did shaders.  This, in general, was enough to start learning from the mobile development branch. <br><br>  In my opinion, the most important thing for a candidate (and a developer in general) is general intelligence, technical outlook and technical thinking.  By the way, at the interview I was asked the notorious task about round hatches.  Now I myself conduct interviews, and give similar abstract tasks.  Oskomina they fill some candidates due to the fact that the list of such tasks rarely changes (if given randomly, there will not be a common metric - it will not be very fair to the candidates).  But, given that they are ‚Äúleaking‚Äù beyond the limits of interviews, we usually prepare a couple more of our tasks to check if the candidate does not read.  If the logic is all right, then ignorance of some syntactic features of the language is a problem of a smaller scale.  You can learn the syntax, programming patterns are also being studied, but, alas, you need to think right away. <br><br>  In general, the coder differs from the developer in that the latter is able to come up with ideas for solving problems.  In one well-known large company my good friend works.  Their Russian office is busy only by inventing algorithms, checking them on Python or C # for prototypes, and then giving the results to the units in India and China.  There, already far-away coders without fantasy, but with the utmost pedantry and with purely Asian persistence, take the described ideas and ideally implement them in the code for C ++ or C microcontrollers for each device. <br><br>  I would advise those who are looking for work immediately after the university to get a rating in the region of 2000 on Codeforces.  If you are slightly yellow there, this is a high chance to go, for example, in Google.  In addition, you will quickly understand that the first place is the ability to think and solve unique problems, when specific technologies are already being studied ‚Äúlocally‚Äù to the required (or sufficient) level. <br><br><h1>  A few words about the artists </h1><br>  At first we had Cocos2D.  A good framework, but many things simply did not suit us for implementation, so we began to write our system.  Quickly enough, I managed to implement a very cool animation system and good resource preparation in C ++.  We have already told about the animation, if briefly - it is prepared in Flash, then we parse the FLA-files, and then we recreate the same animations in the application.  The most important thing for us has always been the emphasis on quality.  In the case of animations, this is smooth: artists often stand behind the programmers and say what‚Äôs wrong.  Without training, you can not see where and what slightly twitches, but the artists just feel it.  An ordinary person will not be able to understand what is wrong, and will not always be able to describe it, even if he sees it.  But it will feel, often not very consciously, that it is ‚Äúrough.‚Äù  Our artists achieve the perfect picture for themselves, and they know how to explain in technical terms what needs to be changed. <br><br><img src="https://habrastorage.org/files/68b/070/cd5/68b070cd56f245adaa95b2503b34caea.jpg"><br><br>  At the <a href="http://mobiusconf.com/">conference,</a> our guys will tell you exactly how we achieved this quality of picture and show that under the hood of the framework.  I will tell about the evolution of our technologies, about the preparation of resources.  It is very important for controls to get exactly a pixel to a pixel, to prepare fonts correctly, to take into account low-res devices and much more.  Again, I will show concrete examples at the conference. <br><br><img src="https://habrastorage.org/files/dec/eff/727/deceff727ac44732b2703011db061a77.jpg"><br><br>  For me, perhaps the greatest thrill is to stand behind the artist and watch him create a masterpiece out of nothing.  Sometimes they also look at us and try to understand what we are doing.  It seems to us in development that there are few good artists on the market, and it‚Äôs hard to find such cool ones.  It seems to them that developers who understand what they need are unrealistically few. <br><br><img src="https://habrastorage.org/files/80d/466/c1a/80d466c1a4b640149f86acb6f905e408.jpg"><br><br>  By the way, with all their sincere humanitarian education, there have never been any problems with the technical part.  The tasks are formulated perfectly, the general architecture is presented.  There was even such a funny case: we photographed for a contest on Codeforces we are an artist in the role of developer, for fun.  Glasses, complex face, thought.  So, after that, he suddenly began to write code in JavaScript.  At first there were very simple macros for Photoshop and Flash.  Then in a few months, in fact, went through the whole history of the evolution of the development, discovering new and new possibilities.  I remember that at some point he came up and began to clumsily explain a concept that would help him write complex scripts: after a while I realized that he wanted to set breakpoints and watch the values ‚Äã‚Äãof variables.  Himself came to the use of assertions.  Prior to that, we sometimes laughed at his code: he interfered with expressions in one line, without indents, it looked really a little crazy.  And then somehow quietly began to make very cool scripts.  Now we think who else to photograph with a complex face. <br>  But back to the framework.  We have quite a lot of routine, in particular, associated with its constant modifications.  The framework develops, a new hardware appears, new requirements, I want to deal with the Legacy code in a timely manner.  Of the last major tasks, for example, we needed our own particle system.  We looked at what is in Unity, the artists say - megakruto, but you need more of this, this and this. <br><br>  As a result, the task has been reduced not only to writing a particle generator, but also to the implementation of a user-friendly interface.  We have several layers of emission, and the particles move according to different laws.  An arbitrary formula for each would very heavily load client devices (in fact, it would have to parse each one separately), and the overall one was not flexible enough to implement the artists' ideas.  It was decided by mathematics - they derived some general formula for each particle, where by changing the coefficients you can run even a parabola, even a sinusoid.  And it does not slow down, and there is visual wealth. <br><br><h1>  In a team </h1><br><br>  Every two weeks we teach ourselves.  The guys (and now we have 21 developers in the team) are learning something new, which they have not yet used on other projects, or which are not in other companies.  They gather everyone, they say that they have found something interesting.  It can be a variety of topics: starting from how to make the download subjectively fast for the user and ending with a quick background blur behind popup (as done in King of Thieves).  Mikhail Mirzayanov regularly came to our office (by the way, he coached our team, which won first place at ACM / ICPC).  I read 3 blocks of the coolest lectures on algorithms and data structures, showed rare, little-known structures and tasks (for example, about a segment tree, which he independently discovered as one of the first in the world and the first in Russia).  As a training, we went to a three-day training session by Scott Myers (who wrote this book "Effective Modern C ++"). <br><br><img src="https://habrastorage.org/files/606/be5/2ba/606be52ba8144e49ad53c7e6f0d54541.jpg"><br><br>  Of the examples of problems, in 2013 a rather large article was published on the solutions of the well-known NP-hard problem on the packaging of texture atlases.  According to the results of one of the Codeforces contests, a strong algorithmist came to us.  I read the article, I thought for a long time, then I wrote my own algorithm, an improved version of the well-known, which we immediately checked on one of the most difficult packaged atlases.  If we take for 100% perfect packaging, then our previous algorithm gave more than 120% result, and the new one on the same data set began to show 104%.  In practice, this means a reduction in memory consumption per megabytes. <br><br>  In general, for 500 million installations such things look very funny.  For example, our very first system for storing and loading images operated on PNG files, and it took about 15 seconds to load the level on the test device.  Profiled, sorted out - PNG decoding took most of the time.  I rewrote this code (it took a new internal graphics storage format) - and on the same test device, the download took 6 seconds.  9 seconds saved - we rolled out a new storage system for all our games.  If you count the 20 downloads of the game for some basic indicator, it seems to me that this saved at least fifty lives.  Then this mechanism was accelerated by another 20-30% on the advice of a beginner, who did the same at the old place of work, because at some point simple calculations on the processor ceased to be a bottleneck of the loading system, everything began to rest on the reading speed from the storage. .  Improved your format. <br>  Optimization is generally a lot of work.  Our games even work on old hardware, the framework supports iOS 4.3 (now iOS 5: initially because of the partner code, then we began to use libc ++, which is also available from iOS 5, in the second version of the framework).  We are developing entirely new applications and experiments under the top models, because by the end of the development they will become the most popular device - but we don‚Äôt forget the ‚Äúoldies‚Äù.  With the same "Cut the Rope" most of the release is content updates.  The old code is not broken.  New games are much richer visually, but the requirements for the hardware are higher. <br><br>  We do prototyping very quickly, faster than in many studios.  A game designer issues a concept, then in 1-2 days one of the developers does a ‚Äúdream job‚Äù - collects a prototype from scratch without graphics, on primitives.  If jumping the ball and the square after that pins the game designer - goes to work further.  Naturally, the prototypes are much smaller than the usual tasks, but we are trying to ensure that everyone in the team sooner or later wrote his own. <br><br>  Again, of course, we do it right away on the finished blank project, where all the basic things are.  For people coming from the development of native mobile applications, this is just another world - there are no standard controllers, their own preparation of resources, in general, all of their own and not even particularly tied to the platform.  Those who worked with Unity are more interested in digging ‚Äúunder the hood‚Äù, seeing the realization of some things that are difficult to do there.  With Coconut, in general, there are parallels at a high level, but it is still interesting to make out the game and see how it works inside. <br><br><h1>  A little about the test </h1><br><br>  Finally - my little argument with friends.  Below under the spoiler 5 sample code from test tasks from different people.  The code is published with the consent of all candidates.  (careful, the sources are quite large) <br><br><div class="spoiler">  <b class="spoiler_title">App.cpp</b> <div class="spoiler_text"><pre><code class="hljs pgsql">// // App.cpp // Asteroids // // Created <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> xxxx // // #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;string&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "App.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "RenderCommandPolygonConvex.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Vec2.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Color.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "GameMap.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Camera.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapDrawObjectPolygon.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapObjectMovable.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "IMovable.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MovableObjectTouch.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapObjectEmitter.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "EmitterLineContinuous.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MovableInDirection.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapObjectHero.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapObjectAsteroid.h" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "MapObjectDebris.h" const <span class="hljs-type"><span class="hljs-type">float</span></span> LOGIC_MAP_WIDTH = <span class="hljs-number"><span class="hljs-number">100</span></span>; const <span class="hljs-type"><span class="hljs-type">float</span></span> GAMEPLAY_ACCELERATION = <span class="hljs-number"><span class="hljs-number">0.003</span></span>; namespace { <span class="hljs-type"><span class="hljs-type">void</span></span> initAsteroidsEmitters(GameMapPtr gameMap, <span class="hljs-type"><span class="hljs-type">float</span></span> logicMapWidth, std::vector&lt;EmitterLineContinuousPtr&gt;&amp; asteroidEmitters) { for_each(asteroidEmitters.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), asteroidEmitters.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), [](EmitterLineContinuousPtr emitter){emitter-&gt;die();}); MapObjectEmitterPtr emitterMapObject(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectEmitter()); EmitterLineContinuousPtr emitter(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EmitterLineContinuous(Vec2(-logicMapWidth*<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(logicMapWidth*<span class="hljs-number"><span class="hljs-number">1.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, gameMap)); emitter-&gt;setParticlesMapObject(MapObjectAsteroidPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectAsteroid())); asteroidEmitters.push_back(emitter); emitterMapObject-&gt;setEmitter(emitter); gameMap-&gt;addMapObject(emitterMapObject, Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); MapObjectEmitterPtr emitterMapObject2(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectEmitter()); EmitterLineContinuousPtr emitter2(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EmitterLineContinuous(Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(logicMapWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, gameMap)); emitter2-&gt;setParticlesMapObject(MapObjectAsteroidPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectAsteroid())); emitterMapObject2-&gt;setEmitter(emitter2); asteroidEmitters.push_back(emitter2); gameMap-&gt;addMapObject(emitterMapObject2, Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); MapObjectEmitterPtr emitterMapObject3(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectEmitter()); EmitterLineContinuousPtr emitter3(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EmitterLineContinuous(Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(logicMapWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, gameMap)); emitter3-&gt;setParticlesMapObject(MapObjectDebrisPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectDebris())); emitterMapObject3-&gt;setEmitter(emitter3); asteroidEmitters.push_back(emitter3); gameMap-&gt;addMapObject(emitterMapObject3, Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); MapObjectEmitterPtr emitterMapObject4(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectEmitter()); EmitterLineContinuousPtr emitter4(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EmitterLineContinuous(Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(logicMapWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>), Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, gameMap)); emitter4-&gt;setParticlesMapObject(MapObjectAsteroidPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectAsteroid())); emitterMapObject4-&gt;setEmitter(emitter4); asteroidEmitters.push_back(emitter4); gameMap-&gt;addMapObject(emitterMapObject4, Vec2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); } } App::App() :time_(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-type"><span class="hljs-type">void</span></span> App::updateAndRender(<span class="hljs-type"><span class="hljs-type">float</span></span> dtSec, std::vector&lt;RenderCommandBasePtr&gt;&amp; renderCommands) { <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(dtSec); collectRenderData(renderCommands); } <span class="hljs-type"><span class="hljs-type">bool</span></span> App::touch(const std::vector&lt;TouchEvent&gt;&amp; events) const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events.empty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameMap_) gameMap_-&gt;touch(events); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> App::<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(<span class="hljs-type"><span class="hljs-type">float</span></span> dtSec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameMap_) gameMap_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(dtSec); tryRespawnHero(); updateGameplayAcceleration(); time_+= dtSec; } <span class="hljs-type"><span class="hljs-type">void</span></span> App::resetGameplay() { time_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; ::initAsteroidsEmitters(gameMap_, LOGIC_MAP_WIDTH, asteroidEmitters_); } <span class="hljs-type"><span class="hljs-type">void</span></span> App::tryRespawnHero() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hero_ || hero_-&gt;isReadyToDestruct() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gameMap_-&gt;hasObjectOfType(MAP_OBJECT_HERO_DEBRIS)) { resetGameplay(); hero_ = MapObjectHeroPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MapObjectHero(Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, logicMapSize_.x, logicMapSize_.y))); gameMap_-&gt;addMapObject(hero_, Vec2(<span class="hljs-number"><span class="hljs-number">50</span></span>, logicMapSize_.y - <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); } } } <span class="hljs-type"><span class="hljs-type">void</span></span> App::setScreenSize(<span class="hljs-type"><span class="hljs-type">int</span></span> screenW, <span class="hljs-type"><span class="hljs-type">int</span></span> screenH) { screenSize_ = Vec2(screenW, screenH); <span class="hljs-type"><span class="hljs-type">float</span></span> logicCellSize = screenW/LOGIC_MAP_WIDTH; logicMapSize_ = Vec2(screenW/logicCellSize, screenH/logicCellSize); CameraPtr camera = CameraPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Camera(logicCellSize, logicCellSize)); gameMap_ = GameMapPtr(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GameMap(Size(logicMapSize_.x, logicMapSize_.y), camera)); gameMap_-&gt;setLiveAreaRect(Rect(-logicMapSize_.x/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, logicMapSize_.x*<span class="hljs-number"><span class="hljs-number">2</span></span>, logicMapSize_.y + <span class="hljs-number"><span class="hljs-number">20</span></span>)); resetGameplay(); } <span class="hljs-type"><span class="hljs-type">void</span></span> App::collectRenderData(std::vector&lt;RenderCommandBasePtr&gt;&amp; renderCommands) const { gameMap_-&gt;collectRenderData(renderCommands); } <span class="hljs-type"><span class="hljs-type">void</span></span> App::updateGameplayAcceleration() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto emitter: asteroidEmitters_) { emitter-&gt;setSpeedParticles(emitter-&gt;getSpeedParticles() + time_*GAMEPLAY_ACCELERATION); } }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">game.cpp</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/* w,a,d    r   , space  *<span class="hljs-regexp"><span class="hljs-regexp">/ #include "stdafx.h" #include &lt;math.h&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;glut.h&gt; using namespace std; const float Pi=3.14159265358; float winwid=400; float winhei=400; bool game_end=0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//bullet</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> float dx=<span class="hljs-number"><span class="hljs-number">0</span></span>,dy=<span class="hljs-number"><span class="hljs-number">0</span></span>; float bull_speed=<span class="hljs-number"><span class="hljs-number">6</span></span>; float betta=<span class="hljs-number"><span class="hljs-number">0</span></span>; bool fl1=<span class="hljs-number"><span class="hljs-number">0</span></span>, fl2=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ship/</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ float speed=0; float angle=0; float acsel=0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//asteroid</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ float ast_size=50; float aster_speed=3; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>-rand/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ int kol_aster=0; class bullet { public: float dxb; float dyb; float angleb; bullet() { dxb=dx; dyb=dy; angleb=betta; } }; class asteroid { public: float anglea; float dx; float dy; float depth; int n; int i_big; int ifsmall; vector &lt;double&gt; x; vector &lt;double&gt; y; void create(int i,bool param); void create_small(int i,int j,bool param,float depth1,float dx1,float dy1); }; void asteroid:: create_small(int i,int j,bool param,float depth1,float dx1,float dy1) { ifsmall=0; int size=ast_size/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>; depth=depth1+(j+<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(<span class="hljs-number"><span class="hljs-number">8.0</span></span>*(kol_aster)); dx=dx1; dy=dy1; i_big=i; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ int quat=rand()%4; int n1=rand()%2+1; int n2=rand()%2+1; int n3=rand()%2+1; int n4=rand()%2+1; n1=n2=n3=n4=1; n=n1+n2+n3+n4; double xi,yi; anglea=rand()%360; x.clear(); y.clear(); for (int i=0;i&lt;n1;i++) { xi=rand()%(size/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>)-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n2;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n3;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n4;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ } void asteroid:: create(int kol_exist,bool param) { int size=ast_size; int quat=rand()%4; int n1=rand()%2+1; int n2=rand()%2+1; int n3=rand()%2+1; int n4=rand()%2+1; n1=n2=n3=n4=1; n=n1+n2+n3+n4; double xi,yi; anglea=rand()%360; i_big=kol_exist; ifsmall=1; depth=(float)(kol_exist)/</span></span>((kol_aster)); dx=rand()<span class="hljs-string"><span class="hljs-string">%(int)</span></span>winwid -winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; dy=rand()<span class="hljs-string"><span class="hljs-string">%(int)</span></span>winhei -winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(quat==<span class="hljs-number"><span class="hljs-number">0</span></span>) dy=-ast_size-winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(quat==<span class="hljs-number"><span class="hljs-number">1</span></span>) dy=ast_size+winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(quat==<span class="hljs-number"><span class="hljs-number">2</span></span>) dx=-ast_size-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(quat==<span class="hljs-number"><span class="hljs-number">3</span></span>) dx=ast_size+winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.clear(); y.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n1;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n2;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n3;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>+size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n4;i++) { xi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; yi=rand()<span class="hljs-string"><span class="hljs-string">%(size/2)</span></span>-size/<span class="hljs-number"><span class="hljs-number">2</span></span>; x.push_back(xi); y.push_back(yi); } } vector &lt;bullet&gt; vecb; vector &lt;asteroid&gt; veca; void destroy_small_ast( int i) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span> -  /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> bool create_big=<span class="hljs-number"><span class="hljs-number">1</span></span>; float up_boarder=(float)(veca[i].i_big)/((kol_aster)); float down_boarder=(float)(veca[i].i_big)/((kol_aster)); asteroid a_big; a_big.create(veca[i].i_big,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(veca[i-<span class="hljs-number"><span class="hljs-number">1</span></span>].depth&gt;down_boarder) create_big=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i&lt;veca.size()-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(veca[i+<span class="hljs-number"><span class="hljs-number">1</span></span>].depth&lt;up_boarder) create_big=<span class="hljs-number"><span class="hljs-number">0</span></span>; {<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (create_big==<span class="hljs-number"><span class="hljs-number">1</span></span>) {veca.insert(veca.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+veca[i].i_big,a_big); veca[veca[i].i_big].create(veca[i].i_big,<span class="hljs-number"><span class="hljs-number">1</span></span>); veca.erase(veca.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+i+<span class="hljs-number"><span class="hljs-number">1</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> veca.erase(veca.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+i);} } void destroy_aster(float dep) { dep=<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>*dep; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;veca.size();i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(dep-veca[i].depth)&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0001</span></span>) {<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(veca[i].ifsmall==<span class="hljs-number"><span class="hljs-number">1</span></span>) { veca.resize(veca.size()+<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>;j++) veca[veca.size()-j-<span class="hljs-number"><span class="hljs-number">1</span></span>].create_small(i,j,<span class="hljs-number"><span class="hljs-number">0</span></span>,veca[i].depth,veca[i].dx,veca[i].dy); veca.erase(veca.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+i); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {destroy_small_ast( i);<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } } void shoot() { float depth[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;vecb.size();i++) { glLoadIdentity(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ vecb[i].dxb+=(speed+bull_speed)*cos(Pi*(vecb[i].angleb)/</span></span><span class="hljs-number"><span class="hljs-number">180.0</span></span>); vecb[i].dyb+=(speed+bull_speed)*sin(Pi*(vecb[i].angleb)/<span class="hljs-number"><span class="hljs-number">180.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((vecb[i].dxb&gt;winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span>(vecb[i].dxb&lt;-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span>(vecb[i].dyb&lt;-winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span> (vecb[i].dyb&gt;winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) {vecb.erase(vecb.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+i);i--;} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ glReadPixels((vecb[i].dxb+winwid/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>),-vecb[i].dyb+winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,GL_DEPTH_COMPONENT,GL_FLOAT,depth); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (depth[<span class="hljs-number"><span class="hljs-number">0</span></span>]!=<span class="hljs-number"><span class="hljs-number">1</span></span>) { destroy_aster(depth[<span class="hljs-number"><span class="hljs-number">0</span></span>]); vecb.erase(vecb.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>()+i); i--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ glTranslatef(vecb[i].dxb,vecb[i].dyb,0.0f); glColor3f(1.0f,1.0f,1.0f); glBegin(GL_LINES); glVertex3f( 0.0,0.0, 0.5f); glVertex3f(1.0,0.0, 0.5f); glEnd(); } } } } void aster_draw() { glColor3f(0.5f,1.0f,1.0f); glLoadIdentity(); for (int i=0;i&lt;veca.size();i++) { glBegin(GL_POLYGON); for(int j=0;j&lt;veca[i].n;j++) glVertex3f( veca[i].dx+veca[i].x[j],veca[i].dy+veca[i].y[j], veca[i].depth); glEnd(); veca[i].dx+=aster_speed*cos(Pi*(veca[i].anglea)/</span></span><span class="hljs-number"><span class="hljs-number">180.0</span></span>); veca[i].dy+=aster_speed*sin(Pi*(veca[i].anglea)/<span class="hljs-number"><span class="hljs-number">180.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((veca[i].dx&gt;winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>+ast_size) <span class="hljs-params"><span class="hljs-params">||</span></span>(veca[i].dx&lt;-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>-ast_size) <span class="hljs-params"><span class="hljs-params">||</span></span>(veca[i].dy&lt;-winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>-ast_size) <span class="hljs-params"><span class="hljs-params">||</span></span> (veca[i].dy&gt;winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>+ast_size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (veca[i].ifsmall==<span class="hljs-number"><span class="hljs-number">0</span></span>) {destroy_small_ast( i);i--;} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> veca[i].create(i,<span class="hljs-number"><span class="hljs-number">1</span></span>); } } void asteroidsinit() { int k; k=rand()%<span class="hljs-number"><span class="hljs-number">6</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(kol_aster!=<span class="hljs-number"><span class="hljs-number">0</span></span>) k=kol_aster; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> kol_aster=k; veca.resize(k); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;k;i++) veca[i].create(i,<span class="hljs-number"><span class="hljs-number">1</span></span>); } void draw_ship() { float depth[<span class="hljs-number"><span class="hljs-number">6</span></span>]; float dx1,dx2,dy1,dy2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dx&lt;winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dx&gt;-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy&lt;winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy&gt;-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)) glReadPixels((dx+winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>),-dy+winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,GL_DEPTH_COMPONENT,GL_FLOAT,depth); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> depth[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>; dx1=dx-<span class="hljs-number"><span class="hljs-number">10</span></span>*cos(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)-<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; dy1=-dy+<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)-<span class="hljs-number"><span class="hljs-number">10</span></span>*cos(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dx1&lt;winwid-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dx1&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy1&lt;winhei-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy1&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)) glReadPixels(dx1,dy1,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,GL_DEPTH_COMPONENT,GL_FLOAT,depth+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> depth[<span class="hljs-number"><span class="hljs-number">1</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>; dx2=dx-<span class="hljs-number"><span class="hljs-number">10</span></span>*cos(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; dy2=-dy+<span class="hljs-number"><span class="hljs-number">10</span></span>*sin(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+<span class="hljs-number"><span class="hljs-number">10</span></span>*cos(Pi*betta/<span class="hljs-number"><span class="hljs-number">180</span></span>)+winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dx2&lt;winwid-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dx2&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy2&lt;winhei-<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;&amp;(dy2&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>)) glReadPixels(dx2,dy2,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,GL_DEPTH_COMPONENT,GL_FLOAT,depth+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> depth[<span class="hljs-number"><span class="hljs-number">2</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ if(dx&gt;winwid/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>) dx=-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dx&lt;-winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>) dx=winwid/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dy&lt;-winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>) dy=winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dy&gt;winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>) dy=-winhei/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ glColor3f(0.8f,0.0f,0.8f); glLoadIdentity(); glTranslatef(dx,dy,0.0f); glRotatef(betta,0.0f,0.0f,1.0f); glBegin(GL_TRIANGLES); glVertex3f( -10.0f,-10.0f, 1.0f); glVertex3f(-10.0f,10.0f, 1.0f); glVertex3f(0.0f,0.0f, 1.0f); if (fl2==1){ glVertex3f( -10.0f,-3.0f, 1.0f); glVertex3f(-10.0f,3.0f, 1.0f); glVertex3f(-15.0f,0.0f, 1.0f); } glEnd(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> - /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((depth[<span class="hljs-number"><span class="hljs-number">0</span></span>]!=<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-params"><span class="hljs-params">||</span></span>(depth[<span class="hljs-number"><span class="hljs-number">1</span></span>]!=<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-params"><span class="hljs-params">||</span></span>(depth[<span class="hljs-number"><span class="hljs-number">2</span></span>]!=<span class="hljs-number"><span class="hljs-number">1</span></span>)) game_end=<span class="hljs-number"><span class="hljs-number">1</span></span>; } void display() { glClearDepth( <span class="hljs-number"><span class="hljs-number">1.0</span></span>f ); glClear(GL_COLOR_BUFFER_BIT <span class="hljs-params"><span class="hljs-params">| GL_DEPTH_BUFFER_BIT); aster_draw(); draw_ship(); shoot(); glutSwapBuffers(); } void Timer(int) { acsel--; </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params">(speed&gt;10) speed=10; </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (fl1==1) {angle=betta;fl1=0;} </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> (acsel==0) {fl2=0;} dx=dx+speed*cos(Pi*angle/180.0); dy=dy+speed*sin(Pi*angle/180.0); </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params">(speed&gt;0)speed=speed-0.1; </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">else</span></span></span><span class="hljs-params"> speed=0; display(); </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params">(game_end==0) glutTimerFunc(50,Timer,0); } void Initialize() { dx=0; dy=0; vecb.empty(); angle=betta=speed=0; glClearColor(0, 0, 0.0, 1.0); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(-winwid/2, winwid/2, winhei/2, -winhei/2, -1, 1); glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST); glDepthFunc( GL_LEQUAL ); float depth[5]; glClearDepth( 1.0f ); //     glClear(GL_COLOR_BUFFER_BIT |</span></span> GL_DEPTH_BUFFER_BIT); asteroidsinit(); glutTimerFunc(<span class="hljs-number"><span class="hljs-number">500</span></span>,Timer,<span class="hljs-number"><span class="hljs-number">0</span></span>); } void keyboard(unsigned char key,int x,int y) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==<span class="hljs-string"><span class="hljs-string">'w'</span></span>) {fl1=<span class="hljs-number"><span class="hljs-number">1</span></span>;speed++;fl2=<span class="hljs-number"><span class="hljs-number">1</span></span>;acsel=<span class="hljs-number"><span class="hljs-number">10</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==<span class="hljs-string"><span class="hljs-string">'d'</span></span>) {betta+=<span class="hljs-number"><span class="hljs-number">7</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==<span class="hljs-string"><span class="hljs-string">'a'</span></span>) betta-=<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==<span class="hljs-string"><span class="hljs-string">' '</span></span>) {bullet b1;vecb.push_back(b1);} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key==<span class="hljs-string"><span class="hljs-string">'r'</span></span>) {<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(game_end==<span class="hljs-number"><span class="hljs-number">1</span></span>) {game_end=<span class="hljs-number"><span class="hljs-number">0</span></span>;Initialize();}} } int main(int argc, char **argv)/<span class="hljs-regexp"><span class="hljs-regexp">/  { glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DEPTH |GLUT_DOUBLE | GLUT_RGB); glutInitWindowSize(winwid, winhei); glutInitWindowPosition(200, 200); glutCreateWindow("Powder Toy"); Initialize(); glutDisplayFunc(display); glutKeyboardFunc(keyboard); glutMainLoop(); }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">game.cpp</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"game.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"logic.h"</span></span> Game::Game(unsigned width, unsigned height) : _asteroids(std::vector&lt;AsteroidFamily *&gt;()), _shots(std::vector&lt;Shot *&gt;()), _booms(std::vector&lt;Boom *&gt;()), _score(<span class="hljs-number"><span class="hljs-number">0</span></span>), _livesBonus(<span class="hljs-number"><span class="hljs-number">10000</span></span>), _level(<span class="hljs-number"><span class="hljs-number">0</span></span>), _isAsteroidsEmpty(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), _gameOver(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), _playerPoints(new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">3</span></span>)), _shotsPoints(new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">4</span></span>)), _boomPoints(new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)), _lastTimepoint(std::chrono::high_resolution_clock::now()), _lastShotTimepoint(std::chrono::high_resolution_clock::now()), _gameOverTimepoint(std::chrono::high_resolution_clock::now()), _timeMultiplier(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f), _width(width), _height(height), _aspectRatio((float)width / (float)height), _render(new GL(&amp;_aspectRatio, &amp;_halfWidth, &amp;_halfHeight)), _controls(new Controls(&amp;_width, &amp;_height, &amp;_halfWidth, &amp;_halfHeight)) { _halfHeight = GAME_HEIGHT; _halfWidth = _aspectRatio * _halfHeight; _playerPoints = new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">3</span></span>); (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.6</span></span>f; (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.6</span></span>f; (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.6</span></span>f; (*_playerPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; _shotsPoints = new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">4</span></span>); (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">3</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.02</span></span>f; (*_shotsPoints)[<span class="hljs-number"><span class="hljs-number">3</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.02</span></span>f; _boomPoints = new std::vector&lt;Point&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>); (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.1</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">0</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.1</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">1</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.4</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.1</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">2</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.2</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">3</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">3</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.4</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">4</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.2</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">4</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.1</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">5</span></span>].x = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">5</span></span>].y = -<span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">6</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.1</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">6</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.2</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">7</span></span>].x = -<span class="hljs-number"><span class="hljs-number">0.5</span></span>f; (*_boomPoints)[<span class="hljs-number"><span class="hljs-number">7</span></span>].y = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; Shot::SetStaticPoints(_shotsPoints); Boom::SetStaticPoints(_boomPoints); Random::Init(&amp;_halfWidth, &amp;_halfHeight); _player = new Player(_playerPoints, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); } Game::~Game() { delete _player; delete _render; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Shot *item : _shots) delete item; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Boom *item : _booms) delete item; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AsteroidFamily *item : _asteroids) delete item; delete _playerPoints; delete _shotsPoints; delete _boomPoints; } void Game::Refresh() { _controls-&gt;Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_score &gt;= _livesBonus) { _livesBonus += <span class="hljs-number"><span class="hljs-number">10000</span></span>; _player-&gt;SetLives(_player-&gt;GetLives() + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isAsteroidsEmpty) { _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AsteroidFamily *item : _asteroids) delete item; _asteroids.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (_level + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>; ++i) _asteroids.push_back(Random::GenerateAsteroidFamily()); _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; std::chrono::high_resolution_clock::time_point now = std::chrono::high_resolution_clock::now(); auto time_span = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(now - _lastTimepoint).count(); _timeMultiplier = (float)time_span / <span class="hljs-number"><span class="hljs-number">16666666.67</span></span>f; _lastTimepoint = now; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_controls-&gt;GetHyperspace()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_gameOver) { Random::ChangePlayerCoords(_player); _controls-&gt;SetHyperspace(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _gameOverTimepoint).count() &gt;= GAMEOVER_SCORE_TIME) { _player-&gt;SetCoord(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); _player-&gt;SetAngle(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f); _player-&gt;SetLives(PLAYER_DEFAULT_LIVES); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AsteroidFamily *item : _asteroids) delete item; _asteroids.clear(); _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _score = <span class="hljs-number"><span class="hljs-number">0</span></span>; _level = <span class="hljs-number"><span class="hljs-number">0</span></span>; _livesBonus = <span class="hljs-number"><span class="hljs-number">10000</span></span>; _gameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _controls-&gt;SetHyperspace(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_player-&gt;GetIsGhost() &amp;&amp; !_gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_player-&gt;GetIsRendering()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _player-&gt;GetDeadTime()).count() &gt;= PLAYER_BLACKOUT_TIME) { _player-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _player-&gt;GetDeadTime()).count() &gt;= PLAYER_GHOST_TIME) { _player-&gt;SetIsGhost(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_player-&gt;GetLives() &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !_gameOver) { _gameOver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _gameOverTimepoint = now; _player-&gt;SetIsGhost(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); _player-&gt;Stop(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_player-&gt;GetIsRendering() &amp;&amp; !_gameOver) { RefreshObjectCoord(_player); _player-&gt;Refresh(_controls-&gt;GetAngle(), _controls-&gt;GetAcceleration()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_controls-&gt;GetShoot()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now - _lastShotTimepoint).count() &gt;= NEXT_SHOT_TIME) { _shots.push_back(_player-&gt;GenerateShot()); _lastShotTimepoint = now; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto it = _shots.begin(); it != _shots.end();) { RefreshObjectCoord(*it); (*it)-&gt;Refresh(_timeMultiplier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*it)-&gt;GetDistance() &gt;= std::min(_halfHeight, _halfWidth) * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1.2</span></span>f) { delete(*it); it = _shots.erase(it); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++it; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AsteroidFamily *item : _asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetLarge()-&gt;GetIsRendering()) { _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshObjectCoord(item-&gt;GetLarge()); item-&gt;GetLarge()-&gt;Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_player-&gt;GetIsGhost()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCollision(_player, item-&gt;GetLarge())) { item-&gt;DestroyLarge(); _score += SCORE_LARGE; ProcessCollision(_player, item-&gt;GetLarge()); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetLarge()-&gt;GetIsRendering()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto it = _shots.begin(); it != _shots.end();) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCollision(*it, item-&gt;GetLarge())) { delete(*it); it = _shots.erase(it); item-&gt;DestroyLarge(); _booms.push_back(new Boom(item-&gt;GetLarge()-&gt;GetCoord().x, item-&gt;GetLarge()-&gt;GetCoord().y)); _score += SCORE_LARGE; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++it; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetFirstSmall()-&gt;GetIsRendering()) { _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshObjectCoord(item-&gt;GetFirstSmall()); item-&gt;GetFirstSmall()-&gt;Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_player-&gt;GetIsGhost()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCollision(_player, item-&gt;GetFirstSmall())) { item-&gt;GetFirstSmall()-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _score += SCORE_SMALL; ProcessCollision(_player, item-&gt;GetFirstSmall()); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetSecondSmall()-&gt;GetIsRendering()) { _isAsteroidsEmpty = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshObjectCoord(item-&gt;GetSecondSmall()); item-&gt;GetSecondSmall()-&gt;Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_player-&gt;GetIsGhost()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCollision(_player, item-&gt;GetSecondSmall())) { item-&gt;GetSecondSmall()-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _score += SCORE_SMALL; ProcessCollision(_player, item-&gt;GetSecondSmall()); } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto it = _shots.begin(); it != _shots.end();) { <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> isFirstCollision = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, isSecondCollision = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetFirstSmall()-&gt;GetIsRendering()) isFirstCollision = isCollision(*it, item-&gt;GetFirstSmall()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetSecondSmall()-&gt;GetIsRendering()) isSecondCollision = isCollision(*it, item-&gt;GetSecondSmall()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFirstCollision || isSecondCollision) { delete(*it); it = _shots.erase(it); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFirstCollision) { item-&gt;GetFirstSmall()-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _booms.push_back(new Boom(item-&gt;GetFirstSmall()-&gt;GetCoord().x, item-&gt;GetFirstSmall()-&gt;GetCoord().y)); _score += SCORE_SMALL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isSecondCollision) { item-&gt;GetSecondSmall()-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); _booms.push_back(new Boom(item-&gt;GetSecondSmall()-&gt;GetCoord().x, item-&gt;GetSecondSmall()-&gt;GetCoord().y)); _score += SCORE_SMALL; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++it; } } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto it = _booms.begin(); it != _booms.end();) { (*it)-&gt;Refresh(_timeMultiplier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*it)-&gt;GetDuration() &gt;= BOOM_MAX_DURATION) { delete(*it); it = _booms.erase(it); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++it; } } } void Game::RefreshObjectCoord(Object *object) { object-&gt;SetCoord(object-&gt;GetCoord().x + object-&gt;GetVelocity().x * _timeMultiplier, object-&gt;GetCoord().y + object-&gt;GetVelocity().y * _timeMultiplier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object-&gt;GetCoord().x &lt;= -_halfWidth) object-&gt;SetCoord(object-&gt;GetCoord().x + _halfWidth * <span class="hljs-number"><span class="hljs-number">2</span></span>, object-&gt;GetCoord().y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object-&gt;GetCoord().x &gt;= _halfWidth) object-&gt;SetCoord(object-&gt;GetCoord().x - _halfWidth * <span class="hljs-number"><span class="hljs-number">2</span></span>, object-&gt;GetCoord().y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object-&gt;GetCoord().y &lt;= -_halfHeight) object-&gt;SetCoord(object-&gt;GetCoord().x, object-&gt;GetCoord().y + _halfHeight * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object-&gt;GetCoord().y &gt;= _halfHeight) object-&gt;SetCoord(object-&gt;GetCoord().x, object-&gt;GetCoord().y - _halfHeight * <span class="hljs-number"><span class="hljs-number">2</span></span>); } void Game::Render() { Refresh(); _render-&gt;Clear(); _render-&gt;RenderControls(_controls); _render-&gt;SetColor(OBJECTS_COLOR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_player-&gt;GetIsRendering() &amp;&amp; !_gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_player-&gt;GetIsGhost()) _render-&gt;SetColor(PLAYER_GHOST_COLOR); _render-&gt;RenderPlayer(_player); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_gameOver) _render-&gt;SetColor(OBJECTS_GAMEOVER_COLOR); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _render-&gt;SetColor(OBJECTS_COLOR); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AsteroidFamily *item : _asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetLarge()-&gt;GetIsRendering()) { _render-&gt;RenderAsteroid(item-&gt;GetLarge()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetFirstSmall()-&gt;GetIsRendering()) { _render-&gt;RenderAsteroid(item-&gt;GetFirstSmall()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;GetSecondSmall()-&gt;GetIsRendering()) { _render-&gt;RenderAsteroid(item-&gt;GetSecondSmall()); } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Shot *item : _shots) { _render-&gt;RenderShot(item); } _render-&gt;SetColor(BOOM_COLOR); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Boom *item : _booms) { _render-&gt;RenderBoom(item); } _render-&gt;SetColor(TEXT_COLOR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_gameOver) { _render-&gt;RenderScoreAndLives(_score, _player-&gt;GetLives()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _render-&gt;RenderGameOver(_score); } } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> Game::isCollision(Player *player, Asteroid *asteroid) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::vector&lt;Point&gt; &amp;playerPoints = *(player-&gt;GetPoints()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::vector&lt;Point&gt; &amp;asteroidPoints = *(asteroid-&gt;GetPoints()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TestAABB(player, asteroid)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; playerPoints.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; asteroidPoints.size(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Logic::IsLinesCross(playerPoints[i], playerPoints[(i + <span class="hljs-number"><span class="hljs-number">1</span></span> == playerPoints.size()) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : i + <span class="hljs-number"><span class="hljs-number">1</span></span>], asteroidPoints[j], asteroidPoints[(j + <span class="hljs-number"><span class="hljs-number">1</span></span> == asteroidPoints.size()) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : j + <span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Logic::IsInside(asteroidPoints, playerPoints[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> Game::isCollision(Shot *shot, Asteroid *asteroid) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Logic::IsInside(*(asteroid-&gt;GetPoints()), shot-&gt;GetCoord())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> Game::TestAABB(Player *player, Asteroid *asteroid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (player-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; asteroid-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; player-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; asteroid-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; player-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt; asteroid-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; player-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">3</span></span>] &gt; asteroid-&gt;GetSizes()[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } void Game::ProcessCollision(Player *player, Asteroid *asteroid) { _booms.push_back(new Boom(asteroid-&gt;GetCoord().x, asteroid-&gt;GetCoord().y)); player-&gt;SetIsRendering(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); player-&gt;SetIsGhost(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); player-&gt;SetLives(player-&gt;GetLives() - <span class="hljs-number"><span class="hljs-number">1</span></span>); player-&gt;SetCoord(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); player-&gt;SetDeadTime(std::chrono::high_resolution_clock::now()); } void Game::Resize(float width, float height) { _aspectRatio = (float)width / (float)height; _halfWidth = _aspectRatio * _halfHeight; _width = width; _height = height; _render-&gt;Resize(); } Controls *Game::GetControls() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _controls; } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> Game::GetIsPaused() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _isPaused; } void Game::SetIsPaused(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> isPaused) { _isPaused = isPaused; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Game.cpp</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;Game.h&gt; #include &lt;Controls.h&gt; #include &lt;tuple&gt; Game::Game() { isLevelRunning = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ResetLogic(); RequestRestart(); Renderer::InitInternals(); Controls::Init(); Score::Init(); } Game&amp; Game::Get() { static Game instance; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } void Game::Restart() { objects.clear(); Score::OnRestart(); ResetLogic(); GameObject::Create&lt;Ship&gt;(); SpawnAsteroids(Constant::asteroidTargetCount); } //  ,       (<span class="hljs-literal"><span class="hljs-literal">false</span></span> -  ) bool Game::IsLevelRunning(float dt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wantRestart) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(restartTimer &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isLevelRunning) { Restart(); wantRestart = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { restartTimer -= dt; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isLevelRunning; } void Game::Update() { float deltaTime = timer.Tick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsLevelRunning(deltaTime)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto&amp; go : objects) { go-&gt;Update(deltaTime); } DetectCollisions(deltaTime); DestroyRequestedObjects(); //     } Renderer::Draw(); } void Game::OnGLInit() { Renderer::InitGLContext(); } void Game::OnResolutionChange(int w, int h) { Renderer::OnResolutionChange(w, h); Controls::Resize(); Score::Resize(); } GameObject&amp; Game::AddGameObject(std::unique_ptr&lt;GameObject&gt; obj) { objects.push_back(std::move(obj)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *objects.back().get(); } void Game::DestroyRequestedObjects() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto i = objects.begin(); i != objects.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>();) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*i)-&gt;isDestructionRequested()) { i = objects.erase(i); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++i; } } } void Game::DetectCollisions(float dt) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto a = objects.begin(); a != objects.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++a) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto b = std::<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(a); b != objects.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++b) { //    GameObject&amp; ra = **a; GameObject&amp; rb = **b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CollisionMask(ra, rb)) { //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DetectCollision(ra, rb, dt)) { //  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RefineCollision(ra, rb, dt)) { //  ra.OnCollision(rb); rb.OnCollision(ra); } } } } } } bool Game::CollisionMask(const GameObject&amp; a, const GameObject&amp; b) { //      ,       (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a.isDestructionRequested() || b.isDestructionRequested()) &amp;&amp; //          ,   <span class="hljs-literal"><span class="hljs-literal">false</span></span> (a.CollisionMask(b.getStaticType()) || b.CollisionMask(a.getStaticType())); } //    ,    //      ,       dt bool Game::DetectCollision(const GameObject&amp; a, const GameObject&amp; b, float dt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Constant::continuousCollisions) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a.getPosition() - b.getPosition()).getLength() &lt; a.getRadius() + b.getRadius() + (a.getVelocity().getLength() + b.getVelocity().getLength()) * dt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a.getPosition() - b.getPosition()).getLength() &lt; a.getRadius() + b.getRadius(); } } bool Game::RefineCollision(const GameObject&amp; a, const GameObject&amp; b, float dt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Constant::refineCollisions) { const Model&amp; am = a.getModel(); const std::vector&lt;GLfloat&gt;&amp; av = am.getTransformed(); const std::vector&lt;GLubyte&gt;&amp; ai = am.getIndices(); const Vec2 aBackVel = a.getVelocity() * <span class="hljs-number"><span class="hljs-number">-1</span></span>; const Model&amp; bm = b.getModel(); const std::vector&lt;GLfloat&gt;&amp; bv = bm.getTransformed(); const std::vector&lt;GLubyte&gt;&amp; bi = bm.getIndices(); const Vec2 bBackVel = b.getVelocity() * <span class="hljs-number"><span class="hljs-number">-1</span></span>; //    ,      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ai.size(); i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { Vec2 a0(i, av, ai); Vec2 at = Vec2(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, av, ai) - a0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bi.size(); j += <span class="hljs-number"><span class="hljs-number">2</span></span>) { Vec2 b0(j, bv, bi); Vec2 bt = Vec2(j + <span class="hljs-number"><span class="hljs-number">1</span></span>, bv, bi) - b0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Constant::continuousCollisions ? // ,       t0, //     t0+dt,      - MovingSegmentCollision(a0, at, aBackVel, b0, bt, bBackVel, dt) : SegmentCollision(a0, at, b0, bt)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } bool Game::SegmentCollision(Vec2 p, Vec2 r, Vec2 q, Vec2 s) { //http://stackoverflow.com/a/<span class="hljs-number"><span class="hljs-number">565282</span></span>/<span class="hljs-number"><span class="hljs-number">2502024</span></span> float det = Vec2::CrossProd2D(r, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fabs(det) &gt; Constant::smallNumber) { Vec2 diff = q - p; float f = Vec2::CrossProd2D(diff, s / det); float g = Vec2::CrossProd2D(diff, r / det); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; f &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; g &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; g &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } bool Game::MovingSegmentCollision(Vec2 p, Vec2 r, Vec2 vp, Vec2 q, Vec2 s, Vec2 vq, float dt) { float det = Vec2::CrossProd2D(r, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fabs(det) &gt; Constant::smallNumber) { const Vec2 v = vq - vp; const Vec2 diff = q - p; //    : //q = q0 + v*t, t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>, dt] //(vx * sy - vy * sx) * t + ((qx - px) * sy - (qy - py) * sx) //  f  g  SegmentCollision    t. //    t  [<span class="hljs-number"><span class="hljs-number">0</span></span>, dt],    t, // f  g    [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]. ..  <span class="hljs-number"><span class="hljs-number">3</span></span>    t auto getInequation = [=](Vec2 dir)-&gt;std::tuple&lt;float, float&gt; { //<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= a*t + cp &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> float cp = Vec2::CrossProd2D(diff, dir / det); float a = Vec2::CrossProd2D(v, dir / det); float left = -cp, right = <span class="hljs-number"><span class="hljs-number">1</span></span> - cp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fabs(a) &lt; Constant::smallNumber) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cp &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; cp &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { left = <span class="hljs-number"><span class="hljs-number">0</span></span>; right = dt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { left = dt + <span class="hljs-number"><span class="hljs-number">1</span></span>; right = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { left /= a; right /= a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) std::swap(left, right); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_tuple(left, right); }; float ls, rs, lr, rr; //ls &lt;= t &lt;= rs std::tie(ls, rs) = getInequation(s); //lr &lt;= t &lt;= rr std::tie(lr, rr) = getInequation(r); //  <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= t &lt;= dt float mx = std::<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span>f, std::<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(ls, lr)); float mn = std::<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(dt, std::<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(rs, rr)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mx &lt;= mn; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } void Game::RequestRestart(float t) { wantRestart = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; restartTimer = t; } void Game::Pause() { isLevelRunning = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Controls::onPause(); } void Game::Resume() { isLevelRunning = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Controls::onResume(); timer.Tick(); } void Game::SetPlayerPos(const Ship&amp; player) { playerPos = player.getPosition(); } Vec2 Game::GetPlayerPos() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> playerPos; } void Game::AddPoints(int pointsToAdd) { Score::AddPoints(pointsToAdd); } void Game::DecAsteroidCount(const Asteroid&amp; a) { asteroidCount<span class="hljs-comment"><span class="hljs-comment">--; if(asteroidCount == Constant::asteroidUfoCount * 2 &amp;&amp; !isUfoPresent) { GameObject::Create&lt;UFO&gt;(GetUfoSpawn()); } if(asteroidCount &lt;= Constant::asteroidRespawnCount * 2) { SpawnAsteroids(Constant::asteroidTargetCount - Constant::asteroidRespawnCount); } } //  2, .. asteroidCount      void Game::IncAsteroidCount(const Asteroid&amp; a) { asteroidCount += 2; } void Game::ResetLogic() { asteroidCount = 0; isUfoPresent = false; } void Game::SpawnAsteroids(int n) { for(int i = 0; i &lt; n; ++i) { GameObject::Create&lt;Asteroid&gt;(GetSpawnPosition()); } } //  ,      (    ) Transform Game::GetSpawnPosition() { std::uniform_real_distribution&lt;float&gt; zone(-Constant::asteroidSpawnZone, Constant::asteroidSpawnZone); Vec2 pos(Constant::worldRatio + 0.2, 1.2); if(fabs(playerPos.x) &gt; Constant::asteroidSpawnZone &amp;&amp; fabs(playerPos.y) &lt; Constant::asteroidSpawnZone) { pos.y = zone(Random::generator); } else if(fabs(playerPos.x) &lt; Constant::asteroidSpawnZone &amp;&amp; fabs(playerPos.y) &gt; Constant::asteroidSpawnZone) { pos.x = zone(Random::generator); } else { if(Random::flipCoin()) { pos.x = zone(Random::generator); } else { pos.y = zone(Random::generator); } } return Transform(pos); } Transform Game::GetUfoSpawn() { std::uniform_real_distribution&lt;float&gt; zone(-Constant::ufoZone, Constant::ufoZone); return Transform((Constant::worldRatio + 0.12) * (playerPos.x &gt; 0 ? -1 : 1), zone(Random::generator)); } void Game::OnUfoCreated(const UFO&amp; u) { isUfoPresent = true; } void Game::OnUfoDestroyed(const UFO&amp; u) { isUfoPresent = false; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">model_handler.cpp</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"model_handler.h"</span></span> #include &lt;time.h&gt; #include &lt;math.h&gt; #include &lt;cstdlib&gt; using namespace model; namespace { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double tickTime = <span class="hljs-number"><span class="hljs-number">40.00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsigned int asteroidNumber = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float projectileSpeed = <span class="hljs-number"><span class="hljs-number">10.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float smallAsteroidRadiusK = <span class="hljs-number"><span class="hljs-number">1.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float minLargeAsteroidRadius = <span class="hljs-number"><span class="hljs-number">35.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float maxLargeAsteroidRadius = minLargeAsteroidRadius * smallAsteroidRadiusK - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float minAsteroidSpeed = <span class="hljs-number"><span class="hljs-number">1.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float maxAsteroidSpeed = <span class="hljs-number"><span class="hljs-number">6.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float explosionK = <span class="hljs-number"><span class="hljs-number">50000.0</span></span>; } ModelHandler::ModelHandler(float worldWidth, float worldHeight): _isGameOver(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), _worldWidth(worldWidth), _worldHeight(worldHeight), _tickTime(<span class="hljs-number"><span class="hljs-number">0</span></span>), _ship(ShipPtr(new Ship(Point(worldWidth / <span class="hljs-number"><span class="hljs-number">2.0</span></span>, worldHeight / <span class="hljs-number"><span class="hljs-number">2.0</span></span>)))) { srand(time(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } void ModelHandler::newGame() { _asteroids.clear(); _projectiles.clear(); _ship.reset(new Ship(Point(_worldWidth / <span class="hljs-number"><span class="hljs-number">2.0</span></span>, _worldHeight / <span class="hljs-number"><span class="hljs-number">2.0</span></span>))); _isGameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> ModelHandler::isGameOver() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _isGameOver; } void ModelHandler::update(double deltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this-&gt;isGameOver()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _tickTime += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_tickTime &gt; tickTime) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_asteroids.size() &lt; ::asteroidNumber) { this-&gt;addAsteroid(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ObjectPtr&amp; obj: this-&gt;allObjects()) { obj-&gt;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(); } this-&gt;checkObjects(&amp;_asteroids); this-&gt;checkObjects(&amp;_projectiles); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this-&gt;withinBoundaries(_ship)) { this-&gt;removeShip(); } _tickTime -= tickTime; } } ShipPtr ModelHandler::ship() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ship; } void ModelHandler::removeShip() { _isGameOver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } void ModelHandler::removeAsteroid(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AsteroidPtr&amp; asteroid) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid-&gt;collisionRadius() &gt;= ::minLargeAsteroidRadius) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> model::Vector v1(asteroid-&gt;velocity() + model::Vector(-asteroid-&gt;velocity().y, asteroid-&gt;velocity().x)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> model::Vector v2(asteroid-&gt;velocity() + model::Vector(asteroid-&gt;velocity().y, -asteroid-&gt;velocity().x)); this-&gt;addAsteroid(asteroid, v1); this-&gt;addAsteroid(asteroid, v2); } _asteroids.remove(asteroid); } void ModelHandler::addAsteroid(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AsteroidPtr&amp; asteroid) { _asteroids.push_back(asteroid); } std::list&lt;AsteroidPtr&gt; ModelHandler::asteroids() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _asteroids; } std::list&lt;ProjectilePtr&gt; ModelHandler::projectiles() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _projectiles; } void ModelHandler::removeProjectile(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ProjectilePtr&amp; projectile) { _projectiles.remove(projectile); } void ModelHandler::addProjectile() { Vector projectileSpeed = _ship-&gt;direction() * ::projectileSpeed + ship()-&gt;velocity(); _projectiles.push_back(ProjectilePtr(new Projectile(_ship-&gt;point(), projectileSpeed))); } void ModelHandler::processHit(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ProjectilePtr&amp; projectile, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AsteroidPtr&amp; asteroid) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid-&gt;collisionRadius() &gt;= ::minLargeAsteroidRadius) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector ox = asteroid-&gt;velocity().normaVector(); Vector explosionVector(ox.y, -ox.x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ox * asteroid-&gt;velocity() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { explosionVector = explosionVector * (-<span class="hljs-number"><span class="hljs-number">1.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector v1(asteroid-&gt;velocity() + model::Vector(-asteroid-&gt;velocity().y, asteroid-&gt;velocity().x) + explosionVector * (-::explosionK / asteroid-&gt;mass())); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector v2(asteroid-&gt;velocity() + model::Vector(asteroid-&gt;velocity().y, -asteroid-&gt;velocity().x) + explosionVector * (::explosionK / asteroid-&gt;mass())); this-&gt;addAsteroid(asteroid, v1); this-&gt;addAsteroid(asteroid, v2); } _projectiles.remove(projectile); _asteroids.remove(asteroid); } std::list&lt;ObjectPtr&gt; ModelHandler::allObjects() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { std::list&lt;ObjectPtr&gt; objects; objects.insert(objects.end(), _asteroids.begin(), _asteroids.end()); objects.insert(objects.end(), _projectiles.begin(), _projectiles.end()); objects.push_back(_ship); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objects; } void ModelHandler::addAsteroid() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float r = common::rangeRand(::minLargeAsteroidRadius, ::maxLargeAsteroidRadius); Point point; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> isCorrect = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isCorrect) { point = randPoint(r); isCorrect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AsteroidPtr&amp; asteroid : _asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float d = model::distance(asteroid-&gt;point(), point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &lt; (asteroid-&gt;collisionRadius() + r)) { isCorrect = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float distToCenter = ::distance(point.x, point.y, _worldWidth / <span class="hljs-number"><span class="hljs-number">2.0</span></span>, _worldHeight / <span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float vx = (_worldWidth / <span class="hljs-number"><span class="hljs-number">2.0</span></span> - point.x) / distToCenter * common::rangeRand(::minAsteroidSpeed, ::maxAsteroidSpeed); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float vy = (_worldHeight / <span class="hljs-number"><span class="hljs-number">2.0</span></span> - point.y) / distToCenter * common::rangeRand(::minAsteroidSpeed, ::maxAsteroidSpeed); _asteroids.push_back(AsteroidPtr(new Asteroid(point, r, Vector(vx, vy)))); } void ModelHandler::addAsteroid(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AsteroidPtr&amp; oldAsteroid, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector&amp; newVelocity) { Point point = oldAsteroid-&gt;point(); point.<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(newVelocity.normaVector() * oldAsteroid-&gt;collisionRadius()); _asteroids.push_back(AsteroidPtr(new Asteroid(point, oldAsteroid-&gt;collisionRadius() / ::smallAsteroidRadiusK, newVelocity))); } Point ModelHandler::randPoint(float r) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { float x = <span class="hljs-number"><span class="hljs-number">0</span></span>; float y = <span class="hljs-number"><span class="hljs-number">0</span></span>; switch (rand() % <span class="hljs-number"><span class="hljs-number">4</span></span>) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: x = common::rangeRand(<span class="hljs-number"><span class="hljs-number">0</span></span> - r, _worldWidth + r); y = <span class="hljs-number"><span class="hljs-number">0</span></span> - r; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-number"><span class="hljs-number">1</span></span>: x = common::rangeRand(<span class="hljs-number"><span class="hljs-number">0</span></span> - r, _worldWidth + r); y = _worldHeight - r; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-number"><span class="hljs-number">2</span></span>: x = <span class="hljs-number"><span class="hljs-number">0</span></span> - r; y = common::rangeRand(<span class="hljs-number"><span class="hljs-number">0</span></span> - r, _worldHeight + r); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case <span class="hljs-number"><span class="hljs-number">3</span></span>: x = _worldWidth + r; y = common::rangeRand(<span class="hljs-number"><span class="hljs-number">0</span></span> - r, _worldHeight + r); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point(x, y); } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> ModelHandler::withinBoundaries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectPtr&amp; obj) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (obj-&gt;x() &gt; (<span class="hljs-number"><span class="hljs-number">0</span></span> - _worldWidth * <span class="hljs-number"><span class="hljs-number">0.1</span></span>) &amp;&amp; obj-&gt;x() &lt; (_worldWidth * <span class="hljs-number"><span class="hljs-number">1.1</span></span>) &amp;&amp; obj-&gt;y() &gt; (<span class="hljs-number"><span class="hljs-number">0</span></span> - _worldHeight * <span class="hljs-number"><span class="hljs-number">0.1</span></span>) &amp;&amp; obj-&gt;y() &lt; (_worldHeight * <span class="hljs-number"><span class="hljs-number">1.1</span></span>)); } template&lt;class T&gt; void ModelHandler::checkObjects(std::list&lt;T&gt;* objects) { typename std::list&lt;T&gt;::iterator it = objects-&gt;begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it != objects-&gt;end()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this-&gt;withinBoundaries(*it)) { it = objects-&gt;erase(it++); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++it; } } }</code> </pre><br></div></div><br><br>   ,        .      .  ,      ?     ,     ,    . </div><p>Source: <a href="https://habr.com/ru/post/254009/">https://habr.com/ru/post/254009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253999/index.html">Docker and crutches in production</a></li>
<li><a href="../254001/index.html">In Berlin, the developers showed their vision of a smart car</a></li>
<li><a href="../254003/index.html">Security Analysis of Common Terminals</a></li>
<li><a href="../254005/index.html">We write the extension for Chrome "download audio recordings from Vkontakte"</a></li>
<li><a href="../254007/index.html">15 tips and tricks of the Chrome developer tools you need to know</a></li>
<li><a href="../254011/index.html">Recover Lost LVM Volume in XenServer</a></li>
<li><a href="../254015/index.html">Experience roentgenoscopy at home</a></li>
<li><a href="../254017/index.html">A hundred times the same thing</a></li>
<li><a href="../254021/index.html">Turn your Android phone into a network SQL database (MyMobileSQLServer - Utesov)</a></li>
<li><a href="../254023/index.html">Planets and the fourth dimension</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>