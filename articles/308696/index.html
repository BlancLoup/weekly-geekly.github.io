<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vector computing in JS, is there any sense when and how SIMD can be used in the browser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More and more, the field of application of the javascript programming language is moving away from the movement of buttons in the browser and backgrou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vector computing in JS, is there any sense when and how SIMD can be used in the browser</h1><div class="post__text post__text-html js-mediator-article"><p>  More and more, the field of application of the javascript programming language is moving away from the movement of buttons in the browser and background repainting in the direction of complex and voluminous web applications.  Already throughout the whole world, the WebGL technology is striding, which allows displaying three-dimensional scenes in the browser directly in the js language, and with it the tasks become more complex. </p><br><p>  The performance of user machines continues to grow, and with it the language acquires new expressive means to speed up computations.  And while WebAssembly is somewhere there in the distant and bright future, asm.js is stuck in a swamp and turned off the path, soon as part of es2015, now support JS for separate operations as a standard. </p><br><p>  All who are interested in what SIMD and vector calculus are, how to use them in js, as well as what their use gives - I ask for cat. </p><br><a name="habracut"></a><br><p>  <b>Deviation from the author:</b> you do not deja vu, this article is really a reloading of the previous one.  Unfortunately, then I did not put enough effort to get a quality article, and the tests were not suitable for anything, as a result - I got totally wrong conclusions, which I rightly received criticism for.  "Habr cake and every demand here is not a ride," I rejoiced, I figured that my article is still one of the few that pops up on SIMD JS requests and it would be wrong to distribute incorrect information, and even poor quality.  In this article I try to correct that ruthlessly hid and removed as a bad dream and an instructive lesson about the ratio of time spent on an article to its quality. </p><br><h3>  Theory </h3><br><p>  Suppose you need to perform some simple operation with each element from the array.  Take a sum with a constant C, write an example in C </p><br><pre><code class="hljs matlab">int arr[<span class="hljs-number"><span class="hljs-number">16</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; const c = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + c; }</code> </pre> <br><p>  Doggy people can try to optimize this example a little by writing something like: </p><br><pre> <code class="hljs matlab">int arr[<span class="hljs-number"><span class="hljs-number">16</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; const c = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> += <span class="hljs-number"><span class="hljs-number">4</span></span>) { arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + c; arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] = arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] + c; arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>] = arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>] + c arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] = arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] + c; }</code> </pre> <br><p>  Optimization is dubious, but, in fact, work.  The reason for this is not that we do the operation i = i + 1 much less often;  (after all, it all the same happens when taking the index), and the fact that the processor in this case can load and perform operations with large overlapping on each other in the pipeline, as long as the operations do not depend on each other, which allows it to perform internal operations, up to performing these operations simultaneously and batch loading the next part of the array. </p><br><p>  The problem is that he can make these optimizations, and he may not.  We cannot explicitly influence this, but the lining is still preserved.  And if the sum is calculated quickly, then some square root is already performed for a sufficiently noticeable time so that there is a desire to force the processor to perform this operation simultaneously for several numbers. </p><br><p>  Something like this was thought many years ago (in the 70s) somewhere in the bowels of Texas Instruments and CDC, having made the first vector super-computers.  However, before them, a certain Michael Flynn proposed his taxonomy (classification) of computers, one of which was SIMD.  Unfortunately, the thread of history is lost on this, but we have not gathered here for this. </p><br><p>  Thus, in the 70s of the last century, the first processors appeared, which allowed counting several similar operations on numbers at a time.  Later it was dragged to almost all in the form of an extended set of instructions. </p><br><p>  Graphically, the classic architecture is as follows: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6ce/bd9/35f/6cebd935f44642e38ad4b7065489af00.png" alt="image"></div><br><p>  We need to add 4 pairs of numbers, so we have to call the add instruction 4 times in the processor. </p><br><p>  The vector operation looks like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/806/293/f8f/806293f8f2624f33aacb87bd1ec91d02.png" alt="image"></div><br><p>  When we need to add 4 pairs of numbers, we simply call one instruction, which adds them in one measure. </p><br><p>  A small remark about the "vector operation" and SIMD-operation.  The fact is that SIMD is a more general concept, implying that at one and the same moment of time performing one or several identical operations on different data.  In CUDA, at each time point, the threads perform the same operation on different data, but these operations are performed as many threads are available in the video card.  Vector arithmetic implies that exactly one operation is performed, and, in fact, it is simply performed on two extended data, which are several of themselves in orderly numbers in one cell.  Thus, vector operations are included as a subset in SIMD operations, but ES2017 speaks about vector arithmetic, I don‚Äôt know why they decided to generalize this way, then we will consider these two concepts to be the same in this article. </p><br><p>  So, it turns out, can we increase the performance of our js applications 4 times?  (Extended) Nuuu not really.  But first, take a look at how this is done on C (gcc) </p><br><div class="spoiler">  <b class="spoiler_title">C and assembler here.</b>  <b class="spoiler_title">Yes, in the article about js</b> <div class="spoiler_text"><p>  Scalar example </p><br><pre> <code class="hljs swift">void main() { int a[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> }; int b = <span class="hljs-number"><span class="hljs-number">3</span></span>; int <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = a[<span class="hljs-number"><span class="hljs-number">0</span></span>] + b; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] = a[<span class="hljs-number"><span class="hljs-number">1</span></span>] + b; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] = a[<span class="hljs-number"><span class="hljs-number">2</span></span>] + b; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] = a[<span class="hljs-number"><span class="hljs-number">3</span></span>] + b; }</code> </pre> <br><p>  Its vector analogue is: </p><br><pre> <code class="hljs go">#include &lt;xmmintrin.h&gt; extern void printv(__m128 m); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { __m128 m = _mm_set_ps(<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); __m128 one = _mm_set1_ps(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>); printv(_mm_add_ps(m, one)); <span class="hljs-comment"><span class="hljs-comment">// Multiply by one (nop) return 0; }</span></span></code> </pre> <br><p>  (Examples taken from the resource <a href="http://www.liranuna.com/sse-intrinsics-optimizations-in-popular-compilers/">liranuna.com</a> ) </p><br><p>  The first option will be something like asm in asm: </p><br><pre> <code class="hljs perl">main: .LFB<span class="hljs-number"><span class="hljs-number">0</span></span>: .cfi_startproc pushq %rbp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">16</span></span> .cfi_offset <span class="hljs-number"><span class="hljs-number">6</span></span>, -<span class="hljs-number"><span class="hljs-number">16</span></span> movq %rsp, %rbp .cfi_def_cfa_register <span class="hljs-number"><span class="hljs-number">6</span></span> subq $64, %rsp movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, -<span class="hljs-number"><span class="hljs-number">8</span></span>(%rbp) xorl %eax, %eax movl $1, -<span class="hljs-number"><span class="hljs-number">48</span></span>(%rbp) movl $3, -<span class="hljs-number"><span class="hljs-number">44</span></span>(%rbp) movl $5, -<span class="hljs-number"><span class="hljs-number">40</span></span>(%rbp) movl $7, -<span class="hljs-number"><span class="hljs-number">36</span></span>(%rbp) movl $3, -<span class="hljs-number"><span class="hljs-number">52</span></span>(%rbp) movl -<span class="hljs-number"><span class="hljs-number">48</span></span>(%rbp), %edx movl -<span class="hljs-number"><span class="hljs-number">52</span></span>(%rbp), %eax addl %edx, %eax movl %eax, -<span class="hljs-number"><span class="hljs-number">32</span></span>(%rbp) movl -<span class="hljs-number"><span class="hljs-number">44</span></span>(%rbp), %edx movl -<span class="hljs-number"><span class="hljs-number">52</span></span>(%rbp), %eax addl %edx, %eax movl %eax, -<span class="hljs-number"><span class="hljs-number">28</span></span>(%rbp) movl -<span class="hljs-number"><span class="hljs-number">40</span></span>(%rbp), %edx movl -<span class="hljs-number"><span class="hljs-number">52</span></span>(%rbp), %eax addl %edx, %eax movl %eax, -<span class="hljs-number"><span class="hljs-number">24</span></span>(%rbp) movl -<span class="hljs-number"><span class="hljs-number">36</span></span>(%rbp), %edx movl -<span class="hljs-number"><span class="hljs-number">52</span></span>(%rbp), %eax addl %edx, %eax movl %eax, -<span class="hljs-number"><span class="hljs-number">20</span></span>(%rbp) nop movq -<span class="hljs-number"><span class="hljs-number">8</span></span>(%rbp), %rax xorq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax je .L2 call __stack_chk_fail</code> </pre> <br><p>  His vector friend will be something like: </p><br><pre> <code class="hljs mel"> movss xmm0, DWORD PTR __real@c0800000 movss xmm2, DWORD PTR __real@c0400000 movss xmm3, DWORD PTR __real@c0000000 movss xmm1, DWORD PTR __real@bf800000 unpcklps xmm3, xmm0 xorps xmm0, xmm0 unpcklps xmm1, xmm2 unpcklps xmm1, xmm3 movaps XMMWORD PTR tv129[esp+<span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 movaps XMMWORD PTR _m$[esp+<span class="hljs-number"><span class="hljs-number">32</span></span>], xmm1 addps xmm0, xmm1</code> </pre><br><p>  What is there to pay attention to?  On the fact that the operation "add" (addps instruction) is really one, when in the first example there are 4 of them, while in the first example there are also many complex data transfers to and fro.  Indeed, in the dry residue instructions became less.  However, in x86, the execution time (as in the rest of CISC) is not limited, in theory, even a model of the whole world can be crammed into microcode.  It will be considered infinitely, but the instruction is one!  However, what is much more important for us right now is the xmm0-7 registers (0-15 in the 64-bit architecture. However, we are not talking about circuit design or even about assembler, we are not interested in such details).  These are special registers from the SSE extension (English Streaming SIMD Extensions, streaming SIMD processor expansion) of 128 bits, each of which can contain 4 single-precision floating point values ‚Äã‚Äã(32-bit float), as well as various combinations of signed and unsigned integer numbers of different digits.  It is over them that all SIMD instructions occur. </p><br><p>  This is important enough, as long as any operation implies that you first upload the data there in any way.  This is where the main limitation of this technology lies - loading this data is not very cheap, so mixed arithmetic (vector and scalar operations interspersed) will only result in large costs on the data train back and forth, hence all the algorithms for vector calculus are optimized so as to minimize points touch, which is not always easy. </p><br><p>  However, streaming processing is included here - performance increases even more due to the fact that DDR allows you to get from 2 (for ddr3 this is already 8) words in one memory access.  Of course, the processor will also try to resort to them in scalar calculations, but if you tell him clearly about this, it will be easier for him to understand what to download. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">How does it work inside, another pitfall and verilog in the article on js?</b>  <b class="spoiler_title">What's next?</b>  <b class="spoiler_title">Quantum mechanics?</b> <div class="spoiler_text"><p>  Inside each of the instructions looks like this: </p><br><pre> <code class="hljs pgsql">module adds( <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>] a, <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>] b, <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire[<span class="hljs-number"><span class="hljs-number">0</span></span>] size, // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> output reg[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>] c, <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire clk ); <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @ (posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (size) <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0: begin c[0:7] &lt;= a[0:7] + b[0:7]; c[8:15] &lt;= a[8:15] + b[8:15]; c[16:23] &lt;= a[16:23] + b[16:23]; c[24:31] &lt;= a[24:31] + b[24:31]; end 1'</span></span>b1: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> c[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>] &lt;= a[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>] + b[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>]; c[<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>] &lt;= a[<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>] + b[<span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br><p>  I will not give a real example for two reasons: firstly, they are all very voluminous, but they don‚Äôt belong to business, secondly, none of the large companies, especially intel, have not really overclocked them to share, and I don‚Äôt have any familiar circuitry from there subtle hint, by the way).  But it does not matter.  Another thing is important - similar lines of code (more precisely, hardware descriptions) are somewhere in the depths of the intel x86 core, accessible to us through the micro-architecture in the form of an extended set of sse instructions.  That's just in other architectures (yes, sort of like, and inside x86, somewhere under the micro-architecture, where honest RISC is) it is part of the co-processor on floating point arithmetic.  If, for x86 overlays, the call to the instructions of the co-processor is not particularly superimposed due to the possibility to optimize it inside the micro-architecture, then in other processors the co-processor often performs a separate sequence of commands and is controlled by the central one.  Thus, his team will be called according to the following scheme: </p><br><ul><li>  initiate coprocessor parameters </li><li>  pass on the values ‚Äã‚Äãhe needs to work with </li><li>  set its internal CP (instruction counter) to the address of the program written for it </li><li>  run it </li><li>  wait until he completes the operation (at this time you can do something else, no less useful) </li><li>  get results </li><li>  stop coprocessor </li></ul><br><p>  Obviously more than three instructions that we are trying to reduce.  Hence the logic of working on specific equipment is that, again, it is necessary to minimize the points of contact between scalar and vector arithmetic in order to reduce the number of data transfers and other overlays. </p><br><p>  For example, the description of ARM on wikipedia: </p><br><blockquote>  Advanced SIMD (NEON) <br>  An enhanced SIMD extension, also called NEON technology, is a combined 64-bit and 128-bit SIMD (single instruction multiple data) instruction set that provides standardized acceleration for media and signal processing applications.  NEON can perform decoding of mp3 audio format at a processor frequency of 10 MHz, and can work with the GSM AMR (adaptive multi-rate) speech codec at a frequency of more than 13 MHz.  It has an impressive instruction set, separate register files, and an independent execution system at the hardware level.  NEON supports 8-, 16-, 32-, 64-bit information of integer type, single precision and floating point, and works in SIMD operations for audio and video processing (graphics and games).  In NEON, SIMD supports up to 16 operations at a time. <br><br>  One of the drawbacks (or, say, a feature) of the improved SIMD is that the coprocessor executes the commands of the advanced SIMD with a fairly significant delay relative to the main processor code, the delay reaches two dozen ticks or more (depending on the architecture and specific conditions).  For this reason, when the main processor tries to use the results of the calculation of the co-processor, the execution will be frozen for a considerable time. </blockquote><p>  In general, we are talking about SIMD in js.  So what the hell?  ARM and x86 are all that we have when java-script-developers are concerned about what architecture will their code be executed on?  Maximum - which is not even a browser, but an engine. </p><br><p>  But damn two.  First, and with what fright did SIMD get pulled into JS?  Secondly, a <a href="http://www.espruino.com/">controversial decision, but now they are like mushrooms</a> .  And since the instrument is there, then it is necessary to understand how to use it effectively. </p></div></div><br><h3>  Practice </h3><br><p>  So vector operations will soon appear in js.  How soon?  At the moment, firefox nightly, edge with the "experimental features" flag and the chrome with the flag at startup - <code>--js-flags="--harmony-simd"</code> , i.e.  at least in some form, but all browsers.  In addition, there is a <a href="https://github.com/tc39/ecmascript_simd">polyfill</a> , so you can use it right now. </p><br><p>  A small example of how to use SIMD in js code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> someValue = SIMD.Float32x4(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> otherValue = SIMD.Float32x4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> summ = SIMD.Float32x4.add(someValue, otherValue);</code> </pre> <br><p>  For a complete list of available functions, see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SIMD">MDN</a> .  I want to note that SIMD.Float32x4 is not a designer and the entry is <code>new SIMD.Float32x4(0, 0, 0, 0);</code>  is not valid. </p><br><p>  I will not describe all the possibilities for using them, there are not very many of them, in general - arithmetic and loading with data upload, some more examples are all on the same <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/SIMD_types">MDN</a> , I will go straight to examples. </p><br><p>  <b>The designations I</b> have introduced for simplicity of examples are: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sload = SIMD.Float32x4.load; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sadd = SIMD.Float32x4.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smul = SIMD.Float32x4.mul; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ssqrt = SIMD.Float32x4.sqrt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sstore = SIMD.Float32x4.store;</code> </pre><br><h3>  Convolution </h3><br><p>  A convolution in mathematics refers to the conversion from one data set to another.  For programmers, convolution is traversing the entire array and performing a mathematical transformation on each of its elements, for example, multiplying by another number, adding to another array, or using the Sobel operator for the image (it will also be slightly lower). </p><br><p>  Scalar option: </p><br><img src="https://habrastorage.org/files/c28/357/8f9/c283578f931941e4bf8af7628a0b5c7d.PNG"><br><p><br>  Vector: </p><br><img src="https://habrastorage.org/files/fb0/4e0/caa/fb04e0caa2db44aeb7cde9e1f363484d.PNG"><br><p>  <i>Here and below: on the vertical axis data, on the horizontal - time.</i>  <i>Orange block - the data on which the operation occurs.</i> </p><br><p>  In the code, this is an example from above explicitly, on js like this (part of the algorithm for calculating the variance): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>(someBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ,     4,    ! sstore(arr, i, smul( sadd( sload(arr, i), expected // .  ), sadd( sload(arr, i), expected // .  ) )); }</span></span></code> </pre><br><h3>  The sum of the elements of the array </h3><br><p>  If I am not mistaken, this example is the first in the book on CUDA, and indeed it is the most typical example for SIMD (and, in this case, it is more suitable for computing on a video card, as long as it allows you to go to logarithmic complexity than to vector operations). </p><br><p>  I'll tell you the multi-threading algorithm, which is not difficult to adapt to the vector: first, every even (including zero) is summed with the odd, following it.  Then the zero (in which the sum a [0] + a [1] now lies) is added to the second even (a [2], which is equal to a [2] + a [3]) and so on.  In the next step, 0, 4, 8, ..., then 0, 8, 16, and so on, are combined in powers of two, until the array is finished. </p><br><p>  In the case of vector operations, the first 4 values ‚Äã‚Äãcan be summed with the second 4 values, otherwise everything is the same, i.e. </p><br><p>  a [0-3] = a [0-3] + a [4-7]; </p><br><p>  a [8-11] = a [8-11] + a [12-15]; </p><br><p>  Graphically: </p><br><p>  Scalar option </p><br><img src="https://habrastorage.org/files/98f/99b/6a5/98f99b6a5456419393ccac2d9412b019.PNG"><br><p><br>  Vector: </p><br><img src="https://habrastorage.org/files/4e8/36b/11c/4e836b11caa14514a1b529ffc9e34db1.PNG"><br><p><br>  Speed ‚Äã‚Äãincrease is expected to be quite large.  My js option: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> length = a.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; size) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i += k * <span class="hljs-number"><span class="hljs-number">2</span></span>) { SIMD.Float32x4.store(a, i, SIMD.Float32x4.add( SIMD.Float32x4.load(a, i), SIMD.Float32x4.load(a, i + k) )); } k = k &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  This example has a limitation: the size of the array must be at the same time a power of two and a multiple of 4. In principle, this is not so difficult to correct, but we will leave it for homework. </p><br><h3>  4x4 matrix multiplication </h3><br><p>  It makes sense to assume that matrix operations for square matrices of size 4 (and with them vectors of the same dimensionality. Mathematical vectors, and not calculating ones) SIMD will give a noticeable increase.  What is multiplication and what the classic version looks like, as well as graphically - I will not show it (graphically looks unattractive, the classic version is using the mathematical definition of matrix multiplication in the forehead, you can look at it on Wikipedia), I‚Äôve got the vector code on js: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row1, row2, row3, row4; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> brod1, brod2, brod3, brod4, row; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>); row1 = SIMD.Float32x4.load(a, <span class="hljs-number"><span class="hljs-number">0</span></span>); row2 = SIMD.Float32x4.load(a, <span class="hljs-number"><span class="hljs-number">4</span></span>); row3 = SIMD.Float32x4.load(a, <span class="hljs-number"><span class="hljs-number">8</span></span>); row4 = SIMD.Float32x4.load(a, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { d = b[<span class="hljs-number"><span class="hljs-number">4</span></span> * j + <span class="hljs-number"><span class="hljs-number">0</span></span>]; brod1 = SIMD.Float32x4(d, d, d, d); <span class="hljs-comment"><span class="hljs-comment">//      _mm_set1_ps d = b[4 * j + 1]; brod2 = SIMD.Float32x4(d, d, d, d); //      _mm_set1_ps d = b[4 * j + 2]; brod3 = SIMD.Float32x4(d, d, d, d); //      _mm_set1_ps d = b[4 * j + 3]; brod4 = SIMD.Float32x4(d, d, d, d); //      _mm_set1_ps row = SIMD.Float32x4.add( SIMD.Float32x4.add( SIMD.Float32x4.mul(brod1, row1), SIMD.Float32x4.mul(brod2, row2) ), SIMD.Float32x4.add( SIMD.Float32x4.mul(brod3, row4), SIMD.Float32x4.mul(brod3, row4) ) ); SIMD.Float32x4.store(c, j * 4, row); } }</span></span></code> </pre> <br><p>  It's hard.  I note that after viewing the code into which the c-shny version is compiled, I was not very upset by the lack of _mm_set1_ps, as long as it was compiled inside into 4 separate download commands, so the loss is not great. </p><br><h3>  Sobel operator </h3><br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258F">Wikipedia</a> .  It is an example of one of the typical tasks that should fit well on SIMD, as long as it is inside a convolution above an image.  Pictures, code and algorithm will not, however, I note that in the test I am somewhat cheated.  The fact is that the Sobel operator is much more optimized and stronger when using SIMD, but first you need to convert the data to another type, and matan is not easy there.  However, even a simple application gave an advantage.  As for the honest conversion - even though jpeg is a discrete-cosine transformation, inside it is not so far gone from convolution by the Sobel operator, namely due to SSE (and older) processor extensions, we can watch high-quality video on the processor (and impose much more complex effects using a video card), so this algorithm is the direct assignment of SIMD instructions in the processor, including js. </p><br><h3>  Is the future here?  Performance </h3><br><p>  <a href="http://corey-maler.github.io/simdBenchmark/index.html">Hands test can be run here</a> .  Remember to make sure your browser supports SIMD.  <a href="https://github.com/Corey-Maler/corey-maler.github.io/tree/master/simdBenchmark">The source code</a> , do not forget about the fork button, if you have ideas how to improve and optimize. </p><br><p>  He took the tests seriously: each test is grouped into 4 starts, one of which is ‚Äúidle‚Äù, designed for warming up the cache and so that the browser can compile what it considers necessary into a binary code.  Three are taken into account when calculating.  Then each of these groups is run n times, the order is chosen randomly, then the expectation and variance (the black bar on each of the graphs) is considered. </p><br><p>  I ran 500 times in each of my groups, which made it possible to eliminate such factors as garbage collection, switching flow, Kaspersky thinking and other windows 10 updates, and reflects numbers close to reality.  Unfortunately, it‚Äôs impossible to get more accurate conclusions on js for the reason that we can‚Äôt force the system‚Äôs task scheduler to switch tasks and other things, and to get the number of ticks allocated exclusively for js, there are also no tools (there is a profiler, but he is too hellish from that. Recheck in it - there is a link to the tests at the top, you can inspect it). </p><br><p>  Results on my computer (core i5 6400m, firefox nightly 51.0a): </p><br><img src="https://habrastorage.org/files/b0c/5a7/983/b0c5a7983816483e907f16c3b7c2bfe7.PNG"><br><p><br></p><br><h3>  findings </h3><br><p>  As can be seen from the improvised comparison of performance, with at least a little more or less competent use of technology, it gives an advantage of 20-40%.  In specific tasks, you can squeeze even more productivity, as a result, the technology is worth starting to think about its use.  Unfortunately, vector programming is quite complicated, there are few specialists in it, especially in the js world, so everyone and everyone will not rush.  However, if your project involves complex calculations, a sensitive speed increase will not be superfluous and can save a lot of resources and time for solving other problems. </p><br><p>  Now polyfill is available and there is no reason to think that the API for working with SIMD instructions in js will change, while the standard is completed by 90%, and the remaining 10%, secretly, are reflections on how to redefine operators like "+" and "* ".  In js, there are no operator overloads and I see no reason to drag them here, so it will most likely be directly included in the standard, which, after being accepted in the nearest release, will be available in firefox and edge.  Google in Chrome is not in a hurry with it for some reason, so if you now (at the time of writing this article in August 2016) start your new application on JS, which will have a lot of calculations, you should immediately have this library in view of and        ( ), ,   ,         ,         . </p><br><h3>           </h3><br><p>    ,          .   ,      x86,         ,    (    a + b * c,    ).  ,  - 66AK2x  TI (  )         javascript,   -      . (   <a href="https://habrahabr.ru/users/akon32/" class="user_link">Akon32</a> , </p><blockquote> SIMD-?  What for? JS      ,   .        ,   4-     .    3,  5,  8 ? ,     . <br> ,   (  )      JIT (    ),  OpenCL/CUDA- API. </blockquote><br>  ,         ). <p></p><br><p>   :  ,       ,     ,  MPi (  OpenMP).  ,  ,  : </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, N)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Float32Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">; /// #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pragma</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">omp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">private</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = 0; i &lt; N; i++)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">; } }</span></span></code> </pre><br><p> ,     <a href="https://ru.wikipedia.org/wiki/OpenMP">OpenMP</a> .         ,    128-  ,     .        JIT?   ,       . </p><br><p> PS              javascript.       ,    ,        js    ,  ,    ,    ,  .        js  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308696/">https://habr.com/ru/post/308696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308684/index.html">We optimize our effort when developing an application in Google Material Design</a></li>
<li><a href="../308686/index.html">Why do companies so hard to have Fullstack developers?</a></li>
<li><a href="../308690/index.html">PostgreSQL integration with other DBMS: making queries in MySQL</a></li>
<li><a href="../308692/index.html">The nuclear bunker in Paris will be converted into a data center company online.net</a></li>
<li><a href="../308694/index.html">How to ‚Äúmodel the future‚Äù at ITMO University: from predicting crowd behavior to analyzing opinions in social networks</a></li>
<li><a href="../308698/index.html">The digest of fresh materials from the world of the frontend for the last week No. 225 (August 22 - 28, 2016)</a></li>
<li><a href="../308700/index.html">The results of the selection of the school Android-developers in Kazan</a></li>
<li><a href="../308702/index.html">PHP Digest number 91 - interesting news, materials and tools (August 15 - 28, 2016)</a></li>
<li><a href="../308714/index.html">How I tried to make money on Pokemon Go</a></li>
<li><a href="../308718/index.html">Distributing unpublished Windows 10 apps to the Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>