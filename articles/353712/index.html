<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our own clever thread_pool-dispatcher for SObjectizer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is this article about? 
 One of the main distinguishing features of the SObjectizer C ++ framework is the presence of dispatchers. Dispatchers de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our own clever thread_pool-dispatcher for SObjectizer</h1><div class="post__text post__text-html js-mediator-article"><h1>  What is this article about? </h1><br>  One of the main distinguishing features of the <a href="https://habrahabr.ru/post/304386/">SObjectizer C ++ framework</a> is the presence of dispatchers.  Dispatchers determine where and how the actors (agents in the SObjectizer terminology) will handle their events: on a separate thread, on a working thread pool, on one thread common to a group of actors, etc. <br><br>  SObjectizer already includes <a href="https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-eighth-part-dispatchers">eight full-time dispatchers</a> (plus one more in the <a href="https://stiffstream.com/ru/products/so_5_extra.html">set of extensions for SObjectizer</a> ).  But even with all this diversity there are situations when it makes sense to make your own dispatcher for a specific specific task.  The article just examines one of these situations and shows how you can make your own dispatcher, if the staff dispatchers for some reason do not like us.  And at the same time it will be shown how easy it is to change the behavior of an application just by tying the same actor to different dispatchers.  Well, a few more interesting little things and not very small things. <br><br>  In general, if someone is interested in touching on the details of the implementation of one of the few living and developing actor frameworks for C ++, then we can safely read further. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Preamble </h1><br>  Recently, one of the users of SObjectizer talked about a specific problem that he had to face in the process of using SObjectizer.  The point is that, on the basis of SObjectizer agents, an application is being developed for managing devices connected to a computer.  Some operations (namely, the operation of initializing and re-initializing the device) are performed synchronously, which leads to blocking of the working thread for some time.  The same I / O operations are carried out asynchronously, so the read / write initiation and the read-write result processing are performed much faster and do not block the working thread for a long time. <br><a name="habracut"></a><br>  There are many devices, from several hundred to several thousand, so using the ‚Äúone device - one working thread‚Äù scheme is not profitable.  Because of what the small pool of working threads on which all operations with devices are performed is used. <br><br>  But such a simple approach has an unpleasant feature.  When a large number of applications for initialization and re-initialization of devices arise, these applications begin to be distributed among all threads from the pool.  And there are regular situations when all the working threads of the pool are busy with performing long operations, while short operations, like reading and writing, accumulate in queues and are not processed for a long time.  This situation is consistently observed, for example, at the start of the application, when a large ‚Äúbundle‚Äù of applications for device initialization is immediately formed.  And until this ‚Äúbundle‚Äù is disassembled, I / O operations on already initialized devices are not performed. <br><br>  To eliminate this trouble, you can use several approaches.  In this article we will analyze one of them, namely, writing your own clever thread_pool-dispatcher, analyzing the types of requests. <br><br><h1>  What do we want to achieve? </h1><br>  The problem is that long-running processors (i.e., handlers for initializing and reinitializing devices) block all working threads in the pool and because of this request for short operations (i.e., I / O operations) can wait in the queue is very long.  We want to get such a dispatch scheme so that when a request for a short operation arrives, its waiting in queues will be minimized. <br><br><h1>  Imitation "stand" </h1><br>  In the article we will use the <a href="https://bitbucket.org/sobjectizerteam/so5_tricky_thread_pool_disp_ru">imitation of the problem described above</a> .  Why imitation?  Because, first of all, we have an idea only about the essence of the user's problem, but we don‚Äôt know the details and have never seen his code.  And, secondly, imitation allows you to concentrate on the most significant aspects of the problem being solved, without dispersing attention to small details, of which there are a great many in real production code. <br><br>  However, there is one important detail that has become known to us from our user and which most seriously affects the solution described below.  The fact is that in SObjectizer there is a thread-safety concept for message handlers.  Those.  if the message handler is marked as thread-safe, then SObjectizer has the right to run this handler in parallel with other thread-safe handlers.  And there is an adv_thread_pool-dispatcher that does just that. <br><br>  So, our user used a stateless agent tied to an adv_thread_pool-dispatcher to manage devices.  This greatly simplifies the whole kitchen. <br><br>  So what are we going to consider? <br><br>  We made an imitation consisting of the same agents.  One agent is an auxiliary agent of type a_dashboard_t.  His task is to collect and record statistics, according to which we will judge the results of simulation experiments.  We will not consider the <a href="">implementation of</a> this agent. <br><br>  The second agent, <a href="">implemented by the a_device_manager_t class</a> , simulates working with devices.  We will talk a little about how this agent works below.  This can be an interesting example of how agents can be implemented in SObjectizer that do not need to change their state. <br><br>  The imitation consists of two applications that do almost the same thing: parse the command line arguments and run the imitation with the a_dashboard_t and a_device_manager_t agents inside.  But the first application binds a_device_manager_t to the adv_thread_pool dispatcher.  But the second application implements its own type of dispatcher and binds a_device_manager_t to this own dispatcher. <br><br>  Based on the results of each of the applications, it will be possible to see how different types of dispatchers affect the nature of service requests. <br><br><h1>  Agent a_device_manager_t </h1><br>  In this section, we will try to highlight the main points in the implementation of the a_device_manager_t agent.  All other details can be seen <a href="">in the full agent code</a> .  Or clarify in the comments. <br><br>  The a_device_manager_t agent should imitate work with many devices of the same type, but it should be a ‚Äústateless agent‚Äù, i.e.  he should not change his state in the process.  Exactly that the agent does not change its state and allows it to have thread-safe event handlers. <br><br>  However, if the a_device_manager_t agent does not change its state, how does it determine which device should be initialized, which device should be reinitialized, and which device should perform input / output operations?  It's simple: all this information is sent inside the messages that a_device_manager_t agent sends to itself. <br><br>  At start, the a_device_manager_t agent sends N messages to init_device_t.  Upon receiving such a message, the a_device_manager_t agent creates an instance of the ‚Äúdevice‚Äù ‚Äîan object of the device_t type and performs its initialization.  Then point to this instance is sent in the message perform_io_t.  It looks like this: <br><br><pre><code class="hljs ruby">void on_init_device(mhood_t&lt;init_device_t&gt; cmd) const { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     . handle_msg_delay(a_dashboard_t::op_type_t::init, *cmd); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    . auto dev = std::make_unique&lt;device_t&gt;(cmd-&gt;id<span class="hljs-number"><span class="hljs-number">_</span></span>, calculate_io_period(), calculate_io_ops_before_reinit(), calculate_reinits_before_recreate()); std::this_thread::sleep_for(args<span class="hljs-number"><span class="hljs-number">_</span></span>.device_init_time<span class="hljs-number"><span class="hljs-number">_</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       IO- /<span class="hljs-regexp"><span class="hljs-regexp">/   . send_perform_io_msg(std::move(dev)); }</span></span></code> </pre> <br>  Upon receiving the perform_io_t message, the a_device_manager_t agent simulates an I / O operation for the device, the pointer to which is inside the perform_io_t message.  At the same time, for a device_t, the counter of IO operations is decremented.  If this counter reaches zero, then a_device_manager_t either sends itself a reinit_device_t message (if the reinitialization counter is not yet reset), or the init_device_t message to re-create the device.  This simple logic simulates the behavior of real devices that have the property of "sticking" (that is, ceasing to perform normal IO-operations) and then they need to be reinitialized.  And also the sad fact that every device has a limited resource, having exhausted the device that needs to be replaced. <br><br>  If the counter of IO operations has not yet been reset, the a_device_manager_t agent once again sends itself the message perform_io_t. <br><br>  In the code, it all looks like this: <br><br><pre> <code class="hljs dos">void on_perform_io(mutable_mhood_t&lt;perform_io_t&gt; <span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>) const { //     . handle_msg_delay(a_dashboard_t::op_type_t::io_op, *<span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>); //     IO-. std::this_thread::sleep_for(args_.io_op_time_); //   IO-  . <span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_-&gt;remaining_io_ops_ -= <span class="hljs-number"><span class="hljs-number">1</span></span>; // ,    . //   ,     . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_-&gt;remaining_io_ops_) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_-&gt;remaining_reinits_) //   .     . so_5::send&lt;init_device_t&gt;(*this, <span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_-&gt;id_); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     . so_5::send&lt;so_5::mutable_msg&lt;reinit_device_t&gt;&gt;(*this, std::<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     ,  IO-. send_perform_io_msg(std::<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>-&gt;device_)); }</code> </pre> <br>  This is such a simple logic, regarding which the specification of some details may make sense. <br><br><h2>  Sending information to a_dashboard_t agent </h2><br>  In the init_device_t, reinit_device_t message handlers and perform_io_t, the first line is a similar construction: <br><br><pre> <code class="hljs lisp">handle_msg_delay(<span class="hljs-name"><span class="hljs-name">a_dashboard_t</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:op_type_t</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:init</span></span>, *cmd);</code> </pre> <br>  This is the transfer to the a_dashboard_t agent of how much a particular message has spent in the request queue.  Based on this information, statistics are built. <br><br>  In principle, accurate information about how much time the message spent in the queue of applications could be obtained only by taking root in the giblets of SObjectizer: then we could fix the time for submitting the application to the queue and the time it was taken from there.  But for such a simple experiment, we will not deal with such an extreme.  Let's do it easier: when sending the next message, we will save it the expected time of arrival of the message.  For example, if we send a deferred message to 250ms, then we wait for it to arrive at the time (Tc + 250ms), where Tc is the current time.  If the message came through (Tc + 350ms), then it spent 100ms in the queue. <br><br>  This, of course, is not an exact way, but it is quite suitable for our imitation. <br><br><h2>  Blocking the current working thread for a while </h2><br>  Also in the code of the message handlers init_device_t, reinit_device_t and perform_io_t, you can see the call to std :: this_thread :: sleep_for.  This is nothing more than an imitation of synchronous operations with the device, which should block the current thread. <br><br>  The delay times can be set via the command line, and the default values ‚Äã‚Äãare as follows: for init_device_t - 1250ms, for perform_io_t - 50ms.  Duration for reinit_device_t is calculated as 2/3 of the duration of init_device (i.e. 833ms by default). <br><br><h2>  Using mutable messages </h2><br>  Perhaps the most interesting feature of the a_device_manager_t agent is how the lifetime of the dynamically created device_t objects is ensured.  After all, the device_t instance is created dynamically during the processing of init_device_t and then it must remain alive until the attempts to reinitialize this device have been exhausted.  And when reinitialization attempts are exhausted, the device_t instance should be destroyed. <br><br>  At the same time, a_device_manager_t should not change its state.  Those.  we cannot get into a_device_manager_t some kind of std :: map or std :: unordered_map, which would be a living device_t dictionary. <br><br>  To solve this problem, use the following trick.  In the reinit_device_t and perform_io_t messages, a unique_ptr is passed, containing a pointer to the device_t instance.  Accordingly, when we process reinit_device_t or perform_io_t and want to send the following message for this device, we simply transfer the unique_ptr from the old message instance to the new instance.  And if the instance is no longer needed, i.e.  we don‚Äôt send reinit_device_t or perform_io_t for it anymore, the device_t instance is automatically destroyed because  The unique_ptr instance is destroyed in the already processed message. <br><br>  But there is a little trick.  Normally messages in a SObjectizer are sent as immutable objects that should not be modified.  This is because SObjectizer implements the Pub / Sub model and sending a message to the mbox in general cannot say with certainty how many subscribers will receive the message.  Maybe there will be ten.  Maybe a hundred.  Maybe a thousand.  Accordingly, some subscribers will process the message simultaneously.  Therefore, it is impossible to allow one subscriber to modify an instance of a message while another subscriber is trying to work with this instance.  It is because of this that ordinary messages are passed to the handler via a constant link. <br><br>  However, there are situations when a message is guaranteed to be sent to a single recipient.  And this recipient wants to modify the received copy of the message.  Here's how in our example, when we want to take the value of unique_ptr from the received_per_________fr__fr and give this value to a new instance of reinit_device_t. <br><br>  For such cases, support for <a href="https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-tenth-part-mutable-messages">mutable messages has</a> been added to SObjectizer-5.5.19.  These messages are marked in a special way.  And the SObjectizer checks in run-time whether mutable messages are sent to multi-producer / multi-consumer mboxes.  Those.  A mutable message can be delivered to no more than one recipient.  Therefore, it is transmitted to the recipient by a normal, non-constant link, which allows modifying the content of the message. <br><br>  Traces of this are found in the a_device_manager_t code.  For example, this handler signature says that the handler is expecting a mutable message: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_perform_io</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mutable_mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">perform_io_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span></code> </pre> <br>  And this code says that a copy of the mutable message will be retrieved: <br><pre> <code class="hljs ruby">so_5::send&lt;so_5::mutable_msg&lt;reinit_device_t<span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>(*this, std::move(cmd-&gt;device<span class="hljs-number"><span class="hljs-number">_</span></span>));</code> </pre> <br><h1>  Imitation using adv_thread_pool-manager </h1><br>  In order to see how our a_device_manager_t will behave with the regular adv_thread_pool-manager, you need to create cooperation from the a_dashboard_t and a_device_manager_t agents, assigning a_device_manager_t to the adv_thread_pool-manager.  What looks <a href="">like this</a> : <br><br><pre> <code class="hljs markdown">void run<span class="hljs-emphasis"><span class="hljs-emphasis">_example(const args_</span></span>t &amp; args ) { print<span class="hljs-emphasis"><span class="hljs-emphasis">_args(args); so_</span></span>5::launch([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::environment_t &amp; env</span></span>) { env.introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_coop([&amp;](so_</span></span>5::coop<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; coop) { const auto dashboard_</span></span>mbox = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;a_</span></span>dashboard<span class="hljs-emphasis"><span class="hljs-emphasis">_t&gt;()-&gt;so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(); //        // adv_</span></span>thread<span class="hljs-emphasis"><span class="hljs-emphasis">_pool-. namespace disp = so_</span></span>5::disp::adv<span class="hljs-emphasis"><span class="hljs-emphasis">_thread_</span></span>pool; coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent_</span></span>with<span class="hljs-emphasis"><span class="hljs-emphasis">_binder&lt;a_</span></span>device<span class="hljs-emphasis"><span class="hljs-emphasis">_manager_</span></span>t&gt;( disp::create<span class="hljs-emphasis"><span class="hljs-emphasis">_private_</span></span>disp(env, args.thread<span class="hljs-emphasis"><span class="hljs-emphasis">_pool_</span></span>size<span class="hljs-emphasis"><span class="hljs-emphasis">_)-&gt; binder(disp::bind_</span></span>params<span class="hljs-emphasis"><span class="hljs-emphasis">_t{}), args, dashboard_</span></span>mbox); }); }); }</code> </pre> <br>  As a result of a test run with 20 worker threads in the pool and other default values, we get the following image: <br><br><img src="https://habrastorage.org/webt/uk/pq/0u/ukpq0uehznxkxoj7ibprl427xvi.jpeg"><br><br>  You can see a large ‚Äúblue‚Äù peak at the very beginning (this is mass creation of devices at the start), as well as large ‚Äúgray‚Äù peaks soon after the start of work.  First, we receive a large number of init_device_t messages, some of which are long waiting for their turn to be processed.  Then perform_io_t is processed very quickly and a large number of reinit_device_t is generated.  Some of these reinit_device_t are waiting in queues, hence the noticeable gray peaks.  You can also see noticeable dips in the green lines.  This drop in the number of messages processed by perform_io_t during those moments when there is a massive processing of reinit_device_t and init_device_t. <br><br>  Our task is to reduce the number of ‚Äúgray‚Äù bursts and make the ‚Äúgreen‚Äù dips not so deep. <br><br><h1>  The idea of ‚Äã‚Äãa tricky thread_pool dispatcher </h1><br>  The problem with the adv_thread_pool-manager is that all requests are equal for him.  Therefore, as soon as the working thread is released, he gives her the first application from the queue.  Absolutely not understanding what type of this application.  This leads to situations where all the worker threads are busy processing the init_device_t or reinit_device_t requests, while in the queue there are requests of the type perform_io_t. <br><br>  To get rid of this problem we will make our clever thread_pool-dispatcher, which will have two sub-pools from the working threads of two types. <br><br>  The working threads of the first type can process applications of any type.  Priority is given to requests of the type init_device_t and reinit_device_t, but if they are not present at the moment, then you can process requests of the type perform_io_t. <br><br>  The working threads of the second type cannot process requests of the type init_device_t and reinit_device_t.  An application of type perform_io_t can be processed, but an application of type init_device_t cannot. <br><br>  Thus, if we have 50 applications of the type reinit_device_t and 150 applications of the type perform_io_t, then the first subpool will rake the applications reinit_device_t, and the second subpool will rake the applications perform_io_t.  When all applications of the type reinit_device_t are processed, the worker threads from the first subpool will be freed and will be able to help process the remaining requests of type perform_io_t. <br><br>  It turns out that our clever thread_pool-controller holds a separate set of threads for processing short requests and this allows us not to slow down short requests even when there are a large number of long requests (as, say, at the very beginning of work, when a large number of init_device_t is sent at one time). <br><br><h1>  Imitation using tricky thread_pool-manager </h1><br>  In order to do the same imitation, but with another dispatcher, we need only <a href="">slightly redo the</a> already shown function run_example: <br><br><pre> <code class="hljs markdown">void run<span class="hljs-emphasis"><span class="hljs-emphasis">_example(const args_</span></span>t &amp; args ) { print<span class="hljs-emphasis"><span class="hljs-emphasis">_args(args); so_</span></span>5::launch([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::environment_t &amp; env</span></span>) { env.introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_coop([&amp;](so_</span></span>5::coop<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; coop) { const auto dashboard_</span></span>mbox = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;a_</span></span>dashboard<span class="hljs-emphasis"><span class="hljs-emphasis">_t&gt;()-&gt;so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(); //        //  . coop.make_</span></span>agent<span class="hljs-emphasis"><span class="hljs-emphasis">_with_</span></span>binder<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a_device_manager_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>( tricky<span class="hljs-emphasis"><span class="hljs-emphasis">_dispatcher_</span></span>t::make(env, args.thread<span class="hljs-emphasis"><span class="hljs-emphasis">_pool_</span></span>size<span class="hljs-emphasis"><span class="hljs-emphasis">_)-&gt;binder(), args, dashboard_</span></span>mbox); }); }); }</code> </pre> <br>  Those.  we create all the same agents, only this time we bind a_device_manager_t to another dispatcher. <br><br>  As a result of the launch with the same parameters, we will see a different picture: <br><br><img src="https://habrastorage.org/webt/vb/2y/sp/vb2ysp_zxg14hbgbzq1pmwcswug.jpeg"><br><br>  There is the same "blue" peak.  Now he has become even taller, which is not surprising, since  for processing init_device_t, fewer worker threads are now allocated.  But we do not see the "gray" peaks and the "green" dips become less deep. <br><br>  Those.  we got the result we wanted.  And now we can look at the code of this very cunning dispatcher. <br><br><h1>  Implementing a tricky thread_pool dispatcher </h1><br>  Dispatchers in SObjectizer are divided into two types: <br><br>  First, public dispatchers.  Each public dispatcher must have a unique name.  Usually, dispatcher instances are created before SObjectizer starts, while SObjectizer starts up, and public dispatchers start, and when SObjectizer ends, it stops.  These controllers must have a <a href="">specific interface</a> .  But this is an obsolete type of dispatchers.  There is far from zero chance that there will be no public dispatchers in the next major version of SObjectizer. <br><br>  Secondly, private dispatchers.  The user creates these dispatchers at any time after starting SObjectizer.  The private dispatcher should start immediately after creation and it finishes its work after it is no longer used.  Just for our imitation, we will create a dispatcher, which can only be used as a private dispatcher. <br><br>  Let's look at the main points related to our dispatcher. <br><br><h2>  disp_binder for our dispatcher </h2><br>  Private controllers do not have a strictly defined interface, since  All basic operations are performed in the constructor and destructor.  But the private dispatcher must have a public method, usually called binder (), that returns a special binder object.  This binder object will bind the agent to a specific dispatcher.  And binder already should have quite a specific interface - <a href="">disp_binder_t</a> . <br><br>  Therefore, for <a href="">our dispatcher,</a> we make our own binder type that implements the disp_binder_t interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_dispatcher_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt;<span class="hljs-keyword"><span class="hljs-keyword">tricky_dispatcher_t</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_event_queue_t</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_disp_binder_t</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_event_queue_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">event_queue_t</span></span> {...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_disp_binder_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">disp_binder_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">tricky_dispatcher_t</span></span>&gt; disp_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">tricky_disp_binder_t</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">tricky_dispatcher_t</span></span>&gt; disp) : disp_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp)} {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">disp_binding_activator_t</span></span> bind_agent( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp;, so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_ref_t</span></span> agent) override { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [d = disp_, agent] { agent-&gt;so_bind_to_dispatcher(d-&gt;event_queue_); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbind_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . } }; ... // ,   so_5::event_queue_t  , //      . tricky_event_queue_t event_queue_; ... public: ... //  ,       . so_5::disp_binder_unique_ptr_t binder() { return so_5::disp_binder_unique_ptr_t{ new tricky_disp_binder_t{shared_from_this()}}; } };</span></span></code> </pre> <br>  Our tricky_dispatcher_t class is inherited from std :: enable_shared_from_this so that we can use the reference count to control the lifetime of the dispatcher.  As soon as the dispatcher is no longer used, the reference count is reset and the dispatcher is automatically destroyed. <br><br>  In the ticky_dispatcher_t class, there is a public binder () method that returns a new instance of tricky_disp_binder_t.  A smart pointer to the dispatcher itself is passed to this instance.  This allows you to then associate a specific agent with a specific dispatcher, as we saw earlier in the run_example code: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-comment"><span class="hljs-comment">//        //  . coop.make_agent_with_binder&lt;a_device_manager_t&gt;( tricky_dispatcher_t::make(env, args.thread_pool_size_)-&gt;binder(), args, dashboard_mbox); }); });</span></span></code> </pre><br>  The binder object must perform two actions.  The first is to bind the agent to the dispatcher.  What does bind_agent () do?  Although, in fact, the agent is associated with the dispatcher in two stages.  First, in the process of registering cooperation, the bind_agent () method is called and this method must create all the resources necessary for the agent.  For example, if an agent is bound to the active_obj dispatcher, then a new working thread should be allocated for the agent.  This should just happen in bind_agent ().  The bind_agent () method returns a functor that already completes the agent binding procedure using previously allocated resources.  Those.  it turns out that when registering a co-operation, bind_agent () is first called, and a bind_agent returned by a functor returned a little later. <br><br>  In our case, bind_agent () is very simple.  No resources need to be allocated, just return the functor, which will connect the agent with the dispatcher (more on this below). <br><br>  The second action is unbinding the agent from the dispatcher.  This unbinding occurs when the agent is removed from the SObjectizer (deregistered).  In this case, it may be necessary to clear some resources that were allocated to the agent.  For example, the active_obj dispatcher stops the worker thread allocated to the agent. <br><br>  The unbind_agent () method is responsible for performing the second action.  But in our case it is empty, because for tricky_dispatcher_t, clearing resources when unbinding an agent is not required. <br><br><h2>  tricky_event_queue_t </h2><br>  Above, we talked about ‚Äúbinding an agent to a dispatcher,‚Äù but what is the meaning of this binding?  Meaning in two simple things. <br><br>  First, some dispatchers, such as active_obj, mentioned above, must allocate certain resources to the agent at the time of binding. <br><br>  Secondly, in SObjectizer, agents do not have their own message / request queues.  This is the fundamental difference between the SObjectizer implementation of the "classical Actor Model", in which each actor has its own mailbox (and, therefore, its own message queue). <br><br>  In SObjectizer, dispatchers own the order queues.  It is the dispatchers who determine where and how applications are stored (that is, messages addressed to the agent), where, when and how applications are retrieved and processed. <br><br>  Accordingly, when the agent starts working inside SObjectizer, you need to establish a connection between the agent and the order queue into which messages addressed to the agent should be added.  To do this, call the agent a special method so_bind_to_dispatcher () and transfer to this method a reference to the object that implements the <a href="">event_queue_t</a> interface.  What, in fact, we see in the implementation of tricky_disp_binder_t :: bind_agent (). <br><br>  But the question is what exactly tricky_disp_binder_t gives to so_bind_to_dispatcher ().  In our case, this is a special implementation of the event_queue_t interface, which serves only as a thin proxy for calling tricky_dispatcher_t :: push_demand (): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_event_queue_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">event_queue_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tricky_dispatcher_t</span></span> &amp; disp_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">tricky_event_queue_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">tricky_dispatcher_t</span></span> &amp; disp) : disp_{disp} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> demand)</span></span></span><span class="hljs-function"> override </span></span>{ disp_.push_demand(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(demand)); } };</code> </pre> <br><h2>  What does tricky_dispatcher_t :: push_demand hide? </h2><br>  So, in our tricky_dispatcher_t there is a single instance of tricky_event_queue_t, the link to which is passed to all agents attached to the dispatcher.  And this instance itself simply delegates all the work to the tricky_dispatcher_t :: push_demand () method.  It's time to look inside the push_demand: <br><br><pre> <code class="hljs ruby">void push_demand(so_5::execution_demand_t demand) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(init_device_type == demand.m_msg_type <span class="hljs-params"><span class="hljs-params">||</span></span> reinit_device_type == demand.m_msg_type) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . so_5::send&lt;so_5::execution_demand_t&gt;(init_reinit_ch<span class="hljs-number"><span class="hljs-number">_</span></span>, std::move(demand)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      . so_5::send&lt;so_5::execution_demand_t&gt;(other_demands_ch<span class="hljs-number"><span class="hljs-number">_</span></span>, std::move(demand)); } }</code> </pre> <br>  Everything is simple here.  For each new application, its type is checked.  If the application relates to the init_device_t or reinit_device_t messages, then it is put in one place.  If this is an application of any other type, then it is put in another place. <br><br>  The most interesting is what init_reinit_ch_ and other_demands_ch_ are?  And they represent nothing more than CSP-shny channels, which in SObjectizer are called <a href="https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-ninth-part-message-chains">mchains</a> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ,       . so_5::mchain_t init_reinit_ch_; so_5::mchain_t other_demands_ch_;</span></span></code> </pre> <br>  It turns out that when a new application has been created for the agent and this application has reached push_demand, then its type is analyzed and the application is sent either to one channel or to another.  And the working threads that are included in the dispatcher pool are already retrieved and processed. <br><br><h2>  Implementing Manager Worker Threads </h2><br>  As mentioned above, our cunning dispatcher uses working threads of two types.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is now clear that the working threads of the first type must read the requests from init_reinit_ch_ and execute them. And if init_reinit_ch_ is empty, then you need to read and execute requests from other_demands_ch_. If both channels are empty, then you need to sleep until a request arrives in one of the channels. Or until both channels are closed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With working threads of the second type is even simpler: you only need to read requests from other_demands_ch_. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, this is exactly what we see in the tricky_dispatcher_t code:</font></font><br><br><pre> <code class="hljs pgsql">//   so_5::execution_demand_t. static <span class="hljs-type"><span class="hljs-type">void</span></span> exec_demand_handler(so_5::execution_demand_t d) { d.call_handler(so_5::null_current_thread_id()); } //     . <span class="hljs-type"><span class="hljs-type">void</span></span> first_type_thread_body() { //     ,      . so_5::<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(so_5::from_all(), case_(init_reinit_ch_, exec_demand_handler), case_(other_demands_ch_, exec_demand_handler)); } //     . <span class="hljs-type"><span class="hljs-type">void</span></span> second_type_thread_body() { //     ,      . so_5::<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(so_5::from_all(), case_(other_demands_ch_, exec_demand_handler)); }</code> </pre> <br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the thread of the first type hangs on a select of two channels. </font><font style="vertical-align: inherit;">While the thread of the second type is on select from only one channel (in principle, inside second_type_thread_body () one could use so_5 :: receive () instead of so_5 :: select ()). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, this and all that we needed to do was to organize two thread-safe queues of requests and reading these queues on different working threads.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start-stop of our cunning dispatcher </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For completeness, it makes sense to provide in the article also the code related to starting and stopping tricky_dispatcher_t. </font><font style="vertical-align: inherit;">The start is performed in the constructor, and the stop, respectively, in the destructor:</font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/       . tricky_dispatcher_t( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ SObjectizer Environment,     . so_5::environment_t &amp; env, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     . unsigned pool_size) : event_queue_{*this} , init_reinit_ch_{so_5::create_mchain(env)} , other_demands_ch_{so_5::create_mchain(env)} { const auto [first_type_count, second_type_count] = calculate_pools_sizes(pool_size); launch_work_threads(first_type_count, second_type_count); } ~tricky_dispatcher_t() noexcept { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . shutdown_work_threads(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the constructor you can also see the creation of the init_reinit_ch_ and other_demands_ch_ channels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helper methods launch_work_threads () and shutdown_work_threads () look like this:</font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . void launch_work_threads( unsigned first_type_threads_count, unsigned second_type_threads_count) { work_threads_.reserve(first_type_threads_count + second_type_threads_count); try { for(auto i = 0u; i &lt; first_type_threads_count; ++i) work_threads_.emplace_back([this]{ first_type_thread_body(); }); for(auto i = 0u; i &lt; second_type_threads_count; ++i) work_threads_.emplace_back([this]{ second_type_thread_body(); }); } catch(...) { shutdown_work_threads(); throw; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . } } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,     . void shutdown_work_threads() noexcept { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . so_5::close_drop_content(init_reinit_ch_); so_5::close_drop_content(other_demands_ch_); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . for(auto &amp; t : work_threads_) t.join(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . work_threads_.clear(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, perhaps, the only tricky moment is the need to catch exceptions in launch_work_threads, call shutdown_work_threads, and then forward the exception further. Everything else seems to be trivial and should not cause difficulties.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generally speaking, the development of controllers for SObjectizer is not an easy topic. And the </font><font style="vertical-align: inherit;">regular dispatchers that are </font><font style="vertical-align: inherit;">part of SO-5.5 and </font></font><a href="https://stiffstream.com/ru/products/so_5_extra.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so_5_extra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have a much more sophisticated implementation than the tricky_dispatcher_t shown in this article. However, in some specific situations, when no full-time dispatcher is 100% suitable, you can implement your own dispatcher, specially tailored to your task. If you do not try to touch on such a complex topic as run-time monitoring and statistics, then writing your own dispatcher does not look so prohibitively complex.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should also be noted that the tricky_dispatcher_t shown above turned out to be simple due to the very important assumption that the events of all the agents attached to it will be thread-safe and can be called in parallel without thinking anything. However, this is usually not the case. In most cases, agents have only thread-unsafe handlers. But even when there are thread-safe handlers, they exist simultaneously with the thread-unsafe handlers. And when dispatching applications, you have to check the type of the next processor. For example, if the handler for the next thread-safe request, and now thread-unsafe is working, then you need to wait until the previously launched thread-unsafe handler is completed. Just all this is done by the staff adv_thread_pool-dispatcher. But it is rarely used in practice. More often other dispatchers are used,which do not analyze the thread-safety flag for handlers, but consider that all handlers are thread-unsafe.</font></font><br><br>   ,             SObjectizer      <a href="https://www.youtube.com/watch%3Fv%3D9fWDTbXnWaw">  SObjectizer  C++Russia 2017</a> .  -     SObjectizer     ,      ,      <a href="http://cppconf.ru/talks/evgeniy-okhotnikov"> C++Russia 2018</a> . </div><p>Source: <a href="https://habr.com/ru/post/353712/">https://habr.com/ru/post/353712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353698/index.html">Code architecture</a></li>
<li><a href="../353704/index.html">Fell with AWS? Call in without question, documents later, now not before</a></li>
<li><a href="../353706/index.html">Aviakacathon</a></li>
<li><a href="../353708/index.html">[St. Petersburg, announcement] SpbDotNet # 30 - reports on telemetry of .NET microservices and code analyzers ReSharper and Roslyn</a></li>
<li><a href="../353710/index.html">How to learn to predict late trains</a></li>
<li><a href="../353714/index.html">Announcement of AppsConf: 2 days of application, hardcore and HYIP reports</a></li>
<li><a href="../353716/index.html">IPv6 support in CleanTalk Security for WordPress</a></li>
<li><a href="../353718/index.html">It's all about the combination: the history of the security system of one site</a></li>
<li><a href="../353720/index.html">How to create custom components for monitoring devices and automating IT tasks</a></li>
<li><a href="../353722/index.html">Guide to create your own shaders in the Unreal Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>