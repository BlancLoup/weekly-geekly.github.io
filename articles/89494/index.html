<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static analysis of C ++ code and new standard of C ++ 0x language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 Introduction 
 1. auto 
 2. decltype 
 3. Link to temporary object (R-value reference) 
 4. Right angle brackets 
 5. Lambda functions (L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static analysis of C ++ code and new standard of C ++ 0x language</h1><div class="post__text post__text-html js-mediator-article">  <b>annotation</b> <br>  <b>Introduction</b> <br>  <b>1. auto</b> <br>  <b>2. decltype</b> <br>  <b>3. Link to temporary object (R-value reference)</b> <br>  <b>4. Right angle brackets</b> <br>  <b>5. Lambda functions (Lambdas)</b> <br>  <b>6. Suffix return type syntax</b> <br>  <b>7. static_assert</b> <br>  <b>8. nullptr</b> <br>  <b>9. New Standard Classes</b> <br>  <b>10. New directions in the development of static code analyzers</b> <br>  <b>Conclusion</b> <br>  <b>Bibliographic list</b> <br><br><h2>  annotation </h2><br>  The article describes new C ++ features described in the C ++ 0x standard and supported in Visual Studio 2010. By the example of PVS-Studio, the changes in the language will be reflected in the static code analysis tools. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  The new standard of C ++ is about to come into our lives.  While it continues to be called C ++ 0x, although, apparently, its final name is C ++ 11.  The new standard is already partially supported by modern C ++ compilers, for example, Intel C ++ and Visual C ++.  Support is far from complete, which is quite natural.  First, the standard has not yet been adopted, and secondly, even when it is adopted, it will take time for the compilers to work out its features. <br><br>  Compiler developers are not the only ones who care about supporting the new standard.  Innovations of the language should be promptly supported in static source code analysis tools.  The new standard promises backward compatibility.  Almost guaranteed old C ++ code will be correctly compiled by the new compiler without the need for any changes.  However, this does not mean that a program that does not contain new language constructs can still be processed by a static analyzer that does not support the new C ++ 0x standard.  We saw this in practice by trying to check with <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio a</a> project created in the beta version of Visual Studio 2010. It‚Äôs all about the header files that already use new language constructs.  For example, in the header file ‚Äústddef.h‚Äù you can see the use of the new decltype operator: <br><table><tbody><tr><td><pre> namespace std {typedef decltype (__ nullptr) nullptr_t;  } </pre></td></tr></tbody></table>  Naturally, such constructions are syntactically incorrect for an analyzer that does not support C ++ 0x, and result either in stopping its operation or in an incorrect result.  The need to support C ++ 0x in PVS-Studio by the time Visual Studio 2010 was released became obvious, at least to the extent that the new standard is supported by this compiler. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It can be stated that this problem was successfully solved by us and at the time of this writing, the site has a PVS-Studio 3.50 version that integrates into both Visual Studio 2005/2008 and Visual Studio 2010. Starting with PVS-Studio 3.50 in the tool support is provided for that part of C ++ 0x, which is implemented in Visual Studio 2010. Support is not ideal, such as when working with ‚Äúright-angle brackets‚Äù, but we will continue to work on supporting the C ++ 0x standard in future versions. <br><br>  In this article we will look at new features of the language, the support of which is implemented in the first edition of Visual Studio 2010. At the same time, we will look at these possibilities from different perspectives: what is a new feature, is there a connection with 64-bit errors, how was the new language supported in PVS-Studio and how its appearance affected the <a href="http://www.viva64.com/ru/vivacore-library/">VivaCore library</a> . <br><br>  <i>Note.</i>  <i>VivaCore is a library for parsing, analyzing and transforming code.</i>  <i>VivaCore is an open library and supports C and C ++ languages.</i>  <i>Based on VivaCore, the PVS-Studio product is built and other software projects can be created on its basis</i> . <br><br>  The article brought to your attention can be called a report on research and support of the new standard in PVS-Studio.  PVS-Studio tool diagnoses 64-bit and parallel <a href="http://www.viva64.com/terminology/OpenMP_rus.html">OpenMP</a> errors.  But since at the moment a more relevant topic is the transition to 64-bit systems, preference will be given to examples that demonstrate detection of <a href="http://www.viva64.com/terminology/64-bit_error_rus.html">64-bit errors</a> with PVS-Studio. <br><br><h2>  1. auto </h2><br>  In C ++, as in C, the variable type must be specified explicitly.  However, with the introduction of template types and templates of template metaprogramming in C ++, it is often the case that the type of an object is not so easy to write.  Even in a fairly simple case, when iterating over the elements of an array, we need an iterator type declaration of the form: <br><table><tbody><tr><td><pre> for (vector &lt;int&gt; :: iterator itr = myvec.begin (); 
      itr! = myvec.end (); 
      ++ itr) </pre></td></tr></tbody></table>  Such designs are very long and uncomfortable.  To shorten the record, you can use typedef, but this creates new entities and adds little in terms of convenience. <br><br>  C ++ 0x offers a way to mitigate this problem.  In the new standard, the value of the auto keyword will be replaced.  If earlier auto meant that a variable is being created on the stack, and implied implicitly if you did not specify something else (register, for example), now this is analogous to var in C # 3.0.  The type of a variable declared as auto is determined by the compiler itself based on what this variable is initialized to. <br><br>  It should be noted that the auto-variable will not be able to store values ‚Äã‚Äãof different types during one program run.  C ++ still remains a statically typed language, and the indication of auto only tells the compiler to take care of the type definition itself: after initialization, changing the type of the variable will no longer be possible. <br><br>  Now the iterator can be declared as follows: <br><table><tbody><tr><td><pre> for (auto itr = myvec.begin (); itr! = myvec.end (); ++ itr) </pre></td></tr></tbody></table>  In addition to ease of writing and simplifying code, the auto keyword helps make the code more secure.  Consider an example where auto will make code safe from the point of view of creating 64-bit applications: <br><table><tbody><tr><td><pre> bool Find_Incorrect (const string * arrStr, size_t n)
 {
   for (size_t i = 0; i! = n; ++ i)
   {
     unsigned n = arrStr [i] .find ("ABC");
     if (n! = string :: npos)
       return true;
   }
   return false;
 }; </pre></td></tr></tbody></table>  This code contains a 64-bit error.  The function behaves correctly when compiling a <a href="http://www.viva64.com/terminology/Win32_rus.html">Win32</a> version and fails when building in <a href="http://www.viva64.com/terminology/Win64_rus.html">Win64</a> mode.  The error lies in using the unsigned type for the variable ‚Äún‚Äù, although the type string :: size_type must be used, which is returned by the find () function.  In a 32-bit program, the type string :: size_type and unsigned are the same, and we get the correct results.  In the 64-bit program, string :: size_type and unsigned stop coinciding.  When the substring is not found, the find () function returns the value string :: npos equal to 0xFFFFFFFFFFFFFFFFui64.  This value is truncated to the value 0xFFFFFFFFu and placed in a 32-bit variable.  As a result, the condition 0xFFFFFFFFu == 0xFFFFFFFFFFFFFFFFui64 is false and it turns out that the Find_Incorrect function always returns true. <br><br>  In this example, the error is not so terrible, it is so detected even by the compiler and even more so by the specialized analyzer Viva64 (included in PVS-Studio). <br><br>  Compiler: <br><table><tbody><tr><td><pre> warning C4267: 'initializing': 
 conversion from 'size_t' to 'unsigned int', possible loss of data </pre></td></tr></tbody></table>  Viva64: <br><table><tbody><tr><td><pre> V103: Implicit type conversion from memsize to 32-bit type. </pre></td></tr></tbody></table>  More importantly, this error is possible and often occurs in the code due to inaccuracy when choosing a type to store the return value.  It is even possible that the error occurred due to the reluctance to use the cumbersome construction of the type string :: size_type. <br><br>  Now such errors are easy to avoid, without cluttering up the code.  Using the type of "auto" we can write the following simple and reliable code: <br><table><tbody><tr><td><pre> auto n = arrStr [i] .find ("ABC");
 if (n! = string :: npos)
   return true; </pre></td></tr></tbody></table>  The error disappeared by itself.  The code has not become more difficult or less effective.  Conclusion - the use of "auto" is rational in many cases. <br><br>  The ‚Äúauto‚Äù keyword will reduce the number of 64-bit errors or allow you to fix errors more gracefully.  But the use of ‚Äúauto‚Äù by itself does not at all relieve all 64-bit errors!  This is just another language tool that makes the programmer‚Äôs life easier, but doesn‚Äôt do all the type-control work for him.  Consider an example: <br><table><tbody><tr><td><pre> void * AllocArray3D (int x, int y, int z,
                    size_t objectSize)
 {
   int size = x * y * z * objectSize;
   return malloc (size);
 } </pre></td></tr></tbody></table>  The function must calculate the size of the array and allocate the necessary amount of memory.  It is logical to expect that in a 64-bit environment this function will be able to allocate memory for working with an array of 2000 * 2000 * 2000 type ‚Äúdouble‚Äù.  However, a call like ‚ÄúAllocArray3D (2000, 2000, 2000, sizeof (double));‚Äù will always return NULL, as if allocating such a memory is impossible.  The real reason why the function returns NULL is an overflow error in the expression "int size = x * y * z * sizeof (double)".  The variable ‚Äúsize‚Äù will take the value -424509440 and the further call to the malloc function does not make sense.  By the way, the compiler will also warn about the danger of this expression: <br><table><tbody><tr><td><pre> warning C4267: 'initializing': 
 conversion from 'size_t' to 'int', possible loss of data </pre></td></tr></tbody></table>  Hoping for ‚Äúauto‚Äù, an inaccurate programmer can modify the code as follows: <br><table><tbody><tr><td><pre> void * AllocArray3D (int x, int y, int z,
                    size_t objectSize)<font></font>
<font></font>
 {
   auto size = x * y * z * objectSize;
   return (double *) malloc (size);
 } </pre></td></tr></tbody></table>  However, this does not eliminate at all, but only disguises the error.  The compiler will no longer give a warning, but the AllocArray3D function will still return NULL. <br><br>  The type of the size variable will automatically become <a href="http://www.viva64.com/terminology/size_t_rus.html">size_t</a> .  But overflow occurs when evaluating the expression "x * y * z".  This subexpression has the type ‚Äúint‚Äù and only then the type will be expanded to ‚Äúsize_t‚Äù when multiplied by the variable ‚ÄúobjectSize‚Äù. <br><br>  Now this hidden error can be detected only using the Viva64 analyzer: <br><table><tbody><tr><td><pre> V104: Implicit type conversion to memsize type in an 
 arithmetic expression. </pre></td></tr></tbody></table>  Conclusion - using "auto", you should still be careful. <br><br>  Now let's take a quick look at how a new keyword was supported in the VivaCore library, on which the static analyzer Viva64 is built.  So, the analyzer should be able to understand that the variable AA has the type ‚Äúint‚Äù in order to warn (see <a href="http://www.viva64.com/content/PVS-Studio-help-ru/V101.html">V101</a> ) about the expansion of the variable AA to the type size_t: <br><table><tbody><tr><td><pre> void Foo (int X, int Y)
 {
   auto AA = X * Y;
   size_t BB = AA;  // V101
 } </pre></td></tr></tbody></table>  First of all, a new table of tokens was compiled, which included new C ++ 0x keywords.  This table is in the file Lex.cc and is named tableC0xx.  In order not to modify the old code by processing the token ‚Äúauto‚Äù (tkAUTO), the token ‚Äúauto‚Äù in this table is named tkAUTOcpp0x. <br><br>  In connection with the advent of the lexeme, the following functions were modified: isTypeToken, optIntegralTypeOrClassSpec.  There is a new class LeafAUTOc0xx.  In TypeInfoId, a new object class has appeared - AutoDecltypeType. <br><br>  To encode the type ‚Äúauto‚Äù, the letter 'x' is selected, which is reflected in the functions of the TypeInfo and Encoding classes.  This, for example, features such as IsAutoCpp0x, MakePtree. <br><br>  These fixes allow you to parse the code with the key "auto", which has a new meaning and save the type of objects in encoded form (the letter 'x').  However, this does not allow us to know which type the variable actually represents.  That is, there is no functionality in VivaCore, which allows to find out that in the expression ‚Äúauto AA = X * Y‚Äù the variable AA will have the type ‚Äúint‚Äù. <br><br>  This functionality is contained in the source code of Viva64 and is not included in the code of the VivaCore library.  The principle lies in the additional work of calculating the type in the TranslateAssignInitializer method.  After the right part of the expression is calculated, the connection (Bind) of the variable name with the type is changed. <br><br><h2>  2. decltype </h2><br>  In some cases it is useful to "copy" the type of some object.  The ‚Äúauto‚Äù keyword displays the type based on the expression used to initialize the variable.  If there is no initialization, then the keyword "decltype" can be used to determine the type of expression at compile time.  An example of code where the variable ‚Äúvalue‚Äù will have the type returned by the function ‚ÄúCalc ()‚Äù: <br><table><tbody><tr><td><pre> decltype (Calc ()) value;
 try {
   value = Calc (); 
 }
 catch (...) {
   throw;
 } </pre></td></tr></tbody></table>  You can use "decltype" for type declaration: <br><table><tbody><tr><td><pre> void f (const vector &lt;int&gt; &amp; a,
        vector &lt;float&gt; &amp; b)
 {
   typedef decltype (a [0] * b [0]) Tmp;
   for (int i = 0; i &lt;b.size (); ++ i)
   {
     Tmp * p = new Tmp (a [i] * b [i]);
     // ...
   }
 } </pre></td></tr></tbody></table>  Note that the type taken using decltype may differ from the type displayed by auto. <br><table><tbody><tr><td><pre> const std :: vector &lt;int&gt; v (1);
 auto a = v [0]; decltype (v [0]) b = 1;
 // type a - int  
 // type b - const int &amp; (return value
 // std :: vector &lt;int&gt; :: operator [] (size_type) const) </pre></td></tr></tbody></table>  Let's move on to an example where ‚Äúdecltype‚Äù can be useful from the point of view of 64 bits.  The IsPresent function searches for an element in the sequence and returns ‚Äútrue‚Äù if it is found: <br><table><tbody><tr><td><pre> bool IsPresent (char * array,
                size_t arraySize,
                char key)
 {
   for (unsigned i = 0; i &lt;arraySize; i ++) 
     if (array [i] == key)
       return true;
   return false;
 } </pre></td></tr></tbody></table>  This function is unable to work in a 64-bit system with large arrays.  If the variable arraySize has a value greater than UINT_MAX, then the condition "i &lt;arraySize" will never be fulfilled and an eternal loop will occur. <br><br>  If we use the "auto" keyword, this will not change anything: <br><table><tbody><tr><td><pre> for (auto i = 0; i &lt;arraySize; i ++) 
   if (array [i] == key)
     return true; </pre></td></tr></tbody></table>  The variable ‚Äúi‚Äù will be of type ‚Äúint‚Äù, since 0 is of type ‚Äúint‚Äù.  The correct fix is ‚Äã‚Äãto use decltype: <br><table><tbody><tr><td><pre> for (decltype (arraySize) i = 0; i &lt;arraySize; i ++) 
   if (array [i] == key)
     return true; </pre></td></tr></tbody></table> Now the ‚Äúi‚Äù counter has the ‚Äúsize_t‚Äù type as the ‚ÄúarraySize‚Äù variable. <br><br>  Support for ‚Äúdecltype‚Äù in the VivaCore library is in many ways similar to the support for ‚Äúauto‚Äù.  Added new lexeme tkDECLTYPE.  Added parsing function rDecltype in the Parser.cc file.  In connection with the advent of the modification, the optIntegralTypeOrClassSpec function has undergone a modification.  There was a new class LeafDECLTYPE. <br><br>  To encode the type returned by the decltype operator, the letter 'X' is selected (the capital letter 'X', as opposed to the capital 'x', used for auto).  In connection with this, the functionality of the TypeInfo and Encoding classes has changed.  For example, functions WhatIs, IsDecltype, MakePtree. <br><br>  The functionality for calculating types for the decltype operator is implemented in the Environment class and is part of the VivaCore library.  The type is calculated at the moment of writing a new variable / type in the Environment (functions RecordTypedefName, RecordDeclarator, RecordConstantDeclarator).  For calculating the type, the FixIfDecltype function is responsible. <br><br><h2>  3. Link to temporary object (R-value reference) </h2><br>  In the C ++ 98 standard, temporary objects can be passed to functions, but only as a constant reference (const &amp;).  Therefore, the function is not able to determine whether it is a temporary object or a normal one, which is also passed as const &amp;. <br><br>  In C ++ 0x, a new link type will be added - a link to a temporary object (R-value reference).  His announcement is: "TYPE_NAME &amp;&amp;".  It can be used as a non-constant, legally modifiable object.  This innovation allows you to take into account temporary objects and implement the transfer semantics (Move semantics).  For example, if std :: vector is created as a temporary object or returned from a function, you can create a new object by simply transferring all internal data from a new type of link.  The constructor of the transport std :: vector through the resulting link to a temporary object simply copies the array pointer located in the link, which at the end is set to an empty state. <br><br>  The transport constructor or transport operator can be declared as follows: <br><table><tbody><tr><td><pre> template &lt;class T&gt; class vector {
   // ...
   vector (const vector &amp;);  // copy constructor
   vector (vector &amp;&amp;);  // move constructor
   vector &amp; operator = (const vector &amp;);  // copy assignment
   vector &amp; operator = (vector &amp;&amp;);  // move assignment
 }; </pre></td></tr></tbody></table><br>  From the point of view of analysis of 64-bit errors in the code, it does not matter for us, it is processed when declaring the type '&amp;' or '&amp;&amp;'.  Accordingly, the support of this innovation in VivaCore is quite simple.  The changes affected only the optPtrOperator function of the Parser class.  In it, we equally perceive both '&amp;' and '&amp;&amp;'. <br><br><h2>  4. Right angle brackets </h2><br>  From the point of view of the C ++ 98 standard, the following construct contains a syntax error: <br><table><tbody><tr><td><pre> list &lt;vector &lt;string &gt;&gt; lvs; </pre></td></tr></tbody></table>  To prevent it, you need to insert a space between the two right closing angle brackets: <br><table><tbody><tr><td><pre> list &lt;vector &lt;string&gt;&gt; lvs; </pre></td></tr></tbody></table>  Standard C ++ 0x legitimized the use of double closing brackets when declaring template types, without the need to insert a space between them.  As a result, it becomes possible to write a little more elegant code. <br><br>  It is important to implement the support of this innovation in a static analyzer, since developers will be happy to stop writing extra spaces. <br><br>  At the moment, the analysis of template type declarations with "&gt;&gt;" is not well implemented in VivaCore so far.  In some cases, the analyzer is mistaken and, apparently, over time, the parts of the analyzer related to the template parsing will be substantially reworked.  While in the code you can see the following ugly functions that are trying to determine by heuristic methods, we are dealing with the shift operator "&gt;&gt;" or with a part of the type declaration of the type "A &lt;B &lt;C &gt;&gt; D": IsTemplateAngleBrackets, isTemplateArgs.  For those who are interested in how to approach this problem correctly, the following document will be useful: " <a href="http://www.viva64.com/go.php%3Furl%3D303">Right Angle Brackets (N1757)</a> ".  Over time, we will improve the processing of right-angle brackets in VivaCore. <br><br><h2>  5. Lambda functions (Lambdas) </h2><br>  Lambda expressions in C ++ is a short form of writing anonymous functors (objects that can be used as a function).  Consider a little story.  In C, function pointers are used to create functors: <br><table><tbody><tr><td><pre> / * callback function * /
 int compare_function (int A, int B) {
   return A &lt;B;
 }<font></font>
 <font></font>
 / * declaration of the sort function * /
 void mysort (int * begin_items,
             int num_items,
             int (* cmpfunc) (int, int));<font></font>
 <font></font>
 int main (void) {
     int items [] = {4, 3, 1, 2};
     mysort (items,
            sizeof (items) / sizeof (int),
            compare_function);
     return 0;
 } </pre></td></tr></tbody></table>  Earlier in C ++, a functor was created using a class that has operator () overloaded: <br><table><tbody><tr><td><pre> class compare_class {
   public:
   bool operator () (int A, int B) {
     return (A &lt;B);
   }
 };<font></font>
 	<font></font>
 // declaration of the sort function
 template &lt;class ComparisonFunctor&gt; 
 void mysort (int * begin_items,
              int num_items,
              ComparisonFunctor c);<font></font>
 <font></font>
 int main () {
     int items [] = {4, 3, 1, 2};
     compare_class functor;
     mysort (items,
     sizeof (items) / sizeof (int),
     functor);
 } </pre></td></tr></tbody></table>  In C ++ 0x, we get the ability to declare a functor even more elegantly: <br><table><tbody><tr><td><pre> auto compare_function = [] (char a, char b)
   {return a &lt;b;  };<font></font>
<font></font>
 char Str [] = "cwgaopzq";
 std :: sort (Str,
           Str + strlen (Str),
           compare_function);
 cout &lt;&lt; Str &lt;&lt; endl; </pre></td></tr></tbody></table>  We set the variable compare_function which is a functor and the type of which is determined by the compiler automatically.  Then we can pass this variable to std :: sort.  We can further shorten the code: <br><table><tbody><tr><td><pre> char Str [] = "cwgaopzq";
 std :: sort (
   Str,
   Str + strlen (Str),
   [] (char a, char b) {return a &lt;b;}
 );
 cout &lt;&lt; Str &lt;&lt; endl; </pre></td></tr></tbody></table>  Here "[] (char a, char b) {return a &lt;b;}" is nothing more than a lambda function. <br><br>  A lambda expression always starts with [] brackets, in which a capture list can be specified.  Then comes an optional parameter list and an optional return type.  The declaration ends directly with the function body.  In general, the format for writing lambda functions is as follows: <br><table><tbody><tr><td><pre> '[' [&lt;gripping_list&gt;] ']'
 ['(' &lt;list_of_parameters&gt; ')' ['mutable']]
 ['throw' '(' [&lt;types of exceptions&gt;] ')']
 ['-&gt;' &lt;return type&gt;]
 '{' [&lt;body_function&gt;] '}' </pre></td></tr></tbody></table>  The capture list indicates which objects from the outer scope are accessed by the lambda function: <br><ul><li>  [] - without capturing variables from outer scope; </li><li>  [=] - all variables are captured by value; </li><li>  [&amp;] - all variables are captured by reference; </li><li>  [x, y] - capture x and y by value; </li><li>  [&amp; x, &amp; y] - capture x and y by reference; </li><li>  [in, &amp; out] - capture in by value, and out - by reference; </li><li>  [=, &amp; out1, &amp; out2] - capture of all variables by value, except for out1 and out2, which are captured by reference; </li><li>  [&amp;, x, &amp; y] - capture all variables by reference, except x. </li></ul>  Unfortunately, in this article it is not possible to pay more attention to the lambda functions.  You can learn more about the lambda functions by visiting the resources listed in the bibliography at the end of the article.  As a demonstration of the use of lambda functions, we consider the code of a program that outputs lines in increasing order of their length. <br><br>  The program creates an array of strings and an array of indices.  Then, the program sorts the row indices in such a way that the rows are arranged by increasing their length: <br><table><tbody><tr><td><pre> int _tmain (int, _TCHAR * [])
 {
   vector &lt;string&gt; strings;
   strings.push_back ("lambdas");
   strings.push_back ("decltype");
   strings.push_back ("auto");
   strings.push_back ("static_assert");
   strings.push_back ("nullptr");<font></font>
<font></font>
   vector &lt;size_t&gt; indices;
   size_t k = 0;
   generate_n (back_inserter (indices),
              strings.size (),
              [&amp; k] () {return k ++;  });<font></font>
<font></font>
   sort (indices.begin (),
        indices.end (),
        [&amp;] (ptrdiff_t i1, ptrdiff_t i2)
        {return strings [i1] .length () &lt;
                 strings [i2] .length ();  });<font></font>
<font></font>
   for_each (indices.begin (),
            indices.end (),
            [&amp; strings] (const size_t i)
            {cout &lt;&lt; strings [i] &lt;&lt; endl;  });<font></font>
<font></font>
   return 0;
 } </pre></td></tr></tbody></table>  <i>Note According to C ++ 0x, you can initialize the std :: vector arrays as follows:</i> <br><table><tbody><tr><td><pre> vector &lt;size_t&gt; indices = {0,1,2,3,4}; </pre></td></tr></tbody></table>  <i>But while Visual Studio 2010 does not support such constructs.</i> <br><br>  The quality of the analysis of lambda functions in static analyzers must match the quality of the analysis of simple functions.  In general, the analysis of lambda functions is similar to the analysis of simple functions, except that the lambda functions have a different scope. <br><br>  PVS-Studio provides full error diagnostics in lambda functions.  Consider a sample code containing a 64-bit error: <br><table><tbody><tr><td><pre> int a = -1;
 unsigned b = 0;
 const char str [] = "Viva64";
 const char * p = str + 1;<font></font>
<font></font>
 auto lambdaFoo = [&amp;] () -&gt; char
   {
     return p [a + b];
   };<font></font>
<font></font>
 cout &lt;&lt; lambdaFoo () &lt;&lt; endl; </pre></td></tr></tbody></table>  This code works when compiling in Win32 mode and prints the letter 'V' on the screen.  In Win64 mode, the program crashes due to an attempt to access the element number 0xFFFFFFFF.  More details on this type of errors are described in the lessons on developing 64-bit C / C ++ applications - ‚Äú <a href="http://www.viva64.com/lessons-x64/13_Pattern_05_Address_arithmetic_rus.html">Lesson 13. Pattern 5. Address arithmetic</a> ‚Äù. <br><br>  When checking the above code, PVS-Studio displays a diagnostic message: <br><table><tbody><tr><td><pre> error V108: Incorrect index type: p [not a memsize-type].  Use memsize type instead. </pre></td></tr></tbody></table>  Accordingly, the analyzer had to parse the lambda function and deal with the scope of the variables.  Difficult, but necessary functionality. <br><br>  With the support of lambda functions the most significant changes in VivaCore are connected.  In the process of building <a href="http://www.viva64.com/terminology/Parse_tree_rus.html">a parse tree is</a> now involved a new function rLambdas.  The function is in the Parser class and is called from such functions as rInitializeExpr, rFunctionArguments, rCommaExpression.  The rLambdas function parses the lambda functions and adds a new type of object to the tree - PtreeLambda.  The PtreeLambda class is declared and implemented in the PtreeLambda.h and PtreeLambda files. <br><br>  PtreeLambda is processed in the constructed tree by the TranslateLambda function.  All logic on working with lambda functions is concentrated in VivaCore.  Inside TranslateLambda, you will encounter a call to the GetReturnLambdaFunctionTypeForReturn function implemented in the PVS-Studio code.  But this function serves for internal purposes PVS-Studio and the blank stub function GetReturnLambdaFunctionTypeForReturn in VivaCore will not affect the code analysis in any way. <br><br><h2>  6. Suffix return type syntax </h2><br>  There are cases when it is difficult to specify the type returned by the function.  Consider an example of a template function that multiplies two values: <br><table><tbody><tr><td><pre> template &lt;class T, class U&gt;
 ???  mul (T x, U y)
 {
   return x * y;
 } </pre></td></tr></tbody></table>  The type returned must be the type of the expression "x * y".  But it is not clear what can be written instead of "???".  The first idea might be to use ‚Äúdecltype‚Äù: <br><table><tbody><tr><td><pre> template &lt;class T, class U&gt;
 decltype (x * y) mul (T x, U y) // Scope problem!
 {
   return x * y;
 } </pre></td></tr></tbody></table>  The variables ‚Äúx‚Äù and ‚Äúy‚Äù are declared after ‚Äúdecltype (x * y)‚Äù and such code, unfortunately, cannot be compiled. <br><br>  The solution to this problem is to use the new syntax of returned values: <br><table><tbody><tr><td><pre> template &lt;class T, class U&gt;
 [] mul (T x, U y) -&gt; decltype (x * y)
 {
   return x * y;
 } </pre></td></tr></tbody></table>  Using brackets [] we generate a lambda function here and at the same time we say "the return type will be displayed or specified later."  Unfortunately, although the example is correct, it is not compiled in Visual C ++ at the time of writing.  However, we can use an alternative option (where Suffix return type syntax is also used): <br><table><tbody><tr><td><pre> template &lt;class T, class U&gt;
 auto mul (T x, U y) -&gt; decltype (x * y)
 {
   return x * y;
 } </pre></td></tr></tbody></table>  This code will be successfully compiled by Visual C ++ and we will get the desired result. <br><br>  In the PVS-Studio 3.50 version, support for the new format of functions is only partially implemented.  The constructions are completely understood by the VivaCore library, but PVS-Studio does not take into account the data types returned by these functions.  You can get acquainted with the support of alternative function recording in the VivaCore library in the Parser :: rIntegralDeclaration function. <br><br><h2>  7. static_assert </h2><br>  In the C ++ 0x standard, the new keyword static_assert has appeared.  Syntax: <br><table><tbody><tr><td><pre> static_assert (expression, "error message"); </pre></td></tr></tbody></table>  If the expression is false, the specified error message is displayed and the compilation is terminated.  Consider an example of using static_assert: <br><table><tbody><tr><td><pre> template &lt;unsigned n&gt;
 struct MyStruct
 {
   static_assert (n&gt; 5, "N must be more 5");
 };<font></font>
<font></font>
 MyStruct &lt;3&gt; obj; </pre></td></tr></tbody></table>  When compiling this code, the Visual C ++ compiler will display the message: <br><table><tbody><tr><td><pre> error C2338: N must be more 5
   xx.cpp (33): see reference to class template
   instantiation 'MyStruct &lt;n&gt;' being compiled 
   with
   [
     n = 3
   ] </pre></td></tr></tbody></table>  From the point of view of analyzing the code implemented by PVS-Studio, the static_assert construction is not of interest and therefore is ignored.  A new lexeme tkSTATIC_ASSERT has been added to VivaCore.  Encountering this lexeme, the lexer ignores it and all parameters related to the static_assert construction (implementation as Lex :: ReadToken). <br><br><h2>  8. nullptr </h2><br>  Prior to the C ++ 0x standard, C ++ did not have a keyword for the null pointer.  The number 0 was used to denote it. However, using the NULL macro was considered a good style.  When expanded, the NULL macro becomes 0, and there is no practical difference between them.  Here is how the NULL macro is declared in Visual Studio: <br><table><tbody><tr><td><pre> #define NULL 0 </pre></td></tr></tbody></table>  In some cases, the absence of a special keyword to indicate a null pointer was inconvenient and even provoked the occurrence of errors.  Consider an example: <br><table><tbody><tr><td><pre> void Foo (int a)
 {cout &lt;&lt; "foo (int a)" &lt;&lt; endl;  }<font></font>
<font></font>
 void Foo (char * a)
 {cout &lt;&lt; "foo (char * a)" &lt;&lt; endl;  }<font></font>
<font></font>
 int _tmain (int, _TCHAR * [])
 {
   Foo (0);
   Foo (null);
   return 0;
 } </pre></td></tr></tbody></table>  Although the programmer may expect that different functions of Foo will be called in this code, this is not so.  Instead of NULL, 0 having the type ‚Äúint‚Äù will be substituted and when the program is started, the screen will print: <br><table><tbody><tr><td><pre> Foo (int a)
 Foo (int a) </pre></td></tr></tbody></table>  To eliminate such situations, the nullptr keyword has been introduced in C ++ 0x.  The nullptr constant is of type nullptr_t and is implicitly cast to any pointer type or to a pointer to class members.  The nullptr constant is not implicitly cast to integer data types, except for the bool type. <br><br>  Let's go back to our example and add a call to the ‚ÄúFoo‚Äù function with the argument nullptr: <br><table><tbody><tr><td><pre> void Foo (int a)
 {cout &lt;&lt; "foo (int a)" &lt;&lt; endl;  }<font></font>
<font></font>
 void Foo (char * a)
 {cout &lt;&lt; "foo (char * a)" &lt;&lt; endl;  }<font></font>
<font></font>
 int _tmain (int, _TCHAR * [])
 {
   Foo (0);
   Foo (null);
   Foo (nullptr);
   return 0;
 } </pre></td></tr></tbody></table>  Now the screen will be printed: <br><table><tbody><tr><td><pre> Foo (int a)
 Foo (int a)
 Foo (char * a) </pre></td></tr></tbody></table>  Although the nullptr keyword is of no interest from the point of view of searching for 64-bit errors, it is necessary to support it when parsing code.  For this, a new lexeme tkNULLPTR has been added to VivaCore, as well as the class LeafNULLPTR.  Creating objects of type LeafNULLPTR occurs in the function rPrimaryExpr.  When calling the function LeafNULLPTR :: Typeof, the type ‚Äúnullptr‚Äù is encoded as ‚ÄúPv‚Äù, that is, ‚Äúvoid *‚Äù.  From the point of view of the existing tasks of analyzing the code in PVS-Studio this is enough. <br><br><h2>  9. New Standard Classes </h2><br>  The C ++ 0x standard introduces new standard classes related to namespace std.  A number of these classes are already supported in Visaul Studio 2010. Examples include: <br><ul><li>  std :: array; </li><li>  std :: shared_ptr; </li><li>  std :: regex. </li></ul><br>  Since the listed entities are ordinary template classes, their appearance did not require any modification of PVS-Studio or the VivaCore library. <br><br><h2>  10. New directions in the development of static code analyzers </h2><br>  In the end, I would like to note one interesting point related to the use of C ++ 0x.  New features of the language, on the one hand, correcting old defects, make the code safer and more efficient, but at the same time they also create new, as yet unknown traps, into which a programmer can fall.  True, I can not tell you anything about them. <br><br>  But it is possible to get into already known traps due to the fact that their diagnostics in new C ++ 0x constructions is implemented much worse or not implemented at all.  Consider a small example demonstrating the use of an uninitialized variable: <br><table><tbody><tr><td><pre> {
   int x;
   std :: vector &lt;int&gt; A (10);
   A [0] = x;  // Warning C4700
 }<font></font>
<font></font>
 {
   int x;
   std :: vector &lt;int&gt; A (10);
   std :: for_each (A.begin (), A.end (),
     [x] (int &amp; y)
     {y = x;  } // No Warning
   );
 } </pre></td></tr></tbody></table>  The programmer may hope to receive a warning from the compiler in both the first and second cases.  But in the example with the lambda function, no warning will be issued (tested on Visual Studio 2010 RC, / W4).  As before, there were not many other warnings to various dangerous situations.  It takes time to implement detailed diagnostics. <br><br>  We can expect a new round of development of static analyzers in terms of the search for potentially dangerous constructions that arise when using C ++ 0x constructs.  We position our product PVS-Studio as a tool for testing modern programs.  At the moment we understand this as 64-bit and parallel technologies.  In the future, we plan to conduct research into the question of what potential problems can be expected when using C ++ 0x.  If there are a lot of pitfalls, then maybe we will start creating a new tool for their diagnosis. <br><br><h2>  Conclusion </h2><br>  In our opinion, C ++ 0x introduces many positive points.  The old code does not require immediate upgrading, although it may be modified over time during refactoring.  The new code can already be written using new constructions.  Thus, the beginning of using C ++ 0x looks rational now. <br><br><h2>  Bibliographic list </h2><br><ol><li>  Bjarne Stroustrup.  C ++ 0x - the next ISO C ++ standard.  <a href="http://www.viva64.com/go.php%3Furl%3D304">http://www.viva64.com/go.php?url=304</a> </li><li>  Visual C ++ Team Blog.  Rvalue References: C ++ 0x Features in VC10, Part 2. <a href="http://www.viva64.com/go.php%3Furl%3D305">http://www.viva64.com/go.php?url=305</a> </li><li>  Sergey Olendarenko.  C ++ 0x.  Lambda expressions.  <a href="http://www.viva64.com/go.php%3Furl%3D306">http://www.viva64.com/go.php?url=306</a> </li><li>  Maksim.  C ++ 0x and solving initialization problems.  <a href="http://www.viva64.com/go.php%3Furl%3D307">http://www.viva64.com/go.php?url=307</a> </li><li>  Wikipedia.  C ++ 0x.  <a href="http://www.viva64.com/go.php%3Furl%3D301">http://www.viva64.com/go.php?url=301</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/89494/">https://habr.com/ru/post/89494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../89482/index.html">Epic fail of RSL</a></li>
<li><a href="../89483/index.html">I write a search engine (virtual project). Part 1 First bricks</a></li>
<li><a href="../89487/index.html">Flash Builder 4 and unit tests</a></li>
<li><a href="../89489/index.html">And again about MISS SYS</a></li>
<li><a href="../89491/index.html">The chat built into iGoogle and Orkut now transfers files</a></li>
<li><a href="../89495/index.html">Cybersquatters will present a passport on April 1</a></li>
<li><a href="../89499/index.html">Instructions for registration of "Experienced open source zones" in schools</a></li>
<li><a href="../89500/index.html">Bob Chronicles</a></li>
<li><a href="../89502/index.html">Sales of HTC Legend start in Russia!</a></li>
<li><a href="../89504/index.html">Solaris is no longer free</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>