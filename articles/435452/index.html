<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>End-to-end testing of microservices with Catcher</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! I would like to present a new tool for end-to-end testing of microservices - Catcher 

 Why test? 


 Why do you need e2e testing? Martin Fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>End-to-end testing of microservices with Catcher</h1><div class="post__text post__text-html js-mediator-article"><p>  Good day!  I would like to present a new tool for end-to-end testing of microservices - <a href="https://github.com/comtihon/catcher">Catcher</a> <br><img src="https://habrastorage.org/getpro/habr/post_images/593/124/ebb/593124ebb4c5078524f5313257efeebc.png" alt="logo"></p><br><h3 id="zachem-testirovat">  Why test? </h3><br><p>  Why do you need e2e testing?  Martin Fowler <a href="https://martinfowler.com/articles/microservice-testing/">recommends</a> avoiding it in favor of simpler tests. </p><a name="habracut"></a><br><p>  However, the higher the tests are - the less rewritten.  Unit tests are almost completely rewritten.  Functional tests also have to waste your time in the event of a serious refactoring.  End-to-end tests should check business logic, and it changes least of all. </p><br><p>  Moreover, even full coverage of all microservices with tests does not guarantee their correct interaction.  Developers may incorrectly implement the protocol (errors in the name / data type). </p><br><p>  Or implement a new functionality relying on the data schema from the documentation, and on the product environment get a surprise in the form of schema mismatch errors: a mess in the data or someone forgot to update the data schema. </p><br><p>  And the tests of each of the involved services will be green. </p><br><h3 id="a-zachem-avtomaticheskoe-testirovanie">  Why automatic testing? </h3><br><p>  Really.  At my previous place of work, it was decided that it was too long, difficult and expensive to spend time on deploying automatic tests.  The system is not large (10-15 microservices with a common hitch).  CTO decided that "tests are not important, the main thing is that the system worked."  Tested manually on multiple environments. </p><br><p>  What it looked like (general process): </p><br><ol><li>  Agree with other developers (rollout of all microservices participating in the new functionality) </li><li>  Roll out all services </li><li>  Connect to remote kafka (double ssh in dmz) </li><li>  Connect to k8s logs </li><li>  Manually create and send a message (thank God json) </li><li>  Watch the logs, trying to figure out whether it worked or not. </li></ol><br><p>  And now a little tar in this barrel with chocolate: most of the tests needed to create users, because it is difficult to reuse existing ones. </p><br><p>  Firstly, due to the fact that the system is distributed - several services had their own databases, which contained information about users. </p><br><p>  Secondly, Kafka was used for permanent data storage.  Those.  even if the information is deleted / changed in the database, the service will still read it back on restart. </p><br><p>  How did the registration of the new test user look (approximately): </p><br><ol><li>  Enter any data (name, mail, etc.) </li><li>  Enter personal data (address, phone number, any tax information) </li><li>  Input of bank data (actually, bank data) </li><li>  Answer 20-40 questions (do you already feel pain?) </li><li>  <a href="https://www.idnow.io/">Get IDNow</a> identification (on dev environment, thank God it was turned off, on stage it's around 5 minutes or more, because their sandbox is sometimes overloaded) </li><li>  At this step, opening an account in a third-party system is required and you can‚Äôt do anything through the front-end.  You need to go through ssh to the kafka and work as a mock server (send a message that the account is open) </li><li>  Next you need to go to another front-end in the personal account of the moderator and confirm the user. </li></ol><br><p>  Great, user is registered!  Now a little more tar: for some tests you need more than 1 test user.  And sometimes from the first time tests do not pass. </p><br><p>  And how is the verification of the new functionality and confirmation from the business team? <br>  All the same need to be repeated in the next environment. </p><br><p>  Do I have to say that after a while you begin to feel like a monkey, which only does what presses the buttons, registering users. </p><br><p>  Some other developers (usually the front-end) had problems connecting to the kafka.  And with a bug in the terminal with a line of 80+ characters (not everyone knew about tmux). </p><br><p>  <strong>Pros</strong> : </p><br><ul><li>  No need to configure / write.  Test directly on the running environment. </li><li>  does not require high qualification (cheaper specialists can do) </li></ul><br><p>  <strong>Cons</strong> : </p><br><ul><li>  takes a lot of time (the farther, the more) </li><li>  usually only new functionality is tested (it is not clear if the existing one is broken) </li><li>  Often skilled developers are busy in manual testing (expensive specialists do cheap work). </li></ul><br><h3 id="kak-avtomatizirovat">  How to automate? </h3><br><p>  If you read up to here nodding your head and saying: ‚Äúyes, an excellent process, guys know what they are doing,‚Äù then you will not be interested further. </p><br><p>  Self-made e2e tests are of two types and depend on which of the programmers was more free: </p><br><ul><li>  the backend that lives in your test environment.  It contains the logic of testing, which is twitching through endpoints.  It can even be partially automated due to its interaction with CI. </li><li>  The script, with the same wired logic.  The only difference is that you need to go somewhere and from there start it.  If you trust your CI, then you can even run it automatically. </li></ul><br><p>  Sounds good.  Problems? </p><br><p>  Yes, such tests are written on what the person who writes them knows.  Usually these are scripting languages ‚Äã‚Äãlike Ruby or Python, which allow you to quickly and simply write this kind of thing.  However, sometimes you can stumble upon a bunch of bash scripts, C or something more exotic (I spent a week rewriting the bike on bash scripts to a python, because the scripts were no longer extensible and no one really knew how they work or what they test) . <br>  Sample project <a href="https://github.com/comtihon/metrics">here</a> </p><br><p>  <strong>Pros</strong> : </p><br><ul><li>  automation </li></ul><br><p>  <strong>Cons</strong> : </p><br><ul><li>  additional requirements for the qualifications of developers are possible (if they are developed in Java, and the tests were written in Python) </li><li>  writing code to test written code (who will test the tests?) </li></ul><br><h3 id="est-chto-nibud-gotovoe">  Is there anything ready? </h3><br><p>  Of course, just look in the direction of <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> .  There is <a href="https://cucumber.io/">Cucumber</a> , there is <a href="https://www.gauge.org/">Gauge</a> . </p><br><p>  In short, the developer describes the business scenario in a special language, then it implements the script steps in the code.  The language is generally human readable and it is assumed that it will be read / written not only by developers, but also by project managers. </p><br><p>  The scenarios along with the implementation of the steps are also in a separate project and run by third-party products (Cucumber / Gauge / ...). </p><br><p>  The script looks like this: </p><br><pre><code class="plaintext hljs">Customer sign-up ================ * Go to sign up page Customer sign-up ---------------- tags: sign-up, customer * Sign up a new customer with name "John" email "jdoe@test.de" and "password" * Check if the sign up was successful</code> </pre> <br><p>  And implementation: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Step</span></span>(<span class="hljs-string"><span class="hljs-string">"Sign up as &lt;customer&gt; with email &lt;test@example.com&gt; and &lt;password&gt;"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String customer, String email, String password)</span></span></span><span class="hljs-function"> </span></span>{ WebDriver webDriver = Driver.webDriver; WebElement form = webDriver.findElement(By.id(<span class="hljs-string"><span class="hljs-string">"new_user"</span></span>)); form.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"user[username]"</span></span>)).sendKeys(customer); form.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"user[email]"</span></span>)).sendKeys(email); form.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"user[password]"</span></span>)).sendKeys(password); form.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"user[password_confirmation]"</span></span>)).sendKeys(password); form.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"commit"</span></span>)).click(); } <span class="hljs-meta"><span class="hljs-meta">@Step</span></span>(<span class="hljs-string"><span class="hljs-string">"Check if the sign up was successful"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSignUpSuccessful</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebDriver webDriver = Driver.webDriver; WebElement message = webDriver.findElements(By.className(<span class="hljs-string"><span class="hljs-string">"message"</span></span>)); assertThat(message.getText(), is(<span class="hljs-string"><span class="hljs-string">"You have been signed up successfully!"</span></span>)); }</code> </pre> <br><p>  Complete project <a href="https://github.com/getgauge-examples/java-maven-selenium">here</a> </p><br><p>  <strong>Pros</strong> : </p><br><ul><li>  business logic is described in human readable language and is stored in one place (can be used as documentation) </li><li>  ready-made solutions are used, developers only need to know how to use them </li></ul><br><p>  <strong>Cons</strong> : </p><br><ul><li>  managers will not read and write scripts </li><li>  you have to keep track of both the specifications and their implementation (and this is writing code and editing specifications) </li></ul><br><h3 id="nu-i-zachem-togda-catcher">  So why then the catcher? </h3><br><p>  Of course, to simplify the process. </p><br><p>  The developer writes only scripts in json / yaml, and Catcher executes them.  The script consists of sequentially executed steps, for example: </p><br><pre> <code class="plaintext hljs">steps: - http: post: url: '127.0.0.1/save_data' body: {key: '1', data: 'foo'} - postgres: request: conf: 'dbname=test user=test host=localhost password=test' query: 'select * from test where id=1'</code> </pre> <br><p>  Catcher supports jinja2 patterns, so you can use variables instead of wired values ‚Äã‚Äãin the example above.  Global variables can be stored in inventory files (as in an edible), pull up from the environment and register new ones: </p><br><pre> <code class="plaintext hljs">variables: bonus: 5000 initial_value: 1000 steps: - http: post: url: '{{ user_service }}/sign_up' body: {username: 'test_user_{{ RANDOM_INT }}', data: 'stub'} register: {user_id: '{{ OUTPUT.uuid }}' - kafka: consume: server: '{{ kafka }}' topic: '{{ new_users_topic }}' where: equals: {the: '{{ MESSAGE.uuid }}', is: '{{ user_id }}'} register: {balance: '{{ OUTPUT.initial_balance }}'}</code> </pre> <br><p>  Additionally, you can run verification steps: </p><br><pre> <code class="plaintext hljs">- check: # check user's initial balance equals: {the: '{{ balance }}', is: '{{ initial_value + bonus }}'}</code> </pre> <br><p>  You can also run some scripts from other scripts, which has a great effect on cleanliness and reuse of the code (including starting only parts of the steps through the tag system, deferred launch, etc. buns). </p><br><pre> <code class="plaintext hljs">include: file: register_user.yaml as: sign_up steps: # .... some steps - run: include: sign_up # .... some steps</code> </pre> <br><p>  Inserting and using scripts can solve the problem of waiting for a resource (wait for the service while it starts). </p><br><p>  In addition to ready-made built-in <a href="https://catcher-test-tool.readthedocs.io/en/latest/source/catcher.steps.html">steps</a> and an additional <a href="https://github.com/comtihon/catcher_modules">repository</a> , it is possible to write your own modules on python (simply by inheriting <a href="https://catcher-test-tool.readthedocs.io/en/latest/source/modules.html">ExternalStep</a> ) or in any other language: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash one=$(echo ${1} | jq -r '.add.the') two=$(echo ${1} | jq -r '.add.to') echo $((${one} + ${two}))</span></span></code> </pre> <br><p>  and use: </p><br><pre> <code class="plaintext hljs">--- variables: one: 1 two: 2 steps: - math: add: {the: '{{ one }}', to: '{{ two }}'} register: {sum: '{{ OUTPUT }}'}</code> </pre> <br><p>  Scripts are placed in the docker file and run through CI. </p><br><p>  This image can also be used in Marathon / K8s to test an existing environment.  At the moment I am working on a backend (analogue of AnsibleTower) to make the testing process even easier and more convenient. </p><br><p>  <strong>Pros</strong> : </p><br><ul><li>  no need to write code (only in case of custom modules) </li><li>  switching environments through inventory files (as in ansible) </li><li>  you can use your own modules (in any language, even sh) </li></ul><br><p>  <strong>Cons</strong> : </p><br><ul><li>  not human readable syntax (compared to BDD tools) </li></ul><br><h3 id="vmesto-zaklyucheniya">  Instead of conclusion </h3><br><p>  When I wrote this tool, I just wanted to reduce the time I usually spend on tests.  It so happened that in every new company you have to write (or rewrite) such a system. </p><br><p>  However, the tool turned out more flexible than I expected.  If someone is interested in an article (or the tool itself), I can tell you how to use Catcher for organizing centralized migrations and updating microservice systems. </p><br><h3 id="upd">  Upd </h3><br><p>  As I pointed out in the comments, the topic is not disclosed. <br>  I will try to indicate here the most controversial theses. </p><br><ul><li>  end-to-end tests are not unit tests.  I already referred to <a href="https://martinfowler.com/articles/microservice-testing/">M. Fowler</a> in this article.  Unit tests are in the test backend project (standard <code>tests</code> directory) and run every time the code changes to CI.  And e2e tests are a separate project, they usually run longer, test the interaction of all participating services and do not know anything about the code of your project (black box). </li><li>  do not use the Catcher for integration (and below) tests.  It is expensive.  It is much faster to write a test on your PL for the current backend.  You need end-to-end tests only if your business logic is spread over 2 or more services. </li><li>  Catcher is also BDD.  From my point of view, the main advantage over Gauge / Cucumber is ready-made modules and the ease of adding them.  Ideally, only the test is written.  In the last company I wrote all 4 tests on standard components, without programming anything.  Accordingly, the requirements for qualification (and the price of such a specialist) will be lower.  You only need to know json / yaml and the ability to read specifications. </li><li>  For writing Catcher tests, you will have to study Catcher-DSL.  Alas, it is true.  At first I wanted to make the tests themselves written directly from the microphone.  But then I thought that they would then dismiss me as unnecessary;) As mentioned above, the Catcher DSL is a standard json / yaml and specification of steps.  Nothing fundamentally new. </li><li>  You can use standard technology and write something of your own.  However, we are talking about microservices.  This is a large number of different technologies and PL and a large number of teams.  And if for the java-command junit + testcontainers is the obvious choice, the erlang command will choose something else.  In a large company with 30+ teams at the top, they will decide that all tests should be given to the new infrastructure / qa team.  Present how they will be delighted to this zoo? </li><li>  If you have 4-5 e2e tests, then you can write everything in any scripting language and forget about it.  However, if over time the logic will change, then in 2-4 years you will have to refactor, passing directly the business logic of the tests and the implementation of access methods to the components under test.  So in the end you will write your Catcher, just not so flexible.  It took me 4 implementations to understand this;) </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435452/">https://habr.com/ru/post/435452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435436/index.html">5 IT infrastructure trends: forecast for 2019</a></li>
<li><a href="../435442/index.html">Funnel change</a></li>
<li><a href="../435446/index.html">Verkhuffa algorithm for an arbitrary even number system</a></li>
<li><a href="../435448/index.html">About the experience of communicating with the signal generator through QTcpSocket and SCPI</a></li>
<li><a href="../435450/index.html">Happy new year with new MQTT / UDP</a></li>
<li><a href="../435454/index.html">AOP vs Functions</a></li>
<li><a href="../435462/index.html">Testing Node.js projects. Part 1. Anatomy of tests and types of tests</a></li>
<li><a href="../435464/index.html">Testing Node.js projects. Part 2. Evaluation of the effectiveness of tests, continuous integration and analysis of code quality</a></li>
<li><a href="../435466/index.html">React Tutorial, Part 6: Some Course, JSX, and JavaScript Features</a></li>
<li><a href="../435468/index.html">React Tutorial, Part 7: Inline Styles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>