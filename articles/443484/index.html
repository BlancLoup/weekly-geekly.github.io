<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>6 Nezhdanchikov from Julia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Finally, the Russian-language Julia language guide appeared. There is a full-fledged introduction to the language for those who have little experience...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>6 Nezhdanchikov from Julia</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/kk/lq/li/kklqliklumioy9-vmupwuq9afpc.png"></p><br><p>  Finally, the <a href="https://github.com/YermolenkoIgor/Julia_tutorial_rus">Russian-language Julia language guide</a> appeared.  There is a full-fledged introduction to the language for those who have little experience in programming (the rest will be useful for general development), there is also an introduction to machine learning and a lot of tasks for securing the material. </p><br><p>  While searching, I stumbled upon a <a href="https://lectures.quantecon.org/jl/">programming</a> course <a href="https://lectures.quantecon.org/jl/">for economists</a> (besides Julia, there is a Python).  Experienced can go through the <a href="http://bogumilkaminski.pl/files/julia_express.pdf">express course</a> or read the book <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">How to Think Like a Computer Scientist</a> </p><br><p>  The following is a translation of the material from the blog Christopher Rackauckas <a href="http://www.stochasticlifestyle.com/7-julia-gotchas-handle/">7 Julia Gotchas and How to Handle Them</a> </p><a name="habracut"></a><br><p> Let me start by saying that Julia is a wonderful language.  I love her, this is what I consider the most powerful and intuitive language I have ever used.  This is undoubtedly my favorite language.  However, there are some 'pitfalls', tricky little things you need to know about.  Every language has them, and one of the first things you need to do to master a language is to find out what they are and how to avoid them.  The point of this post is to help you speed up this process, exposing some of the most common <code></code> that offer alternative programming techniques. </p><br><p>  Julia is a good language for understanding what is happening, because there is no magic in it.  Julia's developers wanted clear rules of behavior.  This means that all behavior can be explained.  However, this may mean that you have to strain your head in order to understand why exactly this and not the other is happening.  This is why I‚Äôm not just going to pose some common problems, but I‚Äôm also going to explain why they arise.  You will see that there are some very similar patterns, and as soon as you become aware of them, you will no longer be intimidating of any of them.  Because of this, Julia has a slightly steeper learning curve compared to simpler languages, such as <em>MATLAB / R / Python</em> .  However, once you have mastered this, you can fully utilize Julia‚Äôs brevity in obtaining <em>C / Fortran</em> performance.  Now let's dig deeper. </p><br><h2 id="nezhdanchik-raz-repl-terminal-imeet-globalnuyu-oblast-vidimosti">  Times nezhdanchik: REPL (terminal) has a global scope </h2><br><p>  This is by far the most common problem reported by new Julia users.  Someone will say: ‚ÄúI heard Julia is fast!‚Äù, Will open the REPL, quickly write some familiar algorithm and execute this script.  After doing it, they look at the time and say: "Wait a second, why is it slow, like on Python?"  Since this is such an important and common problem, let's spend some time studying the reasons why this happens in order to understand how to avoid it. </p><br><h3 id="nebolshoe-otstuplenie-pochemu-dzhuliya-bystra">  A small digression: why is Julia quick </h3><br><p>  You have to understand that Julia is not only a compilation of code, but also a specialization of types (that is, a compilation of code that is specific to these types).  Let me repeat: Julia is not fast, because the code is compiled using the JIT compiler, rather the secret of speed is that the type-specific code is compiled. </p><br><p>  If you need a full story, check out some of the notes <a href="http://ucidatascienceinitiative.github.io/IntroToJulia/Html/WhyJulia">that I wrote for the upcoming seminar</a> .  Type specificity is determined by the basic design principle of Julia: <strong>multiple dispatching</strong> .  When you write code: </p><br><pre> <code class="plaintext hljs">function f(a,b) return 2a+b end</code> </pre> <br><p>  it seems that this is only one <code></code> , but in fact a large number of <code></code> are created here.  In the language of Julia, a function is an abstraction, and what is actually called is a method.  If you call <code>f(2.0,3.0)</code> , Julia will run the compiled code, which takes two floating-point numbers and returns the value <code>2a + b</code> .  If you call <code>f(2,3)</code> , then Julia will run another compiled code that takes two integers and returns the value <code>2a + b</code> .  The function <code>f</code> is an abstraction or abbreviation for many different methods that have the same form, and this scheme of using the <em>f</em> symbol to call all these different methods is called multiple scheduling.  And this applies everywhere: the <code>+</code> operator is actually a function that will call methods depending on the types it sees.  Julia actually gets its speed, because the code compiled by it knows its types, and therefore the compiled code that calls f (2.0,3.0) is the compiled code that you get by defining the same function in <em>C / Fortran</em> .  You can check this with the <code>code_native</code> macro to see the compiled assembly: </p><br><pre> <code class="plaintext hljs">@code_native f(2.0,3.0)</code> </pre> <br><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp Source line: 2 vaddsd %xmm0, %xmm0, %xmm0 vaddsd %xmm1, %xmm0, %xmm0 popq %rbp retq nop</code> </pre> <br><p>  This is the same compiled assembly that you expect from a function in <em>C / Fortran</em> , and it differs from the assembly code for integers: </p><br><pre> <code class="plaintext hljs">@code_native f(2,3) pushq %rbp movq %rsp, %rbp Source line: 2 leaq (%rdx,%rcx,2), %rax popq %rbp retq nopw (%rax,%rax)</code> </pre> <br><h4 id="sut-repl--global-scope-ne-dopuskaet-specifiku-tipov">  Essence: REPL / Global Scope does not allow type specifics </h4><br><p>  This brings us to the basic idea: REPL / Global Scope is slow because it does not allow type specification.  First of all, note that the REPL is a global scope, because Julia allows nested scope for functions.  For example, if we define </p><br><pre> <code class="plaintext hljs">function outer() a = 5 function inner() return 2a end b = inner() return 3a+b end</code> </pre> <br><p>  then we will see that this code works.  This is because Julia allows you to capture <code></code> from an external function into an internal function.  If you apply this idea recursively, you will realize that the highest area is the area that is the <strong>REPL itself</strong> (which is the global scope of the <strong>Main</strong> module).  But now let's think about how the function will be compiled in this situation.  We implement the same thing, but using global variables: </p><br><pre> <code class="plaintext hljs">a=2.0; b=3.0 function linearcombo() return 2a+b end ans = linearcombo()</code> </pre> <br><p>  and </p><br><pre> <code class="plaintext hljs">a = 2; b = 3 ans2= linearcombo()</code> </pre> <br><p>  Question: What types should the compiler take for <code>a</code> and <code>b</code> ?  Notice that in this example we changed the types and still called the same function.  It can deal with any types we add to it: floating, integers, arrays, strange user types, etc. In Julia, this means that the variables must be boxed, and the types are checked every time they are used.  What do you think the compiled code looks like? </p><br><div class="spoiler">  <b class="spoiler_title">Bulky</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $96, %rsp movl $2147565792, %edi # imm = 0x800140E0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, %rsi leaq -72(%rbp), %r14 movq $0, -88(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -72(%rbp) movq $0, -56(%rbp) movq $10, -104(%rbp) movq (%rsi), %rax movq %rax, -96(%rbp) leaq -104(%rbp), %rax movq %rax, (%rsi) Source line: 3 movq pcre2_default_compile_context_8(%rdi), %rax movq %rax, -56(%rbp) movl $2154391480, %eax # imm = 0x806967B8 vmovq %rax, %xmm0 vpslldq $8, %xmm0, %xmm0 # xmm0 = zero,zero,zero,zero,zero,zero,zero,zero,xmm0[0,1,2,3,4,5,6,7] vmovdqu %xmm0, -80(%rbp) movq %rdi, -64(%rbp) movabsq $jl_apply_generic, %r15 movl $3, %edx movq %r14, %rcx callq *%r15 movq %rax, %rbx movq %rbx, -88(%rbp) movabsq $586874896, %r12 # imm = 0x22FB0010 movq (%r12), %rax testq %rax, %rax jne L198 leaq 98096(%rdi), %rcx movabsq $jl_get_binding_or_error, %rax movl $122868360, %edx # imm = 0x752D288 callq *%rax movq %rax, (%r12) L198: movq 8(%rax), %rax testq %rax, %rax je L263 movq %rax, -80(%rbp) addq $5498232, %rdi # imm = 0x53E578 movq %rdi, -72(%rbp) movq %rbx, -64(%rbp) movq %rax, -56(%rbp) movl $3, %edx movq %r14, %rcx callq *%r15 movq -96(%rbp), %rcx movq %rcx, (%rsi) addq $96, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r14 popq %r15 popq %rbp retq L263: movabsq $jl_undefined_var_error, %rax movl $122868360, %ecx # imm = 0x752D288 callq *%rax ud2 nopw (%rax,%rax)</code> </pre> </div></div><br><p>  For dynamic languages ‚Äã‚Äãwithout type specialization, this bloated code with all the additional instructions is as good as it can be, so Julia slows down to their speed.  To understand why this is so important, note that each piece of code that you write in Julia is compiled.  Suppose you write a loop in your script: </p><br><pre> <code class="plaintext hljs">a = 1 for i = 1:100 a += a + f(a) end</code> </pre> <br><p>  The compiler will have to compile this cycle, but since it cannot guarantee that the types do not change, it conservatively winds the footcloth on all types, which leads to slow execution. </p><br><h4 id="kak-izbezhat-problemy">  How to avoid problems </h4><br><p>  There are several ways to avoid this problem.  The easiest way is to always wrap your scripts in a function.  For example, the previous code will look like this: </p><br><pre> <code class="plaintext hljs">function geta(a) # can also just define a=1 here for i = 1:100 a += a + f(a) end return a end a = geta(1)</code> </pre> <br><p>  This will give you the same result, but since the compiler may specialize in type <code>a</code> , it will provide the compiled code you want.  Another thing you can do is define your variables as constants. </p><br><pre> <code class="plaintext hljs">const b = 5</code> </pre> <br><p>  By doing this, you tell the compiler that the variable will not change, and thus it will be able to specialize all the code that uses it on the type that it is at present.  There is a slight fad that Julia actually allows you to change the value of a constant, but not the type.  Thus, you can use <code>const</code> to tell the compiler that you will not change the type.  However, note that there are some small quirks: </p><br><pre> <code class="plaintext hljs">const a = 5 f() = a println(f()) # Prints 5 a = 6 println(f()) # Prints 5 # WARNING: redefining constant a</code> </pre> <br><p>  this does not work as expected, because the compiler, realizing that it knows the answer to <code>f () = a</code> (since <code>a</code> is constant), simply replaced the function call with the answer, giving a different behavior than if <code>a</code> not constant. </p><br><p>  <strong>Moral: do not write your scripts directly in the REPL, always enclose them in a function.</strong> </p><br><h2 id="nezhdanchik-dva-nestabilnost-tipov">  Nezhdanchik two: type instability </h2><br><p>  So, I just expressed the opinion on how important code specialization is for data types.  Let me ask you a question, what happens when your types can change?  If you guessed it: ‚ÄúWell, in this case you cannot specialize the compiled code,‚Äù then you are right.  Such a problem is known as type instability.  They may appear differently, but one common example is that you initialize a value with a simple, but not necessarily the type that it should be.  For example, let's look at: </p><br><pre> <code class="plaintext hljs">function g() x=1 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Note that <code>1/2</code> is a floating point number in Julia.  Therefore, if we started with <code>x = 1</code> , the integer will change to a floating point number, and thus the function must compile the inner loop, as if it could be of any type.  If instead we had: </p><br><pre> <code class="plaintext hljs">function h() x=1.0 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  then the entire function can be optimally compiled, knowing that <code>x</code> will remain a floating point number (this ability for the compiler to define types is called type inference).  We can check the compiled code to see the difference: </p><br><div class="spoiler">  <b class="spoiler_title">Native footcloth</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r13 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $136, %rsp movl $2147565728, %ebx # imm = 0x800140A0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, -152(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -80(%rbp) movq $0, -64(%rbp) vxorps %ymm0, %ymm0, %ymm0 vmovups %ymm0, -128(%rbp) movq $0, -96(%rbp) movq $18, -144(%rbp) movq (%rax), %rcx movq %rcx, -136(%rbp) leaq -144(%rbp), %rcx movq %rcx, (%rax) movq $0, -88(%rbp) Source line: 4 movq %rbx, -104(%rbp) movl $10, %edi leaq 477872(%rbx), %r13 leaq 10039728(%rbx), %r15 leaq 8958904(%rbx), %r14 leaq 64(%rbx), %r12 leaq 10126032(%rbx), %rax movq %rax, -160(%rbp) nopw (%rax,%rax) L176: movq %rbx, -128(%rbp) movq -8(%rbx), %rax andq $-16, %rax movq %r15, %rcx cmpq %r13, %rax je L272 movq %rbx, -96(%rbp) movq -160(%rbp), %rcx cmpq $2147419568, %rax # imm = 0x7FFF05B0 je L272 movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %edx leaq -80(%rbp), %rcx movabsq $jl_apply_generic, %rax vzeroupper callq *%rax movq %rax, -88(%rbp) jmp L317 nopw %cs:(%rax,%rax) L272: movq %rcx, -120(%rbp) movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %r8d leaq -80(%rbp), %rdx movabsq $jl_invoke, %rax vzeroupper callq *%rax movq %rax, -112(%rbp) L317: movq (%rax), %rsi movl $1488, %edx # imm = 0x5D0 movl $16, %r8d movq -152(%rbp), %rcx movabsq $jl_gc_pool_alloc, %rax callq *%rax movq %rax, %rbx movq %r13, -8(%rbx) movq %rsi, (%rbx) movq %rbx, -104(%rbp) Source line: 3 addq $-1, %rdi jne L176 Source line: 6 movq -136(%rbp), %rax movq -152(%rbp), %rcx movq %rax, (%rcx) movq %rbx, %rax addq $136, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r13 popq %r14 popq %r15 popq %rbp retq nop</code> </pre> </div></div><br><p>  vs </p><br><div class="spoiler">  <b class="spoiler_title">Neat Assembly Spell</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp movabsq $567811336, %rax # imm = 0x21D81D08 Source line: 6 vmovsd (%rax), %xmm0 # xmm0 = mem[0],zero popq %rbp retq nopw %cs:(%rax,%rax)</code> </pre> </div></div><br><p>  Such a difference in the number of calculations to get the same value! </p><br><h4 id="kak-nayti-i-spravitsya-s-nestabilnostyu-tipov">  How to find and cope with type instability </h4><br><p><img src="https://habrastorage.org/webt/92/l8/sn/92l8sno_8hd-dho0limmkwerezs.jpeg"></p><br><p>  At this point, you may ask: "Well, why not just use <strong>C</strong> so that you do not have to look for these instabilities?"  The answer is: </p><br><ol><li>  Easy to find </li><li>  They may be helpful. </li><li><p>  You can handle instability with functional barriers. </p><br><p>  Julia gives you the macro <code>code_warntype</code> to show where the type instabilities are.  For example, if we use this in the <code>g</code> function we created: </p><br><pre> <code class="plaintext hljs">@code_warntype g()</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">get the analysis</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Variables: #self#::#g x::ANY #temp#@_3::Int64 i::Int64 #temp#@_5::Core.MethodInstance #temp#@_6::Float64 Body: begin x::ANY = 1 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#@_3::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#@_3::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 30 SSAValue(3) = #temp#@_3::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#@_3::Int64,1)) i::Int64 = SSAValue(3) #temp#@_3::Int64 = SSAValue(4) # line 4: unless (Core.isa)(x::UNION{FLOAT64,INT64},Float64)::ANY goto 15 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Float64, ::Int64) goto 24 15: unless (Core.isa)(x::UNION{FLOAT64,INT64},Int64)::ANY goto 19 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Int64, ::Int64) goto 24 19: goto 21 21: #temp#@_6::Float64 = (x::UNION{FLOAT64,INT64} / 2)::Float64 goto 26 24: #temp#@_6::Float64 = $(Expr(:invoke, :(#temp#@_5), :(Main./), :(x::Union{Float64,Int64}), 2)) 26: x::ANY = #temp#@_6::Float64 28: goto 5 30: # line 6: return x::UNION{FLOAT64,INT64} end::UNION{FLOAT64,INT64}</code> </pre> </div></div><br><p>  Notice that at the beginning we say that type x is <code>Any</code> .  It will use any type that is not designated as the <code>strict type</code> , that is, it is an abstract type that must be placed in the box / checked at each step.  We see that at the end we return <code>x</code> as <code>UNION {FLOAT64, INT64}</code> , which is another non-strict type.  This tells us that the type <code></code> has changed, causing difficulties.  If we instead look at the <code>code_warntype</code> for <code>h</code> , we get all the strict types: </p><br><pre> <code class="plaintext hljs">@code_warntype h() Variables: #self#::#h x::Float64 #temp#::Int64 i::Int64 Body: begin x::Float64 = 1.0 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 15 SSAValue(3) = #temp#::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#::Int64,1)) i::Int64 = SSAValue(3) #temp#::Int64 = SSAValue(4) # line 4: x::Float64 = (Base.box)(Base.Float64,(Base.div_float)(x::Float64,(Base.box)(Float64,(Base.sitofp)(Float64,2)))) 13: goto 5 15: # line 6: return x::Float64 end::Float64</code> </pre> <br><p>  This indicates that the function is stable in type and will be compiled essentially into the optimal <em>C-code</em> .  Thus, type instability is not difficult to find.  What's harder is finding the right design.  Why allow type instability?  This is a long-standing question that led to the fact that dynamically typed languages ‚Äã‚Äãdominate the playing field of scenarios.  The idea is that in many cases you want to find a compromise between performance and reliability. </p><br><p>  For example, you can read a table from a web page in which integers are mixed with floating-point numbers.  In Julia, you can write your function so that if they were all integers, it would compile well, and if they were all floating-point numbers, it would also compile well.  And if they are mixed?  It will still work.  This is the flexibility / convenience that we know and love from a language like <em>Python / R.</em>  But Julia will tell you directly ( <em>via code_warntype</em> ) when you sacrifice performance. </p><br><h3 id="kak-spravitsya-s-nestabilnostyami-tipov">  How to cope with type instability </h3><br><p><img src="https://habrastorage.org/webt/2s/9h/xg/2s9hxgty3fsdvuqf3a6ey05dxzs.png"></p><br><p>  There are several ways to cope with type instability.  First of all, if you like something like <em>C / Fortran</em> , where your types are declared and cannot change (which ensures the stability of types), you can do it in Julia: </p><br><pre> <code class="plaintext hljs">local a::Int64 = 5</code> </pre> <br><p>  This makes <code>a</code> 64-bit integer, and if future code tries to change it, an error message will be displayed (or the correct conversion will be performed. But since the conversion will not be automatically rounded, it will most likely cause errors).  Sprinkle them around your code, and you will get type stability, ala, <em>C / Fortran</em> .  A less complicated way to handle this is with type statements.  Here you put the same syntax on the other side of the equal sign.  For example: </p><br><pre> <code class="plaintext hljs">a = (b/c)::Float64</code> </pre> <br><p>  It seems to say: "calculate b / c and make sure that Float64 is output. If this is not the case, try automatic conversion. If the conversion cannot be easily performed, output an error".  Placing such constructions will help you make sure that you know which types are involved.  However, in some cases type instability is necessary.  For example, let's say you want to have a reliable code, but the user gives you something crazy, like: </p><br><pre> <code class="plaintext hljs">arr = Vector{Union{Int64,Float64}}(undef, 4) arr[1]=4 arr[2]=2.0 arr[3]=3.2 arr[4]=1</code> </pre> <br><p>  which is an array of 4x1 integers and floating point numbers.  The actual element type for the array is <code>Union {Int64, Float64}</code> , which, as we saw earlier, was loose, which could lead to problems.  The compiler knows only that each value can be an integer or floating point number, but not what element of which type.  This means that it is naive to perform arithmetic with this array, for example: </p><br><pre> <code class="plaintext hljs">function foo{T,N}(array::Array{T,N}) for i in eachindex(array) val = array[i] # do algorithm X on val end end</code> </pre> <br><p>  will be slow since the operation will be boxed.  However, we can use multiple dispatching to run codes in a specialized way.  This is known as the use of functional barriers.  For example: </p><br><pre> <code class="plaintext hljs">function inner_foo{T&lt;:Number}(val::T) # Do algorithm X on val end function foo2{T,N}(array::Array{T,N}) for i in eachindex(array) inner_foo(array[i]) end end</code> </pre> <br><p>  Note that due to multiple dispatch, the call to <code>inner_foo</code> calls either a method specifically compiled for floating-point numbers, or a method specially compiled for integers.  Thus, you can put a long calculation in <code>inner_foo</code> and at the same time make it work well, without yielding to the strict typing that the functional barrier gives you. </p><br><p>  So I hope that you see that Julia offers a good combination of strong typing performance and dynamic typing convenience.  A good programmer, Julia, has at his disposal both that and the other, in order to maximize productivity and / or performance if necessary. </p><br><h3 id="nezhdanchik-3-eval-rabotaet-na-globalnom-urovne">  Nezhdanchik 3: Eval works globally </h3><br><p><img src="https://habrastorage.org/webt/vs/5d/p2/vs5dp2t9wel5mbje-ewldc3fxne.jpeg"></p><br><p>  One of the greatest strengths of Julia is her metaprogramming capabilities.  This allows you to easily write a program that generates code, effectively reducing the amount of code you need to write and maintain.  A macro is a function that runs at compile time and (usually) spits out code.  For example: </p><br><pre> <code class="plaintext hljs">macro defa() :(a=5) end</code> </pre> <br><p>  will replace any instance of <code>defa</code> with the code <code>a = 5</code> ( <code>:(a = 5)</code> is the <em>quoted expression</em> . Julia's code is expressions, and therefore metaprogramming is an assembly of expressions). </p><br><p>  You can use this to build any complex Julia program you want and put it into a function as a type of really smart abbreviation.  However, sometimes you may need to directly evaluate the generated code.  Julia gives you the <code>eval</code> function or the <code>@eval</code> macro for this.  In general, you should try to avoid <code>eval</code> , but there are some codes where necessary, for example, <a href="">my new library for transferring data between different processes for parallel programming</a> .  However, note that if you use it: </p><br><pre> <code class="plaintext hljs">@eval :(a=5)</code> </pre> <br><p>        (REPL).    ,      / .  For example: </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) return 2a+5 end</code> </pre> <br><p>     ,   <code>a</code>      REPL.   , ,       : </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) b = a::Int64 return 2b+5 end</code> </pre> <br><p>  <code>b</code> ‚Äî   ,     ,     , ,  ,          .     <code>eval</code>  ,    ,     <code>REPL</code> . </p><br><h3 id="nezhdanchik-4-kak-razbivat-vyrazheniya">  4:    </h3><br><p>  Julia   ,     .        :    ,    . </p><br><p>  , ?  ,   ,   .  For example: </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 +8 + 9 + 10+ 11+ 12+ 13 a</code> </pre> <br><p> ,      90,     27. ?  <code>a = 2 + 3 + 4 + 5 + 6 + 7</code>   ,      <code>a = 27</code> ,     <code>+8 + 9 + 10+ 11+ 12+ 13</code> ,   ,    ,    : </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10+ 11+ 12+ 13</code> </pre> <br><p>   90,   .         ,   . </p><br><blockquote>              .   ‚Äî     ,       . <a href="https://habr.com/ru/users/rssdev10/" class="user_link">rssdev10</a> </blockquote><p>       .  For example: </p><br><pre> <code class="plaintext hljs">x = rand(2,2) a = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)] b = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) - sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)]</code> </pre> <br><p>     ,  a  b ‚Äî     ,    !    (2,2) ,   ‚Äî (1-)   2.  ,   ,    : </p><br><pre> <code class="plaintext hljs">a = [1 -2] b = [1 - 2]</code> </pre> <br><p>      : <code>1</code>  <code>-2</code> .    : <code>1-2</code> .  -     .    : </p><br><pre> <code class="plaintext hljs">a = [1 2 3 -4 2 -3 1 4]</code> </pre> <br><p>    2x4.   ,    .      :        <code>hcat</code> : </p><br><pre> <code class="plaintext hljs">a = hcat(cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi),-sin(2.*x[:,1]).*sin(2.*x[:,2])./(4))</code> </pre> <br><p>  ! </p><br><h3 id="podvodnyy-kamen-5-predstavleniya-kopirovanie-i-glubokaya-kopiya">   ‚Ññ5: ,     </h3><br><p><img src="https://habrastorage.org/webt/wh/xj/8f/whxj8fg_es5hmuoky6ixtzneat0.jpeg"></p><br><blockquote> <strong> (View)</strong> ‚Äî  () ,     (  ),        . <br><br>       ,       ,   .       ,    .            ,     . </blockquote><p>         ‚Äî   "". ""     <code></code>    ,     . ""  ‚Äî      (    ).    (  <em>()</em> ) . ,     : </p><br><pre> <code class="plaintext hljs">a = [3;4;5] b = a b[1] = 1</code> </pre> <br><p>     ,  <code>a</code> ‚Äî   <code>[1; 4; 5]</code> , . .  <code>b</code>  <code>a</code> .   ,  <code>b = a</code>   <code>b</code>   <code>a</code> .         , ,    <code>b</code> ,    ,          (   <code>b</code>  <code>a</code> ).   ,            . ,        , : </p><br><pre> <code class="plaintext hljs">a = rand(2,2) # Makes a random 2x2 matrix b = vec(a) # Makes a view to the 2x2 matrix which is a 1-dimensional array</code> </pre> <br><p>  <code>b</code>  ,   <code>b</code>    <code>a</code> ,  <code>b</code>    .  ,       ,        ( ,         ).   .  ,          .  For example: </p><br><pre> <code class="plaintext hljs">c = a[1:2,1]</code> </pre> <br><p>        <code></code> ( ,  <code>c</code>   <code>a</code> ).     ,   ,      ,   ,   .  ,        , : </p><br><pre> <code class="plaintext hljs">d = @view a[1:2,1] e = view(a,1:2,1)</code> </pre> <br><p>  <code>d</code> ,  <code>e</code> ‚Äî     ,   <code>d</code>  <code>e</code>  <code>a</code> ,       ,     ,       <code></code> . ( ,   , ‚Äî  <code>reshape</code> ,     .)     ,   .  For example: </p><br><pre> <code class="plaintext hljs">a[1:2,1] = [1;2]</code> </pre> <br><p>  <code>a</code> ,      <code>a[1:2,1]</code>   <code>view (a, 1:2,1)</code> ,      ,   <code>a</code> .   -? ,     : </p><br><pre> <code class="plaintext hljs">b = copy(a)</code> </pre> <br><p> ,  <code>b</code>   <code>a</code> ,   ,  <code>b</code>   <code>a</code> .     <code>a</code> ,    <code>copy! (B, a)</code>  ,           <code>a</code>   <code>a</code> (   ,  <code>b</code>       ).        . , <code>Vector {Vector}</code> : </p><br><pre> <code class="plaintext hljs">a = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]</code> </pre> <br><p>   <code></code>  .  ,   ? </p><br><pre> <code class="plaintext hljs">b = copy(a) b[1][1] = 10 a</code> </pre> <br><pre> <code class="plaintext hljs">3-element Array{Array{Int64,1},1}: [10, 2, 3] [4, 5] [6, 7, 8, 9]</code> </pre> <br><p>  ,     <code>a[1][1]</code>  10!   ?   <code>copy</code>    <code>a</code> .   <code>a</code>  ,         <code>b</code> ,  <code>b</code>      .   ,  <code>deepcopy</code> : </p><br><pre> <code class="plaintext hljs">b = deepcopy(a)</code> </pre> <br><p>      ,     .  ,         ,      . </p><br><h3 id="golovnaya-bol-6-vremennye-raspredeleniya-vektorizaciya-i-funkcii-in-place">   ‚Ññ6:  ,    In-Place </h3><br><p>  <em>MATLAB / Python / R</em>    .  Julia , , ,  "  ".    <code> </code> (. .    ,   , ,   ,        ).               (in-place),   .       ?  in-place ( <em>mutable function</em> ) ‚Äî  ,   ,    .       ,                 . ,   : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x = x + inner(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>   ,   <code>inner</code> ,     ,    <code>2x</code> . ,       .  ,       - <code>y</code> ,      : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] y = Vector{Int64}(3) for i = 1:10 inner(y,x) for i in 1:3 x[i] = x[i] + y[i] end copy!(y,x) end return x end function inner!(y,x) for i=1:3 y[i] = 2*x[i] end nothing end</code> </pre> <br><p>  . <code>inner!(y, x)</code>   ,   <code>y</code> .  <code>y</code>  ,  <code>y</code>     , ,       , <code>inner! (y, x)</code>  <code></code>   <code></code> . ,   ,  mutable (,  "").     <code>!</code>      (   ). </p><br><p>  ,   <code>inner!(y, x)</code>   .    <code>copy!(y, x)</code> ‚Äî   ,    <code>x</code>  <code>y</code> ,  .  ,  ,       .    :    <code>x</code>     <code>y</code> .       ,   <code>x + inner(x)</code> , ,  ,      11 .     ,     . </p><br><p> ,     ,    ,     .  -     ( <em>loop-fusion</em> ).   Julia v0.5    <code>.</code>      (    ( <em>broadcast</em> ),         <code></code> ).  ,  <code>f.(x)</code> ‚Äî    ,   <code>f</code>    <code>x</code> ,   ,   .     <code>f</code>  <code>x</code>    ,  <code>x = x + f. (x)</code>   .          : </p><br><pre> <code class="plaintext hljs">x .= x .+ f.(x)</code> </pre> <br><p> <code>.=</code>    ,   ,  ,   </p><br><pre> <code class="plaintext hljs">for i = 1:length(x) x[i] = x[i] + f(x[i]) end</code> </pre> <br><p>  ,       : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x .= x .+ inner.(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>         <em>MATLAB / R / Python</em> ,        , ,  .      <code>  </code> ,     ,  <em>C / Fortran</em> . </p><br><h3 id="vyvod-vyuchite-pravila-poymite-ih-i-kataytes-kak-syr-v-masle"> :  ,         </h3><br><p>   :     ,   .   ,      .  ,        .   ,     ,     .     ,    . </p><br><p>    -   ,      <em>C / Fortran</em> ,           .    -  ,        ,   ! </p><br><p>   :     ?  ,       .  ,  ,       ? [    ,   Javascript   <code>var x = 3</code>  <code>x</code> ,  <code>x = 3</code>  <code>x</code> .    ?     , -       Javascript!] </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443484/">https://habr.com/ru/post/443484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443472/index.html">Has the challenge come to the cloud? 7 tips on how not to mess up</a></li>
<li><a href="../443476/index.html">How SimCity inspired a whole generation of city planners</a></li>
<li><a href="../443478/index.html">Synthetic vs real test data: pros, cons, pitfalls</a></li>
<li><a href="../443480/index.html">PKCS # 11 cryptographic tokens: viewing and exporting certificates, checking their validity</a></li>
<li><a href="../443482/index.html">AIOps in practice - what can Huawei FabricInsight</a></li>
<li><a href="../443486/index.html">ReLEx SMILE: How not to be mistaken in forecasts</a></li>
<li><a href="../443488/index.html">Functional components with React Hooks. How are they better?</a></li>
<li><a href="../443490/index.html">Why am I closing my work on Debian</a></li>
<li><a href="../443494/index.html">Hyde: How to get SaaS product to AppSumo - successes and some mistakes</a></li>
<li><a href="../443502/index.html">Why exactly 4 years ago NASA shot Atlas V rocket at the night sky of Cape Canaveral?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>