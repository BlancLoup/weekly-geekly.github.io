<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generate 3D grids with predefined surface regions using NetGen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In a previous post, we looked at the features of using third-party open source libraries Freefem ++ and NetGen in an aerodynamic proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generate 3D grids with predefined surface regions using NetGen</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In a previous <a href="http://habrahabr.ru/post/181263/">post,</a> we looked at the features of using third-party open source libraries Freefem ++ and NetGen in an aerodynamic process modeling program.  It was about the possibility of including these libraries in a commercial project from a licensing point of view, about the features of the performance of functions and inclusion in the software architecture.  This article is an addition to the previous one, in which we take a closer look at the NetGen library.  Of interest are the functions of generating a 3D finite element mesh with specified regions on the model surface. <br><a name="habracut"></a><br><h4>  NetGen connection in MS Visual Studio </h4><br>  We show how you can connect NetGen to a C ++ program.  From the official <a href="http://sourceforge.net/projects/netgen-mesher/">site of the project NetGen</a> download archive.  In our case, NetGen version 4.9.13 was available.  To connect the library, you need three folders from the archive: libsrc, nglib, windows.  In Visual Studio, we create a project and solution for the demo program and include the existing nglib.vcxproj project file from the windows folder.  Since in our experiment the nglib project was created in an earlier version of Visual Studio, we are simultaneously converting the project to a new version.  In the nglib project settings, add the libsrc \ include include folder, add the NO_PARALLEL_THREADS symbol, remove pthreadVC2.lib from the additional linker dependencies, delete the linker post event, and set up the target folders so that the project is assembled without errors. <br><br>  The inclusion of the nglib.h header file should be recorded in the following not very familiar way: <br><br><pre> namespace nglib
 {
 #include "nglib.h"
 }
 using namespace nglib; </pre><br><h4>  Test model </h4><br>  The space that must be filled with finite elements can be defined for NetGen in two ways: <br><ol><li>  In the form of constructive block geometry operators (CSG). </li><li>  In the form of a description of the boundary of space in the file format STL. </li></ol><br>  Here we consider only the second variant of the surface description - the description of the three-dimensional model in the text format STL.  The graphic image of the test model is shown in Fig.  1. The model is a parallelepiped of 10 X 10 X 5. On one of the faces there is a rectangular region of 5 X 2 with an offset (4; 2), the boundaries of which must remain unchanged <br><img src="https://habrastorage.org/storage2/b5a/407/726/b5a407726227aafc76f37c326bca4b34.gif" alt="image"><br>  <i>Fig.</i>  <i>1. Surface triangulation to form an STL file.</i>  <i>Red color indicates the region, the boundaries of which should remain unchanged.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Below is the contents of the STL file describing the test model: <br><pre> solid
 facet normal 1 0 0 outer loop vertex 10 4 2 vertex 10 6.5 3 vertex 10 4 4 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 6.5 3 vertex 10 9 4 vertex 10 4 4 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 9 2 vertex 10 6.5 3 vertex 10 4 2 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 9 2 vertex 10 9 4 vertex 10 6.5 3 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 0 5 vertex 10 0 0 vertex 10 4 2 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 4 2 vertex 10 4 4 vertex 10 0 5 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 10 5 vertex 10 0 5 vertex 10 4 4 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 9 4 vertex 10 10 5 vertex 10 4 4 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 9 2 vertex 10 10 5 vertex 10 9 4 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 10 0 vertex 10 10 5 vertex 10 9 2 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 10 0 vertex 10 9 2 vertex 10 4 2 endloop endfacet
 facet normal 1 0 0 outer loop vertex 10 10 0 vertex 10 4 2 vertex 10 0 0 endloop endfacet
 facet normal -1 0 0 outer loop vertex 0 10 5 vertex 0 10 0 vertex 0 0 5 endloop endfacet
 facet normal -1 0 0 outer loop vertex 0 0 0 vertex 0 0 5 vertex 0 10 0 endloop endfacet
 facet normal 0 -1 0 outer loop vertex 0 0 5 vertex 0 0 0 vertex 10 0 5 endloop endfacet
 facet normal 0 -1 0 outer loop vertex 10 0 0 vertex 10 0 5 vertex 0 0 0 endloop endfacet
 facet normal 0 1 0 outer loop vertex 10 10 5 vertex 10 10 0 vertex 0 10 5 endloop endfacet
 facet normal 0 1 0 outer loop vertex 0 10 0 vertex 0 10 5 vertex 10 10 0 endloop endfacet
 facet normal 0 0 1 outer loop vertex 0 0 5 vertex 10 0 5 vertex 0 10 5 endloop endfacet
 facet normal 0 0 1 outer loop vertex 10 10 5 vertex 0 10 5 vertex 10 0 5 endloop endfacet
 facet normal 0 0 -1 outer loop vertex 10 0 0 vertex 0 0 0 vertex 10 10 0 endloop endfacet
 facet normal 0 0 -1 outer loop vertex 0 10 0 vertex 10 10 0 vertex 0 0 0 endloop endfacet
 endsolid </pre><br>  The information in the STL file has the following format.  At the beginning and end of the file the keywords solid and endsolid are specified, between which are listed the triangles defining the required surface in the format: <br><pre> facet normal nx ny nz 
 outer loop 
 vertex v1x v1y v1z 
 vertex v2x v2y v2z 
 vertex v3x v3y v3z 
 endloop 
 endfacet </pre>  where nx, ny, nz are the components of the normal vector along the X, Y, Z axes, directed outward from the simulated object;  (v1x, v1y, v1z), (v2x, v2y, v2z), (v3x, v3y, v3z) are the coordinates of the three vertices of the triangle. <br><br><h4>  An example of a program that generates a finite element mesh </h4><br>  Below is the text of the program that performs all the actions necessary to obtain a finite element mesh.  This program reads the OneRegionBar.stl STL file and writes the finite element mesh to the OneRegionBar.vol file. <br><br><pre> #include "stdafx.h"
 #include &lt;iostream&gt;
 #include &lt;fstream&gt;

 namespace nglib
 {
 #include ".. \ NetGen \ nglib \ nglib.h"
 }

 using namespace std;
 using namespace nglib;

 void main ()
 {
	 const char * stlFileName = ".. \\ Data \\ OneRegionBar.stl";
	 const char * volFileName = ".. \\ Data \\ OneRegionBar.vol";

	 // Edges on the surface
	 const int EDGES_NUM = 4;
	 const int POINTS_NUM = 4;
	 typedef double Point [3];
	 Point points [POINTS_NUM] = {{10, 4, 2}, {10, 9, 2}, {10, 9, 4}, {10, 4, 4}};
	 typedef pair &lt;int, int&gt; Edge;
	 Edge edges [EDGES_NUM] = {Edge (0,1), Edge (1, 2), Edge (2,3), Edge (3, 0)};

	 // Grid generation parameters
	 Ng_Meshing_Parameters ngMeshParameters;
	
	 ngMeshParameters.maxh = 10; 
	 ngMeshParameters.fineness = 0.4;
	 ngMeshParameters.secondorder = 0;
	 ngMeshParameters.quad_dominated = 0;

	 ngMeshParameters.grading = 0.0;
	 ngMeshParameters.optsurfmeshenable = false;
	 ngMeshParameters.optsteps_2d = 0;
	 ngMeshParameters.closeedgeenable = false;

	 // The result of the operations
	 Ng_Result ng_res;

	 //
	 // Start grid building
	 //

	 // Reading the STL file, creating the object "STL-geometry"
	 Ng_STL_Geometry * stlGeometry = Ng_STL_LoadGeometry (stlFileName);

	 // Adding unchangeable edges to the "geometry"
	 for (int i = 0; i &lt;EDGES_NUM; i ++)
	 {
		 double * p1 = points [edges [i] .first];
		 double * p2 = points [edges [i] .second];
		 Ng_STL_AddEdge (stlGeometry, p1, p2);
	 }

	 // Initialize an object with an STL description
	 ng_res = Ng_STL_InitSTLGeometry (stlGeometry);
	 if (ng_res! = NG_OK)
	 {
		 cout &lt;&lt; "Error in Ng_STL_InitSTLGeometry" &lt;&lt; endl;
	 }

	 // For now, an empty element mesh object
   	 Ng_Mesh * mesh = Ng_NewMesh ();

	 // Build edges on model surface
	 ng_res = Ng_STL_MakeEdges (stlGeometry, mesh, &amp; ngMeshParameters);
	 if (ng_res! = NG_OK)
	 {
		 cout &lt;&lt; "Error in Ng_STL_MakeEdges" &lt;&lt; endl;
	 }

	 // Generate space surface
	 ng_res = Ng_STL_GenerateSurfaceMesh (stlGeometry, mesh, &amp; ngMeshParameters);
	 if (ng_res! = NG_OK)
	 {
		 cout &lt;&lt; "Error in Ng_STL_GenerateSurfaceMesh" &lt;&lt; endl;
	 }

	 // Generate Finite Element Network
	 ng_res = Ng_GenerateVolumeMesh (mesh, &amp; ngMeshParameters);
	 if (ng_res! = NG_OK)
	 {
		 cout &lt;&lt; "Error in Ng_GenerateVolumeMesh" &lt;&lt; endl;
	 }

	 // Save Finite Element Mesh To File
	 Ng_SaveMesh (mesh, volFileName);
 } </pre><br>  Next we give detailed comments on the program text: <br><ol><li>  The coordinates of the points that are the edges of the edges are in the points [POINTS_NUM] array.  In the array of edges [EDGES_NUM], the edges of the surface region are specified as the corresponding pairs of point numbers.  These edges will need to be specified by NetGen so that they remain on the surface of the model. <br></li><li>  The grid generation process is controlled using parameters collected in the ngMeshParameters object of the Ng_Meshing_Parameters class.  One of the parameters - maxh limits the maximum size of the grid elements.  With the help of other parameters, you can fine-tune the generation process: limit the minimum size of elements, initiate grid optimization, etc. <br></li><li>  The STL file is read by the Ng_STL_LoadGeometry () function, and the STL geometry object is returned: <br><pre>
       Ng_STL_Geometry * stlGeometry = Ng_STL_LoadGeometry (stlFileName); 

</pre>  where Ng_STL_Geometry should be understood as a type of pointer to an object with an STL geometry.  In fact, Ng_STL_Geometry, like some other types, is a synonym for void *.  NetGen authors in this way completely hid the features of the implementation of complex objects. <br></li><li>  Next, you need to add edges to the STL geometry object.  They are added in a loop using the Ng_STL_AddEdge () function: <br><pre>
       Ng_STL_AddEdge (stlGeometry, p1, p2);

</pre>  where stlGeometry is an STL geometry object;  p1 and p2 are edge vertices.  Each vertex is specified by an array of components along the X, Y, Z axes. These vertices are selected from the edge array of edges that was previously formed. <br></li><li>  Call the Ng_STL_InitSTLGeometry () function to initialize the STL geometry object: <br><pre>
       ng_res = Ng_STL_InitSTLGeometry (stlGeometry);
</pre><br></li><li>  Create an empty mesh item object pointed to by mesh.  For this, the Ng_NewMesh () function is executed: <br><pre>
        Ng_Mesh * mesh = Ng_NewMesh (); 
</pre><br></li><li>  To form edges on the surface of the model in accordance with the STL-geometry and generation parameters: <br><pre>
        ng_res = Ng_STL_MakeEdges (stlGeometry, mesh, &amp; ngMeshParameters); 
</pre><br></li><li>  Triangulate the model surface with the Ng_STL_GenerateSurfaceMesh () function.  Here previously specified edges are taken into account, which will remain undistorted, and generation parameters will be taken into account: <br><pre>	
        ng_res = Ng_STL_GenerateSurfaceMesh (stlGeometry, mesh, &amp; ngMeshParameters);
</pre><br></li><li>  And, finally, the generation of the grid of elements is performed directly with the Ng_GenerateVolumeMesh () function, taking into account the generation parameters: <br><pre>
        ng_res = Ng_GenerateVolumeMesh (mesh, &amp; ngMeshParameters);
</pre><br></li><li>  In this program, the result of the grid generation is output to the VOL file using the Ng_SaveMesh () function, which is passed a pointer to the grid and the file name: <br><pre>
        Ng_SaveMesh (mesh, volFileName);
</pre><br></li></ol><br><h4>  Mesh generation result </h4><br>  The result of the grid generation is a program object under the Ng_Mesh pointer, in the demonstration program it is a mesh pointer.  There is a set of functions that provide programmatic access to the properties of the mesh of elements: get the number of points in the grid Ng_GetNP (), get the number of triangles on the surface Ng_GetNSE (), get the number of finite elements Ng_GetNE (), get the coordinates of the point Ng_GetPoint (), get the element of the surface Ng_GetSurfaceElement ( ), get the final element of Ng_GetVolumeElement (), save the grid to the Ng_SaveMesh file. <br><br>  A VOL file saved in the program can be opened in the netgen.exe visualizer.  The result of viewing the file is shown in Fig.  2. As can be seen in the figure, the boundaries of the surface region remained unchanged. <br><br><img src="https://habrastorage.org/storage2/655/9dc/bba/6559dcbba8773ffa3ee8eb27505c0ec2.gif"><br>  <i>Fig.</i>  <i>2. The surface of the model after generating a grid of elements</i> <br><br>  The .vol file generated by NetGen has the following format: <br><ol><li>  At the beginning of the file, the format code (mesh3d), model dimension (dimension 3), geometry code (geomtype 0) are indicated: <br><pre> mesh3d
 dimension
 3
 geomtype
 0 
</pre><br></li><li>  Next, after the surfaceelements keyword, the quantity is indicated and surface elements are listed.  For each element, the number of the surface, the number of the ‚Äúmaterial‚Äù of the surface, the reserved integer field, the number of points that describe the surface element (for triangles - 3), the numbers of three points of the surface element vertices are recorded.  Hereinafter points are numbered from 1. <br><pre> # surfnr bcnr domin domout np p1 p2 p3
 surfaceelements
 546
        2 1 1 0 3 3 4 13
        2 1 1 0 3 4 5 107 
 # ...
</pre><br></li><li>  The file lists the final elements, for each of which the number of ‚Äúmaterial‚Äù is recorded, the number of vertices of one element (for tetrahedra there are four) and the number of points that are vertices: <br><pre> # matnr np p1 p2 p3 p4
 volumeelements
 1009
        1 4 213 85 153 214
        1 4 298 307 301 305
 # ...
</pre><br></li><li>  Specifies information about the edges on the surface: <br><pre> # surfid 0 p1 p2 trignum1 trignum2 domin / surfnr1 domout / surfnr2 ednr1 dist1 ednr2 dist2 
 edgesegmentsgi2
 220
        1 0 1 2 1 1 0 0 1 0 1 2
        2 0 2 1 6 6 0 0 1 2 1 0
 # ...
</pre><br></li><li>  Lists points that are grid nodes: <br><pre> # XYZ
 points
 333
    10.00000000000000 4.0000000000000000 4.0000000000000000
    10.00000000000000 4.00000000000000 2.0000000000000000
 # ...
</pre><br></li><li>  At the end of the file, color components are recorded for surfaces identified by numbers.  These colors are used by the visualizer to color the surface.  Here for the surface with number 2 the color is set so as to select a rectangular region in Fig.  2 <br><pre> # Surfnr Red Green Blue
 face_colours
 7
        2 1.00000000 1.00000000 0.00000000
        3 0.00000000 1.00000000 0.00000000
 # ...
</pre><br></li></ol><br><h4>  2D grid generation with NetGen </h4><br>  NetGen has a feature for creating 2D mesh elements.  In the particular case, this function can be useful, for example, for generating an STL file for a 3D model that has flat edges.  The geometry of the model is described in the input file in the form of the boundaries of areas of space.  The boundaries of the subdomains of a partition are specified either by using straight line segments or by using quadratic splines.  When describing a border, it is necessary to indicate the area number to the left and right of the border.  The area outside the grid is encoded by the number 0. <br><br><img src="https://habrastorage.org/storage2/075/7cd/462/0757cd462b33039ff2110f81de501414.gif"><br>  <i>Fig.</i>  <i>3. Coding of points and areas for generating 2D mesh of elements</i> <br><br>  We give an example of the input file corresponding to Fig.  3 <br><pre> splinecurves2dv2
 2
 points
 100
 2 3 0
 3 3 2
 4 0 2
 5 1 0
 6 2 0
 7 2 1
 8 1 1
 segments
 1 0 2 1 5 -bc = 1
 2 0 2 5 6 -bc = 1
 1 0 2 6 2 -bc = 1
 1 0 2 2 3 -bc = 1
 1 0 2 3 4 -bc = 1
 1 0 2 4 1 -bc = 1
 2 1 2 6 7 -bc = 1
 2 1 2 7 8 -bc = 1
 2 1 2 8 5 -bc = 1
 
 materials
 1 domain1 -maxh = 1
 2 domain2 -maxh = 1 
</pre><br>  At the beginning of this file is the splinecurves2dv2 keyword.  Behind it is the grid rebuilding factor (here - 2).  After the keyword points, the model description points are listed: point number and coordinates along the X, Y axes. <br><br>  Next, after the segments keyword, there is a list of border segments in the following format: <br><ol><li>  The area number to the left of the border. </li><li>  The area number to the right of the border. </li><li>  The number of points to describe the border segment (in example 2). </li><li>  The number of the starting point of the boundary. </li><li>  The number of the end point of the boundary. </li><li>  Generation control flags.  The bc flag (the number of the boundary condition) has to be specified even when it is not used. </li></ol><br>  After the keyword materials, areas ("materials") are listed in the following format: <br><ol><li>  The area number. </li><li>  The name of the material. </li><li>  Generation control flags.  Here the maxh flag can be specified, limiting the maximum size of the mesh elements. </li></ol><br>  Below is a program that generates a 2D mesh: <br><pre> #include "stdafx.h"

 namespace nglib
 {
 #include ".. \ NetGen \ nglib \ nglib.h"
 }

 using namespace nglib;
 void main () {
	 const char * in2DFileName = ".. \\ Data \\ triangulation.in2d";
	 const char * volFileName = ".. \\ Data \\ triangulation.vol";

	 Ng_Geometry_2D * geom;

	 Ng_Init ();

	 geom = Ng_LoadGeometry_2D (in2DFileName);

	 Ng_Meshing_Parameters mp;
	 mp.maxh = 10,000;
	 mp.fineness = 1;
	 mp.secondorder = 0;

	 Ng_Mesh * mesh;
	 Ng_GenerateMesh_2D (geom, &amp; mesh, &amp; mp);

	 Ng_SaveMesh (mesh, volFileName);
 }
</pre><br>  To generate a 2D mesh, the object is used to describe the 2D geometry by the pointer geom.  The result of the mesh generation is in the object by the mesh pointer.  In the example, the same Ng_SaveMesh () function is used to display the result of the generation as in the example of generating the 3D grid.  Therefore, in this case, the output file has a structure for the 3D grid, but the value of the Z coordinate in it is everywhere zero.  The program interface for working with 2D mesh contains the functions Ng_GetNP_2D () - get the number of grid nodes, Ng_GetNE_2D () - get the number of elements in the grid, Ng_GetPoint_2D () - get the coordinates of the grid node by the node number, Ng_GetElement_2D () - get the coordinates of the nodes of the element by item number.  The visualization of the 2D grid generation result is shown in Fig.  4. As can be seen from the figure, the borders of the region are not distorted. <br><br><img src="https://habrastorage.org/storage2/e6e/dce/4d7/e6edce4d7790f4cc38bfd62fb7144f42.gif"><br>  <i>Fig.</i>  <i>4. The result of the generation of 2D grids</i> <br><br><h4>  Conclusion </h4><br>  This article provides a brief presentation of NetGen, from which it follows that this library can be conveniently used in applications that require the generation of a 3D mesh of elements.  Library functions can be studied and used without writing code.  NetGen comes with a netgen.exe application that implements a visual interface to all library functions.  Figures in this article, depicting the grid elements, obtained using this application. </div><p>Source: <a href="https://habr.com/ru/post/181616/">https://habr.com/ru/post/181616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181604/index.html">Visualization of lists in the Visual Studio debugger or a new word from ‚ÄúBugAid For Visual Studio‚Äù</a></li>
<li><a href="../181606/index.html">Three fifteen</a></li>
<li><a href="../181608/index.html">Curiosity talked about radiation in space</a></li>
<li><a href="../181610/index.html">We write the client for your favorite site on phoneGap</a></li>
<li><a href="../181614/index.html">SaaS Site Builders. Google sites</a></li>
<li><a href="../181618/index.html">Popularity of Javascript Framework</a></li>
<li><a href="../181624/index.html">Three new Evernote security features</a></li>
<li><a href="../181626/index.html">How to run a program without an operating system: part 4. Parallel computing</a></li>
<li><a href="../181630/index.html">Learn Pebble Watch to understand Russian.</a></li>
<li><a href="../181632/index.html">We create Apple-media storage on a PC-based</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>