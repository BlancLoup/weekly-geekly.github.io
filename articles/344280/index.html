<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solution of the optimization problem of multistage rockets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Nonlinear optimization methods are widely used in the design of machines and mechanisms. These methods are used in rocket production, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solution of the optimization problem of multistage rockets</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/-j/yn/cl-jynieyqxwxyasvn9tfcst0jg.png"></div><br>  <b>Introduction</b> <br><br>  Nonlinear optimization methods are widely used in the design of machines and mechanisms.  These methods are used in rocket production, for example, to optimize multi-stage rockets [1]. <br><br>  A multistage rocket is an apparatus in which parts of the structure are separated during flight, giving the remaining part of the rocket additional speed.  A three-stage rocket is shown schematically in the figure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/lw/fp/kc/lwfpkcmed2d0lhdigvold_76qgy.png"><br><br>  As the rocket moves, the stages separate until the main part of the rocket carrying the payload remains.  The task of optimizing the rocket is to distribute the weight over the steps, at which a certain objective function reaches the maximum or minimum value. <br><br>  We will consider two tasks on the assumption that the coefficient <img src="https://habrastorage.org/webt/ka/eb/uv/kaebuvntumpsdwf4-ff8ivuiubu.png">  and the jet velocity <b>Cn is</b> constant at each stage, but at different levels it can take on different values.  In both tasks, the payload ratio of the rocket <b>G is</b> taken as the target function, which must be minimized. <br><br>  The characteristics of a multistage rocket can be described by two equations.  The first equation for the payload ratio of a rocket: <br><br><img src="https://habrastorage.org/webt/r2/lv/ch/r2lvchdx5w7_ngo-mhjufelbg7e.png"><br><br>  where: W1 is the useful weight of the rocket; WN is the initial weight of the rocket before the stages are separated. <br><a name="habracut"></a><br>  The second equation for the characteristics of the payload of a multi-stage rocket, which can be written as an expression for its ideal final velocity (KE Tsiolkovsky formula): <br><br><img src="https://habrastorage.org/webt/ou/e9/by/oue9byv7kef7v0swkxve9objmmk.png"><br><br>  Where: <br><br><img src="https://habrastorage.org/webt/zr/ua/ux/zruauxw-fvhl4dqt4oeuefeskpg.png"><br><br>  Consider a 4-stage rocket moving in the absence of a gravitational field with given values ‚Äã‚Äãof the ideal final velocity <b>Vc</b> , the initial weight of the rocket <b>W4</b> , the jet velocity <b>Cn</b> and the coefficients <b>∆ên = ∆ê</b> . <br><br><h3>  Setting goals </h3><br><br>  <b>The first task</b> is to find such a weight distribution in steps <b>W3, W2</b> in order to <b>minimize</b> the payload ratio of the rocket <b>G = W4 / W1</b> at a given speed <b>Vc</b> . <br><br>  <b>The second task</b> is to find a weight distribution in steps <b>W3, W2</b> in order to <b>maximize the</b> ideal final speed <b>Vc</b> for a given payload ratio of the rocket <b>G.</b> <br><br>  Consider the first task of minimizing the payload ratio at a given rocket speed of Vc = 1,400 m / s and the speed of a jet stream Cn = C = 2000 m / s. <br><br>  As control variables, we choose the weight distribution in steps: W3, W2 for given values ‚Äã‚Äãof the initial weight of the rocket W4 and the load effect coefficient n = = 0.3 <br><br>  Imagine a formula for calculating a given speed in the form: <br><br><img src="https://habrastorage.org/webt/6x/u4/c2/6xu4c2isnnhz3ztbcf6tsih8-rk.png"><br><br>  Where <br><br><img src="https://habrastorage.org/webt/gb/xa/bc/gbxabc9nu2gnf18vfdlrfdobcdq.png"><br><br>  It follows that: <br><br><img src="https://habrastorage.org/webt/7u/tm/zg/7utmzgdwxs2tjrb0cl5djxjh7ue.png"><br><br>  <b>The solution to the first problem in Python</b> <br><br>  Python is a free high-level programming language.  So far, optimization problems have been solved in the licensed math packages of Maple, Mathcad, Matlab and others. <br><br>  Despite this, the arsenal of Python tools has wonderful numpy and scipy libraries.  optimize, the use of which allows you to solve problems of conditional and unconditional, as well as custom optimization.  However, their use requires careful selection of the initial conditions, the solver and the function of the goal, which we will now do. <br><br>  I am listing the first part of the program, including the goal function: <br><br><div class="spoiler">  <b class="spoiler_title">Definition of the goal function</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time C=<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-comment"><span class="hljs-comment">#    e=0.3#   VCzad=1400#     w4=4000#    def f(a):#   return C*np.log(a/(1+e*a)) def VC2(w3,w2):#     return VCzad-f(w4/w3)-f(w3/w2) def w1(w3,w2):#       return (w2/(np.e**(VC2(w3,w2)/C)))-e*w2 start = time.time()#       def fun1(x,y):#     (x=w3, y=w2)      return 4000/(-0.3*y+y*np.e**(np.log(x/(0.3*x+y))+np.log(4000/(1200+x))-0.7))</span></span></code> </pre> <br></div></div><br>  Construct a contour graph of the goal function. <br><br><div class="spoiler">  <b class="spoiler_title">Listing goal function graph</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python #coding=utf8 import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def fun1(x,y):#  return 4000/(-0.3*y+y*np.e**(np.log(x/(0.3*x+y))+np.log(4000/(1200+x))-0.7)) x= np.linspace(500,5000,10000) y = np.linspace(500,5000,10000) z=fun1(x,y) fig = plt.figure('   ') ax= Axes3D(fig) ax.plot(x,y,z,linewidth=1) plt.show()</span></span></code> </pre> <br></div></div><br>  We get: <br><br><img src="https://habrastorage.org/webt/ed/zi/0w/edzi0wndjxlbash8j0oqw9po6qy.png"><br><br>  The complexity of the goal function consists in abrupt changes in the region of acceptable values ‚Äã‚Äãof variables, therefore we are exploring the from scipy library.  optimize import minimize. <br><br>  Usually, the goal function is written as [2]: fun = lambda x: (x [0] - 1) ** 2 + (x [1] - 2.5) ** 2 (example).  Using such an entry in a solvable problem will complicate the analysis of the objective function.  To simplify the notation of the target function, apply the auxiliary function fun2 (x): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun1(*x)</code> </pre> <br>  We use the example from the documentation [2] for the SLSQP solver: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4000</span></span>/(<span class="hljs-number"><span class="hljs-number">-0.3</span></span>*y+y*np.e**(np.log(x/(<span class="hljs-number"><span class="hljs-number">0.3</span></span>*x+y))+np.log(<span class="hljs-number"><span class="hljs-number">4000</span></span>/(<span class="hljs-number"><span class="hljs-number">1200</span></span>+x))<span class="hljs-number"><span class="hljs-number">-0.7</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun1(*x) x0 =[<span class="hljs-number"><span class="hljs-number">3000</span></span>,<span class="hljs-number"><span class="hljs-number">2000</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     res = minimize(fun2, x0, method='SLSQP', bounds=None) stop = time.time() print ("  :",round(stop-start,3)) print(res)</span></span></code> </pre><br>  We get the following result: <br><br>  Optimization time: 0.0 <br>  fun: 8.8345830746128 <br>  jac: array ([7.71641731e-04, -4.12464142e-05]) <br>  message: 'Optimization terminated successfully.' <br>  nfev: 48 <br>  nit: 12 <br>  njev: 12 <br>  status: 0 <br>  success: True <br>  x: array ([2953.94929027, 1149.31138351]) <br><br>  We cannot vary the starting point of the search, for example, we have such a condition, therefore, to verify the optimality of the solution, we will rewrite the listing without specifying the method: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4000</span></span>/(<span class="hljs-number"><span class="hljs-number">-0.3</span></span>*y+y*np.e**(np.log(x/(<span class="hljs-number"><span class="hljs-number">0.3</span></span>*x+y))+np.log(<span class="hljs-number"><span class="hljs-number">4000</span></span>/(<span class="hljs-number"><span class="hljs-number">1200</span></span>+x))<span class="hljs-number"><span class="hljs-number">-0.7</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fun1(*x) x0 =[<span class="hljs-number"><span class="hljs-number">3000</span></span>,<span class="hljs-number"><span class="hljs-number">2000</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     res = minimize(fun2, x0)) stop = time.time() print ("  :",round(stop-start,3)) print(res)</span></span></code> </pre> <br>  We get the following result: <br><br>  Optimization time: 0.0 <br>  fun: 8.402280475718243 <br>  hess_inv: array ([[911166.17713172, 192191.3238931], <br>  [192191.3238931, 194600.77394409]]) <br>  jac: array ([-1.19209290e-07, 1.31130219e-06]) <br>  message: 'Optimization terminated successfully.' <br>  nfev: 152 <br>  nit: 28 <br>  njev: 38 <br>  status: 0 <br>  success: True <br>  x: array ([1967.29278561, 967.91321904]) <br><br>  Time too, but the value of the goal function is less.  Therefore, further searches can be stopped and present the final listing in the form: <br><br><div class="spoiler">  <b class="spoiler_title">Listing solving the first optimization problem</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time C=<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-comment"><span class="hljs-comment">#    e=0.3#   VCzad=1400#     w4=4000#    def f(a):#   return C*np.log(a/(1+e*a)) def VC2(w3,w2):#     return VCzad-f(w4/w3)-f(w3/w2) def w1(w3,w2):#       return (w2/(np.e**(VC2(w3,w2)/C)))-e*w2 start = time.time()#       def fun1(x,y):#     (x=w3, y=w2)      return 4000/(-0.3*y+y*np.e**(np.log(x/(0.3*x+y))+np.log(4000/(1200+x))-0.7)) def fun2(x): return fun1(*x) x0 =[3000,2000] res = minimize(fun2, x0) stop = time.time() print ("   :",round(stop-start,3)) print ("    :",round(res['fun'],3)) w2=round(res['x'][1],3) w3=round(res['x'][0],3) w1=round(w1(w3,w2),3) v1=round(f(w2/w1),3) v2=round(f(w2/w1)+f(w3/w2),3) v3=round(f(w2/w1)+f(w3/w2)+f(w4/w3),3) print("   -:%s;%s;%s;%s "%(w4,w3,w2,w1)) print("   -:%s;%s;%s;%s "%(0,v1,v2,v3)) VES=[w4,w3,w2,w1] VC=[0,v1,v2,v3] plt.title("      \n   ") plt.plot(VES,VC,'o') plt.plot(VES,VC,'r') plt.xlabel(" ") plt.ylabel(" ") plt.grid(True) plt.show()</span></span></code> </pre><br></div></div><br>  We get the following result: <br><br>  Optimizer operation time: 0.0 <br>  The estimated value of the objective function: 8.402 <br>  The change in weight of the rocket - 4000; 1967.293; 967.913; 476.061 <br>  Change the speed of the rocket -: 0; 466.785; 933.166; 1400.001 <br><br><img src="https://habrastorage.org/webt/ly/do/km/lydokm4hs7wpnocgy0dvvddff78.png"><br><br>  The weight of the rocket is distributed as follows (4000.0; 1967.0; 967.9; 476.1), which corresponds to an increase in speed in equal parts (after the separation of each step) by an average of 460 m / s. <br><br>  We use the same formula for the final speed of the rocket, as in the previous problem: <br><br><img src="https://habrastorage.org/webt/j7/7p/ej/j77pejs2tpovsrwwlj_xli8flq8.png"><br><br>  Since W4 and W1 are set, the distribution of the weight of the rocket in steps W3 and W2 can maximize the ideal final speed Vc for a given payload ratio of the rocket G. <br><br>  <b>The solution of the second problem in Python</b> <br><br>  Taking into account the previously stated, we write down a part of the listing to the objective function: <br><br><div class="spoiler">  <b class="spoiler_title">Listing to define a goal function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time C=<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-comment"><span class="hljs-comment">#    e=0.4#     w4zad=4000#   w1zad=200#    def f(a): return np.log(a/(1+e*a)) def Vc1(w3): return C*f(w4zad/w3) def Vc2(w3,w2): return C*f(w3/w2) def Vc3(w2): return C*f(w2/w1zad) start = time.time() def fun1(x, y): return -(C*np.log((w4zad/y)/(1+e*(w4zad/y)))+ C*np.log((y/x)/(1+e*(y/x)))+C* np.log((x/w1zad)/(1+e*(x/w1zad))))</span></span></code> </pre> <br></div></div><br>  Construct a contour graph of the goal function: <br><br><div class="spoiler">  <b class="spoiler_title">Listing contour graphics</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mpl_toolkits.mplot3d <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Axes3D C=<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-comment"><span class="hljs-comment">#   e=0.4#    w4zad=4000#   w1zad=200#    def fun1(x, y): return -(C*np.log((w4zad/y)/(1+e*(w4zad/y)))+ C*np.log((y/x)/(1+e*(y/x)))+C* np.log((x/w1zad)/(1+e*(x/w1zad)))) x= np.linspace(500,5000,10000) y = np.linspace(500,5000,10000) z=fun1(x,y) fig = plt.figure('   ') ax= Axes3D(fig) ax.plot(x,y,z,linewidth=1) plt.show()</span></span></code> </pre><br></div></div><br>  We obtain a contour graph of the target function with a negative sign to change the minimum to the maximum: <br><br><img src="https://habrastorage.org/webt/br/bh/2p/brbh2pxptg3edycyn_h7c13j3da.png"><br><br>  We got a local maximum (minimum on the chart), so the final listing will be presented in the form: <br><br><div class="spoiler">  <b class="spoiler_title">Listing solving the second optimization problem</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> minimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time C=<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-comment"><span class="hljs-comment">#   e=0.4#    w4zad=4000#   w1zad=200#    def f(a): return np.log(a/(1+e*a)) def Vc1(w3): return C*f(w4zad/w3) def Vc2(w3,w2): return C*f(w3/w2) def Vc3(w2): return C*f(w2/w1zad) start = time.time() def fun1(x, y): return -(C*np.log((w4zad/y)/(1+e*(w4zad/y)))+ C*np.log((y/x)/(1+e*(y/x)))+C* np.log((x/w1zad)/(1+e*(x/w1zad)))) def fun2(x): return fun1(*x) x0 = (1000,2000) res = minimize(fun2, x0) stop = time.time() print ("  :",round(stop-start,3)) print ("    :",round(res['fun'],3)) w2=round(res['x'][0],3) w3=round(res['x'][1],3) v1=round(Vc1(w3),3) v2=round(Vc1(w3)+Vc2(w3,w2),3) v3=round(Vc1(w3)+Vc2(w3,w2)+Vc3(w2),2) print("   -:%s;%s;%s;%s "%(w4zad,w3,w2,w1zad)) print("   -:%s;%s;%s;%s "%(0,v1,v2,v3)) VES=[w4zad,w3,w2,w1zad] VC=[0,v1,v2,v3] plt.title("     \n   ") plt.plot(VES,VC,'o') plt.plot(VES,VC,'r') plt.xlabel(" ") plt.ylabel(" ") plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  As a result, we get: <br><br>  Optimizer running time: 0.016 <br>  The estimated value of the objective function: -1580.644 <br>  The change in the weight of the rocket -: 4000; 1473.625; 542.889; 200 <br>  Change the speed of the rocket -: 0; 526.873; 1053.753; 1580.64 <br><br><img src="https://habrastorage.org/webt/tl/kl/2k/tlkl2kxzpai1tibd24awmoywu0c.png"><br><br>  The rocket weights are distributed as follows: 4000; 1473.625; 542.889; 200, which corresponds to an increase in speed in equal parts (after separation of each stage) by 526.9 m / s. <br><br><h3>  findings </h3><br><br>  The publication describes the features of the use of the library scipy.  optimize when solving optimization problems using the example of multistage rocket optimization.  The results obtained in terms of the immutability of the initial point of the search for extremum for variables and the formation of a goal function in the usual user form will help expand the scope of the freely-available programming language Python. <br><br>  <b>Thank you all for your attention!</b>  And the main thing is that a multistage rocket with a load that is not useful for us <b>NEVER arrives</b> to us. <br><br>  Links <br><br><ol><li>  <a href="http://mm.lti-gti.ru/data/met3.pdf">Solving nonlinear programming problems</a> </li><li>  <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize">SciPy.</a>  <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize">Optimize.minimize</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/344280/">https://habr.com/ru/post/344280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344266/index.html">Transition from tester to project managers</a></li>
<li><a href="../344268/index.html">On the results of the MERC-2017 contest: an interview with the winners</a></li>
<li><a href="../344270/index.html">Webpage interaction with Ethereum</a></li>
<li><a href="../344272/index.html">Angular 5 (or 4): downgrade component for use in AngularJS</a></li>
<li><a href="../344278/index.html">Location of Wi-FI sources in AR and bowler</a></li>
<li><a href="../344282/index.html">Rust vs. C ++ on algorithmic tasks</a></li>
<li><a href="../344284/index.html">How to replace old indexes and not to break the system?</a></li>
<li><a href="../344288/index.html">Arrays, Collections: Algorithmic minimum</a></li>
<li><a href="../344290/index.html">Blockchain's guide for the marketer</a></li>
<li><a href="../344292/index.html">Websockets. Possible approach to use</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>