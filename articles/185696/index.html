<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networking in Android: traffic, security, and battery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, there are more than 800 thousand applications on Google Play. Many of them are based on client-server communication. When developing such appli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networking in Android: traffic, security, and battery</h1><div class="post__text post__text-html js-mediator-article">  Today, there are more than 800 thousand applications on Google Play.  Many of them are based on client-server communication.  When developing such applications, it is necessary to take into account three main points that will be discussed in this article. <br><br><a name="habracut"></a>  <b>What you need to remember when implementing the network part of the application</b> <br><br>  The first is traffic.  It is not always possible to work on a free Wi-Fi connection, and the mobile Internet is still expensive, and this must be remembered, because traffic is the user's money. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second is the battery limit.  Mobile devices are necessary for the user for some daily affairs, meetings, walks, business, and when the battery sits down at the most inopportune moment, the user is indignant. <br>  The third is security.  Since we are still talking about mobile clients, and the data is walking across the network from client to server and back, they need to be protected. <br><br>  <b>Networking Implementation Approaches</b> <br><br>  To begin, let us recall what ways of implementing client-server communication exist and are popular today. <br>  The first approach is based on sockets (here I mean working directly with the Socket API).  It is often used in applications where the speed of message delivery is important, the order of message delivery is important, and you need to keep a stable connection to the server.  This method is often implemented in messengers and games. <br><br><img src="https://habrastorage.org/storage2/77a/1aa/9f1/77a1aa9f179096065a1d5b2203058a6a.jpg"><br><br>  The second approach is frequent polling (polling): the client sends a request to the server and tells him: ‚ÄúGive me fresh data‚Äù;  the server responds to the client's request and gives everything that it has accumulated by that moment. <br><br><img src="https://habrastorage.org/storage2/8d4/420/0b2/8d44200b2a06ea4b627f0bb5d8e94c19.jpg"><br><br>  The disadvantage of this approach is that the client does not know whether fresh data has appeared on the server.  The network once again chases traffic, primarily because of the frequent connections to the server. <br><br>  The third approach - long polling (long polling) - is that the client sends a "pending" request to the server.  The server is looking to see if there is fresh data for the client, if they are not there, then it keeps the connection with the client until this data appears.  As soon as the data appeared, he "pushes" them back to the client.  The client, having received data from the server, immediately sends the next "pending" request, etc. <br><br><img src="https://habrastorage.org/storage2/689/96d/fb9/68996dfb9248fa210e0c87f126316fd1.jpg"><br><br>  The implementation of this approach is quite complicated on a mobile client primarily due to the instability of the mobile connection.  But with this approach, the traffic is consumed less than with the usual polling, since  reduced the number of connections to the server. <br>  The mechanism of long polling, or push notifications (push notifications), is implemented in the Android platform itself.  And, probably, for most tasks it will be better to use it, rather than implement it yourself.  Your app is signed by Google Cloud Messaging (GCM) to receive push notifications. <br><br><img src="https://habrastorage.org/storage2/152/ec7/598/152ec7598f44d126eed593a8e6529eac.jpg"><br><br>  Thus, the connection is broken directly between the server and the client due to the fact that the server works with the GCM service and sends fresh data always to this service, and it in turn implements all the logic of delivering this data to your application.  The advantages of this approach are that it eliminates the need for frequent connections to the server, because you know for sure that the data has appeared, and the GCM service notifies you of this. <br>  Of these four approaches, push notifications and frequent surveys are the most popular in developing business applications.  When implementing these approaches, we somehow have to establish a connection to the server and transfer data.  Next, we will discuss the tools that are available to the developer to work on HTTP / HTTPS protocols. <br><br>  <b>HttpUrlConnection and HttpClient</b> <br><br>  In the arsenal of the Android developer, there are two classes for working on these protocols.  The first is java.net.HttpURLConnection, the second is org.apache.http.client.HttpClient.  Both of these libraries are included in the Android SDK.  Further, the main points that will affect traffic, battery and safety when working with each of these libraries will be discussed in detail. <br><br>  With HttpURLConnection, everything is simple.  One class and all.  This is explained by the fact that the parent class URLConnection was designed to work not only via the HTTP protocol, but also through such as file, mailto, ftp, etc. <br><br><img src="https://habrastorage.org/storage2/b3b/b2c/a7e/b3bb2ca7eaa1c8e35b64e8691eab9368.jpg"><br><br>  HttpClient is designed more object oriented.  It has a clear separation of abstractions.  In the simplest case, we will work with five different interfaces: HttpRequest, HttpResponse, HttpEntity and HttpContext.  Therefore, the Apache client is much heavier than the HttpUrlConnection. <br><br><img src="https://habrastorage.org/storage2/b40/01a/986/b4001a98659e549b42fa4b9b88f72716.jpg"><br><br>  As a rule, there is only one instance of the HttpClient class for the entire application.  This is due to its heaviness.  Using a separate instance for each request will be wasteful.  We can, for example, store an instance of an HTTP client as a successor to the Application class. <br><br><img src="https://habrastorage.org/storage2/43e/73f/e49/43e73fe4964ef2967fc17a1dba38dff0.jpg"><br><br>  In the case of HttpUrlConnection, a new client instance should be created for each request. <br><br><img src="https://habrastorage.org/storage2/ecf/6ce/330/ecf6ce330f97447a6ceb8fd61abf113f.jpg"><br><br>  <b>What makes the traffic?</b> <br><br>  During the operation of our application, the picture will be something like this. <br><br><img src="https://habrastorage.org/storage2/b4a/5f4/b02/b4a5f4b02aebe8a1df146e454cec7602.jpg"><br><br>  The number and frequency of requests will depend on the functionality and saturation of the UI - application interface.  Each such request establishes a TCP connection to the server.  In this case, the traffic that will be spent will be equal to the sum of the connection settings and the sum of the transmitted data.  In this case, it is possible to reduce traffic consumption by using a long-lived connection (keep alive). <br><br><img src="https://habrastorage.org/storage2/1a0/445/480/1a0445480178f146f2b1d6368aa54423.jpg"><br><br>  The main idea of ‚Äã‚Äãkeep alive connection is to use the same TCP connection for sending and receiving HTTP requests.  The main benefits are reduced traffic and query execution time.  I did a simple test, which consisted in the sequential execution of 10 requests for the same host.  Data is presented in the table below.  When keep alive is off, you can see that the average query execution time was about two seconds.  In the case of keep alive, this time decreased to 1.7 seconds, which is 16% faster.  This is primarily due to the fact that eliminating the need for frequent connection with the server.  When using a secure HTTPS connection, the difference would be more noticeable, since  The SSL Handshake procedure is much harder than the TCP Handshake procedure. <br><br><img src="https://habrastorage.org/storage2/58d/502/40c/58d50240c42d69be7ef4170e5d41af54.jpg"><br><br>  An important parameter to keep alive is the keep alive duration.  It means time interval.  If several HTTP requests come within this interval, then the already established TCP connection will be reused. <br><br><img src="https://habrastorage.org/storage2/4ba/e1c/92a/4bae1c92a8bbf7fdbde0a8d6b29cbb6d.jpg"><br><br>  The figure shows that the time between the fourth and third request exceeded the keep alive duration, so a new TCP connection is created with the server. <br>  Let's see how you can adjust the above parameter.  In the case of HttpClient, everything is fine, we have the ConnectionKeepAliveStrategy interface.  By overriding the getKeepAliveDuration method, we can return the desired value of the keep alive duration parameter. <br><br><pre><code class="html hljs xml">httpClient.setKeepAliveStrategy( new ConnectionKeepAliveStrategy() { @Override public long getKeepAliveDuration( HttpResponse response, HttpContext context) { return KEEP_ALIVE_DURATION_MILLISECONDS; } });</code> </pre> <br><br>  When working with HttpUrlConnection, you need to remember about the <a href="http-clients.html">bug in the Android 2.2 platform</a> and disable keep alive on platforms &lt;= 2.2. <br><br><pre> <code class="html hljs xml">if (Build.VERSION.SDK_INT <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Build.VERSION_CODES.FROYO</span></span></span><span class="hljs-tag">) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">System.setProperty</span></span></span><span class="hljs-tag">("</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http.keepAlive</span></span></span><span class="hljs-tag">", "</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">false</span></span></span><span class="hljs-tag">"); }</span></span></code> </pre><br>  The second unpleasant (perhaps only for me) moment when working with HttpUrlConnection is that the keep alive duration parameter is not configurable (I did not find a legal way, if someone tells me, I will be grateful).  By default it is approximately 5 seconds. <br>  Also, when working with keep alive connection, you should try to read data completely from the established connection (connection).  If you don‚Äôt read the data in Donets, you can get connections that will hang in the pool and ‚Äúthink‚Äù that someone else is going to read them.  If the InputStream is successfully received, read the entire response body.  <a href="http://goo.gl/9cdlz">A complete subtraction clears the connection</a> from the data, and this connection will be reused more likely. <br><br>  <b>Work with cookies</b> <br><br>  Cook is a small piece of data sent by a web server and stored on the user's computer.  In our case, the computer is an Android device.  In practice, cookies are usually used to authenticate a user, store their personal preferences and settings, track the status of a user's access session, and keep statistics about users.  A large number of services begin to develop mobile applications after the mobile version of the site has already been made.  In such a situation, an interesting question is: ‚ÄúIs it possible, having received an authorization cookie in a mobile application, to install it in a browser (in a WebView)?‚Äù.  When solving this problem, there are a couple of details that will help save your time: <br><br><ol><li>  On the surface&gt; = 4.0.3 (API Level 15) there should be a <b>dot at the beginning of the domain</b> </li><li>  After calling the sync () method in CookieSyncManager, the cookie will be entered only in the WebView inside your application, <b>but not in the browser</b> .  This restriction is imposed by the Android system for security reasons. </li></ol><br><br><img src="https://habrastorage.org/storage2/ab9/3e9/7b9/ab93e97b956c44d22e9de411dff901c3.jpg"><br><br>  <b>Secure connection (https)</b> <br><br>  To conclude this article, I will look at how to enable HTTPS in Android.  As far as I know, on other mobile platforms, it is enough to enable the HTTPS scheme, the SSL transport mechanism - and everything should work.  There are some problems in Android that should be considered and solved.  First, remember how a secure connection is established.  The red arrow points to the problem point - this is certificate authentication. <br><br><img src="https://habrastorage.org/storage2/9db/651/ac4/9db651ac448e22c2975ec0f09594c3f7.jpg"><br><br>  On platforms &lt;Android 4.0, if you try to perform a network request over HTTPS, an SSLHandshakeException will crash.  The ability to install a trusted certificate appeared on Android 4.0 using the <a href="http://developer.android.com/reference/android/security/KeyChain.html">KeyChain API.</a>  But what about platforms below 4.0?  On these platforms we have two ways: <br><br><ol><li>  Create a <a href="http://goo.gl/5Surx">local certificate store</a> </li><li>  Trust any certificates.  In this case, the traffic will also be encrypted, but the threat of <a href="http://ru.wikipedia.org/wiki/Man_in_the_middle">man in the middle</a> will remain </li></ol><br><br>  If the choice fell on the creation of a local certificate store, then after it is created, you can connect it as follows: <br><br>  - in the case of HttpUrlConnection: <br>  ... <br><pre> <code class="html hljs xml">TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm); KeyStore keyStore = KeyStore.getInstance("BKS"); InputStream in = context.getResources().openRawResource(mykeystore); keyStore.load(in, "mysecret".toCharArray()); in.close(); tmf.init(keyStore); SSLContext sslc = SSLContext.getInstance("TLS"); sslc.init(null, tmf.getTrustManagers(),new SecureRandom());</code> </pre><br>  ... <br>  - in the case of HttpClient: <br><pre> <code class="html hljs xml">private SSLSocketFactory createSslSocketFactory() { SSLSocketFactory sf = null; try { KeyStore keyStore = KeyStore.getInstance("BKS"); InputStream in = context.getResources().openRawResource(mykeystore); keyStore.load(in, "mysecret".toCharArray()); in.close(); sf = new SSLSocketFactory(keyStore); sf.setHostnameVerifier(STRICT_HOSTNAME_VERIFIER); } catch (Exception e) { e.printStackTrace(); } return sf; }.</code> </pre><br><br>  With the help of KeyStore.getInstance (‚ÄúBKS‚Äù), we get a KeyStore object that supports the Bounce Castle KeyStore format (a Java package for working with crypto-algorithms).  mykeystore - id of the resource in which the certificates are located. <br>  mysecret - KeyStore password.  More information can be found at the link to the local certificate store above. <br><br>  If the choice fell on ‚ÄúTrust with any certificate‚Äù, then it suffices to implement two interfaces as follows: <br><br><pre> <code class="html hljs xml">private class DummyHostnameVerifier implements HostnameVerifier{ @Override public boolean verify(String hostname, SSLSession session) { return true; } } private class DummyTrustManager implements X509TrustManager{ @Override public void checkClientTrusted(...) throws CertificateException { //empty } @Override public void checkServerTrusted(...) throws CertificateException { //empty } ... }</code> </pre><br><br>  You should then apply these implementations either to HttpClient or to HttpUrlConnection. <br><br>  <b>And what about the battery?</b> <br><br>  Battery consumption directly depends on the number of server connections being established, since  Each installation activates a wireless radio that consumes battery power.  How Android wireless radio works and what affects battery consumption, I recommend reading in this article: <a href="http://developer.android.com/training/efficient-downloads/index.html">Transferring Data Without Draining the Battery</a> . <br><br>  After reading the article, you probably wondered which tool to use - HttpClient or HttpUrlConnection?  Android developers recommend using HttpUrlConnection in new applications, since  it is easy to use, it will be developed further and adapted to the platform.  HttpClient should be used on platforms below Android 2.3, primarily because of a serious bug with a keep alive connection. <br><br>  These three points we, of course, take into account when developing our mobile applications.  And what, in the first place, do you think? </div><p>Source: <a href="https://habr.com/ru/post/185696/">https://habr.com/ru/post/185696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185684/index.html">Check CNC</a></li>
<li><a href="../185686/index.html">So you still don't understand Hindley-Milner? Part 2</a></li>
<li><a href="../185688/index.html">Geeksphone Peak video review on Firefox OS</a></li>
<li><a href="../185692/index.html">Servers in the Netherlands Intel Quad-Core Xeon X3440 / 8GB DDR3 / 2x1TB SATA2 / 100Mbps Unmetered for $ 89! 65 servers left!</a></li>
<li><a href="../185694/index.html">Cyber ‚Äã‚ÄãSecurity. Weekly Review June 24 - June 30, 2013</a></li>
<li><a href="../185698/index.html">Take part in the international final of the Imagine Cup 2013! - Support ours and don‚Äôt miss the opportunity to meet with leading Microsoft experts</a></li>
<li><a href="../185700/index.html">Extending Git and Mercurial Repositories with Amazon S3</a></li>
<li><a href="../185704/index.html">UEFI BIOS File Device, Part One: UEFI Capsule and Intel Flash Image</a></li>
<li><a href="../185706/index.html">Technique of writing await / async analogue from C # for C ++</a></li>
<li><a href="../185710/index.html">RMI for multiple network interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>