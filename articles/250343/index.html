<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PSR-7 in examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The PSR-7 standard has been successfully completed. The final touches were added this week. And now version 0.6.0 of the http-message package is ready...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PSR-7 in examples</h1><div class="post__text post__text-html js-mediator-article">  The <a href="https://github.com/php-fig/fig-standards/blob/master/proposed/">PSR-7</a> standard has been successfully completed.  The final touches were added this week.  And now version 0.6.0 of the <a href="http-message">http-message package</a> is ready for use.  Try to follow this standard in your applications. <br><br>  I still hear remarks both about too simplified, and about too complicated presentation.  That is why this post was written - to demonstrate the use of published recommendations and to show both their simplicity, and the completeness and reliability that they provide. <br><a name="habracut"></a><br>  To begin with, I will briefly talk about what this standard regulates. <br><br><h2>  HTTP messages </h2><br>  HTTP is a fairly simple protocol.  That is why it has been used successfully for many years.  Messages in it have the following structure: <br><pre><code class="php hljs">&lt;message line&gt; Header: value Another-Header: value Message body</code> </pre> <br>  Headers are key ‚Äì value pairs.  Keys are case sensitive.  Values ‚Äã‚Äãare strings.  A single header can have multiple meanings.  In this case, the values ‚Äã‚Äãare usually represented by a comma-separated list. <br>  The message body is a string.  Although it is usually handled by the server and client as a stream, to reduce memory consumption and reduce the processing load.  This is extremely important when large data sets are transferred, and especially when files are transferred.  For example, PHP "out of the box" represents the incoming request body as a stream php: // input and uses the output buffer (also, formally, a stream) to return a response. <br>  A message line is a place that distinguishes an HTTP request from a response. <br>  The message string of the request (hereinafter referred to as the query string) has the following format: <br><pre> <code class="php hljs">METHOD request-target HTTP/VERSION</code> </pre><br>  Where the method (‚ÄúMETHOD‚Äù) determines the type of request: GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD, and so on, the protocol version (‚ÄúVERSION‚Äù) is usually 1.0 or 1.1 (more often 1.1 for modern web clients).  And on the purpose of the request (‚Äúrequest-target‚Äù), we dwell in more detail. <br>  The purpose of the request can be represented as follows: <br><ul><li>  In the standard form, which represents the path and query string (if present), i.e.  <a href="https://ru.wikipedia.org/wiki/URI">URI</a> (Universal Resource Identifier). </li><li>  In absolute form, which is an absolute URI. </li><li>  In the authorization form, which is a part of the URI required for authorization (information about the user, if presented; host; and port, if not standard). </li><li>  In the form of *, that is, a string consisting of the character "*". </li></ul><br>  Usually, the client sends the data for the HTTP authorization only with the first request to connect to the HTTP server.  Then, just a relative (or absolute) path to the resource (URI without data for authorization) is sent as the target of the request.  Thus, data for authorization is transmitted only for a connection request (CONNECT method), which is usually performed when working with a proxy server.  The ‚Äú*‚Äù symbol is used with the OPTIONS method to get general information about the web server. <br>  In short, there are many uses for the purpose of a query. <br>  Now, to completely confuse you, consider the URI.  We see the following: <br><pre> <code class="php hljs">&lt;scheme&gt;:<span class="hljs-comment"><span class="hljs-comment">//&lt;authority&gt;[/&lt;path&gt;][?&lt;query string&gt;]</span></span></code> </pre><br>  The ‚Äúscheme‚Äù in the http request will be either http or https.  ‚ÄúPath‚Äù is also a clear part for everyone.  But what is ‚Äúauthority‚Äù? <br><pre> <code class="php hljs">[user-info@]host[:port]</code> </pre><br>  ‚ÄúAuthority‚Äù always contains a host, which can be a domain name or an IP address.  The port is optional and only necessary if it is not standard for this scheme (or if the scheme is unknown).  User information is presented as <br><pre> <code class="php hljs">user[:pass]</code> </pre><br>  where the password is optional.  In fact, in existing specifications, it is recommended not to use a password in the URI at all.  It is better to force a password from the client. <br>  The query string is a set of key-value pairs separated by ampersands: <br><pre> <code class="php hljs">?foo=bar&amp;baz&amp;quz=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Depending on the implementation language, it can also model lists or arrays: <br><pre> <code class="php hljs">?sort[]=ASC&amp;sort[]=date&amp;filter[product]=name</code> </pre><br>  PHP converts this string to a two-dimensional array: <br><pre> <code class="php hljs">[ <span class="hljs-string"><span class="hljs-string">'sort'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'ASC'</span></span>, <span class="hljs-string"><span class="hljs-string">'date'</span></span> ], <span class="hljs-string"><span class="hljs-string">'filter'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'product'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span> ], ]</code> </pre><br>  So, if the flexibility in shaping the purpose of the request would not be enough for us, the URI would provide its own. <br>  Fortunately, HTTP server responses are simpler.  The response line is as follows: <br><pre> <code class="php hljs">HTTP/VERSION &lt;status&gt;[ &lt;reason&gt;]</code> </pre><br>  ‚ÄúVERSION‚Äù, as mentioned earlier, is usually 1.0 or, more often, 1.1.  ‚ÄúStatus‚Äù is a number from 100 to 599 inclusive;  ‚ÄúReason‚Äù - an explanation of the status, standard for each status. <br>  So this was a quick overview of HTTP messages.  Let's now see how the PSR-7 models them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Message Headers </h2><br>  Message header names are case-insensitive.  Unfortunately, most languages ‚Äã‚Äãand libraries bring them to one register.  As an example, PHP stores them in the $ _SERVER array in uppercase, with the HTTP_ prefix, and substituting _for - (this is for compliance with the <a href="http://www.w3.org/CGI/">Common Gateway Interface</a> (CGI) specification). <br>  PSR-7 simplifies access to headers by providing an object-oriented layer above them. <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  null,   : $header = $message-&gt;getHeader('Accept'); // ,   : if (! $message-&gt;hasHeader('Accept')) { } //     , //   : $values = $message-&gt;getHeaderLines('X-Foo');</span></span></code> </pre><br>  All the above logic does not depend on how the header is specified;  accept, ACCEEPT, or even aCCePt will be valid header names and return the same result. <br>  PSR-7 assumes that parsing all the headers will return the structure as an array: <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* Returns the following structure: [ 'Header' =&gt; [ 'value1' 'value2' ] ] */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($message-&gt;getAllHeaders() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $header =&gt; $values) { }</code> </pre><br>  When the structure is defined, users will know exactly what they will receive and can process headers in a convenient way for them - regardless of implementation. <br>  But what if you want to add headers to the message ‚Äî for example, to create a request and send it to the HTTP client? <br>  Messages in PSR-7 are modeled as <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">value objects</a> ;  this means that any change in state is, in fact, a different meaning.  Thus, defining a new header will result in a new message object. <br><pre> <code class="php hljs">$new = $message-&gt;withHeader(<span class="hljs-string"><span class="hljs-string">'Location'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://example.com'</span></span>);</code> </pre><br>  If you just need to update the value, you can simply override it: <br><pre> <code class="php hljs">$message = $message-&gt;withHeader(<span class="hljs-string"><span class="hljs-string">'Location'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://example.com'</span></span>);</code> </pre><br>  If you want to add another value to an already existing header, you can do the following: <br><pre> <code class="php hljs">$message = $message-&gt;withAddedHeader(<span class="hljs-string"><span class="hljs-string">'X-Foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>);</code> </pre><br>  Or even delete the title: <br><pre> <code class="php hljs">$message = $message-&gt;withoutHeader(<span class="hljs-string"><span class="hljs-string">'X-Foo'</span></span>);</code> </pre><br><br><h2>  Message body </h2><br>  As mentioned above, the message body is usually treated as a stream to improve performance.  This is especially important when you transfer files using HTTP.  Unless you intend to use all available memory for the current process.  Most implementations of HTTP messages that I have reviewed forget about this or try to change the behavior in fact (yes, even ZF2 is sinning!).  If you want to read more about the benefits of this approach, read the article by Michael Dowling.  He <a href="http://mtdowling.com/blog/2014/07/03/a-case-for-higher-level-php-streams/">wrote</a> on his blog about using threads in the PSR-7 last summer. <br>  So, the message body in PSR-7 is modeled as a <a href="http-message/blob/master/src/StreamableInterface.php">stream</a> . <br>  ‚ÄúBut this is too difficult for 80% of cases where you can get by with strings!‚Äù Is the most frequent argument among those that criticize this implementation of processing the message body.  Well, let's consider the following: <br><pre> <code class="php hljs">$body = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stream(<span class="hljs-string"><span class="hljs-string">'php://temp'</span></span>); $body-&gt;write(<span class="hljs-string"><span class="hljs-string">'Here is the content for my message!'</span></span>);</code> </pre><br>  This example, and all subsequent examples of working with HTTP messages in this post will use the <a href="http">phly / http</a> library written by me and reflecting the development of PSR-7.  In this case, the Stream implements StreamableInterface. <br>  Essentially, you get a subtle, object-oriented interface for interacting with the message body, which allows you to add information to it, read it, and more.  Want to change the message?  Create a new message body: <br><pre> <code class="php hljs">$message = $message-&gt;withBody(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stream(<span class="hljs-string"><span class="hljs-string">'php://temp'</span></span>));</code> </pre><br>  My opinion is that, despite the fact that the presentation of the message body as a stream seems to be difficult, in reality, implementation and use are quite simple and understandable. <br>  The benefit of using a StreamableInterface in PSR-7 is that it provides flexibility that simplifies the implementation of various design patterns.  For example, you can implement a ‚Äúcallback‚Äù function, which, when you call the read () method or getContents (), returns the content of the message (Drupal, in particular, uses this template).  Or "Iterator", the implementation of which uses any "Traversable" to return or merge content.  The point is that such an interface gives you a wide scope for implementing a variety of templates for working with the message body.  And does not limit just strings or files. <br>  StreamableInterface offers a set of methods that are most often used when working with the body of an HTTP message.  This does not mean that it provides for absolutely everything, but covers a large set of potentially necessary operations. <br>  Personally, I like to use php: // temp streams, because they are in memory until they are large enough (in this case, they are written to a temporary file on disk).  The method can be quite effective. <br><br><h2>  Answers </h2><br>  So far, we have considered functions common to any message.  Now I am going to dwell on the answers in particular. <br>  The response has a status code and an explanatory phrase: <br><pre> <code class="php hljs">$status = $response-&gt;getStatusCode(); $reason = $response-&gt;getReasonPhrase();</code> </pre><br>  It's easy to remember.  Now, what if we form the answer ourselves? <br>  Explanatory phrase is considered optional (but at the same time standard for each status code).  For it, the interface provides a response-specific mutator withStatus (): <br><pre> <code class="php hljs">$response = $response-&gt;withStatus(<span class="hljs-number"><span class="hljs-number">418</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm a teapot"</span></span>);</code> </pre><br>  Again, messages are modeled as value objects;  changing any value will result in a new instance that must be tied to the response or request.  But in most cases, you will simply reassign the current instance. <br><br><h2>  Requests </h2><br>  Requests include the following: <br><ul><li>  Method. </li><li>  Request URI / Purpose. </li></ul><br>  The latter is a bit tricky to model.  Probably in 99% of cases, we will see the standard URI as the target of the request.  But this does not negate the fact that it is necessary to envisage other types of query objectives.  Thus, the query interface does the following: <br><ul><li>  Makes an instance of a UriInterface that models the request URI. </li><li>  Provides two methods for the purpose of the request: getRequestTarget (), which returns the purpose of the request, and calculates it if not presented (using the proposed URI to return the original form or to return ‚Äú/‚Äù if the URI is not provided or does not contain a path);  and withRequestTarget () to create a new instance with the specific purpose of the request. </li></ul><br>  This will further allow us to address requests with an arbitrary purpose of the request, when necessary (for example, using information about the URI in the request to establish a connection with the HTTP client). <br>  Let's get the method and URI from the request: <br><pre> <code class="php hljs">$method = $request-&gt;getMethod(); $uri = $request-&gt;getUri();</code> </pre><br>  $ uri in this case will be an instance of UriInterface, and allow you to use the URI: <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  URI: $scheme = $uri-&gt;getScheme(); $userInfo = $uri-&gt;getUserInfo(); $host = $uri-&gt;getHost(); $port = $uri-&gt;getPort(); $path = $uri-&gt;getPath(); $query = $uri-&gt;getQuery(); //   $authority = $uri-&gt;getAuthority(); // [user-info@]host[:port]</span></span></code> </pre><br>  In the same way as HTTP messages, URIs are represented as value objects, and changing any part of a URI changes its value, mutated methods return a new instance: <br><pre> <code class="php hljs">$uri = $uri -&gt;withScheme(<span class="hljs-string"><span class="hljs-string">'http'</span></span>) -&gt;withHost(<span class="hljs-string"><span class="hljs-string">'example.com'</span></span>) -&gt;withPath(<span class="hljs-string"><span class="hljs-string">'/foo/bar'</span></span>) -&gt;withQuery(<span class="hljs-string"><span class="hljs-string">'?baz=bat'</span></span>);</code> </pre><br>  Since changing the URI means creating a new instance, if you want the change to be reflected in your request, you need to report these changes to the request object;  and, as with any message, if you need to change a method or a URI in a particular instance, you should use the following methods: <br><pre> <code class="php hljs">$request = $request -&gt;withMethod(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>) -&gt;withUri($uri-&gt;withPath(<span class="hljs-string"><span class="hljs-string">'/api/user'</span></span>));</code> </pre><br><br><h2>  Server requests </h2><br>  Server requests have slightly different tasks than standard HTTP request messages.  Native to the PHP Server API (SAPI) provides us with a set of common, as for PHP developers, functions: <br><ul><li>  Deserialization of arguments in the query string ($ _GET). </li><li>  Deserialization of encoded data transmitted by the POST method ($ _POST). </li><li>  Deserialization of cookies ($ _COOKIE). </li><li>  Indication and processing of downloaded files ($ _FILES). </li><li>  Encapsulation of CGI / SAPI parameters ($ _SERVER). </li></ul><br>  Arguments from the request string, data from the request body and cookies can be obtained from different parts of the request, but it would be convenient if this was implemented for us.  There are times when we may need to work with these values: <br><ul><li>  For an API, data can be in XML or JSON format and can be transferred not only by the POST method.  That is, we must decrypt the data and then reintroduce it into the request. </li><li>  Many frameworks now encrypt cookies, and this means that they need to be decrypted and embedded in the request. </li></ul><br>  So, PSR-7 provides a special interface, ServerRequestInterface, which extends the basic RequestInterface, which describes the functions of working with similar data: <br><pre> <code class="php hljs">$query = $request-&gt;getQueryParams(); $body = $request-&gt;getBodyParams(); $cookies = $request-&gt;getCookieParams(); $files = $request-&gt;getFileParams(); $server = $request-&gt;getServerParams();</code> </pre><br>  Imagine that you are writing an API and want to accept requests in JSON format;  doing this might look like this: <br><pre> <code class="php hljs">$accept = $request-&gt;getHeader(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! $accept || ! preg_match(<span class="hljs-string"><span class="hljs-string">'#^application/([^+\s]+\+)?json#'</span></span>, $accept)) { $response-&gt;getBody()-&gt;write(json_encode([ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">405</span></span>, <span class="hljs-string"><span class="hljs-string">'detail'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'This API can only provide JSON representations'</span></span>, ])); emit($response -&gt;withStatus(<span class="hljs-number"><span class="hljs-number">405</span></span>, <span class="hljs-string"><span class="hljs-string">'Not Acceptable'</span></span>) -&gt;withHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/problem+json'</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(); } $body = (string) $request-&gt;getBody(); $request = $request -&gt;withBodyParams(json_decode($body));</code> </pre><br>  The example above demonstrates several features.  First, it shows the extraction of the header from the query, and the branching of logic based on this header.  Secondly, it shows the formation of the request object in the event of an error (the emit () function is hypothetical, it accepts the request object and gives the headers and the request body).  Finally, the example demonstrates getting the request body, deserializing it, and inserting it back into the request. <br><br><h2>  Attributes </h2><br>  Another feature of server requests is attributes.  They are designed to store values ‚Äã‚Äãthat are obtained from the current query.  A common use case is storing routing results (splitting a URI into key / value pairs). <br>  Working with attributes consists of the following methods: <br><ul><li>  getAttribute ($ name, $ default = null) to get a specific attribute and return a default value if the attribute is not found. </li><li>  getAttributes () retrieves all attributes. </li><li>  withAttribute ($ name, $ value) to return a new ServerRequestInterface instance that contains this attribute. </li><li>  withoutAttribute (($ name) to return the ServerRequestInterface instance without the specified attribute. </li></ul><br>  As an example, let's take Aura Router with our query instance: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Aura</span></span>\<span class="hljs-title"><span class="hljs-title">Router</span></span>\<span class="hljs-title"><span class="hljs-title">Generator</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Aura</span></span>\<span class="hljs-title"><span class="hljs-title">Router</span></span>\<span class="hljs-title"><span class="hljs-title">RouteCollection</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Aura</span></span>\<span class="hljs-title"><span class="hljs-title">Router</span></span>\<span class="hljs-title"><span class="hljs-title">RouteFactory</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Aura</span></span>\<span class="hljs-title"><span class="hljs-title">Router</span></span>\<span class="hljs-title"><span class="hljs-title">Router</span></span>; $router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RouteCollection(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RouteFactory()), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Generator() ); $path = $request-&gt;getUri()-&gt;getPath(); $route = $router-&gt;match($path, $request-&gt;getServerParams()); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($route-&gt;params <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $param =&gt; $value) { $request = $request-&gt;withAttribute($param, $value); }</code> </pre><br>  The query instance in this case is used to organize the data and transfer it to the route.  Routing results are then used to create an instance of the response. <br><br><h2>  Use cases </h2><br>  Now, after a quick tour of the various components of the PSR-7, let's go back to the specific use cases. <br><br><h3>  Customers </h3><br>  For me, the main creator of the PSR-7 standard is <a href="http://mtdowling.com/">Michael Dowling</a> , the author of the popular HTTP client <a href="http://guzzlephp.org/">Guzzle</a> .  Therefore, it is clear that PSR-7 will bring HTTP improvements to clients.  Let's discuss how. <br>  Firstly, this means that developers will have a unique messaging interface for executing requests;  they can send the request object using the PSR-7 standard to the client and receive the response object back using the same standard. <br><pre> <code class="php hljs">$response = $client-&gt;send($request);</code> </pre><br>  Because messages and URIs are modeled as value objects, it also means that developers can create basic request instances and URIs and create separate requests and URIs from them: <br><pre> <code class="php hljs">$baseUri = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">'https://api.example.com'</span></span>); $baseRequest = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request()) -&gt;withUri($baseUri) -&gt;withHeader(<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>, $apiToken); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($action = $queue-&gt;dequeue()) { <span class="hljs-comment"><span class="hljs-comment">//   !   // URI      . $request = $baseRequest -&gt;withMethod($action-&gt;method) -&gt;withUri($baseUri-&gt;withPath($action-&gt;path)); //  URI! foreach ($action-&gt;headers as $header =&gt; $value) { //      ,    //     ! $request = $request-&gt;withHeader($header, $value); } $response = $client-&gt;send($request); $status = $response-&gt;getStatusCode(); if (! in_array($status, range(200, 204))) { //  ! break; } //  ! $data-&gt;enqueue(json_decode((string) $response-&gt;getBody())); }</span></span></code> </pre><br>  What the PSR-7 offers is a standard way to interact with the requests that you send to the client and the answers you receive.  By implementing value objects, we open up the possibility of some interesting use cases with an eye to simplifying the ‚Äúreset request‚Äù pattern ‚Äî changing the request always results in a new instance, allowing us to have a basic instance with a known state, which we can always expand. <br><br><h2>  Connecting link </h2><br>  I will not dwell on this for a long time, because  already did it in the <a href="http-middleware-and-psr-7.html">article</a> .  The basic idea, briefly, is this: <br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ServerRequestInterface $request, ResponseInterface $response, callable $next = null )</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  The function accepts two HTTP messages, and performs some transformations with them (which may include delegation to the next available link).  Typically, these links return a response object. <br>  Another option that is often used is lambda expressions (thanks to <a href="http://www.garfieldtech.com/">Larry Garfield</a> , who sent this term to me in the mail!): <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* response = */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre><br>  In the lambda link, you make one in the other: <br><pre> <code class="php hljs">$inner = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }; $outer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($inner)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> $response = $inner($request); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }; $response = $outer($request);</code> </pre><br>  Finally, there is a method promoted by Rack and WSGI, in which each link is an object and passes to the exit: <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $wrapped; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $wrapped)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapped = $wrapped; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ServerRequestInterface $request, ResponseInterface $response )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   $new = $request-&gt;withAttribute('foo', 'bar'); //  ,   : $result = ($this-&gt;wrapped)($new, $response); // ,      if ($result instanceof ResponseInterface) { $response = $result; } //      return $reponse-&gt;withHeader('X-Foo', 'Bar'); } }</span></span></code> </pre><br>  The use of an intermediate link is that it implements the connection between request and response and follows the standard: a predictable pattern with predictable behavior.  This is a great method of writing web components that can be reused. <br><br><h2>  Frameworks </h2><br>  One thing that frameworks have been offering for many years is ... a layer of abstraction over HTTP messages.  The purpose of PSR-7 is to provide a common set of interfaces for frameworks so that the latter can use the same abstractions.  This will allow developers to write reusable, framework-independent code, or at least that's what I would like to see! <br>  Consider the Zend Framework 2. It defines the Zend \ Stdlib \ DispatchableInterface interface, which is the base for any controller that you are going to use in the framework: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">RequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">ResponseInterface</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchableInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( RequestInterface $request, ResponseInterface $response )</span></span></span></span>; }</code> </pre><br>  This is the intermediate we described above;  the only difference is that it uses HTTP framework implementations specific to this framework.  What if, instead, it will support PSR-7? <br>  Most implementations of HTTP messages in frameworks are built in such a way that you can change the status of a message at any time.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes this may not be entirely true, especially assuming that the state of the message may already be invalid. But this is perhaps the only drawback of this method. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PSR-7 messages are value objects. Thus, you do not need to inform the application in any way about any change in the messages. This makes the implementation more explicit and easy to track in your code (and step by step in the debugger, and using static code analyzers). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example, if ZF2 is updated in accordance with PSR-7, developers will not be required to inform MvcEvent of any changes they want to pass on to the following clients:</font></font><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   $request = $request-&gt;withAttribute('foo', 'bar'); $response = $response-&gt;withHeader('X-Foo', 'bar'); $event = $this-&gt;getEvent(); $event-&gt;setRequest($request) -&gt;setResponse($response);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code above clearly shows that we are changing the state of the application. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using value objects makes one particular practice simpler: distributing subqueries or implementing Hierarchical MVC (HMVC). In this case, you can create new requests based on the current one without informing the application about it, and being sure that the status of the application will not change. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, for most frameworks, using PSR-7 messages will translate to portable abstraction over HTTP messages. This will make it possible to implement a universal intermediate. Adaptation of messages, however, will require minor changes. Developers need to update the code responsible for tracking application state.</font></font><br><br><h2>  Sources </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you see the advantage that the PSR-7 standard provides: a unified, complete abstraction over HTTP messages. </font><font style="vertical-align: inherit;">Further, this abstraction can be used for each part of the HTTP transaction (where you send requests through the HTTP client, or parse the server request). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PSR-7 specification is not yet complete. </font><font style="vertical-align: inherit;">But what I have outlined above will not undergo significant changes without a vote. </font><font style="vertical-align: inherit;">More details on the specification can be on the link:</font></font><br><ul><li> <a href="https://github.com/php-fig/fig-standards/blob/master/proposed/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I also recommend that you read the ‚Äúexplanatory note‚Äù, as it describes the ideas, the developed solutions and the results of (endless) disputes over two years: </font></font><br><ul><li> <a href="https://github.com/php-fig/fig-standards/blob/master/proposed/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/php-fig/fig-standards/blob/master/proposed/http-message-meta.md</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The latest updates are published in the psr / http-message package, which you can install via </font></font><a href="https://getcomposer.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is always the latest updated offers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I created a library, phly / http, which offers a concrete implementation of the proposed interfaces. </font><font style="vertical-align: inherit;">It can also be installed via composer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, if you want to experiment with an intermediate based on PSR-7, I suggest the following options:</font></font><br><ul><li> <a href="https://github.com/phly/conduit"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">phly / conduit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ported to the Sencha </font></font><a href="https://github.com/senchalabs/connect"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">, using phly / http and psr / http-message as its base.</font></font></li><li> <a href="https://github.com/Crell/stacker"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stacker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://stackphp.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackPHP is a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kind of implementation written by Larry Garfield.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I see the future of development with PSR-7. </font><font style="vertical-align: inherit;">And I believe that it will generate a completely new generation of PHP applications.</font></font></div><p>Source: <a href="https://habr.com/ru/post/250343/">https://habr.com/ru/post/250343/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250333/index.html">Digest of good educational programs for IT-specialists and sympathizers: in Moscow and online</a></li>
<li><a href="../250335/index.html">How does ABAP Secure Storage work in SAP?</a></li>
<li><a href="../250337/index.html">We are forbidden to even talk about cryptocurrency?</a></li>
<li><a href="../250339/index.html">TLS hacking with cash prize</a></li>
<li><a href="../250341/index.html">External hardware driver for 1C on the example of the Maria-301MTM fiscal recorder</a></li>
<li><a href="../250345/index.html">Pack the cluster in a box!</a></li>
<li><a href="../250347/index.html">Password cracking on Mac with Arduino and OpenCV</a></li>
<li><a href="../250349/index.html">The results of the Olympiad on programming among schoolchildren</a></li>
<li><a href="../250353/index.html">Webinars on new features RAD Studio XE7</a></li>
<li><a href="../250355/index.html">High-tech gifts for Valentine's Day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>