<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Through thorns to Haskell (translation). 2/2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second part of the TRANSFER is a short and hard introduction to Haskell. The first can be found here. 

 Original here 


- Damn hard part We deal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Through thorns to Haskell (translation). 2/2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/48f/617/aa4/48f617aa492ef81587b120c22a7679a0.jpg"><br><br>  The second part of the <b>TRANSFER is a</b> short and hard introduction to Haskell.  The first can be found <a href="http://habrahabr.ru/post/152889/">here.</a> <br><br>  Original <a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/">here</a> <br><ul><li>  <a href="https://habr.com/ru/post/153383/">Damn hard part</a> <br><ul><li>  <a href="https://habr.com/ru/post/153383/">We deal with IO</a> </li><li>  <a href="https://habr.com/ru/post/153383/">Explain trick with IO</a> </li><li>  <a href="https://habr.com/ru/post/153383/">Monads</a> <br><ul><li>  <a href="https://habr.com/ru/post/153383/">Maybe this is a monad</a> </li><li>  <a href="https://habr.com/ru/post/153383/">Monad Lists</a> </li></ul><br></li></ul><br></li><li>  <a href="https://habr.com/ru/post/153383/">application</a> <br><ul><li>  <a href="https://habr.com/ru/post/153383/">A few more words about the endless tree</a> </li></ul><br></li></ul><br><a name="habracut"></a><br><a name="hell-difficulty-part"></a><br><h2>  Damn hard part </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Congratulations!  You got really far away. <br>  And now trash, waste and sodomy will begin :). <br><br>  If we are like you, you have already moved into a functional style a bit.  You understand the advantages that laziness gives by default.  But you still do not quite understand how you can write a really useful program.  In particular: <br><br><ul><li>  What to do with side effects? </li><li>  Why did you need such a strange syntax for working with input-output (IO)? </li></ul><br><br>  Get ready, the answers may not be the easiest. <br>  But the benefits of them will be certain. <br><br><hr><br>  <a href="">03_Hell / 01_IO / <strong>01_progressive_io_example.lhs</strong></a> <br><br><a name="deal-with-io"></a><br><h3>  We deal with IO </h3><br><br><blockquote>  <abbr title="Too long; didn't read">tl; dr</abbr> : <br><br>  A typical function that works with <code>IO</code> looks almost like an imperative program: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a f = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- action1 action2 x y &lt;- action3 action4 xy</code> </pre><br><ul><li>  To assign a value to an object, we use <code>&lt;-</code> . </li><li>  In this example, the type of expression in each line is <code>IO *</code> ; <br><ul><li> <code>action1 :: IO b</code> </li> <li> <code>action2 x :: IO ()</code> </li> <li> <code>action3 :: IO c</code> </li> <li> <code>action4 xy :: IO a</code> </li> <li>  <code>x :: b</code> , <code>y :: c</code> </li></ul><br></li><li>  Several objects have type <code>IO a</code> . <br>  With such objects, you cannot use pure functions. <br>  In order to use pure functions, you will have to do <code>action2 (purefunction x)</code> . </li></ul><br></blockquote><br><br>  In this section, I will show how to use IO, but not how it works. <br>  You will see how Haskell separates the pure parts of the program from the parts with side effects. <br><br>  Do not stop, if some details of the syntax will be a little incomprehensible. <br>  We will return to them in the next section. <br><br>  What do we want to get? <br><br><blockquote>  Get a list of numbers from the user.  Print their amount <br></blockquote><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">toList</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] toList input = read (<span class="hljs-string"><span class="hljs-string">"["</span></span> ++ input ++ <span class="hljs-string"><span class="hljs-string">"]"</span></span>) main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"   ( ):"</span></span> input &lt;- getLine print $ sum (toList input)</code> </pre><br><br>  The behavior of this program should be obvious. <br>  But let's look closely at the types. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putStrLn</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () getLine :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> print :: <span class="hljs-type"><span class="hljs-type">Show</span></span> a =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br><br>  Have you noticed that every expression in the <code>do</code> block is of type <code>IO a</code> ? <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">" ... "</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () getLine :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> print <span class="hljs-type"><span class="hljs-type">Something</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br><br>  Also note the behavior of the <code>&lt;-</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">do</span></span> x &lt;- something</code> </pre><br><br>  If <code>something :: IO a</code> , then <code>x :: a</code> . <br><br>  Important note on using <code>IO</code> .  All lines in the do-block should look like one of two ways: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">action1</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a <span class="hljs-comment"><span class="hljs-comment">--      a = ()</span></span></code> </pre><br>  or <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">value</span></span> &lt;- action2 <span class="hljs-comment"><span class="hljs-comment">--  -- bar zt :: IO b -- value :: b</span></span></code> </pre><br><br>  These two entries correspond to different ways of describing actions.  Full awareness of this offer comes at the end of the next section. <br><br>  <a href="">03_Hell / 01_IO / <strong>01_progressive_io_example.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 01_IO / <strong>02_progressive_io_example.lhs</strong></a> <br><br>  Let's take a look at how this program behaves. For example, what happens if a user enters something weird? <br>  We try: <br><br><pre> <code class="haskell hljs"> % runghc <span class="hljs-number"><span class="hljs-number">02</span></span>_progressive_io_example.lhs <span class="hljs-type"><span class="hljs-type">Enter</span></span> a list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> numbers (separated by comma): foo <span class="hljs-type"><span class="hljs-type">Prelude</span></span>.read: no parse</code> </pre><br><br>  Arrrghghhhh!  Devilish error message and program crash! <br>  Then we need to make the first step so that the error message is easy to read. <br><br>  In order to do this, we must understand that something has gone wrong. <br>  One way is to use the <code>Maybe</code> type. <br>  This type is very often used in Haskell programs. <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Maybe</code> </pre><br>  What is this thing?  <code>Maybe</code> is a type that takes one parameter.  Here is its definition: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br><br>  This is a good way to understand if an error occurred while trying to create / calculate a value. <br>  The <code>maybeRead</code> function is a great example of this approach. <br>  This function is similar to the <code>read</code> function (which is very similar to the javascript <code>eval</code> function, which processes a JSON string.), <br>  but if something goes wrong, the result is a <code>Nothing</code> . <br>  And if the result is correct, it will return <code>Just &lt;&gt;</code> . <br>  Do not try to penetrate deeply into this function. <br>  The code in it is of a lower level than <code>read</code> ;  . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybeRead</span></span> :: <span class="hljs-type"><span class="hljs-type">Read</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a maybeRead s = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reads s <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(x,<span class="hljs-string"><span class="hljs-string">""</span></span>)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> x _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br><br>  Now that the code has become more readable, let's write a function that does the following: <br>  if the string came in the wrong format, it will return <code>Nothing</code> . <br>  In other cases, for example, for ‚Äú1,2,3‚Äù, it will return <code>Just [1,2,3]</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">getListFromString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] getListFromString str = maybeRead $ <span class="hljs-string"><span class="hljs-string">"["</span></span> ++ str ++ <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre><br><br>  Now let's test our code using the main function. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"  ,  :"</span></span> input &lt;- getLine <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeList = getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeList <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; print (sum l) <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; error <span class="hljs-string"><span class="hljs-string">"  . ."</span></span></code> </pre><br><br>  In case of an error, we display a nice error message. <br><br>  In this case, the type of each expression in the do-block of the main function remains as <code>IO a</code> . <br>  The only weird thing is <code>error</code> . <br>  The <code>error msg</code> function simply accepts any type of input ( <code>IO ()</code> in our case). <br><br>  Pay attention to a very important thing - the types of all functions are defined in advance. <br>  There is only one function, with type <code>IO</code> and this: <code>main</code> . <br>  This means that main is not a pure function. <br>  But it uses the pure <code>getListFromString</code> function. <br>  Just by looking at the declared types of functions, we can distinguish pure functions from functions with side effects. <br><br><br>  Why are pure functions important? <br>  I may forget some things, but here are three main reasons: <br><br><ul><li>  Clean code is much easier to analyze. </li><li>  Cleanliness protects you from complex reproducible errors due to side effects. </li><li>  You can calculate pure functions in any order, or even in parallel, without any risk. </li></ul><br><br>  For these reasons, you should keep as much code as possible in clean functions. <br><br>  <a href="">03_Hell / 01_IO / <strong>02_progressive_io_example.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 01_IO / <strong>03_progressive_io_example.lhs</strong></a> <br><br>  The next step is to continuously poll the user, until he enters the correct answer. <br><br>  The first part will remain unchanged: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Maybe maybeRead :: Read a =&gt; String -&gt; Maybe a maybeRead s = case reads s of [(<span class="hljs-title"><span class="hljs-title">x</span></span>,"")] -&gt; Just x _ -&gt; Nothing getListFromString :: String -&gt; Maybe [Integer] getListFromString str = maybeRead $ "[" ++ str ++ "]"</code> </pre><br><br>  And now we will write a function that requests a list of numbers, and does not exit until it receives a valid list as input. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] askUser = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"  ,  :"</span></span> input &lt;- getLine <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeList = getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeList <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; return l <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; askUser</code> </pre><br><br>  The type of this function is <code>IO [Integer]</code> . <br>  This means that we get the result of the <code>[Integer]</code> using IO actions. <br>  Some people explain it this way: <br><br><blockquote>  "This is <code>[Integer]</code> inside <code>IO</code> " <br></blockquote><br><br>  If you want to understand the internal structure of the I / O mechanism, read the next section. <br>  But, in truth, if you just want to <em>use</em> IO, just write a few simple programs and don't forget to think about types. <br><br>  As a result, our main function turned out to be much simpler: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> list &lt;- askUser print $ sum list</code> </pre><br><br>  This concludes our introduction to <code>IO</code> .  Everything went very quickly.  Here are a few things that I want you to remember: <br><br><ul><li>  in the <code>do</code> block, each expression must have type <code>IO a</code> . <br>  You have a rather limited set of possible expressions: <br>  <code>getLine</code> , <code>print</code> , <code>putStrLn</code> , etc. </li><li>  Try to use the purest functions to the maximum. </li><li>  type <code>IO a</code> means the following - IO <em>action</em> , which returns a result of type <code>a</code> . <br>  <code>IO</code> type represents actions, and <code>IO a</code> is the type of the function. <br>  If you're still interested, read the next section. </li></ul><br><br>  A bit of practice, and <em>using</em> <code>IO</code> will not be a problem for you. <br><br><blockquote>  <em>Exercises</em> : <br><br><ul><li>  Write a program that summarizes all your arguments.  Hint: use the <code>getArgs</code> function. </li></ul><br></blockquote><br><br>  <a href="">03_Hell / 01_IO / <strong>03_progressive_io_example.lhs</strong></a> <br><br><a name="io-trick-explained"></a><br><h3>  Explain trick with IO </h3><br><img src="http://habrastorage.org/storage2/f0f/3bb/057/f0f3bb057ac8f97fa086adc2331498ab.jpg"><br><blockquote>  <abbr title="Too long; didn't read">tl; dr</abbr> : <br><br>  To distinguish pure functions, <br>  <code>main</code> defined as a function that changes the state of the world <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">World</span></span></code> </pre><br>  Functions with this type are guaranteed to have side effects.  Look at a typical main function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> w0 = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (v1,w1) = action1 w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (v2,w2) = action2 v1 w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (v3,w3) = action3 v2 w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> action4 v3 w3</code> </pre><br>  In this example, many temporary values ‚Äã‚Äã( <code>w1</code> , <code>w2</code> and <code>w3</code> ) <br>  which are used to transfer data to the next action. <br><br>  We write the <code>bind</code> function or <code>(&gt;&gt;=)</code> .  Thanks to <code>bind</code> we no longer need named temporary values. <br><br><pre> <code class="haskell hljs"> main = action1 &gt;&gt;= action2 &gt;&gt;= action3 &gt;&gt;= action4</code> </pre><br><br>  Bonus: Haskell has syntax sugar for us: <br><pre> <code class="haskell hljs"> main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> v1 &lt;- action1 v2 &lt;- action2 v1 v3 &lt;- action3 v2 action4 v3</code> </pre><br></blockquote><br><br>  Why do we need such a strange syntax, and what is the type of <code>IO</code> ?  For now, it all looks like some kind of magic. <br><br>  Forget about pure functions for a while.  Concentrate on the side effects: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] askUser = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"  ,  :"</span></span> input &lt;- getLine <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeList = getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeList <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; return l <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; askUser main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> list &lt;- askUser print $ sum list</code> </pre><br><br>  At first, this code looks as if written in ordinary imperative language. <br>  Haskell is cool enough to make code with side effects look imperative. <br>  If you wanted, you could create a Haskell <code>while</code> analog. <br>  In real life, when working with <code>IO</code> , the imperative style is more appropriate. <br><br>  But you probably noticed that the record is somewhat unusual.  So we got to a detailed description of the reasons. <br><br>  In most languages, the state of the world can be represented as a large implicit global variable.  This implicit variable is accessible from anywhere in your program.  For example, you can write / read from a file in any function.  On the other hand, the presence or absence of a file can be considered as different states of the world. <br><br>  In Haskell, the state of the world is explicit.  We clearly say that the <code>main</code> function can <em>potentially</em> change the state of the world.  And its type will look something like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">World</span></span></code> </pre><br><br>  But this variable is not available to all functions. <br>  Functions working with this variable are not clean. <br>  Functions that do not use it are clean (there are <em>dangerous</em> exceptions to this rule. But in real programs you will not need it. Unless in the case of deep debugging). <br><br>  Haskell believes that the world is an input parameter to the <code>main</code> function. <br>  But the real type of this function is more like <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; ((),<span class="hljs-type"><span class="hljs-type">World</span></span>)</code> </pre><br><br>  (For those who are interested, the type of expression is <code>data IO a = IO {unIO :: State# RealWorld -&gt; (# State# RealWorld, a #)}</code> . All <code>#</code> are related to optimization, and in the example I swapped several fields. But in general, the idea has not changed.) <br><br><br>  Type <code>()</code> is an empty type. <br>  Emptiness. <br><br>  Let's rewrite our function, not forgetting about: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> w0 = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (list,w1) = askUser w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (x,w2) = print (sum list,w1) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x</code> </pre><br><br>  First, all functions with side effects must be of a certain type: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; (a,<span class="hljs-type"><span class="hljs-type">World</span></span>)</code> </pre><br><br>  Where <code>a</code> is the type of result. <br>  For example, the <code>getChar</code> function should be of type <code>World -&gt; (Char,World)</code> . <br><br>  Another unobvious thing is the order of computing functions. <br>  In Haskell, if you try to calculate <code>fab</code> , you will have several options: <br><br><ul><li>  calculate <code>a</code> , then <code>b</code> then <code>fab</code> </li><li>  first calculate <code>b</code> , then <code>a</code> and finally <code>fab</code> . </li><li>  parallel to calculate <code>a</code> and <code>b</code> and then <code>fab</code> </li></ul><br><br>  Since the language is functionally pure - such tricks are real. <br><br>  If you now look at the function main, it is obvious that the first line should be calculated earlier than the second, because the first line, calculate the parameter for the second. <br><br>  This trick works great. <br>  At each step of the calculation, the compiler will pass a pointer to the new modified world. <br>  Under the hood, <code>print</code> works like this: <br><br><ul><li>  print something on the screen </li><li>  change world id </li><li>  return as result <code>((),__)</code> . </li></ul><br><br>  Now the main looks just awful.  Let's do the same with the askUser function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> :: <span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; ([<span class="hljs-type"><span class="hljs-type">Integer</span></span>],<span class="hljs-type"><span class="hljs-type">World</span></span>)</code> </pre><br>  Before <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] askUser = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"  :"</span></span> input &lt;- getLine <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeList = getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeList <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; return l <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; askUser</code> </pre><br>  After <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> w0 = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (_,w1) = putStrLn <span class="hljs-string"><span class="hljs-string">"Enter a list of numbers:"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (input,w2) = getLine w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (l,w3) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; (l,w2) <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; askUser w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (l,w3)</code> </pre><br>  Looks like, but ugly.  Just look at these clumsy <code>w*</code> variables. <br><br>  The lesson we learned is that the naive implementation of I / O in a functionally pure language looks terrible. <br><br>  Fortunately, there is a more direct approach to solving this problem.  We see the pattern.  Each line is represented as: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (y,w') = action xw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br><br>  Even if the first parameter <code>x</code> not needed, the result will be a pair <code>(answer, newWorldValue)</code> .  Each <code>f</code> function must have a type similar to: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; (a,<span class="hljs-type"><span class="hljs-type">World</span></span>)</code> </pre><br>  Moreover, we also noticed that the use of these functions looks very similar: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (y,w1) = action1 w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (z,w2) = action2 w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (t,w3) = action3 w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...</code> </pre><br><br>  Each action can take on input from zero to n parameters.  And, in particular, each action can take as input the result of the previous line. <br><br>  For example, we could write: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (_,w1) = action1 x w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (z,w2) = action2 w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (_,w3) = action3 xz w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...</code> </pre><br><br>  And, of course, <code>actionN w :: (World) -&gt; (a,World)</code> . <br><br><blockquote>  IMPORTANT!  There are only two patterns that are worth paying attention to: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (x,w1) = action1 w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (y,w2) = action2 x w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br>  and <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (_,w1) = action1 w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (y,w2) = action2 w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span></code> </pre><br><br></blockquote><br><br><img src="http://habrastorage.org/storage2/a62/0c3/28c/a620c328cfd9775a82c5f53849b979ea.jpg"><br><br>  And now there will be a small trick. <br>  We will make the variable that stores the state of the world disappear.  We will <code>bind</code> two strings.  To do this, write the function <code>bind</code> . <br>  Her type looks strange at first: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bind</span></span> :: (<span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; (a,<span class="hljs-type"><span class="hljs-type">World</span></span>)) -&gt; (a -&gt; (<span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; (b,<span class="hljs-type"><span class="hljs-type">World</span></span>))) -&gt; (<span class="hljs-type"><span class="hljs-type">World</span></span> -&gt; (b,<span class="hljs-type"><span class="hljs-type">World</span></span>))</code> </pre><br><br>  Don't forget that <code>(World -&gt; (a,World))</code> is the type for IO action. <br>  Let's rename it for simplicity: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">World</span></span></span><span class="hljs-class"> -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">World</span></span></span><span class="hljs-class">)</span></span></code> </pre><br><br>  A couple of examples: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">getLine</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> print :: <span class="hljs-type"><span class="hljs-type">Show</span></span> a =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre><br><br>  <code>getLine</code> is an IO action that takes the world as a parameter and returns a pair <code>(String,World)</code> .  You could say the type of <code>getLine</code> would be an <code>IO String</code> . <br>  We can also perceive it as an IO action, which will return to us the String ‚Äúenclosed inside the IO‚Äù. <br><br>  The <code>print</code> function is also quite interesting.  It takes a parameter as input, which it displays later.  But in fact, it takes two parameters.  The first parameter is the value that will be displayed, the second is the state of the world.  As a result, it returns a pair <code>((),World)</code> .  That is, it changes the state of the world, but does not return any data. <br><br>  This type will allow us to simplify the type definition for the <code>bind</code> function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bind</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a -&gt; (a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> b) -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> b</code> </pre><br><br>  <code>bind</code> takes 2 IO actions as arguments and returns another IO action. <br><br>  Now let's refresh <em>important</em> patterns.  The first was: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (x,w1) = action1 w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (y,w2) = action2 x w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (y,w2)</code> </pre><br><br>  Pay attention to the types: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">action1</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a action2 :: a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> b (y,w2) :: <span class="hljs-type"><span class="hljs-type">IO</span></span> b</code> </pre><br>  Looks familiar, isn't it? <br><pre> <code class="haskell hljs">(bind action1 action2) w0 = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (x, w1) = action1 w0 (y, w2) = action2 x w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (y, w2)</code> </pre><br>  The basic idea is to hide the World parameter with this function.  Go!  Here is approximately what we want to get: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (line1,w1) = getLine w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ((),w2) = print line1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ((),w2)</code> </pre><br><br>  And now, use the bind function: <br><pre> <code class="haskell hljs">(res,w2) = (bind getLine (\l -&gt; print l)) w0</code> </pre><br><br>  Since print is of type <code>(World -&gt; ((),World))</code> , we know that <code>res = ()</code> (null type). <br>  If you don‚Äôt see any special street magic here, try writing a three-line program. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (line1,w1) = getLine w0 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (line2,w2) = getLine w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ((),w3) = print (line1 ++ line2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ((),w3)</code> </pre><br>  Which is similar to the following: <br><pre> <code class="haskell hljs">(res,w3) = bind getLine (\line1 -&gt; bind getLine (\line2 -&gt; print (line1 ++ line2)))</code> </pre><br><br>  And now noticed? <br>  Yes, no more World time variables! <br>  This is <em>MA</em> .  <em>Gi</em> .  <em>I</em> <br><br>  But we can use a different syntax. <br>  Let's replace <code>bind</code> with <code>(&gt;&gt;=)</code> . <br>  <code>(&gt;&gt;=)</code> is an infix function, the same as <br>  <code>(+)</code> ;  remind <code>3 + 4 ‚áî (+) 3 4</code> <br><br><pre> <code class="haskell hljs">(res,w3) = getLine &gt;&gt;= \line1 -&gt; getLine &gt;&gt;= \line2 -&gt; print (line1 ++ line2)</code> </pre><br>  Ho ho ho!  Happy New Year everyone!  Haskell has syntactic sugar for us: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">do</span></span> x &lt;- action1 y &lt;- action2 z &lt;- action3 ...</code> </pre><br><br>  Can be replaced by: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">action1</span></span> &gt;&gt;= \x -&gt; action2 &gt;&gt;= \y -&gt; action3 &gt;&gt;= \z -&gt; ...</code> </pre><br><br>  You can use <code>x</code> in <code>action2</code> and <code>x</code> with <code>y</code> in <code>action3</code> . <br><br>  But what about strings that don't use <code>&lt;-</code> ? <br>  Easy!  We have a <code>blindBind</code> function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">blindBind</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> b blindBind action1 action2 w0 = bind action (\_ -&gt; action2) w0</code> </pre><br><br>  I did not specifically simplify this expression. <br>  Of course, if we want to make the code easier, we can use the operator <code>(&gt;&gt;)</code> . <br><br>  And thus <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">do</span></span> action1 action2 action3</code> </pre><br><br>  Turns into <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">action1</span></span> &gt;&gt; action2 &gt;&gt; action3</code> </pre><br>  By the way, here is another rather useful feature: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">putInIO</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> a putInIO x = <span class="hljs-type"><span class="hljs-type">IO</span></span> (\w -&gt; (x,w))</code> </pre><br><br>  This is the standard way to push pure values ‚Äã‚Äãinto the ‚ÄúIO context‚Äù. <br>  Usually <code>putInIO</code> is called <code>return</code> . <br>  This function name is very confusing when learning Haskell.  <code>return</code> very different from analogues in other languages. <br><br><hr><br>  <a href="">03_Hell / 01_IO / <strong>21_Detailled_IO.lhs</strong></a> <br><br>  Finally, let's rewrite our example: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">askUser</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] askUser = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"  ,  :"</span></span> input &lt;- getLine <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeList = getListFromString input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> maybeList <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> l -&gt; return l <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; askUser main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> list &lt;- askUser print $ sum list</code> </pre><br><br>  Can be rewritten as: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Maybe maybeRead :: Read a =&gt; String -&gt; Maybe a maybeRead s = case reads s of [(<span class="hljs-title"><span class="hljs-title">x</span></span>,"")] -&gt; Just x _ -&gt; Nothing getListFromString :: String -&gt; Maybe [Integer] getListFromString str = maybeRead $ "[" ++ str ++ "]" askUser :: IO [Integer] askUser = putStrLn "  ,  :" &gt;&gt; getLine &gt;&gt;= \input -&gt; let maybeList = getListFromString input in case maybeList of Just l -&gt; return l Nothing -&gt; askUser main :: IO () main = askUser &gt;&gt;= \list -&gt; print $ sum list</code> </pre><br><br>  Now you can compile this code to make sure that it works. <br><br>  And now, let's imagine what it would all look like without <code>(&gt;&gt;)</code> and <code>(&gt;&gt;=)</code> . <br><br>  <a href="">03_Hell / 01_IO / <strong>21_Detailled_IO.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 02_Monads / <strong>10_Monads.lhs</strong></a> <br><a name="monads"></a><br><h3>  Monads </h3><br><img src="http://habrastorage.org/storage2/bf6/e8c/3f3/bf6e8c3f3bfbe56fc1147460dc5d1802.jpg"><br><br>  And now let's reveal the secret secret: <code>IO</code> is a <em>monad</em> . <br>  Using monads means you can use syntax sugar <code>do</code> notations. <br>  But the most important thing is a design pattern that will allow you to write cleaner and more understandable code. <br><br><blockquote>  <strong>Important note</strong> : <br><br><ul><li>  Monads are not necessarily related to side effects! <br>  There are many <em>pure</em> monads. </li><li>  The essence of monads - in the composition of calculations </li></ul><br></blockquote><br><br>  In terms of the Haskell language, <code>Monad</code> is a type class. <br>  To become an instance of this class, you need to define functions <code>(&gt;&gt;=)</code> and <code>return</code> . <br>  The function <code>(&gt;&gt;)</code> will be created automatically based on <code>(&gt;&gt;=)</code> . <br>  Here is the (almost complete) definition of the <code>Monad</code> class: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> m </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (&gt;&gt;=) :: ma -&gt; (a -&gt; mb) -&gt; mb return :: a -&gt; ma (&gt;&gt;) :: ma -&gt; mb -&gt; mb f &gt;&gt; g = f &gt;&gt;= \_ -&gt; g <span class="hljs-comment"><span class="hljs-comment">--         --         fail :: String -&gt; ma fail = error</span></span></code> </pre><br><blockquote>  Remarks: <br><br><ul><li>  the <code>class</code> keyword is not what you think. <br>  The class in Haskell is <em>not a</em> class from OOP. <br>  A class in Haskell is more like an interface in Java or C #. <br>  It would be better to call it <code>typeclass</code> . <br>  What does a lot of classes mean? <br>  For a type to belong to this class, the type must implement all the functions of the class. </li><li>  In this particular case, the type <code>m</code> must be a type that can take an argument. <br>  for example, <code>IO a</code> , and also <code>Maybe a</code> , <code>[a]</code> , etc. </li><li>  To be a useful monad, your function must comply with some laws. <br>  If your function violates these laws, strange things will happen: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> a &gt;&gt;= k == ka m &gt;&gt;= return == m m &gt;&gt;= (\x -&gt; kx &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h</code> </pre><br></li></ul><br></blockquote><br><br><a name="maybe-monad"></a><br><h4>  Maybe is a monad </h4><br><br>  There are many types that are <code>Monad</code> instances. <br>  The easiest example is <code>Maybe</code> . <br>  If you have a set of <code>Maybe</code> values, you can use monads to work with them.  In particular, it can be useful to get rid of nested <code>if..then..else..</code> <br><br>  Imagine a complex banking operation, you can claim a ‚Ç¨ 700 bonus only if you have a history of operations without going into a minus. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deposit</span></span> value account = account + value withdraw value account = account - value eligible :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a,<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> eligible account = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account1 = deposit <span class="hljs-number"><span class="hljs-number">100</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account1 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account2 = withdraw <span class="hljs-number"><span class="hljs-number">200</span></span> account1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account2 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account3 = deposit <span class="hljs-number"><span class="hljs-number">100</span></span> account2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account3 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account4 = withdraw <span class="hljs-number"><span class="hljs-number">300</span></span> account3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account4 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account5 = deposit <span class="hljs-number"><span class="hljs-number">1000</span></span> account4 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account5 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print $ eligible <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-comment"><span class="hljs-comment">-- True print $ eligible 299 -- False</span></span></code> </pre><br>  <a href="">03_Hell / 02_Monads / <strong>10_Monads.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 02_Monads / <strong>11_Monads.lhs</strong></a> <br><br>  And now we introduce order in this code using Maybe and its Monad entity: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deposit</span></span> :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a deposit value account = <span class="hljs-type"><span class="hljs-type">Just</span></span> (account + value) withdraw :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a,<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a withdraw value account = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account &lt; value) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> (account - value) eligible :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> eligible account = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> account1 &lt;- deposit <span class="hljs-number"><span class="hljs-number">100</span></span> account account2 &lt;- withdraw <span class="hljs-number"><span class="hljs-number">200</span></span> account1 account3 &lt;- deposit <span class="hljs-number"><span class="hljs-number">100</span></span> account2 account4 &lt;- withdraw <span class="hljs-number"><span class="hljs-number">300</span></span> account3 account5 &lt;- deposit <span class="hljs-number"><span class="hljs-number">1000</span></span> account4 <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print $ eligible <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Just True print $ eligible 299 -- Nothing</span></span></code> </pre><br><br>  <a href="">03_Hell / 02_Monads / <strong>11_Monads.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 02_Monads / <strong>12_Monads.lhs</strong></a> <br><br>  Not bad, but you can do even better: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deposit</span></span> :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a deposit value account = <span class="hljs-type"><span class="hljs-type">Just</span></span> (account + value) withdraw :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a,<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a withdraw value account = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account &lt; value) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> (account - value) eligible :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> eligible account = deposit <span class="hljs-number"><span class="hljs-number">100</span></span> account &gt;&gt;= withdraw <span class="hljs-number"><span class="hljs-number">200</span></span> &gt;&gt;= deposit <span class="hljs-number"><span class="hljs-number">100</span></span> &gt;&gt;= withdraw <span class="hljs-number"><span class="hljs-number">300</span></span> &gt;&gt;= deposit <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt; return <span class="hljs-type"><span class="hljs-type">True</span></span> main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print $ eligible <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Just True print $ eligible 299 -- Nothing</span></span></code> </pre><br><br>  So, we proved that monads can make our code more elegant. <br>  Generally speaking, this use of <code>Maybe</code> will work in most imperative languages. <br>  This is a fairly natural design. <br><br><blockquote>  Important note: <br><br>  The first calculation, the result of which is <code>Nothing</code> will stop all further calculations. <br>  This means that not all code will be executed. <br>  And this optimization is available to you absolutely free, thanks to the laziness of the language. <br></blockquote><br><br>  You can rewrite this code using the definition <code>(&gt;&gt;=)</code> for <code>Maybe</code> <br>  : <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (&gt;&gt;=) :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; (a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> b) -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> b <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &gt;&gt;= _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) &gt;&gt;= f = fx return x = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><br>  The <code>Maybe</code> monad has proven its usefulness even in such a small example.  We also saw the use of the <code>IO</code> monad.  But there is a more interesting example - lists. <br><br>  <a href="">03_Hell / 02_Monads / <strong>12_Monads.lhs</strong></a> <br><br><hr><br>  <a href="">03_Hell / 02_Monads / <strong>13_Monads.lhs</strong></a> <br><a name="the-list-monad"></a><br><h4>  Monad Lists </h4><br><img src="http://habrastorage.org/storage2/d1c/590/49a/d1c59049a51f3669fa44f1af78c3d85e.jpg"><br>  The list monad allows us to model non-deterministic calculations. <br>  For example: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) allCases = [1..10] resolve :: [(<span class="hljs-type"><span class="hljs-type">Int</span></span>,<span class="hljs-type"><span class="hljs-type">Int</span></span>,<span class="hljs-type"><span class="hljs-type">Int</span></span>)] resolve = do x &lt;- allCases y &lt;- allCases z &lt;- allCases guard $ 4*x + 2*y &lt; z return (<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>,<span class="hljs-title"><span class="hljs-title">z</span></span>) main = do print resolve</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ma. </font><font style="vertical-align: inherit;">Gi. </font><font style="vertical-align: inherit;">I. :</font></font><br><br><pre> <code class="haskell hljs">[(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>),(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>)]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For the monad of the list, there is also syntactic sugar: </font></font><br><br><pre> <code class="haskell hljs"> print $ [ (x,y,z) | x &lt;- allCases, y &lt;- allCases, z &lt;- allCases, <span class="hljs-number"><span class="hljs-number">4</span></span>*x + <span class="hljs-number"><span class="hljs-number">2</span></span>*y &lt; z ]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not give a complete list of monads, there are so many of them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using monads can simplify many tasks. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, monads are very useful for:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Io </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nondeterministic computing </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generating pseudorandom numbers, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> storage configuration </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> working with states </font></font></li><li>  ... </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you get to this place, congratulations! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you know the </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kung fu</font></font></strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> monad! </font><font style="vertical-align: inherit;">(Of course, you will need practice to get used to them. Write a couple of your own. But you have already made a huge step in this direction) </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">03_Hell / 02_Monads / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13_Monads.lhs</font></font></strong></a> <br><a name="appendix"></a><br><h2>  application </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This section is not directly related to learning Haskell. </font><font style="vertical-align: inherit;">We just pay more attention to some details.</font></font><br><br><hr><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">04_Appendice / 01_More_on_infinite_trees / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10_Infinite_Trees.lhs</font></font></strong></a> <br><a name="more-on-infinite-tree"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Something more about endless trees </font></font></h3><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the section </font></font><a href="https://habr.com/ru/post/153383/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infinite structures,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we have dismantled a pair of simple infinite structures. </font><font style="vertical-align: inherit;">Unfortunately, our tree has lost two properties:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no duplicates in the tree nodes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ordered tree </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section we will deal with the first property. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the second - we will weaken it a little, but we will try to be as close to the ideal as possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's create a list of a set of pseudo-random numbers:</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">shuffle</span></span> = map (\x -&gt; (x*<span class="hljs-number"><span class="hljs-number">3123</span></span>) `mod` <span class="hljs-number"><span class="hljs-number">4331</span></span>) [<span class="hljs-number"><span class="hljs-number">1.</span></span>.]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To refresh the memory, let's duplicate the implementation </font></font><code>treeFromList</code> <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeFromList</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">BinTree</span></span> a treeFromList [] = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeFromList (x:xs) = <span class="hljs-type"><span class="hljs-type">Node</span></span> x (treeFromList (filter (&lt;x) xs)) (treeFromList (filter (&gt;x) xs))</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>treeTakeDepth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeTakeDepth</span></span> _ <span class="hljs-type"><span class="hljs-type">Empty</span></span> = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeTakeDepth <span class="hljs-number"><span class="hljs-number">0</span></span> _ = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeTakeDepth n (<span class="hljs-type"><span class="hljs-type">Node</span></span> x left right) = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nl = treeTakeDepth (n<span class="hljs-number"><span class="hljs-number">-1</span></span>) left nr = treeTakeDepth (n<span class="hljs-number"><span class="hljs-number">-1</span></span>) right <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span> x nl nr</code> </pre><br><br>  Let's look at the result: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"take 10 shuffle"</span></span> print $ take <span class="hljs-number"><span class="hljs-number">10</span></span> shuffle putStrLn <span class="hljs-string"><span class="hljs-string">"\ntreeTakeDepth 4 (treeFromList shuffle)"</span></span> print $ treeTakeDepth <span class="hljs-number"><span class="hljs-number">4</span></span> (treeFromList shuffle)</code> </pre><br><br><pre> <code class="haskell hljs">% runghc <span class="hljs-number"><span class="hljs-number">02</span></span>_Hard_Part/<span class="hljs-number"><span class="hljs-number">41</span></span>_Infinites_Structures.lhs take <span class="hljs-number"><span class="hljs-number">10</span></span> shuffle [<span class="hljs-number"><span class="hljs-number">3123</span></span>,<span class="hljs-number"><span class="hljs-number">1915</span></span>,<span class="hljs-number"><span class="hljs-number">707</span></span>,<span class="hljs-number"><span class="hljs-number">3830</span></span>,<span class="hljs-number"><span class="hljs-number">2622</span></span>,<span class="hljs-number"><span class="hljs-number">1414</span></span>,<span class="hljs-number"><span class="hljs-number">206</span></span>,<span class="hljs-number"><span class="hljs-number">3329</span></span>,<span class="hljs-number"><span class="hljs-number">2121</span></span>,<span class="hljs-number"><span class="hljs-number">913</span></span>] treeTakeDepth <span class="hljs-number"><span class="hljs-number">4</span></span> (treeFromList shuffle) &lt; <span class="hljs-number"><span class="hljs-number">3123</span></span> : |<span class="hljs-comment"><span class="hljs-comment">--1915 : | |--707 : | | |--206 : | | `--1414 : | `--2622 : | |--2121 : | `--2828 : `--3830 : |--3329 : | |--3240 : | `--3535 : `--4036 : |--3947 : `--4242</span></span></code> </pre><br>  Hooray!  Earned!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But it will only work if you have something to add to the branch. </font></font><br><br>  For example: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeTakeDepth</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> (treeFromList [<span class="hljs-number"><span class="hljs-number">1.</span></span>.])</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will run forever. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is because the code is trying to get the expression head </font></font><code>filter (&lt;1) [2..]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But </font></font><code>filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not smart enough to understand that the result of the expression will be an empty list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nevertheless, this is a good example of what loose programs can do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reader Exercise:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prove the existence of such a number </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that </font></font><code>treeTakeDepth n (treeFromList shuffle)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will fall into an infinite loop.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the upper bound for </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prove that there is no such </font></font><code>shuffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list, executing which, the program will end.</font></font></li></ul><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">04_Appendice / 01_More_on_infinite_trees / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10_Infinite_Trees.lhs</font></font></strong></a> <br><br><hr><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">04_Appendice / 01_More_on_infinite_trees / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11_Infinite_Trees.lhs</font></font></strong></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Davate is slightly modified </font></font><br> <code>treeFromList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>shuffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in order to get rid of this problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first problem is the lack of random numbers in our implementation </font></font><code>shuffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We generated only </font></font><code>4331</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">different numbers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improve our function </font></font><code>shuffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">shuffle</span></span> = map rand [<span class="hljs-number"><span class="hljs-number">1.</span></span>.] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rand x = ((px) `mod` (x+c)) - ((x+c) `div` <span class="hljs-number"><span class="hljs-number">2</span></span>) px = m*x^<span class="hljs-number"><span class="hljs-number">2</span></span> + n*x + o <span class="hljs-comment"><span class="hljs-comment">-- some polynome m = 3123 n = 31 o = 7641 c = 1237</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This version of the function is good because (I sincerely hope) has no upper and lower bounds on the values. </font><font style="vertical-align: inherit;">But the improvements in shuffle are not enough to avoid an endless loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strictly speaking, we cannot say if the list is empty </font></font><code>filter (&lt;x) xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, I‚Äôll break our binary tree implementation a bit. </font><font style="vertical-align: inherit;">In the new implementation for some nodes the following condition will not be met:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Any element of the left (or right) must be strictly less (or greater) than the value in the root of the tree. </font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the tree will remain </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> orderly. </font><font style="vertical-align: inherit;">Moreover, at the stage of creating a tree, we will ensure the uniqueness of the nodes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the new version, </font></font><code>treeFromList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we just replaced it </font></font><code>filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>safefilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeFromList</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> a) =&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">BinTree</span></span> a treeFromList [] = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeFromList (x:xs) = <span class="hljs-type"><span class="hljs-type">Node</span></span> x left right <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> left = treeFromList $ safefilter (&lt;x) xs right = treeFromList $ safefilter (&gt;x) xs</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function is </font></font><code>safefilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost identical </font></font><code>filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but does not fall into an infinite loop when processing infinite trees. </font><font style="vertical-align: inherit;">If she cannot find a suitable element in 10,000 steps, she interrupts the search.</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">safefilter</span></span> :: (a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; [a] -&gt; [a] safefilter fl = safefilter' fl nbTry <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> nbTry = <span class="hljs-number"><span class="hljs-number">10000</span></span> safefilter' _ _ <span class="hljs-number"><span class="hljs-number">0</span></span> = [] safefilter' _ [] _ = [] safefilter' f (x:xs) n = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fx <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> x : safefilter' f xs nbTry <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> safefilter' f xs (n<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's launch the program and rejoice: </font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> putStrLn <span class="hljs-string"><span class="hljs-string">"take 10 shuffle"</span></span> print $ take <span class="hljs-number"><span class="hljs-number">10</span></span> shuffle putStrLn <span class="hljs-string"><span class="hljs-string">"\ntreeTakeDepth 8 (treeFromList shuffle)"</span></span> print $ treeTakeDepth <span class="hljs-number"><span class="hljs-number">8</span></span> (treeFromList $ shuffle)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may have noticed that the delay between the mappings of different values ‚Äã‚Äãis not the same. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This comes because Haskell computes each value as needed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the need comes at the time of displaying the number on the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if you increase the search depth from </font></font><code>8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function will work, and it will not devour all the RAM! </font></font><br><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reader Exercise:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even for large values </font></font><code>deep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>nbTry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the function works fine. But in the worst case, we can expect an exponential growth. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the worst possible list option for </font></font><code>treeFromList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hint</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : think about ( </font></font><code>[0,-1,-1,....,-1,1,-1,...,-1,1,...]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first I tried to implement </font></font><code>safefilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><pre> safefilter' fl = if filter f (take 10000 l) == []<font></font>
                  then []<font></font>
                  else filter fl<font></font>
</pre><br> ,    . <br></li><li> ,  <code>shuffle</code>    . <br>     ,  ,   100%   . <br>     <br> (,     <code>safefilter'</code> ) <br>    <code>f</code>      <br> treeFromList' shuffle.  . <br></li></ul><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeFromList'</span></span> [] n = <span class="hljs-type"><span class="hljs-type">Empty</span></span> treeFromList' (x:xs) n = <span class="hljs-type"><span class="hljs-type">Node</span></span> x left right <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> left = treeFromList' (safefilter' (&lt;x) xs (fn) right = treeFromList' (safefilter' (&gt;x) xs (fn) f = ???</code> </pre><br><br> <a href="">04_Appendice/01_More_on_infinite_trees/ <strong>11_Infinite_Trees.lhs</strong></a> <br><br><a name="thanks"></a><br><h2>  ( ,  ) </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank </font></font><a href="http://reddit.com/r/haskell"><code>/r/haskell</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font><br> <a href="http://reddit.com/r/programming"><code>/r/programming</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your comments are invaluable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, I want to thank </font></font><a href="https://github.com/Emm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emm a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thousand times </font><font style="vertical-align: inherit;">for the time spent on correcting my English text. </font><font style="vertical-align: inherit;">Thank's man.</font></font></div><p>Source: <a href="https://habr.com/ru/post/153383/">https://habr.com/ru/post/153383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153373/index.html">Books that a Java programmer should read: from beginner to professional</a></li>
<li><a href="../153375/index.html">"Java-Oscar" has found its new owner</a></li>
<li><a href="../153377/index.html">Catalog of services for searching contacts of customers and performers on free-lance.ru</a></li>
<li><a href="../153379/index.html">Interview with astrophysicist Neil Tyson</a></li>
<li><a href="../153381/index.html">Finger Prostheses</a></li>
<li><a href="../153385/index.html">Painless migration from Gitosis to Gitolite</a></li>
<li><a href="../153387/index.html">Connecting an ASP.NET MVC project to an ASP.NET WebForms project</a></li>
<li><a href="../153389/index.html">Everything you wanted to know about implantable tags, but were afraid to ask</a></li>
<li><a href="../153391/index.html">Getting Genuine Windows Subsystem (csrss.exe) Process</a></li>
<li><a href="../153395/index.html">Weather station on STM32L-DISCOVERY</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>