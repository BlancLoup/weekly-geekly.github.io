<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Library of quick path search on the graph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello friends! 


 I have written a library for searching paths on arbitrary graphs, and I would like to share it with you . 


 An example of use on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Library of quick path search on the graph</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello friends! </p><br><p>  I have written a library for searching paths on arbitrary graphs, and I would like to <a href="">share it with you</a> . </p><br><p>  An example of use on a huge graph: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hGeZuIEV6KU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Play with the demo <a href="https://anvaka.github.io/ngraph.path.demo/">here</a> </p><br><p> The library uses the little-known <code>A*</code> search variant, which is called <a href="https://repub.eur.nl/pub/16100/ei2009-10.pdf"><code>NBA*</code></a> .  This is a bidirectional search, with relaxed requirements for a heuristic function, and a very aggressive completion criterion.  Despite its little knownness, the algorithm has an excellent rate of convergence to the optimal solution. </p><br><p>  Description of different options <code>A*</code> more than once met in Habr√©.  I really liked <a href="https://habrahabr.ru/company/2gis/blog/326638/">this</a> , because I will not repeat in this article.  Under the cut I will tell you more about why the library works quickly and how the demo was done. </p><a name="habracut"></a><br><h1 id="pochemu-biblioteka-rabotaet-bystro">  Why does the library run fast? </h1><br><blockquote>  "Somehow I can not believe that so quickly. You definitely do not think in advance?" <br>  <em>The reaction of a friend who first saw the library.</em> </blockquote><p>  I must admit right away that I do not believe that my implementation is the fastest possible one.  It works quickly enough considering the environment in which it is located (browser, javascript).  Its speed will strongly depend on the size of the graph.  And, of course, what is now in the <a href="">repository</a> can be accelerated and improved. </p><br><h2 id="statistika">  Statistics </h2><br><p>  To measure performance, I took a graph of roads from New York (~ <code>730 000</code> ribs, <code>260 000</code> knots).  The table below shows the statistics of the time needed to solve one task of finding a path of 250 randomly selected: </p><br><table><thead><tr><th></th><th>  The average </th><th>  Median </th><th>  Min </th><th>  Max </th><th>  p90 </th><th>  p99 </th></tr></thead><tbody><tr><td>  A * lazy (local) </td><td>  32ms </td><td>  24ms </td><td>  0ms </td><td>  179ms </td><td>  73ms </td><td>  136ms </td></tr><tr><td>  NBA * </td><td>  44ms </td><td>  34ms </td><td>  0ms </td><td>  222ms </td><td>  107ms </td><td>  172ms </td></tr><tr><td>  A *, unidirectional </td><td>  55ms </td><td>  38ms </td><td>  0ms </td><td>  356ms </td><td>  123ms </td><td>  287ms </td></tr><tr><td>  Dijkstra </td><td>  264ms </td><td>  258ms </td><td>  0ms </td><td>  782ms </td><td>  483ms </td><td>  631ms </td></tr></tbody></table><br><p>  Each algorithm solved the same problem.  <code>A* </code> is the fastest, but its solution is not always optimal.  In fact, it is bidirectional <code>A*</code> which immediately comes out as soon as both searches have met.  <code>NBA*</code> bidirectional, converges to the optimal solution.  In <code>99%</code> it took him less than <code>172</code> milliseconds to find the shortest path (p99). </p><br><h2 id="optimizacii">  Optimization </h2><br><p>  The library works relatively quickly for several reasons. </p><br><p>  First, I <a href="">changed the data structure in the priority queue</a> so that the priority update of any queue element takes <code>O(lg n)</code> time.  This is achieved by the fact that each element tracks its position on the heap during queue restructuring. </p><br><p>  Secondly, during stress tests, I noticed that garbage collection takes considerable time.  This is not surprising, since the algorithm creates many small objects when it walks through the graph.  Solves the problem with the garbage collector using a <a href="">pool of objects</a> .  This is a data structure that allows you to reuse objects when they are no longer needed. </p><br><p>  Finally, the <code>NBA*</code> search algorithm has a very beautiful and hard criterion for visiting nodes. </p><br><p>  Frankly, I think that this is not the limit of perfection.  It is likely, if you use the hierarchical approach <a href="https://habrahabr.ru/company/2gis/blog/326638/">described by Boris,</a> it will be possible to speed up time for even larger graphs. </p><br><h1 id="kak-rabotaet-demo">  How does the demo work? </h1><br><p>  Creating a library is, of course, very interesting.  But it seems to me that the demo project deserves a separate description.  I learned a few lessons, and would like to share with you, in the hope that this will prove useful. </p><br><p>  Before we begin.  Someone asked me: "But this is a graph? How can a map be represented as a graph?"  It is easiest to imagine each intersection as a node graph.  Each intersection has a position <code>(x, y)</code> .  Each straight stretch of road will make an edge of the graph.  Road bends can be modeled as a special case of intersections. </p><br><h2 id="gotovim-dannye">  Preparing data </h2><br><p>  Of course, I heard about <a href="https://www.openstreetmap.org/">https://www.openstreetmap.org</a> , but their appearance did not appeal to me very much.  When I discovered an API and tools like <a href="http://overpass-turbo.eu/">http://overpass-turbo.eu/</a> , this is how a new world opened up before my eyes :).  They give the data under the license <a href="https://opendatacommons.org/licenses/odbl/summary/">ODbL</a> , which requires that they be mentioned (the more people know about the service - the better the service becomes). </p><br><p>  The API allows you to make very complex queries, and gives you tremendous amounts of information. </p><br><p>  For example, such a request will give all the cycle roads in Moscow: </p><br><pre> <code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">out:json</span></span>]; //     <span class="hljs-code"><span class="hljs-code">`a`</span></span> (area[<span class="hljs-string"><span class="hljs-string">"name"=""</span></span>])-&gt;.a; //     a    <span class="hljs-code"><span class="hljs-code">`highway == cycleway`</span></span> way[<span class="hljs-string"><span class="hljs-string">"highway"="cycleway"</span></span>](<span class="hljs-link"><span class="hljs-link">area.a</span></span>); //       (  ) node(w); // ,   out meta;</code> </pre> <br><p>  The API is very well described here: <a href="http://wiki.openstreetmap.org/wiki/Overpass_API">http://wiki.openstreetmap.org/wiki/Overpass_API</a> </p><br><p>  I wrote <a href="https://github.com/anvaka/playground/tree/master/extract-osm-roads">three small scripts</a> to automate getting roads for cities, and save them in my graph format. </p><br><h2 id="sohranyaem-graf">  Save the graph </h2><br><p>  Data OSM gives in the form of XML or JSON.  Unfortunately, both formats are too voluminous - the map of Moscow with all the roads takes about <code>47MB</code> .  My task was to make the site load as quickly as possible (even on a mobile connection). </p><br><p>  It would be possible to try to compress <code>gzip</code> 'om - the map of Moscow from 47MB turns into 7.1MB.  But with this approach, I would not have control over the speed of data unpacking - they would have to be parsed with javascript on the client, which would also affect the initialization speed. </p><br><p>  I decided to write my own format for the graph.  The graph is split into two binary files.  One with the coordinates of all the vertices, and the second with a description of all the edges. </p><br><p>  The file with coordinates is simply a sequence of <code>x, y</code> pairs (int32, 4 bytes per coordinate).  The offset for which is a pair of coordinates, I consider as a node identifier ( <code>nodeId</code> ). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/abc/ea4/5eb/abcea45ebe2435b91dd6ae2a3bbf4f63.png" alt="coordinates"></p><br><p>  The edges of the graph are transformed into the usual sequence of pairs <code>fromNodeId, toNodeId</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3cd/61b/980/3cd61b98023e2e1c74dd32007f7ad109.png" alt="ribs"></p><br><p>  The sequence in the picture means that the first node refers to the second, and the second refers to the third, and so on. </p><br><p>  The total size for a graph with <code>V</code> nodes and <code>E</code> edges can be calculated as: </p><br><pre> <code class="hljs markdown"> storage_size = V <span class="hljs-bullet"><span class="hljs-bullet">* 4 *</span></span> 2 + # 4       E <span class="hljs-bullet"><span class="hljs-bullet">* 4 *</span></span> 2 = # 4      (V + E) * 8 # ,  </code> </pre> <br><p>  This is not the most efficient compression method, but it is very easy to implement and you can quickly restore the initial graph on the client.  Typed arrays in javascript'e are faster than parsing JSON. </p><br><p>  At first, I also wanted to add edge weights, but I stopped myself, because loading on a weak mobile connection, even for small graphs, will become even slower. </p><br><h2 id="v-pervuyu-ochered-mobilnye-telefony">  Primarily mobile phones </h2><br><p>  When I wrote a demo, I thought I would write about it on Twitter.  Twitter, most people read from mobile phones, and therefore the demo should be primarily designed for mobile phones.  If it does not load quickly, or if it does not support touch, write is gone. </p><br><p>  <em>A couple of days after the announcement, you can recognize the logic above justified.</em>  <em><a href="https://twitter.com/anvaka/status/910921384926134273">Tweet with the announcement of the demo has</a> become the most popular tweet in the life of my twitter.</em> </p><br><p>  I tested the demo primarily on the iPhone and Android platforms.  For tests on Android, I found the cheapest phone and used it.  This has greatly helped with debugging performance and usability on a small screen. </p><br><h2 id="asinhronnost">  Asynchrony </h2><br><p>  The slowest part in the demo was the initial loading of the site.  The code that initialized the graph looked something like this: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; points.length; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nodeId = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(i / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = points[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = points[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// graph  https://github.com/anvaka/ngraph.graph graph.addNode(nodeId, { x, y }) }</span></span></code> </pre> <br><p>  At first glance, nothing bad.  But if you run it on a weak processor and on a large graph - the page becomes dead, while the main thread is busy iterating. </p><br><p>  Output?  I know some use Web Workers.  This is a great solution, considering that everything is multi-core now.  But in my case, using web workers would significantly extend the time required to create a demo.  It would be necessary to think about how to transfer data between threads, how to synchronize, how to save battery life, how to be when web workers are not available, etc. </p><br><p>  Since I did not want to spend more time, I needed a lazier decision.  I decided to just break the loop.  Just run it for a while, see how much time has passed, and then call <code>setTimeout()</code> to continue at the next iteration of the event loop.  All this is done in the <a href="https://github.com/anvaka/rafor">rafor</a> library. </p><br><p>  With this solution, the browser has the opportunity to constantly inform the user about what is happening inside: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a0b/794/63e/a0b79463e048efcb5b5fa56f4d0d5e9e.gif" alt="progress"></p><br><h2 id="otrisovka">  Drawing </h2><br><p>  Now that we have a graph loaded, we need to show it on the screen.  Of course, using SVG to draw a million elements is not good - the speed will begin to sink after the first ten thousand.  It would be possible to cut the graph into tiles, and use <a href="http://leafletjs.com/">Leaflet</a> or <a href="https://openseadragon.github.io/">OpenSeadragon</a> to draw a large picture. </p><br><p>  I also wanted to have more control on the code (and learn WebGL), so I wrote my WebGL drawing tool from scratch.  There I use the scene graph approach.  In this approach, we build a scene from a hierarchy of elements that can be drawn.  During the frame drawing, we go through the graph, and give each node the opportunity to accumulate transformations or display itself on the screen.  If you are familiar with three.js or even the usual DOM, the approach will not be new. </p><br><p>  <em>A drawing tool is available <a href="https://github.com/anvaka/wgl">here</a> , but I intentionally did not document it strongly.</em>  <em>This is a project for my own learning, and I do not want to create the impression that they can be used :)</em> </p><br><h2 id="batareyka">  Battery </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/034/335/dc5/034335dc584ce56cbf1c99507beeee26.png" alt="battery"></p><br><p>  Initially, I redrawed the scene on each frame.  Very quickly, I realized that it was very hot on the phone and the battery went to zero with remarkable speed. </p><br><p>  Writing code under such conditions was just as inconvenient.  To work on a project, I usually sat in a coffee shop in my free time, where there were not always sockets.  Therefore, I had to either learn to think faster, or find a way not to plant a laptop so quickly. </p><br><p>  I still have not found a way to think faster, because I chose the second option.  The solution was naively simple: </p><br><blockquote>  Do not draw a scene on each frame.  Draw only when asked, or when you know that it has changed. </blockquote><p>  It may seem too obvious now, but it was not at all so at first.  After all, basically all examples of using WebGL describe a simple loop: </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(frame)</span></span></span><span class="hljs-function">; //    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderScene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; //   . //     ,        }</span></span></code> </pre> <br><p>  With the "conservative" approach, I had to get the <code>requestAnimationFrame()</code> out of the <code>frame()</code> function: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frameToken = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frameToken) frameToken = requestAnimationFrame(frame); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ frameToken = <span class="hljs-number"><span class="hljs-number">0</span></span>; renderScene(); }</code> </pre> <br><p>  This approach allows anyone to request to draw the next frame.  For example, when the user drags the map and changes the transformation matrix, <a href=""><code>  renderFrame()</code></a> . </p><br><p>  The <code>frameToken</code> variable helps avoid re-calling the <code>requestAnimationFrame</code> between frames. </p><br><p>  Yes, the code is getting a little harder to write, but the life of the battery was more important to me. </p><br><h2 id="tekst-i-linii">  Text and lines </h2><br><p>  WebGL is not the easiest API in the world.  It is especially difficult to work with text and thick lines (whose width is more than one pixel). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/64e/af4/39b/64eaf439b0eb2263481be113f5af8dea.gif" alt="text and lines"></p><br><p>  Considering that I am quite new to this business, I quickly realized that it would take a long time for me to add support for text / lines. </p><br><p>  On the other hand, from the text I needed to draw only a pair of labels <code>A</code> and <code>B</code>  And from the thick lines - only the path that connects the two vertices.  The task is quite capable for DOM'a. </p><br><p>  As you remember, our renderer uses a scene graph.  Why not add another element to the scene whose task it is to apply the current transformation to the ... SVG element?  Make this SVG element transparent and lay it on top of the canvas.  To remove all events from the mouse, we set it <code>pointer-events: none;</code>  . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3f6/710/09e/3f671009e006a992aea5f16876de0504.png" alt="svg top"></p><br><p>  <a href="">It turned out</a> very quickly and angrily. </p><br><h2 id="peremeschaemsya-po-karte">  Move around the map </h2><br><p>  I wanted to make navigation look like typical map behavior (like in Google Maps, for example). </p><br><p>  I have already written a navigation library for SVG: <a href="https://github.com/anvaka/panzoom">anvaka / panzoom</a> .  She supported touch and kinetic damping (when the map continues to move by inertia).  In order to support WebGL, I had to tweak the library a little bit. </p><br><p>  <code>panzoom</code> listens for events from the user ( <code>mousedown</code> , <code>touchstart</code> , etc.), applies smooth transformations to the transformation matrix, and then, instead of working directly with the SVG, it gives the matrix to the "controller".  The task of the controller is to apply the transformation.  The controller can be for SVG, for DOM, or even <a href="">my own controller</a> , which applies the transformation to the WebGL scene. </p><br><h2 id="kak-ponyat-chto-kliknuto">  How to understand what is clicked? </h2><br><p>  We discussed how to load a graph, how to draw it, and how to move along it.  But how to understand what was pressed when the user touches the graph?  Where to pave the way and where? </p><br><p>  When the user clicked on the map, we could the easiest way to bypass all the points in the graph, look at their positions and find the nearest one.  In fact, this is a great way for a couple of thousand points.  If the number of points exceeds tens / hundreds of thousands - the performance will not be acceptable. </p><br><p>  I used a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2">quad tree</a> to index the points.  After the tree is created - the speed of the search for the nearest neighbor becomes logarithmic. </p><br><p>  By the way, if the term "quad tree" sounds frightening - do not be upset!  In fact, quad-trees are very, very similar to ordinary binary trees.  They are easy to learn, easy to implement, and easy to apply. </p><br><p>  In particular, I used my own implementation, <a href="https://github.com/anvaka/yaqt">the yaqt library</a> , because it is unpretentious from memory for my data format.  There are better alternatives, with good documentation and a community (for example, <a href="https://github.com/d3/d3-quadtree">d3-quadtree</a> ). </p><br><h2 id="ischem-put">  Looking for a way </h2><br><p>  Now all parts are in place.  We have a graph, we know how to draw it, we know what was pressed on it.  It remains only to find the shortest path: </p><br><pre> <code class="hljs dos">// pathfinder   https://github.com/anvaka/ngraph.<span class="hljs-built_in"><span class="hljs-built_in">path</span></span> let <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = pathFinder.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(fromId, toId);</code> </pre> <br><p>  Now we have an array of vertices that lie on the found path. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  I hope you enjoyed this little journey into the world of graphs and short cuts.  Please let me know if the library is useful, or if there are tips on how to make it better. </p><br><p>  I sincerely wish you well! <br>  Andrew. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338440/">https://habr.com/ru/post/338440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338430/index.html">REQ Labs 2017. Online conference for business and system analysts</a></li>
<li><a href="../338432/index.html">Uptime day 2: Russian IT companies will talk about how to cope with disasters</a></li>
<li><a href="../338434/index.html">Oblique frustum. Inside the oblique visibility pyramid</a></li>
<li><a href="../338436/index.html">learnopengl. Lessons 3.1 (Assimp) + 3.2 (Mesh class)</a></li>
<li><a href="../338438/index.html">Storage Recycling Analysis</a></li>
<li><a href="../338442/index.html">Stages of development of the Java Online Projects learning project: how it was, an inside look</a></li>
<li><a href="../338444/index.html">VEDO. External electronic document management what it is and how to choose</a></li>
<li><a href="../338450/index.html">How to run your project on Product Hunt: Administration Guide</a></li>
<li><a href="../338452/index.html">Broadcast from the gamedev conference 4C in St. Petersburg. The first day</a></li>
<li><a href="../338454/index.html">The book "ASP.NET Core. Application Development"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>