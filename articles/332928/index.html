<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing Elliptic curve Menezes-Vanstone cryptosystem based on the OpenSSL API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrovchane! As I was able to do cryptography for my modest needs, trying to maintain a decent level of data security (I am guided by the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing Elliptic curve Menezes-Vanstone cryptosystem based on the OpenSSL API</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habrovchane!  As I was able to do cryptography for my modest needs, trying to maintain a decent level of data security (I am guided by the levels specified in the ecrypt section <a href="https://www.keylength.com/">here</a> ), I began to be disturbed by a drop in performance when using the RSA cryptographic algorithm. <br><br>  Unfortunately, this algorithm turned out to be the only one in openssl, which allows encryption / decryption of small data blocks (assumed in the sense of the article - keys for symmetric encryption algorithms) using asymmetric cryptographic algorithms. <br><br>  Walking around the internet, we found out that: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. El-Gamal can successfully encrypt / decrypt, but these operations are not implemented in openssl (there is an implementation in libgcrypt).  In terms of speed, El-Gamal is 3 times faster than RSA <br>  with the same key length and the same cryptographic resistance for 1 key bit. <br><br>  2. The Elliptic Curve cryptosystem (ECC) was pleasantly surprised by the speed and cryptoresistance of 1 bit of the key, but encryption / decryption operations based on ECC are not implemented in openssl. <br>  The implementation of ECC encryption in libgcrypt is, but very specific.  In short, the encrypted message m is mapped to a point on the elliptic curve mG, from which the original message m cannot be received otherwise than by breaking ECC or by enumerating all possible values ‚Äã‚Äãof m. <br><br>  3. In the literature [1] described Menezes-Vanstone ECC, but there are notifications about its "vulnerability" [2] <br>  Let us examine this question in more detail. <br><a name="habracut"></a><br><h3>  A bit of math: </h3><br>  For simplicity, we will only speak about elliptic curves, whose form is described by the Weierstrass equation <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.935ex" height="2.78ex" viewBox="0 -935.7 7291.4 1197.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMATHI-79" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMAIN-32" x="706" y="513"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMAIN-3D" x="1231" y="0"></use><g transform="translate(2287,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMAIN-33" x="809" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMAIN-2B" x="3536" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMATHI-61" x="4536" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMATHI-78" x="5066" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMAIN-2B" x="5861" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/332928/&amp;xid=17259,1500004,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiG4So__SCa4EbsPe3ZRbrk5rfilQ#MJMATHI-62" x="6861" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> y ^ 2 = x ^ 3 + ax + b </script>  over the fields of integers defined as Zp, where Zp is the set of integers less than a certain prime number p and greater than zero. <br><br>  Then E (p, a, b) - where a, b belong to Zp - an elliptic curve over the field Zp, defined by a prime number p and numbers a, b.  Next, you need to define an abstract zero element O (if the coefficient of the Weierstrass equation b is not equal to 0, then you can take the coordinates x = 0, y = 0 as the conditional point O, even if this point is not a solution of the equation) and the operation of adding the curve elements (points) which will give a new point belonging to the same curve. <br><br>  Naturally, it should turn out that P + Q = Q + P, (P + Q) + R = P + (Q + R), P + O = O + P = P and if there is P (x, y), that is, -P = (x, -y) and P + (- P) = PP = O. <br><br>  These are all mathematical operations that are defined for a group of points of an elliptic curve. <br>  In the literature [1] one can find mathematical details on how these operations are determined. <br><br>  You can add different points (P = G + Q) or a point with you (P = Q + Q).  The fact that we will speak about ‚Äúmultiplication‚Äù is just a way to shorten the record, and not to write P = Q + Q + Q + Q + ... + Q m times, but simply write that P = mQ.  In fact, there is no operation ‚Äúmultiplication‚Äù and, accordingly, ‚Äúdivision‚Äù, as well as no ‚Äúexponentiation‚Äù and ‚Äútaking the logarithm‚Äù. <br><br>  This terminology is often used, but for elliptic curves it means not what is usually meant by this.  Summing a point on an elliptic curve with itself m times can be called ‚Äúmultiplication by m‚Äù or even ‚Äúraising to a power of m‚Äù.  The essence of this does not change, and since the inverse operation, ‚Äúdividing‚Äù or ‚Äútaking the logarithm‚Äù does not exist, getting m from the point m * G, even knowing G is impossible, speaks of the ‚Äúproblem of the discrete logarithm on elliptic curves‚Äù.  Such is the well-established terminology. <br><br>  On this curve, we choose (arbitrary) point G (Gx, Gy) which is a generator of a group of points, that is, by specifying different m, we get the result of multiplication mG, which forms a cyclic group of points (since we are in a finite field Zp).  The size of this cyclic group is called the order of the generator point G. <br><br>  Thus, the elliptic group is completely described by the parameters of the curve E (p, a, b), the generator point G (Gx, Gy), and the order of the group ord, and ord * G = O.  These are all called elliptic curve parameters, which are usually well-known, and are identified by names, for example secp192k1 or prime256v1. <br><br>  The user's private key is (secret, random) number 1 &lt;d &lt;ord-1 <br>  The public key of the user is the point Q, which is the product of the private key d and the generator of the group G, Q = dG. <br><br><h3>  What does Elliptic curve Menezes-Vanstone cryptosystem [1] (MVC) offer? </h3><br><br>  Sender side: <br><br>  1. The encrypted message m is divided into two parts x1 and x2, each of which must be an element of the Zp field, for this it is enough to check their length and compare it with the length of the curve parameter p. <br>  2. The sender chooses (secret, random) number 1 &lt;ks &lt;ord-1. <br>  3. The sender multiplies the generator point G by the number ks, y0 = ks * G <br>  4. The sender calculates the point Z (Zx, Zy), multiplying the recipient's public key Q by the number ks, Z = ks * Q <br>  5. The sender calculates y1 = x1 * Zx (mod p), y2 = x2 * Zy (mod p) <br><br>  Computational costs of the sender: generation of a random number of the required length, 2 operations of multiplying a point by a number, 2 operations of multiplying modulo p. <br><br>  The ciphertext is the point y0, the number y1, the number y2.  Point contains 2 numbers - x, y coordinates.  The total amount of ciphertext is approximately 4 * p, for an ECC key with a length of 192 bits (24 bytes) is approximately 24 * 4 = 96 bytes. <br><br>  Recipient's side: <br><br>  1. The recipient checks whether the point y0 belongs to the curve defined by the parameters E (p, a, b), G, ord. <br>  2. The recipient calculates the point Z, multiplying the ciphertext y0 by its private key d, Z = d * y0 = d * ks * G = ks * d * G = ks * Q. <br>  3. The recipient calculates the multiplicative inversion of the components Z (Zx, Zy), e1 = inv (Zx) (mod p), e2 = inv (Zy) (mod p). <br>  4. The receiver recovers x1, x2: x1 = y1 * e1 (mod p), x2 = y2 * e2 (mod p). <br><br>  Computational costs of the recipient: verification of the point to curve, 1 operation of multiplying a point by a number, 2 operations of calculating the multiplicative inversion modulo p, <br>  2 multiplication operations modulo p. <br><br><h3>  MVC vulnerability or weakness </h3><br>  In 1997, Klaus Kiefer [2] showed that MVC is not a system that uses probabilistic encryption, despite its design.  Knowing the ciphertext, knowing the parameters of the curve, it is possible to carry out a "known plaintext attack" (an attack with guessing plaintext). <br><br>  What it looks like: <br><br>  The parameters of the curve E (p, a, b), G, ord are known.  Known ciphertext y0, y1, y2.  We assume that the plaintext is x1, x2. <br><br>  If the point F (f1, f2) f1 = y1 * (inv (x1)) (mod p), f2 = y2 * (inv (x2)) (mod p) belongs to the curve E (p, a, b), then with the probability of error 1 / p x1, x2 is really the desired plaintext. <br><br>  What does this mean in practice? <br><br>  The fact that it is possible to arrange the enumeration of all values ‚Äã‚Äãx1, x2 with computational cost 2 operations of calculating the multiplicative inversion modulo p, 2 multiplication operations modulo p for each variant x1, x2 and with the probability of error 1 / p find the plaintext corresponding to the encrypted one.  A negative test result is always true, a positive one may contain erroneous recognition with a probability of 1 / p.  The iteration operation x1, x2 is well distributed, many processes can independently iterate over their non-overlapping ranges of values ‚Äã‚Äãx1, x2. <br><br>  For reference: I would like to look at the enumeration (just enumeration, without calculations) of all possible key values ‚Äã‚Äãof 192 or 256 bits.  Yes, even 128-168 bits. <br><br>  It is clear that the search can only open small pieces of encrypted data, up to 48-64 bits.  And this brute force can be arranged without MVC, for the task of finding the key by enumerating all possible values, the use of MVC is not necessary, it is an extra entity. <br><br><h3>  What do we have in the end? </h3><br>  If you encrypt large enough (128 bit or more) texts, which exclude the possibility of finding them in a reasonable time and reasonable costs to find them through the search, this ‚Äúvulnerability‚Äù does not play any role. <br><br>  Today, the minimum recommended ECC key length is 192 bits (24 bytes).  The length of the encrypted MVC data in this case should not exceed 2 * 24 = 48 bytes, and the strongest AES or GOST key has a length of 256 bits (32 bytes). <br><br>  But we get crypto-resistant and fairly fast (in my estimation, ECC-224 is 5 times faster than RSA-2048, 3 times faster than ElGamal-2048) asymmetric encryption algorithm. <br>  I believe that the Elliptic curve Menezes-Vanstone cryptosystem is completely undeservedly forgotten. <br>  Trying to fill this gap, I spread the source code in C using the openssl API. <br><br>  Literature: <br>  1. COMPUTER SECURITY AND CRYPTOGRAPHY, ALAN G. KONHEIM, Published by John Wiley &amp; Sons, Inc., Hoboken, New Jersey, 2007. ISBN-13: 978-0-471-94783-7 ISBN-10: 0-471- 94783-0 <br>  2. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.43.9711">‚ÄúA Weakness of Menezes-Vanstone Cryptosystem‚Äù</a> , Klaus Kiefer, member of the research group of prof.  J. Buchmann, 1997 <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // DESCRIPTION 'EC Menezes-Vanstone cryptosystem functions openssl/Linux' // COMPILER 'gcc (GCC) 4.8.2' // FILE 'ecmv.h' // AUTHOR "Nick Korepanov" // Linux-3.10.104, glibc-2.17, OpenSSL 1.0.1u // ECC-192/224/256 // This program is free software; you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation; either version 2 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program; if not, write to the Free Software // Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. // // Author of this program can be contacted by electronic mail // korepanovnd@gmail.com // Copyright (c) 2017 Nick Korepanov. All rights reserved. // This product includes software developed by the OpenSSL Project // for use in the OpenSSL Toolkit. (http://www.openssl.org/) // COMPUTER SECURITY AND CRYPTOGRAPHY, ALAN G. KONHEIM // Published by John Wiley &amp; Sons, Inc., Hoboken, New Jersey, 2007 // Library of Congress Cataloging-in-Publication Data: // Konheim, Alan G., 1934‚Äì // Computer security &amp; cryptography / by Alan G. Konheim. // p. cm. // Includes bibliographical references and index. // ISBN-13: 978-0-471-94783-7 // ISBN-10: 0-471-94783-0 // 1. Computer security. 2. Cryptography. I. Title. // QA76.9.A25K638 2007 // 005.8--dc22 2006049338 // 15.9 THE MENEZES‚ÄìVANSTONE ELLIPTIC CURVE CRYPTOSYSTEM, p. 443 // Another very significant source - "A Weakness of Menezes-Vanstone Cryptosystem", Klaus Kiefer, member of research group of prof. J. Buchmann, 1997 // Shortly, this work show ability of "known plain text attack (KPTA)", with probability O(1/p) of false detection. // What does it mean? If we encrypt 128-bit session key, for success KPTA we must search in 2^128 combinations of session key ... // Known plaintext attack for EC MV cryptosystem // Curve E(p,a,b) known from public key, // y0, y1, y2 - ciphertext // random select 1 &lt; x1 &lt; p and 1&lt; x2 &lt; p // calculate inversion a=inv(x1)(mod p), b=inv(x2)(mod p) // c1=a*y1(mod p), c2=b*y2(mod p) // if C(c1,c2) is point of curve E, x1 and x2 is plaintext with error probability O(1/p) // z=((c1)^3 + a*c1 + b)(mod p) // if (z^((p-1)/2))(mod p) == 1 there are 2 points (c1,+-c2) in curve E(p,a,b) //#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //#include &lt;unistd.h&gt; #include &lt;openssl/rand.h&gt; #define OPENSSL_NO_EC2M #include &lt;openssl/ec.h&gt; #define FORMATBIN 1 #define FORMATHEX 0 struct BinFmt192 // binary format of ECMV encrypted block, EC key = 192 bits { unsigned char y0[1+192/4]; // 2*24 byte BIGNUM + 1 header byte unsigned char z1; unsigned char y1[192/8]; // 24 bytes BIGNUM unsigned char z2; unsigned char y2[192/8]; // 24 bytes BIGNUM unsigned char z3; }; // size = 100 bytes struct BinFmt224 // binary format of ECMV encrypted block, EC key = 224 bits { unsigned char y0[1+224/4]; // 2*28 byte BIGNUM + 1 header byte unsigned char z1; unsigned char y1[224/8]; // 28 bytes BIGNUM unsigned char z2; unsigned char y2[224/8]; // 28 bytes BIGNUM unsigned char z3; }; // size = 116 bytes struct BinFmt256 // binary format of ECMV encrypted block, EC key = 256 bits { unsigned char y0[1+256/4]; // 2*32 byte BIGNUM + 1 header byte unsigned char z1; unsigned char y1[256/8]; // 32 bytes BIGNUM unsigned char z2; unsigned char y2[256/8]; // 32 bytes BIGNUM unsigned char z3; }; // size = 132 bytes // Encrypt plaintext of length len with public EC key pubkey // and store ciphertext in chipher = y0 (point), y1 (bignum), y2 (bignum) // return error code, 0 if all OK // Error codes: /* * 1 // no curve in key? * 2 // wrong plaintext has odd length * 3 // plaintext too long for this key * 8 // binary format of encrypted block not defined for this key length * 4 // internal error: ks is wrong, error in do-while * 5 // internal error: error in EC_POINT_mul y0=ks*g * 6 // internal error: error in EC_POINT_mul z=ks*q * 7 // internal error: error EC_POINT_get_affine_coordinates_GFp * errors 4,5,6,7 lead to memory leak :( * */ // hex format: // Encrypted text consist of 3 hex strings, each is ending with '\n'=0x0A // First string has '04' header and two times longer than second and third // length of encrypted block = 2*4*bits/8 + 5 = bits + 5 bytes, where 'bits' is length of EC key in bits // Plaintext data MUST be of even length in bytes and not longer than 2*bits/8 = bits/4 bytes // bin format: // Encrypted text is binary block consist of 3 binary elements, each is ending with NULL=0x00 byte // First element has 0x04 header and two times longer than second and third // length of encrypted block in binary form = 4*bits/8 + 4 = bits/2 + 4 bytes, where 'bits' is length of EC key in bits // In this example I used 192,224,256 bit EC keys and binary form for other key length don't supported :( int EC_MV_pubkey_encrypt(unsigned char *cipher, EC_KEY* pubkey, unsigned char* plaintext, size_t len, int format); // Decrypt with private EC key privkey ciphertext in cipher = y0 (point), y1 (bignum), y2 (bignum) // and store result in plaintext // return error code, 0 if all OK /* Error codes: * 1 // no curve in key? * 8 // unknown format of ECMV encrypted block * 9 // binary format of encrypted block not defined for this key length * 10 // wrong format of binary encrypted block * 2 // invalid hex point y0 representation * 3,4 // wrong format of HEX encrypted data * 11 // point y0 is not on curve * 6 // internal error: error in EC_POINT_mul z=ks*q * 7 // internal error: error EC_POINT_get_affine_coordinates_GFp * errors 2,3,4,11,6,7 lead to memory leak :( * */ int EC_MV_privkey_decrypt(unsigned char* cipher, EC_KEY *privkey, unsigned char* plaintext);</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // DESCRIPTION 'EC Menezes-Vanstone cryptosystem functions openssl/Linux' // COMPILER 'gcc (GCC) 4.8.2' // FILE 'ecmv.c' // AUTHOR "Nick Korepanov" // Linux-3.10.104, glibc-2.17, OpenSSL 1.0.1u // ECC-192/224/256 // This program is free software; you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation; either version 2 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program; if not, write to the Free Software // Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. // // Author of this program can be contacted by electronic mail // korepanovnd@gmail.com // Copyright (c) 2017 Nick Korepanov. All rights reserved. // This product includes software developed by the OpenSSL Project // for use in the OpenSSL Toolkit. (http://www.openssl.org/) #include "ecmv.h" int EC_MV_pubkey_encrypt(unsigned char *cipher, EC_KEY* pubkey, unsigned char* plaintext, size_t len, int format) { const EC_GROUP *curve; // curve, q and g are part of pubkey, it was allocated and free with pubkey const EC_POINT *q; EC_POINT *y0, *z; BIGNUM *p, *a, *b, *ks, *o1, *z1, *z2, *y1, *y2, *x1, *x2, *ord; int bits, i=0, err; unsigned char buffer[250]; //size_t length; BN_CTX *ctx; curve=EC_KEY_get0_group(pubkey); if(curve) bits = EC_GROUP_get_degree(curve); else return 1; // no curve in key? if(len%2) return 2; // wrong plaintext has odd length if(len &gt; 2*bits/8) return 3; // plaintext too long for this key if( !(bits == 192 || bits == 224 || bits == 256) &amp;&amp; format) return 8; // binary format of encrypted block not defined for this key length //prepare bignums p=BN_new(); a=BN_new(); b=BN_new(); ks=BN_new(); o1=BN_new(); z1=BN_new(); z2=BN_new(); y1=BN_new(); y2=BN_new(); x1=BN_new(); x2=BN_new(); ord=BN_new(); ctx=BN_CTX_new(); //prepare points //q=EC_POINT_new(curve); g=EC_POINT_new(curve); y0=EC_POINT_new(curve); z=EC_POINT_new(curve); // split plaintext at two parts, and assign it to BIGNUMs BN_bin2bn(plaintext, len/2, x1); BN_bin2bn(plaintext+len/2, len/2, x2); // get public key q q=EC_KEY_get0_public_key(pubkey); // get generator point g //g=EC_GROUP_get0_generator(curve); // get order of g EC_GROUP_get_order(curve, ord, ctx ); // get prime p EC_GROUP_get_curve_GFp(curve, p, a, b, ctx ); BN_sub(o1, ord, BN_value_one()); // o1=ord-1 do { if( i&gt;= 10) break; // make secret session key ks &gt; 1 and ks &lt; (o-1) RAND_bytes(buffer, bits/8); BN_bin2bn(buffer, bits/8, ks); i++; } while( BN_cmp(BN_value_one(), ks) &gt;=0 || BN_cmp(o1,ks) &lt;=0 ); if(i&gt;=10) return 4; // ks is wrong, error in do-while // y0=ks*g err=EC_POINT_mul(curve, y0, ks, NULL, NULL, ctx ); if(err == 0) return 5; // error in EC_POINT_mul y0=ks*g // z=ks*q err=EC_POINT_mul(curve, z, NULL, q, ks, ctx ); if(err == 0) return 6; // error in EC_POINT_mul z=ks*q // get z1,z2 = Z(z1,z2) err=EC_POINT_get_affine_coordinates_GFp(curve, z, z1, z2, ctx ); if(err == 0) return 7; //error EC_POINT_get_affine_coordinates_GFp //y1 = z1*x1(modulo p) //y2 = z2*x2(modulo p) BN_mod_mul(y1, z1, x1, p, ctx); BN_mod_mul(y2, z2, x2, p, ctx); /* if bits=192, 24 bytes per every BIGNUM, point contains 2 Bignum + 1 byte header */ if(format) { // bin format if(bits == 192) { struct BinFmt192 *out; out=(struct BinFmt192 *)cipher; EC_POINT_point2oct(curve, y0, POINT_CONVERSION_UNCOMPRESSED, (unsigned char*)&amp;out-&gt;y0, sizeof(out-&gt;y0), ctx); BN_bn2bin(y1, (unsigned char*)&amp;out-&gt;y1); BN_bn2bin(y2, (unsigned char*)&amp;out-&gt;y2); out-&gt;z1=out-&gt;z2=out-&gt;z3=0; } if(bits == 224) { struct BinFmt224 *out; out=(struct BinFmt224 *)cipher; EC_POINT_point2oct(curve, y0, POINT_CONVERSION_UNCOMPRESSED, (unsigned char*)&amp;out-&gt;y0, sizeof(out-&gt;y0), ctx); BN_bn2bin(y1, (unsigned char*)&amp;out-&gt;y1); BN_bn2bin(y2, (unsigned char*)&amp;out-&gt;y2); out-&gt;z1=out-&gt;z2=out-&gt;z3=0; } if(bits == 256) { struct BinFmt256 *out; out=(struct BinFmt256 *)cipher; EC_POINT_point2oct(curve, y0, POINT_CONVERSION_UNCOMPRESSED, (unsigned char*)&amp;out-&gt;y0, sizeof(out-&gt;y0), ctx); BN_bn2bin(y1, (unsigned char*)&amp;out-&gt;y1); BN_bn2bin(y2, (unsigned char*)&amp;out-&gt;y2); out-&gt;z1=out-&gt;z2=out-&gt;z3=0; } } else { // hex format strcpy((char*)cipher, EC_POINT_point2hex(curve, y0, POINT_CONVERSION_UNCOMPRESSED, ctx)); strcat((char*)cipher, "\n"); strcat((char*)cipher, BN_bn2hex(y1)); strcat((char*)cipher, "\n"); strcat((char*)cipher, BN_bn2hex(y2)); strcat((char*)cipher, "\n"); } // free points //EC_POINT_free(q); EC_POINT_free(g); EC_POINT_free(y0); EC_POINT_clear_free(z); BN_CTX_free(ctx); BN_clear(ks); BN_clear(x1); BN_clear(x2); BN_clear(z1); BN_clear(z2); //free bignums BN_free(p); BN_free(a); BN_free(b); BN_free(ks); BN_free(o1); BN_free(z1); BN_free(z2); BN_free(y1); BN_free(y2); BN_free(x1); BN_free(x2); BN_free(ord); return 0; } int EC_MV_privkey_decrypt(unsigned char* cipher, EC_KEY *privkey, unsigned char* plaintext) { const EC_GROUP *curve; // curve, d are part of privkey, it was allocated and free with privkey const BIGNUM *d; EC_POINT *y0, *z; BIGNUM *p, *a, *b, *z1, *z2, *y1, *y2, *x1, *x2; int err, bits, format; unsigned char *ptr; BN_CTX *ctx; ctx=BN_CTX_new(); curve=EC_KEY_get0_group(privkey); if(!curve) return 1; // no curve in key? bits = EC_GROUP_get_degree(curve); if( cipher[0] == 0x04 ) format=FORMATBIN; if( cipher[0] == 0x30 ) format=FORMATHEX; if(cipher[0] != 0x04 &amp;&amp; cipher[0] != 0x30) return 8; // unknown format of ECMV encrypted block if( !(bits == 192 || bits == 224 || bits == 256) &amp;&amp; format) return 9; // binary format of encrypted block not defined for this key length if(format &amp;&amp; bits == 192 &amp;&amp; (cipher[48+1] || cipher[48+1+24+1] || cipher[48+1+24+1+24+1] )) return 10; //wrong format of binary encrypted block if(format &amp;&amp; bits == 224 &amp;&amp; (cipher[56+1] || cipher[56+1+28+1] || cipher[56+1+28+1+28+1] )) return 10; //wrong format of binary encrypted block if(format &amp;&amp; bits == 256 &amp;&amp; (cipher[64+1] || cipher[64+1+32+1] || cipher[64+1+32+1+32+1] )) return 10; //wrong format of binary encrypted block //prepare bignums p=BN_new(); a=BN_new(); b=BN_new(); z1=BN_new(); z2=BN_new(); y1=BN_new(); y2=BN_new(); x1=BN_new(); x2=BN_new(); //prepare points y0=EC_POINT_new(curve); z=EC_POINT_new(curve); // get private key d d=EC_KEY_get0_private_key(privkey); // get prime p EC_GROUP_get_curve_GFp(curve, p, a, b, ctx); if(format) { if(bits == 192) { struct BinFmt192 *in; in=(struct BinFmt192 *)cipher; EC_POINT_oct2point(curve, y0, (const unsigned char *)&amp;in-&gt;y0, sizeof(in-&gt;y0), ctx); BN_bin2bn((const unsigned char *)&amp;in-&gt;y1, sizeof(in-&gt;y1), y1); BN_bin2bn((const unsigned char *)&amp;in-&gt;y2, sizeof(in-&gt;y2), y2); } if(bits == 224) { struct BinFmt224 *in; in=(struct BinFmt224 *)cipher; EC_POINT_oct2point(curve, y0, (const unsigned char *)&amp;in-&gt;y0, sizeof(in-&gt;y0), ctx); BN_bin2bn((const unsigned char *)&amp;in-&gt;y1, sizeof(in-&gt;y1), y1); BN_bin2bn((const unsigned char *)&amp;in-&gt;y2, sizeof(in-&gt;y2), y2); } if(bits == 256) { struct BinFmt256 *in; in=(struct BinFmt256 *)cipher; EC_POINT_oct2point(curve, y0, (const unsigned char *)&amp;in-&gt;y0, sizeof(in-&gt;y0), ctx); BN_bin2bn((const unsigned char *)&amp;in-&gt;y1, sizeof(in-&gt;y1), y1); BN_bin2bn((const unsigned char *)&amp;in-&gt;y2, sizeof(in-&gt;y2), y2); } } else { // read y0 ptr=cipher; y0=EC_POINT_hex2point(curve, (const char *)ptr, y0, ctx); if(y0 == NULL) return 2; //invalid hex point representation //read y1,y2 ptr=strchr((const char *)ptr,'\n'); if(ptr == NULL) return 3; //wrong format of encrypted data ptr++; BN_hex2bn(&amp;y1, (const char *)ptr); ptr=strchr((const char *)ptr,'\n'); if(ptr == NULL) return 4; //wrong format of encrypted data ptr++; BN_hex2bn(&amp;y2, (const char *)ptr); } if( !EC_POINT_is_on_curve(curve, (const EC_POINT *)y0, ctx) ) return 11; // point is not on curve // z=d*y0=d*ks*g=ks*q err=EC_POINT_mul(curve, z, NULL, y0, d, ctx ); if(err == 0) return 6; // error in EC_POINT_mul z=ks*q // get z1,z2 = Z(z1,z2) err=EC_POINT_get_affine_coordinates_GFp(curve, z, z1, z2, ctx ); if(err == 0) return 7; //error EC_POINT_get_affine_coordinates_GFp // a=inv(z1)(mod p) BN_mod_inverse(a, z1, p, ctx); // b=inv(z2)(mod p) BN_mod_inverse(b, z2, p, ctx); //x1 = a*y1(modulo p) //x2 = b*y2(modulo p) BN_mod_mul(x1, a, y1, p, ctx); BN_mod_mul(x2, b, y2, p, ctx); // decode plaintext from two parts BN_bn2bin(x1, plaintext); BN_bn2bin(x2, plaintext+BN_num_bytes(x1)); // free points EC_POINT_free(y0); EC_POINT_clear_free(z); BN_CTX_free(ctx); BN_clear(x1); BN_clear(x2); BN_clear(z1); BN_clear(z2); BN_clear(a); BN_clear(b); //free bignums BN_free(p); BN_free(a); BN_free(b); BN_free(z1); BN_free(z2); BN_free(y1); BN_free(y2); BN_free(x1); BN_free(x2); return 0; }</span></span></code> </pre><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/332928/">https://habr.com/ru/post/332928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332916/index.html">We implement touch logger for Android using CVE-2016‚Äì5195</a></li>
<li><a href="../332918/index.html">Gremlins and ELF magic: what if the ELF file is a container?</a></li>
<li><a href="../332920/index.html">Deploy and demonize the ASP.NET Core Linux application as a background service.</a></li>
<li><a href="../332922/index.html">How isometric worlds are created</a></li>
<li><a href="../332924/index.html">Tcl / Tk. GUI development for command line utilities</a></li>
<li><a href="../332930/index.html">Solution of the promo task from BI.ZONE CTF</a></li>
<li><a href="../332934/index.html">Setting up object archiving in SAP ERP for beginners</a></li>
<li><a href="../332936/index.html">Method of non-iterative learning of a single-layer network of direct distribution with a linear activation function</a></li>
<li><a href="../332938/index.html">How to build a small but good network?</a></li>
<li><a href="../332940/index.html">Marketer Notes: How to install Ubuntu on RPI and connect to Azure IoT Hub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>