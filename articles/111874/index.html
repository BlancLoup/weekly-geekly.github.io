<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trie, or loaded tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habrahabr. Today I want to talk about such a wonderful data structure as a dictionary on a loaded tree , also known as a prefix tree , or trie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trie, or loaded tree</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habrahabr.  Today I want to talk about such a wonderful data structure as a <b>dictionary on a loaded tree</b> , also known as a <b>prefix tree</b> , or <b>trie</b> . <br><br><h4>  What is it ? </h4><br>  A loaded tree is a data structure that implements an interface of an associative array, that is, it allows you to store key-value pairs.  Immediately it should be said that in most cases the keys are strings, however, as keys, you can use any data types that can be represented as a sequence of bytes (that is, any). <br><a name="habracut"></a><br><h4>  How it works ? </h4><br>  A loaded tree differs from ordinary n-ary trees in that its nodes do not store keys.  Instead of them, single-character labels are stored in the nodes, and the key that corresponds to a certain node is the path from the root of the tree to this node, or rather the line composed of the labels of the nodes that met along this path.  In this case, the root of the tree, obviously, corresponds to the empty key. <br><br>  In the picture you can see an example of a loaded tree with the keys <i>c, cap, car, cdr, go, if, is, it</i> . <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/63/0b/630b77d00b2074d48ea56f01da2a24a2.png" alt="Typical loaded tree"></div><br>  And the same tree with the <i>car</i> key highlighted on it. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/37/c4/37c45cb6ffbb547002e7ef1802582647.png" alt="Typical loaded tree"></div><br>  It is immediately obvious that our tree contains ‚Äúextra‚Äù keys, because the only path to it from the root corresponds to any node of the tree, and therefore some key.  To avoid problems with ‚Äúredundant‚Äù keys, a boolean characteristic is added to each node of the tree, indicating whether the node is real or intermediate along the road to another one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Basic operations </h4><br>  Since a loaded tree implements an interface of an associative array, three basic operations can be distinguished in it, namely, insertion, deletion, and key search.  Like many trees, a loaded tree has the property of self-similarity, that is, any of its subtrees are also full-fledged loaded trees.  It is easy to see that all the keys in such a subtree have a common prefix, (whence the name ‚Äúprefix tree‚Äù came from), which means you can select a specific operation for this tree - getting all the keys of a tree with a given prefix during O (| Prefix |). <br><br><h5>  Key search </h5><br>  As already mentioned, the key corresponding to a node is the concatenation of labels of the nodes contained in the path from the root to the given node.  From this property, the key search algorithm naturally follows (as, incidentally, the add and remove algorithms). <br><br>  Let given the key Key, which must be found in the tree.  We will descend from the root of the tree to the lower levels, each time moving into a node whose label coincides with the next key symbol.  After all the key symbols are processed, the node in which the descent has stopped and will be the required node.  If during the descent there was no node with a label corresponding to the next key symbol, or the descent stopped at an intermediate vertex (a vertex that does not matter), then the required key is not in the tree. <br><br>  The time complexity of this algorithm is obviously O (| Key |). <br><br>  The algorithm is shown in more detail in the flowchart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/74/bd/74bd9cbdd705d24c21f4eeaa0aeeee20.png" alt="Key search algorithm"></div><br><br><h5>  Insert </h5><br>  The algorithm for adding a key to a tree is very similar to the search algorithm. <br><br>  Let a pair of Key and Value values ‚Äã‚Äãbe given to be added.  As in the key search algorithm, we will descend from the root of the tree to the lower levels, each time moving to a node whose label matches the next key symbol.  After all the key symbols have been processed, the node where the descent has stopped will be the node to which the Value value should be assigned (also, of course, the node should be marked as having a value).  If in the process of descent there is no node with a label corresponding to the next key symbol, then you should create a new intermediate node with the desired label and designate it as a child of the current one. <br><br>  The time complexity of adding a key is O (| Key |). <br><br>  Algorithm illustration on the flowchart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/f6/18/f6184a4fa1ed0829fd200a9a4071b49b.png" alt="Key insertion algorithm"></div><br><br><h5>  Deletion </h5><br>  Deleting a key is also very easy. <br><br>  Let given Key key, which must be removed from the tree.  Let's search for this key.  If the key exists in the dictionary, then knowing the node to which it corresponds, you can simply mark it as an intermediate one, making it ‚Äúinvisible‚Äù for subsequent searches. <br>  After that, you can go up from the ‚Äúdisabled‚Äù node to the root, simultaneously removing all nodes that are leaves, but saving memory is not significant in this case, and to effectively determine whether a node is a sheet, you need to enter an additional characteristic of the node. <br><br>  The temporal estimation of the deletion algorithm is already familiar O (| Key |). <br><br><h4>  Resource requirements </h4><br>  The loaded tree in terms of memory consumption / CPU time is not inferior to hash tables and balanced trees, and sometimes surpasses them in these parameters. <br><br><h5>  CPU time </h5><br>  The complexity of the operations of insertion, deletion and search - O (| Key |).  Although balanced trees perform these operations for O (ln (n)), but in this asymptotics there is a hidden time required for comparing keys, which, in general, is O (| Key |).  With hash tables, the situation is similar - although the access time is O (1 + a), but taking a hash (if it is not precomputed in advance, of course) takes O (| Key |). <br><br>  Graphs with a comparison of the performance of loaded trees, hash tables and red-black trees can be viewed in the <a href="http://en.wikipedia.org/wiki/Trie">English Wikipedia</a> . <br><br><h5>  Memory </h5><br>  In memory consumption, a loaded tree often wins over hash tables and balanced trees.  This is due to the fact that the set of keys in the loaded tree match the prefixes, and together with them the memory they use.  Also, unlike balanced trees, in a loaded tree there is no need to store a key in each node. <br><br><h4>  Optimization </h4><br>  There are 2 main types of optimization of a loaded tree: <br><ul><li>  <b>Compression</b> .  A compressed loaded tree is obtained from the usual removal of intermediate nodes, which lead to a single non-intermediate node.  For example, a chain of intermediate nodes labeled <i>a, b, c</i> is replaced with one node labeled <i>abc</i> . </li><li>  <b>Patricia</b> .  Patricia loaded tree is obtained from compressed (or ordinary) removal of intermediate nodes that have one child. </li></ul><br><h4>  Why is all this necessary? </h4><br>  Actually, the scope of loaded trees is enormous - they can be used everywhere where the implementation of an associative array interface is required.  Especially loaded trees are convenient for the implementation of dictionaries, spellcheckers and other T9 - that is, in tasks where you need to quickly receive sets of keys with a given prefix.  Also, the loaded tree uses in its work the well-known algorithm of <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE_%25E2%2580%2594_%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">Aho - Korasik</a> . <br><br>  That's all.  I hope the reader was interested to learn about this wonderful data structure, unfairly rarely mentioned in Habr√©. </div><p>Source: <a href="https://habr.com/ru/post/111874/">https://habr.com/ru/post/111874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111868/index.html">Android Application Development Standard</a></li>
<li><a href="../111869/index.html">Preparation of a package of documents for the transfer of domains in the zone .RU and .SU</a></li>
<li><a href="../111870/index.html">WebMatrix Hosting is back!</a></li>
<li><a href="../111871/index.html">Introducing Kohana 3.0 - Part 4</a></li>
<li><a href="../111873/index.html">Subdivision into subtasks: why it works, and why not</a></li>
<li><a href="../111875/index.html">Signed final SP1 for Windows 7 and Windows Server 2008 R2</a></li>
<li><a href="../111876/index.html">Experimental characterization of cache memory: workshop</a></li>
<li><a href="../111878/index.html">Negative of YOTA as a service for the client</a></li>
<li><a href="../111879/index.html">Tablets reduce sales of computers</a></li>
<li><a href="../111881/index.html">Links to RF domains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>