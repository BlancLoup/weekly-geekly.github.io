<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ten C ++ 11 features that every C ++ developer should use</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses a number of C ++ 11 features that all developers should know and use. There are many new additions to the language and the stan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ten C ++ 11 features that every C ++ developer should use</h1><div class="post__text post__text-html js-mediator-article">  This article discusses a number of C ++ 11 features that all developers should know and use.  There are many new additions to the language and the standard library, this article only superficially covers some of them.  However, I believe that some of these new features should be mundane for all C ++ developers.  There are <s>probably</s> a lot of similar articles, in this I will try to make a list of possibilities that should be included in everyday use. <br><br>  Today in the program: <br><ul><li><code>auto</code> </li> <li> <code>nullptr</code> </li> <li>  range-based loops </li><li>  <code>override</code> and <code>final</code> </li><li>  strictly typed <code>enum</code> </li><li>  smart pointers </li><li>  lambdas </li><li>  non-member <code>begin()</code> and <code>end()</code> </li><li>  <code>static_assert</code> and property classes </li><li>  move semantics </li></ul><a name="habracut"></a><br><h4>  # 1 - auto </h4><br>  Prior to C ++ 11, the <code>auto</code> keyword was used as a variable storage specifier (such as <code>register, static, extern</code> ).  In C ++ 11, <code>auto</code> allows you to not explicitly specify the type of a variable, telling the compiler to define the actual type of the variable itself, based on the type of the value being initialized.  This can be used to declare variables in different scopes, such as namespaces, blocks, loop initialization, and so on. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// i - int auto l = 42LL; // l - long long auto p = new foo(); // p - foo*</span></span></code> </pre><br>  Using <code>auto</code> allows you to reduce the code (unless, of course, the type is not <code>int</code> , which is one letter less).  Think about the STL iterators that you should always write to pass containers.  Thus, this makes obsolete the <code>typedef</code> definition just for the sake of simplicity. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = begin(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); it != end(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>); ++it) { <span class="hljs-comment"><span class="hljs-comment">// do smth } // ,  ++03  ++11 // C++03 for (std::vector&lt;std::map&lt;int, std::string&gt;&gt;::const_iterator it = container.begin(); it != container.end(); ++it) { // do smth } // C++11 for (auto it = container.begin(); it != container.end(); ++it) { // do smth }</span></span></code> </pre><br>  It is worth noting that the return value cannot be <code>auto</code> .  However, you can use <code>auto</code> instead of the return type of the function.  In this case, <code>auto</code> does not tell the compiler that it must determine the type, it only instructs it to look for the return type at the end of the function.  In the example below, the return type of the <code>compose</code> function is the return type of the + operator, which summarizes values ‚Äã‚Äãof type <code>T</code> and <code>E</code> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> E&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a, E b)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a+b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// decltype -        { return a+b; } auto c = compose(2, 3.14); // c - double</span></span></span></span></code> </pre><br><br><h4>  # 2 - nullptr </h4><br>  Previously, the NULL macro was used to reset the pointers, which is zero - an integer type, which naturally caused problems (for example, overloading functions).  The <code>nullptr</code> has its own <code>std::nullptr_t</code> , which saves us from past problems.  There are implicit conversions of <code>nullptr</code> to a null pointer of any type and to <code>bool</code> (as <code>false</code> ), but there is no conversion to integer types. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; p)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p2 = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p1 == p2) {} foo(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); bar(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> f = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// :    int   reinterpret_cast</span></span></code> </pre><br><h4>  # 3 - range-based loops </h4><br>  In C ++ 11, <code>foreach</code> paradigm support has been added to iterate over the set.  In the new form, it is possible to perform iterations if the <code>begin()</code> and <code>end()</code> methods are overloaded for the iteration object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is useful when you just want to get the elements of an array / container or do something with them, without worrying about indexes, iterators, or number of elements. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">"one"</span></span>] = v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;kvp: <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; kvp.first &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v: kvp.second) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;e: arr) e *= e;</code> </pre><br><h4>  # 4 - override and final </h4><br>  I have always disliked virtual functions in C ++.  The <code>virtual</code> optional and therefore made it a bit difficult to read the code, forcing it to always return to the top of the inheritance hierarchy to see if one method or another was declared virtual.  I have always used this keyword also in derived classes (and encouraged people who did it) to make the code more understandable.  However, there are errors that can still occur.  Take the following example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> B { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"D::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} };</code> </pre><br>  <code>D::f</code> overrides <code>B::f</code> .  However, they have different signatures, one method accepts <code>short</code> , the other one - <code>int</code> , therefore <code>B::f</code> is just another method with the same name, overloaded, not overdetermined.  Thus, working through a pointer to the base class, you can call <code>f()</code> and wait for the output of the ‚Äúoverridden‚Äù method: ‚ÄúD :: f‚Äù, but the output will be ‚ÄúB :: f‚Äù. <br><br>  Here is another possible error: the parameters are the same, but in the base class the method is constant, and in the derivative it is not. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> B { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"D::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} };</code> </pre><br>  Again, these are two overloaded functions, not redefined functions. <br>  Fortunately, now there is a way to get rid of these errors.  Two new identifiers have been added (not keywords): <code>override</code> to indicate that the method is a virtual method override in the base class and <code>final</code> indicating that the derived class should not override the virtual method.  The first example now looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> B { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"D::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} };</code> </pre><br>  Now this will cause a compilation error (in the same way, if you used <code>override</code> in the second example): <br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">'D::f'</span></span>: method with override specifier <span class="hljs-string"><span class="hljs-string">'override'</span></span> did not override any base class methods</code> </pre><br>  On the other hand, if you want to make a method that is not intended to be redefined (lower in the hierarchy), it should be noted as <code>final</code> .  You can use both identifiers in a derived class at once. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> B { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override final </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"D::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> D { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> override </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"F::f"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;} };</code> </pre><br>  A function declared as <code>final</code> cannot be overridden by the function <code>F::f()</code> - in this case, it overrides the base class method ( <code></code> ) for class <code>D</code> <br><br><h4>  # 5 - strictly typed enum </h4><br>  The "traditional" enumerations in C ++ have some drawbacks: they export their values ‚Äã‚Äãto the surrounding scope (which can lead to name conflicts), they are implicitly converted to an integer type and cannot have a user-defined type. <br><br>  These problems are fixed in C ++ 11 with the introduction of a new category of enums, called <i>strongly-typed enums</i> .  They are defined by the <code>enum class</code> keyword.  They no longer export their enumerated values ‚Äã‚Äãto the surrounding scope, are no longer implicitly converted to an integer type, and may have a user-defined type (this option is also added for "traditional" enumerations "). <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Options</span></span></span><span class="hljs-class"> {</span></span>None, One, All}; Options o = Options::All;</code> </pre><br><br><h4>  # 6 - smart pointers </h4><br>  There are many articles both on Habr√© and on other resources written on this topic, so I just want to mention smart pointers with reference counting and automatic memory freeing: <br><ol><li>  <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a> : should be used when the memory resource should not have been shared (it does not have a copy constructor), but it can be transferred to another <code>unique_ptr</code> </li><li>  <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">shared_ptr</a> : should be used when the memory resource is to be shared </li><li>  <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr">weak_ptr</a> : contains a link to an object that is managed by <code>shared_ptr</code> , but does not count links;  allows you to get rid of the cyclic dependence </li></ol><br>  The following example demonstrates <code>unique_ptr</code> .  To transfer ownership of an object to another <code>unique_ptr</code> , use std :: move (this function will be discussed in the last paragraph).  After the transfer of ownership, the smart pointer that transferred ownership becomes zero and <code>get()</code> returns <code>nullptr</code> . <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(p1); <span class="hljs-comment"><span class="hljs-comment">// transfer ownership if(p1) foo(p1.get()); (*p2)++; if(p2) foo(p2.get());</span></span></code> </pre><br>  The second example demonstrates <code>shared_ptr</code> .  The usage is similar, although the semantics are different, since ownership is now shared. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; p)</span></span></span><span class="hljs-function"> </span></span>{ ++(*p); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p2 = p1; bar(p1); foo(p2.get());</code> </pre><br>  The first ad is equivalent to the following: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p3 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">make_shared</a> is a function that has the advantage of allocating memory for a shared object and a smart pointer with a single allocation, as opposed to explicitly obtaining <code>shared_ptr</code> through a constructor, where at least two selections are required.  Because of this, a memory leak may occur.  The following example demonstrates this; a leak can occur if <code>seed()</code> throws an exception. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> init)</span></span></span><span class="hljs-function"> </span></span>{ *p = init; } foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>)), seed());</code> </pre><br>  This problem is solved using <code>make_shared</code> . <br>  And, finally, an example with <code>weak_ptr</code> .  Note that you must get <code>shared_ptr</code> for an object by calling <code>lock()</code> to access the object. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; wp = p; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sp = wp.lock(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *sp &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } p.reset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wp.expired()) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"expired"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><h4>  # 7 - lambda </h4><br>  The new standard has finally added support for lambda expressions.  You can use lambdas wherever a functor or <code>std::function</code> is expected.  Lambda, generally speaking, is a shorter functor notation, something like an anonymous functor.  More details can be read, for example, on <a href="http://msdn.microsoft.com/en-us/library/dd293603.aspx">MSDN</a> . <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(v), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(v), [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span>;}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(v), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(v), is_odd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pos != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(v)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *pos &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Now a little more tricky - recursive lambdas.  Imagine a lambda representing the Fibonacci function.  If you try to write it using <code>auto</code> , you will get a compilation error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fib = [&amp;fib](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>);};</code> </pre><br><pre> <code class="bash hljs">error C3533: <span class="hljs-string"><span class="hljs-string">'auto &amp;'</span></span>: a parameter cannot have a <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> that contains <span class="hljs-string"><span class="hljs-string">'auto'</span></span> error C3531: <span class="hljs-string"><span class="hljs-string">'fib'</span></span>: a symbol whose <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> contains <span class="hljs-string"><span class="hljs-string">'auto'</span></span> must have an initializer error C3536: <span class="hljs-string"><span class="hljs-string">'fib'</span></span>: cannot be used before it is initialized error C2064: term does not evaluate to a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> taking 1 arguments</code> </pre><br>  There is a cyclical relationship.  To get rid of it, you must explicitly define the type of the function using <code>std::function</code> . <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; lfib = [&amp;lfib](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : lfib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + lfib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>);};</code> </pre><br><h4>  # 8 - non-member begin () and end () </h4><br>  You probably noticed that in the examples earlier, I used the <code>begin()</code> and <code>end()</code> functions.  This is a new addition to the standard library.  They work with all STL containers and can be extended to work with any type. <br><br>  Let's take, for example, the previous example, where I derived a vector and then searched for the first odd element.  If <code>std::vector</code> replaced with a C-like array, the code will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(&amp;arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]+<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(arr)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]), [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span>;}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> begin = &amp;arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> end = &amp;arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]+<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(arr)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(begin, end, is_odd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pos != end) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *pos &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  With <code>begin()</code> and <code>end()</code> it can be rewritten as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(arr), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(arr), [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span>;}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(arr), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(arr), is_odd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pos != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(arr)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *pos &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  This is almost identical to the code with <code>std::vector</code> .  Thus, we can write one universal method for all types, which are supported by the <code>begin()</code> and <code>end()</code> functions. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Iterator&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterator begin, Iterator end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(begin, end, [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span>;}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(begin, end, is_odd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pos != end) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *pos &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C c)</span></span></span><span class="hljs-function"> </span></span>{ bar(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(c), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(c)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T(&amp;arr)[N])</span></span></span><span class="hljs-function"> </span></span>{ bar(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(arr), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(arr)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; foo(arr); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); foo(v);</code> </pre><br><h4>  # 9 - static_assert and property classes </h4><br>  <code>static_assert</code> verifies assertion at compile time.  If the statement is true, then nothing happens.  If - false, the compiler displays the specified error message. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Size &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Size is too small"</span></span>); T _points[Size]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; a1; Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; a2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="bash hljs">error C2338: Size is too small see reference to class template instantiation <span class="hljs-string"><span class="hljs-string">'Vector&lt;T,Size&gt;'</span></span> being compiled with [ T=double, Size=2 ]</code> </pre><br>  <code>static_assert</code> becomes more useful when used with property classes.  This is a collection of classes that provide type information at compile time.  They are available in the <code>&lt;type_traits&gt;</code> header.  There are several types of classes in this header: helper classes, transformation classes, and property classes themselves. <br>  In the following example, the <code>add</code> function is supposed to work only with integer types. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 t1, T2 t2)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t1 + t2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 + t2; }</code> </pre><br>  However, when compiling, there will be no error if you write the following: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; add(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  The program simply displays "4.14" and "e".  Using <code>static_assert</code> , these two lines will cause an error during compilation. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 t1, T2 t2)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t1 + t2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;T1&gt;::value, <span class="hljs-string"><span class="hljs-string">"Type T1 must be integral"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;T2&gt;::value, <span class="hljs-string"><span class="hljs-string">"Type T2 must be integral"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 + t2; }</code> </pre><br><pre> <code class="cpp hljs">error C2338: Type T2 must be integral see reference to function <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> instantiation <span class="hljs-string"><span class="hljs-string">'T2 add&lt;int,double&gt;(T1,T2)'</span></span> being compiled with [ T2=<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, T1=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ] error C2338: Type T1 must be integral see reference to function <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> instantiation <span class="hljs-string"><span class="hljs-string">'T1 add&lt;const char*,int&gt;(T1,T2)'</span></span> being compiled with [ T1=<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *, T2=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ]</code> </pre><br><h4>  # 10 - move semantics </h4><br>  This is another important topic covered in C ++ 11.  You can write several articles on this topic, not paragraphs, so I will not go deep. <br><br>  C ++ 11 introduced the concept of rvalue references (specified with &amp;&amp;) to distinguish between a reference to lvalue (an object that has a name) and rvalue (an object that does not have a name).  Moving semantics allows changing rvalues ‚Äã‚Äã(they were previously considered unchanged and did not differ from const T &amp; types). <br><br>  The class / structure used to have some implicit member functions: the default constructor (if no other constructor is defined), the copy constructor, and the destructor.  The copy constructor performs a one-by-one copy of the variables.  This means that if you have a class with pointers to some objects, the copy constructor will copy the pointers, not the objects to which they point.  If you want to get objects in a copy, and not just pointers to them, you must explicitly describe this in the copy constructor. <br><br>  The displacement constructor and the displacement assignment operator ‚Äî these two special functions take the T &amp;&amp; parameter, which is rvalue.  In fact, they can modify the object. <br><br>  The following example shows a dummy buffer implementation.  The buffer is identified by a name, has a pointer (wrapped in <code>std::unique_ptr</code> ) to an array of elements of type T and a variable containing the size of the array. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Buffer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _name; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T[]&gt; _buffer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// default constructor Buffer(): _size(16), _buffer(new T[16]) {} // constructor Buffer(const std::string&amp; name, size_t size): _name(name), _size(size), _buffer(new T[size]) {} // copy constructor Buffer(const Buffer&amp; copy): _name(copy._name), _size(copy._size), _buffer(new T[copy._size]) { T* source = copy._buffer.get(); T* dest = _buffer.get(); std::copy(source, source + copy._size, dest); } // copy assignment operator Buffer&amp; operator=(const Buffer&amp; copy) { if(this != &amp;copy) { _name = copy._name; if(_size != copy._size) { _buffer = nullptr; _size = copy._size; _buffer = (_size &gt; 0)? new T[_size] : nullptr; } T* source = copy._buffer.get(); T* dest = _buffer.get(); std::copy(source, source + copy._size, dest); } return *this; } // move constructor Buffer(Buffer&amp;&amp; temp): _name(std::move(temp._name)), _size(temp._size), _buffer(std::move(temp._buffer)) { temp._buffer = nullptr; temp._size = 0; } // move assignment operator Buffer&amp; operator=(Buffer&amp;&amp; temp) { assert(this != &amp;temp); // assert if this is not a temporary _buffer = nullptr; _size = temp._size; _buffer = std::move(temp._buffer); _name = std::move(temp._name); temp._buffer = nullptr; temp._size = 0; return *this; } }; template &lt;typename T&gt; Buffer&lt;T&gt; getBuffer(const std::string&amp; name) { Buffer&lt;T&gt; b(name, 128); return b; } int main() { Buffer&lt;int&gt; b1; Buffer&lt;int&gt; b2("buf2", 64); Buffer&lt;int&gt; b3 = b2; Buffer&lt;int&gt; b4 = getBuffer&lt;int&gt;("buf4"); b1 = getBuffer&lt;int&gt;("buf5"); return 0; }</span></span></code> </pre><br>  The default copy constructor and copy assignment operator should be familiar to you.  New in C ++ 11 is a move constructor and a move assignment operator. If you execute this code, you will see that when <code>b4</code> is created, the move constructor is called.  In addition, when <code>b1</code> assigned a value, the assignment operator is called.  The reason for this is the value returned by the <code>getBuffer()</code> function - rvalue. <br><br>  You probably noticed the use of <a href="http://en.cppreference.com/w/cpp/utility/move">std :: move</a> in the <a href="http://en.cppreference.com/w/cpp/utility/move">move</a> constructor, when initializing the variable name and the buffer pointer.  The name is a string <code>std::string</code> and <code>std::string</code> also implements move semantics.  The same goes for <code>unique_ptr</code> .  However, if we wrote just <code>_name(temp._name)</code> , the copy constructor would be called.  But why in this case the displacement constructor for <code>std::string</code> was not called?  The fact is that even if the displacement constructor for <code>Buffer</code> was called with an rvalue, inside the constructor it is still represented as an lvalue.  To make it rvalue again and need to use <code>std::move</code> .  This function simply turns the lvalue reference into an rvalue. <br><br><h4>  Instead of conclusion </h4><br>  There are many things in C ++ 11 that can and should be talked about;  This article was just one of many possible beginnings.  This article introduced a series of language functions and a standard library that every C ++ developer should know.  However, for a deeper understanding of all that has been said, this article is not enough; therefore, additional literature cannot be done here. </div><p>Source: <a href="https://habr.com/ru/post/182920/">https://habr.com/ru/post/182920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182900/index.html">Game Maiden, Work and Community Questions</a></li>
<li><a href="../182902/index.html">British scientists are dissatisfied with government policies regarding copyright</a></li>
<li><a href="../182904/index.html">Apple's WWDC 2013 news: iOS 7, OS X 10.9, iWork for iCloud, iTunes Radio, Haswell-based Macbook Air</a></li>
<li><a href="../182908/index.html">About human immortality</a></li>
<li><a href="../182912/index.html">Obtained photos of the crystal of the specialized bitcoin processor Avalon</a></li>
<li><a href="../182922/index.html">Lawsuit for $ 3 billion against the NSA, Obama, Verizon and the US Justice Department</a></li>
<li><a href="../182924/index.html">Several different VPN connections with local DNS servers</a></li>
<li><a href="../182928/index.html">Apple has provided the ability to transfer applications from one developer to another</a></li>
<li><a href="../182930/index.html">It is contagious: tightening the screws in the information space of Ukraine</a></li>
<li><a href="../182932/index.html">IOS 7 for iPhone Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>