<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software design, metaphors, prerequisites</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The trial topic is a cutting of the main paragraphs from the book from the first chapter. The volume is compressed 4 times, the sequence of presentati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software design, metaphors, prerequisites</h1><div class="post__text post__text-html js-mediator-article"><br>  The trial topic is a cutting of the main paragraphs from the book from the first chapter.  The volume is compressed 4 times, the sequence of presentation and the meaning, if possible, are preserved.  Feedback is very welcome. <br><br>  Why paragraphs from the book, and not in your own words?  Because in many cases it is very difficult to say better.  And then, it‚Äôs boring to read pure abstracts - it bothers you on the second page. <br>  If the topic is like it, I‚Äôm ready to try to describe the whole book in the articles, each time reducing the volume and increasing the density of information. <br><br><h1>  Software engineering </h1><br><h3>  What is software engineering? </h3><br>  Software development is a complex process that can include many components.  Here are the components of software development that scientists have identified over the past 25 years: <br>  - definition of the problem; <br>  - development of requirements; <br>  - creating a design plan; <br>  - software architecture development, or high-level design; <br>  - detailed design; <br>  - coding and debugging; <br>  - block testing; <br>  - integration testing; <br>  - integration; <br>  - system testing; <br>  - corrective maintenance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes construction is called "coding" or "programming." <br>  ‚ÄúCoding‚Äù seems to me not to be the best term in this case, since it <br>  implies a mechanical translation of the developed plan into programming language commands, whereas the design is not at all a mechanical process and is often associated with creativity and analysis.  The meaning of the words ‚Äúprogramming‚Äù and ‚Äúdesign‚Äù seems to me similar, and I will use them as equal rights. <br><a name="habracut"></a><br>  Here are some specific tasks related to the design: <br>  - verification of compliance with the conditions necessary for successful design; <br>  - determination of methods for subsequent testing of the code; <br>  - designing and writing classes and methods; <br>  - creation and naming of variables and named constants; <br>  - selection of control structures and organization of blocks of teams; <br>  - block testing, integration testing and debugging of own code; <br>  - mutual review of code and low-level program structures by members of the group; <br>  - ‚Äúpolishing‚Äù the code by carefully formatting and commenting it; <br>  - integration of software components created separately; <br>  - code optimization, aimed at improving its speed, and reducing <br>  extent of resource utilization. <br><br><h1>  Why software engineering is so important? </h1><br>  ‚Äú <em>Design is a big part of the software development process.‚Äù</em>  Depending on the size of the project, it usually takes 30-80% of the total time to design. <br><br>  - <em>Design is central to the software development process.</em>  Application requirements and its architecture are developed prior to the design stage to ensure its effectiveness.  Testing of the system (in the strict sense) is performed after construction and serves to verify its correctness. <br><br>  - Increased attention to design can greatly increase the productivity of individual programmers. <br><br>  - The result of the design - the source code - is often the only one correct and relevant description of the program. <br><br>  - <em>Construction is the only process that is performed.</em> <em><br></em>  <em>in all cases.</em> <br><br>  <strong>Ultimately, your software engineering competency determines</strong> <strong><br></strong>  <strong>how good are you programmer.</strong> <br><br><h1>  Metaphors for better understanding software development </h1><br>  Computer science terminology is one of the most colorful.  Really, <br>  in what other area are sterile rooms with carefully controlled temperature, filled with viruses, Trojan horses, worms, bugs and other living creatures and scum? <br><br><h3>  The importance of metaphors </h3><br>  Making analogies often leads to important discoveries.  Comparing not really <br>  understandable phenomenon with something similar, but more understandable, you can guess <br>  how to deal with the problem.  This use of metaphors is called modeling. ‚Äù <br>  The history of science is full of discoveries made by metaphors.  So, the chemist Kekule once in a dream saw a snake clutching itself by the tail.  Waking up, he realized that the properties of benzene would be explained by a molecular structure having a similar ring shape.  Further experiments confirmed his hypothesis (Barbour, 1966). <br><br>  In general, the effectiveness of models is explained by their brightness and conceptual <br>  integrity.  Models suggest properties, attitudes and perspectives to scientists <br>  research areas.  Sometimes models are misleading;  as a rule, this leads to an excessive generalization of metaphor.  The search for the ether is a good example of excessive generalization of the model. <br><br>  Sometimes people simplify the essence of metaphors.  For each of the examples described so and <br>  pulls answer: ‚ÄúOf course, the correct metaphor is more useful.  Another metaphor <br>  it was wrong! ‚ÄùThat's the way it is, but it‚Äôs too simplistic.  The history of science is not a series of transitions from ‚Äúwrong‚Äù metaphors to ‚Äútrue‚Äù.  This is a series <br>  transitions from "less good" metaphors to "best." <br><br>  Software development is a relatively young field of science.  She is not enough <br>  mature to have a set of standard metaphors.  Therefore, it includes mass <br>  secondary and contradictory metaphors.  Some of them are better than others - worse. <br>  Because how well you understand metaphors, your understanding also depends <br>  software development. <br><br><h3>  How to use metaphors? </h3><br>  The metaphor for software development looks more like a spotlight than a road map.  She does not say where to find the answer - she says how to find it.  Metaphor is more a heuristic approach than an algorithm. <br><br>  The differences between algorithm and heuristics are subtle, and in some ways these two concepts overlap.  The main difference between them, I will consider the degree of indirection of the decision.  The algorithm gives you the commands themselves.  Heuristics tell you how to find commands yourself or at least where to find them. <br><br>  Next, consider the popular metaphors that characterize software development. <br><br><h3>  Literary metaphor: writing code </h3><br>  The most primitive metaphor describing software development, originates in the expression "writing code."  According to the literary metaphor, the development of a program is similar to writing a letter: you sit down at the table, take paper, pen, and write a letter from beginning to end.  This does not require any formal planning, and the thoughts expressed in the letter are formulated by the author along the way. <br><br>  Such an approach can be practical if you write a banal letter to your aunt.  However, the extension of the metaphor of "writing" software up to the ejection of the first <br>  a copy of the program is not the best advice in the world of software development, where a large system is already on a par with the 10-story office building or ocean liner. <br><br><h3>  Agricultural metaphor: growing system </h3><br>  Some developers state that software development should be considered <br>  analogies with growing crops.  You design a separate block, encode it, test it and add it to the system, slightly expanding with <br>  each time its functionality.  Such a division of the task into many small actions allows minimizing the problems that can be encountered at each stage. <br><br>  The weakness of this metaphor lies in the assumption that you do not have a direct <br>  control over the development of software.  You simply sow the seeds of the code in the spring and, if so <br>  It will be the will of the Great Pumpkin, in the fall will receive an unprecedented harvest code. <br><br><h3>  Pearl Metaphor: slow increment system </h3><br><br>  Sometimes, speaking of growing software, they actually mean increment, or <br>  accretion (accretion).  These two metaphors are closely related, but the second is more convincing.  The increment characterizes the process of pearl formation due to the deposition of small amounts of calcium carbonate.  In geology and jurisprudence, accretion is understood as an increase in the land area through the deposition of rocks contained in water. <br><br>  This does not mean that you should master the creation of code from sedimentary rocks;  This means that you must learn to add to software systems by a small fragment at a time.  In other words, who therefore come to <br>  mind, are the terms "incremental", "iterative", "adaptive" and "evolutionary."  Incremental design, engineering and testing are among the most effective software development concepts. <br><br>  The advantage of an incremental metaphor is that it does not make excessive promises.  Moreover, it is not as easily amenable to undue expansion as an agricultural metaphor.  A shell forming a pearl is a good way to render incremental development, or accretion. <br><br><h3>  Construction metaphor: building software </h3><br>  The metaphor of ‚Äúbuilding‚Äù software is more useful than the metaphors of ‚Äúwriting‚Äù or ‚Äúgrowing‚Äù software, because it is consistent with the idea of ‚Äã‚Äãsoftware accretion and provides more detailed guidance.  Building software implies the presence of planning, preparation and execution stages, the type and severity of which depend on the specific project.  In studying this metaphor, you will find other parallels. <br><br>  To build a meter tower requires a solid hand, a flat surface and <br>  10 beer cans, for a tower 100 times higher is not enough to have <br>  100 times more beer cans.  Such a project requires a completely different planning and design. <br><br><h3>  Combining Metaphors </h3><br><br>  Metaphors have a heuristic, not an algorithmic nature, therefore <br>  they are not mutually exclusive.  You can use both the accretion metaphor and the construction metaphor.  If you want, you can think of software development as writing a letter, combining this metaphor with driving a car, hunting werewolves, or a dinosaur image stuck in a resin pool.  Use any metaphors or combinations of them that stimulate your thinking or help you communicate with other members of the group. <br><br>  Using metaphors is a delicate matter.  To metaphor led you to valuable <br>  heuristic guesses, you should expand it.  But if it is expanded too much or in the wrong direction, it can be misleading.  Like any <br>  powerful tools, metaphors can be used in the wrong way, however <br>  thanks to their power, they can become a valuable component of your intellectual toolkit. <br><br>  <strong>Important points:</strong> <br>  - Comparison of software design with the construction of the building indicates the need for thorough preparation for the project and clarifies the distinction between large and small projects. <br>  - The analogy between software development methods and tools in a programmer‚Äôs intelligent toolkit suggests that <br>  Programmers have many different tools and that no tool is universal.  Choosing the right tool is one of the conditions for effective programming. <br>  - Metaphors do not exclude each other.  Use a combination of metaphors, <br>  most effective in your case. <br><br><h1>  Measure seven times, cut once: prerequisites </h1><br><br>  Before construction begins, builders look at the drawings, check whether all permits have been obtained, and examine the foundation.  For the construction of a skyscraper, a dwelling house and a dog kennel, the builders would prepare differently, but whatever the project, before the start of the design they would conduct a fair preparation taking into account all the features of the project. <br><br>  In this chapter, we will look at the components of software design preparation.  how <br>  and in construction, the ultimate success of a software project is largely determined before construction begins.  If the foundation is unreliable or planning is done carelessly, at best you can <br>  only minimize harm <br><br><h3>  Importance of prerequisites </h3><br>  A common feature of all programmers who create high-quality software is the use of high-quality methods that emphasize software quality in <br>  beginning, middle and end of the project. <br><br>  Design is the middle stage of work, so by the time construction began, the success of the project was already partially predetermined.  And yet during construction, you should at least be able to determine how well your situation is, and go back if black clouds of failure appear on the horizon. <br><br><h3>  The most compelling argument in favor of fulfilling preconditions before construction begins. </h3><br>  Let's say you have already climbed the mountain to identify the problem, walked a mile along the way <br>  requirements, dropped dirty clothes at the fountain of architecture and <br>  bathed in clear waters of preparedness.  Consequently, you know that before <br>  the implementation of the system you need to understand what and how it will do. <br><br>  Creating a software system is like any other project that requires <br>  human and financial resources.  Building a house does not start with clogging <br>  nails, and with the creation, analysis and approval of drawings.  When developing software, having a technical plan means nothing less. <br><br>  Preparation for the project is one of the main conditions for effective programming, and this is logical.  The amount of planning depends on the scale of the project.  From a managerial point of view, planning involves determining the timing, number of people and computers needed to complete the work.  From the technical - planning implies getting an idea about the system being created, which allows not to spend money on creating the wrong system.  Sometimes users do not clearly know what they want to receive, and it may take more effort than they would like to determine their requirements.  Anyway, it‚Äôs cheaper than to create something that‚Äôs not necessary, to deliver the result and start all over again.  Before starting to create a system, it is equally important to think about how you are going to create it.  No one wants to spend time and money on fruitless wanderings through the maze. <br><br>  Scientists from companies Hewlett-Packard, IBM, Hughes Aircraft, TRW and others <br>  organizations found that fixing an error at the beginning of construction costs 10-100 times less than eliminating it at the end of the project, during testing of the application or after its release (Fagan, 1976; Humphrey, Snyder, and Willis, 1991; Leffingwell 1997 ; Willis et al., 1998; Grady, 1999; Shull et al., 2002; Boehm and Turner, 2004). <br><br><h3>  Determine the type of software you are working on </h3><br>  What are you developing? <br>  - Embedded systems on which people's lives depend <br>  - Business Systems <br>  - Target systems <br><br>  When developing business systems, it is preferable to use high-iterative approaches in which the planning, development of requirements and design architecture are interspersed with the design, testing of the system and quality assurance.  Systems on which people's lives depend require more consistent approaches, since stability of requirements is one of the conditions for the highest system reliability. <br><br><h3>  The impact of iterative approaches on preconditions </h3><br>  Some people argue that when using iterative methods, there is no need to bother with preliminary conditions, but this point of view is incorrect.  Iterative approaches weaken the consequences of inadequate training, but not <br>  eliminate them. <br><br>  Iterative project with a reduced program of preliminary <br>  conditions or without it differs from a similar sequential project by two <br>  aspects.  First, with an iterative approach, the cost of fixing defects is usually lower, because defects are detected earlier. <br><br>  Secondly, with iterative approaches, costs are distributed throughout the project, <br>  rather than grouped at its end.  In the end, with both iterative and sequential approaches, the total cost will be similar, but in the first case <br>  it will not seem so big because it will be paid in parts. <br><br>  One popular rule of thumb is to determine about 80% of the requirements in advance, allow time for defining additional requirements later and perform systematic change control as you work, accepting only the most important requirements.  Another option is possible: you can define in advance 20% of only the most important requirements and develop the rest of the software in small fragments, defining additional requirements and refining them - modifying the application draft as you progress. <br><br>  You can choose a more consistent approach (where issues are resolved in advance) if: <br>  - requirements are fairly stable; <br>  - the project of the application is simple and relatively clear; <br>  - the development team is familiar with the application area; <br>  - the project is not associated with a special risk; <br>  - long-term predictability of the project is important; <br>  - the cost of changing the requirements, the project application and the code is likely <br>  prove to be high. <br><br>  A more iterative approach (in which questions are solved as work progresses) can be preferred if: <br>  - the requirements are relatively incomprehensible or it seems to you that they may be unstable for other reasons; <br>  - the project of the application is complicated, not entirely clear, or both; <br>  - the development team is unfamiliar with the application area; <br>  - the project is associated with high risk; <br>  - the long-term predictability of the project does not play a special role; <br>  - the cost of changing the requirements, the project application and the code is likely <br>  will be low. <br><br>  Be that as it may, iterative approaches are more effective than consistent ones.  You can adapt the prerequisites to your specific project as you see fit, making them more or less formal or complete. <br><br><h3>  Problem Prerequisites </h3><br><br>  The first precondition that needs to be fulfilled before construction is a clear statement of the problem that the system must solve. <br><br>  The definition of a problem is simply a statement of the essence of the problem without any <br>  or hints of its possible solutions.  It may take a couple of pages, but <br>  must necessarily sound like a problem.  The phrase ‚Äúour Gigatron system cannot handle order processing‚Äù sounds like a problem and is a good definition.  However, the phrase ‚Äúwe need to optimize the automated data entry module for the Gigatron system to handle order processing‚Äù - <br>  poor definition of the problem.  It does not seem to be a problem, but a solution. <br>  The definition of the problem precedes the elaboration of detailed requirements, which <br>  is a deeper investigation of the problem. <br><br>  The problem should be formulated in a language understandable to the user, and the problem itself should be described from a user point of view.  Usually a problem <br>  should not be formulated in computer terms, because the optimal <br>  her decision may not be a computer program.  Let's say you need to calculate the annual profit.  Calculating quarterly earnings you already <br>  computerized.  If you get stuck on programming, decide that <br>  in the existing application you just need to add the function to calculate the annual <br>  profits with all the ensuing consequences: labor costs <br>  developers, etc. If you think a little, then just raise a little <br>  salary to a secretary who will, once a year, sum up four numbers on <br>  calculator. <br><br>  Exceptions to this rule are valid if the problem is related to computers: programs compile too slowly, or programming tools are full of errors.  In such cases, the problem can be formulated in computer terms that are familiar to programmers. <br><br>  Without having a good definition of a problem, you can spend efforts on solving the wrong problem. <br><br><h3>  Requirements Prerequisites <br></h3><br><br>  The importance of an explicit set of requirements is due to several reasons: <br>  - <em>Explicit requirements help to ensure that the functionality of the system is determined by the user, not the programmer.</em>  If requirements are formulated <br>  obviously, the user can analyze and approve them. <br><br>  - Having explicit requirements helps to avoid disputes. <br><br>  - <em>Attention to requirements helps to minimize system changes after starting development.</em>  Finding an error in the code when encoding, you change a few lines and the work will continue.  If during coding you find an error in the requirements, you will have to change the design of the program to match the changed requirements. <br><br><h3>  Software Stability Myth </h3><br><br>  Perhaps you think the Pontiac Aztec is the most magnificent car <br>  ever created, are members of the Society of Believers in the Flat Earth <br>  and every four years you make a pilgrimage to Roswell, New Mexico, on <br>  aliens landing site.  If so, you can continue to believe that <br>  Requirements in your projects will not change.  If you have already ceased to believe <br>  in Santa Claus or at least stopped admit it, you can have something <br>  undertake to reduce dependency on changes in minimum requirements. <br><br><h3>  What to do when requirements change during program design? </h3><br><br>  Assess the quality of the requirements using the checklist <br>  given at the end of the section.  If the requirements are not good enough, stop working, go back and correct them. <br><br>  - <em>Make sure everyone knows the price of changing requirements</em> .  Thinking about new <br>  features, customers are excited.  Their blood liquefies, overwhelms the medulla, and they euphoric, forgetting about all meetings devoted to the discussion of requirements, about the signing ceremony and all documents.  To calm down such drugged people with new functions is easiest, saying: ‚ÄúWow, this is a really great idea!  But it‚Äôs not in the requirements document, so I have to revise the work schedule and budget so that you can decide whether you want to implement it right now or later. ‚Äù  The words "schedule" and "estimate" sober much better than coffee and cold shower, and many requirements quickly turn into wishes. <br><br>  - Set the change control procedure <br><br>  - Use development approaches that adapt to change. <br><br>  - Leave the project if the requirements are especially unsuccessful. <br><br>  - <em>Remember the business model of the project</em> <br><br><h1>  Checklist: Requirements </h1><br>  The following checklist contains questions to determine the quality of the requirements.  Neither the book nor this list will teach you to correctly develop requirements.  Use it during construction to determine how solid the land you are standing on is. <br><br>  Not all questions will be relevant for your project.  If you are working on <br>  informal project, on some issues do not even need to think.  Other questions are important, but do not require formal answers.  However, if you are working on a large formal project, you should probably answer each question. <br><br><h3>  Specific functional requirements </h3><br>  - Have all methods of data entry into the system been determined, indicating the source, accuracy, range of values ‚Äã‚Äãand frequency of input? <br>  - Are all methods of data output defined by the system, indicating the purpose, accuracy, range of values, frequency and format? <br>  - Are all output formats defined for Web pages, reports, etc.? <br>  - Are all external hardware and software interfaces defined? <br>  - Are all external communication interfaces defined with connection protocols, error checking and communication? <br>  - Are all the tasks that the user needs to be done? <br>  - Are the data used in each task and the data resulting from each task determined? <br><br><h3>  Specific non-functional requirements (quality requirements) </h3><br>  - Is the user expected response time for all necessary operations? <br>  - Are other time parameters defined, such as data processing time, their transfer rate and system capacity? <br>  - Is the level of system security determined? <br>  - Has the reliability of the system been determined, including such aspects as consequences of failures in its operation, information that should be protected from failures, and an error detection and correction strategy? <br>  - Are the minimum requirements of the program for the amount of memory and <br>  free disk space? <br>  - Are the aspects of system maintenance convenience defined, including the ability of the system to adapt to changes in specific functions, operating systems and interfaces with other applications? <br>  - Is the definition of success included in the requirements?  Or failure? <br><br><h3>  Quality requirements </h3><br>  - Are the requirements written in a language understandable to users?  Do users agree with this? <br>  - Are there any conflicts between the requirements? <br>  - Has an acceptable balance been established between antagonist parameters, such as resistance to abnormality of initial prerequisites and correctness? <br>  - Are there any design elements in the requirements? <br>  - Is the level of detail requirements agreed?  Should there be any requirement to define in more detail?  Less detail? <br>  - Are the requirements sufficiently clear and understandable so that they can be transferred to an independent design team?  Do developers agree with that? <br>  - Is every requirement relevant to the problem and its solution?  Is it possible to trace every requirement to its source in the problem environment? <br>  - Is it possible to test every requirement?  Will it be possible to conduct independent testing, which will tell whether all requirements are met? <br>  - Are all possible changes in requirements and probability of each change determined? <br><br><h3>  Completeness of requirements </h3><br>  - Are the missing requirements indicated that cannot be determined before the start of development? <br>  - Are the requirements complete in the sense that if the application meets all the requirements, it will be acceptable? <br>  - Do you have any requirements for discomfort?  Have you excluded requirements that are not amenable to implementation and were included only to calm the client or the boss? <br><br>  Steve mcconnell </div><p>Source: <a href="https://habr.com/ru/post/23736/">https://habr.com/ru/post/23736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237349/index.html">By cities and villages or as we balance between CDN nodes</a></li>
<li><a href="../23735/index.html">Foreword</a></li>
<li><a href="../237351/index.html">Night hackathon Games Coding Night at Igromir</a></li>
<li><a href="../237353/index.html">OpenSSL to encrypt QNAP NAS connection SSL WebDav</a></li>
<li><a href="../237359/index.html">Wolfram Research has launched the Tweet-a-Program service: interesting programs in Wolfram Language, the length of which does not exceed 140 characters</a></li>
<li><a href="../237361/index.html">How we did the QIWI Universe accelerator</a></li>
<li><a href="../237363/index.html">Local Internet?</a></li>
<li><a href="../237365/index.html">How to receive information if the Russian segment of the Internet is cut off from the global</a></li>
<li><a href="../237367/index.html">Using NSURLProtocol in Swift</a></li>
<li><a href="../23737/index.html">Scooter or car? Or maybe great?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>