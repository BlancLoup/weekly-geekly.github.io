<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The difficulty of administering guest hotspots. Practice (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, I talked about how to track the status of isc-dhcpd, now about the practical methods of applying this scheme. 

 When working...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The difficulty of administering guest hotspots. Practice (part 2)</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/sysadm/134134/">previous article,</a> I talked about how to track the status of isc-dhcpd, now about the practical methods of applying this scheme. <br><br>  When working in highly loaded guest Wi-Fi networks, there is the problem of tracking and adding clients that have expanded access to external services.  The best option is to control access by MAC addresses (entering a bunch of addresses in dhcpd.conf), but as practice shows, it is rather inconvenient because  You really cannot control the state of the hosts that are already configured and their work. <br><a name="habracut"></a><br>  Also, due to the large number of random devices, it becomes necessary to reduce the time of the lease or expand the range of ip addresses issued, which in turn slows down the search for the desired host.  Control over MAC addresses and issuing static addresses can lead to certain problems.  Let's say in your company there are 2 Wi-Fi subnets, which are two virtual networks (VLANs) distributed from multiside access points.  In this case, one Wi-Fi network is open, and the second is password protected. <br>  For the client to work correctly, you need to add the device‚Äôs mac address to 2 pools simultaneously.  This leads to confusing configs and problems with administration. <br><br><h5>  Further description requires from the reader at least a basic understanding of the work of pf, squid, isc-dhcpd and web servers. </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Which exit ? </h4><br>  The output is a little not obvious, but rather simple.  Why dhcpd itself does not control user access to the network? <br>  So, we have isc-dhcpd, we have a list of clients who need to open access to services on the firewall when they appear and disable access when they disappear. <br>  We need a database of MAC addresses of our clients, a convenient web snout for their prompt addition, a firewall that can be managed remotely without manual editing of the config and a little patience. <br><br>  To begin, we must prepare our system. <br>  I am a FreeBSD supporter and therefore I am doing all the major projects on it, because  Many system components have convenient control.  As a firewall, we will use a bunch of <a href="http://openbsd.com/faq/pf/index.html">pf</a> and <a href="http://wolfermann.org/pftabled.html">pftabled</a> .  The pf firewall compares favorably with others in that it has dynamic tables that can be changed without touching the basic rules.  pftabled is a daemon that can monitor the state of these tables using a specially crafted package. <br><br><h5>  Approximate config pf.conf </h5><br><pre><code class="hljs vbscript">int_if=<span class="hljs-string"><span class="hljs-string">"em0"</span></span> ext_if=<span class="hljs-string"><span class="hljs-string">"em1"</span></span> table &lt;androids&gt; table &lt;private_nets&gt; persist { <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> } # nat      ! nat <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $ext_if from { &lt;private_nets&gt; } <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> { !&lt;private_nets&gt; } -&gt; ($ext_if) #     .        &lt;androids&gt;    squid  transparent . no rdr <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if from &lt;androids&gt; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any #       apache      wpad.dat rdr <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if from ($int_if:network) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> { any, !($int_if) } port { <span class="hljs-number"><span class="hljs-number">80</span></span>,<span class="hljs-number"><span class="hljs-number">8080</span></span> } -&gt; <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> port <span class="hljs-number"><span class="hljs-number">3129</span></span> # Allow DHCP pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto udp from any port bootpc <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any port bootps pass out <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto udp from any port bootps <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any port bootpc # Allow DNS pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto udp from ($int_if:network) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ($int_if) port domain keep state pass out <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto udp from ($int_if) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ($int_if:network) port domain # Allow Proxy access pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto tcp from ($int_if:network) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ($int_if) port <span class="hljs-number"><span class="hljs-number">3128</span></span> flags S/SA keep state pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto tcp from ($int_if:network) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> port <span class="hljs-number"><span class="hljs-number">3129</span></span> flags S/SA keep state # Allow access <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> local HTTP <span class="hljs-built_in"><span class="hljs-built_in">Server</span></span> pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $int_if proto tcp from ($int_if:network) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ($int_if) port <span class="hljs-number"><span class="hljs-number">80</span></span> flags S/SA keep state # Allow access from &lt;androids&gt; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any services pass <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> from &lt;androids&gt; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any keep state pass out <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $ext_if from ($ext_if) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any keep state pass out <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> $ext_if proto icmp from any <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> any keep state</code> </pre> <br><br><h5>  What gives us the described config? </h5><br><ul><li>  Any requests sent from the guest network to any host on port 80.8080 will be redirected to the proxy server to port 3129 </li><li>  Any requests from hosts included in the androids table will be forwarded to the external network directly </li><li>  Allow requests to dns, dhcpd, local web server and proxy </li></ul><br>  Why do we only allow port 80.8080?  Because by opening other ports, we lose control over the use of our network. <br>  For the correct operation of the scheme, you must configure the local wpad service.  To configure it, you need to create an IN A record in the dns server and specify the address of your web server as the IP address.  Below is an example config file wpad.dat which should be in the root of your web server. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindProxyForURL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, host</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isPlainHostName(host) || dnsDomainIs(host, <span class="hljs-string"><span class="hljs-string">".conf.local"</span></span>) || localHostOrDomainIs(host, <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>) ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DIRECT"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( isInNet(host, <span class="hljs-string"><span class="hljs-string">"172.16.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"255.255.0.0"</span></span>) || isInNet(host, <span class="hljs-string"><span class="hljs-string">"192.168.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"255.255.0.0"</span></span>) || isInNet(host, <span class="hljs-string"><span class="hljs-string">"10.0.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"255.0.0.0"</span></span>) || isInNet(host, <span class="hljs-string"><span class="hljs-string">"127.0.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"255.255.255.0"</span></span>) ){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DIRECT"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( isInNet(myIpAddress(), <span class="hljs-string"><span class="hljs-string">"192.168.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"255.255.0.0"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"PROXY 192.168.0.1:3128"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DIRECT"</span></span>; }</code> </pre><br>  File content reads as follows: <br><ul><li>  If the request contains the host name without the suffix dns, or the domain of the requested host contains ".conf.local", or the host resolves to 127.0.0.1, then send the requests directly to the requested host. </li><li>  If the requested host resolves to the addresses of the local subnet, then send the request directly </li><li>  Everything else is sent to the proxy server </li></ul><br>  How to configure squid in transparent mode is better to read <a href="http://wiki.squid-cache.org/SquidFaq/InterceptionProxy">here</a> . <br><br>  Well, with the preparatory work done.  Then you can check the operation of the system kernel. <br>  If dhcpd correctly delivered the settings to the user's host, then with the settings ‚Äúauto-detect proxy server settings‚Äù enabled, the browser will request the wpad.dat file and all its requests will be sent through the proxy server.  If you add a host to the androids table, then all traffic will go past the proxy server. <br><br><h4>  We form a database for work </h4><br>  The easiest and fastest data processing option is to store the current settings of the issued addresses in an accessible place with high-speed access.  For me, this place is memcached.  You can use databases, file storages, in general everything your heart desires.  For the local database, I‚Äôm using the standard address bar I use DB_File. <br><br>  As described in the first post, you need to connect an event handler to dhcpd to create a database of issued addresses.  Below is the text of my handler. <br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use strict; use warnings; use DB_File; use IO::Socket; use Digest::HMAC_SHA1 qw(hmac_sha1); use Cache::Memcached::Fast; use Sys::Syslog; use vars qw/ $keyfile $key $lease_base $pftabled %macs/; use constant PFTBLPORT =&gt; 56789; use constant pfip =&gt; "127.0.0.1"; use constant PFTBLVERSION =&gt; 2; use constant PFTABLED_CMD_ADD =&gt; 1; use constant PFTABLED_CMD_DEL =&gt; 2; use constant PFTABLED_CMD_FLUSH =&gt; 3; use constant PFTBLCOMMAND =&gt; 1; use constant PFTBLMASK =&gt; 32; use constant SHA1_DIGEST_LENGTH =&gt; 20; use constant PFTBLNAME =&gt; "androids"; my $command = shift; my $ip = shift; my $mac = shift; my $pid = fork(); if($pid == 0) { $pftabled = IO::Socket::INET-&gt;new(Proto =&gt; 'udp', PeerPort =&gt; PFTBLPORT, PeerAddr =&gt; pfip) or die "Creating socket: $!\n"; openlog("publish-ip-mac","ndelay"); &amp;load_key; &amp;open_memcached; if($command eq 'commit') { &amp;commit_address; } elsif($command eq 'release') { &amp;release_address; } elsif($command eq 'expiry') { &amp;release_address; } elsif($command eq 'hostname') { &amp;commit_hostname; } else { syslog("info|local6","Unknown operation $command for $ip and $mac"); #print STDERR "Unknown operation $command for $ip and $mac\n"; } closelog; } exit(0); sub commit_address { $mac = join(":",map { sprintf("%02s",$_); } split(":",$mac)); #print STDERR "Host ".$ip." with MAC ".$mac." is alive\n"; syslog("info|local6","Host ".$ip." with MAC ".$mac." is alive"); $lease_base-&gt;set('ip/'.$mac,$ip,19200); $lease_base-&gt;set('mac/'.$ip,$mac,19200); $lease_base-&gt;set('lease_start/'.$ip,time(),19200); $lease_base-&gt;set('lease_end/'.$ip,time()+19200,19200); tie %macs, 'DB_File', '/var/db/macs.db', O_RDONLY, 0666, $DB_HASH or die "Cannot open file '/var/db/macs.db': $!\n"; syslog("info|local6","Mac: $mac Table Mac: $macs{$mac}"); if(exists $macs{$mac}) { syslog("info|local6","IP $ip put to pftable"); &amp;pftabled_operations(PFTABLED_CMD_ADD,$ip); } untie %macs; } sub commit_hostname { $lease_base-&gt;set('name/'.$ip,$mac,19200); } sub release_address { if($mac = $lease_base-&gt;get('mac/'.$ip)) { syslog("info|local6","Host ".$ip." with MAC ".$mac." released or expired"); # print STDERR "Host ".$ip." with MAC ".$mac." released or expired\n"; $lease_base-&gt;delete('ip/'.$mac); $lease_base-&gt;delete('mac/'.$ip); $lease_base-&gt;delete('name/'.$ip); $lease_base-&gt;delete('lease_start/'.$ip); $lease_base-&gt;delete('lease_end/'.$ip); } else { # print STDERR "Host ".$ip." without MAC info released or expired\n"; syslog("info|local6","Host ".$ip." without MAC info released or expired"); } &amp;pftabled_operations(PFTABLED_CMD_DEL,$ip); } sub check_access_table { } sub pftabled_operations { my $command = shift; my $iparray = shift; #print @iparray; foreach my $addip (split("\0",$iparray)) { my $addr = inet_aton($addip); my $time = time(); my $block = pack("C1 S1 C1",PFTBLVERSION,$command,PFTBLMASK).$addr.pack("a32 N*",PFTBLNAME,$time); my $digest = hmac_sha1($block, $key); $block .= $digest; $pftabled-&gt;send($block); } } sub load_key { my $keyfile = "/usr/local/etc/pftabled.key"; if (! -r $keyfile) { print STDERR "Cannot Read KeyFile $keyfile\n"; exit 1; } open(KEY, "&lt;$keyfile"); sysread KEY, $key, SHA1_DIGEST_LENGTH; close KEY; } sub open_memcached { $lease_base = new Cache::Memcached::Fast({ servers =&gt; [ { address =&gt; 'localhost:11211', noreply =&gt; 1 } ], }); }</span></span></code> </pre><br><br>  In the /usr/local/etc/pftabled.key file there should be a key that uses pftabled. <br>  The /var/db/macs.db file should contain the mac base of addresses in the form of DB_File HASH. <br>  When the commit command appears from dhcpd - the received mac address is checked against the base of addresses and if it is there, a packet is added to pftabled that adds the corresponding ike ip address to the androids table.  When a release or expire command appears, the ip address from the androids table is automatically deleted. <br><br>  The lifetime of the data in memcached and pftabled is set to 19,200 seconds (about 5 hours), the same time is set in the dhcpd.conf config in the parameter maximum-lease-time.  This is done so that the hosts in memcached and pf are not lost. <br><br>  pftabled should be run with the following parameters: <br>  <b>pftabled_flags = "- d -a 127.0.0.1 -k /usr/local/etc/pftabled.key -t 19200"</b> <br>  Add the following line to crontab <br>  <b>* / 5 * * * * / sbin / pfctl -t androids -T expire 19200&gt; / dev / null 2&gt; &amp; 1</b> <br><br>  <b>ATTENTION!!!</b>  <b>/usr/local/etc/pftabled.key should have permissions 0444</b> <br><br>  Well, actually the last part is the web access rule. <br>  The code is simple and unpretentious, I have enough for work.  Therefore, without beautiful and frills. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use POSIX qw(strftime); use DB_File; use strict; use IO::Socket; use Digest::HMAC_SHA1 qw(hmac_sha1); use Cache::Memcached::Fast; use vars qw/%sv %form %cookie %macs $lease_base $pftabled $key/; use constant PFTBLPORT =&gt; 56789; use constant pfip =&gt; "127.0.0.1"; use constant PFTBLVERSION =&gt; 2; use constant PFTABLED_CMD_ADD =&gt; 1; use constant PFTABLED_CMD_DEL =&gt; 2; use constant PFTABLED_CMD_FLUSH =&gt; 3; use constant PFTBLCOMMAND =&gt; 1; use constant PFTBLMASK =&gt; 32; use constant SHA1_DIGEST_LENGTH =&gt; 20; use constant PFTBLNAME =&gt; "androids"; require "functions.pm"; #BEGIN { Net::ISC::DHCPd::OMAPI::_DEBUG = sub { 1 } } $lease_base = new Cache::Memcached::Fast({ servers =&gt; [ { address =&gt; 'localhost:11211', noreply =&gt; 1 } ], }); &amp;systeminit; tie %macs, 'DB_File', '/var/db/macs.db', O_CREAT|O_RDWR, 0666, $DB_HASH or die "Cannot open file '/var/db/macs.db': $!\n"; print "Content-Type: text/html;\r\n\r\n"; print &lt;&lt; "[end]"; &lt;HTML&gt; &lt;HEAD&gt; &lt;meta http-equiv="Content-Type" content="text/html;"&gt; &lt;TITLE&gt;DHCP State&lt;/TITLE&gt; &lt;STYLE&gt; TD { font:14px Courier; border-left:0px; border-top:0px; border-right:1px; border-bottom:1px; border-style: dashed; text-align: center;} BODY { font:14px Courier; } INPUT[type=button] { width: 100px; font: Verdana, Tahoma; } TR.red { background-color: #A0A0A0; } TR.head { background-color: #808080; } TR.green { background-color: #00C000; } TABLE { } &lt;/STYLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;script&gt; function subm(id) { if(confirm("Really toggle access type for " + id)) { document.toggle.mac.value=id; document.toggle.submit(); } } &lt;/script&gt; [end] #print "Macs list: ",join (",",keys %macs),"\n"; if($form{"mac"}) { &amp;load_key; $pftabled = IO::Socket::INET-&gt;new(Proto =&gt; 'udp', PeerPort =&gt; PFTBLPORT, PeerAddr =&gt; pfip) or die "Creating socket: $!\n"; my $ip = $lease_base-&gt;get("ip/".$form{"mac"}); # print "Form list: ",join (",",keys %form),"\n"; if(defined($macs{$form{"mac"}})) { delete($macs{$form{"mac"}}); &amp;pftabled_operations(PFTABLED_CMD_DEL,$ip); print STDERR "MAC Address ".$form{"mac"}." with IP $ip removed from full access\n"; } else { print STDERR "MAC Address ".$form{"mac"}." with IP $ip added to full access\n"; &amp;pftabled_operations(PFTABLED_CMD_ADD,$ip); $macs{$form{"mac"}} = 'full'; } } print &lt;&lt; "[end]"; &lt;table width=100% border=0 cellspacing=0 cellpadding=1&gt; &lt;form name="toggle" method=POST&gt; &lt;input type=hidden name="mac" value=""&gt; &lt;/form&gt; [end] for(my $network=0;$network&lt;255;$network++) { print &lt;&lt; "[end]"; &lt;tr&gt;&lt;th colspan=6&gt;Network $network&lt;/th&gt;&lt;/tr&gt; &lt;tr class="head"&gt;&lt;td&gt;IP&lt;/td&gt;&lt;td&gt;MAC&lt;/td&gt;&lt;td&gt;Access&lt;/td&gt;&lt;td&gt;Hostname&lt;/td&gt;&lt;td&gt;Last Seen/Lease Start&lt;/td&gt;&lt;td&gt;Planned Expire&lt;/td&gt;&lt;/tr&gt; [end] for(my $i=0;$i&lt;256;$i++) { my $ip_address = "192.168.$network.$i"; my $mac_address = $lease_base-&gt;get('mac/'.$ip_address) || next; #print Dumper($lease); my $hostname = $lease_base-&gt;get('name/'.$ip_address); my $checkboxvalue = ($macs{$mac_address}) ? "Back to normal" : "Switch to full"; my $style = ($macs{$mac_address}) ? "green" : "red"; my $checkboxfield = ($mac_address) ? "&lt;input type=button name=\"".$mac_address."\" value=\"$checkboxvalue\" onclick=\"subm(this.name)\"&gt;" : " "; print "&lt;tr class=\"$style\"&gt;&lt;td&gt;"; print join ("&lt;/td&gt;&lt;td&gt;",$ip_address,$mac_address||" ",$checkboxfield,$hostname||" ",time_expand($lease_base-&gt;get('lease_start/'.$ip_address)),time_expand($lease_base-&gt;get('lease_end/'.$ip_address))); print "&lt;/tr&gt;\n"; } print "&lt;tr&gt;&lt;td colspan=6&gt; &lt;/td&gt;&lt;/tr&gt;\n"; } print &lt;&lt; "[end]"; &lt;tr&gt;&lt;th colspan=6&gt;Registered Mac Addresses&lt;/td&gt;&lt;/tr&gt; [end] foreach my $mac (keys %macs) { print &lt;&lt; "[end]"; &lt;tr&gt;&lt;td class="red" colspan=2&gt;$mac -&gt; $macs{$mac}&lt;/td&gt;&lt;td colspan=4&gt; &lt;/td&gt;&lt;/tr&gt; [end] } print "&lt;/table&gt;&lt;/html&gt;&lt;/body&gt;"; untie %macs; exit(0); sub time_expand { my $time = shift; #($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time); my $now = strftime "%a %b %e %H:%M:%S %Y", localtime($time); return($now); } sub pftabled_operations { my $command = shift; my $iparray = shift; #print @iparray; foreach my $addip (split("\0",$iparray)) { my $addr = inet_aton($addip); my $time = time(); my $block = pack("C1 S1 C1",PFTBLVERSION,$command,PFTBLMASK).$addr.pack("a32 N*",PFTBLNAME,$time); my $digest = hmac_sha1($block, $key); $block .= $digest; $pftabled-&gt;send($block); } } sub load_key { my $keyfile = "/usr/local/etc/pftabled.key"; if (! -r $keyfile) { print STDERR "Cannot Read KeyFile $keyfile\n"; exit 1; } open(KEY, "&lt;$keyfile"); sysread KEY, $key, SHA1_DIGEST_LENGTH; close KEY; }</span></span></code> </pre><br><br>  Well, in general, that's all. <br>  I hope the read will be useful to you and guide you to certain thoughts on the possible improvement of the system for your company. <br><br>  PS: To create hotspots with the ability to open access by the user, you can replace the initial redirection of the proxy with redirection to the web server with the authorization form and from there add the host to pftabled without using isc-dhcpd. <br>  PPS: use "functions.pm" in the last file is a handler for input data of forms and environment variables.  The variable check can be rewritten to CGI.  For those who wish, I can lay out the functionality and source of the module "functions.pm" <br><br>  <font>Aborche 2011</font> <br><img src="https://habrastorage.org/getpro/habr/post_images/cff/19a/9b6/cff19a9b6d0354bbc4d1a45beda58acf.jpg"></div><p>Source: <a href="https://habr.com/ru/post/134154/">https://habr.com/ru/post/134154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../134149/index.html">Customer feedback, or how we implemented Kopini</a></li>
<li><a href="../134150/index.html">CSRF vulnerabilities on the example of HabraHabra</a></li>
<li><a href="../134151/index.html">The basic principle of programming a controlled form in 1C</a></li>
<li><a href="../134152/index.html">Opera 11.60 Finally, the bookmarks indicator !!!</a></li>
<li><a href="../134153/index.html">December 10-11, Yekaterinburg will host HackDay # 21</a></li>
<li><a href="../134157/index.html">Vulnerability in Facebook has opened access to private photo users (including Zuckerberg)</a></li>
<li><a href="../134158/index.html">Registering global hotkeys using WPF</a></li>
<li><a href="../134160/index.html">Training course. Creating a complex data model for an ASP.NET MVC application, part 2</a></li>
<li><a href="../134161/index.html">Lenovo has released a secure laptop for students and schoolchildren.</a></li>
<li><a href="../134163/index.html">Data mining in online games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>