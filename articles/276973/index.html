<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explaining the inexplicable. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Registration for the PG Day'16 conference is in full swing, and we continue to publish a translation of Hubert Lubaczewski ‚Äôs articles on explain and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explaining the inexplicable. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <i>Registration for the PG Day'16 conference is in full swing, and we continue to publish a translation of <a href="http://www.depesz.com/">Hubert Lubaczewski</a> ‚Äôs articles on explain and its main components.</i> <br><br>  <a href="https://habrahabr.ru/post/275851/">Last time</a> I wrote about what the output of explain shows.  Now I want to talk more about the different types of "nodes" / operations that you may find in explain plans. <br><img src="https://habrastorage.org/files/977/038/b64/977038b644384b6abc4e453fb72d4c9d.jpg"><br><a name="habracut"></a><br><br><h4>  <font color="#adadad">The most basic operation is sequential scanning (Seq Scan).</font> </h4><br>  She looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------- Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=202) (actual time=0.009..0.049 rows=295 loops=1) Total runtime: 0.249 ms (2 rows)</span></span></code> </pre> <br>  This is the simplest operation possible - PostgreSQL opens the file with the table, reads the lines one by one and returns them to the user or the explain tree node above, for example, LIMIT, like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..0.07 rows=2 width=202) (actual time=0.014..0.014 rows=2 loops=1) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=202) (actual time=0.009..0.009 rows=2 loops=1) Total runtime: 0.132 ms (3 rows)</span></span></code> </pre><br>  It is important to understand that the order in which rows are returned is not specific.  They are not returned "in the order of insertion" or "last updated line - the first", or something else in the same spirit.  Parallel samples, updates, deletes, vacuums can change the order of rows at any time. <br><br>  Seq Scan can filter rows ‚Äî that is, discard some on return.  This happens, for example, when you add a ‚ÄúWHERE" condition: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname ~ <span class="hljs-string"><span class="hljs-string">'a'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------- Seq Scan on pg_class (cost=0.00..11.65 rows=227 width=202) (actual time=0.030..0.294 rows=229 loops=1) Filter: (relname ~ 'a'::text) Rows Removed by Filter: 66 Total runtime: 0.379 ms (4 rows)</span></span></code> </pre><br>  As you can see, now we have the information ‚ÄúFilter:‚Äù.  And, since I have DBMS version 9.2 or newer, I also received the comment "Rows removed by filter" (‚ÄúRows removed by filter"). <br><br><h4>  <font color="#adadad">The next node type is ‚ÄúIndex Scan".</font> </h4><br>  This type of scan seems very simple, and most people understand at least one use case: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> = <span class="hljs-number"><span class="hljs-number">1247</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------- Index Scan using pg_class_oid_index on pg_class (cost=0.15..8.17 rows=1 width=202) (actual time=0.007..0.007 rows=1 loops=1) Index Cond: (oid = 1247::oid) Total runtime: 0.077 ms (3 rows)</span></span></code> </pre><br>  It's simple - we have an index corresponding to the condition, so PostgreSQL: <br><br><ul><li>  opens the index; </li><li>  in the index, if it finds where (in the data of the table) there may be rows corresponding to the given condition: <br><ul><li>  opens the table; </li><li>  obtains the string (s) indicated by the index; </li></ul></li><li>  if the rows can be returned ‚Äî that is, if they are visible in the current session ‚Äî they are returned. </li></ul><br>  Of course, you might ask: how can a string be invisible?  This can happen with deleted rows that are still in the table (have not been cleaned by vacuum).  Or with lines that have been updated.  Or were inserted, but after the current transaction. <br><br>  Index Scan is also used when you want to sort some data using the sort order in the index, for example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.15..1.67 rows=10 width=206) (actual time=0.017..0.029 rows=10 loops=1) -&gt; Index Scan using pg_class_oid_index on pg_class (cost=0.15..44.53 rows=292 width=206) (actual time=0.014..0.026 rows=10 loops=1) Total runtime: 0.145 ms (3 rows)</span></span></code> </pre><br>  There is no condition here, but we can easily add it like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1247</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.15..4.03 rows=10 width=206) (actual time=0.021..0.035 rows=10 loops=1) -&gt; Index Scan using pg_class_oid_index on pg_class (cost=0.15..37.84 rows=97 width=206) (actual time=0.017..0.031 rows=10 loops=1) Index Cond: (oid &gt; 1247::oid) Total runtime: 0.132 ms (4 rows)</span></span></code> </pre><br>  In these cases, the PG finds the starting point in the index (either the first row that is older than 1247, or just the smallest value in the index), and then simply returns the next row / value until the Limit condition is satisfied. <br><br><h4>  <font color="#adadad">There is a version of Index Scan called ‚ÄúIndex Scan Backward", which does the same thing, but is used to scan in descending order:</font> </h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1247</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.15..4.03 rows=10 width=206) (actual time=0.012..0.026 rows=10 loops=1) -&gt; Index Scan Backward using pg_class_oid_index on pg_class (cost=0.15..37.84 rows=97 width=206) (actual time=0.009..0.022 rows=10 loops=1) Index Cond: (oid &lt; 1247::oid) Total runtime: 0.119 ms (4 rows)</span></span></code> </pre><br>  This is the same type of operation: open the index and, for each row referenced by the index, extract data from the table.  It just does not happen ‚Äúfrom the smallest to the largest‚Äù, but ‚Äúfrom the biggest to the lesser‚Äù. <br><br><h4>  <font color="#adadad">Another similar operation is ‚ÄúIndex Only Scan".</font> </h4><br>  Let's create a simple table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, i int4); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (i) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> vacuum <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; VACUUM</code> </pre><br>  This gives us a table like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; id | i <span class="hljs-comment"><span class="hljs-comment">----+----------- 1 | 546119592 2 | 253476978 3 | 235791031 4 | 654694043 5 | 187647296 6 | 709050245 7 | 210316749 8 | 348927354 9 | 120463097 10 | 5611946 (10 rows)</span></span></code> </pre><br>  Here I have an index by id: <br><br><pre> <code class="sql hljs">\d test Table "public.test" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">--------+---------+--------------------------------------------------- id | integer | not null default nextval('test_id_seq'::regclass) i | integer | Indexes: "test_pkey" PRIMARY KEY, btree (id)</span></span></code> </pre><br>  So, if certain conditions are fulfilled (I will talk about this in more detail later), I can get a plan like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------------ Limit (cost=0.29..0.55 rows=10 width=4) (actual time=0.039..0.042 rows=10 loops=1) -&gt; Index Only Scan using test_pkey on test (cost=0.29..2604.29 rows=100000 width=4) (actual time=0.036..0.038 rows=10 loops=1) Heap Fetches: 0 Total runtime: 0.092 ms (4 rows)</span></span></code> </pre><br>  Note the word ‚ÄúOnly" in ‚ÄúIndex Only Scan". <br><br>  This means that Postgres realized that I only select data (columns) from the index.  And, perhaps, he does not need to check anything in the table files.  So it will return data directly from the index. <br><br>  These scans have become a big change in <a href="http://www.depesz.com/2011/10/08/waiting-for-9-2-index-only-scans/">PostgreSQL 9.2</a> , as they can work much faster than regular index scans, because they don't need to check anything in the table data. <br><br>  The difficulty is that in order to work correctly, the Index must contain information that these strings are on pages that have not undergone changes ‚Äúrecently‚Äù.  That is, to use Index Only Scans, your table should be well cleaned using vacuum.  But, with the autovacuum running, this should not be a problem. <br><br><h4>  <font color="#adadad">The last type of table scan is called Bitmap Index Scan.</font>  <font color="#adadad">It looks like this:</font> </h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on test (cost=4.37..39.99 rows=10 width=8) (actual time=0.025..0.110 rows=13 loops=1) Recheck Cond: (i &lt; 100000) -&gt; Bitmap Index Scan on i1 (cost=0.00..4.37 rows=10 width=0) (actual time=0.013..0.013 rows=13 loops=1) Index Cond: (i &lt; 100000) Total runtime: 0.154 ms (5 rows)</span></span></code> </pre><br>  (if you read carefully, you noticed that it uses an index, the creation of which I did not speak about before. This is easy to do: <i>create index i1 on test (i);</i> ). <br><br><h4>  <font color="#adadad">Bitmap Scans always consist of at least two nodes.</font>  <font color="#adadad">First (at the bottom level) is Bitmap Index Scan, and then - Bitmap Heap Scan.</font> </h4><br>  How it works? <br><br>  Suppose your table has 100,000 pages (about 780MB).  Bitmap Index Scan will create a bitmap, where each page of your table will correspond to one bit.  So, in this case, we get a memory block of 100,000 bits ~ 12.5 KB.  All these bits will be set to 0. Then, Bitmap Index Scan will set some bits to 1, depending on which page of the table may contain the row to be returned. <br><br>  This part does not affect the data in the table at all.  After this is done - that is, when all the pages that contain the lines to be returned are ‚Äúmarked‚Äù - this bitmap goes up a level to the Bitmap Heap Scan node, which reads them in a more consistent manner. <br><br>  What is the meaning of such an operation?  Conventional Index Scans cause random I / O operations ‚Äî pages from disk are loaded in random order.  And it is slow.  At least on rotating discs. <br><br>  Sequential scanning is faster when you need to get one page, but, on the other hand, you don‚Äôt always need all the pages. <br><br>  Bitmap Index Scans combines both cases: when you need a lot of rows from the table, but not all, and when the rows that you return are not in the same block (which would be justified if I performed the operation ‚Äú... where id &lt;. .. "). Bitmap scans have another interesting feature - they can combine two operations or two indices, as in this example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">950000000</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------ Bitmap Heap Scan on test (cost=107.36..630.60 rows=5323 width=8) (actual time=1.023..4.353 rows=5386 loops=1) Recheck Cond: ((i &lt; 5000000) OR (i &gt; 950000000)) -&gt; BitmapOr (cost=107.36..107.36 rows=5349 width=0) (actual time=0.922..0.922 rows=0 loops=1) -&gt; Bitmap Index Scan on i1 (cost=0.00..12.25 rows=527 width=0) (actual time=0.120..0.120 rows=491 loops=1) Index Cond: (i &lt; 5000000) -&gt; Bitmap Index Scan on i1 (cost=0.00..92.46 rows=4822 width=0) (actual time=0.799..0.799 rows=4895 loops=1) Index Cond: (i &gt; 950000000) Total runtime: 4.765 ms (8 rows)</span></span></code> </pre><br>  Here we see two Bitmap Index scans (there may be more), which are then combined (but not in the same way as with the ‚ÄúJOIN" operation in SQL!) Using BitmapOr. <br><br>  As you remember, the output Bitmap Index Scan is a bitmap (a block of memory with ones and zeros).  Having several such bitmaps, you can easily perform logical operations on them: Or, And, or Not. <br><br>  Here we see that two such bitmaps were combined using the Or operator, and the resulting bitmap was transferred to the Bitmap Heap Scan, which loaded the appropriate rows from the table. <br><br>  Although both index scans use the same index here, this is not always the case.  For example, let's quickly add some more columns: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> j int4 <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> h int4 <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (j); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (h); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span></code> </pre><br>  But what happens: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> j &lt; <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> h &gt; <span class="hljs-number"><span class="hljs-number">950000000</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------ Bitmap Heap Scan on test (cost=280.76..323.61 rows=12 width=16) (actual time=2.295..2.352 rows=11 loops=1) Recheck Cond: ((h &gt; 950000000) AND (j &lt; 50000000) AND (i &lt; 50000000)) -&gt; BitmapAnd (cost=280.76..280.76 rows=12 width=0) (actual time=2.278..2.278 rows=0 loops=1) -&gt; Bitmap Index Scan on i3 (cost=0.00..92.53 rows=4832 width=0) (actual time=0.546..0.546 rows=4938 loops=1) Index Cond: (h &gt; 950000000) -&gt; Bitmap Index Scan on i2 (cost=0.00..93.76 rows=4996 width=0) (actual time=0.783..0.783 rows=5021 loops=1) Index Cond: (j &lt; 50000000) -&gt; Bitmap Index Scan on i1 (cost=0.00..93.96 rows=5022 width=0) (actual time=0.798..0.798 rows=4998 loops=1) Index Cond: (i &lt; 50000000) Total runtime: 2.428 ms (10 rows)</span></span></code> </pre><br>  Three Bitmap Index Scan scans, each of which uses its own index, bitmaps are combined using the ‚Äúand" bit operation, and the result is fed to the Bitmap Heap Scan. <br><br>  If you are wondering why BitmapAnd shows ‚ÄúActual rows = 0", the answer is simple: this node does not deal with rows at all (only the page page's bitmap). So it cannot return rows. <br><br>  That's all for now.  These are all possible table scans ‚Äî the ways you get data from disk.  Next time I will talk about combining different data sources and other types of plans. </div><p>Source: <a href="https://habr.com/ru/post/276973/">https://habr.com/ru/post/276973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276957/index.html">Carefully about counting single bits</a></li>
<li><a href="../276961/index.html">Nginx 1.9.11 released with support for dynamic modules</a></li>
<li><a href="../276967/index.html">Hardware password manager or how to stop entering passwords and start living</a></li>
<li><a href="../276969/index.html">Dash opened source code for vending machine with InstantX</a></li>
<li><a href="../276971/index.html">RxSwift in action - we write reactive application</a></li>
<li><a href="../276975/index.html">FRUSDR update for optimal server performance (INTEL platform)</a></li>
<li><a href="../276977/index.html">Domain telephony</a></li>
<li><a href="../276979/index.html">PRIMEFLEX vShape - turnkey solution for the implementation of virtualization</a></li>
<li><a href="../276981/index.html">Crash course on interfaces in go</a></li>
<li><a href="../276983/index.html">VK vulnerability: access to previews of photos from dialogues and hidden albums of any user</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>