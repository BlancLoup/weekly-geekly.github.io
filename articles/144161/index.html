<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Django and the features of using transactions in MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably everyone knows that Django is one of the most popular frameworks for web development in python. And even if the web-project is based on third...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Django and the features of using transactions in MySQL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0c8/f9d/aa6/0c8f9daa68bb55a7340ef6ae62e7acd1.png" align="left">  Probably everyone knows that Django is one of the most popular frameworks for web development in python.  And even if the web-project is based on third-party code, then often when developing, they use separate parts of this framework - for example, ORM.  In this article I would like to tell about the features of using Django ORM when working with MySQL database, namely about transactions and pitfalls associated with them.  So, for example, if at some point you realize that instead of the expected data, a completely different result returns, then perhaps this article will help you figure out what's what. <br><a name="habracut"></a><br>  Next, we will talk about InnoDB, because it is the only engine that runs as part of MySQL and fully supports transactions (BDB does not count, since it has not been supported for a long time). <br>  It is worth noting a number of features: <br>  <b>1.</b> In Django, the <b>MySQLdb</b> extension is used as an interface to MySQL, and in turn, each time it connects to the database, it <a href="http://mysql-python.sourceforge.net/FAQ.html">sets</a> : <br><pre><code class="sql hljs">AUTOCOMMIT=0</code> </pre> <br>  That is, each data change operation must complete a COMMIT / ROLLBACK to commit or roll back the changes.  If you used to use PHP (PDO, Mysqli) or Ruby extensions to access MySQL, then you will probably be a little surprised, because in almost all database access drivers the <b>AUTOCOMMIT</b> value <b>does</b> not change when connected (by default, MySQL <b>sets</b> it to <b>AUTOCOMMIT = 1</b> ). <br>  <b>2.</b> MySQL uses the <b>REPEATABLE-READ</b> transaction isolation level, unlike, for example, PosgreSQL or Oracle, in which the isolation level is transacted by default <b>READ-COMMITTED</b> . <br>  What does it mean?  Consider a specific example: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> <span class="hljs-string"><span class="hljs-string">`test`</span></span> ( <span class="hljs-string"><span class="hljs-string">`id`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">`value`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">`id`</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CHARSET</span></span>=utf8; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`test`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>);</code> </pre><br><h6>  REPEATABLE-READ </h6><table><tbody><tr><th>  1st transaction: </th><th>  2nd transaction: </th></tr><tr><td>  SET AUTOCOMMIT = 0; </td><td>  SET AUTOCOMMIT = 0; </td></tr><tr><td>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 + ---- + ------- + </pre><br></td><td></td></tr><tr><td></td><td>  INSERT INTO `test` VALUES (NULL, 'b'); <br>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 |  2 |  b |
 + ---- + ------- + </pre><br>  COMMIT; </td></tr><tr><td>  INSERT INTO `test` VALUES (NULL, 'c'); <br>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 |  3 |  c |
 + ---- + ------- + </pre><br>  COMMIT; </td><td></td></tr></tbody></table><br>  As you can see from the example, in the first transaction after the first reading of the data, all subsequent readings will return exactly the same result until the <b>COMMIT</b> occurs, regardless of what happens in other transactions. <br><br><h6>  READ-COMMITTED </h6><table><tbody><tr><th>  1st transaction: </th><th>  2nd transaction: </th></tr><tr><td>  SET SESSION tx_isolation = 'READ-COMMITTED'; <br>  SET AUTOCOMMIT = 0; </td><td>  SET SESSION tx_isolation = 'READ-COMMITTED'; <br>  SET AUTOCOMMIT = 0; </td></tr><tr><td>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 + ---- + ------- + </pre><br></td><td></td></tr><tr><td></td><td>  INSERT INTO `test` VALUES (NULL, 'b'); </td></tr><tr><td>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 + ---- + ------- + </pre></td><td></td></tr><tr><td></td><td>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 |  2 |  b |
 + ---- + ------- + </pre><br>  COMMIT; </td></tr><tr><td>  INSERT INTO `test` VALUES (NULL, 'c'); <br>  SELECT * FROM `test`; <br><pre>  + ---- + ------- +
 |  id |  value |
 + ---- + ------- +
 |  1 |  a |
 |  2 |  b |
 |  3 |  c |
 + ---- + ------- + </pre><br>  COMMIT; </td><td></td></tr></tbody></table><br>  In the case of READ-COMMITTED, a SELECT always returns the last committed version of the data. <br><br>  Returning to the topic of Django - the trick to using the Django ORM is that it looks like READ-COMMITTED is the only transaction isolation level that the developers were guided by.  So, for example, if we refer to the Django code, namely the implementation of the <b>get_or_create ()</b> method in the <b>QuerySet</b> class: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_or_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Looks up an object with the given kwargs, creating one if necessary. Returns a tuple of (object, created), where created is a boolean specifying whether an object was created. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> kwargs, \ <span class="hljs-string"><span class="hljs-string">'get_or_create() must be passed at least one keyword argument'</span></span> defaults = kwargs.pop(<span class="hljs-string"><span class="hljs-string">'defaults'</span></span>, {}) lookup = kwargs.copy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.model._meta.fields: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f.attname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lookup: lookup[f.name] = lookup.pop(f.attname) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._for_write = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get(**lookup), <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> self.model.DoesNotExist: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: params = dict([(k, v) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kwargs.items() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'__'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> k]) params.update(defaults) obj = self.model(**params) sid = transaction.savepoint(using=self.db) obj.save(force_insert=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, using=self.db) transaction.savepoint_commit(sid, using=self.db) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IntegrityError, e: transaction.savepoint_rollback(sid, using=self.db) exc_info = sys.exc_info() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get(**lookup), <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> self.model.DoesNotExist: <span class="hljs-comment"><span class="hljs-comment"># Re-raise the IntegrityError with its original traceback. raise exc_info[1], None, exc_info[2]</span></span></code> </pre><br>  then the second attempt to retrieve the object: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get(**lookup), <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br>  will always fail. <br>  I will try to explain - here, for example, two processes simultaneously call the <b>get_or_create ()</b> method of a certain model.  The first process is trying to read the data - no data, the exception is generated <b>DoesNotExist</b> .  The second process similarly tries to read the data and similarly generates an <b>DoesNotExist</b> exception.  Further, since the connection uses AUTOCOMMIT = 0 and the transaction isolation level REPEATABLE-READ, both processes freeze the read data.  Suppose that the first process successfully creates a record and returns an object of the created record.  But at the same time, the second process cannot create anything, since this will violate the uniqueness constraint.  The funny thing is that he does not see the object created in the first process, due to the fact that when you re-read the data returns "frozen" result. <br>  Of course, in experimental conditions, this error is rather problematic to reproduce, but with numerous competitive requests, this code will work unstably, periodically generating the exception <b>DoesNotExist</b> . <br>  How to deal with it? <br>  <b>1.</b> In the case of using the <b>get_or_create ()</b> method, write your own method that performs a forced COMMIT before re-reading the data: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@transaction.commit_manually() def custom_get_or_create(...): try: obj = SomeModel.objects.create(...) except IntegrityError: transaction.commit() obj = SomeModel.objects.get(...) return obj</span></span></code> </pre><br>  <b>2.</b> In MySQL settings (/etc/mysql/my.cnf), use the forced transaction isolation level READ-COMMITTED: <br><pre> <code class="bash hljs">transaction-isolation = READ-COMMITTED</code> </pre><br>  <b>3.</b> When using Django&gt; = 1.2 versions, use the following code in settings.py in the connection options to the database: <br><pre> <code class="django hljs"><span class="xml"><span class="xml">DATABASE_OPTIONS = { "init_command": "SET storage_engine=INNODB, SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED", }</span></span></code> </pre>  This bug was <a href="http://code.djangoproject.com/ticket/13906">published on the</a> Django <a href="http://code.djangoproject.com/ticket/13906">bugtracker</a> a long time ago, but still the ticket is not closed and the problem is still relevant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Or another example - let's say Django ORM is used separately from the web server, as part of a certain demon that is constantly hanging in memory, and periodically reads new data from the MySQL table.  This experiment can be performed using the built-in shell in Django: <br><pre> <code class="bash hljs">python manage.py shell &gt;&gt;&gt; from test_module.models import * &gt;&gt;&gt; len(SomeModel.objects.all()) 10</code> </pre><br>  Next, using the second terminal, add several entries: <br><pre> <code class="bash hljs">&gt;&gt;&gt; SomeModel(name=<span class="hljs-string"><span class="hljs-string">'test1'</span></span>).save() &gt;&gt;&gt; SomeModel(name=<span class="hljs-string"><span class="hljs-string">'test2'</span></span>).save() &gt;&gt;&gt; len(SomeModel.objects.all()) 12</code> </pre><br>  And although there are changes in the second terminal, these newly added entries in the first terminal will still be unavailable, since  the started transaction is not completed, and after the first reading of the data all subsequent readings will return the same result until the COMMIT is invoked forcibly. <br>  What to do with it?  Change the transaction isolation level in the mysql settings (my.cnf) or in the database connection settings in settings.py in Django.  Well, or forcibly commit the data after each read: <br><pre> <code class="bash hljs">&gt;&gt;&gt; from django.db import connection, transaction &gt;&gt;&gt; len(Param_Type.objects.all()) 10 &gt;&gt;&gt; transaction.commit_unless_managed() &gt;&gt;&gt; len(Param_Type.objects.all()) 12</code> </pre><br><br>  Why is this all happening?  Perhaps this is due to the fact that Django was originally designed to work using PostgreSQL as a database, in which, as stated above, READ-COMMITTED is used out of the box.  In general, this is not quite the standard behavior of Django ORM in relation to MySQL InnoDB can lead to quite difficult to catch bugs.  Therefore, in most places where the described problem is discussed (in various blogs and on stackoverflow), it is strongly recommended to use READ-COMMITTED as the transaction isolation level by default, arguing this choice by the fact that READ-COMMITTED is more <a href="http://www.mysqlperformanceblog.com/2010/02/11/read-commited-vs-repetable-read-in-tpcc-like-load/">productive</a> than REPEATABLE-READ. </div><p>Source: <a href="https://habr.com/ru/post/144161/">https://habr.com/ru/post/144161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144155/index.html">The quantum computer still does not come out, but there are a lot of other interesting pieces.</a></li>
<li><a href="../144156/index.html">Petition: OpenMAX IL Update for Qualcomm MSM7227 Based Devices</a></li>
<li><a href="../144158/index.html">Ex-PATRIOT Act vs. Facebook Co-Founder</a></li>
<li><a href="../144159/index.html">The complication of life in LaTeX</a></li>
<li><a href="../144160/index.html">Once again about currying and partial application in PHP</a></li>
<li><a href="../144162/index.html">Team Foundation Server Express</a></li>
<li><a href="../144163/index.html">Analysts do not see signs of a speedy recovery of Oracle hardware business</a></li>
<li><a href="../144165/index.html">‚ÄúTry to guess‚Äù, or for what usability experts receive money</a></li>
<li><a href="../144166/index.html">Google received the latest approval for the Motorola deal</a></li>
<li><a href="../144167/index.html">Detected sources of garbage P2P traffic.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>