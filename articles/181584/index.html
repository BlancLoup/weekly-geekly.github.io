<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Atomic commit mechanism in SQLite</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a partial translation of one interesting article from sqlite.org, which discusses in detail the implementation of transactions in SQLi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Atomic commit mechanism in SQLite</h1><div class="post__text post__text-html js-mediator-article">  <i>This article is a partial translation of one interesting article from sqlite.org, which discusses in detail the implementation of transactions in SQLite.</i>  <i>In fact, I rarely work with SQLite, but nevertheless I really enjoyed this reading.</i>  <i>Therefore, if you just want to develop your horizons, it will be interesting to read.</i>  <i>The first two sections are not included in the translation, since there is nothing interesting there, and I am too lazy to fill them (the post is so huge).</i> <br><br><h5>  3.0 Single File Commit </h5><br>  We begin by reviewing the steps SQLite is taking to commit an atomic commit to a transaction that affects only one database file.  Details of the file format used to protect against damage to the database and equipment that are used for a commit to several databases will be shown below. <br><br><h5>  3.1 Initial state </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/37d/872/61b/37d87261b046bd33a8fa7fd7d40c120a.gif" align="right"><br>  The state of the system, when the connection with the database has just been raised, is superficially depicted in the figure to the right.  The right shows information stored on an energy-independent storage medium.  Each rectangle is a sector.  The blue color indicates that this sector contains the original data.  In the middle is the disk cache of the operating system.  At the very beginning of our example, the cache is cold, it is shown in white.  On the left side of the figure - the contents of the process memory that uses SQLite.  The connection to the database has just been opened, and no information has been read. <br><br clear="all"><a name="habracut"></a><br><h5>  3.2 Getting a read lock </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/3b6/57d/35e/3b657d35e9934d6aed4abe2cd2cbc718.gif" align="right"><br>  Before SQLite can start writing, it must first know what is already there.  Even if it is just inserting new data, it needs to read the schema from the <i>sqlite_master</i> table <i>so</i> that it knows how to parse the INSERT query and understand where to write the data. <br>  The first step is to obtain shared lock (shared lock) on the database file.  Joint blocking allows two or more connections to read from a file at the same time.  But this type of blocking prohibits other connections from recording until it is removed.  This is mandatory, as if another connection made a record at the same time, we could read a part of the unchanged data and another part of the data after the change.  Then the record could be considered non-atomic. <br>  Note that the lock was installed on the OS and the disk cache, and not on the disk itself.  File locks are usually just flags controlled by the system kernel.  They will be reset for any system crash or power failure.  Also, they are usually reset when the process that received the lock dies. <br><br clear="all"><h5>  3.3 Reading information from a database </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/255/9bc/003/2559bc00371a02299b03aeef97f4d592.gif" align="right"><br>  After the lock has been acquired, we can start reading from the database file.  In this scenario, we mean that the cache is not yet warmed up, so the information must first be read from the data collector to the operating system cache, and then it can be moved from the OS cache to user space.  On subsequent readings, all or some of the information will already be in the cache, so it will only need to be given to the user space. <br>  Usually only a small part of the pages will be read from the database file.  In our example, we see that out of eight pages, only three have been read.  In a typical database application, there will be thousands of pages and the request will affect a very small percentage of them. <br><br clear="all"><h5>  3.4 Getting a ‚ÄúReserving‚Äù Block </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/e6e/e6d/b38e6ee6ddb1251624f9537c296e542f.gif" align="right"><br>  Before you make any changes to the database, SQLite first gets a ‚Äúbackup‚Äù lock (reserved lock) on the database file (approx. Lane is the most tolerable translation that came to my mind).  Such a lock is similar to a joint one in that it also allows other processes to read from the database file.  One reserving lock can coexist with several joint.  However, only one reserving lock per file can exist at a time.  Thus, only one process can write to the database at a time. <br>  The idea of ‚Äã‚Äãa reserving lock is that it says that the process intends to start writing to the file in the near future, but so far it has not begun to do this.  And, since the changes have not yet begun to be written, other processes can continue reading from the database.  But no processes can no longer initiate a recording while the lock is alive. <br><br clear="all"><h5>  3.5 Creating a rollback log </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/dde/851/7af/dde8517afe87fdc41cd9fea59ce25b4a.gif" align="right"><br>  Before you start writing to the database file, SQLite first creates a separate log for rolling back the changes, and writes the original database pages to it, which will be changed.  The rollback log contains all the necessary information to roll back the database to its original state before the transaction. <br>  The rollback log contains a small header (shown in green in the diagram), which contains the size of the database file in its original state.  So, if after changing the database file will grow in size, we will still know its original size.  The page number is stored next to each page in the log. <br>  When a new file is created, most operating systems (Windows, Linux, Mac OS X) will not actually write anything to disk.  A new file is created only in the cache of the operating system.  The file is not created on the drive until the operating system finds a suitable time for this.  This makes it appear to the user that the I / O operations on the drive are performed much faster than is possible.  We depicted this process in the diagram on the right, showing that the rollback log appeared only in the disk cache, but not on the disk itself. <br><br clear="all"><h5>  3.6 Changing DB pages in user space </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/240/8dd/540/2408dd5407230fbbfd08088424a12bf6.gif" align="right"><br>  After the original content has been saved to the redo log, the pages can be changed in user memory.  Each connection to the database has its own private copy of the user space, so that changes made to the user space are visible only to this connection.  Other connections still see information from the disk cache, which has not yet been changed.  So, even though one process deals with changing data in the database, other processes can continue to read their own copies of the original content. <br><br clear="all"><h5>  3.7 Resetting the rollback log to drive </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/2cc/580/db5/2cc580db5cafbe17d1eceb774618913d.gif" align="right"><br>  The next step is to reset the rollback journal from the cache to non-volatile memory.  As we will see later, this is a very important step, which gives us a guarantee of data integrity in case of power failure.  This step also takes a lot of time, since writing to non-volatile memory is usually a slow operation. <br>  This step is usually more complicated than simply dumping the log to disk.  On most platforms, you need to do two flushs (or fsyncs).  The first flush writes the main contents of the log.  Then the header of the log is changed to reflect the number of pages in the log.  After that, the header is flushed to disk.  The explanations for why we need this will be given below. <br><br clear="all"><h5>  3.8 Getting an exclusive lock </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/ac5/dae/0fdac5daecaf2404c4a009bebe61ac41.gif" align="right"><br>  Before making changes in the database file itself, we must first obtain an exclusive lock on it.  Getting such a lock consists of two steps.  First, SQLite acquires a pending lock.  Then this lock is translated into exclusive. <br>  ‚ÄúPending lock‚Äù allows other processes that already have joint lock on a file to continue reading from the file.  But he forbids other processes to receive new joint locks.  This is necessary so that the situation where the recording cannot be perfect, because of the large and constantly arriving number of read requests, did not work out.  Each process first gets a shared lock before starting to read, after which it reads and resets the lock.  When there are many processes that constantly need to be read, a situation may occur when each new process gets its lok before any of the existing ones releases its lok.  Thus, there will never be a moment when there is not a single shared lock on the file, and accordingly it will not be possible to get an exclusive lock.  A ‚Äúpending‚Äù lock is needed to prevent the possibility of such a situation, preventing new joint locks from being received on a file, but allowing the existing ones to continue to live.  When all shared locks are released, the pending lock can be transferred to the exclusive lock state. <br><br clear="all"><h5>  3.9 Writing data to a database file </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/20a/7fd/8a420a7fd81d38a0f43497e696d1cd6e.gif" align="right"><br>  When an exclusive lock is obtained, we can be sure that no other process writes to this file and it is possible to make changes in it.  Typically, these changes only reach the OS OS disk cache and are not flushed to the disk itself. <br><br clear="all"><h5>  3.10 Resetting data to the drive </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/a3c/dc8/4d8/a3cdc84d82c36520351721b5b1374ad5.gif" align="right"><br>  Now you need to call flush to be sure that all changes in the database are written to the energy-independent memory.  This is a critical step to ensure that the data survive a further possible power outage.  Due to the slowness of disks and flash memory, this step, along with writing a rollback log (p. 3.7), takes the most part of the time it takes to commit a transaction in SQLite. <br><br clear="all"><h5>  3.11 Deleting a redo log </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/e1f/7a1/484/e1f7a1484e82bdb2630c0ebd0bd8586d.gif" align="right"><br>  After the changes have been saved to disk, we need to delete the rollback log.  This is exactly the moment when we can say that the commit is completed successfully.  If there is a power failure or some kind of system failure before deleting, then the base will be restored to its previous state - before the commit.  If a power failure occurs after the rollback log is deleted, then the commit will be committed.  Thus, the success of a commit in SQLite ultimately depends on whether the file with the log for rollback has been deleted or not. <br>  Deleting a file is not really an atomic operation, but it looks like this from the point of view of the user process.  A process can always ask the operating system: ‚ÄúDoes this file exist?‚Äù And it will receive either ‚Äúyes‚Äù or ‚Äúno‚Äù in response.  After a power failure that occurred during the commit of a transaction, SQLite will ask the operating system if there is a file with a transaction rollback log.  If so, the transaction has not been completed and will be rolled back.  If the answer was no, then the transaction was successfully completed. <br>  The existence of an incomplete transaction depends on whether the rollback log file exists, and deleting it looks like an atomic operation from the end user's point of view.  Consequently, the transaction looks like an atomic operation. <br>  File deletion is an expensive operation on many systems.  As an optimization, SQLite can cut to zero bytes in length, or fill the header with zeros.  In any case, as a result, the log file will no longer be possible to read for rollback and the transaction will be commited.  Trimming a file to zero in length, as well as deletion, is intended as an atomic operation from the point of view of the user process.  Overwriting a log header with zeros is not atomic, but if any part of the header is damaged, the log will not be used for rollback.  Thus, we can say that the commit occurred when the header of the redo log became invalid.  This usually happens when only the first byte of the header is set to zero. <br><br clear="all"><h5>  3.12. Unlocking </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/9e7/22f/016/9e722f016ad5d77341df22a78563d2f4.gif" align="right"><br>  The final step of a commit is to unlock an exclusive lock so that other processes can access the database again. <br>  In the figure on the right, we showed that the information that was in user memory was cleared after the lock was released.  This was indeed the case in older versions of SQLite.  But in newer versions of SQLite, information is stored in the user space in case it is needed for the next transaction.  It is cheaper to use data that is already in memory, instead of getting it from disk cache or reading from the disk itself.  Before using this data, we need to get the shared lock again, and also we need to make sure that no process has changed the state of the database until we had a lock.  On the very first page in the database file there is a counter, which is incremented with each change.  We can find out if the state of the database has changed by checking this counter.  If changes were made to the database, then the user cache should be cleared and overheated.  But more often it happens that no changes were made and the user cache can be used further, which gives a good performance boost. <br><br clear="all"><h5>  4.0 Rollback </h5><br>  Atomic commit should be made instantly.  But all the actions described above obviously take some finite time to perform.  Suppose the computer was turned off in the middle of the commit process described above.  To maintain the illusion of instant changes, we must roll back all partial changes that were made and restore the state of the database to the original. <br><br clear="all"><h5>  4.1 When something goes wrong </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/788/0fc/ed0/7880fced0ce34dbbf570683c161c77df.gif" align="right"><br>  Suppose that a power failure occurred at step 3.10 when changes were written to disk.  When power is restored, the situation will be somewhat similar to what is shown on the right in the figure.  We tried to change three pages in the database file, but only one of them was successfully overwritten on disk.  Another page was partially recorded, and the third remained in its original state. <br>  The rollback log will be whole on the disk after power is restored.  This is the key point.  The reason for the need to flush in step 3.7 is to be absolutely sure that the entire rollback log is completely saved to non-volatile memory before any changes are made to the database file. <br><br clear="all"><h5>  4.2 Hot Rollback Logs </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/165/044/69c/16504469c36d4bb5e76af6ead030ab70.gif" align="right"><br>  When the SQLite process first tries to access a database file, it first gets a shared lock on it, as described in section 3.2.  But then he discovers that there is a rollback log.  Then SQLite checks if this log is a ‚Äúhot rollback log‚Äù.  A hot log is a rollback log that must be applied to the database in order to restore it to an intact state.  A hot log exists only when a process was at some step of a transaction commit and, for some reason, dropped at that moment. <br>  The cooldown log is ‚Äúhot‚Äù if all conditions are true: <br><ul><li>  Redo log exists </li><li>  Rollback log is not an empty file </li><li>  There is no ‚Äúreserved‚Äù lock on the database file </li><li>  The header of the log file is valid and has not been corrupted. </li><li>  The redo log does not contain the name of the redo master log file (see 5.5), or if it does, this file exists </li></ul><br>  The presence of a hot log is a signal that the previous process tried to commit a transaction, but failed for some reason.  A hot log indicates that the database file is in inconsistent state and must be restored before use. <br><br clear="all"><h5>  4.3 Obtaining an exclusive lock on a database file </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/9dd/901/f85/9dd901f85e5808e05ef6905ea185fac8.gif" align="right"><br>  The first step before working with the hot log is getting an exclusive lock on the database file.  This will prevent the possibility of a situation where two or more processes try to use the same hot log at one time. <br><br clear="all"><h5>  4.4 Rolling back incomplete changes </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/d31/b37/e68/d31b37e688d2c137c3d03faef74ff75e.gif" align="right"><br>  Once a process receives an exclusive lock, it is allowed to write to the database file.  Then he tries to read the original content of the pages from the rollback log and write it back to the base.  Remember that the header of the log contains the size of the database file in its original state?  SQLite uses this information to trim the database file to its original size in cases where an incomplete transaction caused the file to grow.  After this step, the database must be the same size and contain exactly the same data that was before the unfinished transaction. <br><br clear="all"><h5>  4.5 Removing a hot log </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/6a7/95c/cd8/6a795ccd8f2a4942c8eb1973a22fefbf.gif" align="right"><br>  After the entire log has been applied to the database file (and also flushed to disk in case of another power loss), its (log) can be deleted. <br>  As in section 3.11, the log file can be truncated to zero bytes in length, or its header can be overwritten with zeros.  In any case, the log is no longer ‚Äúhot‚Äù after this step. <br><br clear="all"><h5>  4.6 We continue as if there were no pending transactions. </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/98a/f39/35a/98af3935a606b6e8fbc93b9537c430a3.gif" align="right"><br>  The last recovery step is to change the exclusive lock to a joint one.  When this happens, the database will be in such a state as if there was no roll back transaction.  Since this entire recovery process occurs automatically and transparently for the user, it looks as if no recovery has taken place. <br><br clear="all"><h5>  5.0 Commit to multiple files </h5><br>  SQLite allows you to talk to two or more databases simultaneously from a single connection using the <code>ATTACH DATABASE</code> .  When multiple database files are changed within a single transaction, all files are updated atomically.  In other words, either all of them are updated, or none of them will be updated.  Reaching the atomic update of several files is a bit more complicated than just one.  In this section, all the magic behind this will be described. <br><br clear="all"><h5>  5.1 Separate log backlog for each database </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/d51/920/ea6/d51920ea63a618b92e3a03a5756975a5.gif" align="right"><br>  When a transaction affects several database files, each of these files has its own rollback log and the lock on each file is obtained separately.  The figure on the right shows the situation when three different database files were modified within the same transaction.  The situation at this step is similar to a normal transaction over a single file from section 3.6.  On each file of DB the reserving lock is hung up.  For each database, the original contents of those pages that will now be changed were recorded in the corresponding rollback logs, but these logs have not yet been flushed to disk.  The database files have not yet been changed, but the changes are already in the user memory of the process. <br>  For brevity, the drawings in this section are simplified relative to those in the other sections.  Blue color still means original information, and pink - new.  But individual pages in the rollback logs are not shown in the database files, and we do not show what information is already on the disk, and what else is in the system cache.  Nevertheless, all these factors still exist in a multi-file transaction, but they would take up a lot of space on the charts and would not give us much useful information, so here they are omitted. <br><br clear="all"><h5>  5.2 Master log file </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/9dd/674/6f7/9dd6746f7a5d15557f4646789f700de6.gif" align="right">  The next step in a multi-file transaction is to create a master log.  The name of the master log is the same as the name of the original database file (to which the connection was opened) with the added line ‚Äú-mjHHHHHHHH‚Äù (‚Äúmj‚Äù from the ‚Äúmaster journal‚Äù), where HHHHHHHH is a random 32-bit value that is generated for each new master log. <br>  (This algorithm for generating the name of the master log file is only a detail of the implementation of SQLite 3.5.0. It is not specified in the specifications and can be changed in any new version) <br>  Unlike redo logs, the master log does not contain any original content from the database pages.  Instead, it contains the full paths to the rollback log files for each database that participates in the transaction. <br>  After the master log has been compiled, its contents are flushed to disk.  On Unix systems, the master log directory is also reset to ensure that the master log appears in this directory after a power failure. <br><br clear="all"><h5>  5.3 Update rollback log headers </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/023/5b0/34d/0235b034d4d051403777eff70ae63b4a.gif" align="right"><br>  The next step is to write the full path to the master log file to the header of each redo log.  The place under the name of the master log file in the rollback log files was set aside before they were created. <br>  The content of each rollback log is flushed to disk before and after writing the name of the master log to its header.  It is important that we do exactly two data flushes.  Fortunately, the second flush is usually inexpensive because usually only one page of the log file will be changed. <br><br clear="all"><h5>  5.4 Updating Database Files </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/f53/c23/d03/f53c23d038d80f1331f520dce3efc24e.gif" align="right"><br>  As the rollback log files were flushed to disk, we can start updating the database files.  We need to get exclusive locks for all the files we are going to write changes to.  After the changes are recorded, you will need to reset them to disk. <br>  This step reflects sections 3.8, 3.9 and 3.10 from a single-file commit. <br><br clear="all"><h5>  5.5 Delete Master Log </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/d76/4b2/ae3/d764b2ae3047dbd25f68cb827161e202.gif" align="right"><br>  The next step is to delete the master log file.  At this point, the transaction can be considered complete.  This step reflects section 3.11 from a single-file commit where the rollback log is removed. <br>  If at this moment there is a power failure or some kind of system failure, the transaction will not be rolled back after the system is restored, even if the rollback logs are still alive.  Their headers contain the name of the master-log file, which means they will not be used if the master-log itself does not already exist. <br><br clear="all"><h5>  5.6 Clearing the rollback logs </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/57c/14f/58f/57c14f58f5da10b4f7c6ab6636e32ebc.gif" align="right"><br>  The final step is to remove each of the rollback logs and reset the exclusive locks to the database files so that other processes can see the changes we have made. <br>  At this point, the transaction is already considered completed, so the time spent deleting the logs is not so critical.  In the current implementation, all logs are deleted one by one along with the removal of locks from the corresponding database files - first, the first log is deleted, and the corresponding lock is released, then the second log and lock, and so on.  But in the future, we may change this behavior to one in which all logs will be deleted first, and then all locks will be removed.  The main thing is that the removal of logs occurs before the release of locks, and not after. <br><br clear="all"><h5>  6.0 Additional details of the commit process </h5><br>  Section 3.0 provides an overview of how atomic commits occur in SQLite, but several important details are omitted there.  In the following subsections we will try to fill these gaps. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  6.1 Always whole disk sectors are logged. </h5><br>  When the original data is written to the rollback log, SQLite always writes full sectors, even if the page size is smaller than the sector size.  So historically, the sector size was zakardkozhen in SQLite code as 512 bytes and, since the minimum page size is also 512 bytes, this was never a problem.  But starting with SQLite 3.3.14, it can work with larger sectors.  So starting from this version, when any page is written to the rollback log, then another page can also be recorded with it that falls into the same sector on the disk. <br>  It is important to secure all pages that are on the right sector in order to prevent the scenario with a sudden loss of energy during the recording sector.  Suppose that pages 1, 2, 3, and 4 are all stored in sector 1, and that page 2 is modified.  To write changes to page 2, the file system will also have to rewrite the contents of pages 1, 3, and 4, as it operates with whole sectors.  If this write operation is interrupted by a loss of energy, any of pages 1, 3, or 4 may be left with incorrect data.  Therefore, to avoid such a scenario, you need to save all these pages to the rollback log. <br><br><h5>  6.2 What to do with bad data in the logs </h5><br>  When data is written to a rollback log file, SQLite assumes that the file is first filled with ‚Äúrandom‚Äù data (data that used to be in this place before the file grows and captures this part of the disk), and then it is replaced with valid data.  In other words, SQLite assumes that at first the file size increases (it allocates (sorry, allocates) the space for it), and then only the data is written to it.  If a power failure occurs after changing the file size, but before the data is written, the rollback log will contain bad data.  After the restoration of energy supply, another SQLite process will see a rollback log file that contains garbage (‚Äúgarbage data‚Äù) and will try to roll back based on it, thus the database will be corrupted. <br>  SQLite uses two techniques to combat this problem.  First, SQLite records the number of pages in the header of the redo log.  This number is first written as zero.  So during the attempt to rollback an incomplete log, the process will see that the log does not contain a single page and the rollback will not happen.  Before a commit, the rollback log is flushed to the disk, and only after that the number of pages is corrected in the correct number.  The header of the log is always written in a separate sector of the disk to ensure that rewriting does not harm the data pages in the event of a power failure.  Note that the log is flushed to disk twice: first to record the content of the pages, and then to add the number of pages to the header. <br>  The previous paragraph describes the behavior of SQLite under the <code>PRAGMA synchronous=FULL;</code> flag <code>PRAGMA synchronous=FULL;</code> <br>  By default, this flag is set to <code>FULL</code> , if it is set to <code>NORMAL</code> , SQLite will reset the log only once, after recording the number of pages.  This entails the risk of data corruption, as it may happen that the number of pages is recorded before the database pages.  Although the data pages were sent to the record first, SQLite assumes that the file system can reorganize the order of tasks for writing, and accordingly write the number of pages in the first place.  As another protection against this, SQLite uses 32-bit signatures (hashes) for each page in the redo log.  If it turns out that some page in the log does not match its signature, then the rollback is canceled. <br>  Signatures in the logs are optional if the <code>synchronous</code> flag is set to <code>FULL</code> .  We only need them if this flag is <code>NORMAL</code> .  However, they never hurt, so we include them in the logs in all modes. <br><br><h5>  6.3 Cache overflow during commit </h5><br>  The commit process in section 3.0 assumes that all changes will fit into memory before completing the commit.  This is the most likely case.  But sometimes it happens that the changeset overflows the memory allocated for the user process.  In such cases, the cache must be sent to the database before the transaction is completed. <br>  At the very beginning of the dispatch, the database is in the state as shown in section 3.6.  The original data was saved to the rollback log and changes are in user memory.  To send the cache, SQLite goes through steps 3.7, 3.8 and 3.9.  The log is flushed to disk, an exclusive lock is received on the database file and all changes are recorded.  After that, one more header is added to the log at the end, and we return to step 3.6.  When the transaction is completed, or if there is more data to write, we will return to step 3.7, then 3.9.  (step 3.8 now we don‚Äôt need it, since we didn‚Äôt release the lock) (approx. lane: I didn‚Äôt understand nifiga in this chapter, it‚Äôs written very strangely, if you have ideas, write) <br><br><h5>  7.0 Optimization </h5><br>  Tests say that in most cases, SQLite spends most of its time waiting to be written to disk.  Accordingly, we must first optimize the recording and work with the disc.  This section describes some of the techniques used by SQLite in trying to reduce the number of I / O operations to a minimum, while maintaining the integrity of the commit. <br><br><h5>  7.1 Saving cache between transactions </h5><br>  In step 3.12, you can see that once the joint lock is released, the entire user cache is cleared.  This is done because when you are not sharing a file, other processes can change the database file and make your user cache obsolete.  Consequently, each new transaction will begin with reading data from the database.  This is not as bad as it may seem, since this data is most likely still in the disk cache of the operating system, so it will only be a copy of the data from the OS memory.  But nevertheless, it takes time. <br>  Starting with version 3.3.14, a mechanism has been added that reduces the likelihood that data will need to be re-read.  The data in the user cache remains after the transaction, and before the next transaction, SQLite looks to see if the database file has been changed.  If so, the user cache is reset.  But often at this point the file will be in the same state, so that we avoid unnecessary reads. <br>  To determine whether the database file has changed or not, SQLite uses a counter in the database header (from 24 to 27 bytes), which is incremented after each file change operation.  A custom SQLite process maintains the state of the counter before completing the transaction.  Then, after receiving the lock on the database, it compares the counter with what it was before the first transaction and, if the values ‚Äã‚Äãdiffer, resets the cache. <br><br><h5>  7.2 Exclusive Access Mode </h5><br>  SQLite 3.3.14 received a new feature, called "Exclusive Access Mode".  In this mode, SQLite saves an exclusive lock to the database file after the transaction.  This prevents the database from being accessed by other processes, but in most cases using SQLite, at one point in time only one process uses the database, so this is not a problem.  Thus, the number of disk operations can be reduced by: <br><ol><li>  No need to increment the counter after the first transaction.  This will often save you the operation of writing the first page to the rollback log and to the database file itself. </li><li>  Other processes cannot change the database, so you don‚Äôt need to check the aforementioned counter each time and never need to clean the user cache. </li><li>  Each transaction can overwrite the previous log, the title of which was filled with zeros, instead of deleting the file.  Due to this, we don‚Äôt need to touch the directory with the log file, and also deploy the disk sectors on which the log was located.  Thus, the next transaction will simply overwrite the previous log, instead of creating a new one and writing data to it, because in most systems, rewriting is much cheaper. </li></ol><br>  Part three of optimization, setting the log header instead of deleting the file, actually requires exclusive access mode, it can be enabled using the <code>journal_mode_pragma</code> directive, as described in section 7.6 below. <br><br><h5>  7.3 Do not log freelist pages </h5><br>  When information is removed from the SQLite database, the pages that contained the deleted information are added to the ‚Äúfreelist‚Äù.  Subsequent inserts will simply overwrite these pages in the database file, without the need for file extensions in sizes. <br>  Some freelist pages contain important information, to be more precise, the locations of other freelist pages.  But most of them contain nothing important.  Those pages that are not critical are called leaf pages.  We are free to change their contents, and the state of the database will not change at all. <br>  Since the contents of leaf pages are so insignificant, SQLite avoids storing them in the redo logs in step 3.5 of the commit process.  If the leaf page is changed and this change does not roll back during recovery, the database will not be damaged by this. <br><br><h5>  7.4 One page changes and atomic sector records </h5><br>  Starting with SQLite 3.5.0, the new Virtual File System (VFS) interface contains the <code>xDeviceCharacteristics</code> method, which returns the storage properties (disk).  Among these properties is the possibility of atomic sector recording. <br>  SQLite by default assumes that the disk produces a linear record, and not atomic.  Linear recording starts from one end of a sector and, byte by byte, reaches its other end.  If a power failure occurs during recording, then part of the sector may be damaged (contain old data).  In the atomic sector recording, either the entire sector will be overwritten, or the entire sector will remain in its previous state. <br>  Most modern disks support atomic sector recording.  When power is lost, the disk uses the energy stored in its capacitors and / or the rotational energy of the pancake to complete all the scheduled recording tasks.  Nevertheless, there are so many layers between the system call for recording and the electronics of the disk itself, that we decided to make a pessimistic assumption on all platforms that the sectors are written linearly. <br>  When the record of sectors is atomic, and the size of the database page is equal to the size of the sector, if there is a need to change just one page, SQLite will skip the whole logging process, instead simply writing the changes directly to the database file.  And the change counter will be incremented separately, since a power outage will not cause any harm here, even if it happens before the counter changes. <br><br><h5>  7.5 File systems with safe append </h5><br>  Another optimization, which was introduced in version 3.5.0, uses the safe append disk feature.  As you remember, usually SQLite assumes that when a new piece of data is appended to a file, its size increases first, and then only the data is written.  So if the disk loses energy between these events, the file will eventually contain dead data at the end.  One of the methods in <code>xDeviceCharacteristics</code> tells us whether the disk can make a safe append.  This feature is implemented in such a way that the disk, on the contrary, will first write the data to the ‚Äúpre-allocated‚Äù area, after which it will increase the file size and give that area to this file.  Thus, the loss of energy is not terrible even during recording (in fact, it is an atomic append). <br>  With safe append enabled, SQLite leaves the number of pages in the rollback log header to be -1.  When -1 is found in the log, the process understands that the number of pages needs to be calculated from the size of the log.  Because of this, we save one flush operation. <br><br><h5>  7.6 Failure to delete logs </h5><br>  On many systems, file deletion is a rather expensive operation.  So in SQLite, you can disable the removal of logs.  Instead, you can either trim the file to zero length, or fill in the header with zeros.  Clipping a file is more profitable, because then you don‚Äôt need to touch the directory in which it is contained, because the file itself will remain in that case.  Overwriting the header, on the other hand, allows you not to touch the length of the file (in the inode of this file) and not to waste time on the allocation of the newly freed sectors on the disk.  Then, on the next transaction, the log will be created in an already existing file, overwriting it will also be faster than appending. <br>  SQLite will stick to this strategy if you set the <code>journal_mode</code> option to <code>PERSIST</code> .  ( <code>PRAGMA journal_mode=PERSIST</code> ) <br>  Using this mode usually gives a noticeable performance boost on most systems.  Of course there is a minus - the logs remain on the disk and eat up the place.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only safe way to remove such logs is to commit a transaction with a logging mode </font></font><code>DELETE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">PRAGMA</span></span> journal_mode=<span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXCLUSIVE <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you try to delete the files manually, you can get into a situation where the logs still belong to an incomplete transaction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting from version 3.6.4, the </font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following </font><font style="vertical-align: inherit;">mode is also supported </font><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">PRAGMA</span></span> journal_mode=<span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this mode, the log file size will be truncated to zero bytes. This strategy is also good because the directory in which the file is stored will not be affected. So, often, clipping a file is faster than deleting. Also, it </font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not require a system call to synchronize the state to disk (fsync, flush). But with such a challenge it would be safer. But on most file systems, TRUNCATE is an atomic and synchronous operation, so most likely it will be safe, even with energy loss. If you are not sure whether your file system supports atomic TRUNCATE, and data integrity is important to you, then it is better to choose another logging strategy.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On embedded systems with a synchronous file system, TRUNCATE usually runs slower than PERSIST. </font><font style="vertical-align: inherit;">The first commit is the same in speed, but subsequent transactions are slower, since overwriting data is faster than appending to the end of the file. </font><font style="vertical-align: inherit;">New logs will always be added after TRUNCATE, while with a persistent strategy they will overwrite old ones.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.0 Testing Atomic Commit </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLite developers are confident that this system is reliable in the face of a power failure and various system failures. </font><font style="vertical-align: inherit;">Automatic testing procedures test SQLite for the ability to recover from simulated failures. </font><font style="vertical-align: inherit;">We call it "crash tests."</font></font><br>    SQLite   VFS,        ,        -  .    ,   ¬´¬ª  -      .       ,    ‚Äî    ,  ,  . .                    ,        . <br><br><h5> 9.0      </h5><br>     SQLite  ,     ,       ,  .       ,            . <br><br><h5> 9.1    </h5><br> SQLite    ,  ,             .  ,    VFS      . SQLite    ,   -                 ,        . <br>   -        NFS,       .      ,           ,       ,     .      SQLite       -    . <br>   SQLite,     Max OS X        ,      ,   Apple.    ,   ,          .  ,  ()     ,       AFP     ,      dot-file  (, ),         ,      . <br><br><h5> 9.2     </h5><br> SQLite    <code>fsync</code>  Unix-  <code>FlushFileBuffers</code>  win32,     .  ,    ,   ,             . <code>FlushFileBuffers</code>          Windows.   Linux     <code>fsync</code> ,         .   ,        ,   ,   ,      ,  ,   ,     . <br>  Mac    <code>PRAGMA fillfsync=ON;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That will guarantee a complete reset of data on the pancakes of the disk, and not just in the disk cache. </font><font style="vertical-align: inherit;">But the implementation of fullfsync is rather slow and will slow down other disk operations.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.3 Incomplete file deletion </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLite assumes that deleting a file is an atomic operation from the point of view of the user process. </font><font style="vertical-align: inherit;">If there is a loss of energy during the deletion of the file, SQLite expects that the file will either be saved completely or be deleted. </font><font style="vertical-align: inherit;">Transactions cannot be considered atomic on systems that work differently.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.4 Modification of the database file from the outside </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SQLite database is in regular files on disk that can be opened by other processes and modified. </font><font style="vertical-align: inherit;">Any process can open a database file and fill it with ‚Äúbad‚Äù data. </font><font style="vertical-align: inherit;">SQLite can do nothing to protect against such interference.</font></font><br><br><h5> 9.5      </h5><br>      ,       ,             ,     .    SQLite        ,      .          ,         . <br>         , ,  ,          . <br> <b>      ( ) ,        ,     .           (   ),             .</b> <br>       ,          <code>/lost+found</code> .   ,     ,      . SQLite     (fsync)            .   ,      -   ,        ,    . ,       SQLite,       ,   .    ,    (  ,       ),      SQLite     . </div><p>Source: <a href="https://habr.com/ru/post/181584/">https://habr.com/ru/post/181584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181568/index.html">Impressions of working with Google Glass</a></li>
<li><a href="../181570/index.html">Ubuntu bug number 1 fixed</a></li>
<li><a href="../181572/index.html">What is common between Prince Igor and TCP / IP?</a></li>
<li><a href="../181578/index.html">Odessa Innovation Week</a></li>
<li><a href="../181580/index.html">About color spaces</a></li>
<li><a href="../181586/index.html">USB support in KolibriOS: what's inside? Part 1: general scheme</a></li>
<li><a href="../181588/index.html">Do I need undocumented APIs?</a></li>
<li><a href="../181592/index.html">Login to the site under someone else's account without having a password</a></li>
<li><a href="../181594/index.html">Communication experience with CyanogenMod 10.1</a></li>
<li><a href="../181596/index.html">CheckiNumber.ru: another result of code therapy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>