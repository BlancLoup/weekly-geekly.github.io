<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Energy Optimization STM32: A Practical Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 There are quite a few articles about the work of STM32 microcontrollers in energy-efficient devices - as a rule, these are battery-powere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Energy Optimization STM32: A Practical Guide</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  There are quite a few articles about the work of STM32 microcontrollers in energy-efficient devices - as a rule, these are battery-powered devices - but among them there are regrettably few who understand this topic outside the list of energy-saving modes and SPL / HAL commands that include them (however, the same claim applies to the vast majority of articles about working with STM32). <br><br>  Meanwhile, due to the rapid development of smart homes and all kinds of IoT, the topic is becoming increasingly relevant - in such systems, many components are battery powered, and they are expected to have years of continuous operation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will fill this gap with the example of the STM32L1 controller, which is a very popular controller, quite economical and at the same time having some specific problems for this series.  Virtually everything said will also apply to STM32L0 and STM32L4, and, in terms of common problems and approaches, to other controllers on Cortex-M cores. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  The bottom line should look something like the photo above (and yes, let's also talk about the applicability of multimeters and other measurement tools to similar tasks). <br><a name="habracut"></a><br><h3>  Power saving modes in STM32L1 </h3><br>  The basics of battery saving are basic processor power saving modes.  They are different for each manufacturer and in each series of controllers (a specific set is a vendor extension of the standard Cortex-M core modes with different nuances regarding the periphery, supply voltages, etc.). <br><br>  Specifically, the STM32L1, which belongs to an economical series of controllers and in this connection, among other things, has received an expanded set of power settings, we have the following: <br><br><ul><li>  <b>Run</b> - normal mode.  All inclusive, all peripherals available, frequency up to 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> - a special mode with an operating frequency of 131 kHz and a maximum power consumption, <i>including the entire periphery</i> , 200 ŒºA.  In LP Run mode, the CPU power stabilizer goes into a special economy mode, which saves up to fifty microamps compared to running on the same frequency in Run mode. </li><li>  <b>Sleep</b> - suspend the core, but with the preservation of all clock frequencies.  The processor periphery can continue to work if it does not need the kernel, but it can also be automatically disabled. </li><li>  <b>Low Power Sleep (LP Sleep)</b> - a combination of Sleep with the transition stabilizer in economy mode.  Clock frequency is not higher than 131 kHz, total consumption is not higher than 200 ŒºA. </li><li>  <b>Stop</b> - full stop of all clock frequencies, except for the ‚Äúclock‚Äù generator of 32768 Hz, external or internal.  In the case of the STM32L1, only the real-time clock continues to operate in this mode, everything else stops completely;  in newer processors, some peripherals may be clocked from a low frequency.  <i>Almost</i> all legs of the processor retain their state.  The contents of the RAM is saved, external interrupts continue to work. </li><li>  <b>Standby</b> - complete shutdown of the processor core, RAM and all peripherals, except for the real-time clock.  The RAM is not saved (that is, from the software point of view, going to Standby is almost the same as power juggling - start from the beginning), the RTC continues to tick.  External interrupts do not work, except for the three special legs of WKUPx, which switching from 0 to 1 awakens the processor. </li></ul><br>  Entry into each of the modes is quite simple - you need to set the flags in three to five registers, then (for sleep modes) call the WFI or WFE instruction, this is the standard Cortex-M instruction, meaning "Wait For Interrupt" and "Wait For Event" .  Depending on the flags (they are described in the Reference Manual of the processor, for STM32L1 this is <a href="https://www.st.com/content/ccc/resource/technical/document/reference_manual/cc/f9/93/b2/f0/82/42/57/CD00240193.pdf/files/CD00240193.pdf/jcr:content/translations/en.CD00240193.pdf">RM0038</a> ), the processor itself will fall on this command in the desired mode. <br><br>  In addition, it would be nice to prohibit interruptions (this will not affect the ability of external and internal events to bring the processor out of sleep) and wait until the data has been saved from the registers to memory, if this happens suddenly, with a DSB command. <br><br>  For example, this is how care in Stop mode looks like: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0552a/BABFEFIG.html">WFI</a> is a blocking instruction, on it the processor will go into a deep sleep and will not get out of it until some interruption happens.  Yes, I repeat, despite the fact that we have explicitly turned off the interrupts, the processor will react to them and wake up - but it will start processing only after we turn them on again.  And this has a deep meaning. <br><br>  In the code above, after WFI, it is not just some kind of re-initialization of operating frequencies - the fact is that from deep sleep L1 <i>always</i> comes out at 4.2 MHz and with an internal MSI generator as the source of this frequency.  In many situations, you obviously do not want the interrupt handler to wake up the processor to start running at this frequency ‚Äî for example, because the frequencies of all the timers, UART, and other buses go off;  therefore, we first restore the operating frequencies (or, if we want to stay on MSI, we recalculate the necessary tires under 4.2 MHz), and then we dive into interrupts. <br><br>  In practice, two modes are most often used - Run and Stop.  The fact is that LP Run is painfully slow and does not make sense if the processor needs to perform some calculations, and not just wait for external events, and Sleep and LP Sleep are not very economical (consumption up to 2 mA) and needed if you need save at least a little, but at the same time leave the working periphery and / or ensure the fastest response of the processor to events.  Such requirements are, but in general, not very often. <br><br>  Standby mode is usually not used, because after it, because of the reset of RAM, it is impossible to continue from the same place you stopped at, and there are some problems with external devices, which we will discuss below, and which require hardware solutions.  However, if the device was designed with this in mind, Standby can be used as an ‚Äúoff‚Äù mode, for example, during long-term storage of this device. <br><br>  Actually, on the presentation of this, most manuals usually solemnly breaks off. <br><br>  The problem is that by following them, you will get sad 100-200 ŒºA of real consumption instead of the 1.4 ŒºA promised by dataset at Stop when the clock is running - even on Nucleo's standard debugging, which has no external chips, sensors, etc. at all. on which this could be written off. <br><br>  And no, your processor is healthy, there is nothing in errata, and you did everything right. <br><br>  Just not to the end. <br><br><h3>  Restless Leg Syndrome </h3><br>  The first problem is STM32L1, about which <i>some</i> articles mention, but more often they recall only on the forums, when on the third day of discussion, where did those same 100-200 ŒºA come from, someone remembers the existence of <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/77/74/4f/da/9b/9c/43/e7/DM00033348.pdf/files/DM00033348.pdf/jcr:content/translations/en.DM00033348.pdf">AN3430</a> and reaches it to page 19 - the condition of the legs by default. <br><br>  I note that even STMicro itself is too casual to the question, and in most documents, where energy optimization is considered, it is limited to one or two phrases with the advice to pull unused feet to the ground or switch to analog input mode, without giving any reason. <br><br>  The sadness is that by default all the legs are configured as digital inputs (0x00 in the GPIOx_MODER register).  At the digital input, there is always a Schmitt trigger that improves the noise immunity of this input, while it is completely independent - this is the simplest logical element, a buffer with hysteresis, which does not require external clocking. <br><br>  In our case, this means that we turned off clocking in Stop mode, and Schmitt triggers continued to work as if nothing had happened - depending on the input signal level, they switch their outputs to 0 and 1. <br><br>  At the same time, part of the processor's legs in the typical scheme is hanging in the air - that is, there is no intelligible signal to them.  It would be wrong to think that the lack of a clear signal means that these legs have 0 - no, these legs, due to their high input resistance, have some random interference of an unspecified size, from pickups and current flowing from neighboring tracks to the First TV channel, if the leg is long enough to serve as an antenna (however, analog TV in Russia will soon be turned off, which should lead to some reduction in power consumption of incorrectly configured microcontrollers). <br><br>  In accordance with these fluctuations, the leg in some random way switches between 0 and 1. CMOS logic consumes current when switching.  That is, the <i>processor leg in the air, configured in the digital input mode, consumes a noticeable current by itself</i> . <br><br>  The way out of this is simple - when starting the program, all the legs need to be configured in the analog input state;  for STM32, it is formally available for all legs without exception, regardless of whether they are connected to the ADC or not, and differs from the digital input only by the absence of a Schmitt trigger at the input. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  To do this, it is enough to write the value 0xFF ... FF to all the GPIOx_MODER registers. The easiest way to do this, as mentioned above, is right at the start, and then during the play you have to reconfigure individual legs as you need in this device. <br><br>  Here, however, a second-order problem arises - it‚Äôs good if your firmware runs on one particular controller, and therefore you always know what GPIOx is equal to <i>x</i> .  Worse, if the firmware is universal - the STM32 can have <i>up to</i> 8 ports, but it can be less;  If you try to write to the port that does not exist in this model of the controller, you will get a Hard Fault, i.e.  emergency stop the kernel. <br><br>  However, even this case can be circumvented - Cortex-M allows checking addresses for their validity, and in the case of M3 and M4, the test is generally quite trivial, and on M0 it takes some magic, but is realizable ( <a href="http://olegart.ru/wordpress/2018/09/30/5050/">we can‚Äôt read the details here</a> , ). <br><br>  That is, in the general case, the processor started up, tuned the frequencies - and immediately went through all the available GPIO ports, writing the ones in the MODER (the code below was written under RIOT OS, but on the whole is clear without comment and can be shifted to any other platform). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  I note that this applies only to the L1 series, in L0 and L4 the experience was taken into account, and by default they start to configure all ports as analog inputs. <br><br>  Having carefully done all these procedures, you fill the firmware into the ready-made device ... and get 150 ¬µA in Stop mode on the processor and all external chips turned off, despite the fact that your most pessimistic estimates are derived from datasheets for everything that you have soldered on the board , give no higher than 10 ŒºA. <br><br>  Moreover, further you try to lead the processor to Standby instead of Stop, i.e.  just turn it off almost completely - and instead of falling, the power consumption increases threefold, getting close to half a milliampere! <br><br>  No need to panic.  As you may have guessed, you did everything right.  But not until the end. <br><br><h3>  Restless legs syndrome - 2 </h3><br>  The following problem consists of two parts. <br><br>  The first one is fairly obvious: if your device does not consist of a single microcontroller, then it is important not to forget that external chips also have input signals on which Schmitt triggers hang, and which, moreover, can wake up the internal logic of the chip.  For example, a chip taken away and taken out of its sleep by a UART team, during any movement on this bus, will try to read data from it. <br><br>  Accordingly, if all these legs are hanged in the air, we will not get anything good. <br><br>  Under what conditions are they in the air? <br><br>  First, when the controller goes into Standby mode, all GPIOs are transferred to the High-Z state, with high resistance - that is, in fact, external chips connected to them are airborne.  It is impossible to fix this programmatically in the STM32L1 (in other series and other controllers it happens differently), so the only way out is in the system in which Standby mode is supposed to be used, the inputs of external chips must be pulled to ground or powered by external resistors. <br><br>  The specific level is chosen so that the line is inactive from the point of view of the chip: <br><br><ul><li>  1 for UART TX </li><li>  0 for SPI MOSI </li><li>  0 for SPI CLK with SPI Mode 0 or 1 </li><li>  1 for SPI CLK with SPI Mode 2 or 3 </li><li>  1 for SPI CS </li></ul><br>  Secondly, on STM32, <i>when using Stop mode</i> (sic!), The state of GPIO connected to the internal hardware interface blocks may be ... different.  That is, the same SPI interface, being configured, in the Stop, suddenly it turns out to be either a digital input, or a High-Z in general - with corresponding consequences for external chips hanging on it.  Given that the documentation claims the preservation of the state of the legs, a priori, you can rely on it only if you use your legs as ordinary GPIO. <br><br>  You can‚Äôt understand and forgive this, but you can remember and correct it: for interfaces that behave in this way, they must be forcedly switched to regular GPIO functions with interfaces corresponding to the inactive levels of this interface.  After exiting sleep, interfaces can be restored. <br><br>  For example, the same SPI before going to sleep (for simplicity, I take the code from the RIOT OS OS, it is clear that the same is easy to implement on registers): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Please note that the outputs here are not configured as GPIO_OUT with a level of 0 or 1, but as inputs with a pull-up to 0 or 1 - this is not a crucial moment, but provides additional security if you make a mistake and try to play with pulling-pushing external chip pulling this leg in the other direction.  A short circuit can be made with GPIO_OUT, never with a GPIO_IN with a suspender. <br><br>  In addition, the SPI CS signal is not affected ‚Äî in this case, it is generated by software, that is, by the usual GPIO, and maintains its state in a dream confidently. <br><br>  To restore the state of the legs when leaving sleep, it is enough to record the values ‚Äã‚Äãof the registers that will be changed (MODER, PUPDR, OTYPER, OSPEEDR - at a particular situation) when entering, in variables, and when they come out of sleep from variables, roll them back into registers . <br><br>  And now ... ta-yeah!  The title picture.  One and a half micro ampere. <br><br>  But celebrate early.  At the same time, we have completed the <i>static</i> optimization of energy consumption, and <i>dynamic</i> is waiting for us ahead. <br><br><h3>  Achilles vs the tortoise </h3><br>  What is better - eat more and run faster or eat less, but run slower?  In the case of microcontrollers, the answer to this question is twice non-trivial. <br><br>  First, the operating frequencies can be changed within very wide limits - from 65 kHz (LP Run) to 32 MHz in the usual mode.  Like any CMOS chip, the STM32 has two components in power consumption - static and dynamic;  the second depends on the frequency, the first is constant.  As a result, energy consumption will not decrease as fast as the operating frequency and performance, and depending on the task, the optimal frequency from the point of view of energy efficiency may be different - where you have to wait for some event, but for some reason you cannot go to sleep, there will be low frequencies are effective, where you only need to thresh the numbers - high.  In typical ‚Äúhospital-average‚Äù tasks, it usually does not make sense to descend below 2-4 MHz. <br><br>  Secondly, and this is a less trivial moment, the speed of getting out of sleep depends on the operating frequency and the way it is received. <br><br>  The worst case is getting out of sleep at 32 MHz from external quartz (I remind you that STM32L1 wakes up on an internal generator at 4 MHz), because it consists of three stages: <br><br><ul><li>  processor output from sleep </li><li>  stabilization of quartz generation (1-24 MHz) </li><li>  PLL generation stabilization (32 MHz) </li></ul><br>  Actually, the processor's exit from sleep here is the smallest problem, at a frequency of 4.2 MHz it takes about 10 ¬µs.  But stabilization of quartz can take up to 1 ms (although usually for high-speed resonators it is still faster, on the order of several hundred microseconds), access to the PLL mode is another 160 Œºs. <br><br>  These delays may be insignificant from the point of view of energy consumption for a system that rarely wakes up (no more than once per second), but where the period between waking up is tens of milliseconds or less, and the waking themselves are short, overhead costs begin to make a completely measurable additive even considering that during the wake-up process, the processor consumes a relatively small current. <br><br>  What can be done with this?  In general, the answer is obvious: try to avoid using external quartz.  For example, a program in which there are rare heavy subtasks that require precise clocking (say, from the trivial - data exchange on the UART), and frequent simple subtasks, within each awakening, can decide for some reason or other, whether external quartz, or it will be simpler (and faster!) to perform the current task on the MSI generator, on which the processor has already woken up, without spending a lot of time initializing the frequencies. <br><br>  In this case, however, it may be necessary to adjust the clocking frequencies of the periphery, as well as the adjustment of the flash memory access modes (the number of delay cycles), the processor core supply voltage (in STM32L1 it is selected from three possible values), etc.  However, with regard to the operating modes of the kernel and memory, it is often possible to score on their tuning, choosing the recommended ones for the maximum frequency used, since the non-optimal operation of the kernel at lower frequencies will not give a significant change in practical performance and power consumption due to the small amount of tasks at these frequencies performed by <br><br>  Although all such measures relate to fine-tuning modes (and, for example, most operating systems and libraries do not even know anything closely resembling out of the box), in some cases they can reduce the average consumption of a few percent scale, and sometimes even more.  Imagine, for example, a water meter that polls the reed switch contacts every 50 ms, while the actual poll itself takes several tens of microseconds - do you want to add ~ 500 Œºs by this time when the controller wakes up? .. <br><br><h3>  Unbearable long second </h3><br>  Another problem that is not directly related to energy conservation, but inevitably occurs in connection with it - how to count down time intervals of less than 1 second? <br><br>  The fact is that on STM32L1 there is only one timer operating in the Stop mode - this is the RTC, the nominal time unit of which is 1 second.  At the same time, in the programs time intervals in units, tens and hundreds of milliseconds are constantly encountered, take at least the same water meter. <br><br>  How to be?  Run on processors with LPTIM timers capable of clocking from 32768 Hz?  A good option, in fact, but not always necessary.  It is possible without him. <br><br>  Not at all STM32L1, but starting with Cat.  2 (these are STM32L151CB-A, STM32L151CC and newer processors), the RTC block was supplemented with a new register - SSR, SubSeconds Register.  More precisely, it was not so much added, how many made it visible to the user, plus sub-second alarm clocks ALRMASSR and ALRMBSSR were added. <br><br>  This register does not contain any understandable units of time, it was quickly made from a technical internal counter.  In STM32L1, a clock generator ticking at 32768 Hz passes through two counter-dividers, asynchronous and synchronous, which in total in normal mode divide it by 32768 to get a 1-second tick for the clock.  So, SSR is just the current value of the second counter. <br><br>  Although SSR counts not in milliseconds, but in its units, the dimension of these units can be changed by changing the ratio of the dividers of the synchronous and asynchronous counter, while maintaining their total coefficient equal to 32768 to get the standard 1 second at the RTC input.  Knowing these coefficients, you can calculate the price of one SSR division in milliseconds, and from here you can go on to programming subsecond alarms. <br><br>  It should be noted that the asynchronous pre-counter is more economical than the synchronous SSR, and therefore it should be set to 1, and the input frequency to the SSR should be divided by 32768, having received a count of only 30 Œºs, is energetically unprofitable.  For ourselves, we determined the optimal value for the preliminary divider 7, for the synchronous one - 4095 ((7 + 1) * (4095 + 1) = 32768).  With a further decrease in the preliminary divider, the power consumption of the RTC begins to grow measurably - by the fraction of the microampere, but since we compare this with the ‚Äúreference‚Äù 1.4 ŒºA in the Stop mode, even the fractions matter.  By default, the STM32L1 has these values ‚Äã‚Äã127 and 255, i.e.  the countdown price is about 4 ms, which is a little rough. <br><br>  If you want to dig into the code, then at one time we <a href="">modified the regular RTC driver</a> from RIOT OS to support RTC_SSR and millisecond intervals.  We have been using literally at every step since (and since we are working in the OS, there is also a service on top of it, which allows us to hang almost any number of tasks with arbitrary periods on a single hardware timer). <br><br>  The same approach is transferred to the STM32L0 and STM32L4 controllers, all models of which have the RTC_SSR register;  This allows you to not mess around with the LPTIM timers and unify the code for different platforms. <br><br><h3>  How to understand that a multimeter is lying </h3><br>  Of course, after all the optimizations, a legitimate question arises: what, in fact, have we achieved?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without knowing the answer to it, it would be possible to limit one WFE with properly configured flags, go to sleep and get your 200-500 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most traditional way to measure current is, of course, a multimeter. To understand that he is lying on a load like a microcontroller with its dynamic consumption is very simple - if it is turned on, it means it is lying. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This, however, does not mean that the multimeter in this matter is useless. You just need to know how to use it. </font><font style="vertical-align: inherit;">However, one of the non-random values ‚Äã‚Äãwe are interested in is the consumption of the microcontroller in sleep mode; if it significantly exceeds the value that we estimated on datasheets, it means that something is clearly wrong. This is the consumption of a </font><i><font style="vertical-align: inherit;">static system</font></i><font style="vertical-align: inherit;"> , that is, it can be measured by a multimeter.</font></font><br><br> -,  ‚Äî   ,         ,      ‚Äî  .  ,       ,     . <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br>   ,     ‚Äî    ,        ,       . UT120C   0,1     ¬±1% ¬±3 ,     . <br><br>      ‚Äî       ,   ,              .  ,  ¬´mA¬ª  ¬´uA¬ª       ,       ,         ¬´mA¬ª,      ,   ¬´uA¬ª ‚Äî    ,        . <br><br>  ,       ,   .     , ,  15     ‚Äî       -   27 , , ,      ,    .     -         5-10 ,    . <br><br>    <b></b> (     )   ‚Äî      .       - ,     (, 1 ) ,    ‚Äî     .      0,3        ,   0,3         , 1  = 1 . <br><br>       , ,   ‚Äî       -  100 ,      .        ,   1 ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, static is good, but what about dynamics? </font><font style="vertical-align: inherit;">How to evaluate the same effect of different frequencies on the average power consumption? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here everything is difficult. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's write down the basic requirements:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> current range of at least 1 ŒºA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> measurement period not more than 10 Œºs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voltage drop not higher than 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> duration of measurement - unlimited </font></font></li></ul><br>        ,         18-      30 ,  ,     1 ,     ,        . <br><br>     - . <br><br> , ,           ? Keysight N6705C      ,     $7960. <br><br>    , , SiLabs       ‚Äî   Advanced Energy Monitoring (AEM) System     ,         .   ¬´ ¬ª STK3300/3400   100 ,     STK3700/3800 (    ) ‚Äî 6,25 ,       DK    10 ,      $300+.    SiLabs    Keysight. <br><br>  ,      ‚Äî           ,  OPA2335.          2-3     ,        (        ),       ,        ,     . <br><br>          ‚Äî                ,               -    . <br><br>  ,   ,    -      ,      ‚Äî       -   . <br><br> , ,      USB- UMDK-RF,       ‚Äî     SWD-    DAPLink,  USB-UART    , ,       .        1    INA213 (  50 ,    5 ): <br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br>        (STM32F042F6P6),     10    ,    USB     100- .  ,  -   ,       ,    ,  ,     : <br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br>   ¬´¬ª , ,  ‚Äî  12-        16 ,                 .   ,        -  ,             ,     . <br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br>    ‚Äî       COM-    (  ),       ,   ,        . <br><br>      ,         (  !) -   . <br><br>   <a href="https://github.com/unwireddevices/umdk-boards/blob/master/umdk-rf-107.pdf"> </a> ( <a href="">  DipTrace</a> ),   ‚Äî <a href="https://github.com/unwireddevices/dap42"></a> ( umdk-rf,    UMDK-RF,    <a href="https://devanlai.github.io/projects/dap42/">dap42</a> ).     , , ,   ,    C   libopencm3    arm-none-eabi-gcc.         ,                    . <br><br> NB:   ,   boot         ,       ,     option bytes         ,          . <br><br>   ,            (,        ), <a href="https://www.silabs.com/documents/public/schematic-files/EFM32ZG_BRD2010A_schematic.pdf"> </a> (. 9),     ‚Äî      24-  ‚Äî <a href="https://yadi.sk/i/mIBTGDfM1H6vJQ">  TI</a> (EnergyTrace  . 5). <br><br> PS  ,      UART  JTAG/SWD        ,       . ,  UMDK-RF  SWD   15  (           ,  SWD),   STM32 Nucleo        SWD <a href="http://olegart.ru/wordpress/2016/12/24/4965/"> 200 </a> .           ‚Äî     ,    ,      ,     , ,    . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I hope you already understand what mistake you made by choosing programming microcontrollers as your main specialty. </font></font></div><p>Source: <a href="https://habr.com/ru/post/430218/">https://habr.com/ru/post/430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430206/index.html">MIT course "Computer Systems Security". Lecture 18: "Private Internet Browsing", part 2</a></li>
<li><a href="../430208/index.html">MIT course "Computer Systems Security". Lecture 18: "Private Internet Browsing", part 3</a></li>
<li><a href="../430210/index.html">Puzzle "Test My Patience" by Check Point Security Academy</a></li>
<li><a href="../430212/index.html">OpenSceneGraph: Scene Geometry Basics</a></li>
<li><a href="../430216/index.html">As I understood that I eat a lot of sweets, or the classification of goods by checks in the application</a></li>
<li><a href="../430220/index.html">How to turn a "hundred" usb hub into a "smart" managed and save at the same time $ 300</a></li>
<li><a href="../430222/index.html">Senior Engineer in search of work. How I passed 20 interviews with HR and what I think about it</a></li>
<li><a href="../430224/index.html">Schizotypal Disorder: An Inside Look</a></li>
<li><a href="../430226/index.html">From var b to interview</a></li>
<li><a href="../430228/index.html">X-shaped marks, as a way to identify the radar by analyzing open data from two scientific satellites SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>