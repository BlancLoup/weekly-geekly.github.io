<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Andengine: arbitrary landscape with texture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The people began to write a game for android and encountered in Andengine (who does not know, this is the most popular graph. 2D engine for android) w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Andengine: arbitrary landscape with texture</h1><div class="post__text post__text-html js-mediator-article">  The people began to write a game for android and encountered in Andengine (who does not know, this is the most popular graph. 2D engine for android) with this task: there is a set of interconnected lines that represent the landscape (how to generate, you can read here - <a href="http://gameprogrammer.com/fractal.html">gameprogrammer.com/fractal.html</a> ).  It looked like this: <br><br><img src="http://okmarket.talennsy.org/1.jpg" alt="image"><br><br>  But we do not need a ‚Äúbridge‚Äù, we need a surface, and even with a texture, in general so that it would be like this ... <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="http://okmarket.talennsy.org/2.jpg" alt="image"><br><br>  They began to dig AndEngine, it turned out that it can work with textures only as with sprites consisting of two triangles.  We can not arrange it in any way, because we do not know in advance the size of the landscape, and therefore the proportions of UV coordinates of 1: 1 are not chanted.  And in principle, here we are not a sprite, but the surface is a non-convex polyhedron.  Therefore, we have to write our bike, because  googling did not give normal results for the main andengine branch.  It's good that he has adequate class interfaces and everything is logical, you just have to figure it out.  We need our own class with a vertex buffer for triangles and their corresponding UV coordinates.  I must say at once that I will not go into an explanation of why a number of functions are not overloaded and why some things are being done in a specific way.  In places, andengine is a whole tangled forest in architectural terms and I just left things in the position in which it worked, because going through the entire engine of the engine will take 10 such articles and a half year life. <br>  Go‚Ä¶ <br><br>  First, we agree that you already have a list in which all the lines that make up the surface lie.  The same ‚Äúbridge‚Äù shown on the first screen. <br><br>  We begin to describe the class that will represent our surface: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroundShape</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{</code> </pre> <br>  For convenience, let's create an object for each vertex that stores its two-dimensional coordinates in space and UV. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u, v; }; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MorphVertexBuffer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexBuffer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MorphVertexBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,  . super(capacity, GL11.GL_STATIC_DRAW, true); } //        . public void update(Vertex[] vertexes) { int j = 0; final float[] bufferData = new float[vertexes.length*2]; for (int i = 0; i &lt; vertexes.length; ++i) { bufferData[j++] = vertexes[i].x; bufferData[j++] = vertexes[i].y; } final FastFloatBuffer buffer = this.getFloatBuffer(); buffer.position(0); buffer.put(bufferData); buffer.position(0);//,       :) super.setHardwareBufferNeedsUpdate(); } }</span></span></code> </pre> <br>  The code above describes an internal class, which is a buffer with vertices that can be fed to the engine.  We inherit from VertexBuffer to remain in the standard architecture and describe the update () method that fills the vertex buffer. <br>  The next step is to create a type that describes a buffer with UV coordinate data and a texture mapping method. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MorphTexture</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BufferObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//ITexture  ,    . final ITexture mTexture; public MorphTexture(ITexture tex, int pCapacity) { super(pCapacity, GL11.GL_STATIC_DRAW, true); mTexture = tex; } public void ApplyUV(Vertex [] vertexes) { final float[] bufferData = new float[vertexes.length*2]; for (int i = 0, j = 0; i &lt; vertexes.length; ++i) { bufferData[j++] = vertexes[i].u; bufferData[j++] = vertexes[i].v; } final FastFloatBuffer buffer = this.getFloatBuffer(); buffer.position(0); buffer.put(bufferData); buffer.position(0);//,       :) super.setHardwareBufferNeedsUpdate(); }</span></span></code> </pre> <br>  Here we have again formed a buffer, which we can later feed to the engine. <br>  The following describes a function that ‚Äúapplies‚Äù a texture to an object and sets the pointer of the vertex buffer of the UV coordinates to the one that we formed in ApplyUV () <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GL10 pGL)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mTexture.bind(pGL);<span class="hljs-comment"><span class="hljs-comment">//   ,    glBindTexture() if(GLHelper.EXTENSIONS_VERTEXBUFFEROBJECTS) { final GL11 gl11 = (GL11)pGL; selectOnHardware(gl11); GLHelper.texCoordZeroPointer(gl11); } else { GLHelper.texCoordPointer(pGL, getFloatBuffer()); } } }</span></span></code> </pre> <br>  Next, we enter the vertex buffer objects and UV coordinates described above. <br><pre> <code class="java hljs"> MorphVertexBuffer m_Buffer; MorphTexture m_TextureRegion; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexesLimit; <span class="hljs-comment"><span class="hljs-comment">//    . protected BitmapTextureAtlas m_Texture;//,    </span></span></code> </pre> <br>  I remind you that the classes described above are the internal GroundShape classes and therefore we continue further with its description from the constructor, which itself is trivial and we are only interested in the fact that the texture to be applied to it is transferred to it. <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroundShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BitmapTextureAtlas texture)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); m_Texture = texture; }</code> </pre> <br>  Next, we describe the initialization function, which must be called in the child to initialize the vertex buffers and UV coordinates. <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vertex[] vertexes = buildVertexBuffer();<span class="hljs-comment"><span class="hljs-comment">//    . if (vertexes == null) return; //  . vertexesLimit = vertexes.length; m_Buffer = new MorphVertexBuffer(vertexesLimit*2); m_Buffer.update(vertexes); m_TextureRegion = new MorphTexture(m_Texture, vertexesLimit*2); m_TextureRegion.ApplyUV(vertexes); }</span></span></code> </pre> <br>  Because  GroundShape is abstract; in our descendants we will have to overload the buildVertexBuffer function, in which we need to compile a list of vertices (with UV coordinates) and return them.  Here she is <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> Vertex[] buildVertexBuffer();</code> </pre> <br>  The next step is to overload a pair of GroundShape methods to tell AndEngine what and how to draw on our surface. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GL10 pGL, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Camera pCamera)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  m_TextureRegion.onApply(pGL); // super.doDraw(pGL, pCamera); } @Override protected void onInitDraw(final GL10 pGL) { //           UV . //GLHelper - . super.onInitDraw(pGL); GLHelper.enableTextures(pGL); GLHelper.enableTexCoordArray(pGL); } @Override protected void drawVertices(GL10 pGL, Camera arg1) { //   . pGL.glDrawArrays(GL10.GL_TRIANGLES, 0, vertexesLimit); }</span></span></code> </pre> <br>  If the vertices of the UV coordinates that we need to use are specified in doRaw, calling onApply, then to indicate the vertices of the triangles themselves, we do not need to call the functions, but simply reload getVertexBuffer and return the vertex buffer. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> VertexBuffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertexBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Buffer; }</code> </pre> <br>  The functions that are simply overloaded by default and have no meaning for us are described below, but they are an obligatory part in the inheritance process. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collidesWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IShape arg0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBaseHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBaseWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCulled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Camera arg0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdateVertexBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br>  Ok, we have sketched a class that dictates AndEngine how to draw ANY "model" consisting of triangles and having a texture.  Although this is a 2D engine, it still works through OpenGL, just sprites are drawn on two triangles. <br>  By the way, please note that under the android in OGL, there is no <b>GL_POLYGONS</b> , only <b>GL_TRIANGLES</b> .  The fastest of which is <b>GL_TRIANGLE_STRIP</b> , read about them here - <a href="http://en.wikipedia.org/wiki/Triangle_strip">en.wikipedia.org/wiki/Triangle_strip</a> .  However, they require a certain order and problems, which I don‚Äôt want to do, so we will use <b>GL_TRIANGLES</b> (considering that with later tests, the performance gain was minimal).  And so our surface, if you look at it ‚Äúthrough‚Äù triangles, should look like this, compared to the beginning: <br><img src="http://okmarket.talennsy.org/1.jpg" alt="image"><img src="http://okmarket.talennsy.org/3.jpg" alt="image"><br>  So now we need to generate it based on the list of lines that will be transmitted to us.  Create an object for this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroundSelf</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroundShape</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroundSelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Section&gt; sec, BitmapTextureAtlas texture)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(texture); sections = sec;<span class="hljs-comment"><span class="hljs-comment">//    ,    . Init();//    GroundShape' }</span></span></code> </pre> <br>  And GroundShape :: Init (), as we remember, will call buildVertexBuffer (), which each heir must overload.  In this function we need to build all the vertices of each triangle and set the UV coordinates.  It is worth considering that the texture is square, and the earth is generally a non-convex polyhedron, and if we stupidly stretch the texture in 1: 1 coordinate all triangles, then we will not even analyze the textures as images.  We need to be able to set the factors, and, since  the length is greater than the height, the U coordinates must be greater by the coefficient. <br>  I highly recommend that when you work with textures, take as a picture - a compass of some kind so that you can correctly determine the orientation of the texture coordinates. <br>  In fact, in the buildVertexBuffer function, you define all the triangles of your object and its UV coordinates. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Vertex[] buildVertexBuffer() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexesCount = <span class="hljs-number"><span class="hljs-number">0</span></span>, i, j, k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hellY = <span class="hljs-number"><span class="hljs-number">800.0f</span></span>;<span class="hljs-comment"><span class="hljs-comment">//   "". final float maxU = 4.0f;//     U final float maxV = 2.0f;//  V float stepU; //       // -   ,    . //    V. float startV = sections.get(0).lines.get(0).line.getY1(); float valueV = hellY - sections.get(0).lines.get(0).line.getY1(); for (i = 0; i &lt; sections.size(); ++i) vertexesCount += sections.get(i).lines.size()*6; Vertex[] res = new Vertex[vertexesCount]; Section tmpSection; Line tmpLine; for (i = 0; i &lt; sections.size(); ++i) { tmpSection = sections.get(i); //         //.     . //  6 . for (j = 0; j &lt; tmpSection.lines.size(); ++j) { tmpLine = tmpSection.lines.get(j).line; stepU = maxU/(float)tmpSection.lines.size(); res[k] = new Vertex(); res[k].x = tmpLine.getX1(); res[k].y = tmpLine.getY1(); res[k].u = (float)j*stepU; res[k++].v = maxV + ((startV - tmpLine.getY1())/valueV)*maxV; res[k] = new Vertex(); res[k].x = tmpLine.getX1(); res[k].y = hellY; res[k].u = (float)j*stepU; res[k++].v = 0.0f; res[k] = new Vertex(); res[k].x = tmpLine.getX2(); res[k].y = tmpLine.getY2(); res[k].u = (float)(j + 1)*stepU; res[k++].v = maxV + ((startV - tmpLine.getY2())/valueV)*maxV; res[k] = new Vertex(); res[k].x = tmpLine.getX2(); res[k].y = tmpLine.getY2(); res[k].u = (float)(j + 1)*stepU; res[k++].v = maxV + ((startV - tmpLine.getY2())/valueV)*maxV; res[k] = new Vertex(); res[k].x = tmpLine.getX1(); res[k].y = hellY; res[k].u = (float)j*stepU; res[k++].v = 0.0f; res[k] = new Vertex(); res[k].x = tmpLine.getX2(); res[k].y = hellY; res[k].u = (float)(j + 1)*stepU; res[k++].v = 0.0f; } } //  ,  . return res; } List&lt;Section&gt; sections; }</span></span></code> </pre> <br>  Surface created.  Now we need to attach it to the world.  This is done as usual in AndEngine: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  grndSelf = new GroundSelf(sections, EvoGlobal.getTextureCache().get(EvoTextureCache.tex_ground).texture); //  AndEngine EvoGlobal.getWorld().getScene().attachChild(grndSelf);</span></span></code> </pre> <br>  Result: <br><img src="http://okmarket.talennsy.org/4.png" alt="image"><br><br>  I hope the one who now came here through Google in search of a solution is satisfied. </div><p>Source: <a href="https://habr.com/ru/post/150042/">https://habr.com/ru/post/150042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150034/index.html">We implement RESTful Web Service on java</a></li>
<li><a href="../150037/index.html">FBI for the first time arrested websites with pirated applications for Android</a></li>
<li><a href="../150038/index.html">Smile to login!</a></li>
<li><a href="../150039/index.html">AMatch, part 2. Error codes, own errors, new callback format</a></li>
<li><a href="../150041/index.html">Class Relationships - From UML To Code</a></li>
<li><a href="../150043/index.html">Mathematical expressions in .NET (parsing, differentiation, simplification, fractions, compilation)</a></li>
<li><a href="../150044/index.html">Organization and optimization of user information space</a></li>
<li><a href="../150045/index.html">10G aggregators for providers and data centers</a></li>
<li><a href="../150047/index.html">Working with ssh in Python</a></li>
<li><a href="../150050/index.html">Sending SMS from under Shell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>