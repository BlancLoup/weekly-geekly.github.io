<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with false positives in PVS-Studio and CppCat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I decided to re-check the physics engine of Newton Game Dynamics. Project code quality. Therefore, there were almost no warnings that detect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with false positives in PVS-Studio and CppCat</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d39/609/c8f/d39609c8f149f61a251d44e349ea3373.png" alt="Handling False Positives" align="left"><br>  Recently, I decided to re-check the physics engine of Newton Game Dynamics.  Project code quality.  Therefore, there were almost no warnings that detected errors.  But there were several dozen false positives.  It seems to write an article about.  But I got the idea that you can write about how to work with false positives, and how to make them out.  The Newton Game Dynamics project seemed to me a suitable candidate. <br><a name="habracut"></a><br><h2>  Project Verification </h2><br>  The <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer generates the following number of warnings: <br><table><tbody><tr><td><ul><li>  48 first level; </li><li>  79 second level; </li><li>  261 third level (off by default). </li></ul></td></tr></tbody></table>  These are general purpose warnings ( <a href="http://www.viva64.com/ru/general-analysis/">GA</a> ). <br><br>  Total <b>127</b> warnings recommended for viewing.  Exactly the same number of messages is issued by the <a href="http://www.cppcat.com/">CppCat</a> analyzer.  Further in the article, no distinction is made between PVS-Studio and CppCat analyzers.  In general, they provide the same mechanisms for suppressing false positives.  There are a little more of them in PVS-Studio, but this does not change the overall picture. <br><br>  Note.  What is the difference between the functionality of PVS-Studio and CppCat <a href="http://www.viva64.com/ru/b/0258/">here</a> ? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It took me a little more than three hours to write out all the necessary examples for the article and get rid of all the warnings.  I think if I did not write out the examples, I would have managed in an hour.  So the difficulty of dealing with false positives is exaggerated.  Yes, they interfere and distract.  Yes, if the project is large, then there are many false warnings.  Nevertheless, it is not difficult to get rid of them. <br><br>  Total.  CppCat issues 0 warnings.  PVS-Studio also produces nothing.  You can, of course, enable level 3 or 64-bit diagnostics, but this is not so interesting.  Getting started is very good at getting rid of recommended warnings.  This is a very big step towards improving the quality of the code.  This is the place to start.  If you immediately include all warnings, you do not have enough strength to immediately reach the end.  This is, by the way, the main mistake of newbies.  ‚ÄúMore‚Äù does not mean ‚Äúbetter.‚Äù <br><br><h2>  View Report </h2><br>  PVS-Studio and CppCat analyzers do not combine diagnostic messages into groups and do not sort them.  With regular use it is not necessary.  If the analyzer detects 2-3 errors in the new code, there is nothing to merge and sort.  Only an extra complication of the interface. <br><br>  When you first start working with the tool, you can sort the messages by diagnostic number.  This is done by clicking the mouse on the header of the diagnostic number column.  We didn‚Äôt do this sorting automatically.  Warnings are displayed in the order of file analysis.  This allows, without waiting for the analysis to stop, to start watching messages.  If they are sorted, then while the check is in progress, the messages in the table will ‚Äújump‚Äù and it will be impossible to work with them. <br><br>  So, in the initial stages, sorting by alert type (diagnostics number) will be useful.  I'll do it.  This will allow me to quickly identify the same type of false positives and eliminate them.  This can significantly simplify the work and reduce the initial setup time. <br><br><h2>  Work with warnings </h2><br>  If any of the ways to suppress false positives does not seem clear enough, then we suggest that you familiarize yourself with the relevant section of the documentation: <ul><li>  For PVS-Studio - <a href="http://www.viva64.com/ru/d/0021/">Suppression of false warnings</a> . </li><li>  For CppCat - the documentation comes as part of the distribution. </li></ul><br>  <b>Warning N1, N2</b> <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgWorldDynamicUpdate::CalculateJointsVelocParallelKernel (....) { .... <span class="hljs-function"><span class="hljs-function">dgVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">velocStep2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(velocStep.DotProduct4(velocStep))</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">dgVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">omegaStep2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(omegaStep.DotProduct4(omegaStep))</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">dgVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((velocStep2 &gt; speedFreeze2) | (omegaStep2 &gt; omegaStep2))</span></span></span></span>; .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0090/">V501</a> operator: omegaStep2&gt; omegaStep2 dgworlddynamicsparallelsolver.cpp 546 <br><br>  The expression "omegaStep2&gt; omegaStep2" looks suspicious.  I find it difficult to judge whether there is a mistake or not.  Since this comparison is found in another file, then, probably, this is still not an error, but also conceived. <br><br>  Let there be no mistake.  I tagged these two places with a comment: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">dgVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((velocStep2 &gt; speedFreeze2) | (omegaStep2 &gt; omegaStep2))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//-V501</span></span></code> </pre> <br>  Now, in this place the warning V501 will not be issued. <br><br>  <b>Warning N3</b> <br><pre> <code class="cpp hljs">dgInt32 dgWorld::CalculatePolySoupToHullContactsDescrete(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... dgAssert (dgAbsf(polygon.m_normal % polygon.m_normal - dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)) &lt; dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0e-4</span></span>f)); .... }</code> </pre> <br>  Warning: V501 operator: polygon.m_normal% polygon.m_normal dgnarrowphasecollision.cpp 1921 <br><br>  The analyzer is both right and wrong.  On the one hand, the expression ‚Äúpolygon.m_normal% polygon.m_normal‚Äù is really very suspicious.  But the analyzer does not realize that this is a test for checking the operator '%' implemented in the class.  In fact, the code is correct.  Let's help the analyzer with a comment: <br><pre> <code class="cpp hljs">dgAssert (dgAbsf(polygon.m_normal % polygon.m_normal - <span class="hljs-comment"><span class="hljs-comment">//-V501 dgFloat32 (1.0f)) &lt; dgFloat32 (1.0e-4f));</span></span></code> </pre> <br>  <b>Warning n4</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopupateTextureCacheNode</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dScene* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scene)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(info-&gt;IsType(dSceneCacheInfo::GetRttiType()) || info-&gt;IsType(dSceneCacheInfo::GetRttiType()))) { .... }</code> </pre> <br>  Warning: V501 There are identical sub-expressions 'info-&gt; IsType (dSceneCacheInfo :: GetRttiType ())' to the left |  operator.  dscene.cpp 125 <br><br>  The same is checked twice.  We assume that the second check is superfluous.  Therefore, I corrected the code as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(info-&gt;IsType(dSceneCacheInfo::GetRttiType()))) {</code> </pre> <br>  <b>Warning n5</b> <br><pre> <code class="cpp hljs">dFloat dScene::RayCast (....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... dFloat den = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / ((globalP1 - globalP0) % (globalP1 - globalP0)); <span class="hljs-comment"><span class="hljs-comment">//-V501 .... }</span></span></code> </pre> <br>  Warning: V501 There are identical sub-expressions (globalP1 - globalP0) "%" operator.  dscene.cpp 1280 <br><br>  The variables globalP0 and globalP1 are instances of the class 'dVector'.  Therefore, the code makes sense.  The analyzer worries in vain.  Mark the code: <br><pre> <code class="cpp hljs">dFloat den = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / ((globalP1 - globalP0) % (globalP1 - globalP0)); <span class="hljs-comment"><span class="hljs-comment">//-V501</span></span></code> </pre> <br>  Although the analyzer is wrong, this code cannot be called beautiful.  I think you can get special features for such cases or something else. <br><br>  <b>Warning N6 - N15</b> <br><pre> <code class="cpp hljs">dgInt32 dgCollisionCompound::CalculateContactsToCompound ( ...., dgCollisionParamProxy&amp; proxy) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-function"><span class="hljs-function">dgCollisionInstance </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">childInstance</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*subShape, subShape-&gt;GetChildShape())</span></span></span></span>; .... proxy.m_referenceCollision = &amp;childInstance; .... m_world-&gt;CalculateConvexToConvexContacts(proxy); .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0095/">V506</a> Pointer to local variable "childInstance" is stored outside of scope.  Such a pointer will become invalid.  dgcollisioncompound.cpp 1815 <br><br>  The function comes with a link to an object of the type 'dgCollisionParamProxy'.  A pointer to a local variable is written to this object.  The analyzer warns that it is potentially dangerous.  Upon exiting the function, this pointer will not be used, since the local variable will be destroyed. <br><br>  In this case, there is no error.  The pointer is used only when the variable exists. <br><br>  Comment suppress such warnings do not want.  The fact is that there are 9 more similar warnings. <br><br>  We proceed in another way.  In all lines where a false warning is issued, a variable with the name 'proxy' appears.  We can write one single comment that suppresses all these warnings: <br><br>  // - V: proxy: 506 <br><br>  It needs to be entered into some file that is included in all other files.  In our case, the optimal for this is the file "dgPhysicsStdafx.h". <br><br>  Now for those lines where the word 'proxy' occurs, the warning V506 will not be issued.  Initially, this mechanism was created to suppress warnings in macros.  But, in fact, all the same, the word means a macro or something else (a variable, a function, a class name, etc.).  The principle is simple.  If the string contains the specified substring, the corresponding warning is not displayed. <br><br>  <b>Warning n16</b> <br><br>  Long example.  You can skip it.  Nothing interesting to lose. <br><br>  There is a vector class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dgVector</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { __m128 m_type; __m128i m_typeInt; dgFloat32 m_f[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> dgFloat32 m_x; dgFloat32 m_y; dgFloat32 m_z; dgFloat32 m_w; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> dgInt32 m_ix; dgInt32 m_iy; dgInt32 m_iz; dgInt32 m_iw; }; }; .... };</code> </pre> <br>  And there is such a code where vector members are populated with values ‚Äã‚Äãusing the memcpy () function: <br><pre> <code class="cpp hljs">DG_INLINE dgMatrix::dgMatrix (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgFloat32* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (&amp;m_front.m_x, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (dgMatrix)) ; }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0101/">V512</a> A call of the memcpy function will lead to the overflow of the buffer.  dgmatrix.h 118 <br><br>  The analyzer does not like that more bytes are copied into variables of the 'dgFloat32' type than it takes.  Not very beautiful, but working and widely used technique.  In fact, the variable m_x, m_y, m_z and so on will be filled. <br><br>  In the beginning, I was inattentive and corrected the code as follows: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(m_front.m_f, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dgMatrix));</code> </pre> <br>  I thought that only one vector was copied.  And the size of the array 'm_f' just coincides with the size of the vector. <br><br>  But at the next launch, the analyzer pulled me back.  In fact, not one vector is copied, but 4 vectors.  Exactly 4 vectors contains the class 'dgMatrix': <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dgMatrix</span></span></span><span class="hljs-class"> {</span></span> .... dgVector m_front; dgVector m_up; dgVector m_right; dgVector m_posit; .... }</code> </pre> <br>  How to fix the code so that it is beautiful and short, I do not know.  So I decided to leave everything as it was and add a comment: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (&amp;m_front.m_x, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (dgMatrix)) ; <span class="hljs-comment"><span class="hljs-comment">//-V512</span></span></code> </pre> <br>  <b>Warning N17, N18</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgWorldDynamicUpdate::UpdateDynamics(dgFloat32 timestep) { dgWorld* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> world = (dgWorld*) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; dgUnsigned32 updateTime = world-&gt;m_getPerformanceCount(); m_bodies = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_joints = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_islands = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_markLru = <span class="hljs-number"><span class="hljs-number">0</span></span>; world-&gt;m_dynamicsLru = world-&gt;m_dynamicsLru + DG_BODY_LRU_STEP; m_markLru = world-&gt;m_dynamicsLru; .... }</code> </pre> <br>  Caution: <a href="http://www.viva64.com/ru/d/0108/">V519</a> The 'm_markLru' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 91, 94. dgworlddynamicupdate.cpp 94 <br><br>  In the variable 'm_markLru' at the beginning 0 is written, and then 'world-&gt; m_dynamicsLru'.  There is no error here.  To get rid of the warning, I removed the initialization of the variable to zero. <br><br>  Similarly, I entered another place.  Corresponding warning: <br><br>  V519 The 'm_posit' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 1310, 1313. customvehiclecontrollermanager.cpp 1313 <br><br>  <b>Warning N19, N20</b> <br><pre> <code class="cpp hljs">dgFloat32 dgCollisionConvexPolygon::GetBoxMinRadius () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_faceClipSize; } dgFloat32 dgCollisionConvexPolygon::GetBoxMaxRadius () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_faceClipSize; }</code> </pre> <br>  Warning: It is the odd that the body of the GetBoxMaxRadius function is fully equivalent to the body of the GetBoxMinRadius function.  dgcollisionconvexpolygon.cpp 88 <br><br>  Two functions, containing in their names 'Min' and 'Max', are arranged in the same way.  For the analyzer it is suspicious.  Actually, there is no error.  To eliminate false positives, I implemented one function through another: <br><pre> <code class="cpp hljs">dgFloat32 dgCollisionConvexPolygon::GetBoxMaxRadius () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetBoxMinRadius(); }</code> </pre> <br>  I did the same with the GetBoxMaxRadius / GetBoxMaxRadius functions implemented in the 'dgCollisionScene' class. <br><br>  <b>Warning n21</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">dgInt32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFilterFace</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dgUnsigned32 count, dgInt32* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pool)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (dgUnsigned32 i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i ++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (dgUnsigned32 j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; count; j ++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pool[j] == pool[i]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = j; i &lt; count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i ++) { pool[i] = pool[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } count --; i = count; reduction = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0124/">V535</a> The variable 'i' is being used for this loop.  Check lines: 105, 108. dgpolygonsoupbuilder.cpp 108 <br><br>  There are two cycles.  One uses the variable 'i' as the counter, the other 'j'.  Inside these cycles, another cycle is sometimes started.  As a counter, he again uses the variable 'i'.  The analyzer does not like it, although there is no error here. <br><br>  If an inner loop is executed, then the outer loop stops: <ul><li>  a loop organized with the variable 'j' is stopped due to the operator 'break'; </li><li>  the loop organized with the variable 'i' is stopped due to the assignment ‚Äúi = count‚Äù. </li></ul>  The analyzer could not understand such a tangle.  This is an example of working code that still smacks. <br><br>  To eliminate the false positive, I used the comment: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = j; i &lt; count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i ++) { <span class="hljs-comment"><span class="hljs-comment">//-V535</span></span></code> </pre> <br>  <b>Warning N22 - N25</b> <br><pre> <code class="cpp hljs">DG_INLINE dgMatrix::dgMatrix (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgVector&amp; front) { .... m_right = m_right.Scale3 (dgRsqrt (m_right % m_right)); m_up = m_right * m_front; .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0126/">V537</a> Consider reviewing the correctness of 'm_right' item's usage.  dgmatrix.h 143 <br><br>  The V537 warning is displayed when variables are suspiciously mixed with names that have ‚Äúright‚Äù, ‚Äúleft‚Äù, ‚Äúfront‚Äù, and so on.  For this project, this diagnosis was unsuccessful.  The analyzer issued 4 warnings for a completely harmless code. <br><br>  In this case, in PVS-Studio, you can completely disable the V537 diagnostics in the settings. <br><br>  CppCat cannot disable individual diagnostics.  We use an alternative approach.  In all lines where there were false warnings, the word "right" is present.  I added a comment to the ‚ÄúdgStdafx.h‚Äù file: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-V:right:537</span></span></code> </pre> <br>  <b>Warning n26</b> <br><br>  Pay attention to the comment. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_delay_np</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct timespec *interval)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* * Most compilers will issue a warning 'comparison always 0' * because the variable type is unsigned, * but we need to keep this * for some reason I can't recall now. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; (wait_time = secs_in_millisecs + millisecs)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; } .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0137/">V547</a> Expression is always false.  Unsigned type value is never &lt;0. pthread_delay_np.c 119 <br><br>  The comment tells us that this is not a mistake, but it was conceived.  If so, we have no choice but to suppress the warning using the comment: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; (wait_time = secs_in_millisecs + millisecs)) <span class="hljs-comment"><span class="hljs-comment">//-V547</span></span></code> </pre> <br>  <b>Warning n27</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dgUnsigned64; dgUnsigned64 m_mantissa[DG_GOOGOL_SIZE]; dgGoogol::dgGoogol(dgFloat64 value) :m_sign(<span class="hljs-number"><span class="hljs-number">0</span></span>) ,m_exponent(<span class="hljs-number"><span class="hljs-number">0</span></span>) { .... m_mantissa[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (dgInt64 (dgFloat64 ( dgUnsigned64(<span class="hljs-number"><span class="hljs-number">1</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">62</span></span>) * mantissa)); <span class="hljs-comment"><span class="hljs-comment">// it looks like GCC have problems with this dgAssert (m_mantissa[0] &gt;= 0); .... }</span></span></code> </pre> <br>  Warning: V547 Expression 'm_mantissa [0]&gt; = 0' is always true.  Unsigned type value is always&gt; = 0. dggoogol.cpp 55 <br><br>  The analyzer shares the opinion of GCC that there is something wrong with this code (see the comment in the code). <br><br>  Checking ‚ÄúdgAssert (m_mantissa [0]&gt; = 0)‚Äù does not make sense.  An unsigned variable is always greater than or equal to zero.  The existing dgAssert code doesn‚Äôt actually check anything. <br><br>  Programmers are lazy.  Instead of sorting out and correcting the error, they write a comment. <br><br>  I corrected the code so that 'dgAssert' performs the necessary checks.  To do this, it was necessary to create a temporary signed variable: <br><pre> <code class="cpp hljs">dgInt64 integerMantissa = (dgInt64(dgFloat64( dgUnsigned64(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">62</span></span>) * mantissa)); dgAssert(integerMantissa &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); m_mantissa[<span class="hljs-number"><span class="hljs-number">0</span></span>] = integerMantissa;</code> </pre> <br>  <b>Warning N28 - N31</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgRedBackNode::RemoveFixup (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ptr-&gt;SetColor(RED) ; ptr-&gt;RotateLeft (head); tmp = ptr-&gt;m_right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr || !tmp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0153/">V560</a> A part of conditional expression is always false <a href="http://www.viva64.com/ru/d/0153/">:!</a> Ptr.  dgtree.cpp 215 <br><br>  The expression "! Ptr" is always false.  The fact is that the 'ptr' pointer has already been checked for equality to zero.  If the pointer is zero, the function exited. <br><br>  The second check looks even more stupid due to the fact that the pointer in front of it is dereferenced: "tmp = ptr-&gt; m_right;". <br><br>  I eliminated the false positive by removing the second meaningless check.  Now the code looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... tmp = ptr-&gt;m_right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tmp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ....</code> </pre> <br>  Similarly corrected 3 more code fragments. <br><br>  By the way, such code could additionally lead to V595 warnings.  Specially check it out, I was too lazy.  If at the end of the article we‚Äôve missed a couple of warnings, the reason is just that. <br><br>  <b>Warning N32, N33</b> <br><pre> <code class="cpp hljs">DG_INLINE <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dgBody::IsCollidable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgBroadPhase::AddPair (dgBody* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> body0, dgBody* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> body1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgVector&amp; timestep2, dgInt32 threadID) { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> kinematicBodyEquilibrium = (((body0-&gt;IsRTTIType(dgBody::m_kinematicBodyRTTI) ? <span class="hljs-literal"><span class="hljs-literal">true</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>) &amp; body0-&gt;IsCollidable()) | ((body1-&gt;IsRTTIType(dgBody::m_kinematicBodyRTTI) ? <span class="hljs-literal"><span class="hljs-literal">true</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>) &amp; body1-&gt;IsCollidable())) ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0159/">V564</a> The '&amp;' operator is applied to bool type value.  You've probably forgotten to include the operator.  dgbroadphase.cpp 921 <br><br>  The code with the "smell".  It is not clear why it was necessary to write such a complex and incomprehensible check.  I rewrote it.  The code has become a bit shorter and easier to read.  Plus lost analyzer warning. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> kinematicBodyEquilibrium = !((body0-&gt;IsRTTIType(dgBody::m_kinematicBodyRTTI) &amp;&amp; body0-&gt;IsCollidable()) || (body1-&gt;IsRTTIType(dgBody::m_kinematicBodyRTTI) &amp;&amp; body1-&gt;IsCollidable()));</code> </pre> <br>  Another V564 warning was issued, where I also simplified the code: <br><br>  V564 The '&amp;' operator is applied to bool type value.  You've probably forgotten to include the operator.  dgbroadphase.cpp 922 <br><br>  <b>Warning N34 - N37</b> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dgAIWorld</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> dgAIAgentGraph { .... }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewtonAIWorld</span></span></span><span class="hljs-class">{</span></span>} NewtonAIWorld; <span class="hljs-function"><span class="hljs-function">NewtonAIWorld* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewtonAICreate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TRACE_FUNCTION(__FUNCTION__); dgMemoryAllocator* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allocator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dgMemoryAllocator(); NewtonAIWorld* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ai = (NewtonAIWorld*) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (allocator) dgAIWorld (allocator); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ai; }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0170/">This</a> is <a href="http://www.viva64.com/ru/d/0170/">what</a> the object was created when it was casted to another type.  newtonai.cpp 40 <br><br>  Strange way to store objects.  Create an object of class 'dgAIWorld'.  Explicitly converting it to the 'NewtonAIWorld' type.  I did not understand why this was done.  Apparently, this is for something needed.  Just suppressed the warning with comments in this and another 3 functions. <br><br>  <b>Warning n38</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgCollisionCompound::EndAddRemove () { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;m_type == m_node) { <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.Append(node); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;m_type == m_node) { <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.Append(node-&gt;m_right); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.Append(node-&gt;m_left); } .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0183/">V581</a> The conditional expressions of the 'if' are located alongside each other are identical.  Check lines: 952, 956. dgcollisioncompound.cpp 956 <br><br>  The analyzer does not like that the same condition is checked next to it.  Perhaps there is a typo.  For example, suddenly the code should be like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;m_type == m_node) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;m_type == m_FOO) { .... }</code> </pre> <br>  In the detected code, everything is correct.  To get rid of the false positives, it is best to fix the code.  As it seems to me, I will not change the logic of the program, making only one check: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;m_type == m_node) { <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.Append(node); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.Append(node-&gt;m_right); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.Append(node-&gt;m_left); }</code> </pre> <br>  <b>Warning n39</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dSceneGraph::AddEdge (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!parentLink &amp;&amp; !childLink)) { .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0196/">V592</a> The expression was enclosed by parentheses twice: '((! ParentLink &amp;&amp;! ChildLink))'.  One pair of parentheses is unnecessary or misprint is present.  dscenegraph.cpp 209 <br><br>  Nothing wrong.  Just extra brackets.  Removed them: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parentLink &amp;&amp; !childLink) {</code> </pre> <br>  <b>Warning N40 - N44</b> <br><pre> <code class="cpp hljs">dgVector dgCollisionCylinder::SupportVertex (....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { dgAssert (dgAbsf ((dir % dir - dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0f</span></span>))) &lt; dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0e-3</span></span>f)); .... }</code> </pre> <br>  Warning: V592 The expression was enclosed by parentheses twice: '((dir% dir - dgFloat32 (1.0f)))'.  One pair of parentheses is unnecessary or misprint is present.  dgcollisioncylinder.cpp 202 <br><br>  Nothing wrong.  Just extra brackets.  Removed them so as not to embarrass the analyzer: <br><pre> <code class="cpp hljs">dgAssert (dgAbsf (dir % dir - dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)) &lt; dgFloat32 (<span class="hljs-number"><span class="hljs-number">1.0e-3</span></span>f));</code> </pre> <br>  This line is replicated using Copy-Paste in 4 more code fragments.  There I also removed an extra pair of brackets. <br><br>  <b>Warning N45 - N65</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptw32_throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD exception)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">ptw32_thread_t</span></span> * sp = (<span class="hljs-keyword"><span class="hljs-keyword">ptw32_thread_t</span></span> *) pthread_getspecific (ptw32_selfThreadKey); sp-&gt;state = PThreadStateExiting; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception != PTW32_EPS_CANCEL &amp;&amp; exception != PTW32_EPS_EXIT) { <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == sp || sp-&gt;implicit) .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0205/">V595</a>  Check lines: 77, 85. ptw32_throw.c 77 <br><br>  Diagnostics V595 works as follows.  The analyzer considers the code to be suspicious if the pointer is first used and then checked for equality to zero.  There are certain nuances and exceptions, but the general principle of analysis is just that. <br><br>  Here is just such a case.  At the beginning, the variable 'sp' is dereferenced in the expression "sp-&gt; state".  It is then checked for NULL equality. <br><br>  The analyzer has detected 20 more similar code fragments.  In each case, you should do differently.  Somewhere I moved the check to dereference.  Somewhere just deleted it. <br><br>  <b><i>Note</i></b> <br><br>  Very often the cause of a false warning V595 is a macro similar to this: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FREE(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) free(p); }</span></span></code> </pre> <br>  Specifically, in this case, the analyzer must understand what the programmer had in mind and keep silent.  But in general, false positives may occur on this code: <br><pre> <code class="cpp hljs">p-&gt;foo(); FREE(p);</code> </pre> <br>  In such cases, I recommend getting rid of macros.  The above FREE () macro is completely meaningless and harmful. <br><br>  First, it makes no sense to check the pointer for equality to zero.  The free () function works correctly with null pointers.  The delete operator is the same.  Therefore, the FREE () macro is not needed.  Totally. <br><br>  Secondly, it is dangerous.  If we retrieve pointers from an array, this can lead to an error.  Example: FREE (ArrayOfPtr [i ++]);  - one pointer will be checked and the next one released. <br><br>  <b>Warning n66</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgCollidingPairCollector::Init () { dgWorld* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> world = (dgWorld*) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// need to expand teh buffer is needed world-&gt;m_pairMemoryBuffer[0]; m_count = 0; }</span></span></code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0222/">V607</a> Ownerless expression 'world-&gt; m_pairMemoryBuffer [0]'.  dgcontact.cpp 342 <br><br>  The comment tells us that the expression ‚Äúworld-&gt; m_pairMemoryBuffer [0]‚Äù makes sense.  The analyzer does not know about it and gives a false warning.  I eliminated it using code markup: <br><pre> <code class="cpp hljs">world-&gt;m_pairMemoryBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//-V607</span></span></code> </pre> <br>  A more beautiful solution is to add a special method that expands the buffer.  Then the code would look something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dgCollidingPairCollector::Init () { dgWorld* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> world = (dgWorld*) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; world-&gt;m_pairMemoryBuffer.ExpandBuffer(); m_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Now the comment is not needed.  The code speaks for itself.  The analyzer does not issue warnings.  Idyll. <br><br>  <b>Warning n67</b> <br><pre> <code class="cpp hljs">dgGoogol dgGoogol::Floor () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... dgUnsigned64 mask = (<span class="hljs-number"><span class="hljs-number">-1L</span></span>L) &lt;&lt; (<span class="hljs-number"><span class="hljs-number">64</span></span> - bits); .... }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0225/">V610</a> Undefined behavior.  Check the shift operator '&lt;&lt;.  The left operand '(- 1LL)' is negative.  dggoogol.cpp 249 <br><br>  You cannot move negative numbers to the left.  This leads to undefined behavior.  More: " <a href="http://www.viva64.com/ru/b/0142/">Without knowing the ford, do not climb into the water. Part three</a> ." <br><br>  I corrected the code as follows: <br><pre> <code class="cpp hljs">dgUnsigned64 mask = (~<span class="hljs-number"><span class="hljs-number">0L</span></span>LU) &lt;&lt; (<span class="hljs-number"><span class="hljs-number">64</span></span> - bits);</code> </pre> <br>  <b>Warning N68 - N79</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> dGeometryNodeSkinModifierInfo::RemoveUnusedVertices( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexMap) { .... dVector* vertexWeights = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dVector[m_vertexCount]; dBoneWeightIndex* boneWeightIndex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dBoneWeightIndex[m_vertexCount]; .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> boneWeightIndex; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> vertexWeights; }</code> </pre> <br>  Warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0226/">V611</a> The memory was allocated using the 'new T []' operator.  Consider inspecting this code.  It's probably better to use 'delete [] boneWeightIndex;'.  dgeometrynodeskinmodifierinfo.cpp 97 </li><li>  V611 The memory was allocated using the 'new T []' operator.  Consider inspecting this code.  It's probably better to use 'delete [] vertexWeights;'.  dgeometrynodeskinmodifierinfo.cpp 98 </li></ul>  The square brackets of the 'delete' operators are forgotten.  These are errors that should be corrected.  The correct code is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] boneWeightIndex; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] vertexWeights;</code> </pre> <br>  The analyzer found 10 more such places, and everywhere I corrected the code. <br><br>  <b>Warning n80</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_MSC_VER) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Disable MSVC 'anachronism used' warning */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( disable : 4229 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> typedef void (* PTW32_CDECL ptw32_cleanup_callback_t)(void *); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_MSC_VER) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( default : 4229 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0290/">V665</a> Possibly, the usage of #pragma warning (default: X) 'is incorrect in this context.  The '#pragma warning (push / pop)' should be used instead.  Check lines: 733, 739. pthread.h 739 <br><br>  This is a bad way to suppress warnings.  Especially if it is library code.  What is the reason and how to do better, you can learn from the description of the diagnostic <a href="http://www.viva64.com/ru/d/0290/">V665</a> . <br><br>  I fixed the code using "warning (push)" and "warning (pop)": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_MSC_VER) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Disable MSVC 'anachronism used' warning */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( push ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( disable : 4229 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> typedef void (* PTW32_CDECL ptw32_cleanup_callback_t)(void *); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_MSC_VER) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">( pop ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  <b>Warning N81 - N99</b> <br><pre> <code class="cpp hljs">dgAABBPointTree4d* dgConvexHull4d::BuildTree (....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgBigVector&amp; p = points[i]; .... varian = varian + p.CompProduct4(p); .... }</code> </pre> <br>  Alert: <a href="http://www.viva64.com/ru/d/0312/">V678</a>  Consider comproduct4 function.  dgconvexhull4d.cpp 536 <br><br>  The analyzer does not like calls of the following functions: X.Foo (X).  First, it may be a typo.  Secondly, the class may not be ready for the fact that he will have to work with himself. <br><br>  In this case, the code is correct.  A false warning needs to be suppressed.  You can put a comment like: <br><br>  varian = varian + p. CompProduct4 (p);  // - V678 <br><br>  This is a bad idea.  The analyzer issued 18 more such warnings, and I don‚Äôt want to add so many comments to the code. <br><br>  Fortunately, all 19 warnings are related to CompProduct3 () or CompProduct4 function calls.  Therefore, you can write one comment that suppresses all V678 warnings in the lines containing the substring "CompProduct": <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-V:CompProduct:678</span></span></code> </pre> <br>  I posted this comment in the dgStdafx.h file. <br><br>  <b>Warning N100 - N119</b> <br><br>  The class 'dgBaseNode' contains pointers: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dgBaseNode</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> dgRef { .... dgBaseNode (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgBaseNode &amp;clone); .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... dgBaseNode* parent; dgBaseNode* child; dgBaseNode* sibling; };</code> </pre> <br>  Therefore, it implements a full-fledged copy constructor: <br><pre> <code class="cpp hljs">dgBaseNode::dgBaseNode (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgBaseNode &amp;clone) :dgRef (clone) { Clear (); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (dgBaseNode* obj = clone.child; obj; obj = obj-&gt;sibling) { dgBaseNode* newObj = (dgBaseNode *)obj-&gt;CreateClone (); newObj-&gt;Attach (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); newObj-&gt;Release(); } }</code> </pre> <br>  Warning: <a href="http://www.viva64.com/ru/d/0326/">V690</a> The 'dgBaseNode' class implements a copy constructor, but not the the '=' operator.  It is dangerous to use such a class.  dgnode.h 35 <br><br>  Here is broken the " <a href="http://www.viva64.com/go.php%3Furl%3D1406">Law of the Big Two</a> ".  There is a copy constructor, but there is no copy operator (operator =).  As a result, when assigning, the compiler will simply copy the values ‚Äã‚Äãof the pointers, which will lead to subtle errors.  Even if now the copy operator is not used, this code is potentially dangerous.  It is very easy to make a mistake. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The correct option is one here - implement operator =. </font><font style="vertical-align: inherit;">If this operator is not needed, then you can declare it in the private section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The analyzer found 18 more classes where they forgot to implement (or deny) the copy operator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is still one strange class, the meaning and purpose of which is not clear to me:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringPool</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[STRING_POOL_SIZE]; StringPool () { } StringPool (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringPool &amp;arg) { } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here I just suppressed the false positive with a comment: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringPool</span></span></span><span class="hljs-class"> //-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V690</span></span></span><span class="hljs-class"> {</span></span> .... };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C ++ 11, new keywords have appeared that simplify the prohibition of using copy constructors, assignment operators. Or they say that the copy constructor or the assignment statement created by the default compiler are correct. We are talking about = default and = delete. You can read more about them, for example, in the </font></font><a href="http://www.viva64.com/go.php%3Furl%3D1359"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ FAQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note 2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I often see that many programs implement a copy or assignment operator, although it is not needed. I mean the situation when the object can be perfectly copied by the compiler. A simple artificial example:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-function">Point &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ x = px; y = py; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no unnecessary copy operator. </font><font style="vertical-align: inherit;">The rule of the Big Two Law is violated, and the analyzer issues a warning. </font><font style="vertical-align: inherit;">In order not to write another unnecessary function (copy constructor), you need to delete operator =. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excellent short correct class:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warning N120 - N125</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are still 6 different warnings </font><b><font style="vertical-align: inherit;">left</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I did not cope with them. </font><font style="vertical-align: inherit;">The project code is completely unfamiliar to me. </font><font style="vertical-align: inherit;">I can not understand, I am dealing with an error or a false positive. </font><font style="vertical-align: inherit;">Plus, even if this is a mistake, I still don‚Äôt understand how to change the code. </font><font style="vertical-align: inherit;">I didn‚Äôt torture myself and just marked these warnings with the help of comments as false. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warning N126 - N127</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two warnings are "lost."</font></font> This is normal.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that sometimes the same suspicious code snippet can lead to 2 and sometimes 3 warnings. Accordingly, several edits can be corrected with a single edit. For example, V595 warnings could disappear during the code editing process associated with the V560 (see warnings N28 - N31).</font></font><br><br><h2>  findings </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there are very few false positives. </font><font style="vertical-align: inherit;">Many messages point to a code that "smells." </font><font style="vertical-align: inherit;">Yes, this code works correctly. </font><font style="vertical-align: inherit;">Nevertheless, it is strange, it is difficult to read and maintain. </font><font style="vertical-align: inherit;">What the analyzer can confuse can confuse a person. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often, the code fragments pointed to by the analyzer can be rewritten. </font><font style="vertical-align: inherit;">This will not only eliminate the warning, but also make the code more understandable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case when the analyzer is really wrong, there are various methods of suppressing false warnings. </font><font style="vertical-align: inherit;">They are discussed in detail in the documentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope I managed to show in the article that working with false positives is not as difficult as it may seem at first glance. </font><font style="vertical-align: inherit;">Good luck using our static code analyzers.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This article is in English. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov. </font></font><a href="http://www.viva64.com/en/b/0263/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handling False Positives in PVS-Studio and CppCat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read the article and have a question?</font></font></b> <div class="spoiler_text">          .      : <a href="http://www.viva64.com/ru/a/0085/">      PVS-Studio  CppCat,  2014</a> . ,   . <br></div></div><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, we no longer develop or support the CppCat project. </font><font style="vertical-align: inherit;">You can read </font><font style="vertical-align: inherit;">about the reasons </font></font><a href="http://habrahabr.ru/company/pvs-studio/blog/256637/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></td></tr></tbody></table></div><p>Source: <a href="https://habr.com/ru/post/227019/">https://habr.com/ru/post/227019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227003/index.html">Experiments with bit-reverse patterns in two-dimensional additive cellular automata</a></li>
<li><a href="../227009/index.html">Harley-Davidson Introduces LiveWire Electric Motorcycle</a></li>
<li><a href="../227011/index.html">3 reasons to steam in Startup Sauna</a></li>
<li><a href="../227013/index.html">Android 4.4.4 (KTU84P) became available for the Nexus line</a></li>
<li><a href="../227015/index.html">Compile-time functional programming in D</a></li>
<li><a href="../227021/index.html">Typical payment system API errors</a></li>
<li><a href="../227023/index.html">How we create the best service for the selection of credit cards in RuNet</a></li>
<li><a href="../227025/index.html">Show me an advertisement, I'm ready</a></li>
<li><a href="../227029/index.html">New Germany record: 50.6% of energy per day received from solar panels</a></li>
<li><a href="../227033/index.html">Quality vs. high: what is really important in audio?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>