<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Who should live and who should die: priorities of processes in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator‚Äôs note: when translating, I tried to make the most of the terminology that Google itself offers in the Russian version of the Android docum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Who should live and who should die: priorities of processes in Android</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Translator‚Äôs note: when translating, I tried to make the most of the terminology that Google itself offers in the Russian version of the Android documentation, thus ‚Äúservice‚Äù became ‚Äúservice‚Äù, ‚Äúcontent provider‚Äù became ‚Äúcontent provider‚Äù, and so on.  But the ‚Äúactivity‚Äù could not become an ‚Äúoperation‚Äù - I did not overpower myself.  Excuse me. <br></blockquote><br>  Let's face it: mobile devices don't have infinite memory, infinite battery power, or something else infinite.  For us, this means the following: <b>we must view the death of the process as a natural part of the life cycle of our applications</b> .  It is important to make sure that the release of memory associated with the destruction of the process does not lead to negative consequences for our user.  To accomplish this task, most of the process architecture in Android was created in such a way as to ensure a rigid hierarchy, in accordance with which processes live and die. <br><a name="habracut"></a><br><br><h2>  Android process hierarchy </h2><br>  If you refer to the <a href="http://developer.android.com/guide/components/processes-and-threads.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">documentation</a> , you will find that the most important processes are called <b>foreground</b> <b>processes</b> , followed by <b>visible processes</b> , <b>utility processes</b> , <b>background</b> <b>processes</b> , and finally <b>empty processes</b> .  By the way, notice that although we‚Äôll talk about the components of Android applications (Services, <code>Activity</code> , and so on), <b>Android always destroys processes, not components</b> .  Of course, this does not contradict garbage collection (as a result of which the memory occupied by objects that no one else refers to is returned to the system), but this is a topic for a separate post. <br><br><img src="https://habrastorage.org/files/585/a17/a6b/585a17a6b5b1487da3049394f7680fdc.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Foreground processes </h2><br>  You probably think that what the user interacts with at any given moment is the component of the system that cannot be destroyed at all (at least as long as the user continues his work), and you are absolutely right.  But one thing: ‚Äúwhat the user interacts with at any given point in time‚Äù is a slightly vague definition.  One of the components that fall into this category is the <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">Foreground</a> <code>Activity</code> ‚Äî the one in which <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onResume ()</a> has already been called, and <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onPause ()</a> is not yet. <br><br>  While some <code>Activity</code> rely in their work only on themselves, others shift a part of it to bound services.  <b>Any process containing a service <code>Activity</code> foreground <code>Activity</code> receives exactly the same priority from the system as the process containing the foreground <code>Activity</code> itself.</b>  And rightly so: if the <code>Activity</code> believes that for its work it is necessary to keep a constant connection with the service, then keep this service alive and unharmed in the interests of both the <code>Activity</code> itself and Android.  The same principle applies to content providers. <br><br>  But who said that <code>Activity</code> is the only component whose disappearance will immediately make the user indignant?  I would surely be angry if my music suddenly stopped playing, or the tips from my navigation system would disappear into a fog.  Fortunately, Android allows services to notify the system that they have high priorities by calling the <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">startForeground ()</a> method.  Calling this method is the best way to provide <a href="https://youtu.be/XQwe30cZffg%3Ft%3D1951%26utm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">background music playback</a> , and, as for other tasks, before calling <code>startForeground()</code> , you need to ask yourself: ‚Äú <code>startForeground()</code> user immediately notice that my service has stopped working?‚Äù the plan should be used only in critical cases, when the interruption becomes immediately apparent. <br><br><blockquote>  Note: Front-end services require that you post a <a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">notification</a> that tells the user that the service is working.  If it seems to you that in your particular case the notification is not needed, then you probably don‚Äôt need the foreground service (this is normal, there are other ways to ensure work in the background, which will be described later). <br></blockquote><br>  There are several other cases in which the priority of a process is temporarily raised to that of a foreground process.  These include the service performing the following lifecycle methods: <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onCreate ()</a> , <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onStartCommand (),</a> and <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onDestroy ()</a> .  The execution of a broadcast receiver by the <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onReceive ()</a> method also applies to them.  This priority increase is necessary in order to make these lifecycle methods atomic and allow each component to execute them without being destroyed by the system. <br><br><h2>  Visible processes </h2><br>  So, stop, I already told about the foreground <code>Activity</code> ?  He told, but Android in its inscrutable wisdom allows you to face situations where your <code>Activity</code> is visible, but not in the foreground.  This can happen when the <code>Activity</code> starts another <code>Activity</code> , the topic of which is inherited from Dialog.  Or when the activity being <code>Activity</code> is translucent.  Or when you call the system dialog with a request from the user of <a href="http://developer.android.com/training/permissions/requesting.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">certain permissions</a> (which, in fact, is an <code>Activity</code> !). <br><br>  <code>Activity</code> is visible from the <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onStart ()</a> call to the onStop () call.  Between these two calls, you can do everything you expect from a visible <code>Activity</code> : refreshing the screen, and so on. <br><br>  By the way, the processes in which the associated services and content providers of the visible <code>Activity</code> also given the same priority as the process with the visible <code>Activity</code> (just as it does in the <code>Activity</code> ), and for the same reasons: to ensure that these dependent processes will not be destroyed by the system. <br><br>  Pay attention to the following point: the <b>fact that your process is visible does not guarantee that it will not be destroyed by the system</b> .  If the foreground processes require a lot of memory for their needs, there is a chance that Android will still go to extreme measures and swat the visible process.  For the user, this will look as follows: a visible <code>Activity</code> located under the foreground <code>Activity</code> will be replaced with a black screen.  Of course, if you <a href="http://developer.android.com/training/basics/activity-lifecycle/recreating.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">recreate a killed <code>Activity</code> correctly</a> , your process and your <code>Activity</code> will be recreated without losing state as soon as the foreground <code>Activity</code> is destroyed. <br><br><blockquote>  Note: one of the reasons that the result of <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">startActivityForResult () is</a> processed in <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onActivityResult ()</a> , and the result of <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">requestPermissions ()</a> is <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">processed</a> in <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onRequestPermissionsResult ()</a> , and not in callback functions, the very possibility of destroying the visible process is if your entire the process will be destroyed, and all the callback functions in it will be destroyed too.  Therefore, if you see libraries using the callback approach, be aware: they may not work the way you want, if there is a shortage of memory in the system. <br></blockquote><br><h2>  Utility processes </h2><br>  If your process does not fall into any of the above categories, but it has a running service, then your process receives the priority of the service process.  Such cases are typical of many applications that perform background work (for example, loading data), but the results of this work are not as important as in the case of front-end services. <br><br>  And these processes are not as useless as they may seem.  For a large range of tasks, such a process is the <i>best way to</i> perform background tasks, since it will be destroyed only if so much is happening in visible and foreground processes that you need to take memory from somewhere urgently. <br><br>  Pay particular attention to the constant returned by you from <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onStartCommand ()</a> , since it determines the behavior of the system in case your process is destroyed when there is a shortage of memory: <br><br><ul><li>  <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">START_STICKY</a> implies that the system will revive your service when it is possible, but it will not re-send the last <code>Intent</code> received by the service (for example, you can restore the state yourself, or you have a self-written life cycle that determines what to do at the start and stop the service). </li><li>  <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">START_REDELIVER_INTENT is</a> intended for services that want to be restarted with the same <code>Intent</code> 'that they received in onStartCommand () </li><li>  <a href="http://developer.android.com/reference/android/app/Service.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">START_NOT_STICKY is</a> useful for services that do not have to be restarted if they are quietly dissolved in the fog.  This behavior can be useful for services that perform periodic tasks that can be temporarily omitted. </li></ul><br><br><h2>  Background processes </h2><br>  Suppose that you had a <code>Activity</code> , and the user clicked on the Home button, which led to the <a href="http://developer.android.com/reference/android/app/Activity.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">onStop ()</a> call.  If, apart from this <code>Activity</code> , you no longer had anything that would allow you to continue to maintain the high priority of your process, then <b>your process goes into the category of background processes</b> .  By the way, they occupy most of the device‚Äôs memory, in case the user decides to return to one of the previously opened applications. <br><br>  Android does not destroy processes right and left, since launching them from scratch is quite a resource-consuming operation.  Therefore, they can remain in memory for some time before being destroyed if a new high-priority process appears on the horizon.  Destruction occurs in the order of crowding out long-unused: first, those processes that have not been used the most are destroyed.  Just as in the case of the destruction of visible processes / <code>Activity</code> , you need to be able to <a href="http://developer.android.com/training/basics/activity-lifecycle/recreating.html%3Futm_campaign%3Dadp_series_processes_012016%26utm_source%3Dmedium%26utm_medium%3Dblog">correctly recreate the <code>Activity</code></a> without losing data. <br><br><h2>  Empty processes </h2><br>  As in any hierarchy, there is always the lowest level.  In empty processes, there is not a single active component, and Android can destroy them at any time, but usually they are still kept in memory for some time (this is again a word about the efficient use of memory, which is not to clean everything contract). <br><br><h3>  What you should pay attention to </h3><br>  Although we talked about process priorities in terms of what components are running in your processes, remember that <b>hierarchy exists at the process level, not the component level</b> .  Only one component (for example, the foreground service) will translate your entire process into the category of foreground processes.  Although most applications live well in one process, you need to remember that if the life cycle of your application can be very different from launch to launch, or the application has a very difficult task as well as a long time, but lightweight, and the first does not depend on the second , it makes sense to distinguish two processes.  Let the heavy task be performed in the first process, and the lightweight one in the second, and then, in the event of a lack of memory, the heavy process can be suspended, and the lightweight one will continue its work. <br><br>  It is also important to remember that the <b>priority of your process is determined by what happens at the component level</b> .  This means that if you run a very important task, which should be performed for a long time, in a separate thread, but from under the <code>Activity</code> , then you will have an unpleasant surprise when your process suddenly becomes a background.  Use the tools available to you (for example, services, or foreground services) to ensure that the system is up to date with what you are doing. <br><br><h3>  Do not forget about others and remember your user. </h3><br>  Create your application in such a way that it constantly works at the level of priority that it needs - no more and no less.  Remember also that you, as a developer, have a device that is <i>much</i> more powerful than the weakest end-user devices, and because of this you can never see with your own eyes the destruction of the visible process (and the service one even more so), but this does not mean that never happens. <br><br>  Although I usually recommend buying as weak a device as possible for testing, <b>you can test the behavior of your application when it is destroyed, even on your flagship</b> .  To destroy your application (along with all its processes), do the following: <br><br><pre> <code class="bash hljs">adb shell am force-stop com.example.packagename</code> </pre><br>  If you have multiple processes, you can first find the PID of the process you need by looking at the second column (that is, the first number) of the result of the following command: <br><br><pre> <code class="bash hljs">adb shell ps | grep com.example.packagename</code> </pre><br>  And then swat this process: <br><br><pre> <code class="bash hljs">adb shell <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> PID</code> </pre><br>  This will be the first step to ensure that the application will work correctly on most devices, regardless of what memory limitations will arise. </div><p>Source: <a href="https://habr.com/ru/post/276381/">https://habr.com/ru/post/276381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276367/index.html">Pitfalls of Consciousness: How researchers cheat themselves</a></li>
<li><a href="../276369/index.html">Machine learning from Octave \ Matlab to Python</a></li>
<li><a href="../276371/index.html">"Digital Rain" for Windows in 314 bytes</a></li>
<li><a href="../276373/index.html">Social CRM. Collecting the interest of Internet users</a></li>
<li><a href="../276377/index.html">Reducing the size of a thin disk in ESXi</a></li>
<li><a href="../276383/index.html">Habra graph, community and where did all the karma go</a></li>
<li><a href="../276385/index.html">Hyper-scale server farm Amazon, Apple, Google, Switch, Toyota</a></li>
<li><a href="../276389/index.html">Telegram bot framework</a></li>
<li><a href="../276391/index.html">MonCach√© - implementation of the MongoDB API based on InterSystems Cach√©</a></li>
<li><a href="../276393/index.html">Smart babysitter based on Intel Edison and Ubidots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>