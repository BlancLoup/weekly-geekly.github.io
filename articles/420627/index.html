<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous C # programming: how are you doing with performance?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most recently, we already talked about whether Equals and GetHashCode need to be redefined when programming in C #. Today we will deal with the perfor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous C # programming: how are you doing with performance?</h1><div class="post__text post__text-html js-mediator-article">  Most recently, we already <a href="https://habr.com/company/microsoft/blog/418515/">talked</a> about whether Equals and GetHashCode need to be redefined when programming in C #.  Today we will deal with the performance parameters of asynchronous methods.  Join now! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  In the last two articles on the msdn blog, we looked at the <a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">internal structure of asynchronous methods in C #</a> and <a href="https://blogs.msdn.microsoft.com/seteplia/2018/01/11/extending-the-async-methods-in-c/">the extension points</a> that the C # compiler provides to control the behavior of asynchronous methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Based on the information in the first article, the compiler performs many transformations to make asynchronous programming as similar to synchronous as possible.  To do this, it creates a copy of the state machine, passes it to the builder of the asynchronous method, which calls the awaiter object for the task, etc. Of course, this logic has its price, but what will it cost us? <br><br>  Until the TPL library appeared, asynchronous operations were not used in such a large amount, therefore, the costs were low.  But today, even a relatively simple application can perform hundreds, if not thousands, of asynchronous operations per second.  The library of parallel tasks TPL was created taking into account such a workload, but there is no magic here, and you have to pay for everything. <br><br>  To estimate the costs of asynchronous methods, we will use a slightly modified example from the first article. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  The <code>StockPrices</code> class <code>StockPrices</code> stock prices from an external source and allows you to request them through the API.  The main difference from the example from the first article is the transition from the dictionary to the list of prices.  In order to evaluate the costs of various asynchronous methods in comparison with synchronous ones, the operation itself has to do some work, in our case it is a linear search for stock prices. <br><br>  The <code>GetPricesFromCache</code> method <code>GetPricesFromCache</code> intentionally built on a simple loop to avoid resource allocation. <br><br><h2>  Comparison of synchronous methods and task-based asynchronous methods </h2><br>  In the first performance test, we compare an asynchronous method that calls the asynchronous initialization method ( <code>GetStockPriceForAsync</code> ), a synchronous method that calls the asynchronous initialization method ( <code>GetStockPriceFor</code> ), and a synchronous method that calls the synchronous initialization method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  The results are shown below: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  Already at this stage we received quite interesting data: <br><br><ul><li>  The asynchronous method is quite fast.  <code>GetPricesForAsync</code> runs synchronously in this test and is about 15% (*) slower than the purely synchronous method. </li><li>  The synchronous <code>GetPricesFor</code> method, which calls the asynchronous <code>InitializeMapIfNeededAsync</code> method, has even lower costs, but most surprisingly, it does not allocate resources at all (in the Allocated column in the table above, it is 0 for both <code>GetPricesDirectlyFromCache</code> and <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Of course, one cannot say that the costs of synchronous execution of the asynchronous method are 15% for all possible cases.</i>  <i>This value depends on the workload performed by the method.</i>  <i>The difference between the costs of a pure asynchronous method call (which does nothing) and a synchronous method (which does nothing) will be huge.</i>  <i>The idea of ‚Äã‚Äãthis comparative test is to show that the costs of an asynchronous method that performs a relatively small amount of work are relatively low.</i> <br><br>  How did it happen that when I called <code>InitializeMapIfNeededAsync</code> no resources were allocated at all?  In the first article in this series, I mentioned that the asynchronous method should allocate at least one object in the managed header ‚Äî the task instance itself.  Let's discuss this point in more detail. <br><br><h2>  Optimization # 1: caching task instances when possible </h2><br>  The answer to the above question is very simple: <code>AsyncMethodBuilder</code> <b>uses one instance of the task for each successfully completed asynchronous operation</b> .  The asynchronous method that <code>Task</code> returns uses <code>AsyncMethodBuilder</code> with the following logic in the <code>SetResult</code> method: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  The <code>SetResult</code> method <code>SetResult</code> called only for successfully completed asynchronous methods, and the <b>successful result for each method based on the <code>Task</code> can be freely used together</b> .  We can even trace this behavior with the following test: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  But this is not the only possible optimization.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> optimizes work in a similar way: it caches tasks for <code>Task&lt;bool&gt;</code> and some other simple types.  For example, it caches all default values ‚Äã‚Äãfor a group of integer types and uses a special cache for <code>Task&lt;int&gt;</code> , putting values ‚Äã‚Äãfrom the range [-1;  9] (for details, see <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  This is confirmed by the following test: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>You should not overly rely on this behavior</b> , but it is always pleasant to realize that the creators of the language and the platform are doing everything possible to improve performance by all available means.  Task caching is a popular optimization method that also finds application in other areas.  For example, the new implementation of <code>Socket</code> in the <a href="https://github.com/dotnet/corefx/">corefx repo</a> repository <a href="https://github.com/dotnet/corefx/">makes</a> extensive use of this method and applies <a href="">cached tasks</a> wherever possible. <br><br><h2>  Optimization # 2: Using <code>ValueTask</code> </h2><br>  The optimization method described above only works in a few cases.  Therefore, instead of it, we can use <code>ValueTask&lt;T&gt;</code> (**), a special type of values, similar to the problem;  it will not allocate resources if the method is executed synchronously. <br><br>  <code>ValueTask&lt;T&gt;</code> is a distinguishable combination of <code>T</code> and <code>Task&lt;T&gt;</code> : if the ‚Äúvalue-task‚Äù is completed, then the base value will be used.  If the baseline is not yet exhausted, resources will be allocated for the task. <br><br>  This special type helps prevent excessive heap allocation when performing an operation synchronously.  To be able to use <code>ValueTask&lt;T&gt;</code> , you need to change the return type for <code>GetStockPriceForAsync</code> : instead of <code>Task&lt;decimal&gt;</code> must specify <code>ValueTask&lt;decimal&gt;</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Now we can estimate the difference using the additional benchmark: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  As you can see, the version with <code>ValueTask</code> is only slightly faster than the version with Task.  The main difference is that heap allocation is prevented.  In a minute we will discuss the feasibility of such a transition, but before that I would like to tell you about a clever optimization. <br><br><h2>  Optimization number 3: the rejection of asynchronous methods within a common path </h2><br>  If you often use some asynchronous method and want to reduce costs even more, I suggest you the following optimization: remove the async modifier, and then check the state of the task inside the method and perform the entire operation synchronously, completely abandoning the asynchronous approaches. <br><br>  Looks hard?  Consider an example. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  In this case, the <code>async</code> modifier is not used in the <code>GetStockPriceWithValueTaskAsync_Optimized</code> method; therefore, receiving the task from the <code>InitializeMapIfNeededAsync</code> method, it checks the status of its execution.  If the task is complete, the method simply uses <code>DoGetPriceFromCache</code> to immediately get the result.  If the initialization task is still running, the method calls a local function and waits for the results. <br><br>  Using a local function is not the only one, but one of the easiest ways.  But there is one nuance.  In the course of the most natural implementation, the local function will receive the external state (local variable and argument): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  But, unfortunately, due to <a href="https://github.com/dotnet/roslyn/issues/18946">a compiler error,</a> this code will cause closure, even if the method is executed within the framework of a common path.  Here is how this method looks from the inside: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  As discussed in the article <a href="https://blogs.msdn.microsoft.com/seteplia/2017/10/03/dissecting-the-local-functions-in-c-7/">Dissecting the Local Functions in C #</a> (‚ÄúTruncating Local Functions in C #‚Äù), the compiler uses a common instance of closure for all local variables and arguments in a particular area.  Consequently, there is some sense in such code generation, but it makes the whole struggle with heap allocation useless. <br><br>  <b>TIP</b> .  Such optimization is a very insidious thing.  The advantages are insignificant, and even if you write the <b>correct</b> initial local function, in the course of further changes, you can accidentally get the external state that causes the selection of the heap.  You can still resort to optimization if you work with a frequently used library (for example, BCL) in a method that will definitely be used on a loaded portion of code. <br><br><h4>  Costs associated with waiting for a task </h4><br>  At the moment we have considered only one specific case: the costs of the asynchronous method, which is performed synchronously.  This is intentional.  The ‚Äúless‚Äù the asynchronous method, the more noticeable are the costs in its overall performance.  More detailed asynchronous methods, as a rule, run synchronously and perform a lower workload.  And we usually call them more often. <br><br>  But we need to be aware of the costs of the asynchronous mechanism when the method ‚Äúwaits‚Äù for the completion of an unfulfilled task.  To estimate these costs, we will make changes to <code>InitializeMapIfNeededAsync</code> and call <code>Task.Yield()</code> even when the cache is initialized: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Add to our package for comparative testing the following methods: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  As you can see, the difference is palpable - both in terms of speed and in terms of memory usage.  We briefly explain the results. <br><br><ul><li>  Each await operation for an unfinished task runs approximately 4 microseconds and allocates nearly 300 bytes (**) for each call.  That is why GetStockPriceFor runs almost twice as fast as GetStockPriceForAsync and allocates less memory. </li><li>  An asynchronous method based on ValueTask takes a little longer than the Task option when this method is not running synchronously.  A state machine based on ValueTask &lt;T&gt; must store more data than a state machine based on Task &lt;T&gt;. </li></ul><br>  <i>(**) It depends on the platform (x64 or x86) and a number of local variables and arguments of the asynchronous method.</i> <br><br><h4>  Productivity of asynchronous methods 101 </h4><br><ul><li>  If the asynchronous method runs synchronously, the costs are quite small. </li><li>  If the asynchronous method runs synchronously, the following memory overheads arise: there are no costs for the async Task methods, and the async Task &lt;T&gt; methods have an overrun of 88 bytes per operation (for x64 platforms). </li><li>  ValueTask &lt;T&gt; eliminates the above costs for asynchronous methods that are performed synchronously. </li><li>  When an asynchronous method based on ValueTask &lt;T&gt; is performed synchronously, it takes a little less time than the method with Task &lt;T&gt;, otherwise there are slight differences in favor of the second option. </li><li>  The performance cost for asynchronous methods that are waiting for an unfinished task is much higher (approximately 300 bytes per operation for x64 platforms). </li></ul><br>  Of course, measurements are our everything.  If you see that an asynchronous operation causes performance problems, you can switch from <code>Task&lt;T&gt;</code> to <code>ValueTask&lt;T&gt;</code> , cache the task, or make the common execution path synchronous, if possible.  You can also try to consolidate your asynchronous operations.  This will help improve performance, simplify debugging and code analysis in general.  <b>Not every small piece of code should be asynchronous.</b> </div><p>Source: <a href="https://habr.com/ru/post/420627/">https://habr.com/ru/post/420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420615/index.html">Javascript: object exploration</a></li>
<li><a href="../420617/index.html">Developer Web Design Guide</a></li>
<li><a href="../420619/index.html">Responsive images: CSS techniques that help save time</a></li>
<li><a href="../420623/index.html">Distributed C ++ applications with minimal effort</a></li>
<li><a href="../420625/index.html">KDD 2018, first day, tutorials</a></li>
<li><a href="../420629/index.html">PHP Digest No. 137 (August 6 - 20, 2018)</a></li>
<li><a href="../420631/index.html">We are not afraid of "clouds"</a></li>
<li><a href="../420633/index.html">We write GeoIP exporter for Prometheus with visualizations in Grafana in 15 minutes</a></li>
<li><a href="../420635/index.html">AI, practical course. The basic model of recognition of emotions in images</a></li>
<li><a href="../420637/index.html">WANHAO D9 / 300 3D Printer Review: Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>