<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ethereum Smart Contracts: What to do when you make a mistake in a smart contract or migration technique</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing smart contracts, it is important to remember that after downloading to the blockchain, they can no longer be changed, and therefore, no i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ethereum Smart Contracts: What to do when you make a mistake in a smart contract or migration technique</h1><div class="post__text post__text-html js-mediator-article">  When writing smart contracts, it is important to remember that after downloading to the blockchain, they can no longer be changed, and therefore, no improvements can be made or any errors found can be corrected!  We all know that there are errors in any program, and returning to the code written a couple of months ago, we will always find what can be improved there.  How to be?  The only possible option is to download a new contract with the corrected code.  But what if there are already tokens issued on the basis of the existing contract?  Migration comes to the rescue!  Over the past year, I have tried many different techniques for its implementation, analyzed the projects used in other major blockchain projects and invented something myself.  Details under the cut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d1/6d/59d16d5a92f14262474139.jpeg"></div><a name="habracut"></a><br>  At once I will make a reservation that within the framework of this post I will not bring sheets of ready-made smart contracts, and I will only consider and analyze various techniques.  Almost all of them in one form or another have been implemented by me in contracts for projects in which I have been involved, and much can be taken from <a href="https://github.com/isvirin">my GitHub</a> . <br><br><h2>  Migration from ERC20-compatible contract </h2><br>  Let us begin with the simplest and most common case, when the original contract, already loaded in the blockchain, does not contain any special mechanisms to help us with migration, i.e.  in fact, we have a regular ERC20-compatible contract.  The only thing we can take from the original contract is the balance sheets of all holders of tokens and the total number of tokens issued to verify that we did not forget anyone during the migration. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs">contract ERC20base { uint public totalSupply; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constant</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  Unfortunately, the interface of the ERC20-compatible contract does not allow to know the list of all holders of tokens, so during migration we will have to find out the full list of holders from some other source, for example, by unloading it from <a href="http://etherscan.io/">etherscan.io</a> .  An example of the contract to which the migration is carried out is given in the following listing: <br><br><pre> <code class="javascript hljs">contract NewContract { uint public totalSupply; mapping (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> uint) balanceOf; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _migrationSource, address [] _holders</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;_holders.length; ++i) { uint balance = ERC20base(_migrationSource).balanceOf(_holders[i]); balanceOf[_holders[i]] = balance; totalSupply += balance; } <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(totalSupply == ERC20base(_migrationSource).totalSupply()); } }</code> </pre> <br>  The contract constructor receives as parameters the address of the original ERC20-compatible contract, as well as the list of token holders manually downloaded via etherscan.io.  It should be noted that in the last term of the designer we check that the number of tokens has not changed after the migration, and therefore, no token holder is forgotten.  It is necessary to take into account that such migration is possible only if the number of token holders is small and the cycle for them is all possible within one transaction (the gas limit set in Ethereum for one transaction).  If, however, the number of holders of tokens does not allow migrating in one transaction, then this functionality will have to be put into a separate function that can be called the necessary number of times, and the contract in this case will look like this: <br><br><pre> <code class="javascript hljs">contract NewContract { uint public totalSupply; mapping (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> uint) balanceOf; address public migrationSource; address public owner; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _migrationSource</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ migrationSource = _migrationSource; owner = msg.sender; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">migrate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address [] _holders</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">require</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg.sender == owner</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint i=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i&lt;_holders.length; ++i</span></span></span><span class="hljs-function">) </span></span>{ uint balance = ERC20base(_migrationSource).balanceOf(_holders[i]); balanceOf[_holders[i]] = balance; totalSupply += balance; } } }</code> </pre> <br>  In the constructor of this contract, the address of the original contract is memorized, and the owner field is initialized to remember the address of the contract owner, so that only he has the right to call the migrate () function, which, once called, can migrate any number of tokens holders from the original contract. <br><br>  The disadvantages of this solution are as follows: <br><br><ol><li>  On the old smartcontract, the tokens will remain with their owners, and on the new, their balance sheets will simply be duplicated.  How bad it is depends on how your Tokens sale agreement or any other document describing the amount of your obligations to the holders of your project‚Äôs tokens is drawn up and whether your obligations to them will double after the creation of a ‚Äúduplicate‚Äù. </li><li>  You spend your own gas on migration, but this, in general, is logical, because  You came up with the migration, and in any case, cause inconvenience to your users, although it is limited by the fact that they need to rewrite the address of the smart contract from their old to new ones in their wallets. </li><li>  In the process of migration, if it certainly does not fit into one transaction, transfers of tokens between the addresses of their owners may occur, and therefore new holders may be added and the balance of existing holders may change. </li></ol><br>  But with this, unfortunately, nothing can be done, and for a more comfortable and convenient migration, you should provide some kind of auxiliary means in the original contract. <br><br><h2>  Migration between crowdsale stages </h2><br>  In the world of modern ICO, the practice is quite common when individual contracts are made for different stages of fundraising, migrating issued tokens to new contracts of a new stage.  This, of course, can be done as we have discussed above, but if we know for sure that we will have to migrate, then why not just simplify our life for ourselves?  To do this, simply enter the public field <br><br><pre> <code class="javascript hljs"> address [] public holders;</code> </pre> <br>  All tokens holders must be added to this field.  If the contract already at the early stages of collection allows the holders to transfer tokens, i.e.  implements transfer (), you need to ensure that the array is updated, for example, somehow <br><br><pre> <code class="javascript hljs"> mapping (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> bool) public isHolder; address [] public holders; ‚Ä¶. if (isHolder[_who] != <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { holders[holders.length++] = _who; isHolder[_who] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Now, on the side of the acceptance contract, you can use the same migration technology discussed earlier, but now there is no need to transfer the array as a parameter, just refer to the already prepared array in the original contract.  It should also be remembered that the size of the array may not allow to iterate it in one transaction due to the restriction of gas to one transaction, and therefore, it is necessary to provide the function migrate (), which will receive two indices - the numbers of the initial and final elements of the array for processing within this transactions. <br><br>  The disadvantages of this solution are in general the same as the previous one, except that now there is no need to upload the list of tokens holders via etherscan.io. <br><br><h2>  Migration with burning source tokens </h2><br>  After all, since we are talking about migration, and not about duplication of tokens in a new smart contract, it is necessary to attend to the issue of the destruction (burning) of tokens on the original contract when creating their copy on the new one.  Obviously, it is unacceptable to leave a ‚Äúhole‚Äù in the smart contract, which would allow anyone, even if he were the owner of a smart contract, to burn tokens of other holders.  Such a smart contract will be just scam!  Perform this kind of manipulation of their tokens can only their holder, and hence the holder must carry out the migration.  The owner of the smart contract in this case can only start this migration (transfer the smart contract to the migration state).  I met an example of such a migration in the GOLEM project (link to their github at the end of the post), then implemented it in several of my projects. <br><br>  In the original contract, we define the interface MigrationAgent, which should later be implemented in the contract to which the migration is carried out. <br><br><pre> <code class="javascript hljs">contract MigrationAgent { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">migrateFrom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _from, uint256 _value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  The following additional functionality must be implemented in the original token contract: <br><br><pre> <code class="javascript hljs">contract TokenMigration is Token { address public migrationAgent; <span class="hljs-comment"><span class="hljs-comment">// Migrate tokens to the new token contract function migrate() external { require(migrationAgent != 0); uint value = balanceOf[msg.sender]; balanceOf[msg.sender] -= value; totalSupply -= value; MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); } function setMigrationAgent(address _agent) external { require(msg.sender == owner &amp;&amp; migrationAgent == 0); migrationAgent = _agent; } }</span></span></code> </pre> <br>  Thus, the owner of the source smart contract should call setMigrationAgent (), passing to it the address of the smart contract to which the migration is performed as a parameter.  After that, all holders of tokens of the original smart contract should call the migrate () function, which will destroy their tokens in the original smart contract and add a new one (by calling the migrateFrom () function of the new contract).  Well, the new contract should actually contain the implementation of the MigrationAgent interface, for example, like this: <br><br><pre> <code class="javascript hljs">contract NewContact is MigrationAgent { uint256 public totalSupply; mapping (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> uint256) public balanceOf; address public migrationHost; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _migrationHost</span></span></span><span class="hljs-function">) </span></span>{ migrationHost = _migrationHost; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">migrateFrom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address _from, uint256 _value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(migrationHost == msg.sender); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(balanceOf[_from] + _value &gt; balanceOf[_from]); <span class="hljs-comment"><span class="hljs-comment">// overflow? balanceOf[_from] += _value; totalSupply += _value; } }</span></span></code> </pre> <br>  Everything is great in this decision!  In addition, the user must call the function migrate ().  The situation is significantly complicated by the fact that function calls are supported by only a few wallets and, as a rule, they are not the most convenient.  Therefore, believe me, if among the holders of your tokens there are not only cryptotogics, but also mere mortal people, they will just curse you when you explain to them that you need to install some kind of Mist, and then call some kind of function (thank God, at least without parameters).  How to be? <br><br>  And you can do very simple!  After all, any user of a cryptocurrency, even the most beginner, can do one thing well - send a crypt from one address to another.  So let this address be the address of our smart contract, and its fallback function in the "migration" mode will simply call migrate ().  Thus, the holder of tokens will need to transfer at least 1 wei to the address of the smart contract, which is in the ‚Äúmigration‚Äù mode, so that a miracle happens! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state = State.Migration) { migrate(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><h2>  Conclusion </h2><br>  The considered solutions conceptually cover all possible ways to implement token migration, although variations are possible in specific implementations.  Separate attention is worthy of the ‚Äúdistillery vessel‚Äù approach (link at the end of the post).  Regardless of the migration approach you use, remember that a smart contract is not just a program running inside an Ethereum virtual machine, but a kind of alienated independent contract, but any migration assumes that you change the terms of this contract.  Are you sure that tokens holders want to change the terms of the contract that they signed when they acquired tokens?  This is actually a good question.  And there is a very good practice, ‚Äúasking‚Äù token holders about whether they want to ‚Äúmove‚Äù to a new contract.  I implemented migration through voting in the smart contract of my PROVER project, the text of the contract can be found on my GitHub.  And of course I invite you to join the ICO of my <a href="http://prover.io/">PROVER</a> project. <br><br>  I hope that all this is useful and necessary for someone :). <br><br><h2>  useful links </h2><br><ul><li>  <a href="https://www.youtube.com/watch%3Fv%3DlKnOxopK6Yc">My video presentation on creating a simple smart contract for ICO</a> </li><li>  <a href="https://habrahabr.ru/post/338084/">My post about writing smart contract for ICO</a> </li><li>  <a href="">Implementation of token migration in the GOLEM project</a> </li><li>  <a href="https://blog.aira.life/the-contract-of-the-distillatory-vessel-ambix-sol-for-interrupted-ico-558aac436623">Description of the migration by the "distillation vessel"</a> </li><li>  <a href="https://prover.io/">My PROVER project</a> - <b>preparation for ICO!</b> </li><li>  <a href="https://habrahabr.ru/company/emercoin/blog/334650/">Another post about my project PROVER</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DJhG8ckZ5mpo%26t%3D541s">PROVER Project Video Presentation (eng)</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/339102/">https://habr.com/ru/post/339102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339092/index.html">Classic 2D quest or how our two years of development went. Part 3</a></li>
<li><a href="../339094/index.html">Heading "We read articles for you." September 2017</a></li>
<li><a href="../339096/index.html">Electronic documents in the Russian courts, as a criterion for the electronic maturity of Russia</a></li>
<li><a href="../339098/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ282 (September 25 - October 1, 2017)</a></li>
<li><a href="../339100/index.html">The most important IT event of the fall: Dell EMC Forum 2017</a></li>
<li><a href="../339104/index.html">The tale of well-built business processes, or how one problem hacked a perfectly working development system</a></li>
<li><a href="../339106/index.html">How to work effectively with the advertising format Playable ads: five common mistakes</a></li>
<li><a href="../339108/index.html">Profiling PL / SQL code with IDE PL / SQL Developer</a></li>
<li><a href="../339110/index.html">In the paragraph, everything should be fine</a></li>
<li><a href="../339112/index.html">What follows the web?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>