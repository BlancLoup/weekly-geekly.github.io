<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Laziness is the engine of progress. Task generator Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes I help to carry out mathematical analysis at the first courses and I need to pick up tasks for them to tame. Yes, you can take tasks from th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Laziness is the engine of progress. Task generator Part 2</h1><div class="post__text post__text-html js-mediator-article">  Sometimes I help to carry out mathematical analysis at the first courses and I need to pick up tasks for them to tame.  Yes, you can take tasks from the book.  But what if you do not find the necessary level of tasks in the books that are at hand? <br><br>  How to make your own generator of simple tasks for finding limits / derivatives / integrals and will be discussed after kata. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6d1/62f/b18/6d162fb1861e4986828e62a0cb8adf92.png"></div><br><a name="habracut"></a><br>  <b>Ps</b> The experience of creating a similar program is described <a href="https://habrahabr.ru/post/313488/">in the previous part.</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you can see from the picture, we will generate tasks in pdf using LaTex.  There were already <a href="https://habrahabr.ru/post/187496/">many</a> different <a href="https://habrahabr.ru/post/93169/">articles about him</a> , so I'll omit the introductory part.  We will implement and create tasks through Pascal (but I will describe the general algorithm and hide all the code in the spoilers). <br><br><h3>  Let's get started </h3><br>  First you need to define the concept of a polynomial (polynomial), since the trigonometric functions rely on a polynomial.  As part of the standard operations you need to enter: <br><br><ul><li>  Addition of polynomials </li><li>  Subtracting Polynomials </li><li>  Polynomial multiplication </li><li>  Erection in the natural degree </li><li>  Translation into Tex text </li><li>  Derivative </li><li>  Integral </li></ul><br><div class="spoiler">  <b class="spoiler_title">Class polynomial</b> <div class="spoiler_text">  type polynomial = record <br>  st: integer; // degree of polynomial <br>  kof: array of real; // coefficients at x ^ i <br>  function into (x: real): real; <br>  class function operator + (a, b: polynomial): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] + b.kof [i]; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator- (a, b: polynomial): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] -b.kof [i]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator * (a, b: polynomial): polynomial; <br>  var i, j, stn: integer; <br>  rez: polynomial; <br>  begin <br>  stn: = a.st + b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to a.st do <br>  for j: = 0 to b.st do <br>  begin <br>  rez.kof [i + j]: = rez.kof [i + j] + a.kof [i] * b.kof [j]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator * (a: integer; b: polynomial): polynomial; <br>  var i: integer; <br>  begin <br>  for i: = 0 to b.st do <br>  b.kof [i]: = a * b.kof [i]; <br>  result: = b; <br>  end; <br>  class function operator in (a: polynomial; n: integer): polynomial; <br>  var i: integer; <br>  rez: polynomial; <br>  begin <br>  rez.st:=0; <br>  setlength (rez.kof, 1); <br>  rez.kof [0]: = 1; <br>  for i: = 1 to n do <br>  rez: = rez * a; <br>  result: = rez; <br>  end; <br>  procedure nw (x: integer); <br>  function pltostr: string; // into string variable <br>  procedure derivative; // derivative <br>  procedure integral; // integral <br>  end; <br><br>  procedure polynomial.nw (x: integer); <br>  var <br>  i: integer; <br>  begin <br>  st: = x; <br>  setlength (kof, st + 1); <br>  for i: = 0 to st do <br>  kof [i]: = random (-10,10); <br>  while (kof [st] = 0) do <br>  kof [st]: = random (-10,10); <br>  end; <br>  procedure polynomial.integral; <br>  var <br>  i: integer; <br>  begin <br>  setlength (kof, st + 2); <br>  for i: = st downto 1 do <br>  kof [i + 1]: = kof [i] / i; <br>  kof [0]: = 0; <br>  st: = st + 1; <br>  setlength (kof, st + 1); <br>  end; <br>  procedure polynomial.derivative; <br>  var <br>  i: integer; <br>  begin <br>  for i: = 1 to st do <br>  kof [i-1]: = kof [i] * i; <br>  st: = st-1; <br>  setlength (kof, st + 1); <br>  end; <br></div></div><br>  Following the usual polynomial, you will need to enter a polynomial with roots (so that you can search for roots or reduce fractions). <br><br>  But there will be a peculiarity, since it is necessary to make the same properties not only for the same class, but also for the ordinary polynomial. <br><br><div class="spoiler">  <b class="spoiler_title">Polynomial with roots</b> <div class="spoiler_text">  type polynomialwithroot = record <br>  st: integer; // degree of polynomial <br>  root: array of integer; // roots of a polynomial <br>  kof: array of integer; // coefficients at x ^ i <br>  class function operator + (a, b: polynomialwithroot): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] + b.kof [i]; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator + (a: polynomialwithroot; b: polynomial): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] + b.kof [i]; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator + (b: polynomial; a: polynomialwithroot): polynomial; <br>  // var i: integer; <br>  // rez: polynomial; <br>  begin <br>  result: = a + b; <br>  end; <br>  class function operator- (a, b: polynomialwithroot): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] -b.kof [i]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator- (a: polynomialwithroot; b: polynomial): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] -b.kof [i]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator- (b: polynomial; a: polynomialwithroot): polynomial; <br>  var i, stn: integer; <br>  rez: polynomial; <br>  begin <br>  if (a.st&gt; b.st) then stn: = a.st <br>  else stn: = b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to stn do <br>  begin <br>  if (i &lt;= a.st) then <br>  rez.kof [i]: = rez.kof [i] + a.kof [i]; <br>  if (i &lt;= b.st) then <br>  rez.kof [i]: = rez.kof [i] -b.kof [i]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator * (a, b: polynomialwithroot): polynomialwithroot; <br>  var i, j, stn: integer; <br>  rez: polynomialwithroot; <br>  begin <br>  stn: = a.st + b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to a.st do <br>  for j: = 0 to b.st do <br>  begin <br>  rez.kof [i + j]: = rez.kof [i + j] + a.kof [i] * b.kof [j]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  setlength (rez.root, rez.st); <br>  for i: = 0 to a.st-1 do <br>  rez.root [i]: = a.root [i]; <br>  for i: = 0 to b.st-1 do <br>  rez.root [a.st + i]: = b.root [i]; <br>  result: = rez; <br>  end; <br>  class function operator * (a: polynomialwithroot; b: polynomial): polynomial; <br>  var i, j, stn: integer; <br>  rez: polynomial; <br>  begin <br>  stn: = a.st + b.st; <br>  setlength (rez.kof, stn + 1); <br>  for i: = 0 to stn do <br>  rez.kof [i]: = 0; <br>  for i: = 0 to a.st do <br>  for j: = 0 to b.st do <br>  begin <br>  rez.kof [i + j]: = rez.kof [i + j] + a.kof [i] * b.kof [j]; <br>  end; <br>  while (rez.kof [stn] = 0) do <br>  begin <br>  setlength (rez.kof, stn); <br>  stn: = stn-1; <br>  end; <br>  rez.st:=stn; <br>  result: = rez; <br>  end; <br>  class function operator * (b: polynomial; a: polynomialwithroot): polynomial; <br>  // var i, j, stn: integer; <br>  // rez: polynomial; <br>  begin <br>  result: = a * b; <br>  end; <br>  class function operator in (a: polynomialwithroot; n: integer): polynomialwithroot; <br>  var i: integer; <br>  rez: polynomialwithroot; <br>  begin <br>  rez: = a; <br>  for i: = 2 to n do <br>  rez: = rez * a; <br>  result: = rez; <br>  end; <br>  procedure nw; <br>  procedure roots (x: integer); <br>  function pltostr: string; <br>  end; <br>  procedure polynomialwithroot.roots (x: integer); <br>  var i: integer; <br>  begin <br>  st: = x; <br>  setlength (root, st); <br>  for i: = 0 to st-1 do <br>  begin <br>  root [i]: = random (-5,5); <br>  end; <br>  nw; <br>  end; <br>  procedure polynomialwithroot.nw; <br>  var <br>  i, j, sum: integer; <br>  tk: array of integer; <br>  dop: integer; <br>  begin <br>  setlength (kof, st + 1); <br>  setlength (tk, st + 1); <br>  for i: = 0 to st-1 do <br>  kof [i]: = 0; <br>  for i: = 0 to st-1 do <br>  begin <br>  for j: = 0 to st do <br>  tk [j]: = 0; <br>  while (tk [st] = 0) do <br>  begin <br>  sum: = 0; <br>  for j: = 0 to st-1 do <br>  sum: = sum + tk [j]; <br>  if (sum = (i + 1)) then <br>  begin <br>  dop: = 1; <br>  for j: = 0 to st-1 do <br>  if (tk [j] = 1) then <br>  dop: = dop * root [j]; <br>  for j: = 0 to i do <br>  dop: = - dop; <br>  kof [st-i-1]: = kof [st-i-1] + dop; <br>  end; <br>  tk [0]: = tk [0] +1; <br>  for j: = 0 to st-1 do <br>  begin <br>  tk [j + 1]: = tk [j + 1] + (tk [j] div 2); <br>  tk [j]: = tk [j] mod 2; <br>  end; <br>  end; <br>  end; <br>  kof [st]: = 1; <br>  end; <br></div></div><br>  And then, by the same type of example, we work with trigonometric functions (including the logarithm and e ^ x). <br><br><div class="spoiler">  <b class="spoiler_title">Trigonometric functions</b> <div class="spoiler_text">  type sinx = record <br>  x: polynomial; <br>  s: string; <br>  procedure nw; <br>  procedure derivative; // derivative <br>  end; <br>  type cosx = record <br>  x: polynomial; <br>  s: string; <br>  procedure nw; <br>  procedure derivative; // derivative <br>  end; <br>  type tgx = record <br>  x: polynomial; <br>  s: string; <br>  procedure nw; <br>  procedure derivative; // derivative <br>  end; <br>  type ctgx = record <br>  x: polynomial; <br>  s: string; <br>  procedure nw; <br>  procedure derivative; // derivative <br>  end; <br><br>  type lnx = record <br>  s: string; <br>  x: polynomial; <br>  procedure nw; <br>  procedure derivative; <br>  end; <br>  type ex = record <br>  s: string; <br>  f, x: polynomial; <br>  procedure nw; <br>  procedure derivative; <br>  end; <br></div></div><br>  I will make a reservation in advance that I will not use any trigonometric formulas further.  This will increase the complexity not only for the solution, but also for drawing up task diagrams. <br><br><h3>  Something about TeX </h3><br>  To simplify the work with TeX, a separate class was created to later put everything into a separate module. <br><br>  The class is responsible for: <br><br><ul><li>  Creating a new tex file (creation and introductory block) </li><li>  Line-by-line addition of text (at the end of the line will be a transition to a new line) </li><li>  Creating a new tex file </li><li>  Closing the tex file (closing block and stopping work with the file) </li><li>  Create pdf via Tex installed on computer </li><li>  Opening pdf file </li></ul><br><div class="spoiler">  <b class="spoiler_title">Module code</b> <div class="spoiler_text">  type tex = record <br>  namefl: string; <br>  procedure newtex (s: string); <br>  procedure add (s: string); <br>  procedure closetex; <br>  procedure createpdf; <br>  procedure openpdf; <br>  end; <br><br>  implementation <br><br>  procedure tex.newtex (s: string); <br>  var <br>  t: text; <br>  begin <br>  namefl: = s; <br>  assign (t, s + '. tex'); <br>  rewrite (t); <br>  writeln (t, '\ documentclass [12pt] {article}'); <br>  writeln (t, '\ usepackage {amsmath}'); <br>  writeln (t, '% \ usepackage [rus] {babel}'); <br>  writeln (t, '% \ usepackage [cp1251] {inputenc}'); <br>  writeln (t, '\ begin {document}'); <br>  close (t); <br>  end; <br>  procedure tex.add (s: string); <br>  var <br>  t: text; <br>  begin <br>  assign (t, namefl + '. tex'); <br>  append (t); <br>  writeln (t, '\ ['); <br>  writeln (t, s); <br>  writeln (t, '\]'); <br>  close (t); <br>  end; <br>  procedure tex.closetex; <br>  var <br>  t: text; <br>  begin <br>  assign (t, namefl + '. tex'); <br>  append (t); <br>  writeln (t, '\ end {document}'); <br>  close (t); <br>  end; <br>  procedure tex.createpdf; <br>  var <br>  p: System.Diagnostics.Process; <br>  begin <br>  p: = new System.Diagnostics.Process (); <br>  p.StartInfo.FileName: = 'pdflatex'; <br>  p.StartInfo.Arguments: = namefl + '. tex'; <br>  p.Start (); <br>  end; <br>  procedure tex.openpdf; <br>  var <br>  p: System.Diagnostics.Process; <br>  begin <br>  p: = new System.Diagnostics.Process (); <br>  p.StartInfo.FileName: = namefl + '. pdf'; <br>  p.Start (); <br>  end; <br></div></div><br><h3>  Task map </h3><br>  I will make a reservation in advance that the problem for the derivative and the integral are inverse, so that only one scheme for two problems is needed. <br><br><h4>  Limits </h4><br>  At the beginning of a course of mathematical analysis, the limits (with x-&gt; inf) most often appear: inf / inf, 0/0, inf-inf, a / inf, and a / b. <br><br>  Hence, the schemes of such tasks should check for understanding the difference for <s>lice</s> . <br><br><h5>  1. An example where the answer is zero </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/297/346/32e/29734632ef1e43b78d41b63060978509.png"></div><br>  The task is constructed as P1 (x) / P2 (x) * as x tends to the root P1 (x) (and is not a root of P2 (x)). <br><br>  * P1 (x) and P2 (x) polynomials with roots from 1 to 3 (sometimes 4th) degrees (random generation) <br><br><h5>  2. Zero in the denominator </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0d3/09d/deb/0d309ddeb4314d5bbea4c76f2dc8a5ea.png"></div><br>  Simple enough.  By analogy with the first example, there is zero in the denominator. <br><br><h5>  3. Zero in the numerator and denominator </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/356/501/bcb/356501bcb93f43c892726367e00830ed.png"></div><br>  Two polynomials with roots are constructed so that both P (x) have one root.  Then, when x tends to this root, the ratio will be 0/0.  Hence the need to differentiate P1 (x) and P2 (x) in order to find the correct answer. <br><br><h5>  4. Infinity minus infinity </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cbf/8b9/b0b/cbf8b9b0b2f14798863c121b7cc05eb7.png"></div><br>  An example of the principles of inf-inf, I decided to demonstrate the example of the roots (often found in books, but there are other examples). <br><br>  Here it is based on the fact that P3 (x) * and P4 (x) * are of one degree, and the solution is to multiply and divide by the conjugate. <br><br>  * P3 (x), P4 (x) - polynomials under the first degree root <br><br><h4>  Derivatives and integrals </h4><br><h5>  "Take and think" </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/621/44f/3ed/62144f3ede0b4760b6225b56c438317b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7be/065/12b/7be06512ba5a4bde8104f771d3ba3c4a.png"></div><br>  The examples are constructed as follows: the derivative of a function is taken (polynomial / trigonometric function) and its integral must be found (in fact, the function originally taken). <br><br><h5>  Method of a sly look </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/files/461/13a/0e3/46113a0e3915489ca8d78689d7de75f6.png"></div><br>  The task can be built in various ways.  One of them is to take the trigonometric function T (P (x)) (P (x) polynomial of the second or higher degree) and multiply T (P (x)) by the derivative P (x).  Such a technique must be able to notice, so as not to use the decomposition of the integral. <br><br><div class="spoiler">  <b class="spoiler_title">Task Generation Code</b> <div class="spoiler_text">  unit taskMath; <br><br>  interface <br>  uses mathUnit; <br><br>  type taskderivative = record <br>  task: string; <br>  answer: string; <br>  end; <br>  type tasklimits = record <br>  task: string; <br>  answer: string; <br>  end; <br><br>  function taskintegral1 (var s: string): string; <br><br>  function tasklimits1 (var s: string): string; <br>  function tasklimits2 (var s: string): string; <br>  function tasklimits3 (var s: string): string; <br>  function tasklimits4 (var s: string): string; <br><br>  function taskderivative1 (var s: string): string; <br>  function taskderivative2 (var s: string): string; <br><br>  procedure rand (var x: taskderivative); <br>  procedure rand (var x: tasklimits); <br><br>  implementation <br><br>  function correct (s: string): string; <br>  var i: integer; <br>  begin <br>  for i: = 1 to length (s) do <br>  case s [i] of <br>  '{': s [i]: = '('; <br>  '}': s [i]: = ')'; <br>  end; <br>  result: = s; <br>  end; <br><br>  function tasklimits1 (var s: string): string; <br>  var <br>  p1, p2: polynomialwithroot; <br>  i: integer; <br>  x: integer; <br>  rez: string; <br>  k1, k2, r1, r2: integer; <br>  begin <br>  randomize; <br>  p1.roots (random (1,3)); <br>  p2.roots (random (1,3)); <br>  i: = random (p1.st) -1; <br>  for i: = i downto 0 do <br>  p2.root [random (p2.st)]: = p1.root [random (p1.st)]; <br>  i: = random (p1.st) + random (p2.st); <br>  if (i&gt; p1.st-1) then <br>  begin <br>  x: = p2.root [i- (p1.st-1)]; <br>  end <br>  else <br>  x: = p1.root [i]; <br>  p1.nw; <br>  p2.nw; <br>  rez: = 'Find: \; lim_ {x \ to \!' + inttostr (x) + '} \ quad \ frac {' + p1.pltostr + '} {' + p2.pltostr + '}'; <br>  k1: = 0; <br>  k2: = 0; <br>  r1: = 1; <br>  r2: = 1; <br>  s: = 'When \;  abbreviations \; (x - '+ inttostr (x) +') \;  it turns out \; '; <br>  for i: = 0 to p1.st-1 do <br>  if (p1.kof [i] = x) then <br>  inc (k1) <br>  else <br>  r1: = r1 * (x-p1.kof [i]); <br>  for i: = 0 to p2.st-1 do <br>  if (p2.kof [i] = x) then <br>  inc (k2) <br>  else <br>  r2: = r2 * (x-p2.kof [i]); <br>  if (k1&gt; k2) then <br>  s: = '0'; // s: = s + 'null'; <br>  if (k2&gt; k1) then <br>  s: = 'inf'; // s: = s + 'null \;  at\;  denominator \;  and\;  it turns out \;  infinity'; <br>  if (k1 = k2) then <br>  s: = inttostr (r1) + '/' + inttostr (r2); // s: = s + 'number \;' + floattostr (r1 / r2); <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br>  function tasklimits2 (var s: string): string; <br>  var <br>  f: polynomialwithroot; <br>  g, x: polynomial; <br>  st: integer; <br>  rez, answ: string; <br>  begin <br>  f.roots (random (1,2)); <br>  g.nw (random (1,2)); <br>  x.nw (random (1,2)); <br>  st: = f.root [random (0, f.st-1)]; <br>  rez: = 'Find: \; lim_ {x \ to \!' + inttostr (st) + '} \ quad \ frac {' + (f * g) .pltostr + '} {' + (f * x) .pltostr + '}'; <br>  s: = floattostr (g.into (st)) + '/' + floattostr (x.into (st)); <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br>  function tasklimits3 (var s: string): string; <br>  var <br>  f, g: sqrnpolynomial; <br>  x: polynomial; <br>  rez, answ: string; <br>  begin <br>  f.nw (random (1,4), 2); <br>  g.nw (fxst, 2); <br>  x: = fx-gx; <br>  rez: = 'Find: \; lim_ {x \ to \ infty} \ quad' + f.s + '-' + gs; <br>  if (x.st + 1 = fxst) then <br>  s: = floattostr (x.kof [x.st]) + '/' + floattostr (gxkof [gxst] + fxkof [gxst]) <br>  else <br>  s: = '0'; <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br>  function tasklimits4 (var s: string): string; <br>  var <br>  f, g: polynomialwithroot; <br>  kf1, kf2: polynomial; <br>  a, i, j, num: integer; <br>  rez, add: string; <br>  begin <br>  f.roots (random (1,2)); <br>  g.roots (random ((f.st), 3)); <br>  num: = random (1, f.st-1); <br>  for i: = 0 to num-1 do <br>  g.root [i]: = f.root [i]; <br>  g.nw; <br>  // writeln (num); <br>  sleep (1000); <br>  num: = 0; <br>  for i: = 0 to f.st-1 do <br>  for j: = 0 to g.st-1 do <br>  if (f.kof [i] = g.kof [j]) then num + = 1; <br>  // writeln (num); <br>  // sleep (1000); <br>  kf1.nw (random (1,2)); <br>  kf2.nw (0); <br>  a: = random (2,5); <br>  add: = '\ frac {' + (kf1 + kf2) .pltostr + '} {' + kf1.pltostr + '}'; <br>  for i: = 1 to length (s) do <br>  if (add [i] = 'x') then add [i]: = 'n'; <br>  rez: = 'Find \;  x, \;  when: \; lim_ {n \ to \ infty} \ quad '+ <br>  add + '\ frac {(' + f.pltostr + ') ^ {n ^' + inttostr (a) + '}} {(' + g.pltostr + ') ^ {n ^' + inttostr (a) + '}} = e ^ {'+ floattostr (kf2.kof [0]) +'} '; <br>  s: = inttostr (num); <br>  result: = rez; <br>  end; <br><br>  function taskintegral1 (var s: string): string; <br>  var <br>  tr1: sinx; <br>  tr2: cosx; <br>  tr3: tgx; <br>  tr4: ctgx; <br>  f, g: polynomial; <br>  r: integer; <br>  rez: string; <br>  begin <br>  rez: = 'Find \; \ int'; <br>  r: = random (1,5); <br>  case r of <br>  1: begin <br>  tr1.x.nw (random (1,3)); <br>  tr1.nw; <br>  s: = tr1.s; <br>  tr1.derivative; <br>  rez: = rez + tr1.s + '\; dx'; <br>  end; <br>  2: begin <br>  tr2.x.nw (random (1,3)); <br>  tr2.nw; <br>  s: = tr2.s; <br>  tr2.derivative; <br>  rez: = rez + tr2.s + '\; dx'; <br>  end; <br>  3: begin <br>  tr3.x.nw (random (1,3)); <br>  tr3.nw; <br>  s: = tr3.s; <br>  tr3.derivative; <br>  rez: = rez + tr3.s + '\; dx'; <br>  end; <br>  4: begin <br>  tr4.x.nw (random (1,3)); <br>  tr4.nw; <br>  s: = tr4.s; <br>  tr4.derivative; <br>  rez: = rez + tr4.s + '\; dx'; <br>  end; <br>  5: begin <br>  r: = random (1,2); <br>  f.nw (random (1,3)); <br>  rez: = rez + '(' + f.pltostr + ')'; <br>  while (r &lt;&gt; 0) do <br>  begin <br>  g.nw (random (1,3)); <br>  f: = f * g; <br>  rez: = rez + '(' + g.pltostr + ')'; <br>  r: = r-1; <br>  end; <br>  f.integral; <br>  s: = correct (f.pltostr); <br>  rez: = rez + '\; dx'; <br>  end; <br>  end; <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br><br>  function taskderivative1 (var s: string): string; <br>  var <br>  sinx1, sinx2: sinx; <br>  cosx1, cosx2: cosx; <br>  tgx1, tgx2: tgx; <br>  ctgx1, ctgx2: ctgx; <br>  f, g: polynomial; <br>  r: integer; <br>  rez: string; <br>  bg, answ: string; <br>  begin <br>  randomize; <br>  sinx1.x.nw (random (1,3)); <br>  sinx1.nw; <br>  sinx2: = sinx1; <br>  sinx2.derivative; <br><br>  tgx1.x.nw (random (1,3)); <br>  tgx1.nw; <br>  tgx2: = tgx1; <br>  tgx2.derivative; <br><br>  cosx1.x.nw (random (1,3)); <br>  cosx1.nw; <br>  cosx2: = cosx1; <br>  cosx2.derivative; <br><br>  ctgx1.x.nw (random (1,3)); <br>  ctgx1.nw; <br>  ctgx2: = ctgx1; <br>  ctgx2.derivative; <br><br>  r: = random (1,4); <br>  case r of <br>  1: begin <br>  rez: = rez + sinx1.s; <br>  answ: = sinx2.s; <br>  end; <br>  2: begin <br>  rez: = rez + cosx1.s; <br>  answ: = cosx2.s; <br>  end; <br>  3: begin <br>  rez: = rez + tgx1.s; <br>  answ: = '(' + tgx2.x.pltostr + ') / (cos (' + tgx1.x.pltostr + ') ^ 2)'; <br>  end; <br>  4: begin <br>  rez: = rez + ctgx1.s; <br>  answ: = '(' + (- 1 * ctgx2.x) .pltostr + ')) / (sin (' + ctgx1.x.pltostr + ') ^ 2)'; <br>  end; <br>  end; <br>  bg: = rez; <br>  rez: = 'Find \;  \ frac {d} {dx} \; ('+ rez; <br>  rez: = rez + ')'; <br>  r: = random (1,2); <br>  f.nw (random (1,3)); <br>  while (r&gt; 0) do <br>  begin <br>  g.nw (random (1,3)); <br>  rez: = rez + '('; <br>  rez: = rez + g.pltostr; <br>  rez: = rez + ')'; <br>  f: = f * g; <br>  r: = r-1; <br>  end; <br>  rez: = rez + ')'; <br>  answ: = '(' + answ + ') * (' + g.pltostr + ') + ('; <br>  g.derivative; <br>  answ: = answ + bg + ') * (' + g.pltostr + ')'; <br>  s: = answ; <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br>  function taskderivative2 (var s: string): string; <br>  var <br>  sinx1, sinx2: sinx; <br>  cosx1, cosx2: cosx; <br>  tgx1, tgx2: tgx; <br>  ctgx1, ctgx2: ctgx; <br>  f, g, st: polynomial; <br>  r: integer; <br>  rez: string; <br>  answ, bg: string; <br>  begin <br>  randomize; <br>  sinx1.x.nw (random (1,3)); <br>  sinx1.nw; <br>  sinx2: = sinx1; <br>  sinx2.derivative; <br><br>  tgx1.x.nw (random (1,3)); <br>  tgx1.nw; <br>  tgx2: = tgx1; <br>  tgx2.derivative; <br><br>  cosx1.x.nw (random (1,3)); <br>  cosx1.nw; <br>  cosx2: = cosx1; <br>  cosx2.derivative; <br><br>  ctgx1.x.nw (random (1,3)); <br>  ctgx1.nw; <br>  ctgx2: = ctgx1; <br>  ctgx2.derivative; <br><br>  r: = random (1,4); <br>  case r of <br>  1: begin <br>  rez: = rez + sinx1.s; <br>  answ: = sinx2.s; <br>  end; <br>  2: begin <br>  rez: = rez + cosx1.s; <br>  answ: = cosx2.s; <br>  end; <br>  3: begin <br>  rez: = rez + tgx1.s; <br>  answ: = '(' + tgx2.x.pltostr + ') / (cos (' + tgx1.x.pltostr + ') ^ 2)'; <br>  end; <br>  4: begin <br>  rez: = rez + ctgx1.s; <br>  answ: = '(' + (- 1 * ctgx2.x) .pltostr + ')) / (sin (' + ctgx1.x.pltostr + ') ^ 2)'; <br>  end; <br>  end; <br>  bg: = rez; <br>  rez: = 'Find \;  \ frac {d} {dx} \; ('+ rez; <br>  rez: = rez + ') ^ {'; <br>  f.nw (random (1,3)); <br>  rez: = rez + f.pltostr + '}'; <br>  st: = f; <br>  st.derivative; <br>  answ: = '((' + bg + ') ^ {' + f.pltostr + '}) * ((' + st.pltostr + ') * ln (' + bg + ') + (' + f.pltostr + ') * ( '+ answ +') / ('+ bg +') '; <br>  s: = answ; <br>  s: = correct (s); <br>  result: = rez; <br>  end; <br>  procedure rand (var x: taskderivative); <br>  var <br>  r: integer; <br>  begin <br>  randomize; <br>  r: = random (1,2); <br>  case r of <br>  1: x.task: = taskderivative1 (x.answer); <br>  2: x.task: = taskderivative2 (x.answer); <br>  end; <br>  end; <br>  procedure rand (var x: tasklimits); <br>  var <br>  r: integer; <br>  begin <br>  randomize; <br>  r: = random (1,4); <br>  case r of <br>  1: x.task: = tasklimits1 (x.answer); <br>  2: x.task: = tasklimits2 (x.answer); <br>  3: x.task: = tasklimits3 (x.answer); <br>  4: x.task: = tasklimits4 (x.answer); <br>  end; <br>  end; <br><br>  end. <br></div></div><br><h3>  Summing up </h3><br>  There is a wide variety of typical techniques and examples, but for a minimum assessment of the material‚Äôs understanding, such a set rescued me a couple of times.  Of course, this set can be expanded and expanded, but this is everyone‚Äôs business. <br><br>  Link to the program: <a href="https://github.com/rlggut/Tex_Gen">GitHub</a> <br><br>  There are other tasks in that project that are not described in this article due to their ambiguous work (they are tested and updated). </div><p>Source: <a href="https://habr.com/ru/post/314924/">https://habr.com/ru/post/314924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314912/index.html">The nuances of the introduction of protection against DDoS-attacks</a></li>
<li><a href="../314916/index.html">How to calculate the approximate cost of development for 3 minutes</a></li>
<li><a href="../314918/index.html">Squid with HTTPS filtering without certificate spoofing, integration with Active Directory 2012R2 + WPAD</a></li>
<li><a href="../314920/index.html">ThinkPHP # 13 Mitap Announcement</a></li>
<li><a href="../314922/index.html">Mitap of the MSK.NET community in Kaspersky Lab</a></li>
<li><a href="../314926/index.html">12 cases by big date: confirmed examples from the industry when a big date brings money</a></li>
<li><a href="../314928/index.html">As Tesla Motors and SpaceX nearly disappeared in 2008</a></li>
<li><a href="../314930/index.html">Facebook introduced Backpack - the second generation of modular routers for data centers</a></li>
<li><a href="../314932/index.html">We write Rest API client on Qt5</a></li>
<li><a href="../314934/index.html">Deep Learning: Transfer learning and fine tuning of deep convolutional neural networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>