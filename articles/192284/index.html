<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 1: Getting Started with Boost.Asio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi habraedi! 
 This is my first post, so do not judge strictly. I want to start a free translation of the book John Torjo "Boost.Asio C ++ Network Pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 1: Getting Started with Boost.Asio</h1><div class="post__text post__text-html js-mediator-article">  Hi habraedi! <br>  This is my first post, so do not judge strictly.  I want to start a <b>free</b> translation of the book John Torjo "Boost.Asio C ++ Network Programming" is a <a href="http://www.amazon.com/Boost-Asio-Network-Programming-John-Torjo/dp/1782163263/ref%3Dsr_1_9%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1377848240%26sr%3D1-9%26keywords%3Dboost%2Bc%252B%252B">link</a> to it. <br><br>  Content: <br><ul><li>  <b>Chapter 1: Getting Started with Boost.Asio</b> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  First, let's look at what Boost.Asio is, how to build it, as well as a few examples.  You will find out that Boost.Asio is more than a network library.  As you learn about the most important class, which is located in the heart of Boost.Asio - <code>io_service</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  What is Boost.Asio? </h4><br>  In short, Boost. Asio is, for the most part, a cross-platform C ++ library for programming networks and some other low-level I / O programs. <br>  There are many implementations for solving network problems, but Boost.Asio outdid them all;  It was adopted in Boost in 2005 and has since been tested by a large number of Boost users. It is used in many projects, such as: <br><ul><li>  <a href="http://www.remobo.com/">Remobo</a> , allows you to create your own IPN </li><li>  <a href="http://www.rasterbar.com/products/libtorrent">libtorrent</a> , is a library that implements a bittorrent client </li><li>  <a href="http://www.pokerth.net/">PokerTH</a> , is a poker game with LAN and Internet support. </li></ul><br>  Boost.Asio successfully abstracts the concepts of input and output, which work not only for networking, but also for serial COM ports, files, and so on.  In addition, you can make input or output programming synchronous or asynchronous: <br><br><pre> <code class="cpp hljs">read(stream, buffer [, extra options]) async_read(stream, buffer [, extra options], handler) write(stream, buffer [, extra options]) async_write(stream, buffer [, extra options], handler)</code> </pre><br>  As you have noticed in the previous code snippet, functions accept a stream instance, which can be anything (not just a socket, we can read and write to it). <br>  The library is portable, runs on most operating systems, and scales well with more than a thousand simultaneous connections.  The network part was a follower of BSD (Berkeley Software Distribution) sockets.  An API is provided for working with TCP (Transmission Control Protocol) sockets, UDP (User Datagram Protocol) sockets, IMCP (Internet Control Message Protocol) sockets, the library is also extensible, so if you want, you can adapt it to your own protocol . <br><br><h4>  Story </h4><br>  Boost.Asio was adopted in Boost 1.35 in December 2005, after development began in 2003.  The original author is Christopher M. Kohlhoff (Christopher M. Kohlhoff), you can contact him at chris@kohlhoff.com. <br>  The library has been tested on the following platforms and compilers: <br><ul><li>  32-bit and 64-bit Windows using Visual C ++ 7.1 and higher </li><li>  Windows using MinGW </li><li>  Windows using Cygwin (make sure <code>__USE_232_SOCKETS</code> defined) </li><li>  Linux based on 2.4 and 2.6 kernels using g ++ 3.3 and higher </li><li>  Solaris using g ++ 3.3 and up </li><li>  MAC OS X 10.4+ using g ++ 3.3 and higher </li></ul><br>  It can also work on platforms such as AIX 5.3, HP-UX 11i v3, QNX Neutrino 6.3, Solaris, using Sun Studio 11+, True64 v5.1, Windows, using Borland C ++ 5.9.2+ (consult <a href="http://www.boost.org/">www .boost.org</a> for details). <br><br><h4>  Dependencies </h4><br>  Boost.Asio depends on the following libraries: <br><ul><li>  Boost.System: This library provides operating system support for the Boost library (http://www.boost.org/doc/libs/1_51_0/doc/html/boost_system/index.html) </li><li>  Boost.Regex: this library (option) is used if you use <code>read_until()</code> or <code>async_read_until()</code> , which accept the <code>boost::regex</code> parameter </li><li>  Boost.DateTime: this library (option) is used if you use Boost.Asio timers </li><li>  OpenSSL: this library (option) is used if you decide to use SSL support provided by Boost.Asio </li></ul><br><br><h4>  Build Boost.Asio </h4><br>  Boost.Asio is a purely header library.  However, depending on the compiler and the size of your program, you can choose to create Boost.Asio as the source file.  You can do this to reduce compile time.  This can be done in the following ways: <br><ul><li>  Only in one of your files, using <code>#include &lt;boost/asio/impl/src.hpp&gt;</code> (if you use SSL, then <code>#include &lt;boost/asio/ssl/impl/src.hpp&gt;</code> ) </li><li>  Using <code>#define BOOST_ASIO_SEPARATE_COMPILATION</code> in all of your source files </li></ul><br>  Note that Boost.Asio depends on Boost.System and not necessarily on Boost.Regex, so you need to at least build a boost library using the following code: <br><br><pre> <code class="bash hljs">bjam ‚Äìwith-system ‚Äìwith-regex stage</code> </pre><br>  If you also want to build tests, you should use the following code: <br><br><pre> <code class="bash hljs">bjam ‚Äìwith-system ‚Äìwith-thread ‚Äìwith-date_time ‚Äìwith-regex ‚Äìwithserialization stage</code> </pre><br>  The library comes with many examples that you can check, along with the examples that are provided in this book. <br><br><h4>  Important Macros </h4><br>  Use <code>BOOST_ASIO_DISABLE_THREADS</code> , if installed;  it disables support for threads in Boost. Asio, regardless of whether Boost was compiled with support for threads. <br><br><h4>  Synchronous vs. Asynchronous </h4><br>  First, asynchronous programming is extremely different from synchronous programming.  In synchronous programming, all operations you do in sequential order, such as reading (query) from socket S, and then writing (response) to the socket.  Each of the operations is blocking.  Since the operations are blocking, in order not to interrupt the main program while you are reading or writing to the socket, you usually create one or more threads that deal with I / O sockets.  Thus, synchronous server / clients are usually multi-threaded. <br>  Asynchronous programs, on the other hand, are event driven.  You start the operation, but you do not know when it will end;  You provide a <code>callback</code> function that will be called by the API with the result of the operation when the operation is completed.  For programmers who have extensive experience with QT - Nokia‚Äôs cross-platform library for creating graphical user interface applications, this is second nature.  Thus, in asynchronous programming, you do not need to have more than one stream. <br>  You must decide at an early stage of your project (preferably at the beginning) which approach you will use: synchronous or asynchronous, since switching halfway will be difficult and error prone;  not only the API is significantly different, the semantics of your program will be greatly changed (asynchronous networks are usually harder to test and debug than synchronous ones).  Think before you want to use either blocking calls and many threads (synchronous, as a rule, easier), or few threads and events (asynchronous, as a rule, more complex). <br>  Here is a simple example of a synchronous client: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> boost::asio; io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.connect(ep);</code> </pre><br>  First, your program must have an instance of <code>io_service</code> .  Boost.Asio uses <code>io_service</code> to communicate with the operating system I / O service.  Usually one instance of <code>io_service</code> is enough.  Next, create the address and port to which you want to connect.  Create a socket.  Connect the socket to your address and port: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Here is a simple synchronous server:using boost::asio; typedef boost::shared_ptr&lt;ip::tcp::socket&gt; socket_ptr; io_service service; ip::tcp::endpoint ep( ip::tcp::v4(), 2001)); // listen on 2001 ip::tcp::acceptor acc(service, ep); while ( true) { socket_ptr sock(new ip::tcp::socket(service)); acc.accept(*sock); boost::thread( boost::bind(client_session, sock)); } void client_session(socket_ptr sock) { while ( true) { char data[512]; size_t len = sock-&gt;read_some(buffer(data)); if ( len &gt; 0) write(*sock, buffer("ok", 2)); } }</span></span></code> </pre><br>  Again, your first program must have at least one instance of <code>io_service</code> .  Then you specify the listening port and create an acceptor (receiver) - one object that accepts client connections. <br>  In the next cycle, you create a dummy socket and wait for the client to connect.  After the connection is established, you create a thread that will deal with this connection. <br>  In the stream, in the <code>client_session</code> function <code>client_session</code> you listen to client requests, interpret them, and respond. <br>  To create a simple asynchronous client, you will do something similar to the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> boost::asio; io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.async_connect(ep, connect_handler); service.run(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp; ec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// here we know we connected successfully // if ec indicates success }</span></span></code> </pre><br>  Your program must have at least one <code>io_service</code> instance.  You specify where the socket is connected and created.  Then, as soon as the connection is established, you connect asynchronously to the address and port (this is the completion of the handler), that is, <code>connect_handler</code> is called. <br>  After calling <code>connect_handler</code> check the error code ( <code>ec</code> ), and if successful, you can write to the server asynchronously. <br>  Note that the <code>service.run()</code> loop will be executed as long as there are incomplete asynchronous operations.  In the previous example, there is only one such operation, this is the socket <code>async_connect</code> .  After this, <code>service.run()</code> terminates. <br>  Each asynchronous operation has a terminating handler, a function that will be called when the operation is completed. <br>  The following code is a simple asynchronous server: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> boost::asio; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ip::tcp::socket&gt; socket_ptr; io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::tcp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// listen on 2001 ip::tcp::acceptor acc(service, ep); socket_ptr sock(new ip::tcp::socket(service)); start_accept(sock); service.run(); void start_accept(socket_ptr sock) { acc.async_accept(*sock, boost::bind( handle_accept, sock, _1) ); } void handle_accept(socket_ptr sock, const boost::system::error_code &amp; err) { if ( err) return; // at this point, you can read/write to the socket socket_ptr sock(new ip::tcp::socket(service)); start_accept(sock); }</span></span></code> </pre><br>  In the previous code snippet, first, you create an instance of <code>io_service</code> .  Then you specify the port to listen on.  Then you create an acceptor ‚Äî an object for accepting client connections, as well as creating a dummy socket and asynchronously waiting for a client connection. <br>  Finally, run the asynchronous <code>service.run()</code> loop.  When the client connects, <code>handle_accept</code> is <code>handle_accept</code> (the final handler for calling <code>async_accept</code> ).  If there are no errors, then you can use this socket for read / write operations. <br>  After using the socket, you create a new socket and call <code>start_accept()</code> again, which adds a similar asynchronous operation ‚Äúwaiting for client connection‚Äù, leaving the <code>service.run()</code> loop busy. <br><br><h4>  Exceptions against error codes </h4><br>  Boost.Asio allows you to use both exceptions and error codes.  All synchronous functions have overloading throwing exceptions due to an error or return an error code.  If the function fails, then it throws an error <code>boost::system::system_error</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> boost::asio; ip::tcp::endpoint ep; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.connect(ep); <span class="hljs-comment"><span class="hljs-comment">// Line 1 boost::system::error_code err; sock.connect(ep, err); // Line 2</span></span></code> </pre><br>  In the previous code, <code>sock.connect(ep)</code> threw an exception in case of an error and <code>sock.connect(ep, err)</code> would return an error code. <br>  Take a look at the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sock.connect(ep); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(boost::system::system_error e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e.code() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  The following piece of code is similar to the previous one: <br><br><pre> <code class="cpp hljs">boost::system::error_code err; sock.connect(ep, err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; err &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  In case you use asynchronous functions, they all return an error code, which you can check in your callback function.  Asynchronous functions never throw exceptions and it makes no sense to do this.  And who will catch him? <br>  In your synchronous functions, you can use both exceptions and error codes (which you want more), but use something else.  Mixing them up can lead to problems or even a fall (when you forget to handle an exception by mistake).  If your code is complex (the read / write functions in the socket are called), then you probably prefer to use exceptions and perform read and write functions in the <code>try {} catch</code> block. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket_ptr sock)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> ( boost::system::system_error e) { <span class="hljs-comment"><span class="hljs-comment">// handle the error } }</span></span></code> </pre><br>  If you use error codes, you may well see when the connection is closed, as shown in the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; boost::system::error_code error; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = sock.read_some(buffer(data), error); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error == error::eof) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Connection closed</span></span></code> </pre><br>  All Boost.Asio error codes are in the namespace <code>boost::asio::error</code> (in case you want to do a full brute force search for a fault).  You can also check <code>boost/asio/error.hpp</code> for more details. <br><br><h4>  Streams in Boost.Asio </h4><br>  When it comes to threads in Boost.Asio, we need to talk about the following: <br><ul><li>  <code>io_service</code> : The <code>io_service</code> class is thread safe.  Multiple threads can call <code>io_service::run()</code> .  Most often, you probably call <code>io_service::run()</code> from one thread, so the function waits until all blocking asynchronous functions are executed.  However, you can call <code>io_service::run()</code> from multiple threads.  This blocks all threads that will call <code>io_service::run()</code> .  All callback functions will be called in context of all threads that called <code>io_service::run()</code> ;  it also means that if you called <code>io_service::run()</code> , only in one thread, then all callback functions will be called in the context of this thread. </li><li>  <code>socket</code> : <code>socket</code> classes are not thread safe.  Thus, you should avoid situations like reading from a socket in one thread and writing to it in another (this is recommended generally, not to mention Boost.Asio). </li><li>  <code>utility</code> : <code>utility</code> classes usually do not make sense to use in multiple threads, they are not thread safe.  Most of them are used for a short time and then go out of scope. </li></ul><br>  The Boost.Asio library itself can use several threads besides yours, but it is guaranteed that your code will not be called from these threads.  This in turn means that the callback functions will be called only in those threads where <code>io_service::run()</code> called from. <br><br><h4>  Not only networks </h4><br>  Boost.Asio provides other I / O objects in addition to networks. <br>  Boost.Asio allows you to use such signals as <code>SIGTERM</code> (end the program), <code>SIGINT</code> (signal interruption), SIGSEGV (segment violation) and others. <br>  You create an instance of <code>signal_set</code> and specify which signals to wait asynchronously and when one of them happens, your asynchronous handler will be called: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// log this, and terminate application } boost::asio::signal_set sig(service, SIGINT, SIGTERM); sig.async_wait(signal_handler);</span></span></code> </pre><br>  If <code>SIGINT</code> generated, you will be <code>signal_handler</code> . <br>  Using Boost.Asio, you can easily connect to the serial port.  COM7 port name on Windows or / dev / ttyS0 on POSIX platforms: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-function"><span class="hljs-function">serial_port </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"COM7"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  After opening, you can set some parameters, such as port data rate, parity, stop bits, as indicated in the following code snippet: <br><br><pre> <code class="cpp hljs">serial_port::<span class="hljs-function"><span class="hljs-function">baud_rate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">9600</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; sp.set_option(rate);</code> </pre><br>  If the port is open, you can process it in the stream, and it is recommended to use free functions for reading and / or writing to the serial port, for example, <code>read()</code> , <code>async_read()</code> , <code>write()</code> , <code>async_write()</code> , as shown in following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; read(sp, buffer(data, <span class="hljs-number"><span class="hljs-number">512</span></span>));</code> </pre><br>  Boost.Asio also allows you to connect to Windows files and again use free functions, such as <code>read()</code> , <code>asyn_read()</code> and others, as shown below: <br><br><pre> <code class="cpp hljs">HANDLE h = ::OpenFile(...); windows::<span class="hljs-function"><span class="hljs-function">stream_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, h)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; read(h, buffer(data, <span class="hljs-number"><span class="hljs-number">512</span></span>));</code> </pre><br>  You can do the same with POSIX file descriptors, such as pipes, standard I / O, various devices (but not ordinary files), as is done in the following snippet: <br><br><pre> <code class="cpp hljs">posix::<span class="hljs-function"><span class="hljs-function">stream_descriptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sd_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ::dup(STDIN_FILENO))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; read(sd_in, buffer(data, <span class="hljs-number"><span class="hljs-number">512</span></span>));</code> </pre><br><br><h4>  Timers </h4><br>  Some I / O operations may have time constraints to complete.  You can only apply this to asynchronous operations (since synchronous locking tools have no time limit).  For example, the following message from your partner should come to you in 100 milliseconds: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> read = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deadline_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; (read ? <span class="hljs-string"><span class="hljs-string">"read successfully"</span></span> : <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;)</span></span></span><span class="hljs-function"> </span></span>{ read = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; ‚Ä¶ read = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; sock.async_read_some(buffer(data, <span class="hljs-number"><span class="hljs-number">512</span></span>)); <span class="hljs-function"><span class="hljs-function">deadline_timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, boost::posix_time::milliseconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; t.async_wait(&amp;deadline_handler); service.run();</code> </pre><br>  In the previous code snippet, if we read our data before the end of time, <code>read</code> set to <code>true</code> , then our partner got to us in time.  Otherwise, when <code>deadline_handler</code> is called, <code>read</code> is still set to <code>false</code> , which means that we have not been contacted until the end of the allotted time. <br>  Boost.Asio allows you to use synchronous timers, but, usually, they are equivalent to a simple <code>sleep</code> operation.  <code>boost::this_thread::sleep(500);</code>  and the following fragment will do the same: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">deadline_timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, boost::posix_time::milliseconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; t.wait();</code> </pre><br><br><h4>  Class <code>io_service</code> </h4><br>  You have already seen that most of the code that uses Boost.Asio will use some instance of <code>io_service</code> .  <code>io_service</code> is the most important class in the library, it deals with the operating system, waits for the end of all asynchronous operations, and then at the end it calls the handler for each such operation. <br>  If you decide to create your application synchronous, then you do not need to worry about what I am going to show in this section. <br>  You can use an <code>io_service</code> instance <code>io_service</code> several ways.  In the following examples, we have three asynchronous operations, two connected sockets, and a wait timer: <br><ul><li>  One thread with one <code>io_service</code> instance and one handler: <br><br><pre> <code class="cpp hljs">io_service service_; <span class="hljs-comment"><span class="hljs-comment">// all the socket operations are handled by service_ ip::tcp::socket sock1(service_); // all the socket operations are handled by service_ ip::tcp::socket sock2(service_); sock1.async_connect( ep, connect_handler); sock2.async_connect( ep, connect_handler); deadline_timer t(service_, boost::posix_time::seconds(5)); t.async_wait(timeout_handler); service_.run();</span></span></code> </pre><br></li><li>  Many threads with one <code>io_service</code> instance and several handlers: <br><br><pre> <code class="cpp hljs">io_service service_; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_)</span></span></span></span>; sock1.async_connect( ep, connect_handler); sock2.async_connect( ep, connect_handler); <span class="hljs-function"><span class="hljs-function">deadline_timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_, boost::posix_time::seconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; t.async_wait(timeout_handler); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) boost::thread( run_service); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ service_.run(); }</code> </pre><br></li><li>  Many threads with multiple <code>io_service</code> instances and multiple handlers: <br><br><pre> <code class="cpp hljs">io_service service_[<span class="hljs-number"><span class="hljs-number">2</span></span>]; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; sock1.async_connect( ep, connect_handler); sock2.async_connect( ep, connect_handler); <span class="hljs-function"><span class="hljs-function">deadline_timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">], boost::posix_time::seconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; t.async_wait(timeout_handler); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++i) boost::thread( boost::bind(run_service, i)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ service_[idx].run(); }</code> </pre><br></li></ul><br>  First of all, note that you cannot have multiple instances of <code>io_service</code> in the same thread.  It makes no sense to write the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++i) service_[i].run();</code> </pre><br>  The previous code doesn‚Äôt make any sense, because <code>service_[1].run()</code> will require <code>service_[0].run()</code> when you close the first one.  So all asynchronous <code>service_[1]</code> operations <code>service_[1]</code> will have to wait for processing, which is not a good idea. <br>  In all three previous examples, we waited for three asynchronous operations to complete.  To explain the differences, we will assume that, some time later, operation 1 will end and operation 2 will be completed immediately after that. We also assume that each handler will need a second to complete. <br>  In the first case, we are waiting for the completion of all three operations in one thread.  After the first operation is completed, we call its handler.  Even if operation 2 completes immediately after the first one, we will have to wait a second to call its handler after the first operation completes. <br>  In the second case, we are waiting for the completion of three operations in two threads.  After the completion of the first operation, we call its handler in the first thread.     2,          (      ,     ,          ). <br>   ,   1  <code>connect</code>  <code>sock1</code>   2 <code>connect</code>  <code>sock2</code> ,          .      <code>connect</code>  <code>sock1</code> ,    ‚Äì  <code>connect</code>  <code>sock2</code> . ,   <code>sock1</code>   1  - <code>deadline_timer t</code>   2,        <code>connect</code>  <code>sock1</code> .  ,  - <code>deadline_timer t</code>      <code>connect</code>  <code>sock1</code> (    ),         <code>sock1</code> ,    - <code>t</code> . <br>        : <br><ul><li>  1   .      ,               .        ,     . </li><li>  2   .   ,               .     ,               .   ,         -. </li><li>  3      .      ,   2 .    ,         ().   ,   - (,  <code>io_service::run()</code> )     <code>select/epoll</code> ;    ,   /          .        ,      ,      ( 1000 ).       <code>select/epoll</code>    . </li></ul><br>   ,    -    3,  ,    (,   <code>io_service::run()</code> )    ,      . <br>    ,  <code>.run()</code>   ,      ,     : <br><br><pre> <code class="cpp hljs">io_service service_; tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_)</span></span></span></span>; sock.async_connect( ep, connect_handler); service_.run();</code> </pre><br>           <code>connect_handler</code>  <code>service.run()</code> . <br>   ,  <code>service.run()</code>  ,      .      .        <code>connect_handler</code> ,     . <br>        ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;io_service::work&gt; work_ptr; <span class="hljs-function"><span class="hljs-function">work_ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dummy_work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> io_service::work(service_))</span></span></span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code will provide a permanent job </font></font><code>service_.run()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until you call </font></font><code>useservice_.stop()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>dummy_work.reset(0); // destroy dummy_work</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4>  Summary. </h4><br> Boost.Asio   ,      .   .    ,   ;       /,    ,    . <br> Boost.Asio       .          -     ,         . <br>     ,         ,        ,         ( ). <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Asio is not only for programming networks. </font><font style="vertical-align: inherit;">This library has several features that make it more valuable, such as signals, timers, and so on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next chapter, we will delve into the many functions and classes Boost.Asio provides networks. </font><font style="vertical-align: inherit;">In addition, we learn a few tricks about asynchronous programming. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that's all for today, if you liked it, then I will gladly continue the translation. </font><font style="vertical-align: inherit;">Write about all comments in the comments.</font></font><br><br>  Good luck to all! <br><habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/192284/">https://habr.com/ru/post/192284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192272/index.html">Calculation of the intersection area of ‚Äã‚Äãthe circles by the Monte Carlo method</a></li>
<li><a href="../192274/index.html">Channel balancing - two providers, AS, BGP, NAT</a></li>
<li><a href="../192276/index.html">Electronic libraries at work and at home</a></li>
<li><a href="../192280/index.html">Spiceworks. Part 1: Online Inventory</a></li>
<li><a href="../192282/index.html">Google Chrome Anniversary - 5 years</a></li>
<li><a href="../192286/index.html">Automation testing software systems</a></li>
<li><a href="../192288/index.html">Combining Easel.js and Box2d on Canvas</a></li>
<li><a href="../192294/index.html">0day in the Any.DO extension - access to data on all sites (bypass gmail 2-steps auth). Public disclosure. ~ 500 thousand users affected</a></li>
<li><a href="../192296/index.html">10 Tips for a Freelance Customer</a></li>
<li><a href="../192298/index.html">And let's help them, blocking content and sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>