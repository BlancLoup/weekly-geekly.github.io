<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Handling collisions with an algorithm and implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Recently saw an article about handling collisions. And there was not the most important thing - the algorithm and implementation. Let's f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Handling collisions with an algorithm and implementation</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Recently saw an article about handling collisions.  And there was not the most important thing - the algorithm and implementation.  Let's fill this gap and look at how to find and handle collisions.  The implementation will be in Java. <br>  I warn you that the article has a lot of code. <br><br> <a href="http://habrahabr.ru/post/257655/"><img src="https://habrastorage.org/files/ead/37a/577/ead37a57744d4b75b29830e6a2a1d696.jpg"></a> <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  A bit of theory </h1><br>  The algorithm is based on the separating axis theorem.  For a 3D case, this is the dividing plane. <br>  The definition will be this: if there is a plane (for a 2D straight line) between two convex figures, in relation to which the figures lie on opposite sides, then such figures do not overlap. <br><br>  The consequence, with the help of which it is possible to check the dividing plane or not: if we take our dividing plane and build a perpendicular to it, then the projections of the figures on the resulting plane will also not be stopped. <br><br>  In order to find (or not find if the figures intersect) the dividing plane, it is necessary to assemble the normals of the sides and build perpendiculars to them.  These perpendiculars will be normals of the planes on which it will be necessary to build projections of models.  In this case, we do not need to know the coordinates of the plane; we will assume that they all pass through the center.  The figure below shows the verification of one of the parties. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/231/cfe/ff8/231cfeff843d49848733fa4d526bf993.png"></div><br>  Green indicates the normal of the side of the figure that is checked.  Red is the dividing plane.  The blue plane on which we must build projections.  As you can see, if we take the normal of the blue plane, then it will be perpendicular to the normal of the side we are testing. <br><br>  Now we have two projections of models on each plane.  It is necessary to find at least one plane where the projections do not intersect.  To do this, you can apply the same theorem, only for the 2D case (more details in the implementation).  If we find one, then the models do not overlap.  Accordingly, if we do not find - overlap. <br><br><h1>  Algorithm </h1><br>  Based on the theory, you can make the following algorithm works: <br><br><ul><li>  Find all the normals of the objects.  (we collect normals from both objects) </li><li>  Normally we find planes on which we will build projections. </li></ul><br><br>  Then we work separately with each plane. <br><br><ul><li>  We are looking for projection models on the plane. </li><li>  Check whether the projections intersect.  If not, then our objects also do not overlap. </li></ul><br><br>  Algorithm for checking the intersection of projections: <br><br>  We collect all sides of the projections and then work with them. <br><br><ul><li>  We are looking for perpendicular to the side. </li><li>  We build on this perpendicular projection of figures.  If the projections do not intersect, then our figures also. </li></ul><br><br><h1>  Implementation </h1><br>  Next we analyze the full implementation of finding and processing intersections. <br><br>  A small digression: <br>  I will not shorten the laid out code (the devil is in the details), just add comments, maybe I will not post any methods that interest you, but they can be easily found in the repository on <a href="https://github.com/Nirklav/Tanks">GitHub</a> , I will also leave links to classes. <br><br>  Following the algorithm, let's start with the search for all planes.  It is assumed that we know the normals (loaded them from the model file). <br>  It is very important to weed out the same planes, the algorithm is very difficult in terms of costs, and any optimization will be appropriate.  In this case, it is not any, and a decrease in the number of checked planes greatly affects its speed. <br>  For the physical models in the game, I use only parallelepipeds, no complex shapes.  As a result, in the worst case, we will check 6 planes. <br><br>  Before you begin, consider the interface that I will use below. <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollidable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //       ,     . float getRadius(); Vector3 getPosition(); ArrayList&lt;Vector2&gt; getConvexHull(Plane plane); //     (   ) ArrayList&lt;Vector3&gt; getNormals(); void normalizeLocation(); }</span></span></code> </pre> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ArrayList&lt;Plane&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlanes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ICollidable firstPh, ICollidable secondPh)</span></span></span><span class="hljs-function"> </span></span>{ ArrayList&lt;Plane&gt; planes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList&lt;Vector3&gt; firstNormals = firstPh.getNormals(); ArrayList&lt;Vector3&gt; secondNormals = secondPh.getNormals(); Plane plane = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plane(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = firstNormals.size() + secondNormals.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { setPlane(plane, firstNormals, secondNormals, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!planes.contains(plane)) planes.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plane(plane)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> planes; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plane plane, ArrayList&lt;Vector3&gt; firstNormals, ArrayList&lt;Vector3&gt; secondNormals, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     (      x, y ) if (num &lt; firstNormals.size()) plane.setFrom(firstNormals.get(num)); else { num -= firstNormals.size(); plane.setFrom(secondNormals.get(num)); } //   . plane.swapZY(); }</span></span></code> </pre><br><br>  Class source code <a href="">Plane</a> , <a href="">Vector3</a> <br><br>  So, we have planes that need to be checked.  To do this, we construct projections of models on each plane.  If we do not find the planes on which the projections do not intersect, then we need to find the plane on which the models intersect the least of all, we need to extract a vector from this intersection.  This will be the vector on which it is necessary to move one of the models so that they no longer intersect. <br><br>  Vector we initially get on the plane.  Therefore, although the direction of the axes of the X and Y planes is not important to us, however, we must save them, since the vector will need to be returned to 3D and they will be useful to us. <br><br>  Class implementing the search for the intersection of models: <a href="">Collision3D</a> <br>  Code executing the algorithm above: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CheckResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ICollidable firstPh, ICollidable secondPh)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ArrayList&lt;Plane&gt; planes = getPlanes(firstPh, secondPh); Collision2D min = null; Plane minPlane = new Plane(); for (Plane plane : planes) { //     . ArrayList&lt;Vector2&gt; resultOne = firstPh.getConvexHull(plane); ArrayList&lt;Vector2&gt; resultTwo = secondPh.getConvexHull(plane); //     . (       "check") Collision2D collision = new Collision2D(resultOne, resultTwo); Vector.release(resultOne); Vector.release(resultTwo); if (!collision.isCollide()) return null; //          if (min == null || collision.getMTVLength() &lt; min.getMTVLength()) { min = collision; minPlane.setFrom(plane); } plane.release(); } return new CheckResult(min, minPlane); }</span></span></code> </pre><br><br>  Let us consider in more detail how we get the projections.  <a href="">Here is the full implementation.</a> <br>  Actually finding the projection itself is not difficult, but there will be no sense from the projection itself.  For further processing it is necessary to correctly find the sides of the figure.  It should also be convex, the picture below explains why. <br><br><table><tbody><tr><td>  Voguntaya <div style="text-align:center;"><img src="https://habrastorage.org/files/155/18b/20f/15518b20fc1e4a3d98b1a2dad1a70c3d.png"></div></td><td>  Convex <div style="text-align:center;"><img src="https://habrastorage.org/files/b44/268/b63/b44268b63bce48c8bc29744d76ccc049.png"></div></td></tr></tbody></table><br>  As can be seen in the first figure (with a concave figure), the algorithm considers that the figures intersect, although we can construct a separating axis.  Since the axis is searched from the sides of the figure, there is no parallel side to the axis in this case.  In the second figure, an <abbr title="Minimally convex hull">MBO is</abbr> drawn up along the concave figure.  Here the algorithm will find the axis.  To find the shell, I implemented the Graham algorithm. <br><br>  Below is the function of finding a simple projection ‚Äî a set of points projected onto a plane. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ArrayList&lt;Vector2&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDistinctProjection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plane plane)</span></span></span><span class="hljs-function"> </span></span>{ Vector2 vector = Vector.getInstance(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     HashSet         (   ) ArrayList&lt;Vector2&gt; result = new ArrayList&lt;&gt;(); for (Vector3 current : vertices) { plane.getProjection(vector, current); if (!result.contains(vector)) //     { Vector2 copy = Vector.getInstance(2, vector); result.add(copy); } } Vector.release(vector); return result; } //    Plane: public void getProjection(Vector2 result, Vector3 vector) { throwIfReleased(); float x = vector.getX() * xAxis.getX() + vector.getY() * xAxis.getY() + vector.getZ() * xAxis.getZ(); float y = vector.getX() * yAxis.getX() + vector.getY() * yAxis.getY() + vector.getZ() * yAxis.getZ(); result.setFrom(x, y); }</span></span></code> </pre><br><br>  Now it's time to look at the implementation of building an <abbr title="Minimally convex hull">MBO</abbr> . <br>  Action can be painted on four steps. <br><ol><li>  Search projection. </li><li>  Selection of the reference point. </li><li>  Sort the remaining points relative to the reference. </li><li>  Remove extra points. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Little about mvo</b> <div class="spoiler_text">  Wikipedia says that: <br><blockquote>  The convex hull of a set X is the smallest convex set containing X. ‚ÄúLeast set‚Äù here means the smallest element with respect to the embedding of sets, that is, such a convex set containing this shape that it is contained in any other convex set containing this shape. </blockquote><br><br>  Also there is an example: <br><blockquote>  Imagine a board into which you have driven - but not to the bit of a hat - many nails.  Take a rope, tie a sliding loop (lasso) on it and throw it on the board, and then tighten it.  The rope surrounds all the nails, but it concerns only some of the most external.  Those nails, which it concerns, constitute a convex shell for the entire group of nails [1]. <br></blockquote><br><br>  Good article on <a href="http://habrahabr.ru/post/144921/">building a minimal convex hull</a> . <br></div></div><br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ArrayList&lt;Vector2&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConvexHull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plane plane)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ArrayList&lt;Vector2&gt; projection = getDistinctProjection(plane); ArrayList&lt;Vector2&gt; convexHull = new ArrayList&lt;&gt;(projection.size()); if (projection.size() &lt; 2) throw new IllegalStateException("projection size less than 2"); //   ,  100%    //      //     ,  . int firstIndex = getFirstPointIndex(projection); Vector2 first = projection.remove(firstIndex); convexHull.add(first); //       Collections.sort(projection, new AngleComparator(first)); //   , ..      . Vector2 second = projection.remove(0); convexHull.add(second); Vector2 prevVector = Vector.getInstance(2); Vector2 currentVector = Vector.getInstance(2); for(Vector2 current : projection) { Vector2 firstPrevPoint = convexHull.get(convexHull.size() - 1); Vector2 secondPrevPoint = convexHull.get(convexHull.size() - 2); //   prevVector.setFrom(firstPrevPoint); prevVector.subtract(secondPrevPoint); //   currentVector.setFrom(current); currentVector.subtract(firstPrevPoint); //         ,     float angle = prevVector.getAngle(currentVector); if (angle &gt;= 180 &amp;&amp; angle &lt; 360) convexHull.remove(convexHull.size() - 1); //     convexHull.add(current); } Vector.release(prevVector); Vector.release(currentVector); return convexHull; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">getAngle</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//     Vector2 public float getAngle(Vector2 other) { throwIfReleased(); float scalar = getScalar(other); float lengthOne = this.getLength(); float lengthTwo = other.getLength(); float angle = (float)Math.toDegrees(Math.acos(scalar / (lengthOne * lengthTwo))); return Angle.correct(getCross(other) &gt; 0 ? angle : 360 - angle); }</span></span></code> </pre><br></div></div><br><br>  The first point that should be included in the MBO, I choose the rightmost.  If there are more than one, then choose the top one. <br><div class="spoiler">  <b class="spoiler_title">Select the first point</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstPointIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;Vector2&gt; projection)</span></span></span><span class="hljs-function"> </span></span>{ Vector2 minVector = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minVectorIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = projection.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { Vector2 current = projection.get(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minVector == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { minVector = current; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compareX = Float.compare(current.getX(), minVector.getX()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { minVector = current; minVectorIndex = i; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareX == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compareY = Float.compare(current.getY(), minVector.getY()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareY == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"projection has the same points"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compareY &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { minVector = current; minVectorIndex = i; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> minVectorIndex; }</code> </pre><br></div></div><br><br>  The most buggy place I had was sorting the points counterclockwise.  In the beginning there were just incorrect implementations, and then it took a lot of time to understand what exceptional situations there are.  For myself, even the comments written, so as not to forget what's what. <br><br>  Sort the points relative to the first in the corners.  If the points are equal angles, then I compare them in distance from the first one and in different ways depending on how the points lie - above or below the reference.  If lower, then the first must go to the one to which the distance is less.  If higher - the opposite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/28e/002/cc4/28e002cc416842fea6bd85599f228b42.png"></div><br>  The blue dot is the reference.  Green - the usual points.  Red - with the same angles.  The traversal scheme demonstrates the sorting algorithm described above. <br><br>  You also need to remember to normalize the corners for normal sorting, there will be an example in the code. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AngleComparator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 first; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 left; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AngleComparator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector2 first)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = first; left = Vector.getInstance(<span class="hljs-number"><span class="hljs-number">2</span></span>); right = Vector.getInstance(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector2 lhs, Vector2 rhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     //     left.setFrom(lhs); left.subtract(first); right.setFrom(rhs); right.subtract(first); //      float firstAngle = Vector2.xAxis.getAngle(left); float secondAngle = Vector2.xAxis.getAngle(right); //      // : 15, 45, 315, 345 () =&gt; -45, -15, 15, 45 () if (firstAngle &gt; 90) firstAngle -= 360; if (secondAngle &gt; 90) secondAngle -= 360; //          //              //          . //   ,     //       if (Math.abs(firstAngle - secondAngle) &lt;= Vector.epsilon) { float leftLength = left.getLength(); float rightLength = right.getLength(); //    0,    if (firstAngle &gt;= 0) return Float.compare(rightLength, leftLength); return Float.compare(leftLength, rightLength); } //          return Float.compare(firstAngle, secondAngle); } }</span></span></code> </pre><br><br>  With the search for the projection figured out, it is now necessary to understand how to find the intersection of two projections.  The logic remains the same as with 3D. <br><br>  Further I will call these projections figures, because how to build further we will be projections of projections, I apologize for the tautology. <br><br>  Looking through all sides of the obtained figures, we look for normals.  Next, we build the projection of the figure onto the found normal, if at least one straight line is found on which the projections do not intersect, so what?  Suddenly, but the figures (like 3D models) are not suppressed in this case.  :) <br><br>  Full implementation of the class here: <a href="">Collision2D</a> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CheckResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;Vector2&gt; firstVertices, ArrayList&lt;Vector2&gt; secondVertices)</span></span></span><span class="hljs-function"> </span></span>{ Vector2 mtv = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; Vector2 normal = Vector.getInstance(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minMTVLength = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = firstVertices.size() + secondVertices.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i ++) { setNormal(normal, firstVertices, secondVertices, i); <span class="hljs-comment"><span class="hljs-comment">//      . X -   Y - . Vector2 firstProjection = normal.getProjection(firstVertices); Vector2 secondProjection = normal.getProjection(secondVertices); //         ,    ,     . if (firstProjection.getX() &lt; secondProjection.getY() || secondProjection.getX() &lt; firstProjection.getY()) return null; //   .   ,     . if (mtv == null) { mtv = Vector.getInstance(2, normal); minMTVLength = getIntersectionLength(firstProjection, secondProjection); } else { float mtvLength = getIntersectionLength(firstProjection, secondProjection); if (Math.abs(mtvLength) &lt; Math.abs(minMTVLength)) { mtv = Vector.getInstance(2, normal); minMTVLength = mtvLength; } } } return new CheckResult(mtv, minMTVLength); } //    Vector2 public Vector2 getProjection(ArrayList&lt;Vector2&gt; vertices) { Vector2 result = null; for (Vector2 current : vertices) { float projection = getScalar(current); if (result == null) result = new Vector2(projection, projection); // x - max if (projection &gt; result.getX()) result.setX(projection); // y - min if (projection &lt; result.getY()) result.setY(projection); } return result; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">getIntersectionLength, setNormal</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntersectionLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector2 firstProjection, Vector2 secondProjection)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (secondProjection.getY() - firstProjection.getX() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? secondProjection.getY() - firstProjection.getX() : firstProjection.getY() - secondProjection.getX(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector2 normal, ArrayList&lt;Vector2&gt; vertices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num)</span></span></span><span class="hljs-function"> </span></span>{ Vector2 firstPoint = vertices.get(num); Vector2 secondPoint = vertices.get(num + <span class="hljs-number"><span class="hljs-number">1</span></span> == vertices.size() ? <span class="hljs-number"><span class="hljs-number">0</span></span> : num + <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector2 edge = secondPoint.getSubtract(firstPoint); normal.setX(-edge.getY()); normal.setY(edge.getX()); normal.normalize(); }</code> </pre><br></div></div><br><br>  Immediately in the method above we are looking for the minimum intersection vector, if the figures do not intersect it, of course, we will not need it.  And if crossed, it must be converted to 3D, so that the models can be moved away from each other.  You can do this using the method below. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMTV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CheckResult result)</span></span></span><span class="hljs-function"> </span></span>{ Vector2 mtv2 = result.collision.getMTV(); Vector3 mtv3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(mtv2.getX(), mtv2.getY(), <span class="hljs-number"><span class="hljs-number">0</span></span>); Vector3 planeX = result.plane.xAxis(); Vector3 planeY = result.plane.yAxis(); Vector3 planeZ = result.plane.zAxis(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; matrix[<span class="hljs-number"><span class="hljs-number">0</span></span>] = planeX.getX(); matrix[<span class="hljs-number"><span class="hljs-number">1</span></span>] = planeX.getY(); matrix[<span class="hljs-number"><span class="hljs-number">2</span></span>] = planeX.getZ(); matrix[<span class="hljs-number"><span class="hljs-number">4</span></span>] = planeY.getX(); matrix[<span class="hljs-number"><span class="hljs-number">5</span></span>] = planeY.getY(); matrix[<span class="hljs-number"><span class="hljs-number">6</span></span>] = planeY.getZ(); matrix[<span class="hljs-number"><span class="hljs-number">8</span></span>] = planeZ.getX(); matrix[<span class="hljs-number"><span class="hljs-number">9</span></span>] = planeZ.getY(); matrix[<span class="hljs-number"><span class="hljs-number">10</span></span>] = planeZ.getZ(); matrix[<span class="hljs-number"><span class="hljs-number">15</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; Matrix.multiplyMV(mtv3.getRaw(), <span class="hljs-number"><span class="hljs-number">0</span></span>, matrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mtv3.getRaw(), <span class="hljs-number"><span class="hljs-number">0</span></span>); mtv3.normalize(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mtv3; }</code> </pre><br><br>  On this, in principle, everything, everything described above is sufficient to determine the intersection of 3D models. <br><br><h1>  Algorithm application </h1><br>  Instead of writing, I'll write that checking for the intersection of two objects takes a lot of time.  As I said before, I do not use complex collision models.  I also apply a number of optimizations such as calculating the radius of the sphere described around the model, the intersection of the spheres is much easier to compare.  For the same objects of the sphere that intersect, a detailed search for intersections <a href="">is performed in parallel</a> . <br><br>  The sources of the game are here: <a href="https://github.com/Nirklav/Tanks">github.com/Nirklav/Tanks</a> <br><br>  <b>UPD</b> : <a href="">Updated the</a> implementation of the algorithm, removing the extra step in the form of a projection on the plane, now the projections are searched immediately to the normal. </div><p>Source: <a href="https://habr.com/ru/post/257655/">https://habr.com/ru/post/257655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257639/index.html">Free Data Recovery Test. Version of Habr's readers</a></li>
<li><a href="../257641/index.html">Hello, SaaS | Remote to all</a></li>
<li><a href="../257643/index.html">Setting up a Mikrotik router to work with 3CX Phone System</a></li>
<li><a href="../257651/index.html">Announcement of the conference ThinkJava # 2</a></li>
<li><a href="../257653/index.html">Yii 2.0.4</a></li>
<li><a href="../257657/index.html">Game Exhibitions 2015</a></li>
<li><a href="../257659/index.html">OLED watch on arduino</a></li>
<li><a href="../257661/index.html">The digest of interesting materials for the mobile developer # 102 (on May 5-11)</a></li>
<li><a href="../257663/index.html">LFS: The Dark Side of the Force. Part 1</a></li>
<li><a href="../257665/index.html">Classic notes for the new Opera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>