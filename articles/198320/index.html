<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a 1k / 4k intro for Linux, part 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good luck, my overly patient friends! 
 As very few of you remember, in the second part we stopped at the fact that we received a rectangle on the who...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a 1k / 4k intro for Linux, part 4</h1><div class="post__text post__text-html js-mediator-article">  Good luck, my overly patient friends! <br>  As very few of you remember, in the <a href="http://habrahabr.ru/post/143766/">second part</a> we stopped at the fact that we received a rectangle on the whole screen in some hundreds of bytes there, and now we have been facing the problem of filling the voids in our codes and hearts with creativity for a year and a half. <br><br>  What can you draw with just two triangles?  Square?  Fractal?  Flying through megaton power blast in the city center?  Is there a limit to madness, where reality ends and reality begins?  How to properly care for the rays, what to feed them and what to reflect about you will learn in the sudden continuation of the series of articles about de-making! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/012/4d2/ef2/0124d2ef264e20b3a0012b02083e4562.png"><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  For the convenience of prototyping, I suggest using <a href="http://shadertoy.com/">shadertoy.com</a> , links with examples will lead to the same.  Thus, even users of alternative operating systems can immerse themselves in all this wonderful things that will be here. <br>  Yes, under Windows WebL, which we will use implicitly, for some reason everyone likes to implement through ANGLE, which is an addict and is famous for stealing complex shaders.  Therefore, I recommend including the native OpenGL (in chrome: <i>--use-gl = desktop</i> at startup), otherwise, after the third or fourth example, everything will explode and hardly correspond to what is being discussed. <br>  And yes, we need fairly powerful modern video cards, something like the GTX 4xx or HD 6xxx at a minimum (and by no means Intel, to laugh), otherwise there will be a filmstrip. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Introduction-2 </h5><br>  I won‚Äôt go into details of what shaders are, where they come from and why - this is a topic for a separate series of articles, which will not, lol - you just need to understand what we have to <code>gl_FragColor</code> color of the current pixel to the <code>gl_FragColor</code> variable depending on its coordinates are <code>gl_FragCoord</code> (in pixels) and the <code>iGlobalTime</code> time (this is a shader specific, in GLSL standard there is nothing about time, of course). <br>  In GLSL, among other things, there are vector and matrix types <code>vecN</code> , <code>matN</code> and the standard library of all sorts of mathematical and not so functions.  <a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">A crap</a> for the curious (GL ES because the shader is WebGL, which is inherited from OpenGL ES 2.0). <br><br><h4>  Realtime raytracing </h4><br>  I propose to do what else 10-15 years ago was considered an unattainable dream - ray tracing in real time.  Modern video cards are so monstrously productive that they are. <br>  The main idea - in order to determine the color of a pixel on the screen, we start a beam from it and look for which object it will rest on, then using knowledge of the object and the intersection point, we somehow calculate the illumination and form the desired color. <br>  How can one determine if a ray intersects a particular object, and if so, at what point?  You can, for example, write down the equation of intersection of the beam with the desired object and solve them analytically.  It is easy to find that this method very quickly becomes rather cumbersome for anything more complex than a sphere or a plane.  This is not good, we want to draw the landing of a flock of felines to Mars, so we will use another method, namely spherical tracing of distance functions. <br><br><h5>  From me to you </h5><br>  The distance function is a function R3-&gt; R, which returns the distance to the nearest geometry for each point in space.  In practice, writing such functions even for simple figures is easier than analytic intersection.  For example: <ul><li>  Ball: <code>length(at) - R</code> </li><li>  Plane: <code>dot(at,N) - D</code> </li><li>  Parallelepiped: <code>length(max(abs(at)-size), 0.))</code> </li><li>  Cylinder (Y): <code>length(at.xz) - R</code> </li></ul><br>  In addition, using such functions it is easy to make constructive geometry: <ul><li>  Union: <code>min(f, g)</code> </li><li>  Intersection: <code>max(f, g)</code> * </li><li>  Subtraction: <code>max(f, -g)</code> * </li></ul><br>  And transformations - it is enough to convert the input sampling vector at: <ul><li>  Transfer: <code>at-vec3(pos)</code> </li><li>  Rotation and more: <code>at*mat3(&lt;    &gt;)</code> (for scaling, you should keep in mind that the returned distance must be scaled back) </li></ul><br>  <i>* - not strict f-distance, assessment</i> <br><br><h5>  Spherical tracing </h5><br>  How to find the intersection of the beam with such a function?  One simple and elegant solution is spherical tracing.  The algorithm is as follows: <ol><li>  We start the beam in direction D from point O. </li><li>  We obtain d equal to the value of the function at the point O </li><li>  Shift point O in direction D by distance d </li><li>  If d is greater than a certain selected threshold value, return to step 2. </li><li>  The current point O is the desired intersection with a given accuracy, we exit </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/df2/863/123/df286312311fa9eb390eaef3bb8ff379.png"><br><br>  On GLSL, a simple trace function looks like this: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vec3 O, vec3 D</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> L = <span class="hljs-number"><span class="hljs-number">0.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_STEPS; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = world(O + D*L); L += d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &lt; EPSILON) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; }</code> </pre><br><br>  So, a simple marcher for a sphere with a radius of 1 at the origin of coordinates looks, for example, like this (visualization of the distance traveled): <br><pre> <code class="hljs pgsql">// ,      #define MAX_STEPS <span class="hljs-number"><span class="hljs-number">32</span></span> #define EPSILON <span class="hljs-number"><span class="hljs-number">.001</span></span> //         <span class="hljs-type"><span class="hljs-type">float</span></span> world(vec3 a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(a) - <span class="hljs-number"><span class="hljs-number">1.</span></span>; //   <span class="hljs-number"><span class="hljs-number">1</span></span>   } //      O    D.    <span class="hljs-type"><span class="hljs-type">float</span></span> trace(vec3 O, vec3 D) { <span class="hljs-type"><span class="hljs-type">float</span></span> L = <span class="hljs-number"><span class="hljs-number">0.</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_STEPS; ++i) { //  MAX_STEPS  <span class="hljs-type"><span class="hljs-type">float</span></span> d = world(O + D*L); //      L += d; //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &lt; EPSILON*L) break; //     ,  } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; //    } <span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { //     [<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>] vec2 uv = gl_FragCoord.xy / iResolution.xy * <span class="hljs-number"><span class="hljs-number">2.</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; //     uv.x *= iResolution.x / iResolution.y; //   vec3 O = vec3(<span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>); //      z ; <span class="hljs-number"><span class="hljs-number">-2.</span></span>       -  vec3 D = normalize(vec3(uv, <span class="hljs-number"><span class="hljs-number">-2.</span></span>)); //    <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">path</span></span> = trace(O, D); //  ,    gl_FragColor = vec4(<span class="hljs-type"><span class="hljs-type">path</span></span> * <span class="hljs-number"><span class="hljs-number">.2</span></span>); }</code> </pre><br> <a href="https://www.shadertoy.com/view/lds3Dl"><img src="http://habrastorage.org/storage3/59c/f76/f0d/59cf76f0db5507c33dff10f41d24fc70.png"></a> <br><br>  Our sphere suspiciously hangs in the air, so let's put it on a plane, for example: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> world(vec3 a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(length(a) - <span class="hljs-number"><span class="hljs-number">1.</span></span>, ay + <span class="hljs-number"><span class="hljs-number">1.</span></span>); }</code> </pre><br><img src="http://habrastorage.org/storage3/252/e98/9ee/252e989ee041a26cd52fd96efcc09bfa.png"><br><br>  Now let's muddle the lighting, to start simple diffuse, without glare and frills. <br>  In the simple Lambert model, it is assumed that the light incident on the surface is scattered in all directions evenly, and therefore the illumination of the point is proportional to the cosine of the angle between the normal and the direction to the light source.  In addition, the illumination decreases as the square of the distance from the source.  Well, about the colors of the source and the surface itself, you need not forget. <br>  In code, it looks like this: <br><pre> <code class="hljs ruby">vec3 enlight(vec3 at, vec3 normal, vec3 diffuse, vec3 l_color, vec3 l_pos) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        vec3 l_dir = l_pos - at; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  =      /<span class="hljs-regexp"><span class="hljs-regexp">/  =   (=   ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        (=   ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ,         return diffuse * l_color * max(0.,dot(normal,normalize(l_dir))) /</span></span> dot(l_dir, l_dir); }</code> </pre> <br><br>  The normal to get is simple - this is just the gradient of our distance function: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> wnormal(vec3 a) { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> e = vec2(.<span class="hljs-number"><span class="hljs-number">001</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.); <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> w = world(a); <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> normalize(vec3( world(a+e.xyy) - w, world(a+e.yxy) - w, world(a+e.yyx) - w)); }</code> </pre> <br><br>  Result: <br> <a href="https://www.shadertoy.com/view/4sSGRR"><img src="http://habrastorage.org/storage3/4a7/56a/d3e/4a756ad3ee568fbb206d7c22cc3bb440.png"></a> <br><br>  Something is missing, isn't it?  The sphere still seems to be hanging, and somehow dark. <br>  In order for the eyes to be quite realistic and pleasant, you need to add two pieces: a shadow and a shadow under the shadow. <br><br>  First, add ambeint-lighting, just adding something like <code>vec3(.1)</code> or .2 to the color to your taste. <br>  The undershadow shadow, also ambient occlusion, is an approximation of the effect from the real world, when the surface is partially obscured by photons flying from all sides, and not just from a light source. <br>  In realtime tride graphics, there are many ways to obtain a similar effect of varying degrees of upwardness.  In the technique used, the canonical approach is to operate the scene-space of data on the proximity of geometry ‚Äî we take several steps along the normal and determine how close anything is that could obscure us.  This is a pretty dirty hack (as, in general, everything that we do on this planet), but it looks pretty ok. <br>  Here is the code: <br><pre> <code class="hljs bash">//    <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> occlusion(vec3 at, vec3 normal) { //  ,     <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> b = 0.; //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = 1; i &lt;= 4; ++i) { //   .06 --     <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> L = .06 * <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>(i); <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> d = world(at + normal * L); //           b += max(0., L - d); } //   1    <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> min(b, 1.); }</code> </pre> <br><br>  The usual shadow is made even simpler - we just let the beam from a point into the light source and see if we are not rested in that along the way. <br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">trace</span></span>(<span class="hljs-name"><span class="hljs-name">at</span></span>, normalize(<span class="hljs-name"><span class="hljs-name">l_dir</span></span>), EPSILON*2.) &lt; length(<span class="hljs-name"><span class="hljs-name">l_dir</span></span>)) return vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>.)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Pay attention that you cannot start exactly from that point, you have to retreat a little bit (homework: why?) <br><br>  And finally, close up the black fog there so that the background with ambient lighting does not merge: <br><pre> <code class="hljs lisp">color = mix(<span class="hljs-name"><span class="hljs-name">color</span></span>, vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>.), smoothstep(<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">20</span></span>.,path))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br>  Total: <br> <a href="https://www.shadertoy.com/view/4dBGRR"><img src="http://habrastorage.org/storage3/51a/ac0/ce0/51aac0ce01b63b5bff68d11dd3333f13.png"></a> <br><br><h5>  Material values </h5><br>  But it is still gray and monotonous.  Let's make the ball and the plane be of a different color.  And so that the ball had metal highlights. <br>  Let's create for this the <code>material_t</code> structure: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">material_t</span></span></span><span class="hljs-class"> {</span></span> vec3 diffuse; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> specular; };</code> </pre> <br><br>  We divide our world into functions that return the geometry of individual materials, and write the following function: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      material_t wmaterial(vec3 a) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     material_t m = material_t(vec3(.5, .56, 1.), 200.); float closest = s_ball(a); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     --  float sample = s_floor(a); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     if (sample &lt; closest) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    closest = sample; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    --    m.diffuse = vec3(1.-mod(floor(ax)+floor(az), 2.)); m.specular = 0.; } return m; }</span></span></code> </pre><br>  Now it‚Äôs enough to use the material in the lighting function, but not the color constant. <br>  The final touch add glare.  In general, specular flare is also a crutch-crutch, an attempt to simulate the real effect of light reflection from metals (honestly physically, this is difficult to do - all sorts of BRDFs start, rendering equations, Metropolis beam reeling and other heavy academic graphics, which I do not understand ), therefore, there is a stack of various methods for approximating this effect.  Here we use the normalized Blinn-Phong method, which is reduced to the cosine of the angle between the normal and half-vector between the observer and the light source.  Specular highlights are physically independent of the diffuse color of the material. <br>  Long or short, here's the code: <br><pre> <code class="hljs dos"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.specular &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.) { // , ,  --        vec3 h = normalize(normalize(l_dir) + normalize(eye-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span>)); //      <span class="hljs-built_in"><span class="hljs-built_in">color</span></span> += l_color * pow(max(<span class="hljs-number"><span class="hljs-number">0</span></span>.,dot(normal,h)), m.specular) * (m.specular + <span class="hljs-number"><span class="hljs-number">8</span></span>.) / <span class="hljs-number"><span class="hljs-number">25</span></span>.; }</code> </pre><br><br>  Total: <br> <a href="https://www.shadertoy.com/view/XsB3RR"><img src="http://habrastorage.org/storage3/c63/5c0/00e/c635c000e876f6b2237dcaedd7577f8c.png"></a> <br><br><h5>  How about a wall of peas </h5><br>  Our ball does not reflect anything suspicious, let's ban it. <br>  Add reflections to the material field, which defines the proportion of incident light that will be reflected in the observer. <br>  Wrap up the trace in the reflection cycle: <br><pre> <code class="hljs perl">//        vec3 result_color = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>.); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    float k_reflectivity = <span class="hljs-number"><span class="hljs-number">1</span></span>.; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_REFLECTIONS; ++i) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    float path = trace(O, D, <span class="hljs-number"><span class="hljs-number">0</span></span>.); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,    vec3 <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> = O + D * path; vec3 nor = wnormal(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     material_t mat = wmaterial(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   vec3 color = .<span class="hljs-number"><span class="hljs-number">15</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span>. - occlusion(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>, nor)) * mat.diffuse; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    color += enlight(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>, nor, O, mat, vec3(<span class="hljs-number"><span class="hljs-number">1</span></span>., <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>.), vec3(<span class="hljs-number"><span class="hljs-number">2</span></span>.*<span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(t), <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">2</span></span>.*<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(t))); color += enlight(<span class="hljs-keyword"><span class="hljs-keyword">pos</span></span>, nor, O, mat, vec3(<span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.), vec3(<span class="hljs-number"><span class="hljs-number">2</span></span>.*<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(t*.<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-number"><span class="hljs-number">3</span></span>., <span class="hljs-number"><span class="hljs-number">2</span></span>.*<span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(t*.<span class="hljs-number"><span class="hljs-number">6</span></span>))); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -  color = mix(color, vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>.), smoothstep(<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">20</span></span>.,path)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      result_color += k_reflectivity * color; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     k_reflectivity *= mat.reflectivity; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k_reflectivity &lt; .<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        D = normalize(reflect(D, nor)); O = <span class="hljs-keyword"><span class="hljs-keyword">pos</span></span> + D * EPSILON*<span class="hljs-number"><span class="hljs-number">2</span></span>.; }</code> </pre><br><br>  We will add all sorts of additions to the scene, and here's how to draw an owl: <br> <a href="https://www.shadertoy.com/view/4sSGzR"><img src="http://habrastorage.org/storage3/0ff/40d/f40/0ff40df40142f93aeddbda54ca33514c.png"></a> <br><br>  But this is all bad. <br>  Bad, bad, bad. <br>  All this could be drawn without the functions of the distance, and it would work even faster.  So let's throw everything out and start drawing geometry from scratch. <br><br>  But first you should make a small digression into the world of disorder. <br><br><h4>  Chaos theory </h4><br>  Ideally smooth spheres and planes - it's all good, but too synthetic.  The real world is irregular, imperfect and generally made of shit.  Therefore, to get closer to him with your picture, you need to add a pinch of chaos to your taste. <br>  To make a good noise as it should, we need to have a function that takes one parameter and generates a random number depending on this parameter.  That is, for the same parameter values ‚Äã‚Äãthere should be the same number on the output.  The standard GLSL library contains references to such functions noise, noise2, etc., but in practice they are not implemented by any manufacturer (homework: why?), Therefore they were even cut out in the most recent edition.  So we have to write our noise. <br>  The traditional approach is: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x)*<span class="hljs-number"><span class="hljs-number">48737.3213</span></span>); }</code> </pre><br>  where 48737.3213 is just a random number that I have just blindly dialed with a cat on the numeric keypad.  The guys on the Internet love to copy-paste a certain number and carry it around with them everywhere, but I haven‚Äôt come across an explanation for this. <br>  Noise from vec2 can be obtained in this way: <br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">float</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(vec2 x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(dot(x,vec2(71.,313.))); }</code> </pre><br>  These functions, as is clear from the name - as if the hash from the input number, and at the slightest change of this very number, their value changes significantly.  For our purposes, we need to have a function whose value changes more smoothly.  There are several ways to build such functions that can be based on hashes, the main ones are perlin noise, value noise, simplex noise. <br><br>  On the Internet this season it is fashionable to make mistakes about the noise of Perlin and take it as the addition of several octaves of noise.  Multi-octave noise, or fractal noise, is a completely separate technique that can be based not only on Perlin‚Äôs noise, but also on any other.  Perlin's noise is built on the fact that we take an N-dimensional mesh and arrange random normalized gradients at its nodes (= just normalized random vectors), after which for each point of space we can determine in which grid size we find, calculate the scalar product with all nodes and n-linearly interpolate between these works.  Linear interpolation can be replaced by more complex, for example, making the second derivative of the resulting noise smooth, if you need it for some reason.  Here is the noise of Perlin.  He is bulky and cool.  After this two minutes of educational program, now you can also laugh at everyone else and turn up your nose: <br><img src="http://habrastorage.org/storage3/3c9/221/f78/3c9221f78a6d53750e54e7e04425625d.jpg"><br><br>  Simplex and Perlin noise we will not use here because of their excessive computational complexity.  For our modest goals of enslaving the universe, there is enough value noise - we take random values ‚Äã‚Äãat the grid nodes and interpolate between them, like this: <br><pre> <code class="hljs bash">//  value noise <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> noise(vec2 x) { // F -    , f -   vec2 F = floor(x), f = fract(x); //   vec2 e = vec2(1.,0.); //  f *= f * (3. - 2. * f); //   <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> mix( mix(<span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(F+e.yy), <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(F+e.xy), fx), mix(<span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(F+e.yx), <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(F+e.xx), fx), fy); }</code> </pre><br><br>  Now the notorious fractal noise is obtained by simply summing up several octaves: <br><pre> <code class="hljs markdown">//   float fnoise(vec2 x) { //       x += vec2(10.); //   return .5 <span class="hljs-bullet"><span class="hljs-bullet">* noise(x) + .25 *</span></span> noise(x<span class="hljs-emphasis"><span class="hljs-emphasis">*1.97) + .125 *</span></span> noise(x<span class="hljs-emphasis"><span class="hljs-emphasis">*4.04) + .0625 *</span></span> noise(x*8.17) ; }</code> </pre><br><br>  So we get the following visual representation of noise: <br> <a href="https://www.shadertoy.com/view/XdBGzR"><img src="http://habrastorage.org/storage3/1c7/e97/4df/1c7e974df8fcb2d9b46f7db294a9b6b4.png"></a> <br>  ( <a href="https://www.shadertoy.com/view/4sS3zR">secret bonus track-2</a> ) <br><br><h4>  Destroying everything </h4><br>  Using this source of chance, you can do anything.  For example, draw a city. <br>  The basic idea: let's beat the space into quarters-sectors, and for each sector, using its number-coordinates, we will extract from the chaos the parameters of the structure - dimensions, number of storeys, type. <br>  Similarly, you can highlight, for example, windows - depending on the heights and position, we take a random number and, based on it, decide whether the lights are on in this ‚Äúwindow‚Äù or not. <br>  The position of the camera, the starry sky - all this also comes from the box with random values. <br>  In general, I'm actually already just tired of writing this little bit poor text.  Most likely even more than you are tired of reading it.  So let's just look at ?????  PROFIT and go to bed at last! <br><br>  Attention, slide show on your video cards: <br> <a href="https://www.shadertoy.com/view/XdB3zR"><img src="http://habrastorage.org/storage3/234/05d/bcd/23405dbcd8ef1863a2c8878e6baad1ca.png"></a> <br><br><h4>  Conclusion </h4><br>  Now it remains to minimize the economy - remove a few comments, shorten the names of variables and functions, remove spaces, line breaks, lead to the form in which our framework from the second part expects (insert our variables instead of Shadertools) and can be released.  Well, that is, it is impossible, because it is still full of bad taste and you need a designer who would programmers all the time. <br>  In general, this homework is to make this shader run and see how many bytes the elf weighs with it.  My preliminary estimate is 2..2.5Kb. <br><br>  And, and the last thing: by a strange coincidence, I will suddenly today (Mon, 10.21.2013) talk about the same thing in a little more detail at the Novosibirsk State University (Novosibirsk State University) in the evening at 19:30 in aud.  223 <a href="http://go.2gis.ru/spr6">new sports complex</a> .  You can not come because you already know everything, lol.  Well, that is the opposite - come, polayvkodim! <br><br>  In the previous series: music synthesis in the C programming language. <br>  In the following series: unbiased path tracing of polygonal geometry in real time on OpenCL, probably. </div><p>Source: <a href="https://habr.com/ru/post/198320/">https://habr.com/ru/post/198320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198304/index.html">What happens to startups after conferences in Silicon Valley? Startup Experience from SVOD Conference</a></li>
<li><a href="../198306/index.html">WebGL Beginner's Guide Chapter 1: Getting Started With WebGL</a></li>
<li><a href="../198312/index.html">Php json has been removed from php 5.5?</a></li>
<li><a href="../198316/index.html">DIY dimmer for those who want it themselves</a></li>
<li><a href="../198318/index.html">The digest of interesting news and materials from the world of PHP for the last two weeks, No. 28 (October 6‚Äî20, 2013)</a></li>
<li><a href="../198322/index.html">Do you want to distribute elements, tied to their number, on the same styles? Yes, easily</a></li>
<li><a href="../198324/index.html">Nvidia announced full support for Linux on equal terms</a></li>
<li><a href="../198328/index.html">Dependency Injection in Objective-C with Magic and Blood</a></li>
<li><a href="../198330/index.html">6 tips for creating complex AJAX sites</a></li>
<li><a href="../198332/index.html">Creating extensions in PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>