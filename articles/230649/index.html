<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional Javascript. We write our lenses, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 
 In this article we will get acquainted with the lenses, find out what they are for, and also implement them in JavaScript. 

 Why do we ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional Javascript. We write our lenses, part 1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr. <br>  In this article we will get acquainted with the lenses, find out what they are for, and also implement them in JavaScript. <br><br><h4>  Why do we need lenses </h4><br>  Let's start, perhaps, with the answer to the question of why we need lenses. <br><br>  In functional programming, immutable data structures are widely used.  Working with them is significantly different compared to the variable data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is based on the fact that when a part of an immutable data structure changes, a copy of it is created that differs from the original by the same modified part.  Full copying of the entire original structure is not efficient, therefore the new structure usually uses references to unchanged parts from the original. <br><a name="habracut"></a><br>  Example: <br><br>  Suppose we have a data structure: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">street</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">house</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> } };</code> </pre> <br><br>  Our task is to change the meaning of the name. <br><br>  If we work with this structure as a variable one, then it is enough just to change the value in the user object: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, user</span></span></span><span class="hljs-function">) </span></span>{ user.name = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; }</code> </pre><br><br>  But if we work with this structure as unchangeable, then we do not have the right to change the data in the original object.  We need to create a new user2 object in which to put all the values ‚Äã‚Äãfrom user with the exception of the new name. <br><br>  Full copy option: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: user.address.city, <span class="hljs-attr"><span class="hljs-attr">street</span></span>: user.address.street, <span class="hljs-attr"><span class="hljs-attr">house</span></span>: user.address.house } }; }</code> </pre><br><br>  PS: The example conveys only the essence.  For good, there should be checks that user! = Null, user.adress! = Null. <br><br>  Partial copy option: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: user.address }; }</code> </pre><br><br>  I think the scheme is clear, so we will write general functions for working with the properties of the structure: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  function get(prop) { return function(item) { return item[prop]; }; } //    function setMutable(prop) { return function(value, item) { item[prop] = value; return item; } } //     function setImmutable(prop) { return function(value, item) { var props = properties(item), //     copy = props.reduce(function(lst, next) { lst[next] = item[next]; return lst; }, {}); copy[prop] = value; //    return copy; }; } //    obj function properties(obj) { var key, lst = []; for (key in obj) { if (obj.hasOwnProperty(key)) { lst.push(key); } } return lst; }</span></span></code> </pre><br><br>  Now we can use these functions to generate heters and setters. <br><br>  The original example can be rewritten as: <br><br><pre> <code class="javascript hljs">setName = setMutable(<span class="hljs-string"><span class="hljs-string">'name'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   setName = setImmutable('name') //  getName = get('name') //     </span></span></code> </pre><br><br>  Now suppose that we need to change the value of city from user. <br><br>  Let's set the task more generally and write the heters and seters allowing to work with the city through the user object. <br><br>  For a changeable structure, the implementation might look like <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserCity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.address.city; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUserCity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, user</span></span></span><span class="hljs-function">) </span></span>{ user.address.city = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; }</code> </pre><br><br>  Or the same, but in a more functional style, using the already defined functions get, setMutable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getAddress = get(<span class="hljs-string"><span class="hljs-string">'address'</span></span>), getCity = get(<span class="hljs-string"><span class="hljs-string">'city'</span></span>), getUserCity = compose(getCity, getAddress), <span class="hljs-comment"><span class="hljs-comment">//  compose       (  )          . ..    getUserCity = function(item) { return getCity(getAddress(item)); }, setCity = setMutable('city'), setUserCity = function (value, item) { setCity(value, getAddress(item)) return item; } var newUser = setUserCity(' city', user); getUserCity(newUser) == ' city' // true //PS function compose(func1, func2) { return function() { return func1(func2.apply(null, arguments)); }; }</span></span></code> </pre><br><br>  Let's try to implement the same for immutable structure: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getAddress = get(<span class="hljs-string"><span class="hljs-string">'address'</span></span>), getCity = get(<span class="hljs-string"><span class="hljs-string">'city'</span></span>), getUserCity = compose(getCity, getAddress), setCity = setImmutable(<span class="hljs-string"><span class="hljs-string">'city'</span></span>), setUserCity = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, item</span></span></span><span class="hljs-function">) </span></span>{ setCity(value, getAddress(item)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = setUserCity(<span class="hljs-string"><span class="hljs-string">' city'</span></span>, user); getUserCity(newUser) == <span class="hljs-string"><span class="hljs-string">' city'</span></span> <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br><br>  At first glance, everything is fine.  But pay attention to the <code>setUserCity</code> function.  In it, we get a new value for the input for the city <code>value</code> and the <code>item</code> user, change the value of the city and ... return the original <code>item</code> object.  But this contradicts the definition of immutable data structures.  When changing any part of it, we must create a new object. <br><br>  Using the <code>setUserCity</code> function turns our immutable object back into a mutable.  To verify this, let's execute the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser1 = setUserCity(<span class="hljs-string"><span class="hljs-string">'city1'</span></span>, user), newUser2 = setUserCity(<span class="hljs-string"><span class="hljs-string">'city2'</span></span>, user); newUser1 == newUser2 <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre><br>  To fix this, you need to rewrite the value of the address of the user <code>item</code> , and return the new user <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> setAddress = setImmutable(<span class="hljs-string"><span class="hljs-string">'address'</span></span>), setUserCity = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address = setCity(value, getAddress(item)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setAddress(address, user); }, newUser1 = setUserCity(<span class="hljs-string"><span class="hljs-string">'city1'</span></span>, user), newUser2 = setUserCity(<span class="hljs-string"><span class="hljs-string">'city2'</span></span>, user); newUser1 == newUser2 <span class="hljs-comment"><span class="hljs-comment">//false</span></span></code> </pre><br><br>  Now everything works as it should. <br><br><h5>  Findings: </h5><br>  The composition of heteros is the same for both variable and non-variable structures, but the construction of setters differs significantly. <br><br>  To build a grid with depth n of a variable data structure, it suffices to use n - 1 heteros and one grid from the last level. <br><br>  To obtain a setter of an unchangeable structure of depth n, n - 1 heteros and n sets are necessary, since  It is necessary to update all levels starting from 0 (source object). <br><br>  To simplify the construction (layout) of the seters (and heteros) of immutable data structures, it is convenient to use the <b>lens</b> tool. <br><br><h4>  Lenses </h4><br>  We found out that the layout of the setters for immutable structures is not a trivial task, since it requires a list of all heteros and sets. <br><br>  But let's introduce an abstraction called a lens, which is nothing more than a pair of a hetero and a seter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lens = Lens(getter, setter) <span class="hljs-comment"><span class="hljs-comment">// .</span></span></code> </pre><br><br>  We also introduce the trivial get and set operations that will simply duplicate the functionality transferred to the hetero and seter lens: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getter, setter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: getter, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: setter }; }</code> </pre><br><br>  And now let's look once more at the <code>setUserCity</code> function.  When diving from level A to level B, we need getters and setters A and B. But we just introduced a new abstraction <code>Lens</code> .  Why should not the composition of seters and heteras separately be replaced by the composition of their lenses? <br><br>  Let's introduce a new operation on <code>compose</code> lenses, which builds a composition of two lenses: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getter, setter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">compose</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lens</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lens(get2, set2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lens.get(getter(item)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> innerValue = lens.set(value, getter(item)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setter(innerValue, item); } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: getter, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: setter }; }</code> </pre><br><br>  Let's try to solve our problem with the use of lenses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addressLens = Lens(getAddress, setAddress), <span class="hljs-comment"><span class="hljs-comment">//    cityLens = Lens(getCity, setCity), //    addressCityLens = addressLens.compose(cityLens); //    addressCityLens.set(' city', user); //  city  user,  </span></span></code> </pre><br><br>  Pay attention to the composition of the lenses.  It is very similar to the composition through the <code>user.address.city</code> point.  Adding a new lens as if plunges us to a lower level. <br><br>  In practice, quite often there will be a need to change the value given its current value, so let's expand our abstraction with another <code>modify</code> operation: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getter, setter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">modify</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = getter(item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setter(func(value), item); }, <span class="hljs-attr"><span class="hljs-attr">compose</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lens</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lens(get2, set2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lens.get(getter(item)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> innerValue = lens.set(value, getter(item)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setter(innerValue, item); } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: getter, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: setter }; }</code> </pre><br><br><h4>  Syntactic sugar </h4><br>  We learned what lenses are, what they are for and how to use them.  But let's think about how to make working with lenses easier. <br>  Firstly, it is unlikely that we will need to create a lens with a hetero and a setter for different fields (although this can theoretically be done).  So let's overload the lens constructor.  It will take the name of the property and automatically generate a lens for it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getter, setter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  1 ,     if (arguments.length == 1) { var property = arguments[0]; getter = get(property); setter = setImmutable(property); } return { modify: function (func, item) { var value = getter(item); return setter(func(value), item); }, compose: function (lens) { return Lens(get2, set2); function get2(item) { return lens.get(getter(item)); } function set2 (value, item) { var innerValue = lens.set(value, getter(item)); return setter(innerValue, item); } }, get: getter, set: setter }; }</span></span></code> </pre><br><br>  Now the original example can be written as: <br><br><pre> <code class="javascript hljs">Lens(<span class="hljs-string"><span class="hljs-string">'address'</span></span>).compose(Lens(<span class="hljs-string"><span class="hljs-string">'city'</span></span>)).set(<span class="hljs-string"><span class="hljs-string">' city'</span></span>, user);</code> </pre><br><br>  Creating a lens easier, but the composition looks rather cumbersome.  Let's write a small interpreter that will create lenses and build their composition.  At the entrance it will take a list of the names of the properties for which you want to create lenses.  And the composition operation will be set by a point (in the best traditions of Haskell, but unlike it, it will be carried out from left to right). <br>  As a result, our example should be transformed into something like this: <br><br><pre> <code class="javascript hljs">lens(<span class="hljs-string"><span class="hljs-string">'address.city'</span></span>).set(<span class="hljs-string"><span class="hljs-string">' city'</span></span>, user);</code> </pre><br><br>  Well, pretty close to <code>user.address.city</code> .  Let's implement the <code>lens</code> function <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cmd</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lenses = cmd.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) .map(pass1(Lens)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lenses.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lst, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lst.compose(next); }); } <span class="hljs-comment"><span class="hljs-comment">//         , //     ,   function pass1(func) { return function(x) { return func(x); }; }</span></span></code> </pre><br><br>  Pay attention to the <code>pass1</code> function.  The fact is that the <code>map</code> transmits more than 1 parameter to callback, so if we write <code>map(Lense)</code> , the version of <code>Lense</code> accepts the heteroter and the seter as input will be used.  Therefore, we wrap our <code>pass1</code> function, which ensures that only the first parameter passed to it enters the <code>Lense</code> . <br><br>  <i>In the second part, we will look at how to make friends with the lenses and the Nothing monad.</i> </div><p>Source: <a href="https://habr.com/ru/post/230649/">https://habr.com/ru/post/230649/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230637/index.html">How to improve your programming style?</a></li>
<li><a href="../230639/index.html">The best rake of Russian IT startups</a></li>
<li><a href="../230643/index.html">Flask Mega-Tutorial, Part 8: Subscribers, Contacts and Friends</a></li>
<li><a href="../230645/index.html">Areas of application of homomorphic encryption</a></li>
<li><a href="../230647/index.html">Guarantees of getting the correct result when calculating dynamic systems</a></li>
<li><a href="../230651/index.html">An overview of the ST Nucleo developer platform using the example of Nucleo-F401RE</a></li>
<li><a href="../230655/index.html">Beaver mysql logger or how to find an error in the MySql application</a></li>
<li><a href="../230657/index.html">Ulefone U7 - thin phablet</a></li>
<li><a href="../230659/index.html">Home library of the modern child</a></li>
<li><a href="../230661/index.html">Web server in 5 minutes based on PIC and W5100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>