<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Problems of batch request processing and their solution (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Almost all modern software products consist of several services. Often, a large response time between service channels becomes a source of performance...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Problems of batch request processing and their solution (part 1)</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sb/0r/ap/sb0raprlu2jwllu3gasyznuom40.jpeg"></div>  Almost all modern software products consist of several services.  Often, a large response time between service channels becomes a source of performance problems.  The standard solution to this type of problem is the packaging of several inter-service requests in one package, which is called batching. <br><br>  If you use batch processing, you may not be satisfied with its result in terms of performance or clarity of the code.  This method is not as simple for the caller as you might think.  For different purposes and in different situations, decisions can vary greatly.  For specific examples, I will show the pros and cons of several approaches. <br><a name="habracut"></a><br><h2>  Demonstration project </h2><br>  For clarity, we consider an example of one of the services in the application I'm working on. <br><br><div class="spoiler">  <b class="spoiler_title">Explanation of the choice of platform for examples</b> <div class="spoiler_text">  The problem of poor performance is quite common and does not concern any specific languages ‚Äã‚Äãand platforms.  This article will use Spring + Kotlin code examples to demonstrate tasks and solutions.  Kotlin is equally understandable (or incomprehensible) to Java and C # - to developers, moreover, the code is more compact and understandable than in Java.  To make things easier for pure Java developers, I‚Äôll avoid Kotlin‚Äôs black magic and use only white (in the spirit of Lombok).  There will be some extension methods, but they are actually familiar to all Java programmers as static methods, so this will be a little sugar that doesn‚Äôt spoil the taste of the dish. </div></div><br>  There is a document approval service.  Someone creates a document and submits it for discussion, during which changes are made, and ultimately the document is consistent.  The reconciliation service itself knows nothing about the documents: this is just a chat of coordinators with small additional functions that we will not discuss here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, there are chat rooms (correspond to documents) with a predefined set of participants in each of them.  As in normal chat rooms, messages contain text and files and can be replies (reply) and shipments (forward): <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatMessage</span></span></span></span>( <span class="hljs-comment"><span class="hljs-comment">// nullable,      persist val id: Long? = null, /**    */ val author: UserReference, /**  */ val message: String, /**    */ // -   JPA+    null,    val files: List&lt;FileReference&gt;? = null, /**   ,     */ val replyTo: ChatMessage? = null, /**   ,     */ val forwardFrom: ChatMessage? = null )</span></span></code> </pre> <br>  File and user links are links to other domains.  We live this way: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> FileReference = <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> UserReference = <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span></code> </pre> <br>  User data is stored in Keycloak and obtained via REST.  The same applies to files: files and meta information about them live in a separate file storage service. <br><br>  All calls to these services are <strong>heavy queries</strong> .  This means that the overhead of transporting these requests is much more than the time they are processed by a third-party service.  On our test benches, the typical time for calling such services is 100 ms, so in the future we will use these numbers. <br><br>  We need to make a simple REST controller to receive the latest N messages with all the necessary information.  That is, we believe that in the frontend the message model is almost the same and you need to send all the data.  The difference between the model for the frontend is that the file and the user need to be presented in a little decrypted form to make them links: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/**          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReferenceUI</span></span></span></span>( <span class="hljs-comment"><span class="hljs-comment">/**   url */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ref: String, <span class="hljs-comment"><span class="hljs-comment">/**     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatMessageUI</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>, <span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> author: ReferenceUI, <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message: String, <span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> files: List&lt;ReferenceUI&gt;, <span class="hljs-comment"><span class="hljs-comment">/**   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> replyTo: ChatMessageUI? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">/**   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> forwardFrom: ChatMessageUI? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> )</code> </pre> <br>  We need to implement the following: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRestApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;ChatMessageUI&gt; }</code> </pre> <br>  The postfix UI means DTO-models for the frontend, that is, what we have to give through REST. <br><br>  It may seem surprising here that we don‚Äôt pass on any chat ID, and even in ChatMessage / ChatMessageUI it doesn‚Äôt.  I did this intentionally, so as not to clutter up the code of examples (the chats are isolated, so we can assume that we have one at all). <br><br><div class="spoiler">  <b class="spoiler_title">Philosophical retreat</b> <div class="spoiler_text">  Both the ChatMessageUI class and the ChatRestApi.getLast method use the List data type, whereas in fact it is an ordered Set.  In the JDK, this is all bad, so declaring the order of elements at the interface level (preserving the order when adding and extracting) will not work.  So the common practice has been to use the List in cases where an ordered Set is needed (there is also a LinkedHashSet, but this is not an interface). </div></div><br>  <b>An important limitation:</b> we will assume that there are no long chains of replies or transfers.  That is, they are, but their length does not exceed three messages.  The whole chain of messages should be transmitted to the frontend. <br><br>  To obtain data from external services, there are such APIs: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatMessageRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;ChatMessage&gt; } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileHeadRemote</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: FileReference, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileRemoteApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeadById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: FileHeadRemote <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeadsByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Set&lt;FileHeadRemote&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeadsByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;FileHeadRemote&gt; } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRemote</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: UserReference, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRemoteApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: UserRemote <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Set&lt;UserRemote&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;UserRemote&gt; }</code> </pre> <br>  It can be seen that in external services batch processing is initially provided, and in both options: via Set (without preserving the order of elements, with unique keys) and via List (there may be duplicates - the order is preserved). <br><br><h2>  Simple implementations </h2><br><h4>  Naive implementation </h4><br>  The first naive implementation of our REST controller will look like this in most cases: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRestController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> messageRepository: ChatMessageRepository, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userRepository: UserRemoteApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fileRepository: FileRemoteApi ) : ChatRestApi { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = messageRepository.findLast(n) .map { it.toFrontModel() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ChatMessage.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toFrontModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ChatMessageUI = ChatMessageUI( id = id ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string"> must be persisted"</span></span>), author = userRepository.getUserById(author).toFrontReference(), message = message, files = files?.let { files -&gt; fileRepository.getHeadsByIds(files) .map { it.toFrontReference() } } ?: listOf(), forwardFrom = forwardFrom?.toFrontModel(), replyTo = replyTo?.toFrontModel() ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> UserRemote.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toFrontReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = ReferenceUI(<span class="hljs-string"><span class="hljs-string">"/user/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>, name) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> FileHeadRemote.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toFrontReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = ReferenceUI(<span class="hljs-string"><span class="hljs-string">"/file/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>, name)</code> </pre> <br>  Everything is very clear, and this is a big plus. <br><br>  We use batch processing and retrieve data from external service packages.  But what happens with performance? <br><br>  For each message, one UserRemoteApi call will be made to retrieve data for the author field and one FileRemoteApi call to retrieve all attached files.  It seems to be all.  Suppose that the forwardFrom and replyTo fields for ChatMessage are such that it does not require unnecessary calls.  But converting them into ChatMessageUI will lead to recursion, that is, the indicators for call counters can grow dramatically.  As we noted earlier, let‚Äôs assume that we don‚Äôt have a lot of nesting and the chain is limited to three messages. <br><br>  As a result, we will receive from two to six external service calls per message and one JPA call for the entire batch of messages.  The total number of calls will vary from 2 * N + 1 to 6 * N + 1.  How much is this in real units?  Suppose you need 20 messages to render a page.  To get them, you will need from 4 s to 10 s.  Awful  I would like to meet 500 ms.  And since the front end dreamed of making a seamless scroll, the performance requirements of this endpoint can be doubled. <br><br>  <b>Pros:</b> <br><br>  1. The code is short and self-documenting (support dream). <br>  2. The code is simple, so there is almost no opportunity to shoot in the foot. <br>  3. Batch processing does not look something alien and is organically incorporated into the logic. <br>  4. Logic changes will be made easily and will be local. <br><br>  <b>Minus:</b> <br>  The terrible performance due to the fact that the packages are very small. <br><br>  This approach can often be seen in simple services or in prototypes.  If the speed of making changes is important, it is hardly worth complicating the system.  At the same time, for our very simple service, the performance is terrible, so the scope of applicability of this approach is very narrow. <br><br><h4>  Naive parallel processing </h4><br>  You can start processing all messages in parallel - this will get rid of the linear growth of time depending on the number of messages.  This is not a particularly good path, because it will lead to a large peak load on the external service. <br><br>  Implementing parallel processing is very simple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = messageRepository.findLast(n).parallelStream() .map { it.toFrontModel() } .collect(toList())</code> </pre> <br>  Using parallel processing of messages, we get 300‚Äì700 ms, ideally, which is much better than with a naive implementation, but still not fast enough. <br><br>  With this approach, userRepository and fileRepository requests will be executed synchronously, which is not very efficient.  To fix this, you have to change the call logic a lot.  For example, through CompletionStage (aka CompletableFuture): <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ChatMessage.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toFrontModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ChatMessageUI = CompletableFuture.supplyAsync { userRepository.getUserById(author).toFrontReference() }.thenCombine( files?.let { CompletableFuture.supplyAsync { fileRepository.getHeadsByIds(files).map { it.toFrontReference() } } } ?: CompletableFuture.completedFuture(listOf()) ) { author, files -&gt; ChatMessageUI( id = id ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string"> must be persisted"</span></span>), author = author, message = message, files = files, forwardFrom = forwardFrom?.toFrontModel(), replyTo = replyTo?.toFrontModel() ) }.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()!!</code> </pre> <br>  It can be seen that initially simple mapping code has become less clear.  This is because we had to separate the calls of external services from the place where the results were used.  This is not bad in itself.  But the combination of calls does not look very elegant and resembles the typical jet noodles. <br><br>  If you use Korutiny, everything will look more decent: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ChatMessage.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toFrontModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ChatMessageUI = join( { userRepository.getUserById(author).toFrontReference() }, { files?.let { fileRepository.getHeadsByIds(files).map { it.toFrontReference() } } ?: listOf() } ).let { (author, files) -&gt; ChatMessageUI( id = id ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string"> must be persisted"</span></span>), author = author, message = message, files = files, forwardFrom = forwardFrom?.toFrontModel(), replyTo = replyTo?.toFrontModel() ) }</code> </pre> <br>  Where: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A, B&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: ()</span></span></span></span> -&gt; A, b: () -&gt; B) = runBlocking(IO) { awaitAll(async { a() }, async { b() }) }.let { it[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A to it[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> B }</code> </pre> <br>  Theoretically, using such parallel processing, we obtain 200‚Äì400 ms, which is already close to our expectations. <br><br>  Unfortunately, such a good parallelization does not happen, and the payoff is quite cruel: with the simultaneous operation of only a few users, a squall of requests will fall on the services, which will not be processed in parallel anyway, so we will return to our sad 4 s. <br><br>  My result when using this service is 1300‚Äì1700 ms for processing 20 messages.  This is faster than in the first implementation, but still does not remove the problem. <br><br><div class="spoiler">  <b class="spoiler_title">Alternative use of parallel queries</b> <div class="spoiler_text">  What if third-party services do not provide batch processing?  For example, you can hide the lack of implementation of batch processing inside interface methods: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRemoteApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: UserRemote <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Set</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Set&lt;UserRemote&gt; = id.parallelStream() .map { getUserById(it) }.collect(toSet()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserReference</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;UserRemote&gt; = id.parallelStream() .map { getUserById(it) }.collect(toList()) }</code> </pre> <br>  It makes sense if there is hope for the appearance of batch processing in future versions. </div></div><br>  <b>Pros:</b> <br><br>  1. Easy implementation of parallel processing by messages. <br>  2. Good scalability. <br><br>  <b>Minuses:</b> <br><br>  1. The need to separate the receipt of data from their processing when processing requests for different services in parallel. <br>  2. Increased load on third-party services. <br><br>  It is seen that the scope of applicability is about the same as that of the naive approach.  It makes sense to use the method of parallel queries if you want to increase the productivity of your service by several times due to the merciless exploitation of others.  In our example, productivity increased 2.5 times, but this is clearly not enough. <br><br><h4>  Caching </h4><br>  You can make caching in the spirit of JPA for external services, that is, store received objects within a session so as not to receive them again (including during batch processing).  You can make these caches yourself, you can use Spring with its @Cacheable, plus you can always use a ready-made cache like EhCache manually. <br><br>  A common problem will be related to the fact that there is a sense from caches only if there are hits.  In our case, hitting the author field is very likely (for example, 50%), and there will be no file hits at all.  This approach will bring some improvements, but radically performance will not change (and we need a breakthrough). <br><br>  Intersessional (long) caches require a complex logic of invalidation.  In general, the later you go so far as to solve performance problems with intersessional caches, the better. <br><br>  <b>Pros:</b> <br><br>  1. Implement caching without changing the code. <br>  2. Performance increase several times (in some cases). <br><br>  <b>Minuses:</b> <br><br>  1. The possibility of poor performance when used improperly. <br>  2. Large memory overhead, especially with long caches. <br>  3. Complicated disability, errors in which will lead to difficult-to-reproducible problems in runtime. <br><br>  Very often, caches are used only to quickly patch up design problems.  This does not mean that they do not need to be used.  However, you should always treat them with caution and first evaluate the resulting performance gain, and only then make a decision. <br><br>  In our example, the caches will have a performance gain of around 25%.  At the same time there are a lot of minuses in caches, so I would not use them here. <br><br><h4>  Results </h4><br>  So, we looked at the naive implementation of a service that uses batch processing, and a few simple ways to speed it up. <br><br>  The main advantage of all these methods is simplicity, from which there are many pleasant consequences. <br><br>  A common problem with these methods is poor performance, primarily due to packet size.  Therefore, if these solutions do not suit you, then it is worth considering more radical methods. <br><br>  There are two main areas in which you can search for solutions: <br><br><ul><li>  asynchronous work with data (requires a paradigm shift, therefore, this article is not considered); </li><li>  enlarging packs while maintaining synchronous processing. </li></ul><br>  Enlargement of packs will greatly reduce the number of external calls and at the same time keep the code synchronous.  The following part of the article will be devoted to this topic. </div><p>Source: <a href="https://habr.com/ru/post/460291/">https://habr.com/ru/post/460291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460279/index.html">The contract for 10 billion: who will deal with the cloud for the Pentagon</a></li>
<li><a href="../46028/index.html">How not to make a login form in the Internet bank</a></li>
<li><a href="../460281/index.html">How a UX writer helps improve a product</a></li>
<li><a href="../460283/index.html">A new programming language with your own hands and head</a></li>
<li><a href="../46029/index.html">A small feature of window.open in Internet Explorer</a></li>
<li><a href="../460295/index.html">What does unsafe mean in Rust?</a></li>
<li><a href="../460297/index.html">WeakRef - proposal for adding to ECMAScript standard</a></li>
<li><a href="../4603/index.html">For the virtual "Sotovik" the real battle began</a></li>
<li><a href="../460301/index.html">Powerful new generation LED lamps</a></li>
<li><a href="../460305/index.html">AERODISK Engine: Disaster. Part 2. Metroklaster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>