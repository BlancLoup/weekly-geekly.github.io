<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Traffic generation in user space</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Generating traffic through MoonGen + DPDK + Lua as an artist 

 The neutralization of DDoS attacks in real conditions requires preliminary testing and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Traffic generation in user space</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/ab/qb/d4abqbslioh-eskinpe4jhet0y4.jpeg"></div><br>  <i>Generating traffic through MoonGen + DPDK + Lua as an artist</i> <br><br>  The neutralization of DDoS attacks in real conditions requires preliminary testing and testing of various techniques.  Network equipment and software should be tested in artificial conditions close to real - with intensive flows of traffic simulating attacks.  Without such experiments, it is extremely difficult to obtain reliable information about the specific features and limitations of any complex tool. <br><br>  In this article we will reveal some of the traffic generation methods used in Qrator Labs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>A WARNING</b> <br><br>  We strongly recommend the reader not to try to use the tools mentioned to attack real infrastructure objects.  DoS attacks are punishable by law and can lead to severe punishment.  Qrator Labs conducts all tests in an isolated laboratory environment. <br><a name="habracut"></a><br><h2>  Modern technical level </h2><br>  An illustrative task in our field is to saturate the 10G Ethernet interface with small packets, which implies processing 14.88 Mpps (millions of packets per second).  Hereinafter, we consider the smallest Ethernet network packets - 64 bytes - because our main interest is to maximize the number of transmitted packets per unit time.  A simple calculation shows that we only have about 67 nanoseconds to process one such packet. <br><br>  Just for comparison - this time is close to what is required by a modern processor to get a piece of data from memory in case of a cache miss.  Everything becomes even more difficult when we start working with 40G and 100G Ethernet interfaces and try to fully saturate them up to the line rate (the maximum possible performance of a network device). <br><br>  Since in the usual case the data flow passes through the application in the user space (userspace), then through the kernel, finally getting into the network controller (NIC), the first and most straightforward idea is to try to configure packet generation directly in the kernel.  An example of <a href="http://netoptimizer.blogspot.com/2014/10/unlocked-10gbps-tx-wirespeed-smallest.html">such a solution</a> is the <a href="https://github.com/danieltt/pktgen">pktgen</a> nuclear module [2].  This method allows to significantly improve performance, but is not flexible enough, since the slightest change in the source code in the kernel leads to a long build cycle, reloading the kernel modules or even the entire system and, in fact, testing, which reduces the overall productivity (that is, it takes more and effort). <br><br>  Another possible approach is to get direct access from userspace to the memory buffers of the network controller.  This path is more complex, but it is worth the effort to achieve higher productivity.  Disadvantages include high complexity and low flexibility.  Examples of this approach are the technologies <a href="http://info.iet.unipi.it/~luigi/netmap/">netmap</a> , <a href="https://www.ntop.org/products/packet-capture/pf_ring/">PF_RING</a> and <a href="https://www.dpdk.org/">DPDK</a> [4]. <br><br>  Another effective, albeit very costly way to achieve high performance is to use not universal, but specialized equipment.  Example: <a href="https://www.ixiacom.com/">Ixia</a> . <br><br>  There are also solutions based on DPDK using scripts, which increases flexibility in managing generator parameters, and also allows you to vary the type of packages generated during the launch process.  Below we describe our own experience with one of these tools - MoonGen. <br><br><h2>  MoonGen architecture </h2><br>  The distinctive features of MoonGen are: <br><br><ol><li>  Processing DPDK data in userspace, this is the main reason for productivity gains; </li><li>  The Lua stack [ <a href="https://www.lua.org/">5</a> ] with simple scripts at the top level and bindings to the DPDK library written in C on the bottom; </li><li>  Thanks to JIT technology (just in time), Lua scripts work fairly quickly, which is somewhat contrary to generally accepted ideas about the effectiveness of scripting languages. </li></ol><br>  MoonGen can be perceived as a Lua wrapper around the DPDK library.  At least the following DPDK operations are visible at the Lua user interface level: <br><br><ul><li>  Configuring network controllers; </li><li>  Location and direct access to pools and memory buffers, which, for optimization purposes, should be allocated with continuous aligned areas; </li><li>  Direct access to RSS queues of network controllers; </li><li>  API for managing computational threads, taking into account the heterogeneity of memory access (NUMA and CPU affinity) [ <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">12</a> ]. </li></ul><br><img src="https://habrastorage.org/webt/qg/vh/ij/qgvhijgvyv0fe5m9vntekmwggxo.png"><br><br>  Architecture MoonGen, scheme from the material [ <a href="https://www.net.in.tum.de/fileadmin/bibtex/publications/papers/MoonGen_IMC2015.pdf">1</a> ]. <br><br><h3>  Moongen </h3><br>  MoonGen is a high-speed script package generator based on the DPDK library.  Lua scripts control the entire process: a user-created script is involved in creating, modifying, and sending packets.  Thanks to the very fast LuaJIT and DPDK packet processing library, this architecture allows saturating a 10-gigabit Ethernet interface with 64-byte packets using only one core of the CPU.  MoonGen allows you to achieve this speed even in the case when the Lua script modifies each package.  It does not use tricks like reusing the same network controller buffer. <br><br>  MoonGen can also receive packets, that is, check which packets have been dropped by the system under test.  Since packet reception is controlled exclusively by a custom Lua script, it can also be used to create more complex test scripts.  For example, you can use two instances of MoonGen to establish a connection with each other.  This configuration can be used, in particular, to test the so-called middleboxes (equipment between the point of sending and receiving traffic), for example, firewalls.  MoonGen focuses on four main areas: <br><br><ul><li>  High performance and multi-core scaling: more than 20 million packets per second on a single CPU core; </li><li>  Flexibility: each package is generated in real time based on a user-created Lua script; </li><li>  Accurate time stamps: on ordinary (commodity) iron, time marking is performed with millisecond precision; </li><li>  Precise control of the intervals between the sent packets: reliable generation of the required patterns and types of traffic on regular hardware. </li></ul><br><h3>  DPDK </h3><br>  DPDK stands for Data Plane Development Kit and consists of libraries, the main functions of which are to increase the performance of generating network packets on a wide variety of architectures of central processing units. <br><br>  In a world where computer networks are becoming the foundation of human communication, performance, bandwidth and latency are becoming increasingly critical for the operation of systems such as wireless networks and cable infrastructure, including all their individual components: routers, load balancers, firewalls;  and also spheres of applications: transfer of media (streaming), VoIP, etc. <br><br>  DPDK is a lightweight and convenient way to build tests and scripts.  Data transfer within userspace is something we see less often, mainly because most applications communicate with network equipment through the operating system and the kernel stack, which is the opposite of the DPDK model. <br><br><h3>  Lua </h3><br>  The main purpose of the existence of Lua is to provide simple and flexible expressive means that are extensible for specific current tasks, instead of a set of primitives that is applicable only in one programming paradigm.  As a result, the base language is very easy - the entire interpreter is only <a href="https://www.lua.org/about.html">180 KB</a> in compiled form and easily adapts to a wide range of possible implementations. <br><br>  Lua is a dynamic language.  It is so compact that it can be placed on virtually any device.  Lua supports a small set of types: boolean values, numbers (double-precision floating point), and strings.  Regular data structures, such as arrays, sets, and lists, can be represented by the only embedded data structure in Lua ‚Äî the table, which is a heterogeneous associative array. <br><br>  Lua uses JIT compilation (just in time), therefore, being a scripting language, it shows performance comparable to compiled languages ‚Äã‚Äãsuch as C [ <a href="https://nullprogram.com/blog/2018/05/27/">10</a> ]. <br><br><h2>  Why moongen </h2><br>  As a company specializing in neutralizing DDoS attacks, Qrator Labs needs a reliable way to create, upgrade and test its own security solutions.  For the latter, testing, various methods of generating traffic are needed that mimic real attacks.  However, it is not so easy to imitate a dangerous, straightforward, flood attack at 2-3 levels of the OSI model, primarily because of the difficulties in achieving high performance in packet generation. <br><br>  In other words, for a company engaged in the continuous availability and neutralization of DDoS, simulating various DoS attacks in an isolated laboratory environment is a way to understand how different equipment, which is part of the company's hardware, behaves in reality. <br><br>  MoonGen is a good way to generate near-limit values ‚Äã‚Äãfor the network controller for traffic at the minimum of the CPU cores.  Data transfer within userspace significantly improves the performance of the stack under consideration (MoonGen + DPDK), compared to many other options for generating high traffic values.  The use of pure DPDK requires much more effort, so there is no need to be surprised at our desire to optimize work.  We also support the clone [ <a href="https://github.com/QratorLabs/MoonGen">7</a> ] of the original MoonGen repository in order to extend the functionality and implement its own tests. <br><br>  In order to achieve maximum flexibility, the packet generation logic is set by the user using the Lua script, which is one of the main features of MoonGen.  In the case of relatively simple packet processing, this solution works fast enough to saturate the 10G interface on a single CPU core.  A typical way to modify incoming packages and create new ones is to work with packages of the same type, in which only some of the fields change. <br><br>  An example of this is the l3-tcp-syn-ack-flood test, described below.  Note that any modification of the package can be made in the same buffer where the package was generated or received in the previous step.  Indeed, this kind of packet conversion is performed very quickly, since it does not involve expensive operations, such as system calls, access to potentially uncached memory, and so on. <br><br><h2>  Tests on Qrator Labs hardware </h2><br>  Qrator Labs conducts all tests in the laboratory on various equipment.  In this case, we used the following network interface controllers: <br><br><ul><li>  Intel 82599ES 10G </li><li>  Mellanox ConnectX-4 40G </li><li>  Mellanox ConnectX-5 100G </li></ul><br>  We note separately that when working with network controllers operating on standards higher than 10G, the performance problem is getting more acute.  Today it is not possible to saturate the 40G interface with one core, although this is already possible with a small number of cores. <br><br>  In the case of Mellanox network controllers, it is possible to change some parameters and device settings using the tuning guide [ <a href="http://www.mellanox.com/related-docs/prod_software/Performance_Tuning_Guide_for_Mellanox_Network_Adapters.pdf">3</a> ] provided by the manufacturer.  This allows you to increase productivity, and in some special cases - to deeper change the behavior of the NIC.  Other manufacturers may have similar documents for their own high-performance devices intended for professional use.  Even if you cannot find such a document in the public domain, it always makes sense to contact the manufacturer directly.  In our case, the representatives of Mellanox were very kind and, in addition to providing documentation, quickly answered the questions we had, thanks to which we managed to achieve 100% utilization of the strip, which was very important for us. <br><br><h3>  Test TCP SYN flood </h3><br>  L3-tcp-syn-ack-flood is an example of simulating an attack like SYN flood [ <a href="https://en.wikipedia.org/wiki/SYN_flood">6</a> ].  This is an enhanced Qrator Labs version of the l3-tcp-syn-flood test from the MoonGen main repository, which is stored in our repository clone. <br><br>  Our test can run three kinds of processes: <br><br><ol><li>  Generate from scratch a TCP SYN packet stream, varying the required fields, such as source IP address, source port number, etc .; </li><li>  Create a valid ACK response for each received SYN packet according to the TCP protocol; </li><li>  Create a valid SYN-ACK response for each received ACK packet according to the TCP protocol. </li></ol><br>  For example, the internal (respectively, the ‚Äúhottest‚Äù) loop of code for creating ACK responses is as follows: <br><br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tx = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> rx = rxQ:recv(rxBufs) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, rx <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> buf = rxBufs[i] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pkt = buf:getTcpPacket(ipv4) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pkt.ip4:getProtocol() == ip4.PROTO_TCP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pkt.tcp:getSyn() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (pkt.tcp:getAck() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> synack) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> seq = pkt.tcp:getSeqNumber() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ack = pkt.tcp:getAckNumber() pkt.tcp:unsetSyn() pkt.tcp:setAckNumber(seq+<span class="hljs-number"><span class="hljs-number">1</span></span>) pkt.tcp:setSeqNumber(ack) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tmp = pkt.ip4.src:get() pkt.ip4.src:set(pkt.ip4.dst:get()) pkt.ip4.dst:set(tmp) ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">-- some more manipulations with packet fields tx = tx + 1 txBufs[tx] = buf end end if tx &gt; 0 then txBufs:resize(tx) txBufs:offloadTcpChecksums(ipv4) -- offload checksums to NIC txQ:send(txBufs) end</span></span></code> </pre> <br>  The general idea of ‚Äã‚Äãcreating a response packet is as follows.  First, you need to remove the packet from the RX queue, then check whether the packet type matches the expected one.  If there is a match, prepare an answer by modifying some fields of the original package.  Finally, put the created packet into the TX queue using the same buffer.  To improve performance, instead of taking and modifying packets one by one, we aggregate them, extract all available packets from the RX queue, create the corresponding responses and put them all into the TX queue.  Despite a sufficiently large number of manipulations on one package, the performance remains high, primarily due to the fact that the Lua JIT compiles all these operations into a small number of processor instructions.  Many other tests, not just TCP SYN / ACK, work on the same principle. <br><br>  The table below shows the results of the SYN flood test (generating SYN without trying to respond) using Mellanox ConnectX-4.  This NIC has two 40G ports with a theoretical performance ceiling of 59.52 Mpps per port and 2 * 50 Mpps for two ports.  The concrete implementation of connecting a NIC to a PCIe limits the bandwidth somewhat (yielding 2 * 50 instead of the expected 2 * 59.52). <br><table><tbody><tr><td>  <b>cores per port</b> </td><td>  <b>1 port, Mpps</b> </td><td>  <b>2 ports, Mpps per each port</b> </td></tr><tr><td>  one </td><td>  20 </td><td>  nineteen </td></tr><tr><td>  2 </td><td>  38 </td><td>  36 </td></tr><tr><td>  3 </td><td>  56.5 </td><td>  47 </td></tr><tr><td>  four </td><td>  59.5 </td><td>  50 </td></tr></tbody></table><br>  <i>SYN flood test;</i>  <i>NIC: Mellanox Technologies MT27700 Family (ConnectX-4), dual 40G port;</i>  <i>CPU: Intel¬Æ Xeon¬Æ Silver 4114 CPU @ 2.20GHz</i> <br><br>  The following table shows the results of the same SYN flood test conducted on Mellanox ConnectX-5 with one 100G port. <br><table><tbody><tr><td>  <b>cores</b> </td><td>  <b>Mpps</b> </td></tr><tr><td>  one </td><td>  35 </td></tr><tr><td>  2 </td><td>  69 </td></tr><tr><td>  3 </td><td>  104 </td></tr><tr><td>  four </td><td>  127 </td></tr><tr><td>  five </td><td>  120 </td></tr><tr><td>  6 </td><td>  131 </td></tr><tr><td>  7 </td><td>  132 </td></tr><tr><td>  eight </td><td>  144 </td></tr></tbody></table><br>  <i>SYN flood test;</i>  <i>NIC: Mellanox Technologies MT27800 Family (ConnectX-5), single 100G port;</i>  <i>CPU: Intel¬Æ Xeon¬Æ Silver 4114 CPU @ 2.20GHz</i> <br><br>  Note that in all cases we reach more than 96% of the theoretical performance ceiling on a small number of processor cores. <br><br><h3>  Capture incoming traffic and save to PCAP files </h3><br>  Another example of the test is rx-to-pcap, which attempts to capture all incoming traffic and save to a certain number of PCAP files [ <a href="https://en.wikipedia.org/wiki/Pcap">8</a> ].  Although this test is not specifically concerned with the generation of packets as such, it serves as a demonstration of the fact that the filespace is the weakest link in the organization of data transfer through userspace.  Even the tmpfs virtual file system slows down the stream significantly.  In this case, 8 CPU cores are needed for the disposal of 14.88 Mpps, while just one core is enough to receive (and reset, or redirect) the same amount of traffic. <br><br>  The following table shows the amount of traffic (in Mpps) that was received and saved in PCAP files that are in the ext2 file system on the SSD (second column) or on the tmpfs file system (third column). <br><table><tbody><tr><td>  <b>cores</b> </td><td>  <b>on SSD, Mpps</b> </td><td>  <b>on tmpfs, mpps</b> </td></tr><tr><td>  one </td><td>  1.48 </td><td>  1.62 </td></tr><tr><td>  2 </td><td>  four </td><td>  4.6 </td></tr><tr><td>  3 </td><td>  6.94 </td><td>  8.1 </td></tr><tr><td>  four </td><td>  9.75 </td><td>  11.65 </td></tr><tr><td>  five </td><td>  12.1 </td><td>  13.8 </td></tr><tr><td>  6 </td><td>  13.38 </td><td>  14.47 </td></tr><tr><td>  7 </td><td>  14.4 </td><td>  14.86 </td></tr><tr><td>  eight </td><td>  14.88 </td><td>  14.88 </td></tr></tbody></table><br>  <i>Rx-to-pcap test;</i>  <i>NIC: Intel 82599ES 10-Gigabit;</i>  <i>CPU: Intel¬Æ Xeon¬Æ CPU E5-2683 v4 @ 2.10GHz</i> <br><br><h2>  MoonGen modification: tman task manager </h2><br>  We would also like to present the reader with its own extension of the MoonGen functional, which provides another way to run a group of tasks for testing.  The main idea here is to separate the overall configuration and the settings specific to each task, allowing you to run an arbitrary number of different tasks (that is, Lua scripts) at the same time.  In our clone of the MoonGen repository, the implementation of MoonGen with the task manager [ <a href="https://github.com/QratorLabs/MoonGen">9</a> ] is presented, here we only briefly list its main functions. <br><br>  The new command line interface allows you to run multiple tasks of different types at the same time.  The baseline script looks like this: <br><br><pre> <code class="bash hljs">./build/tman [tman options...] [-- &lt;task1-file&gt; [task1 options...]] [-- &lt;task2-file&gt; [task2 options...]] [-- ...]</code> </pre> <br>  In addition, ./build/tman -h provides detailed help. <br><br>  However, there is a limitation - regular Lua task files are incompatible with the <i>tman</i> interface.  The <i>tman</i> task <i>file</i> must clearly define the following objects: <br><br><ul><li>  A configure (parser) function describing the parameters of the job; </li><li>  The task function (taskNum, txInfo, rxInfo, args), which describes the actual task process.  Here txInfo and rxInfo are arrays of RX and TX queues, respectively;  args contains the parameters of the task manager and the task itself. </li><li>  Examples can be found in examples / tman. </li></ul><br>  Using the task manager gives you more flexibility in running heterogeneous tests. <br><br><h3>  findings </h3><br>  The method that MoonGen offers proved to be well suited to our goals and satisfied the staff with the results.  We got a tool with high performance, while maintaining both the test environment and the language quite simple.  The high performance of this setup is achieved thanks to two main features: direct access to the buffers of the network interface controller and the Just-In-Time compilation technique in Lua. <br><br>  As a rule, achieving a theoretical ceiling for the performance of a network interface controller is quite a feasible task.  As we have demonstrated, a single core can be enough to saturate a 10G port, while with a large number of cores there is no particular problem and the full load of 100G port. <br><br>  We are especially grateful to the Mellanox team for their help in working with their equipment and the MoonGen team for their reaction in correcting errors. <br><br><h2>  Materials </h2><br><ol><li>  <a href="https://www.net.in.tum.de/fileadmin/bibtex/publications/papers/MoonGen_IMC2015.pdf">MoonGen: A Scriptable High-Speed ‚Äã‚ÄãPacket Generator - Paul Emmerich et al., Internet Measurement Conference 2015 (IMC'15), 2015</a> </li><li>  <a href="http://netoptimizer.blogspot.com/2014/10/unlocked-10gbps-tx-wirespeed-smallest.html">Pktgen</a> </li><li>  <a href="http://www.mellanox.com/related-docs/prod_software/Performance_Tuning_Guide_for_Mellanox_Network_Adapters.pdf">Mellanox tuning guide</a> </li><li>  <a href="https://www.dpdk.org/">Data Plane Development Kit</a> </li><li>  <a href="https://www.lua.org/">Lua</a> </li><li>  <a href="https://en.wikipedia.org/wiki/SYN_flood">SYN flood</a> </li><li>  <a href="https://github.com/QratorLabs/MoonGen">Qrator Labs' clone of MoonGen repository</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Pcap">PCAP file format</a> </li><li>  <a href="https://github.com/QratorLabs/MoonGen">Task manager</a> </li><li>  <a href="https://nullprogram.com/blog/2018/05/27/">Lua performance</a> </li><li>  <a href="https://portal.etsi.org/NFV/NFV_White_Paper.pdf">Network Functions Virtualization Whitepaper</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA, non-uniform memory access</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/423957/">https://habr.com/ru/post/423957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423947/index.html">Our personal data is worth nothing.</a></li>
<li><a href="../423949/index.html">Universe corresponding to our current views may not be possible.</a></li>
<li><a href="../423951/index.html">In the footsteps of Nintendo: Sony launches PlayStation Classic in December</a></li>
<li><a href="../423953/index.html">Man-function or stop hiring technology</a></li>
<li><a href="../423955/index.html">How we created a high-tech product and fell to the bottom</a></li>
<li><a href="../423959/index.html">Underwater affairs - for robots</a></li>
<li><a href="../423961/index.html">Do not lose yourself: a new method of diagnosing dementia</a></li>
<li><a href="../423963/index.html">Prologue of Kelvin Point</a></li>
<li><a href="../423965/index.html">You bought the SIEM and are sure that the SOC is in your pocket, isn't it?</a></li>
<li><a href="../423967/index.html">The whole truth about the RTOS. Article # 10. Scheduler: additional features and context preservation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>