<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reflection in C ++ 14</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a transcript (with minor corrections) of the report by Anton antoshkka Polukhin - ‚ÄúA bit of magic for C ++ 14‚Äù. 

 I've been tinkering...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reflection in C ++ 14</h1><div class="post__text post__text-html js-mediator-article">  <i>This article is a transcript (with minor corrections) of the report by Anton <a href="https://habrahabr.ru/users/antoshkka/" class="user_link">antoshkka</a> Polukhin - ‚ÄúA bit of magic for C ++ 14‚Äù.</i> <br><br>  I've been tinkering with C ++ recently and accidentally discovered a couple of new metaprogramming techniques that allow you to make a reflection in C ++ 14.  A couple of motivational examples.  Here you have some kind of POD structure, there are some fields in it: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">complicated_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> u; };</code> </pre> <br>  The number of fields and their names do not matter, the important thing is that from this structure we can write the following piece of code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "magic_get.hpp" struct complicated_struct { /* ‚Ä¶ */ }; int main() { using namespace pod_ops; complicated_struct s {1, 2, 3.0, 4}; std::cout &lt;&lt; "s == " &lt;&lt; s &lt;&lt; std::endl; // Compile time error? }</span></span></span></span></code> </pre><br>  The main function, in it we create a variable of our structure, we somehow initialize it through aggregate initialization, and then we try to output this variable to std :: cout.  And at this moment we, in theory, should have a compilation error: we have not defined a stream output operator for our structure, the compiler does not know how to compile all this and output it.  However, it will compile and display the contents of the structure: <br><br><pre> <code class="hljs ruby">antoshkka@home<span class="hljs-symbol"><span class="hljs-symbol">:~</span></span>$ ./test s == {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}</code> </pre> <br><a name="habracut"></a><br>  We can return to the code, change the names of the fields, change the name of the structure, change the name of the variable, whatever we can do - the code will continue to work and display the contents of the structure correctly.  Let's see how it works. <br><br>  The operator is described in the header file magicget.hpp, it works with any data types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Char</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:basic_ostream&lt;Char, Traits&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::basic_ostream&lt;Char, Traits&gt;&amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { flat_write(out, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out; }</code> </pre><br>  This statement calls the flat_write method.  The flat_write method prints braces and contains a string in the middle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Char</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flat_write</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:basic_ostream&lt;Char, Traits&gt;&amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; val) { out &lt;&lt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>; detail::flat_print_impl&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, flat_tuple_size&lt;T&gt;::value &gt;::print(out, val); out &lt;&lt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>; }</code> </pre><br>  In the middle of the string string there is a flat_tuple_size &lt;T&gt; :: value.  And here it should be noted that the standard library has std :: tuple_size &lt;std :: tuple&gt;, which introduces the number of elements in a tuple.  However, here T is not a tuple, not std :: tuple, but a custom type.  Here, flat_tuple_size prints the number of fields in a custom type. <br><br>  Let's look further at what the print function does: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> FieldIndex, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> FieldsCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flat_print_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stream</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!FieldIndex) out &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span>; out &lt;&lt; flat_get&lt;FieldIndex&gt;(value); <span class="hljs-comment"><span class="hljs-comment">// std::get&lt;FieldIndex&gt;(value) flat_print_impl&lt;FieldIndex + 1, FieldsCount&gt;::print(out, value); } };</span></span></code> </pre><br>  The print function displays or does not display a comma depending on the index of the field with which we work, and then comes the call to the flat_get function and the comment that it works like std :: get, that is, returns the field from the structure by index.  A natural question appears: how does it work? <br><br>  It works as follows: the output operator in the stream determines the number of fields of your structure, iterates over the fields through the indices and outputs each of the fields by index.  Thus it turns out that you saw at the beginning of the article. <br><br>  Let's further understand how to make the flat_get and flat_tuple_size methods, which work with user structures, determine the number of fields in the structure, output this structure by fields: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns const reference to a field with index `I` /// Example usage: flat_get&lt;0&gt;(my_structure()); template &lt;std::size_t I, class T&gt; decltype(auto) flat_get(const T&amp; val) noexcept; /// `flat_tuple_size` has a member `value` that constins fields count /// Example usage: std::array&lt;int, flat_tuple_size&lt;my_structure&gt;::value &gt; a; template &lt;class T&gt; using flat_tuple_size;</span></span></code> </pre><br>  Let's start with the simple.  We will calculate the number of fields in the structure.  We have a POD structure T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_pod&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre><br>  for this structure, we can write an expression: <br><br><pre> <code class="cpp hljs">T { args... }</code> </pre><br>  This is an aggregate initialization structure.  This expression is successfully compiled if the number of arguments is less than or equal to the number of fields within the structure and each type of argument corresponds to the type of field within the structure. <br><br>  From this abracadabra we will try to get the number of fields within the T structure. How will we do this?  We take our structure T and try to initialize it with some huge number of arguments.  This will not compile.  We will reject one of the arguments and try again.  This also does not compile, but someday we will get to that number of arguments, which is equal to the number of fields inside our structure, and then it will gather.  At this point, we just need to remember the number of arguments - and now we are ready: we have the number of fields within the structure.  This is a basic idea.  Let's go into the details. <br><br>  How many arguments do we need from the very beginning if our T structure contains only char or unsigned char and other types of 1 byte size?  In this case the number of fields inside the structure T will be equal to the size of this structure.  If we have other fields, for example, int or pointer, then the number of fields will be less than the size of the structure. <br><br>  We got the number of fields from which to start aggregate initialization.  That is, we will initialize our structure T with the number of arguments equal to sizeof (T).  If it failed to compile, then we discard one argument, try again, if compiled, we found the number of fields within the structure.  One problem remains: even if we guessed with the number of arguments within the structure, the code will still fail.  Because we need to know the type of field. <br><br>  Let's do a workaround.  We will make a structure with an implicit type cast operator to any type: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ubiq</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&amp;() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = ubiq{}; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = ubiq{}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = ubiq{};</code> </pre><br>  This means that the variables of this structure are converted to any type: int, double, std :: string, std :: vector, any custom types, to anything. <br><br>  Completely recipe: we take the structure T and try to aggregate the initialization of this structure with the number of arguments equal to sizeof (T), where each argument is an instance of our ubiq structure.  At the aggregate initialization stage, each instance from ubiq will turn into a field type inside the T structure, and we just need to choose the number of arguments.  If many arguments are not compiled, we drop one and try again.  If it was compiled, then we count the number of arguments - and we get the result. <br><br>  Now for some code.  Slightly changing the structure of ubiq: add a template parameter to make it easier to use this structure with variadic templates.  We also need std :: make_index_sequence (an entity from C ++ 14, which expands to std :: index_sequence - a long chain of digits). <br><br>  Ready to see the scary code?  Go. <br><br>  Only two functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// #1 template &lt;class T, std::size_t I0, std::size_t... I&gt; constexpr auto detect_fields_count(std::size_t&amp; out, std::index_sequence&lt;I0, I...&gt;) -&gt; decltype( T{ ubiq_constructor&lt;I0&gt;{}, ubiq_constructor&lt;I&gt;{}... } ) { out = sizeof...(I) + 1; /*...*/ } // #2 template &lt;class T, std::size_t... I&gt; constexpr void detect_fields_count(std::size_t&amp; out, std::index_sequence&lt;I...&gt;) { detect_fields_count&lt;T&gt;(out, std::make_index_sequence&lt;sizeof...(I) - 1&gt;{}); }</span></span></code> </pre><br>  Both functions are named detect_fields_count.  The first function is a bit more specialized.  Thus, when the compiler sees detect_fields_count &lt;T&gt;, it will think that the first function is more specialized and that it should try to use it. <br><br>  This function has a trailing return type, that is, the type of this function is a decltype from T with <br>  aggregate initialization.  If we have guessed the number of arguments, then this expression will compile, we fall into the body of this function and write the number of arguments that we have to the output variable out.  If it did not work out (we did not guess the number of arguments), then the compiler will think that this is not an error, but a substitution failure, and it must find another function with the same name, but less specialized one.  It will take function # 2.  Function # 2 discards one of the indices (that is, reduces the number of arguments by one) and calls detect_fields_count again.  Again, either the first function or the second will be called.  Thus, we will go over the arguments and find the number of fields within the structure.  That was the easy part. <br><br>  Ahead is difficult: how to get the field type inside the structure T? <br><br>  We already have our expression T with aggregate initialization and we pass ubiq's instances inside.  Each ubiq instance is called an implicit type cast operator, and we know the type of the field inside this operator.  All we need now is to somehow grab and pull this information into the outer scope, where we can work with it ‚Äî beyond the limits of the aggregate initialization of the T structure. Unfortunately, in C ++ there is no mechanism to write the data type into a variable.  More precisely, there are std :: type_index and std :: type_info, but they are useless at the compilation stage.  We from them then will not pull out back type. <br><br>  Let's try to somehow get around this limitation.  To do this, recall what POD is (but very roughly: the standardization committee likes to change the definition every three years). <br><br>  A POD structure is a structure whose fields are labeled either public, private or protected (we are only interested in public fields).  And all the fields inside this structure are either other POD structures or fundamental types: pointers, int, std :: nullptr_t.  For a couple of minutes, let's forget about pointers and we‚Äôll find out that the fundamental types are quite small, less than 32-x, and this means that we can assign an identifier (integral dial) to each fundamental type.  This tsiferku we can write to the output array, pull this output array beyond the implicit conversion of the operator, and then convert the tsiferku to type.  Here is such a simple idea. <br><br>  I went implementation.  To do this, we change our ubiq structures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ubiq_val</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* ref_; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span> ref_[I] = typeid_conversions::type_to_id(identity&lt;Type&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Type{}; } };</code> </pre><br>  There is now a pointer to the output array, and this output array has the terrible name ref_, but it did.  The implicit casting operator has also changed: it now calls the type_to_id function.  It converts the type to the identifier and we write this identifier to the output array ref_.  It remains to generate a bunch of type_to_id methods.  We will do this using a macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BOOST_MAGIC_GET_REGISTER_TYPE(Type, Index) \ constexpr std::size_t type_to_id(identity</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Type&gt;) noexcept { \ return Index; \ } \ constexpr Type id_to_type( size_t_&lt;Index &gt; ) noexcept { \ Type res{}; \ return res; \ } \ /**/</span></span></span></span></code> </pre><br>  The macro will generate the type_to_id function that turns the type into an identifier and also generates the id_to_type function for us, which turns the identifier back into type.  This macro is not visible to the user.  As soon as we used it, we undefine it.  We register the fundamental types (not all are listed here): <br><br><pre> <code class="cpp hljs">BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> , <span class="hljs-number"><span class="hljs-number">2</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> , <span class="hljs-number"><span class="hljs-number">3</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> , <span class="hljs-number"><span class="hljs-number">4</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> , <span class="hljs-number"><span class="hljs-number">5</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> , <span class="hljs-number"><span class="hljs-number">8</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> , <span class="hljs-number"><span class="hljs-number">9</span></span>) BOOST_MAGIC_GET_REGISTER_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> , <span class="hljs-number"><span class="hljs-number">10</span></span>) ...</code> </pre><br>  Zero do not use.  I will say why later.  Registered all fundamental types.  Now we make a function that turns type T into an array of field identifiers inside this type T. The most interesting is in the body of this function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>... I&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_to_array_of_type_ids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* types)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T{ ubiq_constructor&lt;I&gt;{}... })</span></span></span><span class="hljs-function"> </span></span>{ T tmp{ ubiq_val&lt; I &gt;{types}... }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br>  Here comes the aggregate initialization of the time variable, and we pass ubiq's instances there.  This time they hold a pointer to the output array: here types is the output array, into which we will write the identifiers of the field types.  After this line (after initializing the temporary variable), the output array types will store the type identifiers of each field.  The type_to_array_of_type_ids function is constexpr, that is, everything can be used at the compilation stage.  Beautiful!  We have left the identifiers to turn back into types.  This is done like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>... I&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_tuple_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I...&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = array_of_type_ids&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// #0 return std::tuple&lt; // #3 decltype(typeid_conversions::id_to_type( // #2 size_t_&lt;a[I]&gt;{} // #1 ))... &gt;{}; }</span></span></code> </pre><br>  Zero line: here we get an array of identifiers.  Here, the type of the variable a is something similar to std :: array, but heavily dependent, so that it can be used in constexpr expressions (because we have C ++ 14, not C ++ 17, where most problems with constexpr for std :: arrary fixed). <br><br>  In line # 1, we create an integral constant from the element of the array.  The integral constant is std :: integral_constant, the first parameter for which is size_t_, and the second parameter will be our a [I].  size_t_ is the using declaration, alias.  In line # 2 we convert the identifier back to type, and in line # 3 we create std :: tuple, and each element from this tuple corresponds exactly to the data types inside the T structure, the structures inside which we looked.  Now we can do something very dumb.  For example, reinterpret_cast user structure to tuple'u.  And we can work with the user structure as a tuple.  Well, yes: smiles: reinterpret_cast. <br><br>  I warn you, do not try to copy and run because the code is a bit simplified.  For example, std :: tuple does not specify the order in which arguments are created and destroyed: some implementations initialize the arguments from the end forward, store them in the wrong order, which is why std :: tuple does not work.  Need to make your own. <br><br>  Let's go further.  What to do with pointers: pointers to constant pointers, pointers to ints, etc.? <br><br>  We have a type_to_id function.  It returns std :: size_t and we have not used a bunch of bitties from this std :: size_t: we used only for 32 fundamental types.  So, these bitiki can be used for encoding information about the pointer.  For example, if we have in the user structure a field with the unsigned char type, then in binary form it will look like this: <br><br> <code>unsigned char c0; // 0b00000000 00000000 00000000 000 <b>00001</b> <br></code> <br>  The least significant bit contains the char identifier.  This is one: this is how we assigned it in the macro.  If we have an unsigned char pointer, then the most significant bitiki will now store information that this is a pointer: <br><br> <code>unsigned char* 1; // 0b <b>001</b> 00000 00000000 00000000 000 <b>00001</b> <br></code> <br>  If we have a constant pointer, then the most significant bitiki store information that this is a constant pointer: <br><br> <code>const unsigned char* 2; // 0b <b>010</b> 00000 00000000 00000000 000 <b>00001</b> <br></code> <br>  If we add an additional level of indirection (another pointer), then the other most senior bitiki will change and will store information that we have a pointer: <br><br> <code>const unsigned char** 3; // 0b <b>010001</b> 00 00000000 00000000 000 <b>00001</b> <br></code> <br>  Change the underlying type: the most significant bits do not change, the least significant now contain the identifier of the seven, which means that we work with the short: <br><br> <code>const short** s0; // 0b <b>010001</b> 00 00000000 00000000 000 <b>00111</b> <br></code> <br>  We add functions that convert a type to an identifier (and add these bitics accordingly): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_to_id(identity&lt;Type*&gt;) <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_to_id(identity&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type*&gt;) <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_to_id(identity&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Type*&gt;) <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_to_id(identity&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Type*&gt;)</code> </pre><br>  And we add inverse functions that convert the identifier back to the type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id_to_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_t_&lt;Index&gt;, if_extension&lt;Index, native_const_ptr_type&gt; = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id_to_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_t_&lt;Index&gt;, if_extension&lt;Index, native_ptr_type&gt; = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id_to_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_t_&lt;Index&gt;, if_extension&lt;Index, native_const_volatile_ptr_type&gt; = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id_to_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_t_&lt;Index&gt;, if_extension&lt;Index, native_volatile_ptr_type&gt; = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre><br>  Here if_extension is std :: enable_if with aliases and lots of magic.  The magic is that, depending on the identifier, it allows you to call only one of the functions presented. <br><br>  I don‚Äôt know what to do with enums.  The only thing I could think of was to call std :: listing_type.  That is, we lose information about what this enum is: we cannot register all user enums in our list of fundamental types, it is simply impossible.  Instead, we encode only how this enum is stored.  If it is an int, then we will save it as an int, if the user has specified a class enum: char, then we will get a char and encode only the char, information about the enum type will be lost. <br><br>  With complex structures and classes the same problem: we cannot register them all with our list of fundamental types.  Therefore, we will simply once again look inside the class and encode all the fields that exist in this class as if they are in our zero level class. <br><br>  Suppose we have a structure a, it has a field whose type is structure b, we look inside b and all fields from b drag inside a.  I simplify: there is still a lot of logic with alignments to prevent them from breaking. <br><br>  It is done this way: one type_to_id function is added: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_to_id</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;Type&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:enable_if&lt; !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;Type&gt;::value &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_empty&lt;Type&gt;::value&gt;::type*) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array_of_type_ids&lt;Type&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Returns array! }</span></span></code> </pre><br>  This time, it can return an array (all past ones returned size_t).  We will need to change our ubiq structure so that it can work with arrays, add logic to how to define offset'y, where to write offset'y and information about which substructure we work with.  This is all long and not very interesting, there are a couple of examples of how this turns out, these are also technical details. <br><br>  What does this give us and where can all this be used?  No, you do not need to write it yourself, because there is a ready-made library that implements all this.  That's what the library gives you. <br><br>  First <b>comparisons</b> : no longer need to manually write comparisons for <br>  POD structures  There are three methods.  Ie you can write nothing at all, but connect one header file and for all POD structures you will have a comparison out of the box. <br><br>  There are <b>heterogeneous comparisons</b> : you can have two structures with the same fields, but <br>  different data types compare with each other. <br><br>  There is a <b>universal hash function</b> : you pass in any user structure there, and it considers it a hash. <br><br>  <b>I / O operators</b> : what we have already seen in the introduction, everything also exists and works. <br><br>  When I first talked about this metaprogram magic, the developers were very happy with some hardware (I won‚Äôt remember exactly).  They say that they have 1000 different flat structures that represent different protocols.  That is, the one-to-one structure is mapped on the protocol.  For each of these structures, they have three serializers (depending on which hardware and which wires are used in the future).  And that they have 3000 serializers.  They were very unhappy about it.  With the help of this library, they were able to simplify 3000 serializers to 3 serializers.  They were extremely happy. <br><br>  These metaprogram tricks offer the opportunity for basic reflection: you can write new type_traits, for example: is_continuous_layout &lt;T&gt;, is_padded &lt;T&gt;, has_unique_object_representations &lt;T&gt; (as in C ++ 17). <br><br>  You can write great punch_hole &lt;T, Index&gt; functions (which are not in the library) and which define unused bitics and baitics in the user structure, return a link to them, allowing other people to use them. <br><br>      :    boost::spirit, ,       ,             boost::fusion  boost::spirit. ,    boost::spirit     : ‚Äú-  !    ,     ‚Äù.   . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> foo { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">comparable_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">50</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bl; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a,b,c,d,e,f; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace foo std::set&lt;foo::comparable_struct&gt; s;</span></span></code> </pre><br>    .   ,       -  .   std::set.          .     std::tie     ,    ,   ,      . .     .      :  ,    std::set,  .     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;foo::comparable_struct&gt; s = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ofs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"dump.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; a: s) ofs &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>   ofstream       . <br><br>   :        ,   ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;foo::comparable_struct&gt; s; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"dump.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; foo::comparable_struct cs; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ifs &gt;&gt; cs) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ignore = {}; ifs &gt;&gt; ignore; s.insert(cs); }</code> </pre><br> :  . <br><br>    ,    ,   .  flat_tie:        std::tuple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flat_tie</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> s; }; my_struct s; flat_tie(s) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt;{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>};</code> </pre><br>    my_struct::i   10,  my_struct::s  11   s. <br><br>         ,     , -,    C++14,       . <br><br>     reinterpret_cast.  reinterpret_cast'   :      constexpr,    . <br><br>     .     :     .      C++17.  :  C++17  structure binding.   ,       ,    .     ,            ,   enable_if    structure binding.             .         tag dispatching: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_tuple</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> size_t_&lt;fields_count&lt;T&gt;()&gt; fields_count_tag; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::as_tuple_impl(val, fields_count_tag{}); }</code> </pre><br>    as_tuple_impl: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_tuple_impl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t_</span></span></span><span class="hljs-class">&lt;1&gt;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::make_tuple_of_references(a); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_tuple_impl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t_</span></span></span><span class="hljs-class">&lt;2&gt;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a,b] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::make_tuple_of_references(a,b); }</code> </pre><br>    as_tuple_impl         T.   ,    T    ,     as_tuple_impl.   structure binding,   ,         ,    .       ,   structure binding   .    ,         b,  ,          .  Beauty! <br><br>  ,    constexpr,      std::get        ‚Äî      .  .    ,    structure binding   :     structure binding.    ,        . <br><br>    <a href="https://habrahabr.ru/users/antoshkka/" class="user_link">antoshkka</a>  ‚Äî <a href="https://youtu.be/jDI5CHKFKd0">https://youtu.be/jDI5CHKFKd0</a> <br> <a href="https://github.com/apolukhin/magic_get"> Precise and Flat Reflection (magic_get)</a> </div><p>Source: <a href="https://habr.com/ru/post/344206/">https://habr.com/ru/post/344206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344194/index.html">Search for an object in an image using a perceptual hash</a></li>
<li><a href="../344196/index.html">DevDay on functional</a></li>
<li><a href="../344198/index.html">Dependent events and statistical fluctuations or why the ‚Äúwaterfall‚Äù will die</a></li>
<li><a href="../344200/index.html">GitLab 10.2 released: Customizable task boards and GitLab Geo in shared access</a></li>
<li><a href="../344204/index.html">Performance mdadm raid 5,6,10 and ZFS zraid, zraid2, ZFS striped mirror</a></li>
<li><a href="../344210/index.html">How to find out what the program for Linux will do without actually doing it?</a></li>
<li><a href="../344214/index.html">Strike iron: hot hardware startups</a></li>
<li><a href="../344216/index.html">What's new in DataGrip 2017.3</a></li>
<li><a href="../344220/index.html">Kubernetes 1.9: a review of major innovations</a></li>
<li><a href="../344222/index.html">How to build an image classifier based on a pre-trained neural network</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>