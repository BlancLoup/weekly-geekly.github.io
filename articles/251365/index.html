<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Top 10 Mistakes That Newbies Make to Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Alexander Akbashev, I am Lead QA Engineer in the Skyforge project. As well as part-time assistant tully in Technopark on the course ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Top 10 Mistakes That Newbies Make to Java</h1><div class="post__text post__text-html js-mediator-article">  Hello, my name is Alexander Akbashev, I am Lead QA Engineer in the Skyforge project.  As well as part-time assistant <a href="https://habrahabr.ru/users/tully/" class="user_link">tully</a> in Technopark on the course "Advanced Java programming."  Our course is in the second semester of Technopark, and we get students who have completed courses in C ++ and Python.  Therefore, I have long wanted to prepare material on the most common mistakes newbies in Java.  Unfortunately, I did not intend to write such an article.  Fortunately, our compatriot Mikhail Selivanov wrote this article, but in English.  Below is a translation of this article with a few comments.  For all comments related to the translation, please write in private messages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c9/be3/e55/8c9be3e5514dc6529d833ee946381b1b.jpg"></div><br><br>  Initially, the Java language was created for <a href="http://www.oracle.com/technetwork/java/javase/overview/javahistory-index-198355.html">interactive television</a> , but over time it became used wherever possible.  Its developers were guided by the principles of object-oriented programming, abandoning the excessive complexity inherent in the same C and C ++.  Platform-independent Java virtual machine has formed a new approach to programming.  Add to this the smooth learning curve and the slogan ‚ÄúWrite once, run everywhere‚Äù, which is <b>almost</b> always true.  Still, errors still occur, and here I would like to make out the most common ones. <br><a name="habracut"></a><br><h1>  Error one: neglect existing libraries </h1><br>  For Java, a myriad of libraries has been written, but newbies often do not use all this wealth.  Before reinventing the wheel, it is better to first study the available developments on the subject of interest.  Over the years, many libraries have been brought to perfection by developers, and you can use them for free.  Examples include libraries for logback logback and Log4j, Netty and Akka network libraries.  And some developments, like Joda-Time, have become the de facto standard among programmers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On this topic I want to talk about my experience working on one of the projects.  The part of the code that was responsible for escaping HTML characters was written by me from scratch.  For several years everything worked without failures.  But once a user request provoked an endless loop.  The service stopped responding and the user tried to enter the same data again.  In the end, all the processor resources of the server allocated for this application were occupied by this infinite loop.  And if the author of this naive tool for replacing characters took advantage of one of the well-known libraries, <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/html/HtmlEscapers.html">HtmlEscapers</a> or <a href="https://github.com/google/guava">Google Guava</a> , probably this annoying incident would not have happened.  Even if there was some hidden error in the library, then surely it would have been discovered and corrected by the developer community before it manifested itself on my project.  This is typical of most of the most popular libraries. <br><br><h1>  Error two: do not use the break keyword in the Switch-Case construct </h1><br>  Such errors can be very confusing.  It happens that they are not even detected, and the code gets into production.  On the one hand, the failure of <i>switch statements</i> is often helpful.  But if it was not originally intended, the absence of the <i>break</i> keyword can lead to disastrous results.  If we omit <i>break</i> in <i>case 0</i> in the example below, the program after Zero will output One, since the command execution flow will go through all the <i>switches</i> until it encounters <i>break</i> . <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switchCasePrimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> caseIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (caseIndex) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: System.out.println(<span class="hljs-string"><span class="hljs-string">"Zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: System.out.println(<span class="hljs-string"><span class="hljs-string">"One"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: System.out.println(<span class="hljs-string"><span class="hljs-string">"Two"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: System.out.println(<span class="hljs-string"><span class="hljs-string">"Default"</span></span>); } }</code> </pre> <br>  Most often it is advisable to use polymorphism to highlight parts of the code with specific behavior in separate classes.  Such errors can be found using static code analyzers, for example, <a href="http://findbugs.sourceforge.net/">FindBugs</a> or <a href="http://pmd.sourceforge.net/">PMD</a> . <br><br><h1>  Error three: forget to release resources </h1><br>  Every time after the program opens a file or establishes a network connection, it is necessary to release the resources used.  The same applies to situations when there were any exceptions when operating with resources.  Someone might argue that the <i>FileInputStream</i> has a finalizer calling the <i>close ()</i> method for garbage collection.  But we cannot know exactly when the build cycle will start, so there is a risk that the input stream may take resources for an indefinite period of time.  Especially for such cases, Java 7 has a very useful and neat <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources statement</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printFileJava7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(FileInputStream input = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data = input.read(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(data != -<span class="hljs-number"><span class="hljs-number">1</span></span>){ System.out.print((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) data); data = input.read(); } } }</code> </pre><br>  This operator can be used with any objects related to the <i>AutoClosable</i> interface.  Then you will not have to worry about the release of resources, this will happen automatically after the execution of the operator. <br><br><h1>  Error four: memory leaks </h1><br>  In Java, automatic memory management is used, allowing you not to engage in manual allocation and release.  But this does not mean that developers can not be at all interested in how applications use memory.  Alas, but still there may be problems.  As long as the program holds references to objects that are no longer needed, the memory is not released.  Thus, it can be called a memory leak.  The reasons are different, and the most frequent of them is just the presence of a large number of references to objects.  After all, while there is a link, the garbage collector cannot remove this object from the heap.  For example, you described a class with a static field containing a collection of objects, and a link was created.  If you forgot to reset this field after the collection is no longer needed, then the link has not gone away.  Such static fields are considered roots for the garbage collector and are not collected by him. <br><br>  Another common cause of leaks is the presence of circular references.  In this case, the collector simply cannot decide whether more objects are needed that cross-reference each other.  Leaks can also occur on the stack when using the JNI (Java Native Interface).  For example: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Deque&lt;BigDecimal&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedBlockingDeque&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BigDecimal divisor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-number"><span class="hljs-number">51</span></span>); scheduledExecutorService.scheduleAtFixedRate(() -&gt; { BigDecimal number = numbers.peekLast(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; number.remainder(divisor).byteValue() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Number: "</span></span> + number); System.out.println(<span class="hljs-string"><span class="hljs-string">"Deque size: "</span></span> + numbers.size()); } }, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.MILLISECONDS); scheduledExecutorService.scheduleAtFixedRate(() -&gt; { numbers.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(System.currentTimeMillis())); }, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.MILLISECONDS); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { scheduledExecutorService.awaitTermination(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.DAYS); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { e.printStackTrace(); }</code> </pre><br>  Here are two tasks.  One of them takes the last number from the two-way <i>numbers</i> queue and prints its value and queue size if the number is a multiple of 51. The second task places the number in the queue.  Both tasks have a fixed schedule, iterations occur at intervals of 10 milliseconds.  If you run this code, the queue size will increase indefinitely.  In the end, this will cause the queue to fill all available heap memory.  To prevent this from happening, but at the same time preserve the semantics of the code, another method can be used to extract numbers from the queue: <i>pollLast</i> .  It returns an item and removes it from the queue, while <i>peekLast</i> only returns. <br><br>  If you want to learn more about memory leaks, you can study <a href="http://www.toptal.com/java/hunting-memory-leaks-in-java">the article devoted to this</a> . <br><br>  <i>Translator's note: in fact, Java has solved the problem of circular references, since</i>  <i>modern garbage collection algorithms take into account the reachability of links from root nodes.</i>  <i>If objects containing links to each other are not reachable from the root, they will be considered garbage.</i>  <i>You can read about garbage collection algorithms in the <a href="http://techbus.safaribooksonline.com/book/programming/java/0201709694">Java Platform Performance: Strategies and Tactics</a></i> . <br><br><h1>  Fifth error: excessive amount of garbage </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/aee/9ec/258aee9ec17917823bea4607e479fc74.jpg"></div><br><br>  This happens when the program creates a large number of objects that are used for a very short time.  At the same time, the garbage collector continuously removes unnecessary objects from the memory, which leads to a severe drop in performance.  A simple example: <br><br><pre> <code class="java hljs">String oneMillionHello = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { oneMillionHello = oneMillionHello + <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; } System.out.println(oneMillionHello.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>));</code> </pre><br>  In Java, string variables are immutable.  Here, at each iteration, a new variable is created, and for addressing it is necessary to use a variable <i>StringBuilder</i> : <br><br><pre> <code class="java hljs">StringBuilder oneMillionHelloSB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { oneMillionHelloSB.append(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } System.out.println(oneMillionHelloSB.toString().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>));</code> </pre><br>  If in the first variant it takes a lot of time to execute code, then in the second one the performance is already much higher. <br><br><h1>  Error six: use without the need for null pointers </h1><br>  Try to avoid using null.  For example, returning empty arrays or collections is better than methods than null, since this will prevent <i>NullPointerException</i> from occurring.  Below is an example of a method that handles a collection obtained from another method: <br><br><pre> <code class="java hljs">List&lt;String&gt; accountIds = person.getAccountIds(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String accountId : accountIds) { processAccount(accountId); }</code> </pre><br>  If <i>getAccountIds ()</i> returns null when the <i>person has</i> no <i>account</i> , a <i>NullPointerException</i> will occur.  To avoid this, you need to check for null.  And if an empty list is returned instead of null, then the problem with <i>NullPointerException</i> does not occur.  In addition, code without null checks is cleaner. <br><br>  In different situations, you can avoid using null in various ways.  For example, use the <i>Optional</i> class, which can be either an empty object or a wrapper (wrap) for any value: <br><br><pre> <code class="java hljs">Optional&lt;String&gt; optionalString = Optional.ofNullable(nullableString); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(optionalString.isPresent()) { System.out.println(optionalString.get()); }</code> </pre><br>  Java 8 uses a more concise approach: <br><br><pre> <code class="java hljs">Optional&lt;String&gt; optionalString = Optional.ofNullable(nullableString); optionalString.ifPresent(System.out::println);</code> </pre><br>  <i>Optional</i> appeared in the eighth version of Java, but in functional programming it was used long before that.  For example, in Google Guava for earlier versions of Java. <br><br><h1>  Error Seven: ignoring exceptions </h1><br>  Often, novice developers do not handle exceptions.  However, do not neglect this work.  Exceptions are thrown for a reason, and in most cases you need to understand the reasons.  Do not ignore such events.  If necessary, drop them again to view the error message, or deposit it.  As a last resort, you need to at least justify for other developers the reason why you did not understand the exception. <br><br><pre> <code class="java hljs">selfie = person.shootASelfie(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { selfie.show(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullPointerException e) { <span class="hljs-comment"><span class="hljs-comment">// , -.   ? }</span></span></code> </pre><br>  It is best to indicate the insignificance of the exception using a message in a variable: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { selfie.delete(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullPointerException unimportant) { }</code> </pre><br>  <i>Translator's note: Practice does not get tired of proving that there are no unimportant exceptions.</i>  <i>If you want to ignore the exception, then you need to add some additional checks to either not cause an exception in principle, or to ignore the exception super-pointwise.</i>  <i>Otherwise, you expect long hours of debugging in search of an error that was so easy to write to the log.</i>  <i>You also need to remember that creating an exception is not a free operation.</i>  <i>At a minimum, you need to collect a callstack, and for this you need to pause at a safepoint.</i>  <i>And it all takes time ...</i> <br><br><h1>  Error Eight: ConcurrentModificationException </h1><br>  This exception occurs when the collection is modified during iteration by any method, except for the means of the iterator itself.  For example, we have a list of hats, and we want to remove all hats with earflaps from it: <br><br><pre> <code class="java hljs">List&lt;IHat&gt; hats = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); hats.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ushanka()); <span class="hljs-comment"><span class="hljs-comment">// that one has ear flaps hats.add(new Fedora()); hats.add(new Sombrero()); for (IHat hat : hats) { if (hat.hasEarFlaps()) { hats.remove(hat); } }</span></span></code> </pre><br><div style="text-align:center;"><img src="http://www.toptal.com/uploads/blog/image/854/toptal-blog-image-1424259214406.jpg"></div><br><br>  When executing this code, a <i>ConcurrentModificationException will pop up</i> because the code modifies the collection during iteration.  The same exception will arise if one of several threads working with one list tries to modify the collection while other threads iterate it.  Simultaneous modification of the collection is a frequent occurrence with multi-threading, but in this case, you need to use appropriate tools, such as synchronization lock (synchronization lock), special collections adapted for simultaneous modification, etc. <br><br>  In the case of one thread, this problem is solved a little differently. <br><br>  <b>Collect objects and delete them in another cycle.</b> <br><br>  The decision immediately comes to mind to collect fur hat and remove them during the next cycle.  But then you have to create a new collection for storing caps that are prepared for removal. <br><br><pre> <code class="java hljs">List&lt;IHat&gt; hatsToRemove = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (IHat hat : hats) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hat.hasEarFlaps()) { hatsToRemove.add(hat); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (IHat hat : hatsToRemove) { hats.remove(hat); }</code> </pre><br>  <b>Use the <i>Iterator.remove</i> method</b> <br><br>  This is a more concise way in which you do not need to create a new collection: <br><br><pre> <code class="java hljs">Iterator&lt;IHat&gt; hatIterator = hats.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (hatIterator.hasNext()) { IHat hat = hatIterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hat.hasEarFlaps()) { hatIterator.remove(); } }</code> </pre><br>  <b>Use <i>ListIterator</i> methods</b> <br><br>  When a modified collection implements the <i>List</i> interface, it is advisable to use a list iterator (list iterator).  Iterators that implement the <i>ListIterator</i> interface support both delete operations, and additions and assignments.  <i>ListIterator</i> implements the <i>Iterator</i> interface, so our example will look almost the same as the <i>Iterator</i> deletion <i>method</i> .  The difference lies in the type of <i>header</i> iterator and its retrieval using the <i>listIterator ()</i> method.  The following fragment demonstrates how you can replace each earflap with a sombrero using the <i>ListIterator.remove</i> and <i>ListIterator.add methods</i> : <br><br><pre> <code class="java hljs">IHat sombrero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sombrero(); ListIterator&lt;IHat&gt; hatIterator = hats.listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (hatIterator.hasNext()) { IHat hat = hatIterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hat.hasEarFlaps()) { hatIterator.remove(); hatIterator.add(sombrero); } }</code> </pre><br>  With the <i>ListIterator,</i> calls to delete and add methods can be replaced by one call: <br><br><pre> <code class="java hljs">IHat sombrero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sombrero(); ListIterator&lt;IHat&gt; hatIterator = hats.listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (hatIterator.hasNext()) { IHat hat = hatIterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hat.hasEarFlaps()) { hatIterator.set(sombrero); <span class="hljs-comment"><span class="hljs-comment">// set instead of remove and add } }</span></span></code> </pre><br>  Using the flow methods presented in Java 8, you can transform the collection into a stream, and then filter it out according to some criteria.  Here is an example of how a streaming API can help in filtering caps without a <i>ConcurrentModificationException</i> : <br><br><pre> <code class="java hljs">hats = hats.stream().filter((hat -&gt; !hat.hasEarFlaps())) .collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>));</code> </pre><br>  The <i>Collectors.toCollection</i> method creates a new <i>ArrayList</i> with filtered caps.  If a large number of objects satisfy the criteria, this can be a problem, since the <i>ArrayList</i> is quite large.  So use this method with caution. <br><br>  You can do it another way - use the <i>List.removeIf</i> method, introduced in Java 8. This is the shortest option: <br><br><pre> <code class="java hljs">hats.removeIf(IHat::hasEarFlaps);</code> </pre><br>  And that's all.  At the internal level, this method is enabled by <i>Iterator.remove</i> . <br><br>  <b>Use specialized collections</b> <br><br>  If at the very beginning we decided to use <i>CopyOnWriteArrayList</i> instead of <i>ArrayList</i> , then there would be no problems at all, because <i>CopyOnWriteArrayList</i> uses modifying methods (assignment, addition and deletion) that do not change the base array of the collection.  Instead, a new, modified version is created.  This allows you to simultaneously iterate and modify the original version of the collection without fear of getting a <i>ConcurrentModificationException</i> .  The disadvantage of this method is obvious - you have to generate a new collection for each modification. <br><br>  There are collections that are configured for different cases, for example, <i>CopyOnWriteSet</i> and <i>ConcurrentHashMap</i> . <br><br>  Another possible error related to <i>ConcurrentModificationException</i> is to create a stream from the collection, and then modify the backing collection during the iteration of the stream.  Avoid this.  The following is an example of a thread abuse: <br><br><pre> <code class="java hljs">List&lt;IHat&gt; filteredHats = hats.stream().peek(hat -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hat.hasEarFlaps()) { hats.remove(hat); } }).collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>));</code> </pre><br>  The <i>peek</i> method collects all elements and applies a specific action to each.  In this case, trying to remove an item from the base list, which is not correct.  Try to use other methods described above. <br><br><h1>  Error Nine: breach of contract </h1><br>  It happens that for the correct operation of the code from the standard library or from some vendor you need to follow certain rules.  For example, the <i>hashCode</i> and <i>equals</i> contract guarantees the operation of a collection of collections from the Java collection framework, as well as other classes that use the <i>hashCode</i> and <i>equals</i> methods.  Failure to comply with the contract does not always lead to exceptions or interruption of compilation.  Everything is somewhat more complicated, sometimes it can affect the operation of the application so that you do not notice anything suspicious.  Erroneous code can get into production and lead to unpleasant consequences.  For example, cause UI to be buggy, incorrect data reports, poor performance, data loss, etc.  Fortunately, this rarely happens.  The same aforementioned contract <i>hashCode</i> and <i>equals</i> are used in collections based on hashing and comparing objects like <i>HashMap</i> and <i>HashSet</i> .  Simply put, a contract contains two conditions: <br><ul><li>  If two objects are equivalent, then their codes must also be equivalent. </li><li>  If even two objects have the same hash codes, they may not be equivalent. </li></ul><br>  Violation of the first rule leads to problems when trying to extract objects from a hashmap. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Boat</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; Boat(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Boat boat = (Boat) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(name != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? !name.equals(boat.name) : boat.name != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (Math.random() * <span class="hljs-number"><span class="hljs-number">5000</span></span>); } }</code> </pre><br>  As you can see, the <i>Boat</i> class contains overridden <i>hashCode</i> and <i>equals</i> methods.  But the contract was still broken, because <i>hashCode</i> returns random values ‚Äã‚Äãfor the same object each time.  Most likely, the boat named Enterprise will not be found in the hash array, despite the fact that it was previously added: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Boat&gt; boats = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(); boats.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boat(<span class="hljs-string"><span class="hljs-string">"Enterprise"</span></span>)); System.out.printf(<span class="hljs-string"><span class="hljs-string">"We have a boat named 'Enterprise' : %b\n"</span></span>, boats.contains(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boat(<span class="hljs-string"><span class="hljs-string">"Enterprise"</span></span>))); }</code> </pre><br>  Another example relates to the <i>finalize</i> method.  Here is what is said about its functionality in the official Java documentation: <br><blockquote>  The main contract <i>finalize</i> is that it is invoked then and if, when the virtual machine determines that there are no longer any reasons why this object should be available to any thread (not yet dead).  An exception may be the result of the completion of some other object or class that is ready to be completed.  The <i>finalize</i> method can perform any action, including again making the object available to other threads.  But usually <i>finalize is</i> used for cleanup actions before the object is permanently deleted.  For example, this method for an object that is an input / output connection can explicitly perform an I / O transaction to break the connection before the object is permanently deleted. </blockquote><br>  You should not use the <i>finalize</i> method to release resources like file handlers, because it is not known when it can be called.  This can occur while the garbage collector is running.  As a result, the duration of his work will be unpredictably delayed. <br><br><h1>  Error tenth: using raw types instead of parameterized ones </h1><br>  According to the Java specification, the raw type is either a non-parameterized or non-static member of class <i>R</i> , which is not inherited from the superclass or superinterface <i>R.</i>  Before the appearance of generic types in Java, there was no alternative to raw types.  Generalized programming has been supported since version 1.5, and this was a very important step in the development of the language.  However, for the sake of compatibility, it was not possible to get rid of such a disadvantage as the potential for breaking the class system. <br><br><pre> <code class="java hljs">List listOfNumbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); listOfNumbers.add(<span class="hljs-number"><span class="hljs-number">10</span></span>); listOfNumbers.add(<span class="hljs-string"><span class="hljs-string">"Twenty"</span></span>); listOfNumbers.forEach(n -&gt; System.out.println((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) n * <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Here the list of numbers is presented in the form of a raw ArrayList.  Since its type is not specified, we can add any object to it.  But in the last line elements are thrown into int, doubled and output.  This code will be compiled without errors, but if you run it, a runtime exception will pop up, because we are trying to write the string variable to a numeric one.  Obviously, if we hide the necessary information from the type system, it will not prevent us from writing erroneous code.  Therefore, try to determine the types of objects that are going to be stored in the collection: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; listOfNumbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); listOfNumbers.add(<span class="hljs-number"><span class="hljs-number">10</span></span>); listOfNumbers.add(<span class="hljs-string"><span class="hljs-string">"Twenty"</span></span>); listOfNumbers.forEach(n -&gt; System.out.println((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) n * <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  This example differs from the original version in the line in which the collection is defined: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; listOfNumbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre><br>  This option is not compiled because we are trying to add a string variable to the collection that can store only numeric ones.  The compiler will generate an error and point to the line in which we are trying to add the string Twenty to the list.  So always try to parameterize generic types.  In this case, the compiler will be able to check everything, and the chances of the appearance of a runtime exception due to contradictions in the type system will be minimized. <br><br><h1>  Conclusion </h1><br>  Many aspects of software development on the Java platform are simplified, thanks to the division into a complex Java Virtual Machine and the language itself.  However, wide possibilities, like automatic memory management or decent OOP tools, do not exclude the likelihood of problems.  The tips here are universal: practice regularly, study the library, read the documentation.  And do not forget about static code analyzers, they can indicate the existing bugs and suggest what you should pay attention to. </div><p>Source: <a href="https://habr.com/ru/post/251365/">https://habr.com/ru/post/251365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251355/index.html">Several subtleties of using jade in Meteor-projects</a></li>
<li><a href="../251357/index.html">Data exchange using MPI. Working with the MPI Library on the example of the Intel¬Æ MPI Library</a></li>
<li><a href="../251359/index.html">Complete energy autonomy or how to survive with solar panels in the outback (part 1. theoretical)</a></li>
<li><a href="../251361/index.html">MVC and Model 2. Component Knowledge and Responsibilities</a></li>
<li><a href="../251363/index.html">Modifying HTTP traffic using FiddlerScript and .NET plug-ins to Fiddler</a></li>
<li><a href="../251369/index.html">News from the latest builds of Opera Developer 29</a></li>
<li><a href="../251371/index.html">Music in KolibriOS: full review and latest news</a></li>
<li><a href="../251373/index.html">What exactly happens when a user types google.com in the address bar? Part 1</a></li>
<li><a href="../251377/index.html">13 innovative applications in mobile commerce</a></li>
<li><a href="../251379/index.html">About relocation in the UAE and the purchase of real estate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>