<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search and read legacy code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vasya is a young programmer. Having received the task and rolled up the sleeves, he takes up writing the code. One day later, the solution of the prob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search and read legacy code</h1><div class="post__text post__text-html js-mediator-article">  Vasya is a young programmer.  Having received the task and rolled up the sleeves, he takes up writing the code.  One day later, the solution of the problem is ready, Vasya launches it ... And he encounters an unexpected annoying mistake.  Vasya diligently fixes it and reruns the solution.  The result is again an unpleasant mistake.  So Vasya takes a long time to rake, rewrites the program a couple of times, until, finally, after a week, the task is not completely solved. <br><br>  Petya is an experienced programmer.  After receiving the statement, he is looking for whether there is any source code that solved a similar problem.  Petya spends a couple of days reading materials and sorting out other modules, and on the third he launches his solution based on the already existing code.  It has a couple of minor bugs that can be quickly fixed.  Hooray!  Everything works as it should, on the third day. <br><br>  How to find the piece of source code you need?  How to understand it?  And most importantly - why do all this?  In the search for answers to these questions, welcome under cat. <br><a name="habracut"></a><br><h1>  Why is it important to be able to search and read the code? </h1><br>  D. Thomas and D. Spinellis in the book <a href="http://www.williamspublishing.com/Books/5-8459-0604-0.html">"Analysis of the program code on the example of Open Source projects"</a> formulate several important theses. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Reading the code is a programmer's daily routine.</b> <br><br>  From the outside it seems that the main work of the programmer is to write the source code, but it is not.  Most often, the code has to read, not write.  Yesterday your friend wrote a module, and today you are faced with the task of improving it or correcting an error, which is impossible without a preliminary study of the work of your friend. <br><br>  <b>90% of errors can be eliminated when reading the code.</b> <br><br>  With the figure of 90%, it seems to me, it is possible to argue, but the basic idea is clear: when reading (in this case, reviewing) a program, you can (and should) identify and eliminate errors. <br><br>  <b>We are often taught to write code, but rarely - to read it.</b> <br><br>  And in vain, because without reading the existing source you have to constantly reinvent the wheel.  Even if you can write something from scratch, it is much more effective to look around and use someone else's source code directly or as an analogy.  Someone else's code has been tested, debugged and, most likely, already contains some ‚Äúfeatures‚Äù that will be useful in solving your problem. <br><br>  So read the code to not write bicycles.  Read the code to make changes faster.  Read the code so that there are fewer errors in the programs. <br><br><h1>  What is this article about? </h1><br>  The main goal of the article is to systematize the existing approaches to searching and reading code.  Knowledge of specific approaches makes it possible to apply those that are most appropriate in a particular case.  In addition, the article provides an overview of the tools that will effectively apply the approaches described in the article.  It is worth noting that you can search and understand the source code without special tools, but their use makes the process more visual and less routine. <br><br>  I will talk about the most universal concepts: in other words, these concepts are applicable to all or almost all programming languages.  Some tools that make it easier to find and read the source are also universal, but most are only relevant for Visual Studio and .NET.  Nevertheless, the fact that most of the tools are used exclusively in VS does not mean that there are no similar tools for other IDEs: I am sure that they exist, since the approaches presented in the article are universal.  I also make a reservation that all the tools described are free, the exception is only ReSharper. <br><br>  The code examples in the article are taken from the <a href="https://github.com/ShareX/ShareX">ShareX</a> and <a href="http://sourceforge.net/projects/greenshot/">Greenshot applications</a> (both distributed under the <a href="http://www.gnu.org/licenses/">GNU GPL license</a> ) from the ShareX repository as of June 30, 2015. I thank the authors of these applications for the opportunity to use their code base.  I also thank my colleagues, especially Denis Gavrilov and Vladislav Iof, for their comments during the work on this article. <br><br><h1>  Code search </h1><br>  Code search is a process that results in parts of the source code related to the subject of the problem being solved. <br><br><h2>  Search outside code </h2><br>  You can start looking for source codes outside the codebase.  Pre-communication with the team, reading the documentation and bug tracker can greatly simplify the direct search code.  You can learn more about working with artifacts from D. Gavrilov <a href="http://vk.com/custis_young%3Fw%3Dwall-52018779_484">'s</a> seminar <a href="http://vk.com/custis_young%3Fw%3Dwall-52018779_484">‚ÄúTeamwork Practices: The Use of Written Artifacts‚Äù</a> .  In addition to reading the documentation and communicating with the team, it is useful to remember that you already know what is to be found.  For example, if you have to find a screen form, then it is worth remembering that the name of screen forms in your project usually ends with a Form, and all forms are in the collection ‚ÄúUI‚Äù. <br><br>  You can run the application for execution and search the screen form.  When iterating, the programmer opens in a random (or not so) order of the form until he finds a window, button, menu item, or any other interface element that appears to use the desired functionality.  Brute force is used when the search task is blurred or the programmer is not familiar with the system.  For example, you have never worked with an application, and you are required to add a function that would export all open pictures to the clipboard.  It seems logical to start exploring the application: see if it can export images to the clipboard one by one, are there any settings related to the buffer or export, etc. <br><br><h2>  Keyword Search </h2><br>  <a href="http://research_activities.academic.ru/703/%25D0%259A%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25BE">A keyword</a> is a word or phrase from the text of a document or query that carries a significant semantic meaning from the point of view of information retrieval.  The selection of keywords required for the search is formed through communication with users, screening through screen forms and other methods described above as an ‚Äúout of code‚Äù search.  Keywords can be taken from the task description, screen forms and user actions, the text of the error or message, the SQL query, that is, from any artifacts associated with the problem being solved. <br><br>  To make keyword searches as effective as possible, you need to select rare keywords.  For example, if you are working on a project in which there are many different documents (Document), then a search for the word Document will give a lot of unnecessary results.  However, there are situations when it is not possible to select rare keywords.  In this case, you first need to find a lot of potentially useful information, and then narrow down the search.  For example, find all existing references to the Document, and then exclude tests from the results, search for additional keywords in the files found, etc. In general, you should strive to find at least something (a little more or a little less), and not exactly what do you need. <br><br>  In most cases, keyword search is sufficiently built into the IDE search (usually caused by the keyboard shortcut Ctrl + F).  Sometimes a file manager can be useful - for searching in folders that are not part of the software solution - or search engines: for example, <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> and <a href="http://docfetcher.sourceforge.net/ru/index.html">DocFetcher</a> (they will be discussed below).  So, ReSharper contains a useful <a href="http://habrahabr.ru/post/88408/">Search by Pattern</a> function, with which you can find, for example, all class properties declared as null-valid enumerations (public TEnum? Enum {get; set;}).  Of course, we should not forget about the powerful mechanism of regular expressions;  Yes, it is rarely required, but sometimes it helps a lot. <br><br>  Let's talk a little more about the search engines that work with the source code.  The main advantage of search engines is that they allow flexible search.  For example, you need to find all the classes in which there are references to Clipboard and Image.  The usual tools built into the IDE will give you the opportunity to find either files from the Clipboard or files with Image.  Here behind the brackets we leave the notorious regular expression mechanism: it can help, but the search construct will be cumbersome.  A more complex example with which the built-in search tools will not cope: the need to find class properties marked with attribute A, but not marked with attribute B. In addition to flexibility, search engines increase search speed.  If your IDE needs a couple of times, and sometimes more than one dozen seconds, to run through all the project files, the search engine has an index that allows you to do the same in a split second. <br><br>  There are various search engines for the source code, you can read their discussion on <a href="http://stackoverflow.com/questions/156219/what-are-the-open-source-code-search-engines-you-know-about">StackOverflow</a> or read the selection on <a href="http://beyondgrep.com/more-tools/">beyondgrep.com</a> .  I use <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> in my work: it is free and knows how to work with various languages, such as C #, C, PHP, SQL and a dozen others.  The engine consists of 2 modules: a source indexing module and a web application for searching and navigating through the code.  The first module indexes project folders in the file system.  The web application runs under Apache, allows you to enter different search queries and view the results.  OpenGrok is written in Java, available for download on the <a href="http://opengrok.github.io/OpenGrok/">official website of the project</a> , and in the relevant articles you can read about how to <a href="http://algopadawan.blogspot.co.uk/2012/07/installing-opengrok-on-windows.html">install the Windows engine</a> and for <a href="https://github.com/OpenGrok/OpenGrok/wiki/How-to-install-OpenGrok">Linux</a> . <br><br>  <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> supports various types of search: in the text of the entire document or only in definitions, that is, the names of classes, functions.  In addition, it allows you to set filtering of folders and the name of the file you are looking for, choose the language in which the code should be written, etc. This engine shows the results in a descriptive form, grouped by file, and also allows you to go to the desired line in one click file and is able to show the code with highlighting or in the "raw" form. <br><br><img src="https://habrastorage.org/files/0e1/b90/d7b/0e1b90d7b0cb47e58bfeede1a49bd690.png"><br>  <i>Search query and <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> search results by ShareX</i> <br><br>  <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> has several limitations: firstly, there is no integration with Visual Studio, secondly, it does not know how to work with Cyrillic (at least, I could not achieve this with the help of settings).  If you often have to look for Russian text, then you can use <a href="http://docfetcher.sourceforge.net/ru/index.html">DocFetcher</a> : this tool is not sharpened directly under the search in the source code, but it can index any text files and does an excellent job with the Russian language. <br><br>  The table below presents a comparison of the capabilities of the <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> and <a href="http://docfetcher.sourceforge.net/ru/index.html">DocFetcher</a> search engines. <br><div class="spoiler">  <b class="spoiler_title">Comparison of search engines</b> <div class="spoiler_text">  Using this table, you can select for yourself the necessary search parameters and select the most appropriate tool. <br><br><table><tbody><tr><th>  Parameter </th><th>  <a href="http://opengrok.github.io/OpenGrok/">Opengrok</a> </th><th>  <a href="http://docfetcher.sourceforge.net/ru/index.html">Docfetcher</a> </th></tr><tr><td>  Search flexibility (through search language support) </td><td>  Yes </td><td>  Yes </td></tr><tr><td>  Search speed (through indexing) </td><td>  Yes </td><td>  Yes </td></tr><tr><td>  Special Code Finder Tools </td><td>  Yes </td><td>  Not </td></tr><tr><td>  Work with Cyrillic </td><td>  Not </td><td>  Yes </td></tr><tr><td>  Integration with Visual Studio </td><td>  Not </td><td>  Not </td></tr><tr><td>  Multiplatform </td><td>  Yes </td><td>  Yes </td></tr><tr><td>  License </td><td>  <a href="http://opensource.org/licenses/cddl1.php">CDDL</a> </td><td>  <a href="http://ru.wikipedia.org/wiki/Eclipse_Public_License">Eclipse Public License</a> </td></tr></tbody></table></div></div><br><h2>  Search by classifiers </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580">Classifier</a> is a systematic list of named objects.  The classifier most in demand by programmers, in my opinion, is a list of all classes of software solutions.  Examples of other classifiers can be a list of class members ordered by class, a list of files ordered by folders, etc. <br><br><img src="https://habrastorage.org/files/381/1b8/7de/3811b87de5ba49b9a8a6e6c96a8dd0ef.png"><br>  <i>ShareX Application Classes</i> <br><br>  On the one hand, the classifier can be used as a tool for working with a tree view.  You "expand" the base namespace of the software solution, then "expand" the namespace of the desired module, and so on, until you finally reach the desired class.  On the other hand, an end-to-end search can be performed inside the classifier.  For example, you type * Document *, and the classifier shows all the classes with Document in their names. <br><br>  If you work with ReSharper, then you probably know about the Go to Everything function, which allows you to switch to any class, method, property or file in the entire software solution.  Visual Studio has the following classifiers out of the box: Solution Explorer (classifies assemblies, folders, files, classes and their members), Class View (classifies namespaces, classes and their members), and Object Browser (classifies assemblies, namespaces, classes and their members).  Solution Explorer and Class View provide a list of classes within your solution, and the Object Browser, both in your solution and in the third-party assemblies used.  <a href="http://opengrok.github.io/OpenGrok/">OpenGrok</a> allows you to search by definitions (Definition), including using wildcard characters (* Document *).  Another classifier is a regular file manager, which displays artifacts arranged in folders. <br><br>  When should classifiers be used?  In order to successfully use a classifier, the programmer must have a good knowledge of the software product.  It is particularly important, in particular, to know the naming conventions (for example, * Form is a screen form, and DocumentNameListForm is a list form of documents like DocumentName), as well as the principles by which classes are ordered in folders and namespaces (in Dictionaries, directories, and in Documents - documents).  Another possibility of applying the search by classifier is the situation when the exact name of the class or its member is known. <br><br><h2>  Error search </h2><br>  Periodically there is a problem to find a line of code in which some error occurs.  Alternatively, the desired line can be found by the known error number.  In this case, the error number is the keyword by which the search is carried out (the search by keyword was described above).  In another situation, the error stack trace may be known.  ReSharper has a handy tool called Stack Traces, which allows you to view the stack and navigate through the methods that were invoked before the error occurred.  To use Stack Traces, you need to copy the error stack to the clipboard, and then in Visual Studio press Shift + Ctrl + E. <br><br><img src="https://habrastorage.org/files/d12/79d/73f/d1279d73f02a4471bf6a0e396af7006a.png"><br>  <i>View ShareX stack and navigate it in Stack Traces</i> <br><br>  If you do not have information about the error number or the stack trace, you can start the project and turn on the interrupts by mistake.  Visual Studio has created a handy add-on <a href="https://visualstudiogallery.msdn.microsoft.com/50091e25-9e75-40d3-9780-a05892f474de">Exception Breaker</a> , which allows you to enable or disable an interrupt by mistake with one mouse click. <br><br><h2>  By user action </h2><br>  Sometimes you want to know which method is called when you press a button or another user action.  In this case, you can first find the class in which the called method is located (for example, by searching by keywords or by classifier), and then place breakpoints in all members of this class and start the application.  In web applications, in some cases <a href="http://www.telerik.com/fiddler">Fiddler</a> is useful, in particular, you can see the name of the WCF function called and the values ‚Äã‚Äãof the parameters passed to it in it. <br><br><h2>  Results </h2><br>  Before you start searching for the code, it is worth spending a little time to communicate with the team, read the documentation and bust the screen forms.  This is necessary in order to collect keywords, find out the names of classes and methods, without which further search will be difficult.  It is worth starting with the simplest, while you can find a little more or a little less than is required.  You can also search for sources using keywords or classifiers.  To search for errors and functions caused by user action, there are special techniques. <br><br><div class="spoiler">  <b class="spoiler_title">The following table shows the code search methods discussed above.</b> <div class="spoiler_text"><table><tbody><tr><th>  Method </th><th>  Description </th><th>  Instruments </th></tr><tr><td>  Search outside code </td><td>  Preliminary preparation <br>  to direct code search, <br>  especially when the search task is blurred <br>  or bad programmer <br>  with system </td><td><ul><li>  Communication with the team or users </li><li>  Reading documentation and bug tracker </li><li>  Brute force screen forms </li></ul><br></td></tr><tr><td>  Keyword Search </td><td>  Search for code in which they are found <br>  specified keywords </td><td><ul><li>  Built-in IDE search (Ctrl + F) </li><li>  <a href="http://opengrok.github.io/OpenGrok/">Opengrok</a> </li><li>  <a href="http://docfetcher.sourceforge.net/ru/index.html">Docfetcher</a> </li><li>  <a href="http://habrahabr.ru/post/88408/">Search by Pattern</a> </li></ul><br></td></tr><tr><td>  Search by classifiers </td><td>  Search for classes or other objects <br>  sorted by category <br>  (for example, by namespace), <br>  especially when the programmer is good <br>  familiar with the application or known <br>  the exact name of the class or its member </td><td><ul><li>  ReSharper <ul><li>  Go to Everything </li></ul></li><li>  Visual studio <ul><li>  Solution Explorer </li><li>  Class view </li><li>  Object Browser </li></ul></li><li>  File manager </li></ul></td></tr><tr><td>  Error search </td><td>  Search for a line of code in which <br>  an error occurs </td><td><ul><li>  Stack Traces (ReSharper) </li><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/50091e25-9e75-40d3-9780-a05892f474de">Exception breaker</a> </li></ul></td></tr><tr><td>  Search by user action </td><td>  Finding the method that is being called <br>  by user action </td><td><ul><li>  <a href="http://www.telerik.com/fiddler">Feeddler</a> </li><li>  Breakpoints </li></ul></td></tr></tbody></table></div></div><br><br><h1>  Code understanding </h1><br>  Search code is inextricably linked with its understanding.  Understanding is necessary in order to select the source blocks from all the found ones that are really useful for solving the problem, in order to understand how to modify and how to use the results obtained in the search. <br><br><h2>  Understanding without reading the code </h2><br>  Outside the code base begins not only the search for code, but also the process of understanding it.  Running an application, reading the documentation, bug tracker, application log or version control system, communicating with the team and (or) users give a good idea of ‚Äã‚Äãwhat is happening inside the application.  Just like when searching for sources, before reading the code directly, it is important to remember what is already known about the area being parsed. <br><br><h2>  Reading the "black box" </h2><br>  Reading the code as a ‚Äúblack box‚Äù implies that, according to some external features, we are trying to establish what is happening inside a function or class.  The purpose of the object can be guessed by looking at its name, the parameters taken and the return value.  For example, <br><br><pre><code class="hljs lisp">public ResultOrError SetToClipboard(<span class="hljs-name"><span class="hljs-name">Image</span></span> image)</code> </pre> <br>  apparently, it puts the image in the clipboard, and puts information about the errors in the returned ResultOrError. <br><br>  To read the ‚Äúblack box‚Äù it is important to know the naming conventions, that is, the prefixes, postfixes, and other parts of the names adopted in the project.  The ‚Äúblack box‚Äù includes reading descriptions or comments inside functions. <br><br>  To make sure that the function‚Äôs assumptions are correct, you can study its use.  You can also find which user actions lead to a function call (for example, the user clicked the ‚ÄúCopy to clipboard‚Äù button) and, based on this knowledge, understand what the user expects to receive as a result of the function (in our case, obviously, copy an object into clipboard). <br><br>  ReSharper offers powerful Inspect This and Find Usages tools that allow you to find the places from which a function is called.  Inspect This is more convenient because it allows you to easily and visually perform a further search for code fragments, from which the places where the function is called, are called, and so on.  In Visual Studio itself, the Call Hierarchy tool is available out of the box, which has features similar to Inspect This. <br><br><img src="https://habrastorage.org/files/17e/829/e67/17e829e673c34f9087264345da01ab96.png"><br>  <i>Places that use the function (ShareX.UploadManager.UploadFile: 66-80)</i> <br><ul><li>  Inspect This (left); </li><li>  Find Usages (in the center); </li><li>  Call Hierarchy (right). </li></ul><br><h2>  Reading the "white box" </h2><br>  If in the ‚Äúblack box‚Äù the code of the method was ‚Äúclosed‚Äù for us (we study the sources on the border and around the function), then in the ‚Äúwhite box‚Äù the code inside the method under study is supposed to be studied. <br><br>  With the "white box" is important the order of reading the source.  On the one hand, in order to understand the code, it is not necessary to read it in its entirety; therefore, it is worth starting with the most important parts of it, skipping less significant lines.  On the other hand, the speed of understanding depends on the sequence of reading.  Reading from left to right and from top to bottom is not the best way to dive into the sources. <br><br>  One of the methods of reading the "white box" is reading "in depth": first, read the code of the first level, then go to the second and so on through the levels. <br><br><img src="https://habrastorage.org/files/460/ea4/40d/460ea440d97c4425b5734c72fb984a87.png"><br>  <i>Reading "in depth" (ShareX.UploadManager.UploadFile: 43-64)</i> <br><br>  For Visual Studio, there is an add-on <a href="https://visualstudiogallery.msdn.microsoft.com/6c3c5dec-1534-4c42-81b1-cfd4615fd0e9">C # outline</a> that allows you to collapse and expand text within if, for, and other control structures (out of the box. Visual Studio can collapse and expand namespaces, classes, regions, and methods, but not if, for, and similar constructions). <br><br>  Another way to read the code as a ‚Äúwhite box‚Äù is to read ‚Äúfrom key points‚Äù.  As a rule, these are places where the function returns or calculates the result, in some way uses the input parameters, makes output to a file, to the screen or another device.  Key locations in different functions may vary.  It is important to be able to find and read them first. <br><br>  For Visual Studio, there is the <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">RockMargin</a> add- <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">on</a> , which highlights in the editor and on the scroll bar all the places where there are occurrences of the selected keyword.  For example, you double-click on taskSettings, and <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">RockMargin</a> highlights all the places where taskSettings is found in the file: <br><br><img src="https://habrastorage.org/files/09c/1c8/aac/09c1c8aacf9048fa9d4a849ec7c6c5f2.png"><br>  <i>Highlight <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">RockMargin</a> for ShareX \ UploadManager.cs</i> <br><br>  In your application, most likely, there are many of the same type, patterned pieces.  These can be both commonly used templates (for example, Singleton), and templates specific to your project (for example, some features in the UI construction).  You can understand what a template does by two or three keywords, so you should learn to read the templates ‚Äúentirely‚Äù, without ‚Äúparsing letters‚Äù.  For example, in the picture below - class-Singleton, which can be guessed by two lines of code that are highlighted in red. <br><br><img src="https://habrastorage.org/files/b4c/6a7/64d/b4c6a764db2b4d4190568b9a8d62e558.png"><br>  <i>Class-Singleton (Greenshot.Drawing.Fields.Binding.DecimalFloatConverter: 29-52)</i> <br><br>  Another sequence that should be followed when reading the source, is to read from simple to complex.  First, deal with what is clear and true, and then go on to more complex structures. <br><br>  To conclude the white box section, I would like to say a few words about reading when reviewing code.  Before direct reading (especially if there is a lengthy revision to be reviewed), you should review the names of all the changed files, and then understand which files have the key changes.  Reading must begin with files with key changes, from which you grasp the general essence and better understand all the other improvements. <br><br><h2>  Code enhancement </h2><br>  To understand the source code, you can not only read it, but also improve it.  The easiest way to improve code perception is to indent correctly.  Another way to improve readability is refactoring.  The simplest renaming and separation of long functions into several short ones make it possible to quickly make the text of the program more understandable. <br><br>  To understand complex logical constructions, you can use the laws of de Morgan: <br><br><pre> <code class="hljs erlang-repl">!(a &amp;&amp; b) = (!a) || (!b) !(a || b) = (!a) &amp;&amp; (!b)</code> </pre><br>  As a tool for improving the code can be recommended ReSharper, which copes with improvements of varying degrees of complexity. <br><br><h2>  Debug mode </h2><br>  Debug mode allows you to check assumptions made while reading the source.  Reading in debug mode involves the use of tools such as breakpoints (including breakpoints ‚Äúby condition‚Äù, for example, they work only with a certain value of variables), viewing the stack trace, step-by-step program execution, viewing and modifying the values ‚Äã‚Äãof variables. <br><br><h2>  Overall picture </h2><br>  When reading, it is important to maintain a general understanding of what is happening in the module being disassembled, and to be able to move quickly around different places of the puzzle. <br><br>  To keep the big picture in your head, you can use diagrams, both existing in the project and new ones.  Some charts can be built automatically, this is especially true for SQL queries.  In PL / SQL Developer, for example, there is a Query Builder that shows which tables participate in a query and how they are related to each other.  Automatically, you can build class diagrams, for example, in Visual Studio, the View Class Diagram tool is used for this.  However, most often even a hand-drawn scheme is enough. <br><br>  It is convenient to read called methods using ReSharper, Inspect This or the Call Hierarchy tool built into Visual Studio View.  In the section about the ‚Äúblack box‚Äù these tools have already been considered, but there they explored the places from which the function is called.  Here we are talking about viewing the methods that are called inside the function.  Inspect This and View Call Hierarchy provide a complete picture - you see the entire call tree - and allow you to quickly navigate through it. <br><br>  For quick transitions to arbitrary code blocks, you can pin tabs (to distinguish those 5‚Äì10 classes that you work closely with, from the other 20‚Äì100 that you had to open during the work), bookmark the editor or write by hand, for example, write out the names of classes and their members. <br><br>  For quick transitions inside the file, the following will be useful: in ReSharper - File Structure (displays members of the current class), in Visual Studio - Member (similar to File Structure) or <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">RockMargin</a> (displays reduced source code on a wide scroll bar, tints bookmarks and breakpoints). <br><br><h2>  Results </h2><br>  Before directly reading the source, it is important to refer to various sources outside the code base: communicate with the team, read the documentation, run the application for execution.  This will provide some basic understanding of the application that will help in directly reading the code.  You can read the source code as a ‚Äúblack box‚Äù, analyzing the names of the methods, the parameters taken by them, etc., as a ‚Äúwhite box‚Äù, making an analysis of what is inside the method.  To facilitate the perception of the code, it can be improved, for example, indents.  Running the application allows you to check the assumptions made in debug mode.  Finally, when reading it is important to keep the big picture in your head and be able to move quickly in different parts of the module under study. <br><br><div class="spoiler">  <b class="spoiler_title">The following table shows the code understanding methods discussed above.</b> <div class="spoiler_text"><table><tbody><tr><th>  Method </th><th>  Description </th><th>  Instruments </th></tr><tr><td>  Understanding without reading the code </td><td>  Getting a general idea <br>  about the module without viewing the source </td><td><ul><li>  Communication with the team or users </li><li>  Reading documentation and bug tracker </li><li>  Application launch <br></li></ul></td></tr><tr><td>  Reading the "black box" </td><td>  Understanding what's inside <br>  function or class for some <br>  external signs (name taken <br>  parameters return value <br>  etc.) </td><td><ul><li>  ReSharper <ul><li>  Inspect this </li><li>  Find Usages </li></ul></li><li>  Visual studio <ul><li>  Call hierarchy <br></li></ul></li></ul></td></tr><tr><td>  Reading the "white box" </td><td>  Examine the code inside the test <br>  method </td><td><ul><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/6c3c5dec-1534-4c42-81b1-cfd4615fd0e9">C # outline</a> </li><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">Rockmargin</a> </li></ul></td></tr><tr><td>  Code enhancement </td><td>  Improved code readability </td><td><ul><li>  ReSharper <br></li></ul></td></tr><tr><td>  Debug mode </td><td>  Run application in debug mode </td><td><ul><li>  Debugging Tools <br></li></ul></td></tr><tr><td>  Overall picture </td><td>  Hold overall performance <br>  about what happens in the parsed <br>  module;  fast moving <br>  different places code </td><td><ul><li>  ReSharper <ul><li>  Inspect this </li><li>  File structure </li></ul></li><li>  Visual studio <ul><li>  Call hierarchy </li><li>  View Class Diagram </li><li>  Member </li></ul></li><li>  Add-ons for Visual Studio <ul><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">Rockmargin</a> <br></li></ul></li></ul></td></tr></tbody></table></div></div><br><h1>  Conclusion </h1><br>  Search and understanding of the code is an important step in the work on the software product.  Search and understanding begin outside the repository: from communication with the team, reading documentation, bug tracker, launching the application for execution.  Search and understanding are necessary both when finalizing existing modules (to finalize an existing module, you need to understand how it works) and when developing a new functional: yes, a new module can sometimes be developed without reading a single line of code, but in the project, most likely , there are separate blocks that implement similar functionality, which can be taken as a template for implementing functions and classes. <br><br>  In my opinion, reading the code in the broad sense of the word (that is, both the search for sources and their understanding) should be highlighted by the developer at a separate stage in the work on the task.  The result of this stage is a set of bookmarks in methods and files that will be useful when working on a task, as well as a general idea of ‚Äã‚Äãthe work of a certain block of code.  Already within the framework of direct programming, the search for source code must continue.  For example, like this: met a new class, found the places where it is used, updated the list of useful bookmarks.  Perhaps the selection of bookmarks can be distinguished by a separate function in the team: a technical leader or a responsible developer compiles a list of useful bookmarks, after which the programmer takes the task into operation. <br><br>  Both for searching and for understanding the source code, it is important to know the naming conventions and how classes are organized (by folder, namespace).  According to the author‚Äôs experience, such an understanding is acquired in the course of work in a project, but agreements can be formalized and communicated to new developers in the same way as agreements on the design of a code (Code Style Guide). <br>  The development of automated tools that reveal the actual naming conventions and methods for organizing classes is promising.  As it seems, tools that identify the most common folder names, suffixes, postfixes, etc. will be helpful. <br><br>  When reading the code, as with reading a regular book, it is important to realize and keep in mind the purpose of reading.  To read the code, you can use some techniques from articles on how to read plain text (see, for example: <a href="http://outfund.ru/kak-uluchshit-svoyu-sposobnost-ponimat-prochitannyj-tekst/">"How to improve your ability to understand the read text?"</a> ). <br><br>  As far as can be assessed, the search and understanding of the code is a topic that is poorly touched upon in domestic and foreign literature.  I hope that the article presented was useful in mastering techniques for working effectively with the code base. <br><br><div class="spoiler">  <b class="spoiler_title">Links</b> <div class="spoiler_text"><h2>  Books </h2><br><ul><li>  <a href="http://www.williamspublishing.com/Books/5-8459-0604-0.html">Spinellis D. "Analysis of the program code on the example of Open Source projects"</a> </li><li>  <a href="http://www.williamspublishing.com/Books/5-8459-0785-3.html">Hoagland G., McGraw G. ‚ÄúHacking programs: analysis and code samples‚Äù</a> </li><li>  <a href="http://www.williamspublishing.com/Books/978-5-8459-1530-6.html">Fiesers MK "Effective work with legacy code"</a> </li></ul><br><h2>  Articles </h2><br><ul><li>  <a href="http://outfund.ru/kak-uluchshit-svoyu-sposobnost-ponimat-prochitannyj-tekst/">How to improve your ability to understand the read text?</a> </li><li>  <a href="http://programmers.stackexchange.com/questions/6395/how-do-you-dive-into-large-code-bases">How do you dive into large code bases?</a> </li></ul><br><h2>  Seminars </h2><br><ul><li>  <a href="http://vk.com/custis_young%3Fw%3Dwall-52018779_604">Shatalkin I. ‚ÄúSearch and reading of the inherited code‚Äù</a> </li><li>  <a href="http://vk.com/custis_young%3Fw%3Dwall-52018779_484">Gavrilov D. ‚ÄúTeamwork Practices: The Use of Written Artifacts‚Äù</a> </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Instruments</b> <div class="spoiler_text"><h2>  To search for code </h2><br><ul><li>  <a href="http://opengrok.github.io/OpenGrok/">Opengrok</a> </li><li>  <a href="http://docfetcher.sourceforge.net/ru/index.html">Docfetcher</a> </li><li>  <a href="http://www.telerik.com/fiddler">Feeddler</a> </li><li>  ReSharper <ul><li>  Go to Everything </li><li>  Stack traces </li><li>  <a href="http://habrahabr.ru/post/88408/">Search by Pattern</a> </li></ul></li><li>  Visual studio <ul><li>  Built-in search (Ctrl + F) </li><li>  Solution Explorer </li><li>  Class view </li><li>  Object Browser </li><li>  Breakpoints </li></ul></li><li>  Add-ons for Visual Studio <ul><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/50091e25-9e75-40d3-9780-a05892f474de">Exception breaker</a> </li></ul></li><li>  File manager </li><li>  Brute force screen forms </li></ul><br><h2>  To understand the code </h2><br><ul><li>  ReSharper <br><ul><li>  Inspect this </li><li>  Find Usages </li><li>  File structure </li><li>  Refactoring tools </li></ul></li><li>  Visual studio <ul><li>  Call hierarchy </li><li>  View Class Diagram </li><li>  Member </li><li>  Debugging Tools </li></ul></li><li>  Add-ons for Visual Studio <ul><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/1b0d7360-40dd-447e-8bef-90e2cf52f683">Rockmargin</a> </li><li>  <a href="https://visualstudiogallery.msdn.microsoft.com/6c3c5dec-1534-4c42-81b1-cfd4615fd0e9">C # outline</a> </li></ul></li><li>  Application launch </li></ul><br><h2>  General methods </h2><br><ul><li>  Communication with the team or users </li><li>  Reading documentation and bug tracker </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/267923/">https://habr.com/ru/post/267923/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267911/index.html">AdBlockBlock - bypass ad blockers. Method 1</a></li>
<li><a href="../267913/index.html">According to Rambler.iOS # 4</a></li>
<li><a href="../267915/index.html">ZeroNights 2015: Hack now - Save the future</a></li>
<li><a href="../267919/index.html">Network overlay technologies for data centers. Part 1</a></li>
<li><a href="../267921/index.html">Authorization in Redmine from another site</a></li>
<li><a href="../267925/index.html">OTRS for pumping in the style of REG.RU</a></li>
<li><a href="../267927/index.html">Storing configs under version control</a></li>
<li><a href="../267929/index.html">Macroscop video surveillance and analytics in detail</a></li>
<li><a href="../267931/index.html">Cybercriminals kidnapped fingerprints 5.6 million US civil servants</a></li>
<li><a href="../267933/index.html">Microsoft Speech and Streaming Audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>