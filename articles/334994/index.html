<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I want to like YouTube</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever wondered how the ID of a video on YouTube works? 
 You may already know / find the answer, but as the discussions at Stack Overflow have...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I want to like YouTube</h1><div class="post__text post__text-html js-mediator-article"><p>  Have you ever wondered how the ID of a video on YouTube works? <br>  You may already know / find the answer, but as the discussions at Stack Overflow have shown, many people misunderstand this technology.  If you are interested in learning something new, welcome under cat. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cc/a7/59cca737b888c306300556.png" alt="I want to like YouTube"></div><a name="habracut"></a><br><h2>  ID structure </h2><br><p>  For starters, remember what the ID video on YouTube is. <br>  The ID is 11 characters long (previously it was 9 characters long). </p><br><p>  Consists of: </p><br><ul><li> Latin uppercase letters <code>[AZ]</code> - 26 characters; </li><li>  Latin letters lower case <code>[az]</code> - 26 characters; </li><li>  Numbers <code>[0-9]</code> - 10 characters; </li><li>  Dash and underscore <code>[-_]</code> - 2 characters. </li></ul><br><p>  Total 64 characters. <br>  You may have noticed similarities with many well-known Base64 ( <a href="http://www.faqs.org/rfcs/rfc2045.html">RFC 2045</a> section 6.8) and this is no accident.  Only Base64 uses extra plus and slash <code>[+/]</code> characters, not dashes and underscores.  Plus and slash are reserved for use in URLs, and so that there are no problems with using IDs in URLs, YouTube will replace them with more secure ones.  But you can use your characters, more on that later. </p><br><h2>  Why do you need it </h2><br><p>  Strange as it may seem, but most users and developers mistakenly believe that such IDs are needed to protect against grabbers, who can search the entire content of the site through brute force IDs. </p><br><p>  Therefore, many people seriously consider such IDs as a security system and come up with complex hashing algorithms for their incremental numeric identifiers, write libraries and promote them. </p><br><p>  However, I want to surprise you, this is not a hashed number, but just a string.  And not even an incremental string, but a randomly generated value by analogy with a <a href="https://ru.wikipedia.org/wiki/UUID">UUID</a> , only noticeably more compact. </p><br><p>  It can be difficult to understand for those who have always worked with incremental identifiers and relied on the database for this.  The generated identifier has its own purpose, its advantages and disadvantages over the incremental identifier. </p><br><h2>  Generated identifier in distributed systems </h2><br><p>  For the first time, we encounter a generated identifier in distributed systems. </p><br><p>  The problem of incremental ids is that they are created by the database.  To maintain data consistency, we need one master database that will generate them.  This increases the load on it and makes sharding difficult. <br>  Some solve this problem by creating a separate database or service that deals exclusively with ID generation.  But everything is complicated when we need to spread the server geographically, connect the regions. <br>  The solution is to maintain a local ID and, in case of periodic synchronization with the main server, obtain from it an end-to-end ID for the entire system.  That is, on the regional servers we will have 2 IDs - local and pass-through. </p><br><p>  To solve such problems, generated identifiers such as a UUID were invented.  Due to the large number of combinations, we achieve a very small probability of identifier conflict.  Therefore, we can entrust the generation of a global ID to specific instances of the application. </p><br><h2>  DDD and identifiers </h2><br><p>  The concept of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">domain-driven design (DDD) is</a> well described in the books of <a href="https://www.google.ru/search%3Fq%3Disbn%2B9785845915979">Eric Evans</a> and <a href="https://www.google.ru/search%3Fq%3Disbn%2B9780321834577">Von Vernon</a> .  The general idea of ‚Äã‚ÄãDDD is to focus on our subject area, the desire to design systems as close as possible to the real world.  Here I want to talk about the role of identifiers in DDD. </p><br><p>  In terms of the DDD approach, entities cannot be created without an identifier.  Initializing a new instance of an entity, the identifier in it should already be.  That is, the identifier of the created entity must be passed to it in the constructor or the domain-level service is transferred to it to get the identifier, or it must be a <a href="https://ru.m.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587">natural identifier</a> formed by the entity itself. </p><br><p>  The need for an identifier may arise if we want to throw a domain event when creating an entity.  If the event does not have an identifier, then listeners may have problems with the identification of the entity. </p><br><p>  At the same time, an incremental key to insert is used in the database.  Until we write the data to the database, we will not be able to get an identifier for the entity.  Disconnect is obtained.  We cannot create an entity because we do not have an ID, and we cannot get an ID from a database, because for this we need to write the entity into the database. </p><br><p>  There are different ways to solve this problem.  One of them is a randomly generated identifier, which we are talking about now. </p><br><h2>  disadvantages </h2><br><p>  There are drawbacks to the generated identifiers.  Where do without them. <br>  Obvious disadvantages are the time of identifier generation and the probability of collision / conflict of identifiers.  We will talk about the probability of a conflict in the next section. </p><br><h2>  ID collision probability </h2><br><p>  Let's remember the course of combinatorics and estimate the number of combinations.  We will need the formula <strong>Repositioning</strong> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cc/bf/59ccbffd55ed6240194257.png" alt="Posting"></div><br><h3 id="uuid">  UUID </h3><br><p>  For UUID, the number of combinations is known, but we still calculate them for comparison. </p><br><p>  The UUID is <code>550e8400-e29b-41d4-a716-446655440000</code> , has a length of 32 characters minus the separators ( <code>-</code> ) and consists of hexadecimal digits.  What gives us 16 <sup>32</sup> or 2 <sup>128</sup> combinations.  This is a lot. </p><br><p>  UUID has a lot of good and many use it successfully.  Personally, I don‚Äôt like it because it‚Äôs very long, it takes up a lot of space in the database and is difficult to use in the URL, although some are <a href="https://insight.sensiolabs.com/projects/0feb22b7-b64d-462d-b8ba-da49e548be70">not confused</a> . </p><br><h3 id="youtube-id">  YouTube ID </h3><br><p>  Now compare the UUID and YouTube video ID and calculate the number of combinations. </p><br><p>  As we have already found out, the YouTube video ID is 64 characters long and is 11 characters long, which gives us 64 <sup>11</sup> or 2 <sup>66</sup> .  This figure is certainly much smaller than the UUID, but I still think that it is quite large: </p><br><pre> <code class="hljs">73 786 976 294 838 206 464</code> </pre> <br><p>  In order to somehow realize this number, imagine that in order to obtain all possible values ‚Äã‚Äãof identifiers with a length of 11 characters and creating an identifier every <strong>nanosecond</strong> , you will need <strong>2,339</strong> years. </p><br><p>  And in order to get the same number of combinations as the UUID, we need <sup>2,128</sup> = 64 <sup>21</sup> lines 21 characters long, that is, almost 2 times shorter than the UUID (37 characters).  And if we take an identifier of the same length as the UUID, then we get 64 <sup>37</sup> = 2 <sup>222</sup> versus 2 <sup>128</sup> for the UUID. <br>  The most important advantage of this approach is that we ourselves manage the number of combinations by changing the length of the string. </p><br><p>  It is not difficult to guess that it is possible to make the identifier even more compact by taking a larger set of characters.  For example, taking a set of 128 characters and then an identifier with a length of 18 characters will give us 128 <sup>18</sup> = 2 <sup>126</sup> combinations, which is comparable to the UUID.  But it saves us only a few characters, and adds a whole bunch of problems.  Increasing the number of characters used, we are faced with the problem of using reserved characters or with the problem of diverging character coding.  Therefore, I recommend limited to 64 characters and play only with the length of the identifier. </p><br><p>  To calculate the probability of a collision, we use the formula from the <a href="https://ru.wikipedia.org/wiki/UUID">article about the UUID on Wikipedia</a> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/b4/ut/lvb4utkrdzcd5uzeelgi8fhf0lg.png"></div><br><p>  she is </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lt/na/ia/ltnaia3wenjmkc9idi28vxmxehy.png"></div><br><p>  Where <br>  <em>N</em> - the number of possible options. <br>  <em>n</em> is the number of keys generated. </p><br><p>  Take the identifier with a length of 11 characters, like YouTube, which will give us <em>N = 64 <sup>11</sup> = 2 <sup>66</sup></em> and accordingly we get: </p><br><p>  <em>p (2 <sup>25</sup> ) ‚âà 7.62 * 10 <sup>-6</sup></em> <br>  <em>p (2 <sup>30</sup> ) ‚âà 0.0077</em> <br>  <em>p (2 <sup>36</sup> ) ‚âà 0.9999</em> </p><br><p>  This gives us a guarantee that the first few million identifiers will be unique.  Not the worst result for such a short identifier. </p><br><h2>  ID generation </h2><br><p>  And finally the code.  ID is generated elementary. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base64UID</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHARS = <span class="hljs-string"><span class="hljs-string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $length)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $uid = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($length-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { $uid .= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::CHARS[random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>)]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $uid; } }</code> </pre> <br><p>  Using: </p><br><pre> <code class="php hljs">$uid = Base64UID::generate(<span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-comment"><span class="hljs-comment">// iKtwBpOH2Ew</span></span></code> </pre> <br><h2>  DDD </h2><br><p>  And now let's estimate how this can be used in your subject area using the DDD approach.  Suppose we want to use our new ID in the essence of <em>Article</em> .  First, create a <a href="https://martinfowler.com/bliki/ValueObject.html">ValueObject</a> for the article identifier in order to uniquely identify the identifier belonging to the article. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticleId</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id = $id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id; } }</code> </pre> <br><p>  Now we will create the domain service interface for getting the ID.  We need the service to encapsulate ID generation and substitution if necessary. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticleIdGenerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextIdentity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArticleId</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><p>  Let's create the implementation of a specific service of the article ID generator using our new random identifier generator. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base64ArticleIdGenerator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticleIdGenerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextIdentity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArticleId</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArticleId(Base64UID::generate(<span class="hljs-number"><span class="hljs-number">11</span></span>)); } }</code> </pre> <br><p>  Now we can create the essence of the <em>Article</em> with an identifier. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Article</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArticleIdGenerator $generator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id = $generator-&gt;nextIdentity(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArticleId</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id; } }</code> </pre> <br><p>  Usage example: </p><br><pre> <code class="php hljs">$generator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base64ArticleIdGenerator(); $article = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Article($generator); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $article-&gt;id(); <span class="hljs-comment"><span class="hljs-comment">// iKtwBpOH2Ew</span></span></code> </pre> <br><h2>  Conclusion </h2><br><p>  In such a simple way we obtained a managed generated identifier with a high degree of uniqueness.  Whether to use the generated identifiers in your projects is up to you, but their advantages are obvious. </p><br><p>  Do you use generated identifiers?  Tell us in the comments. </p><br><p>  PS: For those who are too lazy to write their own, there is a <a href="https://github.com/gpslab/base64uid">ready library</a> for PHP 5.3+ <br>  PSS: For calculations, I can recommend <a href="https://web2.0calc.com/">this</a> online calculator. </p><br><h1>  Update 02-02-2018 </h1><br><p>  The purpose of this article is to show the principle, advantages and disadvantages of the generated identifiers, and not diminish the merits of the UUID or put Base64 as the best solution. </p><br><h1>  Update 05-02-2018 </h1><br><p>  Let us summarize the discussion in the comments. </p><br><p>  <a href="https://habrahabr.ru/users/medvedevia/" class="user_link">medvedevia</a> very correctly <a href="https://habrahabr.ru/post/334994/">noted</a> that the UUID can be packaged in base64, for which he thanks.  Packed UUID, the output will give us a string 22 characters long, which is already noticeably more compact. </p><br><pre> <code class="php hljs">$uuid = <span class="hljs-string"><span class="hljs-string">'550e8400-e29b-41d4-a716-446655440000'</span></span>; $uuid = str_replace(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, $uuid); $uuid = hex2bin($uuid); $uuid = base64_encode($uuid); $uuid = str_replace(<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, $uuid); <span class="hljs-comment"><span class="hljs-comment">// VQ6EAOKbQdSnFkRmVUQAAA var_dump($uuid);</span></span></code> </pre> <br><p>  However, the UUID is still long and has a number of <a href="https://habrahabr.ru/post/334994/">other disadvantages</a> described by <a href="https://habrahabr.ru/users/sand14/" class="user_link">sand14</a> , for which a special thank you to it. </p><br><p>  Alternatively, consider Snowflake ID <a href="https://habrahabr.ru/post/334994/">proposed by</a> <a href="https://habrahabr.ru/users/mikalair/" class="user_link">MikalaiR</a> .  It is successfully used on Twitter and Instagram. <br>  Snowflake ID is a 64 bit number: </p><br><ul><li>  Sign (1 bit) - required to define timestamp bounds; </li><li>  Timestamp (41 bits) - id generation date in microseconds; </li><li>  Generator (10 bits) - id of the generating id service.  Usually divided into 2 - Datacenter ID (5 bits) and Machine ID (5 bits); </li><li>  Sequence (12 bits) is an incremental number. </li></ul><br><p>  Sequence is incremented in cases where the timestamp of the generated id matches the timestamp of the last generated id.  A kind of collision protection at the local level. </p><br><p>  Pretty simple scheme is obtained.  The advantages of Snowflake ID are: </p><br><ul><li>  Compact than UUID; </li><li>  Constantly growing id, due to use of timestamp; </li><li>  High degree of protection against collisions; </li><li>  Does not use random number generator </li><li>  Manually configured, which allows you to generate a Snowflake id faster than a UUID. </li></ul><br><p>  Now let's talk about the disadvantages of Snowflake: </p><br><p>  The first problem is that an application that generates an id can run on the same server in different processes.  As a result, we can get a collision already within the same server.  You cannot use the process id when generating id for a number of reasons. <br>  The decision, either to make the id generation into microservice, or to force the master process that starts the child processes with the application, transfer some kind of id to the child processes, which can already be used in the algorithm. </p><br><p>  The second problem is the disclosure of information about the project infrastructure.  The number of servers and the number of data centers. </p><br><p>  The third problem is using the timestamp.  The time is infinite and driving it into frames we condemn ourselves to failure. <br>  As I <a href="https://habrahabr.ru/post/334994/">wrote</a> in the comments, the timestamp is already 41 bits long and in 2039 the length will be 42 bits.  We will get an overflow of space and the generation of id will start from scratch, that is, we will receive an id, the same as 69 years ago.  And when the length of the timestamp is 43 bits (year 2248), we get an Integer overflow. </p><br><p>  Twitter may neglect this problem, as it may simply not keep tweets for so long, but this is not applicable to everyone. </p><br><p>  There are also several solutions.  As <a href="https://habrahabr.ru/users/mikalair/" class="user_link">MikalaiR</a> <a href="https://habrahabr.ru/post/334994/">said</a> , you can change the start date of the countdown, for example, the beginning of the 2000-01-01 epoch, which would delay the inevitable for another 30 years. <br>  A more correct solution was <a href="https://habrahabr.ru/post/334994/">suggested by</a> <a href="https://habrahabr.ru/users/devalone/" class="user_link">devalone</a> .  You can redistribute the bits and increase the space for the timestamp, for example, up to 45 bits, which will set aside the turning point until 3084, and overflow the Integer only in 4199. </p><br><p>  Snowflake id generation example: </p><br><pre> <code class="php hljs">$last_time = <span class="hljs-number"><span class="hljs-number">0</span></span>; $datacenter = <span class="hljs-number"><span class="hljs-number">1</span></span>; $machine = <span class="hljs-number"><span class="hljs-number">1</span></span>; $sequence = <span class="hljs-number"><span class="hljs-number">0</span></span>; $offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      //$offset = strtotime('2000-01-01 00:00:00') * 1000; $time = floor(microtime(true) * 1000) - $offset; if (!$last_time || $last_time == $time) { $sequence++; } var_dump(sprintf('%b', $time)); $id = 1 &lt;&lt; (64 - 1); $id |= $time &lt;&lt; (64 - 1 - 41); $id |= $datacenter &lt;&lt; (64 - 1 - 41 - 5); $id |= $machine &lt;&lt; (64 - 1 - 41 - 5 - 5); $id |= $sequence &lt;&lt; (64 - 1 - 41 - 5 - 5 - 12); //     //$id = 1 &lt;&lt; 63 | $time &lt;&lt; 22 | $datacenter &lt;&lt; 17 | $machine &lt;&lt; 12 | $sequence; var_dump(sprintf('%b', $id)); //   base64 $id = dechex($id); $id = hex2bin($id); $id = base64_encode($id); $id = str_replace('=', '', $id); var_dump($id); // oT561auCEAE</span></span></code> </pre> <br><p>  It would seem that here it is YouTube id, but no.  If you <a href="https://3v4l.org/etJkB">generate</a> several id, then you will see that they do not differ much, and the last 4 characters are generally constant. </p><br><pre> <code class="hljs">oT5+eFUCEAE oT5+eU8CEAE oT5+ekkCEAE</code> </pre> <br><p>  For comparison, id videos uploaded to YouTube with a difference of a few seconds. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">fxEbFmSBuIM</span></span> et34RK4qLy8 3oypcgF-LJQ</code> </pre> <br><p>  <a href="https://3v4l.org/HLItm">By comparing the</a> identifiers in the binary representation, you can also make sure that the Snowflake id has much more similarities than YouTube </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">1010000100111110011111100111100001010101000000100001000000000000</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ oT5+eFUCEAE 1010000100111110011111100111100101001111000000100001000000000000 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ oT5+eU8CEAE 1010000100111110011111100111101001001001000000100001000000000000 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ oT5+ekkCEAE 1010000100111110011111100111100001000001000000100001000000000000 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ </span></span></code> </pre> <br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">0111111100010001000110110001011001100100100000011011100010000011</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ fxEbFmSBuIM 0111101011011101111110000100010010101110001010100010111100101111 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ et34RK4qLy8 0000000011011110100011001010100101110010000000010100101100100101 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3oypcgF-LJQ 0000000000010000000010000000000000100000000000000000100000000001 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ </span></span></code> </pre> <br><p>  I'm still inclined to think that YouTube uses random or pseudo-randomly generated values. </p><br><h1>  Update 21-02-2018 </h1><br><p>  The method of generating an identifier described in the article is given as an example.  Do not focus on a specific example. <br>  For comparison, I want to give a few additional examples of the generation of the identifier so that there is something to compare with.  All of them use <a href="http://fi2.php.net/manual/ru/ref.csprng.php">cryptographically secure random number generators</a> . </p><br><h3 id="generaciya-sluchaynyh-znakov">  Generation of random characters </h3><br><pre> <code class="php hljs">$length = <span class="hljs-number"><span class="hljs-number">11</span></span>; $chars = <span class="hljs-string"><span class="hljs-string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-'</span></span>; $uid = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($length-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { $uid .= $chars[random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>)]; } var_dump($uid); <span class="hljs-comment"><span class="hljs-comment">// 4rnQMtJ4HRw</span></span></code> </pre> <br><p>  <strong>pros</strong> </p><br><ul><li>  ID Length Controllability </li><li>  No restrictions on the length of the identifier </li><li>  It is possible to change the characters themselves in the character set </li><li>  It is possible to change the number of characters in the set </li><li>  Multiple calls to <code>random_int()</code> reduce the likelihood of local collisions. </li></ul><br><p>  <strong>Minuses</strong> </p><br><ul><li>  Multiple calls to <code>random_int()</code> adversely affect performance </li></ul><br><h3 id="pobaytovaya-generaciya-id">  ID byte generation </h3><br><pre> <code class="php hljs">$length = <span class="hljs-number"><span class="hljs-number">64</span></span>; $uid = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($length-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { $uid .= random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } $uid = bindec($uid); $uid = dechex($uid); $uid = hex2bin($uid); $uid = base64_encode($uid); $uid = str_replace([<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>], [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>], $uid); var_dump($uid); <span class="hljs-comment"><span class="hljs-comment">// tDiGk9YyWAA</span></span></code> </pre> <br><p>  <strong>pros</strong> </p><br><ul><li>  ID Length Controllability </li><li>  A more frequent call to <code>random_int()</code> , compared to the previous version, reduces the likelihood of local collisions. </li></ul><br><p>  <strong>Minuses</strong> </p><br><ul><li>  Lost the ability to change the characters themselves in the character set </li><li>  Lost the ability to change the number of characters in the set </li><li>  ID is limited to 64 bits. </li><li>  Multiple calls to <code>random_int()</code> adversely affect performance </li></ul><br><h3 id="sluchaynye-chisla-i-vremennaya-metka">  Random numbers and timestamp </h3><br><pre> <code class="php hljs">$time = floor(microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) * <span class="hljs-number"><span class="hljs-number">1000</span></span>); $prefix = random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0b111111111</span></span>); $suffix = random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0b111111111</span></span>); $uid = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">45</span></span> + <span class="hljs-number"><span class="hljs-number">9</span></span>); $uid |= $prefix &lt;&lt; (<span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">45</span></span>); $uid |= $time &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; $uid |= $suffix; $uid = dechex($uid); $uid = hex2bin($uid); $uid = base64_encode($uid); $uid = str_replace([<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>], [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>], $uid); var_dump($uid); <span class="hljs-comment"><span class="hljs-comment">// vELDchIFvk0</span></span></code> </pre> <br><p>  <strong>pros</strong> </p><br><ul><li>  The probability of a collision decreases due to the use of a time stamp. </li></ul><br><p>  <strong>Minuses</strong> </p><br><ul><li>  Lost the ability to change the characters themselves in the character set </li><li>  Lost the ability to change the number of characters in the set </li><li>  ID is limited to 64 bits. </li><li>  Difficult to manage ID length </li><li>  As in the case of <em>Snowflake</em> , the identifiers are <a href="https://3v4l.org/EEADG">similar.</a> </li></ul><br><h3 id="sluchaynye-chisla-i-plavayuschaya-vremennaya-metka">  Random Numbers and Floating Timestamp </h3><br><pre> <code class="php hljs">$time = floor(microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) * <span class="hljs-number"><span class="hljs-number">1000</span></span>); $prefix_length = random_int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>); $prefix = random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, bindec(str_repeat(<span class="hljs-string"><span class="hljs-string">'1'</span></span>, $prefix_length))); $suffix_length = <span class="hljs-number"><span class="hljs-number">18</span></span> - $prefix_length; $suffix = random_int(<span class="hljs-number"><span class="hljs-number">0</span></span>, bindec(str_repeat(<span class="hljs-string"><span class="hljs-string">'1'</span></span>, $suffix_length))); $uid = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; ($suffix_length + <span class="hljs-number"><span class="hljs-number">45</span></span> + $prefix_length); $uid |= $prefix &lt;&lt; ($suffix_length + <span class="hljs-number"><span class="hljs-number">45</span></span>); $uid |= $time &lt;&lt; $suffix_length; $uid |= $suffix; $uid = dechex($uid); $uid = hex2bin($uid); $uid = base64_encode($uid); $uid = str_replace([<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>], [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>], $uid); var_dump($uid); <span class="hljs-comment"><span class="hljs-comment">// 4WG5MmC3SQo</span></span></code> </pre> <br><p>  <strong>pros</strong> </p><br><ul><li>  Identifiers are less <a href="https://3v4l.org/W3no0">similar</a> than in the previous example, even when using the same timestamp. </li></ul><br><p>  <strong>Minuses</strong> </p><br><ul><li>  Lost the ability to change the characters themselves in the character set </li><li>  Lost the ability to change the number of characters in the set </li><li>  ID is limited to 64 bits. </li><li>  Difficult to manage ID length </li><li>  Due to the inconstant position of the timestamp, collision is still possible. </li></ul><br><h3 id="generaciya-sluchaynyh-bayt">  Random byte generation </h3><br><pre> <code class="php hljs">$uid = random_bytes(<span class="hljs-number"><span class="hljs-number">8</span></span>); $uid = base64_encode($uid); $uid = str_replace([<span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>], [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>], $uid); var_dump($uid); <span class="hljs-comment"><span class="hljs-comment">// BOjs1VmavxI</span></span></code> </pre> <br><p>  <strong>pros</strong> </p><br><ul><li>  The shortest and simplest solution of all </li><li>  No restrictions on the length of the identifier </li></ul><br><p>  <strong>Minuses</strong> </p><br><ul><li>  Lost the ability to change the characters themselves in the character set </li><li>  Lost the ability to change the number of characters in the set </li><li>  Complicated management of the length of the final identifier </li></ul><br><p>  PS: Correct me in the comments if I missed something. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334994/">https://habr.com/ru/post/334994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334984/index.html">Resource planning. Part 1. What is it all about?</a></li>
<li><a href="../334986/index.html">Comedy. Actors in Node.JS for flexible scaling</a></li>
<li><a href="../334988/index.html">Struct, union, and enum types in Modern C ++</a></li>
<li><a href="../334990/index.html">Introduction to octree</a></li>
<li><a href="../334992/index.html">How to view 20 million domain names and be satisfied</a></li>
<li><a href="../334996/index.html">Usability card product. Scenario profitable for business</a></li>
<li><a href="../334998/index.html">Protection of the site against attacks using Nemesida WAF: from signatures to artificial intelligence</a></li>
<li><a href="../335002/index.html">Lecture by Vladimir Iglovikov at machine training for Yandex</a></li>
<li><a href="../335006/index.html">[Archeology Live] Shameful talk about singletons</a></li>
<li><a href="../335008/index.html">We give the user of the application game currency using AdMob Rewarded Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>