<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning to write multi-threaded and multi-process applications in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is not for experienced Python tamers, for whom unraveling this tangle of snakes is child's play, but rather a superficial overview of mul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning to write multi-threaded and multi-process applications in Python</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/a06/32c/656/a0632c656b32bf928add9f5cf3085f4d.png" align="left">  This article is not for experienced Python tamers, for whom unraveling this tangle of snakes is child's play, but rather a superficial overview of multi-threaded features for those who recently sat down on a python. <br><br>  Unfortunately, there are not so much material in Russian on the topic of multithreading in Python, and the pythoners who have not heard anything, for example, about GIL, began to come across to me with enviable regularity.  In this article I will try to describe the most basic features of a multi-threaded python, tell you what GIL is and how to live with it (or without it) and much more. <br><a name="habracut"></a><br><br>  Python is a charming programming language.  It perfectly combines many programming paradigms.  Most of the tasks that a programmer can meet are solved here easily, elegantly and concisely.  But for all these tasks, a single-threaded solution is often enough, and single-threaded programs are usually predictable and easy to debug.  What can not be said about multi-threaded and multiprocess programs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Multithreaded applications </h4><br>  Python has a <a href="http://docs.python.org/library/threading.html">threading</a> module, and it has everything you need for multi-threaded programming: there are different types of locks, and a semaphore, and an event mechanism.  One word - everything you need for the vast majority of multi-threaded programs.  And to use all these tools is quite simple.  Consider an example of a program that runs 2 threads.  One thread writes ten ‚Äú0‚Äù, the other - ten ‚Äú1‚Äù, and <b>strictly</b> in turn. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, event_for_wait, event_for_set)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">10</span></span>): event_for_wait.wait() <span class="hljs-comment"><span class="hljs-comment"># wait for event event_for_wait.clear() # clean event for future print x event_for_set.set() # set event for neighbor thread # init events e1 = threading.Event() e2 = threading.Event() # init threads t1 = threading.Thread(target=writer, args=(0, e1, e2)) t2 = threading.Thread(target=writer, args=(1, e2, e1)) # start threads t1.start() t2.start() e1.set() # initiate the first event # join threads to the main thread t1.join() t2.join()</span></span></code> </pre> <br>  No magic and voodoo-code.  The code is clear and consistent.  And, as you can see, we created a stream from a function.  For small tasks it is very convenient.  This code is also quite flexible.  Suppose we have a 3rd process that writes ‚Äú2‚Äù, then the code will look like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, event_for_wait, event_for_set)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">10</span></span>): event_for_wait.wait() <span class="hljs-comment"><span class="hljs-comment"># wait for event event_for_wait.clear() # clean event for future print x event_for_set.set() # set event for neighbor thread # init events e1 = threading.Event() e2 = threading.Event() e3 = threading.Event() # init threads t1 = threading.Thread(target=writer, args=(0, e1, e2)) t2 = threading.Thread(target=writer, args=(1, e2, e3)) t3 = threading.Thread(target=writer, args=(2, e3, e1)) # start threads t1.start() t2.start() t3.start() e1.set() # initiate the first event # join threads to the main thread t1.join() t2.join() t3.join()</span></span></code> </pre><br>  We added a new event, a new stream and slightly changed the parameters with which <br>  threads start (of course, you can write a more general solution using, for example, MapReduce, but this is already beyond the scope of this article). <br>  As we see, there is still no magic.  Everything is simple and clear.  Let's go further. <br><br><h4>  Global Interpreter Lock </h4><br>  There are two most common reasons for using threads: firstly, to increase the efficiency of using the multicore architecture of modern processors, and hence the performance of the program; <br>  secondly, if we need to divide the logic of the program into parallel fully or partially asynchronous sections (for example, be able to ping several servers at the same time). <br><br>  In the first case, we are confronted with such a restriction of Python (or rather its main CPython implementation), as Global Interpreter Lock (or abbreviated GIL).  The concept of GIL is that only one thread at a time can be executed by a processor.  This is done to ensure that between threads there is no struggle for individual variables.  The executable thread accesses the entire environment.  This feature of the implementation of threads in Python greatly simplifies work with threads and gives a certain thread safety. <br><br>  But there is a subtle point: it may seem that a multi-threaded application will work exactly the same time as a single-threaded one, doing the same thing, or for the sum of the execution time of each thread on the CPU.  But here we are waiting for one unpleasant effect.  Consider the program: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test1.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fout: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> &gt;&gt; fout, <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  This program simply writes a million ‚Äú1‚Äù lines to the file and does it in ~ 0.35 seconds on my computer. <br><br>  Consider another program: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Thread <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fout: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(n): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> &gt;&gt; fout, <span class="hljs-number"><span class="hljs-number">1</span></span> t1 = Thread(target=writer, args=(<span class="hljs-string"><span class="hljs-string">'test2.txt'</span></span>, <span class="hljs-number"><span class="hljs-number">500000</span></span>,)) t2 = Thread(target=writer, args=(<span class="hljs-string"><span class="hljs-string">'test3.txt'</span></span>, <span class="hljs-number"><span class="hljs-number">500000</span></span>,)) t1.start() t2.start() t1.join() t2.join()</code> </pre><br>  This program creates 2 threads.  In each stream, she writes in a separate file for half a million lines "1".  In essence, the amount of work is the same as that of the previous program.  But over time, there is an interesting effect.  The program can work from 0.7 seconds to as much as 7 seconds.  Why is this happening? <br><br>  This is due to the fact that when a thread does not need a CPU resource, it frees GIL, and at this moment it can try to get it, and another thread, and also the main thread.  At the same time, the operating system, knowing that there are many cores, can aggravate everything by trying to distribute the flows between the cores. <br><br>  UPD: at the moment in Python 3.2 there is an improved implementation of GIL, in which this problem is partially solved, in particular, due to the fact that each thread after losing control waits for a short period of time before it can again capture GIL (there is good <a href="http://www.dabeaz.com/python/NewGIL.pdf">presentation</a> in English) <br><br>  ‚ÄúIt‚Äôs impossible to write effective multi-threaded programs in Python?‚Äù You ask.  No, of course, there is a way out and even a few. <br><br><h4>  Multi-process applications </h4><br>  In a sense, to solve the problem described in the previous paragraph, Python has a <a href="http://docs.python.org/library/subprocess.html">subprocess</a> module.  We can write a program that we want to execute in a parallel thread (in fact, already a process).  And run it in one or more threads in another program.  Such a way would really speed up the work of our program, because the threads created in the GIL launching program do not pick up, but just wait for the completion of the running process.  However, in this way there are a lot of problems.  The main problem is that it becomes difficult to transfer data between processes.  It would be necessary to somehow serialize objects, establish communication through PIPE or a friend of tools, and all this inevitably carries overhead and the code becomes difficult to understand. <br><br>  Here another approach can help us.  Python has a <a href="http://docs.python.org/library/multiprocessing.html">multiprocessing</a> module.  In terms of functionality, this module resembles <b>threading</b> .  For example, processes can be created in the same way from normal functions.  The methods for working with processes are almost all the same as for threads from the threading module.  But for the synchronization of processes and data exchange it is customary to use other tools.  We are talking about queues (Queue) and channels (Pipe).  However, there are analogs of locks, events and semaphores that were in threading, too. <br><br>  In addition, the multiprocessing module has a mechanism for working with shared memory.  For this, the module has classes for the variable (Value) and the array (Array), which can be ‚Äúgeneralized‚Äù (share) between processes.  For the convenience of working with common variables, you can use classes managers (Manager).  They are more flexible and easy to handle, but slower.  It should be noted a pleasant opportunity to make common types from the ctypes module using the multiprocessing.sharedctypes module. <br><br>  Even in the multiprocessing module, there is a mechanism for creating process pools.  This mechanism is very useful for implementing the Master-Worker template or for implementing a parallel Map (which in a sense is a special case of the Master-Worker). <br><br>  Of the main problems with working with the multiprocessing module, it is worth noting the relative platform dependence of this module.  Since working with processes is organized differently in different operating systems, some restrictions are imposed on the code.  For example, in Windows OS there is no fork mechanism, therefore the process split point should be wrapped in: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ ==<span class="hljs-string"><span class="hljs-string">'__main__'</span></span>:</code> </pre><br>  However, this design and so is a good form. <br><br><h4>  What else ... </h4><br>  There are other libraries and approaches for writing parallel applications in Python.  For example, you can use Hadoop + Python or various MPI implementations in Python (pyMPI, mpi4py).  You can even use wrappers for existing C ++ or Fortran libraries.  Here one could mention such frameworks / libraries as Pyro, Twisted, Tornado and many others.  But this is all beyond the scope of this article. <br><br>  If you like my style, in the next article I will try to tell you how to write simple interpreters in <a href="http://www.dabeaz.com/ply/">PLY</a> and why they can be used. </div><p>Source: <a href="https://habr.com/ru/post/149420/">https://habr.com/ru/post/149420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149415/index.html">Now Google Translate for Android translates from photos</a></li>
<li><a href="../149416/index.html">Forwarding a video card in Xen, from under Ubuntu</a></li>
<li><a href="../149417/index.html">Microsoft is already thinking about Windows 9 and choosing the name of the Windows 8 interface.</a></li>
<li><a href="../149418/index.html">Wi-Fi: unobvious nuances (for example, home Wi-Fi) [part 1]</a></li>
<li><a href="../149419/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ17 (August 4 - 10, 2012)</a></li>
<li><a href="../149421/index.html">RAID from USB flash drives</a></li>
<li><a href="../149422/index.html">Digital terrestrial TV in Ukraine, or a review of DVB-T2 tuner Strong SRT 8500</a></li>
<li><a href="../149424/index.html">Biometric identification by the pattern of the veins of the palm (mini How To)</a></li>
<li><a href="../149426/index.html">Kohana, Image Preview - it‚Äôs just</a></li>
<li><a href="../149427/index.html">Backdoor in your Java application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>