<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dump, extract: the architecture of complex chat bots</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Users, having communicated with smart voice assistants, wait for intelligence from chatbots. If you are developing a bot for business, the expectation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dump, extract: the architecture of complex chat bots</h1><div class="post__text post__text-html js-mediator-article">  Users, having communicated with smart voice assistants, wait for intelligence from chatbots.  If you are developing a bot for business, the expectations are even higher: the customer wants the user to follow the necessary, pre-written script, and the user wants the robot to answer the questions posed sensibly and preferably with human language, help solve problems, and sometimes just support small talk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0-/pv/i1/0-pvi1riz8k3g804x9fke0sre6w.jpeg"></div><br>  We do English-speaking chat bots that communicate with users through different channels - Facebook Messenger, SMS, Amazon Alexa and the web.  Our bots replace support services, insurance agents, and be able to just chat.  Each of these tasks requires its own approach to development. <br><br>  In this article we will describe what modules our service consists of, how each one is made, what approach we have chosen and why.  We share our experience analyzing different tools: when generative neural networks are not the best choice, why instead of Doc2vec we use Word2vec, what is the charm and horror of ChatScript, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  At first glance it may seem that the problems that we solve are rather trivial.  However, in the field of Natural Language Processing there are a number of difficulties associated with both the technical implementation and the human factor. <br><ol><li>  A billion people speak English, and each speaker uses it in his own way: there are different dialects, individual features of speech. </li><li>  Many words, phrases and expressions are ambiguous: a typical example is in this picture. </li><li>  Context is necessary for the correct interpretation of the meaning of words.  However, the bot that asks the client clarifying questions is not as cool as the one that can switch to any topic as desired by the user and answer any question. <br></li><li>  Often, in lively speech and correspondence, people either neglect the rules of grammar, or respond so briefly that it is almost impossible to restore the structure of the sentence. </li><li>  Sometimes in order to answer a user's question, it is necessary to verify his request with the texts of the FAQ.  At the same time, you need to make sure that the text found in the FAQ is really the answer, and not just contains several words that match the query. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/zw/iy/yzzwiynir0jqsmzyjdcfrrrokoo.png"></div><br>  These are just a few of the most obvious aspects, but there is also slang, jargon, humor, sarcasm, spelling and pronunciation errors, abbreviations and other points that make it difficult to work in this area. <br><br>  To solve these problems, we developed a bot that uses a set of approaches.  The AI ‚Äã‚Äãpart of our system consists of a dialog manager, recognition service and important complex microservices that solve specific problems: Intent Classifier, FAQ-service, Small Talk. <br><br><h3>  Start a conversation.  Dialog Manager </h3><br>  The task of the Dialog Manager in the bot is a software simulation of communication with a live agent: he must guide the user through a conversation scenario to some useful goal. <br>  To do this, firstly, find out what the user wants (for example, calculate the cost of insurance for cars), secondly, find out the necessary information (address and other user data, data about drivers and cars).  After that, the service should give a useful answer - fill out the form and give the client the result of this data.  However, we should not ask the user about what he has already indicated earlier. <br><br>  Dialog Manager allows you to create such a scenario: to describe programmatically, to build from small bricks - specific questions or actions that should occur at a certain moment.  In fact, the scenario is a directed graph, where each node is a message, a question, an action, and an edge determines the order and conditions for switching between these nodes if there is a multiple choice of switching from one node to another. <br>  Basic node types <br><ul><li>  Nodes that are waiting until the queue reaches them and they appear in the messages. </li><li>  Nodes waiting until the user shows a certain intention (for example, he writes: ‚ÄúI want to get insurance‚Äù). </li><li>  Nodes awaiting data from the user to validate and save them. </li><li>  Nodes for the implementation of various algorithmic constructions (cycles, branching, etc.). </li></ul><br>  If the node is closed, the control will not be transferred to it again, and the user will not see the question that has already been asked.  Thus, if we perform a depth-first search on such a column to the first open node, we will receive a question that must be asked to the user at a given point in time.  Alternately answering the questions that Dialog Manager generates, the user gradually closes all the nodes in the graph, and it will be considered that he executed the prescribed script.  Then we, for example, give the user a description of the insurance options that we can offer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/sb/hp/ntsbhp9gpihkj2awmq8clkt6cl8.png"></div><br><h4>  ‚ÄúI've already said everything!‚Äù </h4><br>  Suppose we ask the user a name, and he will also give out his date of birth, name, gender, marital status, address, or send a photo of his driver‚Äôs license in one message.  The system will extract all relevant data and close the corresponding nodes, that is, questions about the date of birth and gender will no longer be asked. <br><br><h4>  "And by the way ..." </h4><br>  Also in Dialog Manager implemented the ability to simultaneously communicate on several topics.  For example, the user says: "I want to get insurance."  Then, without completing this dialogue, he adds: "I want to make a payment on a previously attached policy."  In such cases, Dialog Manager saves the context of the first topic, and after completing the second scenario, offers to resume the previous dialogue from the place where it was interrupted. <br><br>  There is an opportunity to return to questions that the user has already answered earlier.  To do this, the system saves a snapshot of the graph when receiving each message from the client. <br><br><h4>  What options? </h4><br>  In addition to ours, we considered another AI approach to implementing the dialog manager: the user's intention and parameters are sent to the input of the neural network, and the system itself generates the corresponding states, the next question to be asked.  However, in practice this method requires the addition of the rule based approach.  Perhaps such an implementation option is suitable for trivial scenarios - for example, for ordering food, where you need to get only three parameters: what the user wants to order, when he wants to receive the order and where to bring it.  But in the case of complex scenarios, as in our subject area, this is still unattainable.  At the moment, machine learning technologies are not able to qualitatively guide the user to the target in a complex scenario. <br><br>  Dialog Manager is written in the Python, Tornado framework, because initially our AI part was written as a single service.  A language was chosen in which all this can be implemented without spending resources on communication. <br><br><h3>  "Let's decide."  Recognition Service </h3><br>  Our product is able to communicate through different channels, but the AI ‚Äã‚Äãpart is completely client independent: this communication only comes in the form of proxied text.  The dialog manager conveys the user's context, response and collected data to the Recognition Service, which is responsible for recognizing the user's intentions and extracting the necessary data. <br>  Today, the Recognition Service consists of two logical parts: the Recognition Manager, which manages the recognition pipeline, and the extractors. <br><br><h4>  Recognition Manager </h4><br>  Recognition Manager is responsible for all the basic stages of speech sense recognition: tokenization, lemmatization, etc. It also determines the order of extractors (objects that recognize entities and signs in texts) by which a message will be skipped, and decides when it is necessary to stop recognition and return finished result.  This allows you to run only the necessary extractors in the most expected order. <br><br>  If we asked what the name of the user is, then it is logical to check whether the name came in the answer.  The name has come, and there is no more useful text - it means that recognition can be completed at this step.  Some more useful entities have come, which means that recognition needs to be continued.  Most likely, the person added some more personal data - respectively, you need to run the personal data processing extractor. <br><br>  Depending on the context, the order in which the extractors are started may vary.  This approach allows us to significantly reduce the load on the entire service. <br><br><h4>  Extractors </h4><br>  As mentioned above, extractors are able to recognize certain entities and characteristics in texts.  For example, one extractor recognizes phone numbers;  the other determines whether the person answered the question positively or negatively;  the third one recognizes and verifies the address in the message;  the fourth is the user's vehicle data.  Passing a message through a set of extractors is the process of recognizing our incoming messages. <br><br>  For optimal performance of any complex system, it is necessary to combine approaches.  We followed this principle when working on extractors.  I will highlight some of the principles of work that we used in extractors. <br><br>  Using our own microservices with Machine Learning inside (extractors send a message to this service, sometimes supplement it with the information they have and return the result). <br><br><ul><li>  Using POS tagging, Syntactic parsing, Semantic parsing (for example, determining the user's intent by verb) </li><li>  Using full-text search (can be used to find the make and model of the car in the messages) </li><li>  Using regular expressions and response patterns </li><li>  Using third-party APIs (such as the Google Maps API, SmartyStreets, etc.) </li><li>  A verbatim search for sentences (if the person answered ‚Äúyep‚Äù shortly, then there is no point in passing it through the ML algorithms to search for intent). </li><li>  We also use ready-made natural language processing solutions in extractors. </li></ul><br><h4>  What options? </h4><br>  We looked at the NLTK, Stanford CoreNLP and SpaCy libraries.  NLTK is the first Google issue when you start a NLP survey.  It is very cool for prototyping solutions, has extensive functionality and is quite simple.  But its performance leaves much to be desired. <br><br>  The Stanford CoreNLP has a serious disadvantage: it pulls the Java virtual machine with very large modules, built-in libraries, and consumes a lot of resources.  In addition, the output from this library is difficult to customize. <br><br>  As a result, we stopped at SpaCy, because it has enough functionality for us and has an optimal balance of lightness and speed.  The SpaCy library is dozens of times faster than the NLTK and offers much better dictionaries.  However, it is much easier than Stanford CoreNLP. <br><br>  At the moment we use spaCy for tokenization, vectorization of the message (using the built-in trained neural network), primary recognition of parameters from the text.  Since the library covers only 5% of our recognition needs, we had to add a lot of functions. <br><br><h4>  "It used to be like that ..." </h4><br>  Recognition Service was not always a two-part structure.  The first version was the most trivial: we in turn used different extractors and tried to understand if there were any particular parameters or intentions in the text.  The AI ‚Äã‚Äãdid not even smell there - it was a completely rule based approach.  The difficulty was that the same intention could be expressed in a mass of ways, each of which should be described in the rules.  At the same time, it is necessary to take into account the context, since the same user phrase, depending on the question posed, may require different actions.  For example, from the dialogue: ‚ÄúAre you married?‚Äù - ‚ÄúAlready two years‚Äù it can be understood that the user is married (boolean value).  And from the dialogue ‚ÄúHow long do you drive this car?‚Äù - ‚ÄúFor two years already‚Äù, you need to extract the value ‚Äú2 years‚Äù. <br><br>  From the very beginning, we understood that the support of a rule based solution would require great efforts, and with an increase in the number of supported intentions, the number of rules will increase much faster than in the case of an ML-based system.  However, a business point of view.  we needed to launch MVP, a rule based approach allowed us to do this quickly.  Therefore, we used it, and in parallel we worked on the ML-model of intent recognition.  As soon as she appeared and began to give satisfactory results, the rule-based approach slowly began to depart. <br><br>  For most cases of information extraction, we used ChatScript.  This technology provides its own declarative language that allows you to write templates for extracting data from natural language.  Thanks to WordNet under the hood, this solution is very powerful (for example, you can specify ‚Äúcolor‚Äù in the recognition pattern, and WordNet recognizes any narrowing concept, such as ‚Äúred‚Äù).  We did not see any analogs at that time.  But ChatScript is written very crookedly and buggy, with its use it is almost impossible to implement complex logic. <br><br>  As a result, the disadvantages outweighed, and we abandoned ChatScript in favor of NLP libraries in Python. <br>  In the first version of Recognition Service, we came up against the ceiling for flexibility.  The introduction of each new feature greatly slowed down the whole system. <br><br>  So we decided to completely rewrite the Recognition Service, dividing it into two logical parts: small, lightweight extractors and Recognition Manager, which will manage the process. <br><br><h3>  "What do you want?".  Intent Classifier </h3><br>  In order for a bot to communicate adequately - to provide the necessary information on request and to fix the user's data - it is necessary to determine the user's intention (intent) based on the text sent to them.  The list of intents, according to which we can interact with users, is limited to the client‚Äôs business objectives: it may be the intention to find out the conditions of insurance, fill in data about yourself, get an answer to a frequently asked question, and so on. <br><br>  There are many approaches to classification of intents based on neural networks, in particular, on recurrent LSTM / GRU.  They have proven themselves in recent studies, but they have a common drawback: a very large sample is required for correct operation.  On a small amount of data, such neural networks are either difficult to train, or they produce unsatisfactory results.  The same applies to the Fast Text framework from Facebook (we looked at it as this is a state-of-the-art solution for handling short and medium phrases). <br><br>  Our training samples are very high-quality: a dataset is made up of a full-time team of linguists who are proficient in English and know the specifics of the insurance field.  However, our samples are relatively small.  We tried to dilute them with public data, but those, with rare exceptions, did not match our specifics.  We also tried to attract freelancers with Amazon Mechanical Turk, but this method also turned out to be inoperative: the data they sent was partially poor quality, the samples had to be completely rechecked. <br><br>  Therefore, we were looking for a solution that would work on a small sample.  A good quality of data processing was demonstrated by the Random Forest classifier trained on data that was converted into vectors of our bag-of-words model.  With the help of cross-validation, we have selected the optimal parameters.  Among the advantages of our model are speed and size, as well as relative ease of deployment and additional training. <br><br>  In the process of working on the Intent Classifier, it became clear that for some tasks its use is not optimal.  Suppose the user wants to change the name specified in the insurance, or the car number.  That the qualifier correctly defined this intention, it would be necessary to manually add to the template all the phrases used in this case.  We found another way: to make a small extractor for the Recognition Service, which defines intent by keywords and NLP methods, and to use the Intent Classifier for non-sample phrases in which the keyword method does not work. <br><br><h3>  "They always ask about it."  FAQ </h3><br>  Many of our clients have sections with FAQ.  In order for the user to receive such answers directly from the chat bot, it was necessary to provide a solution that would (a) recognize the FAQ query;  b) would find the most relevant answer in our database and give it out. <br><br>  There are a number of models trained on SQUAD from Stanford.  They work well when the response text from the FAQ contains the words from the user's question.  Suppose the FAQ says: "Frodo said that he would take the Ring to Mordor, although he did not know the way there."  If the user asks: ‚ÄúWhere does Frodo put the Ring?‚Äù, The system will respond: ‚ÄúTo Mordor‚Äù. <br><br>  Our script, as a rule, was different.  For example, a bot should respond differently to two similar requests - ‚ÄúCan I pay?‚Äù And ‚ÄúCan I pay online?‚Äù: In the first case, you can offer a form of payment to a person, in the second case, you can pay online, here‚Äôs the page address. <br><br>  Another class of solutions for assessing the similarity of documents is focused on long answers - at least a few sentences, among which contains information that interests the user.  Unfortunately, in cases with short questions and answers (‚ÄúHow do I pay online?‚Äù - ‚ÄúYou can pay with PayPal‚Äù), they are very unstable. <br><br>  Another solution is the Doc2vec approach: the large text is distilled into a vector representation, which is then compared with other documents in the same form and reveals the coefficient of similarity.  This approach also had to be put aside: it is focused on long texts, but we mainly deal with questions and answers from one or two sentences. <br><br>  Our decision was based on two steps.  First: we, using embeddings, translated into vectors each word in the sentence, using the Google Word2vec model.  After that, we considered the average vector over all words, representing one sentence as one vector.  The second step we took the question vector and found in the FAQ database stored in the same vector form, the closest answer to a certain extent, in our case cosine. <br><br>  The advantages include ease of implementation, very easy extensibility and fairly simple interpretability.  The disadvantages are weak optimization possibilities: this model is difficult to refine - it either works well in most of your use cases, or you have to give it up. <br><br><h3>  "And talk?".  Small talk </h3><br>  Sometimes the user writes something absolutely irrelevant, for example: "The weather is good today."  This is not included in the list of interests we are interested in, but we still want to respond intelligently, demonstrating the intelligence of our system. <br><br>  For such solutions, a combination of the approaches described above is used: they are based on either very simple rule based solutions or generative neural networks.  We wanted to get a prototype early, so we took a public dataset from the Internet and used an approach very similar to the one used for the FAQ.  For example, a user has written something about the weather ‚Äî and using an algorithm comparing the vector representations of two sentences for a certain cosine measure, we are looking for a proposal in a public dataset that will be as close as possible to the subject of the weather. <br><br><h3>  Training </h3><br>  Now we have no goal to create a bot that would learn from every message received from customers: first, experience shows that this is the way to death of the bot (recall how IBM Watson <a href="https://habr.com/company/ibm/blog/165423/">had to erase the database</a> , because it began to diagnose with , and Microsoft's Twitter-bot <a href="https://habr.com/post/392113/">managed to become a racist in</a> just a day).  Secondly, we strive to close the tasks of insurance companies as best we can;  self-learning bot is not our business task.  We have written a number of tools for linguists and QA-teams, with which they can manually train bots, exploring dialogs and correspondence with users during post-moderation. <br><br>  However, our bot seems to be ready to pass the Turing test.  Some users start a serious conversation with him, believing that they are communicating with an insurance agent, and one even started threatening the chief with a complaint when the bot misunderstood him. <br><br><h3>  Plans </h3><br>  Now we are working on the visual part: the display of the entire graph of the script and the ability to compose it using the GUI. <br><br>  On the part of the Recognition Service, we implement linguistic analysis to recognize and understand the meaning of each word in the message.  This will improve the accuracy of the reaction and extract additional data.  For example, if a person fills in a car insurance and mentions that he has an uninsured house, the bot will be able to remember this message and give it to the operator to contact the client and offer home insurance. <br><br>  Another feature in the work - processing feedback.  After the completion of the dialogue with the bot, we ask the user whether the service pleased him.  If Sentiment Analysis recognized the user feedback as positive, we offer the user to share opinions in social networks.  If the analysis shows that the user has reacted negatively, the bot clarifies what was wrong, fixes the answer, says: ‚ÄúOkay, we will correct‚Äù - and does not offer to share the feedback in the tape. <br><br>  One of the keys to making communication with the bot as natural as possible is to make the bot modular, to expand the set of reactions available to it.  We are working on it.  Maybe thanks to this, the user was ready to sincerely accept our bot as an insurance agent.  The next step: to make the person try to announce the bot thanks. <br><br><hr><br>  <i>The article was written together with Sergey Kondratyuk and <a href="https://habr.com/users/ratuvog/">Mikhail Kazakov</a> .</i>  <i>Write in the comments your questions, we will prepare more practical materials on them.</i> </div><p>Source: <a href="https://habr.com/ru/post/429638/">https://habr.com/ru/post/429638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429628/index.html">How to create a chat bot for VKontakte using Python, Django and webhook</a></li>
<li><a href="../429630/index.html">"Monsters in games or make fear diverse"</a></li>
<li><a href="../429632/index.html">Causes of failure to hosters when added to directories</a></li>
<li><a href="../429634/index.html">This is how the search for borrowing in Antiplagiat is arranged.</a></li>
<li><a href="../429636/index.html">Installing a 3CX PBX in the Amazon Lightsail Cloud</a></li>
<li><a href="../429640/index.html">Let's remove quaternions from all 3D engines.</a></li>
<li><a href="../429642/index.html">Security Week 46: let's update something</a></li>
<li><a href="../429644/index.html">Dimmable Spot GX53 with adjustable illumination angle</a></li>
<li><a href="../429648/index.html">DNS Over TLS & Over HTTPS is now on iOS / Android and for all networks at once [Thanks to Cloudflare]</a></li>
<li><a href="../429650/index.html">Open lesson "Symmetric and asymmetric encryption"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>