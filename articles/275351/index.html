<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic Interrupt Management in ARM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I will tell you how you can dynamically replace interrupt handlers in ARM processors using the example of STM32 microcontrollers. The method I d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic Interrupt Management in ARM</h1><div class="post__text post__text-html js-mediator-article">  Today I will tell you how you can dynamically replace interrupt handlers in ARM processors using the example of STM32 microcontrollers.  The method I described works in ARM Cortex M3 processors and above. <br><br>  When and where might it be needed?  First, you can replace interrupt handlers if you are faced with the task of writing a program that is compatible with different hardware platforms.  There are several kernel interrupts in ARM processors that are required for any implementation of the architecture.  But the remaining interrupts are for the periphery, and processor manufacturers are free to set these vectors for any peripheral devices present in the processor.  This requires dynamically substituting the necessary interrupt handlers for each implementation of the architecture.  Secondly, if your product has high demands on the speed of reaction to external events, sometimes the choice of the desired action inside the interrupt handler is ineffective, and it will be more profitable to change the interrupt vector dynamically. <br><a name="habracut"></a><br>  In order to understand how to programmatically change the interrupt handler, consider how the processor determines what to do when an interrupt occurs.  In STM32 microcontrollers, the interrupt vector table is located at the very beginning of the executable code.  The first 32-bit word of the executable program is the stack pointer.  Usually it is equal to the maximum address of the controller's RAM.  Next comes the pointer to Reset_Handler, NMI_Handler and other interrupt handlers.  Theoretically, to dynamically set a new function to handle an interrupt, you simply need to rewrite one of these pointers.  But the hardware limitations of the platform will not allow this, because the program in the STM32 is executed from FLASH-memory, and to write a new word into it, you must first erase the entire page, and this is not included in our plans: the program cannot be damaged.  So let's try to transfer the interrupt table to the RAM and change the vectors already there.  But the question remains: how does the kernel know that the table has been moved?  After all, a simple copying of the table will not work if the kernel turns to the old table when an interrupt occurs and calls the old handler.  To resolve this situation there is a VTOR (Vector Table Offset Register) register.  You will not find the description of this register in the documentation for the controller; debuggers do not know about it either.  Information about this registry should be found in the documentation for the ARM core, you can also find it in the header file core_cm3.h.  The register is located at address 0xE000ED08, and its value must be a multiple of 0x400.  This means that you can not put the interrupt table wherever they want.  Let's not puzzle, and just place it at the beginning of the RAM, and then set the new value of the VTOR register.  Having filled the new interrupt table, we will test it by interrupting the system timer. <br><br>  To accomplish the task, we will use the gcc compiler, the CMSIS library.  We will need to modify the startup_stm32f103xb.asm file and the linker script.  In the linker script, you need to explicitly specify the location of the interrupt table in RAM and declare the variables of the beginning and end of the interrupt table.  In the startup_stm32f103xb.asm file, copy the table and set a new value for the VTOR register.  Why did I decide to modify the library file, what is usually not recommended?  The fact is that the operations of allocating sections of memory should be performed as early as possible, and it is this operation that performs the code of this file: it copies global variables from the .data section and initializes the static memory (.bss) to zero.  We will only finish copying the .isr_vector section. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start modifying the linker script.  Rewrite the .isr_vector section as follows: <br><br><pre><code class="hljs ruby">/* The startup code goes first into FLASH *<span class="hljs-regexp"><span class="hljs-regexp">/ .isr_vector : { . = ALIGN(4); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   4-  _svector = .; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    -       KEEP(*(.isr_vector)) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  .isr_vector    . = ALIGN(4); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   4-  _evector = .; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     } &gt;RAM AT&gt; FLASH /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    flash-,       _sivector = LOADADDR(.isr_vector); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     flash-.</span></span></code> </pre> <br>  We have declared a place to place the interrupt table in RAM.  Now the variables declared in the linker script must be additionally declared in the assembler.  Paste this code somewhere at the beginning of the file. <br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">svector</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">evector</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">sivector</span></span></code> </pre><br>  Now let's copy the interrupt table.  To do this, between the instructions {bcc FillZerobss} and {bl SystemInit} we insert the following code: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">movs</span></span> r1, <span class="hljs-comment"><span class="hljs-comment">#0 //  b LoopCopyVectorTable //    CopyVectorTable: ldr r3, =_sivector //   r3      flash- ldr r3, [r3, r1] //      r3+r1,    r3 (r3=*(r3+r1)) str r3, [r0, r1] //   r0+r1   r3 adds r1, r1, #4 //    LoopCopyVectorTable: ldr r0, =_svector //   r0        ldr r3, =_evector //   r3        adds r2, r0, r1 //r2=r0+r1 cmp r2, r3 //  ? bcc CopyVectorTable // ,     </span></span></code> </pre><br>  The table is copied.  Now we need to set the value of the VTOR register.  As already mentioned, the address of this register is specified in the core_cm3.h file, but let's not knock on it from the assembler, and just declare it directly in this file.  We write the definition: <br><br><pre> <code class="hljs dos">.<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> VTOR, <span class="hljs-number"><span class="hljs-number">0</span></span>xE000ED08</code> </pre><br>  And then just put this figure at the end of the interrupt table.  To do this, add to the end of the .isr_vector section: <br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VTOR</span></span></code> </pre><br>  We ensured that the address of the VTOR register is located in the flash memory of the controller.  Now write the desired value in the register.  To do this, after the code to copy the interrupt table, add the following code: <br><br><pre> <code class="hljs ruby"> ldr r<span class="hljs-number"><span class="hljs-number">0</span></span>, =_svector /<span class="hljs-regexp"><span class="hljs-regexp">/       r0 ldr r2, =VTOR /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   VTOR   r2 str r0, [r2] /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  c,   r2  r0</span></span></code> </pre><br>  Everything.  We received a new interrupt table, identical to the standard one, but now we can dynamically change it.  Now you can safely go to the function main: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">bl</span></span> __libc_init_array b main</code> </pre><br>  And check how our works work: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SysTickVectorLoc 0x2000003c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     void main(); void SysTick_Handler(); void SysTick_Handler2(); //  ,    void SysTick_Handler() { *(uint32_t*)SysTickVectorLoc = (uint32_t)SysTick_Handler2; } //    void SysTick_Handler2() { *(uint32_t*)SysTickVectorLoc = (uint32_t)SysTick_Handler; } void main() { //           *(uint32_t*)SysTickVectorLoc = (uint32_t)SysTick_Handler2; //   SysTick_Config(300); while(1) { __WFI();// .   . } }</span></span></span></span></code> </pre><br>  Here we immediately after the start of the controller change the interrupt handler of the system timer.  After that, we set up the timer, and in each interrupt handler we transfer the vector to another function.  Thus, each time the timer is triggered, the processor will alternately fall into one or another function. <br><br>  The code was checked on the controller STM32F103.  If you have any questions or comments, please write in the comments. <br><br>  <b>Literature</b> <br><br>  <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337h/DDI0337H_cortex_m3_r2p0_trm.pdf">ARM Cortex M3 Documentation</a> <br>  <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0489f/DUI0489F_arm_assembler_reference.pdf">ARM Assembler Documentation</a> </div><p>Source: <a href="https://habr.com/ru/post/275351/">https://habr.com/ru/post/275351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275337/index.html">Writing your spring-boot-starter</a></li>
<li><a href="../275339/index.html">Own search engine in the distributions of The Pirate Bay</a></li>
<li><a href="../275341/index.html">Patching modern application for use under Windows 2000</a></li>
<li><a href="../275343/index.html">3rd place in 11 steps in the Hola JavaScript contest</a></li>
<li><a href="../275347/index.html">Purple Encryption Machine</a></li>
<li><a href="../275353/index.html">HTML5 analog clock with JavaScript logic</a></li>
<li><a href="../275355/index.html">Anonymous Father Frost 2015-2016 - Post boasting New Year's gifts</a></li>
<li><a href="../275359/index.html">Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</a></li>
<li><a href="../275361/index.html">Office lighting control over Wi-Fi. Part 2: Q-touch sensor technology</a></li>
<li><a href="../275369/index.html">USB bootloader on the microcontroller: firmware update from a flash drive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>