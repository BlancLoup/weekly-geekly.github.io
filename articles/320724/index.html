<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New Year's Promises by Go-Developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo Roman Pronskiy 


 This is a translation of the post of one of the main developers of the Go language, Russ Cox, where in the traditional New Ye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New Year's Promises by Go-Developer</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/0f8/5b8/8e2/0f85b88e29e0461cae6fa0581ffc7c5b.jpg" alt="image"><br>  <em>Photo Roman Pronskiy</em> </p><br><p>  <em>This is a translation of the post of one of the main developers of the Go language, Russ Cox, where in the traditional New Year time format he gives himself promises and plans to fulfill them.</em> </p><br><p>  It was time to make decisions, and I thought that it makes sense to talk a little about what I want to work on in the coming year in relation to Go. </p><br><p>  Every year I set a goal to <strong>help go-developers</strong> .  I want to be sure that what the Go creators do has a positive effect on all Go developers.  Because they have a lot of ways to make a mistake: for example, you can spend too much time cleaning or optimizing code that does not require it;  respond only to the most common or recent complaints and requests;  focus unnecessarily on short-term improvements.  Therefore, it is so important to look at everything from the outside and to do what will bring the most benefit to the Go community. </p><br><p>  In this article I will describe a few basic tasks that I will focus on this year.  This is my own list, not the entire Go creators team. </p><a name="habracut"></a><br><p>  First, I want to get feedback on everything that is written here.  Secondly, I want to show that I really consider the problems described below important.  I think that people too often perceive the lack of activity on the part of the Go team as a signal that everything is fine, although in reality we are just solving other, more important tasks. </p><br><h3 id="aliasy-tipov">  Types Aliases </h3><br><p>  We have a constantly popping problem with moving types from one package to another with large-scale code base refactorings.  We tried to solve it last year with the help of <a href="https://golang.org/issue/16339">general aliases</a> , but it did not work: we explained the changes too badly, and the changes themselves were late, the code was not ready for Go 1.8 release.  Learning from this experience, I <a href="https://www.youtube.com/watch%3Fv%3Dh6Cw9iCDVcU">spoke</a> and <a href="https://talks.golang.org/2016/refactor.article">wrote an article</a> about the underlying problem, and this gave rise to a <a href="https://golang.org/issue/18130">productive discussion</a> in the Go tracker dedicated to possible solutions.  It seems that introducing more limited <a href="https://golang.org/design/18130-type-alias">type aliases</a> will be the right next step.  Hope they will appear in Go 1.9.  <a href="https://golang.org/issue/18130"># 18130</a> </p><br><h3 id="upravlenie-paketami">  Package management </h3><br><p>  In February 2010, I developed Go support for downloading published packages (goinstall, which became go get).  Since then a lot has happened.  In particular, the ecosystems of other languages ‚Äã‚Äãhave seriously raised expectations for package management systems, and the OpenSource community largely <a href="http://semver.org/">agrees</a> with <a href="http://semver.org/">semantic versioning</a> , which gives a basic understanding of the compatibility of different versions.  Here Go needs improvements, and a group of people are already <a href="https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management/">working on a solution</a> .  I want to make sure these ideas are properly integrated into the standard Go toolkit.  I want package management to be another Go value. </p><br><h3 id="uluchsheniya-v-sisteme-sborki">  Build Improvements </h3><br><p> The build with the <code>go</code> command has a number of flaws that it‚Äôs time to correct  Below are three typical examples to which I intend to devote my work. </p><br><p>  Assemblies can be very slow because the <code>go</code> utility does not actively cache the build results.  Many people do not understand that <code>go install</code> saves the results of their work, but <code>go build</code> does not, therefore, they start <code>go build</code> time after time and the build is expectedly slow.  The same applies to repeating <code>go test</code> without <code>go test ‚Äìi</code> in the presence of modified dependencies.  As far as possible, all types of assemblies should be incremental.  <a href="https://golang.org/issue/4719"># 4719</a> </p><br><p>  Test results also need to be cached: if the input data has not changed, then usually there is no need to restart the test itself.  This will greatly reduce the cost of launching "all tests", subject to minor changes or their absence.  <a href="https://golang.org/issue/11193"># 11193</a> </p><br><p>  Work outside GOPATH should be supported in much the same way as work within it.  In particular, it should be possible to run <code>git clone</code> , enter the directory with <code>cd</code> , and then run the <code>go</code> command, and make it all work fine.  Package management only increases the importance of this task: you should be able to work with different versions of a package (say, v1 and v2) without having to maintain separate GOPATH for them.  <a href="https://golang.org/issue/17271"># 17271</a> </p><br><h3 id="osnovnoy-nabor-koda">  Basic code set </h3><br><p>  It seems to me that specific examples from real projects benefited my presentation and the article on refactoring the code base.  We also came to the conclusion that <a href="https://golang.org/src/cmd/vet/README">adding to the vet</a> should solve problems typical of real programs.  I would like this analysis of actual practice to become a standard way to discuss and evaluate changes in Go. </p><br><p>  Now there is no generally accepted characteristic set of code to conduct a similar analysis: everyone must first create their own project, and this is too much work.  I would like to build a single, autonomous Git repository containing our official basic code set for analysis, which the community can check with.  A possible starting point is the top 100 Go repositories on GitHub by the number of stars, forks, or both. </p><br><h3 id="avtomaticheskiy-vet">  Automatic vet </h3><br><p>  Go-distribution comes with a powerful tool - <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> , which indicates common errors.  The level for these errors is high, so you need to listen to his messages.  But the main thing - do not forget to run the vet.  Although it would be more convenient to not remember.  I think that we could run the vet in parallel with the final compilation and linking of the binaries that occur when doing a <code>go test</code> without any slowdown.  If we succeed in this and if we limit the allowed vet checks to a sample that is 100% accurate, then we will generally be able to turn the vet transmission into a prerequisite for running the test.  Then the developers will not need to remember that you need to run <code>go vet</code> .  They will run the <code>go test</code> , and the vet will occasionally report something important, avoiding unnecessary debugging.  <a href="https://golang.org/issue/18084"># 18084</a> <a href="https://golang.org/issue/18085"># 18085</a> </p><br><h3 id="oshibki-i-obscheprinyatye-metodiki">  Errors and generally accepted techniques </h3><br><p>  Part of the common practice of error reporting in Go is that the functions include the relevant accessible context, including information about what operation was attempted (the name of the function and its arguments).  For example, this program </p><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">err</span></span> := os.Remove(<span class="hljs-string"><span class="hljs-string">"/tmp/nonexist"</span></span>) fmt.Println(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>)</code> </pre> <br><p>  displays </p><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> /tmp/nonexist: no such <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory</code> </pre> <br><p>  Not all Go code does the same as <code>os.Remove</code> does.  A lot of code does just </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  throughout the call stack and throws out a useful context that would be worth showing (for example, as <code>remove /tmp/nonexist:</code> above).  I would like to understand if we are not mistaken in our expectations for the inclusion of the context, and whether we can do something that will make it easier to write code that returns more informative errors. </p><br><p>  There are also various discussions in the community about interfaces for clearing errors from context.  And I want to understand when it is justified, and whether we should work out some kind of official recommendation. </p><br><h3 id="kontekst-i-luchshie-metodiki">  Context and best practices </h3><br><p>  In Go 1.7, we added a new <a href="https://golang.org/pkg/context/">context package</a> to store information that is somehow related to the request (for example, about <a href="https://blog.golang.org/context">timeouts, about whether the request was canceled and about authorization data</a> ).  Individual context is immutable (as strings or integer values): you can only get a new, updated context and pass it explicitly down the call stack, or (which is less common) back to the top.  The context of today is transmitted via the API (for example, <a href="https://golang.org/pkg/database/sql">database / sql</a> and <a href="http">net / http</a> ) mainly so that they can stop processing the request when the caller no longer needs the result of the processing.  Information about timeouts is quite suitable for passing in context, but is completely inappropriate for database options, for example, because they are unlikely to be applied as well to all possible database operations during the execution of a query.  What about a time source or a logger?  Can I store them in context?  I will try to understand and describe the criteria for what can be used in context and what cannot. </p><br><h3 id="model-pamyati">  Memory model </h3><br><p>  Unlike other languages, <a href="https://golang.org/ref/mem">the memory model</a> in Go is intentionally made modest, not giving users many promises.  In fact, the document says that it is not worth reading too much.  At the same time, it requires more from the compiler than in other languages: in particular, a race with integer values ‚Äã‚Äãis no excuse for the arbitrary behavior of your program.  There are full spaces: for example, <a href="https://golang.org/pkg/sync/atomic/">the sync / atomic package</a> is not mentioned.  I think the developers of the main compiler and runtime systems will agree with me that these atomics should behave in the same way as seqcst atomics in C ++ or volatile in Java.  But at the same time, we must neatly fit this into the memory model and into a long, long blog post.  <a href="https://golang.org/issue/5045"># 5045</a> <a href="https://golang.org/issue/7948"># 7948</a> <a href="https://golang.org/issue/9442"># 9442</a> </p><br><h3 id="neizmenyaemost">  Immutability </h3><br><p>  <a href="https://golang.org/doc/articles/race_detector.html">Race detector</a> is one of Go's favorite features.  But not having a race would be even better.  I would really like to have a reasonable way to integrate <a href="https://www.google.com/search%3Fq%3D%2522reference%2520immutability%2522">link immutability</a> into Go, so that programmers can make clear, verified judgments about what can and can not be written, thereby preventing certain race conditions at the compilation stage.  Go already has one immutable type ‚Äî <code>string</code> ;  It would be good to retroactively determine that <code>string</code> is a named type (or alias) for an immutable <code>[]byte</code> .  I do not think that this will be possible to realize this year, but I want to understand the possible solutions.  Javari, Midori, Pony and Rust have already identified interesting options, in addition, there are a number of studies on this topic. </p><br><p>  In the long run, if we manage to statically exclude the possibility of race condition, this will eliminate most of the memory model.  Perhaps this is an impossible dream, but, again, I would like to better understand the potential solutions. </p><br><h3 id="dzheneriki">  Generics </h3><br><p>  The most <a href="https://research.swtch.com/dogma">heated debates</a> between Go-developers and programmers in other languages ‚Äã‚Äãare burning about whether Go should support generics (or how long it should have happened).  As far as I know, the Go creators team never said that Go does not need generics.  We said that there are more important tasks that need to be addressed.  For example, I believe that improving support for package management will have a much stronger positive impact on most Go developers than the introduction of generics.  But at the same time, we realize that in some cases the lack of parametric polymorphism is a serious obstacle. </p><br><p>  Personally, I would like to be able to write common functions for working with channels, for example: </p><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">Join</span></span>        //      . func <span class="hljs-type"><span class="hljs-type">Join</span></span>(inputs ...&lt;-chan <span class="hljs-type"><span class="hljs-type">T</span></span>) &lt;-chan <span class="hljs-type"><span class="hljs-type">T</span></span> // <span class="hljs-type"><span class="hljs-type">Dup</span></span>    c   c1   c2 func <span class="hljs-type"><span class="hljs-type">Dup</span></span>(c &lt;-chan <span class="hljs-type"><span class="hljs-type">T</span></span>) (c1, c2 &lt;-chan <span class="hljs-type"><span class="hljs-type">T</span></span>)</code> </pre> <br><p>  I would also like to be able to write higher-level data processing abstractions on Go, similar to <a href="https://research.google.com/pubs/archive/35650.pdf">FlumeJava</a> or <a href="https://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a> , so that type mismatch errors are caught during compilation, not execution.  You can also write a bunch of data structures or algorithms using generics, but I think these high-level tools are more interesting. </p><br><p>  <a href="https://golang.org/design/15292-generics">For several years,</a> we have been <a href="https://research.swtch.com/generic">trying to</a> find the right way to introduce generics into Go.  The last few sentences concerned the development of a solution that would provide a general parametric polymorphism (like <code>chan T</code> ) and the unification of <code>string</code> and <code>[]byte</code> .  If the latter is solved by parametrization on the basis of immutability, as described in the previous part, then perhaps this will simplify the requirements for the generics architecture. </p><br><p>  When in 2008 I first thought about generics in Go, the main examples were C #, Java, Haskell, and ML.  But none of the approaches implemented in these languages ‚Äã‚Äãlooked perfect for Go.  Today there are more recent solutions, for example, in Dart, Midori, Rust and Swift. </p><br><p>  Several years have passed since we ventured to take up this topic and consider possible options.  It is probably time to look around again, especially in the light of information about the variability / immutability and decisions from new languages.  I do not think that generics will appear in Go this year, but I would like to sort out this issue. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320724/">https://habr.com/ru/post/320724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320714/index.html">3CX Client for Android and iOS updates, and the 3CX SBC release for Debian Linux</a></li>
<li><a href="../320716/index.html">Passive methods to detect illegal traffic termination</a></li>
<li><a href="../320718/index.html">PHP SQL query</a></li>
<li><a href="../320720/index.html">Own search algorithm for similar images. Theory</a></li>
<li><a href="../320722/index.html">Creating a quest tour of Berlin - step by step instructions</a></li>
<li><a href="../320726/index.html">Random Forest: walks in the winter forest</a></li>
<li><a href="../320728/index.html">Design patterns, iOS view developer. Part 0. Singleton Single</a></li>
<li><a href="../320730/index.html">IBM Model 5100: IBM's first laptop 40 years ago.</a></li>
<li><a href="../320732/index.html">The digest of interesting materials for the mobile # 188 developer (January 23-29)</a></li>
<li><a href="../320734/index.html">Who lives on Habr√©?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>