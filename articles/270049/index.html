<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Retrieving deleted data in iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is an author's translation of Chapter 6 Retrieving remote data from the book iOS7 in Action . Unlike the book, the entire interface is made progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Retrieving deleted data in iOS</h1><div class="post__text post__text-html js-mediator-article">  <i>This is an author's translation of Chapter 6 <b>Retrieving remote data</b> from the book <a href="https://www.manning.com/books/ios-7-in-action">iOS7 in Action</a> .</i>  <i>Unlike the book, the entire interface is made programmatically, and the text describing how to do all this in the storyboard is removed accordingly.</i>  <i>For simplicity, selected is the single position of the Portrait screen and the target iPhone platform.</i> <br><br>  We will create an application with a single Label on the screen, which will display a random joke about Chuck Norris, downloaded via the <a href="http://api.icndb.com/jokes/random">api.icndb.com/jokes/random</a> site <a href="http://api.icndb.com/jokes/random">API</a> at the time the application is launched. <br><br><img src="https://habrastorage.org/files/956/953/66e/95695366e2a6452b89b8d1a9d6d23cfe.png"><br>  <i>Fig.1 Our application showing a joke about Chuck Norris.</i> <br><a name="habracut"></a><br><h4>  Retrieving data using NSURLSession </h4><br><h5>  Theory on HTTP request </h5><br>  Recall, for example, how HTTP communication occurs.  Let us type in the browser URL: <code><a href="http://google.com/%3Fq%3DHello%26safe%3Doff"></a> google.com/?q=Hello&amp;safe=off</code>  <code><a href="http://google.com/%3Fq%3DHello%26safe%3Doff"></a> google.com/?q=Hello&amp;safe=off</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It can be divided into the following components: <br><br><ul><li>  http - a protocol that tells the browser to follow the HTTP standard when prompted </li><li>  : // separates the protocol from the domain </li><li>  google.com - the domain from which we receive data </li><li>  / - request path that determines the location of the resource we are defining </li><li>  ?  used to separate the path from the parameter </li><li>  q = Hello &amp; safe = off - parameters.  Each parameter consists of a key-value pair.  The key q has the value Hello, the key safe has the value off </li></ul><br>  With an HTTP request, we always specify a method.  The method determines what the server needs to do with the information we sent. <br><br>  In short, the browser connects to google.com and makes a GET request corresponding to the HTTP protocol to the root directory /, passing q = Hello &amp; safe = off as the parameter. <br><br>  When the browser parses the URL, the HTTP request will be presented like this: <br><br><pre> <code class="xml hljs">GET /?q=Hello&amp;safe=off HTTP/1.1 Host: google.com Content-Length: 133 (‚Ä¶)</code> </pre><br>  The request consists of ASCII lines of text.  In the first line of the GET method, followed by the path with parameters, then the HTTP version.  Then follows a header containing details such as the requested host and the length of the request.  The heading is separated from the body by two blank lines.  For GET the body is empty. <br><br>  Figure 2 shows the query diagram.  First, a request is created, then a connection to the remote server is established, and the request is sent in plain text.  Depending on the size of the request and the quality of the network, the request may take seconds, hours and even days. <br><br><img src="https://habrastorage.org/files/816/0c0/f52/8160c0f5207e4cc89a98c2013dc6a4a4.png"><br>  <i>Fig.2. The steps in the HTTP request: (a) normal HTTP interaction and (b) equivalents for each step from the point of view of the Objective-C implementation.</i> <br><br><h5>  We create the software interface of our application </h5><br>  We create Empty Application in Xcode and in it the following files: <br><br>  THSAppDelegate.h <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @class THSViewController; @interface THSAppDelegate : UIResponder </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIApplicationDelegate&gt;</span></span></span><span class="hljs-meta"> @property (strong, nonatomic) UIWindow *window; @property (strong, nonatomic) THSViewController *viewController; @end</span></span></code> </pre><br>  THSAppDelegate.m <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSAppDelegate.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController.h"</span></span></span><span class="hljs-meta"> @implementation THSAppDelegate - (BOOL) application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; self.viewController = [[THSViewController alloc] initWithNibName:nil bundle:nil]; self.window.rootViewController = self.viewController; self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible]; return YES; } @end</span></span></code> </pre><br>  THSViewController.h <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @interface THSViewController : UIViewController @property (nonatomic, strong) UILabel *jokeLabel; @end</span></span></code> </pre><br>  THSViewController.m <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController+Interface.h"</span></span></span><span class="hljs-meta"> @implementation THSViewController - (void)viewDidLoad { [super viewDidLoad]; [self addLabel]; } @end</span></span></code> </pre><br>  THSViewController + Interface.h <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController.h"</span></span></span><span class="hljs-meta"> @interface THSViewController (Interface) - (void)addLabel; @end</span></span></code> </pre><br>  THSViewController + Interface.m <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController+Interface.h"</span></span></span><span class="hljs-meta"> @implementation THSViewController (Interface) - (void)addLabel { CGFloat width = self.view.frame.size.width - 40.0f; CGFloat y = self.view.frame.size.height / 2.0f - 200.0f; CGRect labelFrame = CGRectMake(20.0f, y, width, 200.0f); self.jokeLabel = [[UILabel alloc] initWithFrame:labelFrame]; self.jokeLabel.text = @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Quotation goes here and continues and continues until I am fed up to type."</span></span></span><span class="hljs-meta">; self.jokeLabel.lineBreakMode = NSLineBreakByWordWrapping; self.jokeLabel.textAlignment = NSTextAlignmentCenter; self.jokeLabel.numberOfLines = 0; self.jokeLabel.font = [UIFont systemFontOfSize:16.0f]; [self.view addSubview:self.jokeLabel]; } @end</span></span></code> </pre><br>  Creating an interface is rendered into a category so as not to mix the main functionality of the chapter with the label code and further buttons. <br><br>  Run the application and see the interface: <br><br><img src="https://habrastorage.org/files/034/92d/f34/03492df34ba34c11bf00ed236a678829.png"><br>  <i>Fig.3 Starting interface of the application.</i> <br><br><h5>  Create Cocoa THSHTTPCommunication class </h5><br>  All UI operations are performed in the main thread.  If you block the main thread, then all events will be blocked by touch, drawing graphics, animation, sounds, eventually the application will hang.  Therefore, you cannot simply interrupt the application to wait for a request.  To solve this problem, there are two techniques: create a new execution thread to control two simultaneous operations or configure an instance of the class as a delegate and implement the methods defined in the delegate protocol. <br><br>  Most methods in Cocoa were originally designed as a delegate pattern to make time-consuming operations asynchronous.  This means that the main thread will continue until the operation is completed, after which a certain method will be called. <br><br>  With iOS 5, Objective-C supports blocks. <br><br>  <i>We will use the delegates in this example for a deeper understanding of networking.</i>  <i>But remember that in iOS7 there is syntactic sugar, which uses blocks to simplify the execution of HTTP requests.</i> <br><br>  Create a class THSHTTPCommunication. <br><br>  THSHTTPCommunication.h: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface THSHTTPCommunication : NSObject @end</span></span></code> </pre><br>  THSHTTPCommunication.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSHTTPCommunication.h"</span></span></span><span class="hljs-meta"> @interface THSHTTPCommunication () @property(nonatomic, copy) void(^successBlock)(NSData *); @end @implementation THSHTTPCommunication @end</span></span></code> </pre><br>  where successBlock contains a block that will be called when the request is completed. <br><br><h5>  We implement HTTP interaction </h5><br>  Next, create a method in THSHTTPCommunication.m, responsible for HTTP communication.  This method pulls jokes from a public API called icndb and returns information asynchronously using blocks. <br><br>  THSHTTPCommunication.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THSHTTPCommunication</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">retrieveURL</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURL</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">successBlock</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">(^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSData</span></span></span><span class="hljs-class"> *))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">successBlock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   successBlock    self.successBlock = successBlock; //  ,   url NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url]; //  ,           NSURLSessionConfiguration *conf = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:conf delegate:self delegateQueue:nil]; //   NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request]; //  HTTP  [task resume]; } @end</span></span></code> </pre><br>  This method takes two parameters: the URL from which we get the content (in our case, the icndb API URL for receiving random jokes) and the block that will be called immediately after the request is completed.  First you need to save this block to call later when the request is completed.  The next step is to create an NSURLRequst object for this URL and use this request to establish an HTTP connection.  [task resume] will not block execution.  In this method, the compiler will show a warning, because we have not yet reported that the THSHTTPCommunication class complies with the NSURLSessionDownloadDelegate protocol.  We will deal with this further. <br><br><h5>  Session delegate </h5><br>  We implement the NSURLSessionDownloadDelegate protocol to catch some of the messages, such as when we receive a new request. <br><br>  First let us inform the compiler that THSHTTPCommunication is subject to this protocol. <br><br>  THSHTTPCommunication.h: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THSHTTPCommunication</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURLSessionDownloadDelegate</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  <i>The NSURLSessionDownloadDelegate</i> protocol defines a set of methods that an instance of the NSURLConnection class can perform during an HTTP connection.  We use <i>URLSession: downloadTask: didFinishDownloadingToURL:</i> <br><br>  There are two more methods that we may need for more complex cases, like tracking the download process and the ability to resume a request.  The names speak for themselves: <br><br>  <i>URLSession: downloadTask: didResumeAtOffset: expectedTotalBytes:</i> <i><br></i>  <i>URLSession: downloadTask: didWriteData: totalBytesWritten: totalBytesExpectedToWrite:</i> <br><br>  But that's not all.  In addition, the NSURLSession API provides three protocols: <br><br>  <i>NSURLSessionDelegate</i> ‚Äî This protocol defines delegate methods for handling session-level events as session or credential invalidation. <br>  <i>NSURLSessionTaskDelegate</i> ‚Äî This protocol defines delegate methods for handling connection events as redirects, errors, and data transfer. <br>  <i>NSURLSessionDataDelegate</i> ‚Äî This protocol defines delegate methods for handling data-level task-specific events and load tasks. <br><br><h5>  We receive the data from the answer </h5><br>  Now we are implementing a method that will allow us to receive data from a response in THSHTTPCommunication.m.  NSURLSession will call this method as soon as the data becomes available and the download is complete. <br><br>  THSHTTPCommunication.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THSHTTPCommunication</span></span></span><span class="hljs-class"> ‚Ä¶ - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLSession</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURLSession</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">session</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">downloadTask</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURLSessionDownloadTask</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">downloadTask</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">didFinishDownloadingToURL</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURL</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       NSData *data = [NSData dataWithContentsOfURL:location]; // ,   successBlock     dispatch_async(dispatch_get_main_queue(), ^{ //       self.successBlock(data); }); } @end</span></span></code> </pre><br>  This code is the last step in the interaction.  We get a complete response and immediately call the block that we saved earlier.  First we get the locally stored data that we received from the server.  Note that the repository is represented by an instance of the NSURL class, but this time the URL is the path to the file containing the response data, not the remote URL. <br><br>  We need to be sure that the call to the successBlock callback comes from the main thread.  This is common practice, because most likely the method that implements the class does a specific task-specific task flow, such as the UI action. <br><br>  In some cases, when we receive information from a remote server, the request may pass through several servers before reaching the destination.  Fig.4 We are trying to get a picture located on <code><a href="http://t.co/"></a> t.co</code>  <code><a href="http://t.co/"></a> t.co</code> , but the first answer is a redirect to the server containing the image.  We need only the last answer (the picture itself). <br><br><img src="https://habrastorage.org/files/871/5f6/a33/8715f6a3319246b58095786a31cd970d.png"><br>  <i>Fig.4 Receiving pictures by abbreviated Twitter url generates a redirect.</i> <br><br>  Despite the fact that we can control redirects by implementing NSURLSessionTaskDelegate, we can allow NSURLSession to cope with all the details, which is the default behavior. <br><br>  Make the newly created retrieveURL: successBlock: method available for the main controller.  Open THSHTTPCommunication.h and add the method declaration: <br><br>  THSHTTPCommunication.h: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THSHTTPCommunication</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURLSessionDownloadDelegate</span></span></span><span class="hljs-class">&gt; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">retrieveURL</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURL</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">successBlock</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">(^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSData</span></span></span><span class="hljs-class"> *))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">successBlock</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br><h4>  Understanding data serialization and interaction with third-party services </h4><br>  We created an application and wrote logic to get data from a remote server.  Now we‚Äôll get random jokes about Chuck Norris using the API provided by icndb.com.  This API, like all services that provide interaction with third-party services, have a normalized way of formatting information.  Therefore, it is necessary to transform this format into something simple to use and manipulate.  In other words, you need a way to convert formatted data into Objective-C objects. <br><br><h5>  Serialization </h5><br>  Figure 5 illustrates how the serialization process works.  We see the sender (icndb server) on the left and the recipient (client) on the right.  First a joke is generated, icndb saves it as binary data (it can be saved as a database, memory, file system or any other kind of storage).  When a request comes from an application, the joke information is serialized and sent to us (the recipient).  The application parses information and converts the data into native Objective-C objects. <br><br><img src="https://habrastorage.org/files/b01/afd/90a/b01afd90a73e4bedb49fd19107e998a1.png"><br>  <i>Fig.5. Architecture of serialization and deserialization of messages.</i> <br><br>  There are different ways to share information, but we will focus on the most widely used serialization format: JavaScript Object Notation (JSON).  JSON is the standard way of representing various types of data structures in text form.  JSON defines a small set of rules for representing strings, numbers, and booleans.  Along with XML, this is one of the most used serialization methods today.  Let's look at an example of JSON in action: <br><br><pre> <code class="xml hljs">{ "name": "Martin Conte Mac Donell", "age": 29, "username": "fz" }</code> </pre><br>  This code represents a dictionary enclosed in {} and consisting of key / value pairs.  Keys can not be repeated.  In our example, name, age and username are keys, Martin Conte Mac Donell, 29 and fz are values. <br><br><h5>  Code for jokes </h5><br>  Now we know that the JSON format is defined and how the serialization process works, back to the application.  We implement the code to get jokes.  In THSViewController.m, we add the jokeID internal variable to an unnamed category and the retrieveRandomJokes method. <br><br>  THSViewController.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSViewController+Interface.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"THSHTTPCommunication.h"</span></span></span><span class="hljs-meta"> @interface THSViewController () { NSNumber *jokeID; } @end @implementation THSViewController ... - (void)retrieveRandomJokes { THSHTTPCommunication *http = [[THSHTTPCommunication alloc] init]; NSURL *url = [NSURL URLWithString:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http://api.icndb.com/jokes/random"</span></span></span><span class="hljs-meta">]; //  ,    THSHTTPCommunication [http retrieveURL:url successBlock:^(NSData *response) { NSError *error = nil; //    NSDictionary *data = [NSJSONSerialization JSONObjectWithData:response options:0 error:&amp;error]; if (!error) { NSDictionary *value = data[@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"value"</span></span></span><span class="hljs-meta">]; if (value &amp;&amp; value[@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"joke"</span></span></span><span class="hljs-meta">]) { jokeID = value[@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"id"</span></span></span><span class="hljs-meta">]; [self.jokeLabel setText:value[@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"joke"</span></span></span><span class="hljs-meta">]]; } } }]; } @end</span></span></code> </pre><br>  We define the retrieveRandomJokes method and see how serialization comes from a code perspective.  In this method, we use the previously created THSHTTPCommunication class to get data from icndb.com.  Therefore, we immediately create an instance of the THSHTTPCommunication class and then call retrieveURL: successBlock :, responsible for receiving the data.  As soon as THSHTTPCommunication receives a response from icndb.com, it calls the code inside the block passed as a parameter.  At this point we have available data ready for analysis. <br><br>  When information is received, it needs to be understood.  You need a way to convert the newly loaded text into something you can easily manipulate.  You need to select a joke and id from the answer.  The process of converting serialized data (JSON) into data structures is called deserialization.  Fortunately, starting with iOS 5, the Cocoa framework includes a class for parsing JSON.  This is the NSJSONSerialization class, and parsing the response data is the first thing we do in a block. <br><br>  The response from the icndb API is an associative array, represented with JSON as <br><br><pre> <code class="xml hljs">{ "type": "success", "value": { "id": 201, "joke": "Chuck Norris was what Willis was talkin' about" } }</code> </pre><br>  We see that the answer is an associative array and the key ‚Äúvalue‚Äù contains another associative array.  Once NSJSONSerialization has completed deserialization, the associative JSON array will be converted to Objective-C NSDictionaries, arrays to NSArray, numbers to NSNumber, and strings to NSString.  After that we get an object that can be used in the application. <br><br>  Returning to retrieveRandomJokes: after deserialization, we assign an associative array from the key ‚Äúvalue‚Äù of the deserialized response to the NSDictionary dictionary.  Finally, we make the resulting jokes text with text labels in our interface. <br><br>  It remains to call the retrieveRandomJokes: method when the view was loaded. <br><br>  THSViewController.m: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addLabel]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> retrieveRandomJokes]; }</code> </pre><br>  That's all, now run the application and see a new joke every time you start. </div><p>Source: <a href="https://habr.com/ru/post/270049/">https://habr.com/ru/post/270049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270033/index.html">Dagaz: Halfway</a></li>
<li><a href="../270039/index.html">Creating Gesture Recognition Web Applications with the Intel RealSense SDK</a></li>
<li><a href="../270041/index.html">Run iOS applications from the console on the device and simulator</a></li>
<li><a href="../270045/index.html">Office as Platform: publish the SharePoint application in the Office Store</a></li>
<li><a href="../270047/index.html">Idea for handling errors in Go</a></li>
<li><a href="../270051/index.html">We work with Xamarin: development experience on two projects</a></li>
<li><a href="../270053/index.html">Do not cos from development on Cach√©</a></li>
<li><a href="../270055/index.html">Another methodology: Stakhanov</a></li>
<li><a href="../270057/index.html">Technical interviews: tips</a></li>
<li><a href="../270059/index.html">Highload to Java: what you need to remember</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>