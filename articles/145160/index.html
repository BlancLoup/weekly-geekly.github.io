<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating GTK + / gtkmm applications using the Glade environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is in addition to the article ‚ÄúCreating Applications on GTK + Using the Glade Environment‚Äù . When I started to read it, and came across word...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating GTK + / gtkmm applications using the Glade environment</h1><div class="post__text post__text-html js-mediator-article">  This post is in addition to the article <a href="http://habrahabr.ru/post/107403/">‚ÄúCreating Applications on GTK + Using the Glade Environment‚Äù</a> .  When I started to read it, and came across words that the example would be in C ++, I was delighted in advance, because at that time I was looking for examples of the Glade bundle with gtkmm, the C ++ wrapper for GTK +.  What was my disappointment when it turned out that the author for some incomprehensible to me code in C, using the GTK + API, put the file in ".cpp" and called it an example in C ++.  As a result, I decided to independently transform the sample example from that article in C ++.  The result is submitted to the readers. <br><a name="habracut"></a><br>  It is assumed that the reader is familiar with the basic concepts of the GTK + library.  Also in this article I will not repeat, therefore before reading I recommend to get acquainted with the content of the original article. <br><br><h4>  Component installation </h4><br>  To use C ++, we need the gtkmm library, which is a wrapper for the GTK + library.  When installed, it will pull the dependencies itself, which we also need, for example, the cairomm library, which, by analogy, is C ++ wrapper for the cairo library (2D graphics rendering).  For a debian-based distribution, install with the command: <br><pre><code class="bash hljs">sudo apt-get install libgtkmm-2.4-dev</code> </pre> <br>  The version number may be different for your distribution. <br><br><h4>  Source </h4><br>  Below is the complete source code of the program, which in terms of functionality fully corresponds to the original example, but is written in C ++.  Next, I will explain some parts of the code separately. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtkmm.h&gt; #include &lt;cairomm/cairomm.h&gt; /** Main window class. */ class MainWindow: public Gtk::Window { private: /** Subclass for drawing area. */ class CDrawingArea: public Gtk::DrawingArea { public: typedef enum { SHAPE_RECTANGLE, SHAPE_ELLIPSE, SHAPE_TRIANGLE } shape_t; private: shape_t _curShape = SHAPE_RECTANGLE; /** Drawing event handler. */ virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr) { switch (_curShape) { case SHAPE_RECTANGLE: cr-&gt;rectangle(20, 20, 200, 100); cr-&gt;set_source_rgb(0, 0.8, 0); cr-&gt;fill_preserve(); break; case SHAPE_ELLIPSE: cr-&gt;arc(150, 100, 90, 0, 2 * 3.14); cr-&gt;set_source_rgb(0.8, 0, 0); cr-&gt;fill_preserve(); break; case SHAPE_TRIANGLE: cr-&gt;move_to(40, 40); cr-&gt;line_to(200, 40); cr-&gt;line_to(120, 160); cr-&gt;line_to(40, 40); cr-&gt;set_source_rgb(0.8, 0, 0.8); cr-&gt;fill_preserve(); cr-&gt;set_line_cap(Cairo::LINE_CAP_ROUND); cr-&gt;set_line_join(Cairo::LINE_JOIN_ROUND); break; } cr-&gt;set_line_width(3); cr-&gt;set_source_rgb(0, 0, 0); cr-&gt;stroke(); return true; } public: CDrawingArea(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder): Gtk::DrawingArea(cobject) { } void SetShape(shape_t shape) { if (_curShape != shape) { _curShape = shape; /* Request re-drawing. */ queue_draw(); } } }; Glib::RefPtr&lt;Gtk::Builder&gt; _builder; Gtk::RadioButton *_rbRect, *_rbEllipse, *_rbTriangle; CDrawingArea *_drawingArea; public: /** Signal handler which is called when any radio button is clicked. */ void OnRadiobuttonClick() { if (_rbRect-&gt;get_active()) { _drawingArea-&gt;SetShape(CDrawingArea::SHAPE_RECTANGLE); } else if (_rbEllipse-&gt;get_active()) { _drawingArea-&gt;SetShape(CDrawingArea::SHAPE_ELLIPSE); } else if (_rbTriangle-&gt;get_active()) { _drawingArea-&gt;SetShape(CDrawingArea::SHAPE_TRIANGLE); } } /** "quit" action handler. */ void OnQuit() { hide(); } MainWindow(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder): Gtk::Window(cobject), _builder(builder) { /* Retrieve all widgets. */ _builder-&gt;get_widget("rbRectangle", _rbRect); _builder-&gt;get_widget("rbEllipse", _rbEllipse); _builder-&gt;get_widget("rbTriangle", _rbTriangle); _builder-&gt;get_widget_derived("drawing_area", _drawingArea); /* Connect signals. */ _rbRect-&gt;signal_clicked().connect(sigc::mem_fun(*this, &amp;MainWindow::OnRadiobuttonClick)); _rbEllipse-&gt;signal_clicked().connect(sigc::mem_fun(*this, &amp;MainWindow::OnRadiobuttonClick)); _rbTriangle-&gt;signal_clicked().connect(sigc::mem_fun(*this, &amp;MainWindow::OnRadiobuttonClick)); /* Actions. */ Glib::RefPtr&lt;Gtk::Action&gt;::cast_dynamic(_builder-&gt;get_object("action_quit"))-&gt; signal_activate().connect(sigc::mem_fun(*this, &amp;MainWindow::OnQuit)); } }; int main(int argc, char **argv) { Gtk::Main app(argc, argv); Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file("sample.glade"); MainWindow *mainWindow = 0; builder-&gt;get_widget_derived("main_wnd", mainWindow); app.run(*mainWindow); delete mainWindow; return 0; }</span></span></span></span></code> </pre><br><br>  Everything begins with the initialization of the library by creating an object of the class ‚ÄúGtk :: Main‚Äù.  Next, a builder object is created, which is initialized with a file describing the graphical interface obtained by the Glade editor (see the original example). <br><pre> <code class="cpp hljs">Gtk::<span class="hljs-function"><span class="hljs-function">Main </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span>; Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(<span class="hljs-string"><span class="hljs-string">"sample.glade"</span></span>);</code> </pre><br>  Note the use of the ‚ÄúGlib :: RefPtr‚Äù class.  This is the implementation of smart pointers in the glibmm library - C ++ wrappers around the low-level glib library.  The pointer that is assigned to this object will be automatically released when the object is destroyed. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainWindow</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Gtk::Window</code> </pre><br>  For the presentation of the main window in our application, we will use our class, which inherits from the standard window class in gtkmm - ‚ÄúGtk :: Window‚Äù.  This technique is called subclassing and, in particular, is one of the ways to capture events for a widget, which will be shown below. <br><br><pre> <code class="cpp hljs">MainWindow *mainWindow = <span class="hljs-number"><span class="hljs-number">0</span></span>; builder-&gt;get_widget_derived(<span class="hljs-string"><span class="hljs-string">"main_wnd"</span></span>, mainWindow);</code> </pre><br><br>  Here we create an object for the main window according to its description in the builder.  To get an object using subclassing, the get_widget_derived method is called.  If a standard class is used (in this case it could be ‚ÄúGtk :: Window‚Äù), then the builder‚Äôs get_widget method should be used. <br><br><pre> <code class="cpp hljs">app.run(*mainWindow); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mainWindow;</code> </pre><br>  The "run" method takes as its argument a window object with which it will work, and returns control only after it is hidden.  Note that in order to avoid memory leaks, the window object must be deleted.  This requirement applies only to top-level widgets, and does not apply to nested widgets (for example, to all widgets inside our main window, which will be obtained below by the same method, but will not be explicitly deleted). <br><br>  We now turn to the class of the main window.  The designer of all widgets always has one prototype: <br><pre> <code class="cpp hljs">MainWindow(BaseObjectType* cobject, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder): Gtk::Window(cobject), _builder(builder)</code> </pre><br>  The first argument is a pointer to the original GTK + object - the type ‚ÄúBaseObjectType‚Äù is always defined this way for all gtkmm classes (in this case, it will be GtkWindow).  It must be passed to the base class constructor.  The second argument is the builder object, which, in particular, can be used to get objects for nested widgets in the manner described above, which is done below: <br><pre> <code class="cpp hljs">_builder-&gt;get_widget(<span class="hljs-string"><span class="hljs-string">"rbRectangle"</span></span>, _rbRect); _builder-&gt;get_widget(<span class="hljs-string"><span class="hljs-string">"rbEllipse"</span></span>, _rbEllipse); _builder-&gt;get_widget(<span class="hljs-string"><span class="hljs-string">"rbTriangle"</span></span>, _rbTriangle); _builder-&gt;get_widget_derived(<span class="hljs-string"><span class="hljs-string">"drawing_area"</span></span>, _drawingArea);</code> </pre><br><br>  Next, the signals for the click event on the radiobuttons are connected to the OnRadiobuttonClick method of our class: <br><pre> <code class="cpp hljs">_rbRect-&gt;signal_clicked().connect(sigc::mem_fun(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::OnRadiobuttonClick)); _rbEllipse-&gt;signal_clicked().connect(sigc::mem_fun(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::OnRadiobuttonClick)); _rbTriangle-&gt;signal_clicked().connect(sigc::mem_fun(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::OnRadiobuttonClick));</code> </pre><br>  Note the use of the sigc :: mem_fun method from the sigc ++ library, which is the main framework for switching signals in gtkmm.  This method returns a functor for a class method.  If you need to use a function that is not a member of the class, you can use the "sigc :: ptr_fun" method.  The described method of binding signals to handlers is the only one for widgets for which subclassing is not used, as in our case with radiobuttons. <br><br>  The following three-storey construction binds the activation signal of the exit action from the program to the OnQuit method of our class: <br><pre> <code class="cpp hljs">Glib::RefPtr&lt;Gtk::Action&gt;::cast_dynamic(_builder-&gt;get_object(<span class="hljs-string"><span class="hljs-string">"action_quit"</span></span>))-&gt; signal_activate().connect(sigc::mem_fun(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::OnQuit));</code> </pre><br>  In this case, in Glade, you need to make sure that the action ‚Äúaction_quit‚Äù is created, to which the ‚ÄúQuit‚Äù element in the main menu should refer.  In the original article, the moment with the actions was omitted, so I will comment on it.  Actions in GTK + are called, in fact, actions that can be performed on events from different sources - menu items, toolbar buttons, hotkeys.  The action object also describes common attributes for its external presentation (for example, in the menu and toolbar) - a label, an icon, and a tooltip text.  The action in gtkmm corresponds to the class ‚ÄúGtk :: Action‚Äù.  To get it from the builder, you should use the get_object method, which returns an object of the base class Glib :: Object, so you also have to use the cast_dynamic method of the Glib :: RefPtr class for explicit type conversion.  The ‚ÄúOnQuit‚Äù method itself is extremely simple: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnQuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hide(); }</code> </pre><br>  As mentioned above, to exit the ‚Äúrun‚Äù method in the ‚Äúmain‚Äù function, it is enough to hide the window passed to it as an argument, which is done in the body of this method. <br><br>  The next interesting point is a subclass for the ‚ÄúGtk :: DrawingArea‚Äù class that implements drawing of figures in the corresponding widget.  Of the new features, we have an on_draw method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)</span></span></span></span></code> </pre><br>  It is an example of another way of intercepting signals to events, which is applicable only to widgets that use subclassing.  Its essence lies in the fact that in each class of widgets in gtkmm virtual methods are defined for each signal supported by the widget, which are called when the corresponding signal is received.  A subclass can override the desired virtual method, thus intercepting the processing of the desired signal, which is done in this example. <br><br>  Specifically, the data handles the event of redrawing the contents of the widget.  As an argument, the cairomm library rendering context is passed to it, the work with which is completely analogous to the original example. <br><br>  This post ends.  Most of the information on the use of the mentioned libraries is taken from the self-documented source code of the libraries themselves. </div><p>Source: <a href="https://habr.com/ru/post/145160/">https://habr.com/ru/post/145160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145153/index.html">[How-To] Sync multiple calendars to Google, Thunderbird and WP7</a></li>
<li><a href="../145155/index.html">Carmageddon for iOS and Android</a></li>
<li><a href="../145156/index.html">How to create effective mobile solutions for enterprises</a></li>
<li><a href="../145158/index.html">Groovy integration into JEE application</a></li>
<li><a href="../145159/index.html">Eco-friendly and energy-efficient printing technologies KYOCERA</a></li>
<li><a href="../145163/index.html">Replacing the WiFi module on the Lenovo B450. Fix error 104-Unsupported wireless network device detected</a></li>
<li><a href="../145164/index.html">Asymmetric multiplayer, or whether democracy is needed in games</a></li>
<li><a href="../145165/index.html">Making a non-actinic LED light source</a></li>
<li><a href="../145167/index.html">Will we ever ... pass the Turing test for computers?</a></li>
<li><a href="../145168/index.html">1935 Brunsviga Nova Adding Instrument - Overview and Demonstration of a Mechanical Calculator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>