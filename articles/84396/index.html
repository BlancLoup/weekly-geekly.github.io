<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pixel Bender. Language specification in the context of programming with Flash Player</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a free translation of the official Pixel Bender language documentation from Adobe. I want to immediately note that this translation is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pixel Bender. Language specification in the context of programming with Flash Player</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/geektimes/post_images/5ea/6fe/23d/5ea6fe23d89506be9376430e5ef30cc1.jpg" alt="Pixel bender" align="right">  This article is a free translation of the <a href="http://www.adobe.com/devnet/pixelbender/pdfs/pixelbender_reference.pdf">official</a> Pixel Bender language <a href="http://www.adobe.com/devnet/pixelbender/pdfs/pixelbender_reference.pdf">documentation</a> from Adobe.  I want to immediately note that this translation is exactly the Pixel Bender Language Reference, and not the Pixel Bender Developer's Guide.  As Google suggests, this topic has not yet emerged on the RuNet, and therefore I would like to correct such an annoying omission)) The translation has deliberately omitted programming questions for Adobe Photoshop and Adobe AfterEffects, since  I was only interested in writing filters for Flash Player. <br><a name="habracut"></a><br>  Pixel Bender is a high-performance graphic programming technology for image processing. <br>  Pixel Bender kernel is a C-like language with image processing extensions.  It is based on GLSL, which, in turn, is based on C. The basics of the language syntax should be familiar to any C programmer. <br>  The main unit of image processing in Pixel Bender is the kernel ( <i>kernel</i> ). ( <b>Note:</b> I do not know how to translate this word more precisely, so I trusted Google;)).  Each program on the Pixel Bender defines one core.  The kernel is an object that contains the result of processing a single pixel by a function with an arbitrary number of arguments that can be obtained from one or more source images. <br><ul><li>  A Pixel Bender program determines a named kernel object by specifying the <i>evaluatePixel ()</i> function that is performed on each pixel of the original image.  Each kernel must contain a definition of this function. </li><li>  The kernel can take any number of arguments of arbitrary types.  It can define within itself parameters and variables that will be used to perform various operations.  Pixel Bender is a staotyped language. </li><li>  Pixel Bender contains many built-in functions for working with pixels. </li></ul><br><br><h4>  Using filters written in Pixel Bender </h4><br><br>  Adobe provides Pixel Bender Toolkit IDE - an integrated development environment for writing programs in the Pixel Bender language.  Working with Pixel Bender Toolkit IDE is described in Pixel Bender Developer's Guide ( <b>Note. Trans.:</b> IDE free. You can get the Windows version <a href="http://www.adobe.com/go/pixelbender_toolkit_zip">from here</a> ). <br>  During development, you can run programs in Pixel Bender Toolkit IDE, which provides a convenient interface for this.  For information on the Pixel Bender Toolkit IDE, see the Pixel Bender Developer's Guide. <br>  To run filters in Flash Player, you must save your files with the .pbj extension. <br>  The client application can, in its own way, organize access to the parameters for starting and operating the filter: <br><ul><li>  The client application typically uses the <i>name</i> attribute specified in the kernel to access this filter. </li><li>  You can specify a string describing the operation of the filter that the client application will use as a hint. </li><li>  When defining a parameter, you need to specify metadata (for example, minimum, maximum values, and default values) that help the developer select and customize the appropriate user interface elements. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Preprocessor directives </h4><br><br>  The following preprocessor directives are available for use (similar to the C preprocessor directives): <br><br>  #if <br>  #ifdef <br>  #defined <br>  #endif <br>  #elif <br>  #define <br><br>  Since Flash Player works on a wide range of equipment, only part of the Pixel Bender language is available for use in Flash Player.  The following is a list of restrictions that Flash Player imposes on using the Pixel Bender language: <br><br><ul><li>  Flash Player always works with a 1x1 pixel object.  The <i>pixelSize ()</i> function always returns (1.0, 1.0), and <i>pixelAspectRatio ()</i> always returns 1.0. </li><li>  The conditional operator (? :) can only be used to choose between two constants or variables. </li><li>  Images in Pixel Bender have 32 bits per channel, but the graphics in Flash Player 10 have only 8 bits per channel.  When the filter is running in Adobe Flash Player, the original image data is first converted to 32 bits per channel, and then converted to 8 bits per channel when the filter completes execution. </li><li>  To change the progress of the program, you can use only if and else statements. </li><li>  The following is a list of unsupported language features: <br><ol><li>  Functions for working with regions. </li><li>  User functions and libraries. </li><li>  Dependent values </li><li>  Arrays </li><li>  Graph description language ( <b>Note:</b> in the original - The Pixel Bender graph language). </li></ol><br></li></ul><br><br><h4>  Kernel syntax </h4><br><br>  In each program written on Pixel Bender, there is one code block containing a set of metadata enclosed in angle brackets, and another code block describing the core, the set of variables, and the operations performed, enclosed in braces. <br><br> <code>&lt;languageVersion : 1.0;&gt; <br> kernel name <br> &lt; <br> kernel metadata pairs <br> &gt; <br> { <br> kernel members <br> } <br></code> <br><br>  Each kernel must begin with the version of the language in which the code is written. <br>  The first part of the kernel defines a metadata block consisting of a group of name-value pairs enclosed in angle brackets: <br><br> <code>&lt; <br> name1 : value1; <br> name2 : value2; <br> ... <br> &gt;; <br></code> <br><br>  The following metadata values ‚Äã‚Äãare predefined: <br><br>  <i>namespace</i> - Required.  The namespace in which the kernel is defined. <br>  <i>vendor</i> - Required.  Publisher. <br>  <i>version</i> - Required.  Integer, version number of the implementation of this kernel.  This is not the same as languageVersion (!). <br>  <i>description</i> - Optional.  Description of the filter. <br><br>  For example: <br><br> <code>&lt; <br> namespace : "Pixel Bender IDE"; <br> vendor : "Adobe"; <br> version : 1; <br> description: "A sample filter"; <br> &gt; <br></code> <br><br>  The second part of the kernel definition is a set of variables and functions enclosed in braces.  The kernel must contain at least the definition of the <i>evaluatePixel ()</i> function, and everything else is optional. <br><br> <code>{ <br> [declarations] <br> [support functions] <br> void evaluatePixel() <br> { <br> statements <br> } <br> } <br></code> <br><br>  Variable declarations usually contain a pixel declaration of the input and output image.  Parameters and constants that will be used in functions can also be included. <br>  The main function, <i>evaluatePixel ()</i> , is used to enter images or images on which the conversion is performed, the result of which is one pixel. <br>  Before the definition of the <i>evaluatePixel ()</i> function can be (optionally) described: <br><br><ol><li>  <b>Options:</b> <br><br> <code>parameter type name <br> &lt; <br> name1 : value1; <br> name2 : value2; <br> ... <br> &gt; <br></code> <br><br>  Parameters are set to read only, within the kernel function.  Parameters can be of any (available for use within the Flash Player) type, except for images. <br></li><li>  <b>Constants:</b> <br><br> <code>const type name=compile-time_expression;</code> <br> <br>  The values ‚Äã‚Äãof the constants are determined at compile time. <br></li><li>  <b>input:</b> <br><br> <code>input type name;</code> <br> <br>  The image used as an argument to the <i>evaluatePixel ()</i> function.  Its type must be image1, image2, image3, or image4. <br></li><li>  <b>output:</b> <br><br> <code>output type name;</code> <br> <br>  A set of pixels resulting from the function <i>evaluatePixel ()</i> .  Its type must be pixel1, pixel2, pixel3, or pixel4. <br><br></li></ol><br><br><h4>  Metadata Settings </h4><br><br>  Parameters may include data that describe this parameter or impose restrictions on its use.  This data will be available within client applications after compilation, and will also help the programmer decide how to design a user interface that allows users to set the value of a parameter. <br>  Data values ‚Äã‚Äãare enclosed in angle brackets following the parameter declaration. <br><br> <code>parameter type name <br> &lt; <br> name1 : value1; <br> name2 : value2; <br> ... <br> &gt; <br></code> <br><br>  Names are strings.  Values ‚Äã‚Äãare constants of any valid Pixel Bender type.  For int, float and bool types, the type definition is automatic.  For other types, it is not necessary to define a constant value of a valid type (for example: float2 (1.0, -1.0)) or a string delimited by double quotes.  For example: <br><br> <code>parameter int angle <br> &lt; <br> minValue : 0; <br> maxValue : 360; <br> defaultValue : 30; <br> description : "measured in degrees"; <br> &gt;; <br></code> <br><br>  This parameter imposes restrictions on possible values: <br><br>  <i>minValue</i> - the minimum value allowed <br>  <i>maxValue</i> - the maximum allowed value <br>  <i>defaultValue</i> is the default <br>  <i>description</i> - a description of the parameter that can be used as a hint in the client application. <br><br><h4>  Kernel function definition </h4><br><br>  The kernel function definition must meet these conditions: <br><br>  Everything except <i>evaluatePixel ()</i> is optional. <br><br>  Function syntax: <br><br> <code>void evaluatePixel() <br> { <br> statements <br> } <br></code> <br><br><h4>  Types of data language Pixel Bender </h4><br><br>  Pixel Bender is a strongly typed language.  There are no automatic type conversions, with one exception: between floating-point vector data types and matrix data types.  There are several types of data, each of which is defined within a specific set of operators and eigenfunctions. <br><br>  Pixel Bender supports the following basic data types: <br><br>  bool - a logical data type <br>  int is an integer <br>  float is a floating point number <br>  pixel1 - determines the value of one image channel.  The number ‚Äú1‚Äù distinguishes this type of data from similar ones, but determining the values ‚Äã‚Äãof several image channels.  A time type of this type is represented by a floating point number and occupies 32 bits of memory. <br><br>  All of these data types can participate in numeric operations. <br><br><h4>  Conversions between scalar data types </h4><br><br>  The bool, int, and float data types can be converted from one to another using the usual rules in the C-style: <br><br>  <i>type (expression)</i> <br><br>  For example: <br><br> <code>int a = int(myfloat)</code> <br> <br>  The pixel1 data type can be interchangeable with the float data type. <br><br>  <b>Note:</b> <br><br>  The int data type occupies 16 bits of memory (without a sign), but its implementation can take more than 16 bits of memory.  You can perform conversions between int and float types.  When the conversion result from the int type to the float type cannot be represented as the int type, the value of the variable becomes undefined. <br><br><h4>  Vector data types </h4><br><br>  Pixel Bender supports 2, 3, and 4-element counterparts for each scalar data type: <br><br>  float2 bool2 int2 pixel2 <br>  float3 bool3 int3 pixel3 <br>  float4 bool4 int4 pixel4 <br><br>  Initialization of any type (including pixel) is represented by a general form: <br><br>  <i>vectorType (element1 [, element2 ...])</i> <br><br>  For example: <br><br> <code>float3(0.5, 0.6, 0.7)</code> <br> <br>  There is also an abbreviated version of the record (the following expressions are equivalent): <br><br> <code>float3(0.3); <br> float3(0.3, 0.3, 0.3); <br></code> <br><br>  You can access the value of a vector variable by index or name by the following rules: <br><br><ol><li>  Using the index operator, as an array element: <br><br>  vectorValue [index] <br><br></li><li>  Using dot notation to access elements in this sequence: <br><br>  r, g, b, a <br>  x, y, z, w <br>  s, t, p, q <br><br>  Each of these elements corresponds to an index from 0 to 3. <br></li></ol><br><br>  For example, to get the value of the first element of the vector myVectorValue, you can use any of the following record options: <br><br>  myVectorValue [0] <br>  myVectorValue.r <br>  myVectorValue.x <br>  myVectorValue.s <br><br><h4>  Select and override element values </h4><br><br>  Pixel Bender supports swizzling to select and redefine the order of the elements of a vector.  For a vector with an n-number of elements, the values ‚Äã‚Äãcan be followed by the point operator.  The corresponding values ‚Äã‚Äãof the elements of the vector form a new result with as many elements as the assigned variable.  This syntax can be used to change the order, to delete or repeat elements of the vector.  For example: <br><br> <code>float4 vec4; <br> float3 no_alpha = vec4.rgb; //     vec4 <br> float3 no_r = vec4.gba; //     vec4 <br> float4 reversed = vec4.abgr; //     <br> float4 all_red = vec4.rrrr; //    <br> float4 all_x = vec4.xxxx; //   <br></code> <br><br>  Pointers from individual sequences cannot be combined: <br><br> <code>float4 vec4; <br> float3 no_alpha = vec4.rgz; // ! <br></code> <br><br>  Index pointers can also be used on the left side of an assignment expression.  In this case, the indexes can not be repeated.  This feature is used to write masking ( <b>Appro. Ln .:</b> in the original - write masking).  The right side of the assignment expression must have the correct number of arguments: <br><br>  float3 vec3; <br>  float2 vec2; <br>  vec3.xy = vec2;  // sets the values ‚Äã‚Äãof vec2 vector elements to vec3 vector elements with indices 0 and 1 <br>  vec3.xz = vec2;  // sets the values ‚Äã‚Äãof vec2 vector elements to vec3 vector elements with indices 0 and 2 <br><br>  Interaction: <br><br>  Swizzling and masking can be used simultaneously on both sides of an assignment expression: <br><br> <code>vec3.xz = vec4.wy;</code> <br> <br>  There is the likelihood of complications between swizzling and assignment operations.  Consider the following example: <br><br> <code>g.yz *= g.yy;</code> <br> <br>  A simplified version of this record can be represented as follows: <br><br> <code>gy *= gy; <br> gz *= gy; <br></code> <br><br>  The problem is that the gy value in the second line has been changed.  The correct solution would be the following entry: <br><br> <code>float2 temp = g.yz * g.yy; <br> g.yz = temp; <br></code> <br><br><h4>  Conversions between vector data types </h4><br><br>  Conversions between vector data types are permissible, provided that the sizes of the assignment operands are equal.  The conversion itself is similar to the conversion between scalar data types: <br><br>  type (expression) <br><br>  For example: <br><br> <code>float3 fvec3; <br> int3 ivec3; <br> fvec3 = float3(ivec3); <br></code> <br><br><h4>  Matrix Types </h4><br><br>  There are the following types of matrices: <br><br>  float2x2 <br>  float3x3 <br>  float4x4 <br><br>  Creating matrices using a constructor implies using float vectors to specify the values ‚Äã‚Äãof matrices, or specifying the values ‚Äã‚Äãof scalar variables of type float for each element of the matrix in the order column-row or a mixture of vectors and scalar variables of type float: <br><br>  float2x2 (float2, float2) <br><br>  float2x2 (float, float, <br>  float <br><br>  float3x3 (float3, float3, float3) <br><br>  float3x3 (float, float, float, <br>  float, float, float, <br>  float, float, float) <br><br>  float4x4 (float4, float4, float4, float4) <br><br>  float4x4 (float, float, float, float, <br>  float, float, float, <br>  float, float, float, <br>  float, float, float, float) <br><br>  You can also initialize the matrix with one scalar variable of type float, which will determine the values ‚Äã‚Äãof the matrix elements on the main diagonal.  All other values ‚Äã‚Äãwill be set to zero: <br><br>  float2x2 (float) <br>  float3x3 (float) <br>  float4x4 (float) <br><br>  To access the values ‚Äã‚Äãof matrix elements, use the following syntax: <br><br>  <i>matrix [column] [row]</i> <br><br>  If you omit the indication of the series, then the whole column is selected and the vector variable of the appropriate dimension is returned: <br><br>  <i>matrix [column]</i> <br><br><h4>  Other data types </h4><br><br>  <b>Types of image data.</b> <br><br>  Pixel Bender also supports image variables.  They are represented by the following data types: <br><br>  image1 <br>  image2 <br>  image3 <br>  image4 <br><br>  Variables of these types cannot be created or used in expressions.  However, they can be passed as arguments to the built-in functions of the language. <br><br>  <b>The data type is void.</b> <br><br>  Functions that do not return values ‚Äã‚Äãmust be defined with the void type. <br><br><h4>  Operators </h4><br><br>  Pixel Bender defines the following types of operators for arithmetic operations on scalar data types.  Here they are listed in order of priority.  The brackets can be used to change this order: <br><br>  .  Variable element selection <br>  ++ - Postfix increment and decrement operators <br>  ++ - Prefix increment and decrement operators <br>  -!  Unary negation operator, logical "NOT" <br>  * / Multiplication, division <br>  + - Addition, subtraction <br>  &lt;&gt; &lt;=&gt; = Comparisons <br>  ==! = Equality <br>  &amp;&amp; Logical "And" <br>  ^^ Logical "EXCLUSIVE OR" <br>  ||  Logical "OR" <br>  = + = - = * = / = Operator grouping <br>  ?: A brief record of branch operators.  This operator can only be used to select between two variables or constants (on the right side), but not expressions. <br><br><h4>  Operations on data types with several elements </h4><br><br>  Standard arithmetic operators (+, -, *, /) can be used for operations on scalar and vector and matrix data types.  A binary operator can be applied to two vector operands only if they have the same size.  In this case, the operation is performed for each element of the vector.  For example: <br><br>  float3 x, y, z; <br>  z = x + y; <br><br>  This entry is equivalent to the following: <br><br>  z [0] = x [0] + y [0]; <br>  z [1] = x [1] + y [1]; <br>  z [2] = x [2] + y [2]; <br><br>  The grouping of scalar and vector pairs is also admissible.  For example: <br><br>  float3 x, y; <br>  float w; <br>  x = y * w; <br><br>  This entry is equivalent to the following: <br><br>  x [0] = y [0] * w; <br>  x [1] = y [1] * w; <br>  x [2] = y [2] * w; <br><br>  An important exception to this rule is the multiplication of matrices between themselves and matrices with vector variables.  Multiplication is carried out according to the rules of a linear algerb (and not componentwise): <br><br>  float2x2 * float2x2 Multiply matrices according to the rules of linear algebra <br>  float3x3 * float3x3 <br>  float4x4 * float4x4 <br><br>  float2x2 * float2 Column multiplication by vector <br>  float3x3 * float3 <br>  float4x4 * float4 <br><br>  float2 * float2x2 Multiply rows by vector <br>  float3 * float3x3 <br>  float4 * float4x4 <br><br><h4>  Built-in language features Pixel Bender </h4><br><br>  <b>Mathematical functions:</b> <br><br>  Like arithmetic operators, mathematical functions can be performed on vector data types.  In this case, they work component by component.  Unless otherwise specified, all angles are in radians. <br><br>  float radians (float degrees) Converting degrees to radians <br>  float2 radians (float2 degrees) <br>  float3 radians (float3 degrees) <br>  float4 radians (float4 degrees) <br><br>  float degrees (float radians) Convert radians to degrees <br>  float2 degrees (float2 radians) <br>  float3 degrees (float3 radians) <br>  float4 degrees (float4 radians) <br><br>  float sin (float radians) Returns the sine of the argument <br>  float2 sin (float2 radians) <br>  float3 sin (float3 radians) <br>  float4 sin (float4 radians) <br><br>  float cos (float radians) Returns the cosine of the argument <br>  float2 cos (float2 radians) <br>  float3 cos (float3 radians) <br>  float4 cos (float4 radians) <br><br>  float tan (float radians) Returns the tangent of the argument.  If x == pi / 2.0 returns <i>undefined</i> <br>  float2 tan (float2 radians) <br>  float3 tan (float3 radians) <br>  float4 tan (float4 radians) <br><br>  float asin (float x) Returns the arcsine of the argument.  The return value is in the range [-pi / 2..pi / 2] <br>  float2 asin (float2 x) <br>  float3 asin (float3 x) <br>  float4 asin (float4 x) <br><br>  float acos (float x) Returns the arc cosine of the argument.  The return value is in the range [0..pi] <br>  float2 acos (float2 x) <br>  float3 acos (float3 x) <br>  float4 acos (float4 x) <br><br>  float atan (float y_over_x) Returns the arctangent of the argument.  The return value is in the range [-pi / 2..pi / 2] <br>  float2 atan (float2 y_over_x) <br>  float3 atan (float3 y_over_x) <br>  float4 atan (float4 y_over_x) <br><br>  float atan (float y, float x) Returns the arctangent of the expression y / x.  The return value is in the range [-pi..pi] <br>  float2 atan (float2 y, float2 x) <br>  float3 atan (float3 y, float3 x) <br>  float4 atan (float4 y, float4 x) <br><br>  float pow (float x, float y) Returns x to the power of y and <i>undefined</i> if x &lt;0 <br>  float2 pow (float2 x, float2 y) <br>  float3 pow (float3 x, float3 y) <br>  float4 pow (float4 x, float4 y) <br><br>  float exp (float x) Returns e to the power x ( <b>Approx. ln .:</b> I don‚Äôt remember what this value is called :)) <br>  float2 exp (float2 x) <br>  float3 exp (float3 x) <br>  float4 exp (float4 x) <br><br>  float exp2 (float x) Returns 2 to the power x <br>  float2 exp2 (float2 x) <br>  float3 exp2 (float3 x) <br>  float4 exp2 (float4 x) <br><br>  float log (float x) Returns the natural logarithm of x <br>  float2 log (float2 x) <br>  float3 log (float3 x) <br>  float4 log (float4 x) <br><br>  float log2 (float x) Returns the natural logarithm of x with base 2 <br>  float2 log2 (float2 x) <br>  float3 log2 (float3 x) <br>  float4 log2 (float4 x) <br><br>  float sqrt (float x) Returns the positive square root of x and <i>undefined</i> if x &lt;0 <br>  float2 sqrt (float2 x) <br>  float3 sqrt (float3 x) <br>  float4 sqrt (float4 x) <br><br>  float inverseSqrt (float x) Returns the inverse of the positive square root of x and <i>undefined</i> if x &lt;0 <br>  float2 inverseSqrt (float2 x) <br>  float3 inverseSqrt (float3 x) <br>  float4 inverseSqrt (float4 x) <br><br>  float abs (float x) If x&gt; = 0, returns x, otherwise returns -x <br>  float2 abs (float2 x) <br>  float3 abs (float3 x) <br>  float4 abs (float4 x) <br><br>  float sign (float x) If x &lt;0, returns -1 <br>  float2 sign (float2 x) If x == 0, returns 0 <br>  float3 sign (float3 x) If x&gt; 0, returns 1 <br>  float4 sign (float4 x) <br><br>  float floor (float x) Rounds x down (returns an integer) <br>  float2 floor (float2 x) <br>  float3 floor (float3 x) <br>  float4 floor (float4 x) <br><br>  float ceil (float x) Rounds x up (returns an integer) <br>  float2 ceil (float2 x) <br>  float3 ceil (float3 x) <br>  float4 ceil (float4 x) <br><br>  float fract (float x) Returns x - floor (x) <br>  float2 fract (float2 x) <br>  float3 fract (float3 x) <br>  float4 fract (float4 x) <br><br>  float mod (float x, float y) Returns x - y * floor (x / y) <br>  float2 mod (float2 x, float2 y) <br>  float3 mod (float3 x, float3 y) <br>  float4 mod (float4 x, float4 y) <br><br>  float min (float x, float y) If x &lt;y returns x, otherwise returns y <br>  float2 min (float2 x, float2 y) <br>  float3 min (float3 x, float3 y) <br>  float4 min (float4 x, float4 y) <br><br>  float max (float x, float y) If x&gt; y, returns x, otherwise returns y <br>  float2 max (float2 x, float2 y) <br>  float3 max (float3 x, float3 y) <br>  float4 max (float4 x, float4 y) <br><br>  float step (float x, float y) If y &lt;x, returns 0.0, otherwise returns 1.0 <br>  float2 step (float2 x, float2 y) <br>  float3 step (float3 x, float3 y) <br>  float4 step (float4 x, float4 y) <br><br>  float clamp (float x, float minval, float maxval) If x &lt;minval, returns minval.  If x&gt; maxval, returns maxval.  Otherwise, it returns x. <br>  float2 clamp (float2 x, float2 minval, float2 maxval) <br>  float3 clamp (float3 x, float3 minval, float3 maxval) <br>  float4 clamp (float4 x, float4 minval, float4 maxval) <br><br>  float mix (float x, float y, float a) Returns x * (1.0 - a) + y * a (this is a linear interpolation between x and y). <br>  float2 mix (float2 x, float2 y, float2 a) <br>  float3 mix (float3 x, float3 y, float3 a) <br>  float4 mix (float4 x, float4 y, float4 a) <br><br>  float smoothStep (float edge0, float edge1, float x) If x &lt;= edge0, returns 0. If x&gt; = edge1, returns 1, otherwise smoothed interpolation is performed ( <b>Note:</b> original: smooth hermite interpolation). <br>  float2 smoothStep (float2 edge0, float2 edge1, float2 x) <br>  float3 smoothStep (float3 edge0, float3 edge1, float3 x) <br>  float4 smoothStep (float4 edge0, float4 edge1, float4 x) <br><br>  <b>Geometric functions:</b> <br><br>  These functions work with vectors as with an integer object, and do not consider each element of the vector as separate. <br><br>  float length (float x) Returns the length of the vector x <br>  float length (float2 x) <br>  float length (float3 x) <br>  float length (float4 x) <br><br>  float distance (float x, float y) Returns the distance between x and y <br>  float distance (float2 x, float2 y) <br>  float distance (float3 x, float3 y) <br>  float distance (float4 x, float4 y) <br><br>  float dot (float x, float y) Returns the scalar product x and y <br>  float dot (float2 x, float2 y) <br>  float dot (float3 x, float3 y) <br>  float dot (float4 x, float4 y) <br><br>  float3 cross (vector3 x, vector3 y) Returns the vector product x by y <br><br>  float normalize (float x) Returns a vector with the same direction as x, but with a length of 1 and <i>undefined</i> if length (x) == 0 <br>  float2 normalize (float2 x) <br>  float3 normalize (float3 x) <br>  float4 normalize (float4 x) <br><br>  These functions are performed by component multiplication (in contrast to the operator *, which performs algebraic multiplication of matrices): <br><br>  float2x2 matrixCompMult (float2x2 x, float2x2 y) Returns the component-wise multiplication x by y <br>  float3x3 matrixCompMult (float3x3 x, float3x3 y) <br>  float4x4 matrixCompMult (float4x4 x, float4x4 y) <br><br>  These functions compare vectors by component and return a boolean value of the same dimension (observing the order of comparison): <br><br>  bool2 lessThan (int2 x, int2 y) Returns componentwise comparison x &lt;y <br>  bool3 lessThan (int3 x, int3 y) <br>  bool4 lessThan (int4 x, int4 y) <br>  bool2 lessThan (float2 x, float2 y) <br>  bool3 lessThan (float3 x, float3 y) <br>  bool4 lessThan (float4 x, float4 y) <br><br>  bool2 lessThanEqual (int2 x, int2 y) Returns componentwise comparison x &lt;= y <br>  bool3 lessThanEqual (int3 x, int3 y) <br>  bool4 lessThanEqual (int4 x, int4 y) <br>  bool2 lessThanEqual (float2 x, float2 y) <br>  bool3 lessThanEqual (float3 x, float3 y) <br>  bool4 lessThanEqual (float4 x, float4 y) <br><br>  bool2 greaterThan (int2 x, int2 y) Returns the componentwise comparison x&gt; y <br>  bool3 greaterThan (int3 x, int3 y) <br>  bool4 greaterThan (int4 x, int4 y) <br>  bool2 greaterThan (float2 x, float2 y) <br>  bool3 greaterThan (float3 x, float3 y) <br>  bool4 greaterThan (float4 x, float4 y) <br><br>  bool2 greaterThanEqual (int2 x, int2 y) Returns componentwise comparison x&gt; = y <br>  bool3 greaterThanEqual (int3 x, int3 y) <br>  bool4 greaterThanEqual (int4 x, int4 y) <br>  bool2 greaterThanEqual (float2 x, float2 y) <br>  bool3 greaterThanEqual (float3 x, float3 y) <br>  bool4 greaterThanEqual (float4 x, float4 y) <br><br>  bool2 equal (int2 x, int2 y) Returns the componentwise comparison x == y <br>  bool3 equal (int3 x, int3 y) <br>  bool4 equal (int4 x, int4 y) <br>  bool2 equal (float2 x, float2 y) <br>  bool3 equal (float3 x, float3 y) <br>  bool4 equal (float4 x, float4 y) <br>  bool2 equal (bool2 x, bool2 y) <br>  bool3 equal (bool3 x, bool3 y) <br>  bool4 equal (bool4 x, bool4 y) <br><br>  bool2 notEqual (int2 x, int2 y) Returns the componentwise comparison x! = y <br>  bool3 notEqual (int3 x, int3 y) <br>  bool4 notEqual (int4 x, int4 y) <br>  bool2 notEqual (float2 x, float2 y) <br>  bool3 notEqual (float3 x, float3 y) <br>  bool4 notEqual (float4 x, float4 y) <br>  bool2 notEqual (bool2 x, bool2 y) <br>  bool3 notEqual (bool3 x, bool3 y) <br>  bool4 notEqual (bool4 x, bool4 y) <br><br>  These functions work only with logical type vectors: <br><br>  bool any (bool2 x) Returns true if at least one x is true <br>  bool any (bool3 x) <br>  bool any (bool4 x) <br><br>  bool all (bool2 x) Returns true if all x elements are true <br>  bool all (bool3 x) <br>  bool all (bool4 x) <br><br>  bool2 not (bool2 x) Returns the result of elementwise logical negation <br>  bool3 not (bool3 x) <br>  bool4 not (bool4 x) <br><br>  <b>PS:</b> This is my first post on Habr√©.  Please do not kick much;) </div><p>Source: <a href="https://habr.com/ru/post/84396/">https://habr.com/ru/post/84396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../84384/index.html">FriendFeed for bright minds</a></li>
<li><a href="../84385/index.html">SE Xperia ‚Ñ¢ X10 mini & SE Xperia ‚Ñ¢ X10 mini pro</a></li>
<li><a href="../84387/index.html">"My business" - preparation of documents for registration of SP</a></li>
<li><a href="../84388/index.html">My first Google Chrome extension</a></li>
<li><a href="../84389/index.html">The sun is simple. Part Two: Radio Emission Mechanisms</a></li>
<li><a href="../84405/index.html">Java Certification - SCJP and SCBCD Passage</a></li>
<li><a href="../84407/index.html">Supercomputer technologies in science, education and industry</a></li>
<li><a href="../84408/index.html">Integration Experience: Dressed.com</a></li>
<li><a href="../84411/index.html">Skype release for Symbian phones</a></li>
<li><a href="../84415/index.html">The mirror phrasebook for the parrot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>