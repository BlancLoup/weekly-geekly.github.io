<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance checks and gradual degradation of distributed systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As always, thanks to Fred Hebert and Sargun Dhillon for reading the draft of this article and offering some invaluable advice. 


 In her report on sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Performance checks and gradual degradation of distributed systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/nv/bv/x0/nvbvx0meh2jzpwpvwzgvtpni1jk.png"><br><p>  <i>As always, thanks to <a href="https://twitter.com/mononcqc%3Flang%3Den">Fred Hebert</a> and <a href="https://twitter.com/sargun">Sargun Dhillon</a> for reading the draft of this article and offering some invaluable advice.</i> </p><br><p>  In her <a href="https://www.oreilly.com/library/view/velocity-conference-/9781492026051/video320766.html">report on speed,</a> <a href="https://twitter.com/tamarbercovici%3Flang%3Den">Tamar Berkovichi</a> from Box stressed the importance of performance checks during automatic failover of databases.  In particular, she noted that monitoring the runtime of end-to-end queries, as a method for determining the performance of a database, is better than simple echo testing (pinging). </p><br><blockquote>  ... transferring traffic to another node (replica), in order to eliminate inaction, it is necessary to build defenses against bounce and other border situations.  It is not difficult.  The trick when organizing effective work is to know <strong>when</strong> to transfer the database to the first position, i.e.  one must be able to correctly assess the performance of the database.  Now, many of the parameters we are accustomed to pay attention to ‚Äî for example, processor load, lock timeout, error rate ‚Äî are secondary signals.  None of these parameters actually speaks of the database‚Äôs ability to handle client traffic.  Therefore, if you use them to make a decision about switching, you can get both false positive and false negative results.  Our health checker actually performs simple queries to database nodes and uses data about completed and failed requests to more accurately assess the health of the database. </blockquote><p>  I discussed this with a friend, and he suggested that health checks should be as simple as possible, and that real traffic is the best criterion for assessing the health of a process. </p><a name="habracut"></a><br><p>  Often, discussions related to the implementation of a performance check revolve around two opposing options: simple connection / signal checks or complex end-to-end tests.  In this article, I want to emphasize the problem of using the above-mentioned form of testing for certain types of load balancing solutions, as well as the need for a more detailed approach to assessing the efficiency of the process. </p><br><h3 id="dva-tipa-proverok-rabotosposobnosti">  Two types of health checks </h3><br><p>  Performance checks, even in many modern systems, tend to fall into two categories: checks at the node level and at the service level. </p><br><p> For example, Kubernetes implements validation by analyzing <em>readiness</em> and <em>survivability</em> .  Readiness check is used to determine the ability to serve traffic.  If the readiness check is not performed, it is removed from the endpoints that make up the <a href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a> , and because of this, in the link, until the check is completed, no traffic is routed.  On the other hand, the survivability test is used to determine the <em>response of a</em> service to a hang or lock.  If it is not executed, the individual container is restarted to the <a href="https://kubernetes.io/docs/admin/kubelet/">kubelet</a> .  Similarly, <a href="https://www.consul.io/docs/agent/checks.html">Consul</a> allows several forms of checks ( <code>checks</code> ): based on <code>script</code> , checks based on HTTP, sent to a specific URL, checks based on TTL, or even checks for aliases. </p><br><p>  The most common method for implementing <em>service</em> -level health checks is to define end-point health checks.  For example, in gRPC, the health check itself becomes an RPC call.  gRPC also allows service level health checks and general <em>gRPC server health checks</em> . </p><br><p>  In the past, node-level health checks were used as a signal to trigger an alert.  For example, an alert with an average processor load (currently, it is considered to be a design anti-pattern).  Even if the health check is not used directly for alerting, it still serves as the basis for a number of other automated infrastructure decisions, such as load balancing and (sometimes) open circuit.  In the service grid data schemes, for example, Envoy, <em>health checks</em> , when it comes to determining the routing of traffic to an instance, go ahead with service discovery data. </p><br><h3 id="rabotosposobnost--eto-spektr-a-ne-binarnaya-taksonomiya">  Performance is a spectrum, not a binary taxonomy. </h3><br><p>  Ping, or ping, can only establish whether the service is <em>running</em> , while end-to-end tests are proxies to determine if the system is able to perform a specific <em>unit of work</em> , where the unit of work can be a <em>database query</em> or a <em>specific calculation</em> .  Regardless of the form of the health check, its <em>result is</em> considered as purely binary: ‚Äúpassed‚Äù or ‚Äúnot passed‚Äù. </p><br><p>  In today's dynamic and often ‚Äúautomatically scalable‚Äù infrastructure options, a single process that simply ‚Äúworks‚Äù does not matter if it cannot complete a specific unit of work.  It turns out that simplified checks, for example, echo testing, are almost useless. </p><br><p>  It is easy to determine when a service is completely <em>disabled</em> , but it is much more difficult to establish the degree of <em>efficiency of a</em> running service.  It is quite possible that the process is working (that is, a functional test passes), and traffic is routed, but to perform a certain unit of work, say, during the service delay period p99, this is not enough. </p><br><p>  Often the work can not be completed due to the fact that the process is overloaded.  In highly competitive services, ‚Äúoverload‚Äù is neatly compared to the number of concurrent requests processed by only one process with redundant queuing, which can lead to an increase in the delay for an RPC call (although most often the lower-level service simply puts the request on standby and retries on after a specified timeout).  This is especially true if the endpoint of the health check is configured to automatically return to the HTTP status code 200, while the actual operation performed by the service involves network I / O or calculation. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/420/7bf/d6b/4207bfd6ba6f7c4afd6892c8f643112d.png" alt="image"></p><br><p>  Process efficiency is a spectrum.  First of all, we are interested in the <em>quality of service</em> , for example, the time required for the process to restore the result of a specific unit of work, and the accuracy of the result. </p><br><p>  It is possible that the process fluctuates between different degrees of <em>working capacity</em> during its service life: from full <em>working capacity</em> (for example, the ability to function at the expected level of parallelism) to the verge of inoperability (when the queues begin to fill) and the point where the process goes completely into an unworkable zone (felt reduced quality of service).  Only the most trivial services can be built on the assumption of the absence of some degree of partial failure in any period, where partial failure implies that some functions work and others are disabled, and not just "some requests are being executed, some are not being executed."  If the architecture of the service does not allow correcting a partial failure correctly, the task of correcting errors is automatically placed on the <em>client</em> . </p><br><p>  An adaptive, self-healing infrastructure must be built with the understanding of the fact that such fluctuations are perfectly <em>normal</em> .  It is also important to remember that this distinction matters only in relation to load balancing - the orchestra, for example, does not make sense to restart the process only because it is on the verge of overload. </p><br><p>  In other words, for the level of orchestration, it is quite reasonable to consider the operation of the process as a binary state and restart the process only after a crash or hang.  But in the <em>load balancing</em> layer (whether it is an external proxy, for example, Envoy, or an internal library from the client), it is extremely important that it acts on the basis of more detailed information about the process performance - when it makes appropriate decisions about breaking the circuit and dropping the load.  Gradual degradation of the service is impossible if it is impossible to accurately determine the level of service health at any point in time. </p><br><p>  I will say from experience: unlimited parallelism is often the main factor leading to the degradation of the service or permanent performance degradation.  Load balancing (and, as a result, load shedding) often comes down to efficiently managing parallelism and applying backpressure, preventing the system from being overloaded. </p><br><h3 id="neobhodimost-obratnoy-svyazi-pri-primenenii-protivodavleniya">  The need for feedback when applying backpressure </h3><br><p>  <a href="https://twitter.com/mranney">Matt Ranney</a> wrote a <a href="http://engineering.voxer.com/2013/09/16/backpressure-in-nodejs/">phenomenal article</a> about unlimited parallelism and the need for back pressure in Node.js.  The article is curious in its entirety, but the main conclusion (at least for me) was the need for feedback between the process and its output unit (usually a load balancer, but sometimes another service). </p><br><blockquote>  The trick is that when resources are exhausted, something must be given somewhere.  Demand is growing, but productivity cannot magically increase.  To limit incoming tasks, first of all, it would be nice to set a certain speed limit at the site level, by IP address, user, session, or, at best, by some important element for the application.  Many load balancers may limit the speed in a more complicated way than restricting an incoming Node.js server, but usually do not notice problems until the process is in a difficult position. </blockquote><p>  Speed ‚Äã‚Äãlimits and open circuits based on <a href="https://www.infoq.com/articles/envoy-service-mesh-cascading-failure">static thresholds and limits can be unreliable and unstable</a> in terms of both correctness and scalability.  Some load balancers (in particular, HAProxy) provide a variety of statistics on the length of internal queues for <em>each server</em> and <em>server part</em> .  In addition, HAProxy allows <code>agent-check</code> testing (auxiliary validation independent of the regular health check), which allows the process to provide the proxy server with more accurate and dynamic health feedback.  <a href="https://cbonte.github.io/haproxy-dconv/1.7/configuration.html">Link to documents</a> : </p><br><blockquote>  The agent‚Äôs health check is performed by a TCP connection to the port based on the <code>agent-port</code> parameter set and reading the ASCII string.  A string consists of a series of words, separated by spaces, tabs or commas in any order, optionally ending with <code>/r</code> and / or <code>/n</code> and including the following elements: <br><br>  - Representation of positive integer percentage ASCII, for example, <code>75%</code> .  The values ‚Äã‚Äãin this format determine the weight in proportion to the initial <br>  the weight of the server configured when HAProxy starts.  Please note that the zero weight value is indicated on the statistics page as <code>DRAIN</code> from the moment of similar impact on the server (it is removed from the LB farm). <br><br>  - The <code>maxconn</code> string <code>maxconn</code> : followed by an integer (no space).  Values ‚Äã‚Äãin <br>  This format defines the <code>maxconn</code> server <code>maxconn</code> .  Maximum number <br>  The claimed connections must be multiplied by the number of load balancers and the various server parts using this health check to get the total number of connections that the server can establish.  For example: <code>maxconn:30</code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - The word <code>ready</code> .  This translates the administrative state of the server into <br>  <code>READY</code> mode, canceling the <code>DRAIN</code> or <code>MAINT</code> . <br><br>  - The word <code>drain</code> .  This translates the administrative state of the server into <br>  <code>DRAIN</code> mode (‚Äúdrain‚Äù), after which the server will not accept new connections, except for connections that are received through the database. <br><br>  - The word <code>maint</code> .  This translates the administrative state of the server into <br>  <code>MAINT</code> mode (‚Äúmaintenance‚Äù), after which the server will not accept any new connections, and the health checks will stop. <br><br>  - The words <code>down</code> , <code>failed</code> or <code>stopped</code> , followed by a descriptive line after the pound (#) character.  They all indicate the operational state of the <code>DOWN</code> server (‚Äúoff‚Äù), but since the word itself is displayed on the statistics page, the difference allows the administrator to determine if the situation was expected: the service can be intentionally stopped, it may appear, but not pass some confirmation tests or considered as disabled (no process, no response from the port). <br><br>  - The word up indicates the operational status of the <code>UP</code> server (‚Äúon‚Äù), if the health checks also confirm the availability of the service. <br><br>  Parameters that are not declared by the agent are not changed.  For example, an agent can only be designed to monitor processor usage and report only a relative weight value, without interacting with the operating state.  Similarly, an agent program can be designed as an end-user interface with 3 switches, allowing the administrator to change only the administrative state. <br><br>  <strong>However, it is necessary to take into account that only the agent can cancel its own actions, therefore, if the server is set to DRAIN mode or to the DOWN state using an agent, then the agent must perform other equivalent actions to restart the service.</strong> <br><br>  Failed connection with the agent is not considered as an error, because the connectivity is tested by regularly performing a health check, which is run using the check parameter.  However, if a disconnection message has been received, a warning is not a good idea to stop the agent, since only the agent reporting the activation can re-enable the server. </blockquote><p>  Such a scheme of dynamic communication service with the output unit is extremely important for creating a self-adaptable infrastructure.  An example would be the architecture that I worked with in my previous work. </p><br><p>  I used to work at <a href="https://www.imgix.com/">imgix</a> , a real-time start-up image processing company.  Using a simple URL API, images are extracted and converted in real time and then used anywhere in the world via CDN.  Our stack was quite complex ( <a href="https://stackshare.io/imgix/how-imgix-built-a-stack-to-serve-100000-images-per-second">as described above</a> ), but briefly, our infrastructure included a level of balancing and load balancing (in tandem with a level to get data from a source), a source caching level, an image processing level and a content delivery level. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f58/98a/d1e/f5898ad1e33db764d7551e29d0a7e5dc.png" alt="image"></p><br><p>  At the heart of the load balancing level was the Spillway service, which acted as a reverse proxy and query broker.  It was a purely internal service;  on the verge we were running nginx and HAProxy and Spillway, so it was not designed to complete TLS or perform any other functions from the innumerable set that is usually within the competence of the border proxy. </p><br><p>  Spillway consisted of two components: the client part (Spillway FE) and the broker.  Although initially both components were in the same binary file, at some point we decided to separate them into separate binaries that were deployed simultaneously on the same host.  Mainly, because these two components had different performance profiles, and the client part was almost completely connected to the processor.  The client-side task was to perform preprocessing of each request, including a preliminary check at the source caching level, to make sure that the image is cached in our data center before sending the request for image conversion to the executor. </p><br><p>  At any point in time, we had a fixed pool (a dozen or so, if memory serves) performers who could be connected to one Spillway broker.  Artists were responsible for the actual image conversion (cropping, resizing, PDF processing, GIF rendering, etc.).  They processed everything from PDF files of hundreds of pages and GIF files with hundreds of frames to simple image files.  Another feature of the artist was that, although all the networks were completely asynchronous, there were no actual conversions on the GPU itself.  Considering that we were working in real time, it was impossible to predict what our traffic would look like at a certain point in time.  Our infrastructure had to self-adapt to various forms of incoming traffic - without manual intervention by the operator. </p><br><p>  Given the disparate and disparate traffic patterns that we often encountered, it became necessary for executors to refuse to accept incoming requests (even when fully operational) if accepting a connection threatened to overload the executor.  Each request to the executor contained some set of metadata about the nature of the request, which allowed the executor to determine whether he was able to service this request.  Each performer had his own set of statistics on the requests with which he currently worked.  The employee used these statistics in conjunction with the query metadata and other heuristics, such as socket buffer size data, to determine if he had correctly received the incoming query.  If the employee determined that he could not accept the request, he created a response that is not different from checking the HAProxy agent, which informs his output unit (Spillway) about its operation. </p><br><p>  Spillway tracked the performance of all pool artists.  At first, I tried to send a request three times in succession to various performers (preference was given to those who had the original image in local databases and who were not overloaded), and if all three executors refused to accept the request, the request was queued at a broker inside the memory.  The broker supported three forms of queues: a LIFO queue, a FIFO queue, and a priority queue.  If all three queues were filled, the broker simply rejected the request, allowing the client (HAProxy) to try again after the delay period.  When a request was placed in one of three queues, any free agent could remove it from there and process it.  There are certain difficulties associated with assigning a priority to a request and deciding which of the three queues (LIFO, FIFO, queues based on priority) should be placed, but this is a topic for a separate article. </p><br><p>  We did not need to discuss this form of dynamic feedback in order to work effectively.  We closely monitored the broker queue size (all three queues), and Prometheus gave one of the key alerts when the queue size exceeded a certain threshold (which was quite rare). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f83/768/88c/f8376888c479f9dbcbadbee1c3e9539e.png" alt="image"></p><br><p>  <a href="https://speakerdeck.com/copyconstructor/prometheus-at-google-nyc-tech-talks-nov-2016%3Fslide%3D39">Image from my presentation on the Prometheus monitoring system at the Google NYC conference in November 2016</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a19/7b7/57c/a197b757cbe5660023612137e3c780d4.png" alt="image"></p><br><p>  <a href="https://speakerdeck.com/copyconstructor/prometheus-a-whirlwind-tour">The warning comes from my presentation on the Prometheus monitoring system at the OSCON conference in May 2017</a> </p><br><p>  Earlier this year, Uber published an interesting article in which he shed light on his approach to implementing a level of load shedding based on quality of service. </p><br><blockquote>  Analyzing the failures over the past six months, we found that 28% of them could be mitigated or prevented by <a href="https://en.wikipedia.org/wiki/Fault_tolerance">smooth degradation</a> . <br><br>  The three most common types of failures were due to the following factors: <br><br>  - Changes to the incoming request schema, including overload and bad operator nodes. <br>  - Depletion of resources such as a processor, memory, I / O circuit or network resources. <br>  - Dependency crashes, including infrastructure, data storage, and downstream services. <br><br>  We implemented an overload detector based on the <a href="https://en.wikipedia.org/wiki/CoDel">CoDel</a> algorithm.  For each enabled endpoint, a lightweight request buffer is added (implemented on the basis of the gateway and <a href="https://www.sohamkamani.com/blog/2017/08/24/golang-channels-explained/">channels</a> ) in order to track the delays between the moment the request is received from the call source and the start of the request processing in the handler.         ,   ,      . </blockquote><p>   ,  ,         ,  -      .   2013  Google     <a href="https://www.dropbox.com/s/vd3divhvrkjqdv7/longtail.pdf%3Fdl%3D0">¬´The Tail at Scale¬ª</a> ,               (   ),        (   )    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8ff/2b5/379/8ff2b5379239a40c0b193f483a85fa86.jpg" alt="image"></p><br><p>             ,           .    <a href="https://twitter.com/copyconstruct/status/1022671271631314944">      </a> ,         . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fd/068/1fb/6fd0681fb86c70cff833ae170f53ce5c.png" alt="image"></p><br><p> (       ) </p><br><p> ,              ,       : </p><br><ol><li> <a href="https://www.infoq.com/presentations/little-usl-scalability-performance">  </a> , <a href="https://twitter.com/kavya719"> </a> , QCon London 2018. </li><li> <a href="https://www.youtube.com/watch%3Fv%3Dyf6wSsOFqdI">   :    -</a> , <a href="https://twitter.com/_emfree_"> </a> ,  LISA 2017. </li><li> <a href="https://www.youtube.com/watch%3Fv%3Dm64SWl9bfvk">   ‚Äì   </a> , <a href="https://twitter.com/jon_moore"> </a> , Strangeloop 2017. </li><li> <a href="https://www.youtube.com/watch%3Fv%3D6NdxUY1La2I">  : ,    </a> , <a href="https://twitter.com/stevegury"> </a> , Strangeloop 2017. </li><li>   <a href="https://landing.google.com/sre/sre-book/chapters/handling-overload/">  </a>  <a href="https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/">  </a>   <a href="https://landing.google.com/sre/books/">¬´   ¬ª</a> . </li></ol><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>           ,  TCP/IP ( <a href="https://en.wikipedia.org/wiki/TCP_congestion_control">  </a>    ), IP <a href="https://en.wikipedia.org/wiki/Explicit_Congestion_Notification">ECN</a> ( IP     )  Ethernet,    ,  <a href="https://en.wikipedia.org/wiki/Ethernet_flow_control"> </a> . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Large-scale health checks may suffice for orchestration systems, but not to ensure quality of service and prevent cascading failures in distributed systems. </font><font style="vertical-align: inherit;">Load balancers need to see the level of the application in order to successfully and accurately apply backpressure to customers. </font><font style="vertical-align: inherit;">Gradual degradation of the service is impossible if it is impossible to accurately determine its level of performance at any time. </font><font style="vertical-align: inherit;">In the absence of timely and sufficient back pressure, services can quickly fall into a quagmire of failures.</font></font></p></div><p>Source: <a href="https://habr.com/ru/post/433462/">https://habr.com/ru/post/433462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433448/index.html">Comparative analysis of markets used. Cars of Germany and France in the B and C segment</a></li>
<li><a href="../433450/index.html">Grow and teach. How we made friends with PEGA</a></li>
<li><a href="../433456/index.html">How to convince a client or company to use Flutter</a></li>
<li><a href="../433458/index.html">Some unobvious Serverless benefits for DevOps</a></li>
<li><a href="../433460/index.html">Simplify build builds in Unity3D</a></li>
<li><a href="../433464/index.html">Subcosmic race</a></li>
<li><a href="../433466/index.html">Compare pages. Simple plugin for Atlassian Confluence</a></li>
<li><a href="../433468/index.html">Fault Injection: your system is unreliable if you have not tried to break it</a></li>
<li><a href="../433472/index.html">Unity 2018.3 has been released</a></li>
<li><a href="../433474/index.html">Pylint from the inside. How he does it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>