<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Timsort sorting algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Timsort , in contrast to all the ‚Äúbubbles‚Äù and ‚Äúinserts‚Äù there, is a relatively new thing - it was invented in 2002 by Tim Peters (named after him). S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Timsort sorting algorithm</h1><div class="post__text post__text-html js-mediator-article">  <b>Timsort</b> , in contrast to all the ‚Äúbubbles‚Äù and ‚Äúinserts‚Äù there, is a relatively new thing - it was invented in 2002 by Tim Peters (named after him).  Since then, it has already become the standard sorting algorithm in Python, OpenJDK 7 and Android JDK 1.5.  And in order to understand why - just look at this tablet from Wikipedia. <br><br><img src="https://habrastorage.org/storage1/61a272a8/54806d34/69954080/310f329f.png"><br><br>  Among the seemingly huge choice in the table, there are only 7 adequate algorithms (with <i>O (n logn) complexity</i> on average and worst case), among which only 2 can boast of stability and <i>O (n)</i> complexity at best.  One of these two is the well-known <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581_%25D0%25BF%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2589%25D1%258C%25D1%258E_%25D0%25B4%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25B0">‚ÄúSorting with Binary Tree‚Äù for</a> a long time.  But the second one is Timsort. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The algorithm is built on the idea that in the real world a sorted data array often contains ordered (not important, ascending or descending) subarrays.  This is indeed often the case.  On such data Timsort tears to shreds all other algorithms. <br><a name="habracut"></a><br><h4>  Go to the point </h4><br>  Do not wait here for some complex mathematical discoveries.  The fact is that in fact Timsort is not a completely independent algorithm, but a hybrid, an effective combination of several other algorithms, seasoned with its own ideas.  Very briefly, the essence of the algorithm can be explained as follows: <br><ol><li>  By a special algorithm, we divide the input array into subarrays. </li><li>  We <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">sort</a> each sub array in the usual <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">sorting by inserts</a> . </li><li>  We assemble sorted subarrays into a single array using modified <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">merge sorting</a> . </li></ol>  The devil, as always, is hidden in the details, namely in the algorithm from item 1 and the modification of the merge sort from item 3. <br><br><h4>  Algorithm </h4><br><h5>  Used concepts </h5><ul><li>  <b>N</b> is the size of the input array </li><li>  <b>run</b> - an ordered subarray in the input array.  Moreover, it is ordered either weakly ascending or strictly descending.  Ie or ‚Äúa0 &lt;= a1 &lt;= a2 &lt;= ...‚Äù, or ‚Äúa0&gt; a1&gt; a2&gt; ...‚Äù </li><li>  <b>minrun</b> - as mentioned above, in the first step of the algorithm, the input array will be divided into subarrays.  <b>minrun</b> is the minimum size of such a subarray.  This number is calculated according to a certain logic from the number <b>N.</b> </li></ul><br><img src="https://habrastorage.org/storage1/8a3bfde5/8c5e9d61/151fc6dd/25b9c11a.png"><br><br><h5>  Step 0. Calculate <b>minrun</b> . </h5><br>  The <b>minrun</b> number is determined based on <b>N</b> based on the following principles: <br><ol><li>  It should not be too large, since sorting by inserts will be further applied to the minrun size <b>array</b> , and it is effective only on small arrays. </li><li>  It should not be too small, because the smaller the subarray, the more iterations of subarray merging will have to be performed at the last step of the algorithm. </li><li>  It would be nice if <b>N \ minrun</b> was a power of 2 (or close to it).  This requirement is due to the fact that the subarray fusion algorithm works most effectively on subarrays of approximately equal size. </li></ol>  At this point, the author of the algorithm refers to his own experiments, which showed that if <b>minrun</b> &gt; 256, point 1 is violated, when <b>minrun</b> &lt;8, point 2 is broken and the values ‚Äã‚Äãfrom the range (32; 65) are used most effectively.  The exception is if <b>N</b> &lt;64, then <b>minrun</b> = <b>N</b> and timsort turns into simple sorting by insertion.  At the moment, the <b>minrun</b> calculation algorithm is simply disgraceful: we take the upper 6 bits of <b>N</b> and add one if the remaining low bits have at least one non-zero one.  Sample code looks like this: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMinrun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  1        1  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { r |= n &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + r; }</code> </pre> <br><h5>  Step 1. Splitting into subarrays and sorting them. </h5><br>  So, at this stage we have an input array, its size <b>N</b> and the calculated number <b>minrun</b> .  The algorithm of this step: <br><ol><li>  We put the pointer of the current element at the beginning of the input array. </li><li>  Starting with the current element, we look for the <b>run</b> in the input array (ordered subarray).  By definition, this <b>run</b> will unambiguously enter the current element and the next one, but then further - as lucky as you are.  If the resulting subarray is ordered in descending order, we rearrange the elements so that they go in ascending order (this is a simple linear algorithm, just go from both ends to the middle, changing the elements in places). </li><li>  If the size of the current <b>run 'is</b> less than <b>minrun</b> - we take the elements in the number of <b>minrun - size (run) that</b> follow the <b>run that it</b> found.  Thus, at the output we have a sub- <b>array of minrun</b> size or more, a part of which (and ideally it is all) is ordered. </li><li>  Apply to this subarray sorting inserts.  Since the size of the subarray is small and part of it is already ordered, the sorting works quickly and efficiently. </li><li>  We set the current element pointer to the next element after the subarray. </li><li>  If the end of the input array is not reached - go to step 2, otherwise - the end of this step. </li></ol><br><h5>  Step 2. Merge. </h5><br>  At this stage, we have an input array, divided into subarrays, each of which is ordered.  If the input array data were close to random - the size of the ordered subarrays is close to <b>minrun</b> , if the data were ordered ranges (and based on the recommendations on the application of the algorithm, we have reason to hope) - the ordered subarrays are larger than <b>minrun</b> . <br>  Now we need to combine these subarrays to produce a resultant, fully ordered array.  And in the course of this association, you need to fulfill 2 requirements: <br><ol><li>  Combine subarrays of approximately equal size (this is more efficient). </li><li>  Preserve the stability of the algorithm - that is,  do not make meaningless permutations (for example, do not change two consecutively the same number of places). </li></ol><br>  This is achieved in this way. <br><ol><li>  Create an empty stack of pairs &lt;index of beginning of subarray&gt; - &lt;size of subarray&gt;.  Take the first ordered subarray. </li><li>  We add to the stack a pair of data &lt;start index&gt; - &lt;size&gt; for the current subarray. </li><li>  Determine if the current subarray should be merged with the previous ones.  To do this, check the fulfillment of 2 rules (let X, Y and Z be the sizes of the three upper subarrays in the stack): <br>  X&gt; Y + Z <br>  Y&gt; Z </li><li>  If one of the rules is violated, the array Y merges with the smaller of the arrays X and Z. Repeats until both rules are fulfilled or the data are completely ordered. </li><li>  If there are still not considered subarrays, we take the next one and go to point 2. Otherwise, the end. </li></ol><br>  The purpose of this tricky procedure is to maintain balance.  Those.  The changes will look like this: <br><img src="https://habrastorage.org/storage1/8cdf432d/ba2bd342/dd411e5f/912028c1.png"><br>  therefore, the sizes of the subarrays in the stack are effective for further merge sorting.  Imagine the ideal case: we have subarrays of size 128, 64, 32, 16, 8, 4, 2, 2 (let's forget for a second about the presence of the requirement ‚Äúsize of subarray&gt; = <b>minrun</b> ‚Äù).  In this case, no merges will be executed until the last 2 subarrays meet, but after that 7 perfectly balanced mergers will be executed. <br><br><h5>  Subarray Merge Procedure </h5><br>  As you remember, in the second step of the algorithm we deal with the merging of two subarrays into one ordered one.  We always connect 2 consecutive subarrays.  Additional memory is used to merge them. <br><ol><li>  Create a temporary array in the size of the smallest of the connected subarrays. </li><li>  Copy the smaller of the subarrays into a temporary array. </li><li>  We put pointers to the current position on the first elements of a larger and temporary array. </li><li>  At each next step, we consider the value of the current elements in the larger and temporary arrays, take the smaller of them and copy it into a new sorted array.  Move the pointer of the current element in the array from which the element was taken. </li><li>  Repeat 4 until one of the arrays is over. </li><li>  Add all elements of the remaining array to the end of the new array. </li></ol><img src="https://habrastorage.org/storage1/33331d30/0a2d9ded/c8700f74/97626abe.png"><br><br><h5>  Modification of the subarray fusion procedure </h5><br>  Everything seems to be good in the merge algorithm shown above.  Except one.  Imagine the procedure of merging two such arrays: <br>  <b>A</b> = {1, 2, 3, ..., 9999, 10000} <br>  <b>B</b> = {20000, 20001, ...., 29999, 30000} <br>  The above procedure for them, of course, will work, but each time in its fourth paragraph you will need to perform one comparison and one copy.  And that 10,000 comparisons and 10,000 copies.  The Timsort algorithm offers a modification at this place, which he calls a "gallop."  The bottom line is as follows: <br><ol><li>  Begin the merge procedure, as shown above. </li><li>  On each operation of copying an element from a temporary or larger sub-array into the resulting one, we remember which sub-array was from which particular element. </li><li>  If already a certain number of elements (in this implementation of the algorithm, this number is strictly equal to 7) was taken from the same array, we assume that we will have to take data from it further.  To confirm this idea, we are switching to the ‚Äúgallop‚Äù mode, i.e.  We run through the array-applicant for the supply of the next large portion of data by binary search (we remember that the array is ordered and we have the full right to binary search) of the current element from the second array to be connected.  Binary search is more efficient than linear, and therefore search operations will be much smaller. </li><li>  Having finally found the moment when the data from the current supplier array no longer suits us (or by reaching the end of the array), we can finally copy them all at once (which can be more efficient than copying single elements). </li></ol><br>  Perhaps the explanation is slightly vague, try on an example. <br>  <b>A</b> = {1, 2, 3, ..., 9999, 10000} <br>  <b>B</b> = {20000, 20001, ...., 29999, 30000} <br><ol><li>  The first 7 iterations we compare the numbers 1, 2, 3, 4, 5, 6 and 7 from the array <b>A</b> with the number 20000 and, making sure that 20,000 is more - copy the elements of the array <b>A</b> into the resulting one. </li><li>  Starting with the next iteration, we switch to the ‚Äúgallop‚Äù mode: compare with the number 20000 successively the elements 8, 10, 14, 22, 38, n + 2 ^ i, ..., 10,000 of the array <b>A.</b>  As you can see, such a comparison will be much less than 10,000. </li><li>  We have reached the end of array <b>A</b> and know that it is all smaller than <b>B</b> (we could also stay somewhere in the middle).  We copy the necessary data from array <b>A</b> into the resulting one, we go further. </li></ol><br>  That's the whole algorithm. <br><br><h5>  Materials on the topic </h5><ul><li>  <a href="http://en.wikipedia.org/wiki/Timsort">Timsort on Wikipedia</a> (no Russian version) </li><li>  <a href="http://bugs.python.org/file4451/timsort.txt">Presentation of the algorithm from its creator</a> </li><li>  <a href="http://stackoverflow.com/questions/154504/is-timsort-general-purpose-or-python-specific">Algorithm discussion on Stackoverflow</a> </li><li>  <a href="http://corte.si/posts/code/timsort/index.html">Beautiful visualization algorithm</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/133303/">https://habr.com/ru/post/133303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133297/index.html">Habrastruchta in St. Petersburg</a></li>
<li><a href="../133299/index.html">Imagine Cup Student Camp - December 3 in Moscow</a></li>
<li><a href="../133300/index.html">YouTube agreed with Walt Disney on the use of films</a></li>
<li><a href="../133301/index.html">Ice Cream Sandwich on HTC Dream</a></li>
<li><a href="../133302/index.html">New qualities of the Asus Eee T101MT-BLK120S netbook transformer</a></li>
<li><a href="../133304/index.html">Lenovo introduced the smallest desktop in the world</a></li>
<li><a href="../133305/index.html">The State Duma launched an open API to search for bills</a></li>
<li><a href="../133306/index.html">Another open source analogue of Github</a></li>
<li><a href="../133307/index.html">Styling applications part one</a></li>
<li><a href="../133308/index.html">Small devices with big problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>