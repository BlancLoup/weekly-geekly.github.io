<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Metaobject Protocol for Basic Perl 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea of ‚Äã‚Äãcreating a Metaobject Protocol ( MOP ) for Perl 5 has been around for a long time. Well known is one of the implementations - Class :: M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Metaobject Protocol for Basic Perl 5</h1><div class="post__text post__text-html js-mediator-article">  The idea of ‚Äã‚Äãcreating a <i>Metaobject Protocol</i> ( <abbr title="Metaobject protocol">MOP</abbr> ) for Perl 5 has been <i>around</i> for a long time.  Well known is one of the implementations - <em>Class :: MOP</em> , which is used in <em>Moose</em> .  But getting into the basic delivery of Perl 5 can only be such a solution that will be compatible with the existing object model and will not be overloaded with excessive features and dependencies.  The other day, <i>Stevan Little</i> published the first trial release on CPAN of a possible candidate for this vacant position - the <a href="https://metacpan.org/release/STEVAN/mop-0.01-TRIAL">mop</a> module.  The project went through a long evolution, the process was closely watched by the community.  Let's take a look at what happened and what consequences this might have for Perl 5. <br><a name="habracut"></a><br><h4>  What is MOP? </h4><br>  <i>Metaobject Protocol</i> (Meta-Object Protocol) is a software interface for managing a system of objects in a language.  Just as an object is an instance of a class, the class itself is represented by an object (or metaobject) with programmatically defined properties (attributes, methods, etc.).  As Stevan Little put it, explaining to his mom what Moose is doing: <br><blockquote>  This is an abstraction for the abstraction system used to create abstractions. <br></blockquote><br>  When dealing with classes in basic Perl, we all came across a very simple MOP implementation: <br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">no</span></span> strict <span class="hljs-string"><span class="hljs-string">'refs'</span></span>; *{$foo . <span class="hljs-string"><span class="hljs-string">'::bar'</span></span>} = \&amp;baz;</code> </pre> <br>  This crypto-record in the course of the program operation adds the method <code>bar</code> for the class specified in the <code>$foo</code> variable, which is a reference (alias) to the <code>baz</code> function.  If someone is familiar with the term <abbr title="ability to analyze and modify objects during work">reflections</abbr> , then this is also one of his examples.  The difference between MOP and reflections is that it provides a convenient and flexible developer tool for metaprogramming classes without the need for semi-legal hacking techniques.  For example: <br><br><pre> <code class="perl hljs">class Foo { method bar { baz } }</code> </pre><br><h4>  Why do I need a MOP in the base Perl distribution? </h4><br>  If you look at the classic MOP book - ‚ÄúThe Art of the Metaobject Protocol‚Äù, which described the implementation of the meta protocol in <abbr title="Common Lisp Object System">CLOS</abbr> , one of the main prerequisites for creating a protocol was the need to solve the problem of a variety of Lisp object system implementations that were incompatible with each other.  The metaprotocol allowed building a compatible, flexible, and extensible object system that would satisfy all Lisp programmer requests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A simple and non-dependency implementation of MOP in the base Perl package can unambiguously resolve the issue of choosing an object system to use when creating programs.  This will end all religious wars in the confrontation of OOP frameworks and make it customary to connect MOPs like <code>use strict</code> . <br><br>  The implementation of MOP for basic Perl should be easy and fast enough, for this reason the same Moose can never get there, but mop has every chance for that. <br><br>  A syntactically beautiful and logical object system can inspire a lot of modules for rework, the authors of which did not dare to use any OOP frameworks due to their severity or excessive dependencies, which in turn will significantly improve the readability of the code and reduce the cost of supporting it (single style , simplified static code analysis). <br><br>  Naturally, this can attract young developers to Perl, since simplicity and conciseness are very important when mastering a language that claims to be object-oriented. <br><br>  As some people in the community note, it is likely that the MOP will become an important part of the future of Perl and there will be a clear boundary in the history of Perl: before and when the MOP arrives at the core. <br><br><h4>  Mop evolution </h4><br>  The development of the mop module was preceded by a very long way.  Stevan Little after participating in the work on the object system for Perl 6 in the <i>Pugs</i> compiler, decided to transfer the results to Perl 5. After several attempts, the Class :: MOP module appeared, which became the basis for creating Moose.  Moose became very popular because it gave developers the tool for working with classes that they had been waiting for.  But for a long time the start of programs on Moose and a large tree of dependencies scared potential users.  So two years ago, Stephen caught fire with the idea of ‚Äã‚Äãcreating a compact MOP system that could be included in the basic delivery of Perl.  This is how the <a href="https://github.com/stevan/p5-mop">p5-mop</a> project came <a href="https://github.com/stevan/p5-mop">about</a> , but it was crushed by the weight of its own complexity, which somewhat disappointed Stephen and led him to an unexpected experiment ‚Äî the <a href="https://github.com/MoeOrganization/moe">Moe</a> project, the implementation of the Perl 5 compiler in the <i>Scala</i> language. <br><br>  Some time passed and Steven decided that he needed to give the p5-mop a second chance and created the <a href="https://github.com/stevan/p5-mop-redux">p5-mop-redux project</a> , which did not try to embrace the immense and did not set out to drag all the possibilities of Moose, but only become the basis for an expandable object system core perl. <br><br>  Stephen kept the community up to date on work progress and published articles on the <a href="http://blogs.perl.org/users/stevan_little/">blogs.perl.org</a> blog platform.  On October 15, the first trial release of the module on CPAN was published.  Now the module has two active developers: <i>Stevan Little</i> and <i>Jesse Luehrs</i> , as well as several contributors. <br><br><h4>  Work with mop </h4><br><h5>  Installation </h5><br>  To install mop, you can use cpanm: <br><br><pre> <code class="bash hljs">$ cpanm --dev mop</code> </pre><br>  Please note that mop makes extensive use of new Perl features such as the <i>Perl parser API</i> .  The minimum version of Perl required for the module to work is 5.16. <br><br><h5>  First example </h5><br>  Consider sample code using mop: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mop; class Point { has $!<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> is ro = <span class="hljs-number"><span class="hljs-number">0</span></span>; has $!<span class="hljs-keyword"><span class="hljs-keyword">y</span></span> is ro = <span class="hljs-number"><span class="hljs-number">0</span></span>; method clear { ($!<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, $!<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  The class is defined by the <code>class</code> keyword.  First, the <code>Point</code> class is declared, in which attributes are defined using the has keyword.  Note that attribute variables are set using <i>twigil</i> ( <i>twigil</i> or two-character <i>sigil</i> ) to distinguish them from ordinary variables.  It almost completely copies the syntax of Perl 6. At the moment, only <code>$!</code> tvigil attributes are supported <code>$!</code>  which are private attributes. <br><br>  After specifying twigil, <i>traits are</i> followed by the keyword <code>is</code> .  For example, <code>ro</code> means that the attribute is read only.  After the equal sign, the default attribute value is set.  In the <code>Point</code> class, the only <code>clear</code> method is set, which resets attribute values.  It can be seen that the attribute variables <code>$!x</code> , <code>$!y</code> are available inside the methods as lexical variables in the scope of this class.  Their values ‚Äã‚Äãare locked within each instance of the class. <br><br><pre> <code class="perl hljs">class Point3D extends Point { has $!z is ro = <span class="hljs-number"><span class="hljs-number">0</span></span>; method clear { $self-&gt;<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>::method; $!z = <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre><br>  It defines the <code>Point3D</code> class, which becomes the heir of the Point class using the <code>extends</code> .  Thus, the resulting class takes over all the attributes and methods of the class <code>Point</code> .  In addition to them in the class attribute is set <code>$!z</code>  The <code>clear</code> method is also redefined, which, as shown in the listing, calls the next (in the inheritance hierarchy) parent <code>clear</code> method from the <code>Point</code> class using <code>next::method</code> .  In addition, the variable <code>$self</code> automatically defined inside each method, which is a reference to the current object. <br><br>  In case no classes are specified for inheritance, the class is inherited from the <code>mop::object</code> class by default.  This is demonstrated in the following example: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Dumper mro::get_linear_isa(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Point-&gt;new); $VAR1 = [ <span class="hljs-string"><span class="hljs-string">'Point'</span></span>, <span class="hljs-string"><span class="hljs-string">'mop::object'</span></span> ];</code> </pre><br>  Object attributes can be set when creating an instance of a class: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $point = Point-&gt;new( <span class="hljs-string"><span class="hljs-string">x =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">y =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Note that we did not specify the <code>new</code> method for the <code>Point</code> class.  This method is inherited from the <code>mop::object</code> class. <br><br>  To access the attribute value, a getter method is automatically created, for example: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $point = Point-&gt;new( <span class="hljs-string"><span class="hljs-string">x =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">y =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $point-&gt;<span class="hljs-keyword"><span class="hljs-keyword">x</span></span></code> </pre><br>  The value <code>1</code> will be displayed.  Since the attribute is declared as <code>ro</code> , an attempt to change it will lead to a runtime error: <br><br><pre> <code class="perl hljs">$point-&gt;<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); Cannot assign to a <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>-only accessor</code> </pre><br>  However, inside the methods we can freely change any attributes, for example, we can create a <code>set_x</code> setter <code>set_x</code> : <br><br><pre> <code class="perl hljs">class Point { has $!<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> is ro = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... method set_x( $x=<span class="hljs-number"><span class="hljs-number">10</span></span> ) { $!<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = $x } }</code> </pre><br>  In this example, you can also clearly see how you can set the method signature, i.e.  describe the variable arguments passed to the method, and even set the default values ‚Äã‚Äãif the argument is omitted. <br><br><pre> <code class="perl hljs">$point-&gt;set_x(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment"># $!x  5 $point-&gt;set_x; # $!x  10</span></span></code> </pre><br>  At the same time, attributes are in scope only for the class Point, i.e.  we cannot directly operate with them in the class of the successor <br><br><pre> <code class="perl hljs">class Point3D extends Point{ ... method set_x_broken { $!<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>; } }</code> </pre><br>  This will <code>No such twigil variable $!x</code> compilation error: <code>No such twigil variable $!x</code> <br><br><h4>  Roles </h4><br>  Roles allow you to flexibly arrange classes with the necessary methods and attributes, while avoiding multiple inheritance. <br><br><pre> <code class="perl hljs">role BlackJack { method win; method loose ($value) { <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $self-&gt;win($value) } }</code> </pre><br>  This role defines the two methods <code>win</code> and <code>loose</code> .  The <code>win</code> method has no body, so in this case the method must be defined in the class that plays the role.  In this respect, the role is similar to the concept of an interface present in other programming languages. <br><br>  Now you can build a class with this role using the with keyword: <br><br><pre> <code class="perl hljs">class LunaPark with BlackJack { method win ($value){ <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre><br>  A class can be composed of several roles, in this case the names of roles are separated by commas. <br><br><h4>  Attribute Properties and Values </h4><br><pre> <code class="perl hljs">has $!foo is rw, lazy = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Attribute properties are separated by a comma, after the keyword is.  The following properties are currently supported: <br><br><ul><li>  <code>ro</code> / <code>rw</code> - read only / read / write access </li><li>  <code>lazy</code> - creating an attribute when it is first accessed </li><li>  <code>weak_ref</code> - attribute is declared as ‚Äúweak‚Äù link </li></ul><br><br>  When specifying the default value, it should be remembered that in fact, after the equal sign, there is an executable construct, i.e.  record: <br><br><pre> <code class="perl hljs">has $!foo = <span class="hljs-string"><span class="hljs-string">"value"</span></span></code> </pre><br>  Means <br><pre> <code class="perl hljs">has $!foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-string"><span class="hljs-string">"value"</span></span> }</code> </pre><br>  Those.  in essence, it is a function for creating a value, and not for assigning a given expression. <br>  When setting the default value, you can refer to the current object instance using the $ _ variable: <br><br><pre> <code class="perl hljs">has $!foo = $_-&gt;set_foo()</code> </pre><br>  If it is required that when creating an object with the help of <code>new</code> , a certain attribute is necessarily set, the default value for it can be the following code: <br><br><pre> <code class="perl hljs">has $!foo = <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">'$!foo is required'</span></span>;</code> </pre><br>  Accordingly, if the value of the <code>foo</code> attribute is not specified when the object is created, an exception will occur. <br><br>  Checks of types, classes of attributes and methods are not implemented in order not to overload the mop kernel with excessive complexity.  However, such checks can easily be performed as an external function: <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">#     ... } class foo { has $!bar is rw, type('Int'); method baz ($a, $b) is type('Int', 'Int') { ... } }</span></span></code> </pre><br>  The working implementation of the <code>type</code> function can be seen in the <a href="">example</a> for the mop module. <br><br><h4>  Module creation </h4><br>  A typical module file might look like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Figures; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mop; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $debug = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debug</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> STDERR <span class="hljs-string"><span class="hljs-string">"@_\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $debug; } class Point { has $!data is ro; method draw_point { debug(<span class="hljs-string"><span class="hljs-string">"draw point"</span></span>) } method BUILD { $!data = <span class="hljs-string"><span class="hljs-string">"some data"</span></span>; } method DEMOLISH { <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span> $!data; } } class Point3D extends Figures::Point {} <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $point = Figures::Point3D-&gt;new; $point-&gt;draw_point;</code> </pre><br>  As you can see from the example, if the <code>package</code> is specified, the class names get the corresponding prefix.  In addition, the class is accessed by the module scope.  This means that functions and variables defined in the module scope are also available for use inside classes.  Moreover, such functions do not become class methods.  No more pollution of the namespace with exported functions! <br><br>  The special <code>BUILD</code> method can be used if some initialization is required when creating the object.  This is convenient and allows you to not override the <code>new</code> method. <br><br>  The <code>DEMOLISH</code> method <code>DEMOLISH</code> called when an object is destroyed, i.e.  is a destructor. <br><br><h4>  The internal structure of the object in the mop </h4><br>  The object created by mop is not familiar to many <i>blessed</i> hash references.  Instead, so-called <i>InsideOut</i> objects are used, where the entire internal structure is hidden in the class code and is accessible only through special methods.  There are several public methods in mop that allow you to inspect the internal structure of an object: <br><br><ul><li>  <code>mop::dump_object</code> - object dump <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Dumper mop::dump_object( Point3D-&gt;new ) $VAR1 = { <span class="hljs-string"><span class="hljs-string">'$!y'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Point3D'</span></span>, <span class="hljs-string"><span class="hljs-string">'$!x'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'ID'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10804592</span></span>, <span class="hljs-string"><span class="hljs-string">'$!z'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'SELF'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{\(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $o = <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span>)}, <span class="hljs-string"><span class="hljs-string">'Point3D'</span></span> ) };</code> </pre><br></li><li>  <code>mop::id</code> - a unique identifier of the object <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> mop::id(Point3D-&gt;new) <span class="hljs-number"><span class="hljs-number">10804592</span></span></code> </pre><br></li><li>  <code>mop::meta</code> - meta-information about an object, for detailed introspection of objects <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Dumper mop::dump_object( mop::meta( Point3D-&gt;new ) ) $VAR1 = { <span class="hljs-string"><span class="hljs-string">'$!name'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Point3D'</span></span>, ... <span class="hljs-comment"><span class="hljs-comment">#         ... }</span></span></code> </pre><br></li><li>  <code>mop::is_mop_object</code> is a logical function, returns true if the object is <code>mop::object</code> <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> mop::is_mop_object( Point3D-&gt;new ) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br></li></ul><br><br><h4>  Practical use </h4><br>  The mop module is currently undergoing active testing by the community.  The basic recommendation is to take any module and try to rewrite it using mop.  What mistakes and problems will you face?  Write about it, it will be a great help in the further development of the project.  For example, the <a href="https://github.com/stevan/Plack">Plack</a> module was successfully ported, all of which 1152 tests were successfully passed. <br><br>  Now it is difficult to say whether mop will be accepted into the core distribution of Perl.  If accepted, starting with which version: 5.20, 5.22 or later?  This is unknown, but the overall very positive background around the event is encouraging. <br><br><h4>  Sources </h4><br><ol><li>  <a href="https://speakerdeck.com/stevan_little/perl-5-mop">"Perl 5 MOP"</a> by Stevan Little </li><li>  <a href="http://modernperlbooks.com/mt/2012/09/why-perl-5-needs-a-metaobject-protocol.html">"Why Perl 5 Needs and Metaobject Protocol"</a> by chromatic </li><li>  <a href="http://blogs.perl.org/users/damien_dams_krotkine/2013/09/p5-mop.html">"P5-mop, a gentle introduction"</a> by Damien "dams" Krotkine </li><li>  <a href="">Mop module documentation</a> </li><li>  <a href="http://blogs.perl.org/users/stevan_little/2013/08/mapping-the-mop-to-moose.html">"Mapping the MOP to Moose"</a> by Stevan Little </li><li>  <a href="http://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol">"The Art of the Metaobject Protocol"</a> AMOP </li></ol></div><p>Source: <a href="https://habr.com/ru/post/198274/">https://habr.com/ru/post/198274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198264/index.html">Prevent participation in dns amplification attack or experience in writing nuclear code</a></li>
<li><a href="../198266/index.html">Algorithm for finding paths in the maze</a></li>
<li><a href="../198268/index.html">Algorithm for learning a multilayer neural network using the back propagation error (Backpropagation)</a></li>
<li><a href="../198270/index.html">Qt Meta System over Network. Part 1 - Properties</a></li>
<li><a href="../198272/index.html">Chelyabinsk meteorite: systematized photo and video materials</a></li>
<li><a href="../198276/index.html">Zabbix: Backing up a small base</a></li>
<li><a href="../198280/index.html">Babel and handlebars, it's time to make friends</a></li>
<li><a href="../198284/index.html">How to cheat Robokassu</a></li>
<li><a href="../198286/index.html">Part 1. Detailed instructions for creating your CocoaPod</a></li>
<li><a href="../198288/index.html">Elon Musk will make a transformed submarine from "James Bond" a real vehicle-transformer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>