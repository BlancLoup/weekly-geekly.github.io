<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is GitOps?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : After the recent publication of material about the methods of pull and push in GitOps, we saw an interest in this model as a whole, but ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is GitOps?</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: After the recent publication of <a href="https://habr.com/ru/company/flant/blog/456754/">material</a> about the methods of pull and push in GitOps, we saw an interest in this model as a whole, but there were very few Russian-language publications on this topic (there are simply not any at the Habr√©).</i>  <i>Therefore, we are pleased to offer you a translation of another article - even if it is almost a year old!</i>  <i>- from the company Weaveworks, the head of which coined the term ‚ÄúGitOps‚Äù.</i>  <i>The text explains the essence of the approach and the key differences from the existing ones.</i> <br><br><img src="https://habrastorage.org/webt/i0/8b/fc/i08bfcph3kkhapzkitpwhylzdhc.png"><br><br>  A year ago, we published an <a href="https://www.weave.works/blog/gitops-operations-by-pull-request">introduction to GitOps</a> .  Then we described how the Weaveworks team launched SaaS, based entirely on Kubernetes, and developed a set of prescriptive best practices for deploying, managing, and monitoring in a cloud native environment. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article proved popular.  Other people started talking about GitOps, began to publish new tools for <a href="https://github.com/hasura/gitkube">git push</a> , <a href="https://dzone.com/articles/weaveworks-gitops-developer-toolkit-part-one-skaff">development</a> , <a href="https://www.weave.works/blog/storing-secure-sealed-secrets-using-gitops">secrets</a> , <a href="https://blog.alexellis.io/introducing-openfaas-cloud/">functions</a> , <a href="https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/">continuous integration</a> , etc.  A <a href="https://www.weave.works/blog/category/gitops/">large number of</a> publications and use cases of GitOps have appeared on our website.  But some people still have questions.  How does the model differ from traditional <a href="https://puppet.com/blog/a-deployment-pipeline-for-infrastructure-a-devops-case-study-at-nbn">infrastructure as code</a> and continuous delivery?  Do I have to use Kubernetes? <br><br>  Soon we realized that a new description was needed, offering: <br><br><ol><li>  A large number of examples and stories; </li><li>  The specific definition of GitOps; </li><li>  Comparison with traditional continuous delivery. </li></ol><br>  In this article we tried to cover all these topics.  In it, you will find an updated introduction to GitOps and a look at it from the developers and CI / CD.  We mainly focus on Kubernetes, although the model can be quite generalized. <br><br><h2>  Meet GitOps </h2><br>  Imagine Alice.  She manages Family Insurance, which offers health, car, real estate and travel insurance to people who are too busy to figure out the nuances of contracts on their own.  Her business began as a side project when Alice worked at the bank as a data scientist.  Once she realized that she could use advanced computer algorithms for more efficient data analysis and the formation of insurance packages.  Investors financed the project, and now her company brings more than $ 20 million a year and is growing rapidly.  Currently, 180 people work in various positions.  Among them is a technology team that develops, maintains a site, a database and analyzes customer base.  The team of 60 people is headed by Bob, the company's technical director. <br><br>  Bob's team deploys production systems in the cloud.  Their main apps run on GKE, taking advantage of Kubernetes in Google Cloud.  In addition, they use in their work various tools for working with data and analytics. <br><br>  Family Insurance was not going to use containers, but it caught the enthusiasm around Docker.  Soon, the company's specialists discovered that GKE allows you to deploy clusters to test new features easily and naturally.  Jenkins for CI and Quay were added to organize the container registry, Jenkins scripts were written, which push or new containers and configurations in GKE. <br><br>  Some time has passed.  Alice and Bob were disappointed in the performance of the chosen approach and its impact on the business.  The introduction of containers did not increase productivity as much as the team had hoped.  Sometimes the deployment broke down, and it was unclear if the code changes were to blame.  It also turned out to be difficult to track changes to configs.  Often we had to create a new cluster and move applications into it, since it was the easiest way to eliminate the mess that the system had become.  Alice was afraid that the situation would worsen as the application developed (besides, a new project was brewing based on machine learning).  Bob automated most of the work and did not understand why the pipeline is still unstable, does not scale well, and periodically requires manual intervention? <br><br>  <b>Then they learned about GitOps.</b>  <b>This decision turned out to be exactly what they needed to move forward with confidence.</b> <br><br>  Alice and Bob have been hearing about Git, DevOps and infrastructure as code-based workflows for years.  The uniqueness of GitOps is that it introduces a number of best practices - categorical and normative - for implementing these ideas in the context of Kubernetes.  This topic <a href="https://twitter.com/search%3Fq%3Dgitops%26src%3Dtypd">has been raised several times</a> , including in the <a href="https://www.weave.works/blog/gitops-high-velocity-cicd-for-kubernetes">Weaveworks blog</a> . <br><br>  Family Insurance decides to implement GitOps.  The company now has an automated operating model that is compatible with Kubernetes and combines <i>speed</i> with <i>stability</i> because they: <br><br><ul><li>  found that the team has doubled its productivity and no one is going crazy; </li><li>  stopped serving scripts.  Instead, they can now concentrate on new features and improve engineering techniques ‚Äî for example, implement canary rollouts and improve testing; </li><li>  improved the deployment process - now it rarely breaks down; </li><li>  got the opportunity to restore deployments after partial failures without manual intervention; </li><li>  gained greater confidence in delivery systems.  Alice and Bob found that it is possible to divide the team into microservice groups and working in parallel; </li><li>  can make 30-50 changes to the project every day with the efforts of each group and try new equipment; </li><li>  easily attract new developers to the project, who have the ability to roll up updates to production using pull requests in just a few hours; </li><li>  easy to pass an audit within SOC2 </li></ul><br><h3>  What happened? </h3><br>  GitOps are two things: <br><br><ol><li>  Exploitation model for Kubernetes and cloud native.  It provides a set of best practices for deploying, managing, and monitoring clusters and applications assembled into containers.  An elegant definition of a <a href="https://twitter.com/vitorsilva/status/999978906903080961">single slide</a> from <a href="https://2018.agilept.org/speaker_luis_faceira.html">Luis Faceira</a> : <br><br><img src="https://habrastorage.org/webt/or/fl/uu/orfluutk_hcqu6dnclf6pu1ewes.jpeg"></li><li>  The path to creating a developer-centric application management environment.  We apply the Git workflow to both exploitation and development.  Please note that this is not just about Git push, but about organizing the entire CI / CD and UI / UX toolkit. </li></ol><br><h3>  Couple of words about git </h3><br>  If you are unfamiliar with version control systems and Git-based workflows, we highly recommend learning them.  At first, working with branches and pull requests may seem like black magic, but the pros are worth the effort.  Here is a <a href="https://codeburst.io/trunk-based-development-vs-git-flow-a0212a6cae64">good article</a> to start with. <br><br><h2>  How Kubernetes works </h2><br>  In our story, Alice and Bob turned to GitOps, having worked for a while with Kubernetes.  Indeed, GitOps is closely related to Kubernetes - an operating model for infrastructure and applications based on Kubernetes. <br><br><h3>  What does Kubernetes give users? </h3><br>  Here are some basic features: <br><br><ol><li>  In the Kubernetes model, everything can be described in a declarative form. </li><li>  The Kubernetes API server accepts such a declaration as input, and then constantly tries to bring the cluster to the state described in the declaration. </li><li>  The declarations are sufficient to describe and manage a wide variety of workloads - ‚Äúapplications‚Äù. </li><li>  As a result, changes to the application and cluster occur due to: <br><ul><li>  changes in the images of containers; </li><li>  changes in the declarative specification; </li><li>  errors in the environment - for example, the fall of the containers. </li></ul></li></ol><br><h3>  Kubernetes excellent convergence abilities </h3><br>  When the administrator makes changes to the configuration, the Kubernetes orchestrator will apply them to the cluster until his state <i>approaches the new configuration</i> .  This model works for any Kubernetes resource and is extended with Custom Resource Definitions (CRDs).  Therefore, deployment Kubernetes have the following wonderful properties: <br><br><ul><li>  <b>Automation</b> : Kubernetes updates provide a mechanism to automate the process of applying changes correctly and in a timely manner. </li><li>  <b>Convergence</b> : Kubernetes will continue to attempt upgrades until success is achieved. </li><li>  <b>Idempotency</b> : reapplication of convergence leads to the same result. </li><li>  <b>Determinism</b> : with sufficient resources, the state of the updated cluster depends only on the desired state. </li></ul><br><h2>  How GitOps works </h2><br>  We've learned enough about Kubernetes to explain how GitOps works. <br><br>  Let's go back to the Family Insurance teams associated with microservices.  What do they usually have to do?  Look at the list below (if some items in it seem strange or unfamiliar - please wait a while with criticism and stay with us).  These are just examples of Jenkins-based workflows.  There are many other processes when working with other tools. <br><br>  The main thing - we see that each update ends with making changes to the configuration files and Git repositories.  These changes in Git cause the ‚ÄúGitOps Operator‚Äù to update the cluster: <br><br>  1. Workflow: " <i>Jenkins build - master branch</i> ". <br>  Task list: <br><br><ul><li>  Jenkins push'it tagged images in quay; </li><li>  Jenkins push'it config and Helm-charts in the master-storage bucket; </li><li>  The cloud function copies the config and charts from the master storage bucket to the master's Git repository; </li><li>  GitOps operator updates the cluster. </li></ul><br>  2. <i>Build Jenkins - release or hotfix thread</i> : <br><br><ul><li>  Jenkins push 'untagged images on Quay; </li><li>  Jenkins push'it config and Helm-charts in the staging-storage buck; </li><li>  The cloud function copies the config and charts from the staging storage bucket to the staging Git repository; </li><li>  GitOps operator updates the cluster. </li></ul><br>  3. <i>Build Jenkins - develop or feature branch</i> : <br><br><ul><li>  Jenkins push 'untagged images on Quay; </li><li>  Jenkins push'it config and Helm-charts in bucket develop-storage; </li><li>  The cloud function copies the config and charts from the develop-storage bucket to the develop git repository; </li><li>  GitOps operator updates the cluster. </li></ul><br>  4. <i>Adding a new client</i> : <br><br><ul><li>  The manager or administrator (LCM / ops) calls Gradle to initially deploy and configure network load balancers (NLB); </li><li>  LCM / ops commits a new config to prepare the deployment for updates; </li><li>  GitOps operator updates the cluster. </li></ul><br><h3>  GitOps Short Description </h3><br><ol><li>  Describe the desired state of the entire system using declarative specifications for each environment (in our history, the Bob team defines the entire system configuration in Git). <br><br><ul><li>  The git repository is the only source of truth regarding the desired state of the entire system. </li><li>  All changes to the desired state are made by commits to Git. </li><li>  All desired cluster parameters are also observable in the cluster itself.  Thus, we can determine whether the desired and observable states differ (converge, <i>converge</i> ) or differ ( <i>diverge</i> , <i>diverge</i> ). </li></ul></li><li>  If the desired and observed states are different, then: <br><br><ul><li>  There is a convergence mechanism that sooner or later automatically synchronizes the target and the observed state.  Inside the cluster, Kubernetes does this. </li><li>  The process starts immediately with a ‚Äúchange committed‚Äù alert. </li><li>  After some customizable period of time, a ‚Äúdiff‚Äù alert may be sent if the states are different. </li></ul></li><li>  Thus, all commits in Git cause checked and idempotent updates in the cluster. <br><br><ul><li>  A pullback is a convergence to a previously desired state. </li></ul></li><li>  Convergence is final.  About its occurrence testify: <br><br><ul><li>  No diff notifications for a certain period of time. </li><li>  A ‚Äúconverged‚Äù alert (for example, a webhook, a git writeback event). </li></ul></li></ol><br><h3>  What is divergence? </h3><br>  Once again: <i>all the desired properties of the cluster must be observed in the cluster itself</i> . <br><br>  Some examples of divergence: <br><br><ul><li>  Change in configuration file due to merging branches in git. </li><li>  Change in configuration file due to a commit in Git made by a GUI client. </li><li>  Multiple changes in the desired state due to PR in Git with the subsequent assembly of the container image and changes in the config. </li><li>  A change in cluster status due to an error, a conflict of resources leading to a ‚Äúbad behavior‚Äù, or simply a random deviation from the original state. </li></ul><br><h3>  What is the convergence mechanism? </h3><br>  A few examples: <br><br><ul><li>  For containers and clusters, the convergence mechanism is provided by Kubernetes. </li><li>  The same mechanism can be used to manage Kubernetes-based applications and constructs (for example, Istio and Kubeflow). </li><li>  The mechanism for managing the working interaction between Kubernetes, the image repositories and Git is provided by the <a href="https://github.com/weaveworks/flux">GitOps Weave Flux operator</a> , which is part of the <a href="https://cloud.weave.works/">Weave Cloud</a> . </li><li>  For base machines, the convergence mechanism must be declarative and autonomous.  In our experience, we can say that <a href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c">Terraform is</a> closest to this definition, but it still requires human control.  In this sense, GitOps extends the traditions of Infrastructure as Code. </li></ul><br>  GitOps combines Git with Kubernetes' excellent convergence mechanism, offering a model for exploitation. <br><br>  GitOps allows us to state: <i>automation and control can only be those systems that can be described and monitored</i> . <br><br><h3>  GitOps is intended for the entire cloud native stack (for example, Terraform, etc.) </h3><br>  GitOps is not just Kubernetes.  We want the entire system to be managed declaratively and use convergence.  By the entire system, we mean a set of environments that work with Kubernetes ‚Äî for example, ‚Äúdev cluster 1‚Äù, ‚Äúproduction‚Äù, etc. Each Wednesday includes machines, clusters, applications, as well as interfaces for external services that provide data, monitoring and t. n. <br><br>  Notice how important Terraform is in this case for the bootstrapping problem.  Kubernetes should be deployed somewhere, and using Terraform means that we can apply the same GitOps workflow to create the control layer that underlies Kubernetes and the applications.  This is a useful best practice. <br><br>  Much attention is paid to the application of GitOps concepts to the layers above Kubernetes.  At the moment there are GitOps-type solutions for Istio, Helm, Ksonnet, OpenFaaS and Kubeflow, as well as, for example, for Pulumi, which create a layer for developing applications for cloud native. <br><br><h2>  Kubernetes CI / CD: Comparing GitOps with Other Approaches </h2><br>  As stated, GitOps are two things: <br><br><ol><li>  The exploitation model for Kubernetes and cloud native, described above. </li><li>  The path to organizing a developer-centric application management environment. </li></ol><br>  For many, GitOps is primarily a Git push based workflow.  We like it too.  But that's not all: let's look at the CI / CD pipelines now. <br><br><h3>  GitOps provides continuous deployment (CD) under Kubernetes </h3><br>  GitOps offers a continuous deployment mechanism that eliminates the need for separate ‚Äúdeployment management systems‚Äù.  Kubernetes does all the work for you. <br><br><ul><li>  Updating an application requires updating in Git.  This is a transactional update to the desired state.  Deployment is then carried out within the cluster by Kubernetes itself based on the updated description. </li><li>  Due to the nature of Kubernetes, these updates are convergent.  This provides a mechanism for continuous deployment in which all updates are atomic. </li><li>  Note: <a href="https://cloud.weave.works/">Weave Cloud</a> offers a GitOps operator that integrates Git and Kubernetes and allows you to run a CD by matching the desired and current status of the cluster. </li></ul><br><h3>  No kubectl and scripts </h3><br>  You should avoid using Kubectl to update the cluster, and in particular - scripts for grouping kubectl commands.  Instead, using a GitOps Pipeline, a user can update his Kubernetes cluster via Git. <br><br>  Benefits include: <br><br><ol><li>  <b>Correctness</b>  The update group can be applied, converged and finally validated, which brings us closer to the goal of atomic deployment.  On the contrary, the use of scripts does not give any guarantees of convergence (more on this below). </li><li>  <b>Safety</b>  <a href="https://twitter.com/kelseyhightower/status/939003832805179392%3Flang%3Den">To quote</a> Kelsey Hightower: ‚ÄúRestrict access to the Kubernetes cluster to automation tools and administrators who are responsible for debugging it or maintaining its functionality.‚Äù  See also <a href="https://www.weave.works/blog/gitops-compliance-and-secure-cicd">my</a> security and compliance statement, and the <a href="https://medium.com/%40vesirin/how-i-gained-commit-access-to-homebrew-in-30-minutes-2ae314df03ab">Homebrew hacking article</a> by stealing credentials from a carelessly written Jenkins script. </li><li>  <b>User experience</b>  Kubectl exposes the mechanics of the Kubernetes object model, which is quite complex.  Ideally, users should interact with the system at a higher level of abstraction.  Here I refer again to Kelsey and recommend viewing <a href="http://superuser.openstack.org/articles/kubernetes-boring/">this summary</a> . </li></ol><br><h3>  Difference between CI and CD </h3><br>  GitOps improves existing CI / CD models. <br><br>  A modern CI server is a tool for orchestration.  In particular, it is a tool for orchestrating the CI pipelines.  These include build, test, merge to trunk, etc. CI servers automate the management of complex multi-step pipelines.  A common temptation is to create a script for the Kubernetes update set and execute it as part of the pipeline for push changes to the cluster.  Indeed, so do many experts.  However, this is not optimal, and this is why. <br><br>  CI should be used to make updates to the trunk, and the Kubernetes cluster must change itself based on these updates in order to manage the CD ‚Äúinternally‚Äù.  We call this the <a href="https://www.weave.works/blog/gitops-compliance-and-secure-cicd">CD pull model</a> , unlike the CI push model.  The CD is part of a <i>runtime orchestration</i> . <br><br><h3>  Why CI servers should not make a CD through direct updates to Kubernetes </h3><br>  <i>Do not use a CI server to orchestrate direct updates to Kubernetes as a set of CI tasks.</i>  <i>This is an anti-pattern, which we <a href="https://www.weave.works/blog/kubernetes-anti-patterns-let-s-do-gitops-not-ciops">already talked about</a> in our blog.</i> <br><br>  Let's go back to Alice and Bob. <br><br>  What problems did they encounter?  Bob's CI server applies the changes to the cluster, but if it drops in the process, Bob will not know what state the cluster is (or should be) and how to fix it.  The same is true if successful. <br><br>  Let's assume that the Bob team assembled a new image and then patched its deployments to deploy the image (all from the CI Pipeline). <br><br>  If the image is collected normally, but the pipeline falls, the team will have to find out: <br><br><ul><li>  Has the update unfolded? </li><li>  Are we launching a new build?  Will this lead to unnecessary side effects - with the ability to get two assemblies of the same unchanging image? </li><li>  Should we wait for the next update before running the build? </li><li>  What exactly went wrong?  What steps need to be repeated (and which ones are safe to repeat)? </li></ul><br>  <i>Organizing a Git-based workflow does not guarantee that the Bob team will not encounter these problems.</i>  <i>They may still be wrong with the commit push, tag, or some other parameter;</i>  <i>however, this approach is still much closer to an explicit all-or-nothing.</i> <br><br>  Summing up, this is why CI servers should not deal with a CD: <br><br><ul><li>  Update scripts are not always deterministic;  they are easy to make mistakes. </li><li>  CI servers do not converge to a declarative cluster model. </li><li>  Difficult to guarantee idempotency.  Users must understand the deep semantics of the system. </li><li>  More difficult to recover from a partial failure. </li></ul><br>  <i>A note about Helm: if you want to use Helm, we recommend combining it with a GitOps operator, such as <a href="https://www.weave.works/blog/managing-helm-releases-the-gitops-way">Flux-Helm</a> .</i>  <i>This will help ensure convergence.</i>  <i>Helm itself is neither deterministic nor atomic.</i> <br><br><h2>  GitOps as the best way to implement Continuous Delivery for Kubernetes </h2><br>  The team of Alice and Bob implements GitOps and discovers that it has become much easier to work with software products and maintain high performance and stability.  Let's finish this article with illustrations showing what their new approach looks like.  Consider that we are mainly talking about applications and services, however GitOps can be used to manage the entire platform. <br><br><h3>  Operation Model for Kubernetes </h3><br>  Look at the following chart.  It presents Git and the container image repository as shared resources for two orchestrated life cycles: <br><br><ul><li>  A continuous integration pipeline that reads and writes files to Git and can update the repository of container images. </li><li>  Pipeline Runtime GitOps, combining deploy with control and observability.  It reads and writes files to Git and can load images of containers. </li></ul><br><img src="https://habrastorage.org/webt/0h/mo/vs/0hmovs2jg182thgg_hxll6jabwk.png"><br><br><h3>  What are the main findings? </h3><br><ol><li>  <b>Separation of problems</b> : Please note that both pipelines can exchange data only by updating Git or the image repository.  In other words, there is a firewall between the CI and the runtime environment.  We call it the <i>immutability firewall</i> , because all the repository updates create new versions.  For more information on this topic, see slides 72-87 of <a href="https://www.slideshare.net/weaveworks/continuous-lifecycle-london-2018-event-keynote-97418556">this presentation</a> . </li><li>  <b>You can use any CI and Git server</b> : GitOps works with any components.  You can continue to use your favorite CI and Git servers, image repositories and test suites.  Almost all other tools for Continuous Delivery on the market require their own CI / Git server or image storage.  This may be a limiting factor in the development of cloud native.  In the case of GitOps, you can use familiar tools. </li><li>  <b>Events as an integration tool</b> : As soon as the data in Git is updated, Weave Flux (or the operator of the Weave Cloud) notifies about this runtime.  Whenever Kubernetes accepts a change set, Git is updated.  This provides a simple integration model for organizing workflows for GitOps, as shown below. </li></ol><br><img src="https://habrastorage.org/webt/xh/wn/83/xhwn83itzgegzohc4vyp2sprpe8.png"><br><br><h2>  Conclusion </h2><br>  GitOps provides the essential upgrade guarantee required for any modern CI / CD tool: <br><br><ul><li>  automation; </li><li>  convergence; </li><li>  idempotency; </li><li>  determinism. </li></ul><br>  This is important because it offers an exploitation model for cloud native developers. <br><br><ul><li>  Traditional tools for managing and monitoring systems are associated with operating teams that operate within the runbook <i>(set of routine procedures and operations - approx. Transl.)</i> , Tied to a specific deployment. </li><li>  In managing cloud native systems, monitoring tools are the best way to evaluate deployment results so that the development team can respond to them quickly. </li></ul><br>  Imagine a multitude of clusters scattered across different clouds and a multitude of services with your own teams and deployment plans.  GitOps offers a scale-invariant model to manage all this abundance. <br><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/456754/">GitOps: Comparison of Pull and Push Methods</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/434160/">Introducing the kubedog library to monitor Kubernetes resources</a> ‚Äù; </li><li>  ‚Äú <a href="https://habr.com/ru/company/flant/blog/449096/">We are expanding and complementing Kubernetes (review and video of the report)</a> ‚Äù. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/458878/">https://habr.com/ru/post/458878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458860/index.html">Tuning Linux kernel parameters to optimize PostgreSQL</a></li>
<li><a href="../458864/index.html">Competition developers bot for TamTam</a></li>
<li><a href="../458868/index.html">Noise in big data. Entropy-based analysis</a></li>
<li><a href="../458874/index.html">ASO Checklist: Text Optimization</a></li>
<li><a href="../458876/index.html">Friday Mini CTF</a></li>
<li><a href="../458880/index.html">Linux development in Windows with WSL and Visual Studio Code Remote</a></li>
<li><a href="../458882/index.html">Public performance. Briefly about the main thing</a></li>
<li><a href="../458884/index.html">A little about the standards of space communications</a></li>
<li><a href="../458886/index.html">The most useful reports of Mail.ru Design Conf √ó Dribbble Meetup 2019 according to True Engineering</a></li>
<li><a href="../458888/index.html">Summer droid meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>