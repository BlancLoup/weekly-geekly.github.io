<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Important aspects of the browser for developers. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Anton Raymer 
 In the first part of the article, based on my webinar, we looked at the general principles of the browser. In the second - I fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Important aspects of the browser for developers. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b3e/607/5a1/b3e6075a1fad4e378aa8d235b2e406d2.png" alt="image"><br>  <i>Author: Anton Raymer</i> <br>  In the <a href="https://habrahabr.ru/company/dataart/blog/304138/">first part of the</a> article, based on my webinar, we looked at the general principles of the browser.  In the second - I focused on important events: repaints and reflows - and on the principles of the event loop. <br><br><h5>  <b>Repaints and reflows</b> </h5><br>  When loading a page, if it is not empty, always executes at least one reflow and repaint.  Further, these events occur in the following cases: <br><br>  1. A part of the display tree needs recalculation, i.e., a node has a width, height, or coordinates.  The reflow event is triggered. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. As a result of the changes, a part of the displayed content should be updated.  It is, first of all, about properties of styles: background color, radius, etc. The repaint event is triggered. <br><br>  If reflow is called, after it the repaint is sure to be called.  But the opposite is not true: repaint can be called independently of the reflow. <br><br><h6>  <b>What actions cause reflow and / or repaint</b> </h6><a name="habracut"></a><br>  <b>1) Adding, updating, deleting a DOM node.</b>  Because at these events it is necessary to recalculate the display tree. <br><br>  Functions: <br>  insertAdjacentHTML (), appendChild (), insertBefore (), removeChild (), replaceChild (), remove (), append () / prepend (), after () / before (), replaceWith () <br><br>  Modifying DOM node properties: <br>  innerHTML, innerText, width, height, offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop / Left / Width / Height, clientTop / Left / Width / Height <br><br>  Querying DOM node properties (without modifying it): <br>  (offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop / Left / Width / Height, clientTop / Left / Width / Height <br><br>  Not only a function call and a change in DOM nodes can cause a reflow, but also a simple request for some properties, which, in particular, include all offset properties.  Why this requires layout, I will tell later. <br><br>  <b>2) Hiding the DOM node</b> using <b>display: none</b> (reflow and repaint) or <b>visibility: hidden</b> (only repaint, because there are no geometric changes). <br><br>  <b>3) Move, animate the DOM node.</b> <br>  The coordinates of the animated node of the display tree change, it can also cause resizing of other nodes. <br><br>  <b>4) Adding / modifying CSS</b> <br><br>  left, top, right, bottom, width, height <br>  If we want to change these css-properties, this will also cause a reflow. <br><br>  <b>5) Custom actions: resize the window (resize), change the font, scroll (scroll), drag and drop.</b> <br><br>  <b>6) Other</b> <br><br>  <i>- JS Scrolling</i> : Scrolling through the script and its corresponding properties. <br>  scrollByLines (), scrollByPages (), scrollHeight, scrollIntoView (), scrollIntoViewIfNeeded (), scrollLeft, scrollTop, scrollWidth <br><br>  <i>- Global methods and events for the window object:</i> <br>  getComputedStyle (), scrollBy (), scrollTo (), scrollX, scrollY <br><br>  <i>- Work with SVG</i> <br><br>  Example <br><br><pre><code class="html hljs xml">var bstyle = document.body.style; // cache bstyle.padding = "20px"; // reflow, repaint bstyle.border = "10px solid red"; // another reflow and a repaint bstyle.color = "blue"; // repaint only, no dimensions changed bstyle.backgroundColor = "#fad"; // repaint bstyle.fontSize = "2em"; // reflow, repaint // new DOM element - reflow, repaint document.body.appendChild(document.createTextNode('dude!'));</code> </pre> <br><br>  On the example of this script, we see that, if we change the padding, we have to recalculate the size of the rectangle.  Accordingly, reflow and repaint will be called.  If we change the border, it will be given a new width, so reflow and repaint will also be called.  And if we just changed the color of the border, background, or text, only repaint would have caused it.  Change the font size - reflow and repaint. <br><br>  The browser compiles together several requests for reflow and repaint, and performs them once, optimizing its work.  But some actions force the browser to execute these events immediately. <br><br>  Properties: <br>  1. offsetTop, offsetLeft, offsetWidth, offsetHeight <br>  2. scrollTop / Left / Width / Height <br>  3. clientTop / Left / Width / Height <br>  4. getComputedStyle (), or currentStyle in IE <br>  When requesting these properties, the browser needs to be repacked immediately, since they must return relevant information.  Therefore, whenever we request these properties, reflow and repaint occur. <br><br><h6>  <b>Code Optimization Tips for Repaint and Reflow Accounting</b> </h6><br>  <b>I. Do not change the element styles directly in the code, use css-classes to switch the appearance of the element.</b>  <b>Or use the cssText property.</b> <br><br><pre> <code class="html hljs xml">// bad var left = 10, top = 10; el.style.left = left + "px"; el.style.top = top + "px"; // better el.className += " theclassname"; // or when top and left are calculated dynamically... // better el.style.cssText += "; left: " + left + "px; top: " + top + "px;";</code> </pre><br><br>  Ways: <br>  1. Switch the CSS class.  Often, the appearance of a block or its state can be changed using a class.  This option is better than working directly with styles, because at least it will still cause reflow and repaint, but only once.  For example, in this case, in the first example, reflow and repaint will occur when the left event changes, and another reflow and repaint will occur when the top event changes.  But if we left and top were registered in the css-property in some class, then when adding this class, we would have one reflow and repaint instead of two. <br>  2. The same goes for the cssText property.  If we replace all the properties we need with dynamic ones in this text, then we will have one reflow and repaint. <br><br>  <b>Ii.</b>  <b>Combine manipulations with the DOM and perform them separately from the DOM update:</b> <br><br>  This can be done in several ways: <br>  ‚Ä¢ Use documentFragment, which is designed to optimize the work with DOM-nodes. <br>  ‚Ä¢ Create a clone of the DOM node, work with it, and when finished, replace the original DOM node with it.  It also optimizes the amount of reflow and repaint. <br>  ‚Ä¢ Use display: none (1 reflow, repaint), make 100 changes, restore the display (1 reflow, repaint).  This is better than calling one reflow on every change out of 100. <br><br>  <b>Iii.</b>  <b>Do not query calculated styles too often.</b>  This forces the browser to reflow and repaint.  We give an example of how to optimize the code in this case.  If you need to work with them, take them once, cache it in a variable (if there is any particular cycle, it‚Äôs better to work with the variable than to take properties each time) and work with it. <br><br><pre> <code class="html hljs xml">// no-no! for(big; loop; here) { el.style.left = el.offsetLeft + 10 + "px"; el.style.top = el.offsetTop + 10 + "px"; } // better var left = el.offsetLeft, top = el.offsetTop esty = el.style; for(big; loop; here) { left += 10; top += 10; esty.left = left + "px"; esty.top = top + "px"; }</code> </pre><br><br>  <b>Iv.</b>  <b>Think about the display tree and try to understand how many changes you are causing in it.</b> <br>  At this point I will focus in more detail, because the layout of the layout is different.  And one layout (reflow - if anyone has forgotten) can be much more labor-intensive than the other.  Consider this example. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"five red"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"four yellow"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"three green"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"two blue"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"one purple"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/993/d42/384/993d423849e0486eb3ef6fa2b7be79b6.jpg"><br>  Here is a small fragment of html.  Suppose we want to insert some DOM node in block 1. <br><br><img src="https://habrastorage.org/files/e14/abd/172/e14abd1724cd44b49430f2a2e3d5f347.jpg"><br><br>  Where it leads?  First, block 1 will have to recalculate its size, because it is not known what size a new inserted DOM node will be.  It is necessary to understand whether there is a need to make the width larger or smaller, etc. Changing the size of block 1 causes the block 2 to be recompiled. This causes the block 3, 4 and 5 to be recomposed. That is, we see that the operation is labor-intensive.  But everything will be different if we insert our DOM node, for example, after the fourth DOM node. <br><br><img src="https://habrastorage.org/files/f07/4ac/4e4/f074ac4e4a034000aad01c33f01c0c61.jpg"><br><br>  In this case, only the fifth DOM node will be updated, and the layout is thus much faster. <br>  Another good example is working with animation.  Suppose we want to animate the movement of a block of 1 to 200 pixels to the right.  If block 1 has position: static, that is, it is in the standard layout stream and is taken into account by other blocks, then changing its coordinates will re-arrange all of its ancestors.  If block 1 has position: absolute, it will exit the standard layout stream.  In this case, a change in its coordinates will only require rebuilding its individual ancestors.  Suppose that rectangle 5 has position: relative, and our rectangle 1 will be linked relative to block number 5. Then the change in block 1 of its coordinates will cause the layout of only the fifth DOM node. <br><br><h5>  <b>Event loop</b> </h5><br>  Consider the topic of asynchronous events and the Event loop, because, in my opinion, it often causes confusion. <br><br><img src="https://habrastorage.org/files/219/72d/34c/21972d34c7a84fc5be9bbe8e27aeb68f.jpg">  " <br><br>  What is an event loop?  This is an infinite loop that is implemented by the JS engine (V8, JavaScriptCore, etc.) and is designed to correctly execute the script, in particular, asynchronous events.  JS engine should not be confused with browser engines, which include Webkit and Gecko.  Also, do not confuse the event loop and the browser loop. <br><br>  On the client side, there are three types of asynchronous actions: <br>  1. Timer. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timerFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'timerFn'</span></span>); },<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre><br><br>  2. Ajax <br><pre> <code class="javascript hljs">$.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'someUrl'</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ajaxFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ajaxFn'</span></span>) } });</code> </pre><br><br>  3. Custom action. <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'something'</span></span>).on(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'clickFn'</span></span>) } )</code> </pre><br><br>  All of these asynchronous events deal with callbacks.  The callbacks mechanism ensures that asynchronous events work properly.  Let's look at a small piece of code.  We have a callback clickFn ().  It runs when we click on the item something.  Suppose at this time we have some very large code in the call stack.  clickFn will fall into the callbacks queue and will wait there for its turn. <br><br>  Suppose the following server response is returned from the server - the corresponding callback ajaxFn rises in turn.  After that, we have a timer, and its callback also falls into place in this queue.  By the way, the developer needs to understand that the time specified by him as a delay for the timer is an approximate number of milliseconds.  Because the browser will need to take into account all callbacks that are already queued in callbacks.  If, say, the callback clickFn and ajaxFn are executed within a millisecond each, the callback timer will be executed not after 100 milliseconds, as stated in the script, but after 102. However, in a normal situation such errors can be neglected. <br><br>  So, we have a lineup: <br><br><img src="https://habrastorage.org/files/54a/d92/13e/54ad9213ee5342338ad79652a8e336e4.jpg"><br><br>  When our Call Stack code has stopped executing, the browser can execute the first callback code from the callbacks queue.  Actually, clickFn is executed.  When it is executed, the place is freed.  It is followed by the next callback - ajaxFn, then - timerFn, and the queue is empty.  This is a simplified work loop event loop. <br><br>  The callbacks queue allows them to be executed not in parallel, but sequentially, one after another.  Since in the callback, we can work with the same variables, with the same DOM nodes, their parallel, i.e., asynchronous execution will cause conflicts.  In this case, the browser will not be able to figure out what exactly needs to be done. <br><br>  The next interesting point is that JavaScript is not a blocking language, despite allowing asynchronous events.  If we are running AJAX, the code following it will still be executed - it does not wait for a response from the server.  Of course, there may be exceptions in the form of alert events or synchronous AJAX, but, as you know, this is not the best practice. <br><br>  The same can be said about streams.  JavaScript runs in a single thread that works with the DOM.  By and large, there is no point in creating several parallel threads - their presence creates additional confusion and makes it difficult to work with the DOM.  But the way to organize parallel streams for the script does exist: use Web Worker - a technology that appeared in the html5 standard.  It has one limitation - Web Worker cannot work directly with the DOM and must interact with the main thread by exchanging messages. <br><br>  <b>Sources:</b> <br>  1. <a href="http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/">http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/</a> <br>  2. <a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/">http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/</a> <br>  3. <a href="http://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html">http://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html</a> </div><p>Source: <a href="https://habr.com/ru/post/304934/">https://habr.com/ru/post/304934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304908/index.html">How to start developing a large, atypical project. Practical guide</a></li>
<li><a href="../304918/index.html">Take a technical interview</a></li>
<li><a href="../304924/index.html">USB mass storage device and libopencm3</a></li>
<li><a href="../304926/index.html">Machine learning instead of DPI. Building a traffic classifier</a></li>
<li><a href="../304932/index.html">Data Protection - Modern Security Challenges</a></li>
<li><a href="../304936/index.html">About tasty and healthy food ESP8266 from batteries</a></li>
<li><a href="../304982/index.html">Sparrowdo is a simple configuration management tool.</a></li>
<li><a href="../304988/index.html">Signals and slots in PHP. Same as in Qt. Almost</a></li>
<li><a href="../304998/index.html">We play mp3 in our program and what can prevent it</a></li>
<li><a href="../305000/index.html">We are looking for vulnerabilities in code: theory, practice and prospects of SAST</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>