<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exchange Sorting Network with Batcher Merge</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sorting is one of the basic operations in data processing, which is used in the widest range of tasks. This article will discuss the exchange sorting ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exchange Sorting Network with Batcher Merge</h1><div class="post__text post__text-html js-mediator-article">  Sorting is one of the basic operations in data processing, which is used in the widest range of tasks.  This article will discuss <b>the exchange sorting network with Batcher merge</b> for parallel sorting of an array of arbitrary size. <br><br><img src="https://habrastorage.org/files/2e9/b3a/459/2e9b3a45980f421a8a48bf426fa9c6d4.png"><a name="habracut"></a><br><br><h1>  Introduction </h1><br>  <i>Sorting networks</i> are a type of sorting algorithms in which the order of execution of comparison operations and their number does not depend on the value of the elements of the array being sorted.  They allow you to create scalable parallel algorithms for sorting large amounts of data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In sorting networks, each element of the array is sequentially processed by <i>comparators</i> , which compare two elements and, if necessary, swap them. <br><br>  Sorting networks are usually depicted as follows.  Sorted array elements are indicated by horizontal data lines, and comparators are indicated by vertical lines that connect only two lines.  Figure 1 below shows the sorting network for three elements and an example of ordering an array <img src="https://habrastorage.org/files/639/c4b/1c5/639c4b1c58c14b1db645912f7fc37caf.png">  .  The value on each data line changes as the corresponding comparator triggers. <br><br><img src="https://habrastorage.org/files/70a/e67/d9a/70ae67d9af9949b59374c09b9f17c6a5.png"><br>  <i>Figure 1. Network sorting array of 3 elements.</i> <br><br>  At the moment, the method of building networks with the minimum time for an arbitrary number of inputs is unknown, so consider one of the fastest scalable sorting networks. <br><br><h1>  Exchange Sorting Network with Batcher Merge </h1><br>  Batcher networks are the fastest of scalable networks.  To build a network, we will use the following recursive algorithm. <br><br>  When sorting an array of <img src="https://habrastorage.org/files/d8f/09a/b77/d8f09ab7731746fd9bb34f9424adb973.png">  items with numbers <img src="https://habrastorage.org/files/0df/162/369/0df1623697414cb5aa7c847fa5d78c5a.png">  it should be divided into two parts: in the first leave <img src="https://habrastorage.org/files/9ba/90b/caf/9ba90bcaff0f4716ab5869b5491b966a.png">  items with numbers <img src="https://habrastorage.org/files/a72/79c/55b/a7279c55b365416aa3760e2da4b0e7ad.png">  and in the second <img src="https://habrastorage.org/files/041/a95/2f4/041a952f49eb418d83bbf459b600ec6f.png">  items with numbers <img src="https://habrastorage.org/files/0a9/f26/442/0a9f264424974c91bb4167d2e864e4b2.png">  .  Next, you should sort each of the parts (function <i><b>B</b></i> ) and combine the results of the sort (function <i><b>S</b></i> ). <br><br>  Consider these functions in more detail. <br><br>  <i><b>B</b></i> ( <i>array</i> ) - function of recursive construction of the network of sorting a group of lines  Recursively divides an array into two subarrays <i>up</i> and <i>down</i> from <img src="https://habrastorage.org/files/423/9d9/f0b/4239d9f0bae04bb0b6f2057b0963c87f.png">  and <img src="https://habrastorage.org/files/4ad/2f5/b70/4ad2f5b702a04cb6ae9180381946f4fd.png">  elements, respectively, and then calls the merge function <i><b>S</b></i> for these subarrays. <br><br>  <i><b>S</b></i> ( <i>up</i> , <i>down</i> ) - the function of recursive merging of two groups of lines.  The network of odd-even merge separately combines elements of arrays with odd numbers and separately with even ones, after which pairs of neighboring elements with numbers are processed with the help of the final group of comparators <img src="https://habrastorage.org/files/20b/7c8/0c4/20b7c80c45ad4b08a25870c76e58885d.png">  where <img src="https://habrastorage.org/files/8fb/334/c93/8fb334c930184a7cb885e7b8c87bfc6b.png">  - natural numbers from <img src="https://habrastorage.org/files/16c/4e3/d0c/16c4e3d0cef14d0bb9038d735fe8c1cd.png">  before <img src="https://habrastorage.org/files/48a/414/d46/48a414d460774bcd824119dafdaef9d7.png">  .  These pairs are written into the comparators array of <i>comparators</i> for further use. <br><br><div class="spoiler">  <b class="spoiler_title">Source code of functions B and S</b> <div class="spoiler_text">  Hereinafter we will give C code examples with the following conventions. <br><ol><li>  Arrays of type T are denoted as array (T). </li><li>  We <i>assume</i> that all the functions of working with arrays are defined in some <i>array.h</i> and do exactly what is written in the title. </li><li>  In addition to the <i>array_push ()</i> function: for vectors, it adds the transferred value to the end of the array, allocating memory if necessary;  for ordinary arrays, it writes the transferred value after the last one written, starting with zero. </li></ol><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">) procs_up, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">) procs_down)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> proc_count = array_size(procs_up) + array_size(procs_down); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (proc_count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (proc_count == <span class="hljs-number"><span class="hljs-number">2</span></span>) { array_push(&amp;comparators, ((<span class="hljs-keyword"><span class="hljs-keyword">pair_t</span></span>){ procs_up[<span class="hljs-number"><span class="hljs-number">0</span></span>], procs_down[<span class="hljs-number"><span class="hljs-number">0</span></span>] })); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_up_odd = array_new(array_size(procs_up) / <span class="hljs-number"><span class="hljs-number">2</span></span> + array_size(procs_up) % <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_down_odd = array_new(array_size(procs_down) / <span class="hljs-number"><span class="hljs-number">2</span></span> + array_size(procs_down) % <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_up_even = array_new(array_size(procs_up) / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_down_even = array_new(array_size(procs_down) / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_result = array_new(array_size(procs_up) + array_size(procs_down), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array_size(procs_up); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span>) { array_push(&amp;procs_up_even, procs_up[i]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { array_push(&amp;procs_up_odd, procs_up[i]); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array_size(procs_down); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span>) { array_push(&amp;procs_down_even, procs_down[i]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { array_push(&amp;procs_down_odd, procs_down[i]); } } S(procs_up_odd, procs_down_odd); S(procs_up_even, procs_down_even); array_concatenate(&amp;procs_result, procs_up, procs_down); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; array_size(procs_result); i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { array_push(&amp;comparators, ((<span class="hljs-keyword"><span class="hljs-keyword">pair_t</span></span>){ procs_result[i], procs_result[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] })); } array_delete(&amp;procs_up_odd); array_delete(&amp;procs_down_odd); array_delete(&amp;procs_up_even); array_delete(&amp;procs_down_even); array_delete(&amp;procs_result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">) procs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array_size(procs) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_up = array_new(array_size(procs) / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) procs_down = array_new(array_size(procs) / <span class="hljs-number"><span class="hljs-number">2</span></span> + array_size(procs) % <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); array_copy(procs_up, procs, <span class="hljs-number"><span class="hljs-number">0</span></span>, array_size(procs_up)); array_copy(procs_down, procs, array_size(procs_up), array_size(procs_down)); B(procs_up); B(procs_down); S(procs_up, procs_down); array_delete(&amp;procs_up); array_delete(&amp;procs_down); }</code> </pre> <br>  Code of functions with normal syntax highlighting on <a href="">github</a> . </div></div><br>  We give examples. <br><br><h2>  First example. </h2><br>  Figure 2 below shows the network of sorting an array of 6 elements, formed as a result of a call to function <i><b>B</b></i> ( <img src="https://habrastorage.org/files/12f/e23/f38/12fe23f38fbc458ca2cf6c74b1e3248b.png">  ). <br><br><img src="https://habrastorage.org/files/0a2/9ee/8e7/0a29ee8e75a140f6b9365f53ffd7373d.png"><br>  <i>Figure 2. Batcher's network of sorting an array of 6 elements.</i> <br><br>  The list of comparators in the order of their formation by the function S will be as follows: <br><ol><li>  (2, 3) </li><li>  (12), </li><li>  (2, 3) </li><li>  (5, 6), </li><li>  (4, 5) </li><li>  (5, 6), </li><li>  (14), </li><li>  (3, 6), </li><li>  (3, 4), </li><li>  (2, 5) </li><li>  (2, 3) </li><li>  (4, 5). </li></ol><br><h2>  The second example. </h2><br>  Consider an example of combining two ordered arrays: <img src="https://habrastorage.org/files/71f/c66/357/71fc6635775d49bd8c3194268b34151b.png">  and <img src="https://habrastorage.org/files/2c2/538/211/2c25382118d745a9997c145334b02fef.png">  .  In Figure 3 below, vertical blocks denote merge networks that process odd and even rows of arrays. <br><br>  As a result of combining elements with odd numbers <img src="https://habrastorage.org/files/235/8ee/4ac/2358ee4ac1ae4a33b7b8a85862e68fea.png">  and <img src="https://habrastorage.org/files/4f4/dd6/772/4f4dd6772cd742f1a44e9eae2c079fac.png">  received ordered array <img src="https://habrastorage.org/files/f37/616/b3b/f37616b3bb1f49889f29a0df3f721c32.png">  . <br><br>  As a result of combining elements with even numbers <img src="https://habrastorage.org/files/cb1/0e2/814/cb10e2814d824e7784b34ea9ad765fe4.png">  and <img src="https://habrastorage.org/files/9a6/bdb/67b/9a6bdb67ba99420d8b069bb81a3adb99.png">  received ordered array <img src="https://habrastorage.org/files/511/74e/d93/51174ed9305f4ef7869eb6dcc8f5c4da.png">  . <br><br>  As a result of the execution of the last group of comparators, a completely sorted array is obtained: <img src="https://habrastorage.org/files/e15/cd9/ce5/e15cd9ce5e2f426a8b5ced81f77e6484.png">  . <br><br><img src="https://habrastorage.org/files/53c/5e2/365/53c5e2365bcd4eb38cc6cf52feab1395.png"><br>  <i>Figure 3. The Batcher odd-even merge network.</i> <br><br><h1>  Sort large arrays </h1><br>  In case the size of the array exceeds the number of processors <img src="https://habrastorage.org/files/254/9ca/092/2549ca092c8d4dfaaca46dd6f2b6ab5f.png">  , on each processor we will store by <img src="https://habrastorage.org/files/466/133/bd8/466133bd8fa640488320aaa15b7837ca.png">  array elements.  Sorting will be done in two stages. <br><ol><li>  <b>Sort on each processor array length</b> <img src="https://habrastorage.org/files/284/c4f/f57/284c4ff57bca46b987edff1e42d844d6.png">  <b>.</b>  Each processor, independently of the others, performs the process of ordering the elements of the array.  Sorting is performed by the best available sequential algorithms. </li><li>  <b>Merging each sorted array</b> according to the schedule specified by the sorting network used <img src="https://habrastorage.org/files/254/9ca/092/2549ca092c8d4dfaaca46dd6f2b6ab5f.png">  elements, that is, at this stage, global sorting is performed. </li></ol><br>  Consider the second stage in more detail.  In Figure 4 below, each data line corresponds to one <i>processor</i> , and each comparator corresponds to a <i>merge comparator</i> . <br><br><img src="https://habrastorage.org/files/39a/f8d/2a7/39af8d2a70904259a671a910976a93bf.png"><br>  <i>Figure 4. Example of array sorting {8, 7, 4, 3, 9, 2, 5, 1, 2, 4, 0, 6}, n = 12, p = 4.</i> <br><br>  <i>The merge comparator</i> takes as input two arrays of the same length and redistributes the elements into two new arrays so that the first one contains the elements with smaller values ‚Äã‚Äãand the second one with the larger ones. <br><br>  In case of using distributed memory, the stage of data transfer between processors is added: <br><ul><li>  each of the processors sends its own fragment of the array to the processor connected to another input of the comparator, </li><li>  a processor with a lower number selects from two fragments <img src="https://habrastorage.org/files/022/581/f04/022581f04ffc459a889a85d55cbff194.png">  the smallest elements, and the processor with a large number - <img src="https://habrastorage.org/files/022/581/f04/022581f04ffc459a889a85d55cbff194.png">  largest items. </li></ul><br>  If necessary, we will supplement the array with fictitious zero elements so that the length of the sorted processor is a multiple of the number of processors. <br><br>  Thus, the first stage can be written as: <br><div class="spoiler">  <b class="spoiler_title">Source code of the first stage</b> <div class="spoiler_text">  For simplicity, we will use the built-in sort function <i>qsort ()</i> .  The size of the sorted array on each processor is defined as: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> proc_count; <span class="hljs-comment"><span class="hljs-comment">//   int elems_count; //   int elems_count_new = elems_count + (elems_count % proc_count ? proc_count - elems_count % proc_count : 0); int elems_per_proc_count = elems_count_new / proc_count;</span></span></code> </pre> <br>  Then the first stage consists of just one line of code: <br><pre> <code class="cpp hljs">qsort(elems_result, elems_per_proc_count, array_item_size(elems_result), compare_uint32);</code> </pre> <br>  <a href="">On the githaba.</a> </div></div><br>  And second: <br><div class="spoiler">  <b class="spoiler_title">Source code of the second stage</b> <div class="spoiler_text">  As already mentioned, this stage consists in the sequential processing of each comparator from the <i>comparators</i> array.  The processor from the first input of the comparator sends its array to the second input, the other processor arrives similarly, with the result that each processor has two arrays: its own ( <i>elems_result</i> ) and another processor ( <i>elems_current</i> ). <br><br>  Then on each processor a third array is formed ( <i>elems_temp</i> ), consisting of the smallest elements (for the first processor) or the largest (for the second processor). <br><br>  After that, the <i>elems_temp</i> array <i>is</i> written in place of the <i>elems_result</i> array. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array_size(comparators); i++) { <span class="hljs-keyword"><span class="hljs-keyword">pair_t</span></span> comparator = comparators[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rank == comparator.a) { MPI_Send(elems_result, elems_per_proc_count, MPI_UNSIGNED, comparator.b, <span class="hljs-number"><span class="hljs-number">0</span></span>, MPI_COMM_WORLD); MPI_Recv(elems_current, elems_per_proc_count, MPI_UNSIGNED, comparator.b, <span class="hljs-number"><span class="hljs-number">0</span></span>, MPI_COMM_WORLD, &amp;status); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res_index = <span class="hljs-number"><span class="hljs-number">0</span></span>, cur_index = <span class="hljs-number"><span class="hljs-number">0</span></span>, tmp_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; tmp_index &lt; elems_per_proc_count; tmp_index++) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result = elems_result[res_index]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> current = elems_current[cur_index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &lt; current) { elems_temp[tmp_index] = result; res_index++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { elems_temp[tmp_index] = current; cur_index++; } } swap_ptr(&amp;elems_result, &amp;elems_temp); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rank == comparator.b) { MPI_Recv(elems_current, elems_per_proc_count, MPI_UNSIGNED, comparator.a, <span class="hljs-number"><span class="hljs-number">0</span></span>, MPI_COMM_WORLD, &amp;status); MPI_Send(elems_result, elems_per_proc_count, MPI_UNSIGNED, comparator.a, <span class="hljs-number"><span class="hljs-number">0</span></span>, MPI_COMM_WORLD); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start = elems_per_proc_count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res_index = start, cur_index = start, tmp_index = start; tmp_index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; tmp_index--) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result = elems_result[res_index]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> current = elems_current[cur_index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &gt; current) { elems_temp[tmp_index] = result; res_index--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { elems_temp[tmp_index] = current; cur_index--; } } swap_ptr(&amp;elems_result, &amp;elems_temp); } }</code> </pre> <br>  <a href="">On the githaba.</a> </div></div><br><h1>  I / O Features </h1><br>  For the input, we will use the function <i>MPI_File_read_ordered ()</i> , which sequentially reads from the file equal fragments of the array for each processor.  If there is not enough data from the file, it will not overwrite the dummy zeros with which the array is initialized. <br><br>  For output, we will use the similar function <i>MPI_File_write_ordered ()</i> , but for each processor it is necessary to calculate how many elements it should write to the file.  Such a need arises if the length of the array being sorted was not a multiple of the number of processors. <br><br>  Consider more. <br><div class="spoiler">  <b class="spoiler_title">Source code output</b> <div class="spoiler_text">  The idea is as follows.  Suppose we have an array of 15 elements, 3 elements per processor (variable <i>elems_per_proc_count</i> ) (Figure 5 below).  You must skip the first 5 items ( <i>skip</i> variable). <br><br><img src="https://habrastorage.org/files/15f/eed/68e/15feed68e7b84d399ac22a4fc529d8f8.png"><br>  <i>Figure 5. An example of the distribution of an array of processors.</i>  <i>It is necessary to display the circled blue elements.</i> <br><br>  For each processor, we will calculate the offset (variable <i>print_offset</i> ) relative to the beginning of the array from which to start output, as well as the number of output elements (variable <i>print_count</i> ). <br><br>  Three cases are possible. <br><ol><li>  <b>The processor does not output anything,</b> that is, the offset is zero, the number of <b>outputs</b> is zero. </li><li>  <b>The processor outputs some of its elements,</b> that is, the offset is the number of elements to be skipped, the number of output is the difference <i>elems_per_proc_count</i> and the offset. </li><li>  <b>The processor outputs all its elements of the array,</b> i.e., the offset is zero, the number of output is <i>elems_per_proc_count</i> . </li></ol><br>  Consider the calculation of the displacement.  Obviously, the offset is always zero, except for the processor, which ends the number of elements to be skipped.  The number of such a processor is calculated as the ratio of <i>skip</i> to <i>elems_per_proc_count</i> with a drop of the fractional part, and the number of elements that do not need to be output to this processor, as the remainder of the division in the specified ratio. <br><br>  Thus, after grouping all the conditions, we get an expression for <i>print_offset</i> . <br><br>  Using the code below, it is easy to understand the formula for calculating the number of elements. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,    . int skip = elems_count_new - elems_count; //  ,       . int print_offset = (skip / elems_per_proc_count == rank) * (skip % elems_per_proc_count); //    . int print_count = (skip / elems_per_proc_count &lt;= rank) * elems_per_proc_count - print_offset; //         0. MPI_File_write_ordered(output, &amp;elems_count, rank == 0, MPI_UNSIGNED, &amp;status); //            . MPI_File_write_ordered(output, (unsigned char *)elems_result + print_offset * array_item_size(elems_result), print_count, MPI_UNSIGNED, &amp;status);</span></span></code> </pre> <br>  <a href="">On the githaba.</a> </div></div><br><h1>  Testing a 32-bit application </h1><br>  Files with random unsigned integers for a different number of elements were generated, after which the result of the program was compared with a reference response obtained using the standard <i>qsort ()</i> function. <br><br>  The table below compares the speed of the sequential algorithm with the sort of Batcher on a different number of processors. <br><br>  On a stationary machine (Intel Core i7-3770 (4 cores, 8 threads), 8 GB RAM): <br><img src="https://habrastorage.org/files/522/3d2/f73/5223d2f73f394d7997aebe51caa548ba.png"><br>  (Dashes - errors in allocating the required amount of memory). <br><br><h1>  Source </h1><br>  The source code for this sorting is available on GitHub at the following link: <a href="https://github.com/zodinyac/batcher-sort">https://github.com/zodinyac/batcher-sort</a> .  You can also find a test generator and other auxiliary utilities described in <i>README.md</i> . <br><br><h1>  References </h1><br><ol><li>  Yakobovskiy M.V. Parallel Algorithms for Sorting Large Volumes of Data. </li><li>  Yakobovskiy MV Introduction to parallel methods for solving problems. </li><li>  Tyutlyaeva EO. Integration of the Batcher parallel sorting algorithm and the active data storage system. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/275889/">https://habr.com/ru/post/275889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275877/index.html">Games and porn in virtual reality: what you need to know on the eve of the launch of Oculus Rift, PlayStation VR, HTC Vive</a></li>
<li><a href="../275881/index.html">OpenJDK 9 is finally ported to iOS</a></li>
<li><a href="../275883/index.html">Alexey Ragozin and Artyom Panasyuk on distributed load testing on jug.msk.ru</a></li>
<li><a href="../275885/index.html">Video of the best reports of the JPoint 2015 Java Conference - Part 2</a></li>
<li><a href="../275887/index.html">Microsoft has posted on Github CNTK toolkit for deep learning</a></li>
<li><a href="../275891/index.html">The book "Creating microservices"</a></li>
<li><a href="../275895/index.html">Can Kingdom and Reliable Systems</a></li>
<li><a href="../275897/index.html">Top your questions to our person</a></li>
<li><a href="../275899/index.html">ABAP: Handsome # 2</a></li>
<li><a href="../275901/index.html">Advanced Oracle Troubleshoot Session - PGA / UGA Memory Fragmentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>