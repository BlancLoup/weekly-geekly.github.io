<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bubbles, caches, and transition predictors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was written based on a curious post , a brief comment by its author, to which I was encouraged to understand what was going on in more de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bubbles, caches, and transition predictors</h1><div class="post__text post__text-html js-mediator-article"> This article was written based on a curious <a href="http://blog.gamedeff.com/%3Fp%3D268">post</a> , a brief comment by its author, to which I was encouraged to understand what was going on in more detail.  It is proposed to compare two variations of the bubble sorting algorithm.  The first one is the usual bubble, with a little optimization ‚Äî the inner loop can be completed a little earlier, knowing that the rest of the array is already sorted: <br> <code><font color="Blue">for</font> (i=0; i&lt;N; i++) <br> <font color="Blue">for</font> (j=0; j&lt;N - (i+1); j++) <br> <font color="Blue">if</font> (a[j] &gt; a[j+1]) <br> swap(a[j], a[j+1]);</code> <br> <br>  In the second variant, the internal loop passes through another part of the array, however, this variant is algorithmically equivalent to the first (details below): <br> <code><font color="Blue">for</font> (i=0; i&lt;N-1; i++) <br> <font color="Blue">for</font> (j=i; j&gt;=0; j--) <br> <font color="Blue">if</font> (a[j] &gt; a[j+1]) <br> swap(a[j], a[j+1]);</code> <br> <br>  We run ( <a href="http://pastebin.com/f66ef25e1">code</a> ), for example, for N = 100,000 on an array of ints, and we get about 30 seconds in the first case, and less than 10 seconds in the second, that is, the difference <b>is 3 times</b> !  Where, then, does such a difference come from? <br><a name="habracut"></a><br>  To begin with, we check that the matter is not in compiler optimizations.  It is easy to verify this by generating and comparing the assembler codes in both cases.  Or you can turn off the optimization.  Or you can rewrite the code in assembler (for example, using assembly inserts).  In any case, the effect persists. <br><br>  Further, how to check that both options are equivalent?  For example, you can output the compared values ‚Äã‚Äãof a [j], a [j + 1] and the corresponding value of j, sort the resulting list, and then compare them line by line (of course, it is reasonable to do this for small N).  It turns out that the lists are the same, which means that in both cases the same comparisons and the same assignments are made, and the difference is only in the order in which these operations are performed. <br><br>  Yes, some will say, but we know other examples, when the time for their execution depends on the order of operations.  For example, there is a difference between sequential and random memory access, even if we read the same data.  In this case, the fact is that accessing the memory is quite a long process, and the processor practically stands idle at the time when it could execute hundreds of instructions.  However, with sequential access, these delays are amortized at the expense of processor caches, where a large amount of data is immediately copied, and access to which is much faster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But note that in our case the amount of data is not that large, 100,000 ints is only 400Kb, while modern processors have L2 caches of megabytes and more.  In addition, in both cases, we consistently refer to the elements of the array, so the memory access delays are again depreciated.  Finally, if you decrease N, you still see the same difference 3 times.  Therefore, here the caches, although they play their part, are not the main cause of the observed effect. <br><br>  To understand what is happening and check the previous statement, we will analyze both options using processor counters.  These counters count the number of instructions executed, accesses to caches, the number of branches that occurred, and many other parameters.  To take the readings, I used Intel's (trial version - yes, do not wait for freebies, here you aren‚Äôt Google!) VTune Performance Analyzer, but there are other ways.  We start, the analysis is performed, and we get at the output (P4 Prescott, L1 16Kb, L2 2Mb, the first option vs. the second): <br><br>  Executed instructions: 40 vs.  35 (¬∑ 10 <sup>9</sup> ) <br>  L2 cache slip: 1.1 vs.  1.8 (¬∑ 10 <sup>9</sup> ) <br>  L1 cache misses: 1.6 vs.  0.4 (¬∑ 10 <sup>6</sup> ) <br><br>  So what follows from this?  First, the first-level cache misses per instruction are very few, and therefore the corresponding delays are not so significant.  Secondly, the second level cache misses are still quite a lot, but it turns out that in the second variant misses occur even more often than in the first!  The results on other processors may be slightly different (in particular, there may be another L3 cache, which is not on my processor), but I think that the overall picture will remain about the same. <br><br>  So, it's not about caches.  But let's look at additional analysis results: <br><br>  Number of transitions (branches, branches): 1.0 vs.  1.0 (¬∑ 10 <sup>10</sup> ) <br>  Conversion predictor errors (mispredicted branches): <b>0.16 vs.</b>  <b>0.00009</b> (¬∑ 10 <sup>10</sup> ) <br><br>  A small digression for those who, like I was until recently, are not familiar with such an interesting thing as a <a href="http://en.wikipedia.org/wiki/Branch_predictor">branch predictor</a> - oddly enough, I did not find topics about it in Habr√©. <br><br>  You probably know that modern processors at the expense of the <a href="http://en.wikipedia.org/wiki/Instruction_pipeline">instruction pipeline</a> ( <a href="http://en.wikipedia.org/wiki/Instruction_pipeline">instruction pipeline</a> ) execute not one instruction after another sequentially, but several instructions at once in parallel, and then combine the results.  However, the sequence of instructions may depend on the results of conditional transitions, as in our example - if a [j]&gt; a [j + 1], then the elements are rearranged, but not otherwise.  Here the predictor of transitions comes to the rescue, who tries to guess whether the transition will be executed or not, and in accordance with this, instructions for the pipeline are chosen. <br><br>  The predictor of transitions can be static and dynamic.  Dynamic tries to predict the transition based on the history of previous transitions.  If this story is not yet recruited, a static predictor is used, but in our case it is not important.  On the subject of static and dynamic predictors, I liked <a href="http://softwarecommunity.intel.com/articles/eng/3431.htm">this article</a> (English), although in reality everything is, of course, more complicated. <br><br>  How important is the predictor of transitions and its errors?  Wikipedia reports that on modern processors the delay is dozens of cycles, which is <s>not so much</s> in itself ( <a href="https://habrahabr.ru/users/leotsarev/" class="user_link">leotsarev</a> ).  However, in addition, the absence of such errors can mean a very good benefit, since due to the long length of the pipeline, the processor can ‚Äúlook‚Äù many instructions forward.  You can verify this with the following code: <br><br> <code><font color="Blue">for</font> (i=0; i&lt;T; i++) <br> <font color="Blue">for</font> (j=0; j&lt;M; j++) <br> <font color="Blue">if</font> (p[j]) ++;</code> <br> <br>  Here, p [] is an array that determines whether to perform a conditional transition or not, and the counter simply serves to distinguish between these two events.  If all p [j] values ‚Äã‚Äãare the same, then after several iterations the transition is already well predicted.  If p [j] is generated in some, for example, periodic way, then the predictability of the transition will depend on the predictor implementation.  But if the array is randomly filled, it is impossible to predict the next transition, under certain restrictions.  It should be noted that the size of the array M is important - if the array is too large, it can be poorly cached, and if it is too small, then the transition can be predicted. <br><br>  On my computer, the execution time of this code varies 4-6 times depending on the degree of randomness of the array filling.  If you perform a more complex operation than increasing the counter, for example, rearranging the elements of an array, the difference decreases, but not much.  Thus, the presence or absence of errors of the predictor of transitions can lead to a difference in the execution time several times, as observed in our original problem. <br><br>  According to the above analysis results, in the first sorting scenario, predictor errors occur in 16% of cases, and in the second, 1000 times less.  Why is this so?  This can be understood by considering how the sorting takes place in both cases. <br><br>  In the first case, for small i, the inner loop through j runs almost to the end of the array, without touching only the sorted ‚Äútail‚Äù.  Initially, the data in this part of the array are unordered, and therefore the condition a [j]&gt; a [j + 1] is performed almost randomly.  As i increases, some ordering of elements takes place due to permutations, but still a large amount of randomness remains ( <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B9%25D0%25BB:Bubble_sort_animation.gif">animation</a> ).  Therefore, it is rather difficult to predict the transition, which leads to a large number of predictor errors. <br><br>  In the second case, with i = 0, the inner loop only sorts a [0] and a [1], with i = 1, it adds a [2], and so on.  In fact, this is <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">sorting by inserts</a> (but not binary) - at the i-th step, the element a [i + 1] is inserted into the already sorted subarray a [0..i] ( <a href="http://en.wikipedia.org/wiki/File:Insertion_sort_animation.gif">animation</a> ).  Since the element is inserted from the end of the subarray, in most cases, this element will be sequentially moved to the required position in the array, and the value of the condition p [j]&gt; p [j + 1] will be the same before it reaches it.  Thus, after several iterations, the transition is easy to predict what the transition predictor seems to be overwhelmingly pleased with. </div><p>Source: <a href="https://habr.com/ru/post/73726/">https://habr.com/ru/post/73726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../73718/index.html">Free web messenger for sites</a></li>
<li><a href="../73720/index.html">New home network</a></li>
<li><a href="../73721/index.html">Neat: very tricky scam</a></li>
<li><a href="../73722/index.html">president.ru</a></li>
<li><a href="../73724/index.html">Metro 2033 will be released in February</a></li>
<li><a href="../73727/index.html">Thunderbird 3 Beta 4. Faster, easier, smarter</a></li>
<li><a href="../73728/index.html">Cloud computing and opera mini</a></li>
<li><a href="../73729/index.html">Twitter Peek - a mobile device for working with Twitter, only with Twitter</a></li>
<li><a href="../73733/index.html">Transferring several parameters through MooTools Autocompleter</a></li>
<li><a href="../73734/index.html">Infected several sites on Mchost</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>