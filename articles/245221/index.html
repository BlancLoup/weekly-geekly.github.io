<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quickhull algorithm for finding a convex hull</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As the definition says, the convex hull of some set  - this is the smallest convex set  containing many  . The convex hull of a finite set of pairwise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quickhull algorithm for finding a convex hull</h1><div class="post__text post__text-html js-mediator-article"> As the definition says, the <i>convex hull of</i> some set <img src="https://habrastorage.org/files/eeb/2cf/9be/eeb2cf9be1334810ace291fafe932336.png">  - this is the smallest convex set <img src="https://habrastorage.org/files/287/2d8/d4e/2872d8d4ee9b4bab8c26925725f47cf4.png">  containing many <img src="https://habrastorage.org/files/eeb/2cf/9be/eeb2cf9be1334810ace291fafe932336.png">  .  The convex hull of a finite set of pairwise distinct points is a polyhedron. <br>  To implement the one-dimensional case of the Quickhull algorithm, the <a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"><i>std :: minmax_element</i></a> function is <a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"><i>appropriate</i></a> .  In the network you can find many implementations of the Quickhull algorithm for a flat case.  However, for the case of an arbitrary dimension, only one heavyweight implementation from <a href="http://qhull.org/">qhull.org is immediately available</a> . <br><a name="habracut"></a><br>  In brackets next to the terms, I will give a translation into English (in the style of Tu'bo, sorry).  This can be useful for those who are not familiar with the terms and will read the English texts on the links, or decide to deal with the texts of the source code. <br>  The ‚Äúcanonical‚Äù implementation mentioned above is written in C (there is C ++ binding), it has been used for a long time and widely (as part of the GNU Octave and MATLAB packages) and, therefore, is well tested.  But if you decide to isolate code that relates only to one Quickhull algorithm, you will encounter difficulties.  For the simplest applications, I would like to be able to get by with something more compact.  Having a little tried, I wrote my own implementation ( <a href="https://github.com/tomilov/quickhull">https://github.com/tomilov/quickhull</a> ): this is the only class, without dependencies.  About 750 lines in total. <br><br><h3>  Geometric concepts. </h3><br>  Starting to work with multidimensional entities, you understand that some analogies with the usual two-dimensional and three-dimensional objects are valid.  It is necessary to streamline knowledge: introduce some new terms and clarify the relationship between them. <br>  For a programmer, geometric objects are primarily data structures.  To begin with, I will give geometric definitions (not very strict).  Further in the text will be given descriptions of the corresponding data structures, convenient to store data and operate with them quite effectively. <br>  Denote the dimension of the space as <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  . <br><br><ul><li>  Simplex (English simplex) is set <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  affinely independent (English affinely independent) point.  I will explain further affinity independence below.  These points are called vertices (eng. Vertex, pl. Vertices). </li><li>  The polyhedron (syn. Polytopic, polyhedron, polyhedron, English polytope, polyhedron) is defined at least <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  affinely independent point (vertex);  simplex (English simplicial polytope) - the simplest case <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  -dimensional body, polyhedra with a smaller number of vertices will necessarily have zero <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  -dimensional volume. </li><li>  Parallelotope (English parallelotope) is a generalization of a flat parallelogram and a volume parallelepiped.  For simplex you can build <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  corresponding parallelotops (they will all have the same volume, equal to <img src="https://habrastorage.org/files/bb6/13a/f39/bb613af39a1c467cbef4314bc67f310b.png">  to the volumes of the simplex), taking as the generators (vectors) of the parallelotope the vectors that go from one fixed vertex to the others <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  tops. </li><li>  I will not give here the concept of a convex polyhedron (born convex polytope, convex polyhedron), your intuitive idea of ‚Äã‚Äãit will fit.  A simplex, as a special case of a polyhedron, is always convex. </li><li>  I will not give the concept of a plane either.  Just note that it has one less dimension than the space into which it is embedded. </li><li>  Simplicial face (born simplicial facet) is defined <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  affinely independent points (vertices).  Further, we will speak only of simplicial objects (except for a convex polyhedron), so I will omit the definition of ‚Äúsimplicial‚Äù.  Many of the assertions will continue to be valid only for non-degenerate (all points are pairwise different) cases of simplicial geometric objects. </li><li>  Edge (English ridge) is defined as the intersection of two faces and has <img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png">  the top.  Two faces can have only one common edge.  One facet, therefore, may have <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  neighbors through ribs. </li><li>  Peak (eng. Peak) is determined <img src="https://habrastorage.org/files/0b4/846/fd6/0b4846fd6de449a4b1aad5e1ad84255b.png">  points.  Here, an intuitive analogy with three-dimensional space can float, since the concept of a peak and a vertex do not coincide, but we will not operate with such objects.  A face can have any number of neighboring faces through the peak, hence we can conclude that storing the graph of adjacency of faces through peaks is expensive and in memory and at the cost of maintaining the relevance of the data structures during any transformations. </li></ul><br>  The face of a polyhedron, its boundaries, the boundaries of its boundaries, etc.  in English are called face.  Dame <a href="http://eusebeia.dyndns.org/4d/vis/02-analogy">link</a> to a good resource, where it is logically justified that in <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  dimensional space visible or observable objects may be only <img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png">  -dimensional objects, i.e. boundaries <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  -dimensional objects.  The English term facet is precisely the observed face.  Straight (born straight line) - is always a one-dimensional entity.  The point (vertex) can be considered zero-dimensional in this gradation. <br>  Dealing with some set of <img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png">  points, we can proceed to the consideration of the corresponding set of <img src="https://habrastorage.org/files/1c9/c5f/677/1c9c5f67724e44f288da709192edc19d.png">  vectors by subtracting one of the points from all the others.  Thus, we will, as it were, designate this point as the origin of coordinates.  If all points lie in the same plane, then the plane is displaced in such a way that it begins to pass through the origin.  Affinity independence <img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png">  points is performed when linear independence is performed <img src="https://habrastorage.org/files/1c9/c5f/677/1c9c5f67724e44f288da709192edc19d.png">  th corresponding vector.  The definition of linear independence of vectors is probably already familiar to you.  So in <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  -dimensional space can not choose more <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  points so that they are all affinely independent.  Let me explain this: in a three-dimensional space, a triangle (the face of a three-dimensional simplex - a tetrahedron) is defined by three points (not lying on one straight line, of course);  a single plane passes through these three points;  any point of this plane added to the set of three vertices of the triangle will transform a set of three affinely independent points into a set of 4 affinely dependent ones.  The analogy is valid for other dimensions. <br>  Among other things, it is necessary to introduce the concept of hypervolume (eng. Hypervolume). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Hyper volume</b> <div class="spoiler_text">  Any considered object from the series <i>simplex</i> , <i>edge</i> , <i>edge</i> , <i>peak</i> , etc.  bounded in the corresponding subspace.  The ‚Äúamount of space‚Äù that such an object occupies can be measured / determined / defined.  For a one-dimensional direct measure is called length;  for a two-dimensional plane, the measure is called area;  for a three-dimensional body - volume.  The concept can be generalized by naming it a D-dimensional volume or a D-hyper volume.  For a simplex formed by pairwise different points <img src="https://habrastorage.org/files/867/0a0/1eb/8670a01eb15446298cb02ef3b256425b.png">  (the order of the enumeration of points is important), you can calculate the hyper volume <a href="http://math.stackexchange.com/a/828854/54348">as follows</a> : <br><br><img src="https://habrastorage.org/files/b2b/153/9e4/b2b1539e4ead4a78a4a8a1d8a92e7272.png"><br><br><img src="https://habrastorage.org/files/78a/ec1/db9/78aec1db9be84e2094448179a1894fa9.png"><br><br><img src="https://habrastorage.org/files/c1e/ee3/802/c1eee3802ae74f2c87bad556acdf9f90.png"><br><br>  Here we wrote out the coordinates of the vectors in the line.  Similar formulas and reasoning can be given for column vectors (that is, if we transpose all matrices, then this will not affect the result and conclusions). <br>  The divisor of the determinant in the formula above is the number of simplices (they all have the same volume) into which the parallelotope can be broken. <img src="https://habrastorage.org/files/440/542/e05/440542e0512f43449985bb17f3544893.png">  built on vectors <img src="https://habrastorage.org/files/a37/776/123/a3777612336446b8b6c8c50b17798c98.png">  .  Accordingly, the determinant itself is a volume of a parallelotope.  For those interested in the bases underlying this statement, I recommend reading about the determinant of the Gram matrix and its geometric interpretation. <br>  It should be noted that this measure will have a nonzero value for ‚Äúvolume‚Äù objects, and it can also be both positive and negative.  It is easy to understand the meaning of the sign from the following considerations: when exchanging the two points of the simplex, we get the sign change of the determinant;  the order of points is the ‚Äúleft- and right orientation‚Äù of the simplex.  On a plane, it's easy to imagine: if the sides of a triangle <img src="https://habrastorage.org/files/2fc/394/99f/2fc39499fdc84d3a8503d2593e634551.png">  listed counterclockwise <img src="https://habrastorage.org/files/674/e5c/04c/674e5c04c9c14d43aadae56d8dd47286.png">  , then the determinant is positive <img src="https://habrastorage.org/files/60e/55a/a10/60e55aa100a04fee847dde99542b411f.png">  otherwise <img src="https://habrastorage.org/files/e00/e8c/66c/e00e8c66c6354dbab96d4fe1f0dd929c.png">  - negative <img src="https://habrastorage.org/files/47f/ee8/274/47fee8274ff1485b855c4841802143eb.png">  .  For a tetrahedron, the sign will depend on the order in which (clockwise or counterclockwise) the first 3 points will be listed when looking at them from the last.  Thus, in the future, when specifying geometric objects, we must accept that the order of enumeration of points must be fixed. <br>  We can omit the factor before the determinant, since the algorithm will use only information about the sign of the magnitude of the oriented hypervolume. <br>  The determinant is zero if at least two lines are linearly dependent (remember that the points are pairwise different, that is, not one line is non-zero).  It is easy to verify the consistency of the above arguments about affine-dependent points and linearly dependent vectors corresponding to them. <br>  The absolute value of the determinant will not be affected by exactly which point is subtracted during the transition to the vectors - only the sign.  It is always necessary to subtract the last point from the first one, otherwise for similarly oriented similar objects used in the future, the sign of the measure will be different in even and odd dimensions. <br>  What to do with the measure for objects nested in a space of too large dimension, for example, with edges?  If we construct the matrix in the same way as shown above, it will be rectangular.  Determinant from such a matrix will not work.  It turns out that the formula can be generalized (this generalization is related to the <a href="https://en.wikipedia.org/wiki/Cauchy%25E2%2580%2593Binet_formula">Binet-Cauchy formula</a> ) using the same matrix made up of row vectors: <br><br><img src="https://habrastorage.org/files/696/52d/600/69652d600a604ca6a7e8609ab68357f1.png"><br><br><img src="https://habrastorage.org/files/c3d/9a1/289/c3d9a128986c4955ba5af9ac17447854.png"><br><br><img src="https://habrastorage.org/files/bed/a18/a2b/beda18a2b61d477d9a2e2d1c0536b831.png"><br><br><img src="https://habrastorage.org/files/e7c/a5b/967/e7ca5b96728748df88b935d04538c310.png"><br><br><img src="https://habrastorage.org/files/162/4ad/6de/1624ad6dec5341fe95ab392764324768.png"><br><br>  For affinely independent pairwise distinct points, the matrix under the determinant always turns out to be square positive-definite, while the determinant of such a matrix is ‚Äã‚Äãalways a positive number.  For affine dependent points, the matrix will be singular (that is, its determinant is zero).  It is clear that the measure is always non-negative and we have no information about orientation. <br>  On the one hand, the determinant of the product of square matrices is equal to the product of determinants, on the other hand, the determinant of the transposed square matrix coincides with the determinant of the original matrix, so the last formula reduces to the formula for <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  the points, except for the root of the square, i.e.  module, which we can omit, in order to obtain additional information about the relative orientation of points in space. <br></div></div><br><h3>  Algorithm. </h3><br>  The Quickhull algorithm itself for the case of arbitrary dimension was proposed in <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">Barber, C. Bradford;</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">Dobkin, David P .;</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">Huhdanpaa, Hannu (1 December 1996).</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">"The quickhull algorithm for convex hulls".</a>  <a href="http://dpd.cs.princeton.edu/Papers/BarberDobkinHuhdanpaa.pdf">ACM Transactions on Mathematical Software 22 (4): 469‚Äì483</a> .  The ‚Äúcanonical‚Äù implementation in C from the authors is located on the already mentioned site <a href="http://qhull.org/">http://qhull.org/</a> , the repository with the C ++ interface <a href="https://gitorious.org/qhull/qhull">https://gitorious.org/qhull/qhull</a> .  I will quote the algorithm from the original source: <br><blockquote><pre> create a simplex of d + 1 points
 for each facet F
	 for each unassigned point p
		 if p is above F
			 assign p to f`s outside set
 for each facet with a non-empty outside set
	 select the furthest point of f set
	 initialize the visible set V to F
	 for all unvisited neighbors n of facets in v
		 if p is above N
			 add N to V
	 the set of horizon ridge
	 for each ridge R in H
		 create a new facet from R and P
		 link the new facet to its neighbors
	 for each new facet F '
		 set of face to face
			 if q is above F '
				 assign q to F'`s outside set
	 delete the facets in v
</pre><br></blockquote><br>  A convex hull is a list of faces. <br><br><h4>  Starting simplex. </h4><br>  As you can see, we need to start with some <i>starting simplex</i> .  To do this, you can choose any <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  affine independent points, but it is better to use some cheap heuristics.  The main requirement at this step is that our simplex should not be ‚Äúnarrow‚Äù if possible (eng. Narrow).  This is important if you use floating-point arithmetic (eng. Floating-point arithmetic).  In the original implementation, points with maximum and minimum values ‚Äã‚Äãof coordinates are used (obviously, they will also be included in the set of vertices of the convex hull).  Starting from the starting simplex, at each subsequent step we will get more and more polyhedra, the constant property of which will always be its convexity.  I will call it a <i>temporary polyhedron</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Heuristics for finding vertices for a starting simplex.</b> <div class="spoiler_text">  My heuristics is based on the sequential selection of points so that each of the next points is as far as possible from all the previous ones.  ‚ÄúFurther‚Äù is in a certain sense, which will be clarified further. <br>  Two lists of points are kept: source list <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  (initially it contains all points from the input of the algorithm) and a list of points of the simplex <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  (initially empty).  In line with the sets <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  and <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  you can put a set of vectors <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  and <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  .  To do this, we mentally at every step of this algorithm choose any point <img src="https://habrastorage.org/files/c44/9d6/768/c449d6768df14bf2ac0e15fc3e726b4c.png">  from the set <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  (db is not empty), remember it, then draw a vector from it to all the other points from <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  (receiving at the same time <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  which will contain less by one element than <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  ) and to all points of <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  (receiving <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  ).  First, take the first (or any other) point from <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  and move it to <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  .  Next, look for a vector from <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  with the largest module and move the corresponding point from <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  at <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  .  The first point from <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  move back to <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  (it was chosen without any criteria).  On each of the following <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  steps looking for a point <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png">  of <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  which is as far as possible from <i>affine space</i> with a <i>basis</i> <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  and move it from <img src="https://habrastorage.org/files/367/eee/2f5/367eee2f584e4115bd97c93737ffdfea.png">  at <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  .  To do this, look for the corresponding point. <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png">  vector <img src="https://habrastorage.org/files/8f2/349/5c4/8f23495c4c7c4c1fab26681da323d17c.png">  of <img src="https://habrastorage.org/files/2be/5ce/624/2be5ce624d7d42e7bcf7ec8aa2ee8db5.png">  whose <i>projection</i> module on the <i>orthogonal complement</i> <img src="https://habrastorage.org/files/3d2/148/942/3d2148942d794d1d807f904ee66f9dba.png">  vector subspace <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  max.  Here <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  - linear shell <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  , that is, the vector space, since  vector in <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  are linearly independent (by construction), then <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  - the basis of this vector space. <br>  Formula distance from <img src="https://habrastorage.org/files/0ce/aa9/211/0ceaa921124f417ca2a9fd18d2814d0b.png">  before <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  : <br><br><img src="https://habrastorage.org/files/2e7/6be/624/2e76be624b7c43aa967c90717ab5d653.png"><br><br>  Since the vector is directly decomposed into a sum of projections onto any subspace and onto the orthogonal complement of this subspace, then: <br><br><img src="https://habrastorage.org/files/ffd/070/e7a/ffd070e7a47a4a37af8d6c3ced82af82.png"><br><br>  Having <i>an orthonormal basis</i> <img src="https://habrastorage.org/files/bcc/80b/03e/bcc80b03e9794bbc85be76fc2bf29845.png">  vector subspace <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  , we can calculate the module of the projection onto the orthogonal complement of this subspace: <br><br><img src="https://habrastorage.org/files/e43/8ec/253/e438ec253ca840158226b66a6df807c2.png"><br><br>  Coordinates of vectors <img src="https://habrastorage.org/files/3e5/977/4be/3e59774beffa475e93c3a924c70636ce.png">  we can get by performing a QR decomposition of a rectangular matrix (for example, using the Householder method) composed of (coordinates) column-vectors from the set <img src="https://habrastorage.org/files/3ab/a4a/a53/3aba4aa53e0c41bf8c559b8fd6fdfc45.png">  .  As a result, we obtain an orthogonal (rectangular) matrix Q ( <img src="https://habrastorage.org/files/20b/c16/cc9/20bc16cc945e47db9ff0ce21ed2a8cf2.png">  ) and upper triangular R (not used).  The Q columns are the coordinates of the vectors. <img src="https://habrastorage.org/files/3e5/977/4be/3e59774beffa475e93c3a924c70636ce.png">  forming an orthonormal basis of a vector space <img src="https://habrastorage.org/files/7b0/f75/476/7b0f754769ce4ef98cdf043b2999e903.png">  . <br>  After completing the algorithm in <img src="https://habrastorage.org/files/9a1/545/b4c/9a1545b4cb804cb0bd88dcf4e7dcdf43.png">  located <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png">  point. <br></div></div><br>  Next, we must distribute the remaining points to the so-called <i>lists of external points</i> (outside sets) of the faces - these are lists of points that are maintained for each face and which are still <i>not considered</i> (hereinafter - unassigned, English unassigned) points that are relatively face planes on the other side than the interior of the simplex (or a temporary polyhedron in the future).  Here we use the property of a convex polyhedron (and simplex in particular) that it lies entirely in only one of the two <i>half-spaces</i> obtained by splitting the whole space with the plane of each face.  From this property follows the fact that if a point does not fall into any of the lists of external points of the faces of the convex hull, then it is reliably located inside it.  In the future, the algorithm will need information about which of the points contained in the list of external points and the most distant from the plane of the face, therefore, adding points to the list of external points, you need to save information about which one is the furthest.  Any point falls only in one list of external points.  The asymptotic complexity is not affected by how exactly the points are distributed among the lists. <br>  At this stage, I need to digress and tell how to set the face, how to calculate the distance to it, how to determine the orientation of a point relative to the face. <br><br><div class="spoiler">  <b class="spoiler_title">The brink.</b>  <b class="spoiler_title">Oriented distance from the plane of the face to the point.</b> <div class="spoiler_text">  To set the brink we need to have <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  points - vertices of the face.  For the reasons given above, we will keep these points in an orderly manner.  Moreover, the orderliness we need is not absolutely strict.  For example, having made two exchanges in any two not necessarily different pairs of pairs of different points, we will get the same oriented edge in the sense that in any operations later (and this will usually be taking determinants from matrices formed from constants and coordinates of the vertices) such pair permutations do not affect the result.  Two possible orientations correspond to two possible directions of the normal to the plane (face). <br>  Only once - at the very beginning - we need to calculate the value of the hyper volume of the starting simplex in order to determine its orientation by a sign.  All further operations regarding the edges will consist only in the calculation of the oriented distance (born distance) to the point.  Here we can recall a school formula allowing generalization to the case of an arbitrary dimension, namely: ‚Äúthe area of ‚Äã‚Äãa triangle is equal to half the product of the base, to a height‚Äù or ‚Äúthe volume of the pyramid is equal to one third of the product of the base to the height‚Äù.  We are able to stretch the measure of the body and the face, therefore we can express the height (one-dimensional length): <br><br><img src="https://habrastorage.org/files/db2/cf7/238/db2cf72383bb4ea78d5f12a8d1156f42.png"><br><br>  In the algorithm, we need to calculate the oriented distance from a fixed plane (face) to points, which can be many.  In this case, we can note that there is a positive constant in the denominator.  From the position of the point ("above" or "under") depends only the hyper volume in the numerator. <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  - also constant.  Thus, we can consider only the relative values ‚Äã‚Äãof the hyper-volumes of the simplexes (or rather, the corresponding parallelotopes) constructed from the face and the point.  If the determinant is not considered the slowest way (by definition for <img src="https://habrastorage.org/files/210/c31/3d0/210c313d0f9346d88e5b24d7dd9785ab.png">  ) and not <a href="https://en.wikipedia.org/wiki/Determinant">the fastest</a> ( <img src="https://habrastorage.org/files/cc7/50e/00b/cc750e00befc4239991d4ff466980beb.png">  ), and in the way through LUP decomposition (English LUP decomposition), it is possible to achieve complexity <img src="https://habrastorage.org/files/844/1db/88c/8441db88c259424d97fbe07b6437d5df.png">  and decent numerical stability (born numerical stability).  I do not undertake to evaluate how the complexity of calculating the determinant affects the final complexity of the entire algorithm, but experimenting, I concluded that in the worst case (for example, the case of points located on a sphere (English cospherical points)) even for small dimensions of space ( <img src="https://habrastorage.org/files/acd/c86/a86/acdc86a86e4a421197a5db4cfae9423d.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) calculating determinants to estimate distance is too computationally expensive. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another approach is to use the normalized plane equation (English hyperplane equation). </font><font style="vertical-align: inherit;">This equation of the first degree, which relates the coordinates of a point of the </font></font><img src="https://habrastorage.org/files/caa/0be/593/caa0be5938a84e5ea7dc4a730db092e5.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plane, the coordinates of the normalized normal vector</font></font><img src="https://habrastorage.org/files/694/ece/f55/694ecef55fbd4f048896af5eaa95c4e2.png">  ( <img src="https://habrastorage.org/files/011/4b4/5d3/0114b45d3c364d6581f2f9b6a0c96b40.png"> ‚Äî  )   (. normalized normal vector)    <img src="https://habrastorage.org/files/871/9f8/9de/8719f89de882478988124f13ba29331f.png">    (. offset): <br><br><img src="https://habrastorage.org/files/e0e/869/273/e0e8692738514991adbf772fae96330e.png"><br><br>   <img src="https://habrastorage.org/files/011/4b4/5d3/0114b45d3c364d6581f2f9b6a0c96b40.png">  : <br><br><img src="https://habrastorage.org/files/c6d/35b/134/c6d35b1347174dfb8ac557fe0571e322.png"><br><br>  <img src="https://habrastorage.org/files/871/9f8/9de/8719f89de882478988124f13ba29331f.png"> ‚Äî     : <br><br><img src="https://habrastorage.org/files/975/fe8/9a6/975fe89a67d245b5add8a5784aba125a.png"><br><br>  <img src="https://habrastorage.org/files/db2/cf7/238/db2cf72383bb4ea78d5f12a8d1156f42.png"> ,         , ‚Äî         : <br><br><img src="https://habrastorage.org/files/467/f27/49a/467f2749aef94f12ad3a82a52e810380.png"><br><br>         ,   ,   <img src="https://habrastorage.org/files/14c/e62/95d/14ce6295d9e046629fc3868eb6c302ed.png">  ,  ‚Äî . <br>        <img src="https://habrastorage.org/files/5f4/2e5/6e3/5f42e56e3af645919037968aa7387431.png">  and <img src="https://habrastorage.org/files/1e2/74b/4ba/1e274b4bad4a496082310cf407b9f6b6.png">     <img src="https://habrastorage.org/files/c80/d9e/efa/c80d9eefa7f442518568acb94c20408a.png"> -  ()  . <br>          <img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"> : <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">        .       <a href="http://en.cppreference.com/w/cpp/algorithm/inner_product"><i>std::inner_product</i></a> ,           ,    ,    ‚Äî  <img src="https://habrastorage.org/files/b94/3ba/f5a/b943baf5a4ac4679a98cb1e7e6c78eba.png">  .           , ,  ,    ,     ,               . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we are able to describe the face plane, but there is one ambiguity: how to choose the order of listing points in the lists of vertices of faces of the starting simplex? Authors do not keep the list of vertices ordered. They act differently. By setting the plane equation for an arbitrary but fixed order of the vertices, they find out the orientation of an internal point relative to this plane. That is, the oriented distance is calculated. If the distance is negative, they change the sign of the coordinates of the normal to the hyperplane and its offset from the origin. Or set the value of the flag, indicating that the face is inverted (English flipped). The internal point for a convex polyhedron will be the arithmetic average of at least </font></font><img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its vertices (the so-called center of mass, if we take all the vertices).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reorientation of the faces of the starting simplex.</font></font></b> <div class="spoiler_text">           (        )  .       ,        ,     ( <img src="https://habrastorage.org/files/1a3/78c/a07/1a378ca079224f41bae61d9107065742.png"> )   ( <img src="https://habrastorage.org/files/e77/cb5/e71/e77cb5e717e242be9556b5f03dab48b0.png">  ).      ,   <img src="https://habrastorage.org/files/1a3/78c/a07/1a378ca079224f41bae61d9107065742.png">  ¬´¬ª    <img src="https://habrastorage.org/files/f6f/401/0f0/f6f4010f0e9d41e19491ee9114f30012.png">    ,         (   ).         ,        <img src="https://habrastorage.org/files/a21/429/41c/a2142941c8a14aacaaa185f984f894e7.png"> (  <img src="https://habrastorage.org/files/7cc/3fb/509/7cc3fb509d3949da84244c32a1b76c52.png">   ).          . <br>        <img src="https://habrastorage.org/files/867/0a0/1eb/8670a01eb15446298cb02ef3b256425b.png">    <img src="https://habrastorage.org/files/359/596/1c0/3595961c0444421f83885a1e649d4500.png">  .                ,     ,          .    ,             .    (   /   ). <br>  ,    ,      <img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">    ,      ,         .     ,             . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each face, in addition to specifying a list of vertices, a list of external points, you must specify a list of adjacent (eng. Adjacency list) faces. </font><font style="vertical-align: inherit;">For each face it will contain exactly</font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png">  items.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the starting simplex contains a </font></font><img src="https://habrastorage.org/files/6e9/bcc/49f/6e9bcc49f3fa4bbfa6a2a0ca934b366e.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">face, it is obvious that for any of its faces, all other faces ( </font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pieces) </font><font style="vertical-align: inherit;">will fall into the list of adjacent faces </font><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main loop. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now there is a temporary polygon with which you can work in the main loop. In the main cycle, this temporary polygon is completed by ‚Äúcapturing‚Äù more and more space, and with it the points of the original set, until a moment comes when there will not be a single point outside the polyhedron. Further I will describe this process in more detail. Namely, the way it works in my implementation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main loop is a loop along edges. At each iteration, among the faces with non-empty lists of external points, the best face is selected </font></font><img src="https://habrastorage.org/files/a82/a1e/139/a82a1e139d9248cbbb58685e3debe880.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(eng. Best facet); best in the sense that the farthest point from the list of external points is farther from the face than other faces. The cycle ends when there are no faces with non-empty lists of external points.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the body of the main loop, the selected face is deleted as a convex hull that is not the face of a convex hull. </font><font style="vertical-align: inherit;">But beforehand, she "understands the components." </font><font style="vertical-align: inherit;">From the list of external points, the farthest point is extracted </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(eng. Furthest point) - it is probably the top of the convex hull. </font><font style="vertical-align: inherit;">The remaining points are moved to a separate temporary list of unassigned points.</font></font><img src="https://habrastorage.org/files/41b/832/432/41b8324326f74a989bdfc203b6eb21a0.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, according to the lists of adjacent faces, starting from the list of faces </font></font><img src="https://habrastorage.org/files/a82/a1e/139/a82a1e139d9248cbbb58685e3debe880.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the adjacency graph of the faces of the temporary polyhedron is bypassed and each face is added to the list of already visited (eng. Visited) faces and tested for visibility (eng. Visibility) from a point</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the face is invisible from a point </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then its adjacent faces will not be further circumvented, otherwise they are bypassed. If the next visible face among neighboring faces has invisible ones from a point </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it falls into the list of border visible faces (the English before-the-horizon, as opposed to over-the-horizon, is ‚Äúover the horizon‚Äù). But if all adjacent faces are visible, then such a face is added to the list of faces to be deleted. After traversing the adjacency graph of faces, the list of boundary visible faces and the list of faces to be deleted all contain all visible from the point.</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">facets. Now all faces are deleted from the list for deletion. Moreover, each deleted face is not removed from the lists of neighboring faces from its neighbors. It is safe to do so, because even if the neighboring face is the visible edge of the border, from the list of its neighboring faces only information about the proximity to the invisible from the point is used in the future </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Following the list of faces to be deleted is a list of visible edges. Each boundary visible edge is ‚Äúparsed‚Äù (then we will need its list of adjacent faces and a list of vertices) and is deleted. For each boundary visible face, new faces are created (from one to</font></font><img src="https://habrastorage.org/files/d90/99e/f43/d9099ef43d3d4510a92c0a798a85f969.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pieces), which are added to the list of new faces. </font><font style="vertical-align: inherit;">At the same time, a list of its neighboring faces is viewed, and for each face from this list, which is invisible, a common edge with a given visible boundary is searched for. </font><font style="vertical-align: inherit;">The vertices common to the invisible and boundary visible edges (that is, the vertices of the common edge) are written out to the list of vertices of a new face, moreover in the order in which they are written in the list of vertices of the boundary visible face. </font><font style="vertical-align: inherit;">The edge (eng. Horizon ridge), by the way, is part of the horizon of that part of the surface of the temporary polyhedron that is visible from the point</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The only vertex of the visible boundary that does not belong to this edge is replaced by the point </font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the list of vertices of the new face, the rest of the vertices are the same as in the (ordered) list of vertices of the boundary visible face and stand in the same places. Thus, the constructed list of vertices of the new facet guarantees its correct orientation, that is, when calculating its normalized plane equation, the normal will be directed outside the time polyhedron and the offset value will receive the correct sign. After all the boundary visible edges are processed, we have a list of new faces. The hyperplane equations for these faces can be calculated immediately after we have vertex lists for them. Also, when creating new faces, one can add one facet to their lists of adjacent faces, namely, the corresponding invisible face that was adjacent to the boundary visible face when forming the list of vertices of a new face. Obviously the rest</font></font><img src="https://habrastorage.org/files/5da/04a/848/5da04a84816d4817a1bafa06a7687cc4.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighboring faces must be searched for among other new faces. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As it turned out (when sampling by the profiler from </font></font><a href="https://code.google.com/p/gperftools/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Performance Tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), the most time in the case of large dimensions and / or poor input data (that is, when most of the points are vertices of a convex hull) the algorithm spends searching for neighboring faces for new faces. In my implementation, the algorithm was initially very simple: all possible pairs (two nested loops) of faces from the list of new faces were searched and comparisons were made (by the number from the input list of points) of vertex lists with one mismatch (modified algorithm </font></font><a href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: set_difference</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="http://en.cppreference.com/w/cpp/algorithm/set_difference"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: set_symmetric_difference</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font> I.e <img src="https://habrastorage.org/files/5a6/031/fe9/5a6031fe9a674b41b32cbb9c2b8ef718.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparisons, where </font></font><img src="https://habrastorage.org/files/f9c/dfd/0ff/f9cdfd0ff4624b4e80120219d4f1a4ed.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the number of new faces. But later I managed to win a pair (binary =) orders in the speed of searching for neighboring ones using ordered associative arrays ( </font></font><a href="http://en.cppreference.com/w/cpp/container/set"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: set</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in this narrow place. In general, there is a whole area of ‚Äã‚Äãknowledge that is associated with this task (identifying neighbors) - this is </font></font><a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locality-sensitive hashing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In the original implementation of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qhull</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just hashes are used (not LSH). It contains a separate data structure for each edge (two faces) (a list of edge vertices and information about faces ‚Äúabove‚Äù and ‚Äúbelow‚Äù an edge), each face contains a list of its edges. To determine the neighborhood of the faces (among the faces from the list of new faces) for all edges of the faces, an associative unordered array of hashes of arrays of their vertices is created (with one skip (English skip) and one dropped vertex</font></font><img src="https://habrastorage.org/files/01a/41f/211/01a41f2114dc4c4089889c137eeb9025.png">  ).  I.e <img src="https://habrastorage.org/files/e2a/e70/908/e2ae70908193468e9a49d7a8040881fa.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saves hashes. If there is a collision (and the subsequent complete coincidence of the lists) of hashes, then (obviously) these two faces have a common edge (the hash, by the way, can be removed to reduce the hash table) and each of them can be added to the list of adjacent faces of the other. I do not use this method, since neither in the standard library nor in the STL there is such a tool as </font></font><a href="http://www.boost.org/doc/html/hash/reference.html"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash combiner</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (upd. Received information that the </font></font><a href="http://stackoverflow.com/questions/5889238/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">best choice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is just XOR). </font><font style="vertical-align: inherit;">I didn‚Äôt want to </font><font style="vertical-align: inherit;">specialize without the information-theoretical justification of the correctness of </font></font><a href="http://en.cppreference.com/w/cpp/utility/hash"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: hash</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><a href="http://en.cppreference.com/w/cpp/container/vector"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector &lt;std :: size_t&gt;</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is why I used associative </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordered</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edge container for finding adjacent faces. </font><font style="vertical-align: inherit;">As a result (apparently) my implementation of the algorithm loses </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qhull</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in speed asymptotically in from</font></font><img src="https://habrastorage.org/files/df3/d68/1d6/df3d681d6482417496dd59e07dfb9c5e.png">  before <img src="https://habrastorage.org/files/03a/497/6b1/03a4976b11c14634b02addfdbc12da7f.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times (for all sorts of input data). </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparative testing. </font></font></h4><br>  The example is the ‚Äúcanonical‚Äù implementation of the Quickhull <b>qhull</b> algorithm, installed through the package manager (in Ubuntu 14.04 LTS).  To generate input from the same <i>qhull-bin</i> package, the <i>rbox</i> utility was <b>used</b> .  The <i>rbox tn D4 30000 s&gt; /tmp/qhuckhull.txt command</i> creates a file with coordinates of 30,000 points on a four-dimensional sphere.  The <i>rbox tn D10 30 s&gt; /tmp/quickhull.txt command</i> creates a file with the coordinates of 30 points on a ten-dimensional sphere.  The amount of memory that the program spends can be seen in the output of the <i>/ usr / bin / time</i> utility with the <i>-v option</i> .  Thus, in the output <i>/ usr / bin / time -v bin / quickhull /tmp/quickhull.txt |</i>  <i>head -7</i> you can find out the consumption of both memory and processor time (cleared from the time to read files and output to the terminal) for my implementation, and in the output <i>/ usr / bin / time -v qconvex s Qt Tv TI /tmp/quickhull.txt</i> - for the ‚Äúcanonical‚Äù implementation of <b>qhull</b> . <br>  I determine the correctness of my implementation by the coincidence of the number of faces of the convex hulls.  But for debugging (in two-dimensional and three-dimensional modes) at some stage I implemented step-by-step (via the <i>pause</i> command) animated output in <b>gnuplot</b> format.  Somewhere in commits it is.  The output of the program is a convex hull and a numbered set of input points represented in the <b>gnuplot</b> format. <br>  In addition, somehow I started writing (but did not finish) the <b>randombox</b> utility, an analogue of <b>rbox</b> .  <b>randombox was</b> conceived as a utility that generates points uniformly distributed in space (English uniform spatial distribution), in contrast to <b>rbox</b> , which generates points that are not evenly distributed.  <b>randombox</b> can generate sets of points bounded by a simplex (of any dimension that can be embedded in space with points), on a unit sphere (in the unit sphere), in a ball (English ball), on the surface of a single ‚Äúdiamond-shaped‚Äù polyhedron (Eng. unit diamond), inside a unit cube (English unit cube), inside a parallelotope, within the standard unit simplex (English unit simplex), and also projects a set of points into the volume of the cone (English cone) or cylinder (English cylinder ).  To generate coordinates that are evenly distributed within an arbitrary speclex (embedded in space), I found a numerically stable algorithm on the Internet (through the Dirichlet distribution), and also came up with <a href="http://math.stackexchange.com/a/871220/54348">my own</a> algorithm, which does not have this property.  In the end, chose the first. <br>  In order to ‚Äúfeel‚Äù the bulging shells with a glance using <b>gnuplot</b> , from the project root enter the command <i>rbox n D3 40 t |</i>  <i>bin / quickhull&gt; /tmp/quickhull.plt &amp;&amp; gnuplot -p -e "load '/tmp/quickhull.plt'"</i> .  <i>rbox n D3 40 t will</i> generate 40 points inside the bounding cube <img src="https://habrastorage.org/files/f41/6ce/72e/f416ce72ee6b40baa7ace420288a905f.png">  (eng. bounding box).  The key <i>t</i> specifies the use of the current time (in seconds) as the initial PRNG value.  To get points on a sphere, you need to add the key <i>s</i> .  It is also interesting to see how nonsimplicial faces are broken: <i>rbox n D3 c</i> - cube, <i>rbox n D3 729 M1,0,1</i> - <img src="https://habrastorage.org/files/62a/68d/fb6/62a68dfb6efe4c37934a96c31d0ea0e0.png">  points located in whole nodes.  The convex shell of the helix looks beautiful (eng. Helix): <i>rbox n D3 50 l</i> .  In the case of the simultaneous location of a large number of points coplanar to the edges, the constant <i>eps</i> begins to play a great role for the correctness of the results, which is set when constructing the algorithm object.  For example, if you use <a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><i>std :: numeric_limits &lt;value_type&gt; :: epsilon ()</i></a> as a small value, then in the case of a ‚Äúrotated‚Äù cube of 64 integer points of <i>rbox n D3 64 M3.4,</i> as a result of the algorithm, an incorrect which is a convex polygon. <br><br><h4>  Total or late TL; DR. </h4><br>  The result of my work was the release of the Quickhull algorithm in C ++, quite compact and not very slower than the implementation with <a href="http://qhull.org/">qhull.org</a> .  The algorithm receives at the input the value of the dimension of space, the value of the small constant <i>eps</i> and the set of points represented as a range defined by a pair of iterators, as is customary in STL.  At the first stage of <i>create_simplex,</i> the starting simplex is built and the point basis of the affine (sub) space containing the input points is returned.  If the number of points in the basis is greater than the dimension of the Euclidean space containing the points, then the algorithm for completing the construction of the convex hull must be run.  At the output, the algorithm will give an array of data structures describing the faces of the convex hull of the input set, which is the answer.  In case of failure, we have a point basis of some subspace of lower dimension, which contains all points.  Using the Householder algorithm, you can in some way rotate the input set, while vanishing the highest coordinates of the points.  Such coordinates can be discarded and the Quickhull algorithm can be applied already in a space of lower dimension. <br><br><h4>  Applications. </h4><br>  This algorithm has many applications.  In addition to finding the convex hull as such, due to the fact that there is a <a href="http://algolist.manual.ru/maths/geom/chull_dv.php">connection</a> between the <a href="http://acm.timus.ru/problem.aspx%3Fnum%3D1062">convex hull</a> , the <a href="http://www.youtube.com/watch%3Fv%3DxYzULMoyaQk">Delaunay triangulation</a> and <a href="http://www.youtube.com/watch%3Fv%3DFIPu9_OGFgc">the Voronoi diagram</a> , it is easy to find applications of the algorithm "indirectly". <br>  This implementation <a href="https://hal.inria.fr/hal-01104587/file/DeClope_isbra.pdf">has already come in handy for some people</a> , and was paid for with gratitude (in Acknowledgments), which is very nice. <br><br><h4>  Updates. </h4><br>  06/24/2015: A check of the convexity of the resulting geometric structure was added according to the algorithm of <a href="">Kurt Mehlhorn, Stefan N√§her, Thomas Schilz, Stefan Schirra, Michael Seel, Raimund Seidel, and Christian Uhrig.</a>  <a href="">Checking geometric programs or verification of geometric structures.</a>  <a href="">In Proc.</a>  <a href="">12th Annu.</a>  <a href="">ACM Sympos.</a>  <a href="">Comput.</a>  <a href="">Geom., Pages 159-165, 1996</a> . <br>  06/24/2015: The faces of the resulting polyhedron now contain sets of vertices and indices of neighboring faces arranged in such a way that the face is the opposite one and the corresponding vertex.  This makes the structure much more convenient to use in some cases. <br>  06.24.2015 G .: Now for the determination of the neighborhood of newly obtained faces, their hashes are used. </div><p>Source: <a href="https://habr.com/ru/post/245221/">https://habr.com/ru/post/245221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245205/index.html">Do away with chaos: implement business processes in CRM</a></li>
<li><a href="../245209/index.html">The digest of interesting materials from the world of Drupal # 1</a></li>
<li><a href="../245211/index.html">Lagrange formalism in problems with dry friction</a></li>
<li><a href="../245213/index.html">Some interesting and useful things for web developer # 34</a></li>
<li><a href="../245215/index.html">Highload ++ 2014 through the eyes of a speaker who really loves Processing Large-Scale Graph Data in various bad ways</a></li>
<li><a href="../245223/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ137 (December 1 - 7, 2014)</a></li>
<li><a href="../245225/index.html">Blender Development Plans</a></li>
<li><a href="../245227/index.html">Yii 2.0.1</a></li>
<li><a href="../245229/index.html">Strange behavior of Google Search results for Highscreen in Google Chrome browser</a></li>
<li><a href="../245231/index.html">Budget hakaton. HackDay Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>