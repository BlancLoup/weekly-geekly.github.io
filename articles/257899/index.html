<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Templates can be called the most important difference and the main advantage of the C ++ language. The ability to create an algorithm pattern for vari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cd9/1a7/d14/cd91a7d14f59470baa7147b364cf2d3e.jpg"><br><br>  Templates can be called the most important difference and the main advantage of the C ++ language.  The ability to create an algorithm pattern for various types without copying the code and with strict type checking is just one aspect of using patterns.  The code of specializations of the template is built at the compilation stage, and this means that the behavior of the created types and functions can be controlled.  How can you resist the possibility of programming compiled classes? <br><br>  Metaprogramming is becoming as an integral part of writing C ++ code, as is the use of the standard library, part of which is created specifically for use at the compilation stage.  Today we will produce a library of safe casting of C ++ scalar types by metaprogramming with templates! <br><a name="habracut"></a><br><h4>  Pattern break </h4><br>  In fact, all metaprogramming is reduced not so much to the patterned behavior, regardless of the type, but to the violation of this very pattern of behavior.  Suppose we have a template class or a template function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Some</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  As a rule, such classes and functions are described immediately with a body common to any type.  But no one prevents us from setting an explicit template specialization for one of the types, creating for this type a unique function behavior or a special kind of class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Some</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_twice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_twice / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_twice; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(value); }</code> </pre><br>  In this case, the general behavior can be described very differently from the pattern specified for specializations: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Some</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T m_value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * value; }</code> </pre><br>  In this case, when using the template, a special behavior will be observed for the `Some` and` func` specializations: it will differ greatly from the general behavior of the template, although the external API will differ slightly.  But when creating instances, `Some` will store a double value and return the original value, halving the` m_twice` property with the query `get_value ()`.  The generic `Some` pattern, where T is any type other than int, will simply save the passed value, producing a constant reference to the` m_value` field for each `get_value ()` request. <br><br>  The `func` function computes the root of the argument value altogether, while any other specialization of the` func` pattern will calculate the square of the passed value. <br><br>  Why do you need it?  As a rule, in order to make a logical fork within the template algorithm, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class">() {</span></span> Some&lt;T&gt; some(T()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(some.get_value()); }</code> </pre><br>  The behavior of the algorithm inside create will be different for the types int and double.  In this case, the behavior of different components of the algorithm will differ.  Despite the illogicality of the template specialization code, we got a simple and understandable example of managing patterns. <br><br><h4>  Gap non-existent pattern </h4><br>  Let's make our example a little more fun - remove the general pattern of behavior for Some and func, leaving only the specializations Some and func already written and, of course, without touching the preliminary announcement. <br><br>  What happens to the `create` template in this case?  It will simply stop compiling for any type.  After all, for `create`, there is no implementation of the` func` function, and for `create` there is no necessary` Some`.  The first attempt to insert the create call for any type into the code will result in a compilation error. <br><br>  To allow the `create` functions to work, you need to specialize` Some` and `func` from at least one type at a time.  You can implement `Some` or` func`, like so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Some</span></span></span><span class="hljs-class">&lt;double&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value*value)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_square; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m_square; };</code> </pre><br>  By adding two specializations, we not only revived the compilation of create specializations from the types int and double, it also turned out that the algorithm would return the same values ‚Äã‚Äãfor these types.  But the behavior will be different! <br><br><blockquote><h4>  INFO </h4><br>  In C ++, types behave differently and not always the template algorithm behaves effectively for all types.  Often, by adding a template specialization, we get not only performance gains, but also more understandable behavior of the program as a whole. </blockquote><br><h4>  So help us std :: </h4><br>  Every year more and more tools for metaprogramming are added to the standard library.  As a rule, everything new is a well-tried old, borrowed from the Boost.MPL library and legalized.  We increasingly need `#include &lt;type_traits&gt;`, and more and more code comes with using forks like `std :: enable_if`, more and more we need to know at the compilation stage whether the template argument is not an integer type` std :: is_integral` , or, for example, compare two types inside a template with `std :: is_same` to control the behavior of template specializations. <br><br>  The supporting structures of the template are built so that only the specialization is compiled, which gives the truth of the expression, and there are no specializations for false behavior. <br><br>  To make it clearer, let's take a closer look at `std :: enable_if`.  This pattern depends on the truth of its first argument (the second is optional), and an expression like `std :: enable_if :: type` will be compiled only for true expressions, this is done quite simply - by specializing on the value true: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> predicate_value, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">&lt;true, result_type&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> result_type type; };</code> </pre><br>  For a value of false of type `std :: enable_if &lt;P, T&gt; :: type`, the compiler simply cannot create it, and this can be used, for example, by limiting the behavior of a number of partial specialization types of the template structure or class. <br><br>  Here, a variety of predicate structures from the same `&lt;type_traits&gt;`: `std :: is_signed :: value` is true if the type T supports the type of the + or - character ( which is very convenient for cutting off the behavior of unsigned integers), `std :: is_floating_point :: value` is true for real types float and double,` std :: is_same &lt;T1, T2&gt; :: value` is true if types T1 and T2 are the same.  There are many predicate structures that help us, and if something is missing in `std ::` or `boost ::`, you can easily make your structure. <br><br>  Well, the introductory part is completed, we proceed to practice. <br><br><blockquote><h4>  How are predicates arranged? </h4><br>  A predicate is the usual partial specialization of a template structure.  For example, for `std :: is_same`, in general, it looks like this: <br><br><pre> <code class="cs hljs">template &lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">class</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; <span class="hljs-title"><span class="hljs-title">struct</span></span> <span class="hljs-title"><span class="hljs-title">is_same</span></span>; template &lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">struct</span></span> <span class="hljs-title"><span class="hljs-title">is_same</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>,<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; template &lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">class</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; <span class="hljs-title"><span class="hljs-title">struct</span></span> <span class="hljs-title"><span class="hljs-title">is_same</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre><br>  For the coinciding argument types `std :: is_same`, the C ++ compiler will select the appropriate specialization, in this case partial with value = true, and for mismatched ones it will fall into the general implementation of the template with value = false.  The compiler is always trying to find a strictly suitable specialization in the types of arguments and, just not finding the one needed, goes into the general implementation of the template. </blockquote><br><h4>  Entry by template is strictly prohibited </h4><br>  To start programming the program code and do all kinds of metaprogramming, try creating a terrible function that returns a different result for the same and different types of template arguments.  In this we will be helped by the mechanism of partial specialization for the auxiliary structure.  Since there is no partial specialization for functions, inside the function we will simply refer to a simple corresponding specialization of the structure, in which we will define a partial specialization: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">try_safe_cast</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_cast&lt;result_type, value_type&gt;::try_cast(result, value); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">same_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class">&lt;same_type, same_type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result_type&amp; result, value_type </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ result = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre><br>  Obviously, we have created a preset for the safe cast function.  The function is based on the types of the arguments passed to it and goes to the static `try_cast` method of the corresponding specialization of the` type_cast` structure.  At the moment we have implemented only the trivial case, when the type of the value coincides with the type of the result and the transformation, in fact, is not necessary.  The result variable is simply assigned an incoming value, and true is always returned - a sign of successful conversion of the value type to the result type. <br><br>  For mismatched types, a compilation error with a long incomprehensible text will now be displayed.  To fix this a little, you need to enter the general implementation of the template with `static_assert (false, ...)` in the body of the `try_cast` method - this will make the error message more understandable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result_type&amp;, value_type </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"     "</span></span>); } }</code> </pre><br>  Thus, every time an attempt is made to cast a type using the `try_safe_cast` type function for which there is no corresponding specialization of the` type_cast` structure, a compilation error message will be issued from the general template. <br><br>  Preparation is ready, it's time to start metaprogramming! <br><br><h4>  Pometaprogram me here! </h4><br>  First you need to correct the declaration of the auxiliary structure `type_cast`.  We will need an additional type of `meta_type` for a logical fork without prejudice to the parameters passed and implicitly determining their types.  Now the description of the structure template will look a bit more complicated: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">meta_type</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  As you can see, the new type in the template declaration is optional and does not interfere with the already existing declarations of specialization and the general behavior of the template.  However, this little nuance allows us to control the compilation success by passing the result of `std :: enable_if &lt;predicate&gt; :: value` to the third parameter.  Specializations with a non-compiled template parameter will be discarded, which is what we need in order to manage the casting logic of the types of different groups. <br><br>  Indeed, it is obvious that integers are given to each other in different ways, depending on whether both types have a sign, which type is of greater bitness and whether the transmitted value value does not exceed the allowable values ‚Äã‚Äãfor `result_type`. <br>  So, if both types are signed integers and a type of result that is larger than the width of the input value, then you can easily assign an input value to the result, the same is true for unsigned types.  Let's describe this behavior with a special partial specialization of the `type_cast` template: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result_type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class">&lt;result_type, value_type, typename std::enable_if&lt;...&gt;::value&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result_type&amp; result, value_type </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ result = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Now we need to figure out what condition we need to insert instead of the ellipsis parameter `std :: enable_if`. <br><br>  Let's go to describe the condition of the compilation time: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;</code> </pre><br>  First, the specialization should not intersect with the already existing one, where the type of the result and the input value coincide: <br><br><pre> <code class="cpp hljs">!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;result_type, value_type&gt;::value &amp;&amp;</code> </pre><br>  Secondly, we consider the case when both template arguments are integer types: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;result_type&gt;::value &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;value_type&gt;::value &amp;&amp;</code> </pre><br>  Thirdly, we mean that both types are either signed or unsigned (brackets are required - the conditions of the template parameters are calculated differently than at the execution stage!): <br><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed&lt;result_type&gt;::value == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed&lt;value_type&gt;::value) &amp;&amp;</code> </pre><br>  Fourthly, the bit width of the integer type of the result is greater than the bit width of the type of the transferred value (again brackets are required!): <br><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(result_type) &gt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value_type))</code> </pre><br>  Finally, close the std :: enable_if declaration: <br><br><pre> <code class="cpp hljs">::type</code> </pre><br>  As a result, the type for `std :: enable_if` will be generated only when these four conditions are met.  In other cases, for other combinations of types, this partial specialization will not even be created. <br><br>  It turns out a furious expression inside `std :: enable_if`, which cuts off only the case specified by us.  This template saves from duplicating the code to bring the various integral types into each other. <br><br>  To consolidate the material, we can describe a slightly more complicated case - the reduction of an unsigned integer to a type of lesser bit depth of an unsigned integer.  Here knowledge of the binary representation of the integer and the standard class `std :: numeric_limits` will help us: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> result_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_cast</span></span></span><span class="hljs-class">&lt;result_type, value_type, typename std::enable_if&lt;...&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result_type&amp; result, value_type </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != (value &amp; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;result_type&gt;::max())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } result = result_type(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  In the if condition, everything is quite simple: the maximum value of the type `result_type` is implicitly reduced to a type of more bitness` value_type` and acts as a mask for the value `value`.  In case the bits outside the `result_type` are used for the` value` value, we will get the executed inequality and get return false. <br><br>  Now let's go through the compile time condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;</code> </pre><br>  The first two conditions remain the same - both types are integer, but different among themselves: <br><br><pre> <code class="cpp hljs">!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;result_type, value_type&gt;::value &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;result_type&gt;::value &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral&lt;value_type&gt;::value &amp;&amp;</code> </pre><br>  Both types are unsigned integers: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned&lt;result_type&gt;::value &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned&lt;value_type&gt;::value &amp;&amp;</code> </pre><br>  The type of the result is smaller than the input type (parentheses are required!): <br><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(result_type) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value_type))</code> </pre><br>  All conditions are listed, close the condition of specialization: <br><br><pre> <code class="cpp hljs">::type</code> </pre><br>  For signed integers, where the result is of lower bitness, the condition will be similar, but with two `std :: is_signed` inside of` std :: enable_if`, but the condition for going beyond the limits of values ‚Äã‚Äãwill be somewhat different: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result_type&amp; result, value_type </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != (value &amp; (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;result_type&gt;::max() | <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;value_type&gt;::min()))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } result = result_type(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Again, remember the binary representation of signed integers: here the mask will be the sign bit of the input value and the value bits of the result type, excluding the sign bit.  Accordingly, the minimum number of the type `value_type`, where only the sign bit is filled, is combined bitwise with the maximum number of the type` result_type`, where all bits except the sign one are filled, and will give us the desired mask of acceptable values. <br><br>  For homework, consider the following cases: <br><br><ol><li>  Bringing signed to unsigned using already written specializations and the modifier `std :: make_unsigned`. </li><li>  Reduction of unsigned to significant higher resolution using already written specializations and the modifier `std :: make_signed`. </li><li>  Slightly more complicated: casting unsigned to signed less or equal to bitness using the no-exit condition and the `std :: make_signed` modifier. </li></ol><br>  It is also not difficult to write similar specializations for conversions from `std :: is_floating_point` types, as well as conversions from` bool` type.  For complete satisfaction, you can add a cast from and to string types and arrange it with the much-needed library of safe casting of C ++ types. <br><br><h4>  Unconventional thinking </h4><br>  For each use case of the pattern, there may be an exception.  Now you will be ready to meet him and correctly handle it.  A special meta-type in the template of the auxiliary structure is not always needed, but if it is time to process predicates at the compilation stage - well, there‚Äôs nothing to worry about.  All that is needed is to roll up the sleeves and neatly create a template construct with a compile time predicate. <br><br>  But be careful, the abuse of templates does not lead to good!  Treat templates as purely a generalization of code for different types with similar behavior; patterns should appear reasonably when there is a risk of replicating the same code for different types. <br><br>  Remember also that in order to understand the logic of the template predicate without the author of the code, you need to be at least a bold optimist, so take care of your colleagues ‚Äômind, make out the template predicates neatly, nicely and readably and feel free to comment on almost every condition in the predicate . <br><br>  Template the code carefully and only when necessary, and colleagues will thank you.  And do not be afraid to break the pattern in the event of an exception to the rule.  Rules without exceptions are rather exceptions to the rules. <br><br><img src="https://xakep.ru/wp-content/uploads/2015/02/COVER_02_2015_mid-326x420.jpg" alt="image"><br><br>  <i>First published in Hacker Magazine # 193.</i> <i><br></i>  <i>Author: Vladimir <a href="http://habrahabr.ru/users/qualab/" class="user_link">Qualab</a> Kerimov, Lead C ++ Developer, Parallels</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/257899/">https://habr.com/ru/post/257899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257889/index.html">Fast cross-platform HTML5 application on Framework7</a></li>
<li><a href="../257891/index.html">Escape from the dungeon types. We work with data, the type of which is determined dynamically.</a></li>
<li><a href="../257893/index.html">Place and conquer! Use host new to optimize C ++ code.</a></li>
<li><a href="../257895/index.html">The sad story of forgotten characters. How not to go crazy when working with encodings in C ++</a></li>
<li><a href="../257897/index.html">That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</a></li>
<li><a href="../257903/index.html">Introduction to functional programming in Python</a></li>
<li><a href="../257905/index.html">Travel SIM + cloud PBX and new approaches to the IP-PBX interface</a></li>
<li><a href="../257909/index.html">Sergey Borisyuk: ‚ÄúThe most important thing in startups is the focus‚Äù</a></li>
<li><a href="../257911/index.html">Determining network topology at OSI levels 2/3</a></li>
<li><a href="../257913/index.html">As I wrote a Docker container launch audit on Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>