<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Active Ranking Learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this post I am opening a series where my colleagues and I will tell you how ML is used in Mail.ru Search. Today I will explain how ranking is arr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Active Ranking Learning</h1><div class="post__text post__text-html js-mediator-article">  With this post I am opening a series where my colleagues and I will tell you how ML is used in Mail.ru Search.  Today I will explain how ranking is arranged and how we use information about user interactions with our search engine to make the search engine better. <br><br><h2>  Ranking task </h2><br>  What is meant by ranking task?  Imagine that in the training sample there are some set of queries for which the order of documents by relevance is known.  For example, you know which document is the most relevant, which is the second most relevant, etc.  And you need to restore this order for the entire population.  That is, for all requests from the general population, put the most relevant document in the first place, and the most irrelevant in the last. <br><br>  Let's see how such problems are solved in large search engines. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/a52/6c3/7f7a526c333c1e49c186b045e8dc86f6.png" width="600"></div><a name="habracut"></a><br>  We have a search index - this is a database of many billions of documents.  When a request arrives, we first generate a list of candidates for final ranking using simple text models.  The easiest option is to pick up documents that, in principle, contain words from the request.  Why is this step necessary?  The fact is that it is impossible for all available documents to build signs and form forecasting of the final model.  After we already calculate the signs.  What signs can we take?  For example, the number of occurrences of words from a query in a document or the number of clicks on a given document.  You can use complex machine-trained factors: we in the Search using neural networks predict the relevance of the document on demand and insert this forecast with a new column in our feature space. <br><br>  Why are we doing all this?  We want to maximize user metrics so that users find relevant results in our results as easily as possible and return to us as often as possible. <br><br>  Our final model uses an ensemble of decision trees built using gradient boosting.  There are two options for building a target metric for training: <br><br><ul><li>  We create a department of assessors - specially trained people to whom we give inquiries and say: "Guys, evaluate how relevant our issuance is."  They will respond with numbers that measure relevancy.  Why is this approach bad?  In this case, we will maximize the model with respect to the opinions of people who are not our users.  We will not optimize for the metric that we really want to optimize. <br></li><li>  For this reason, we use the second approach for the target variable: we show users the results, look at which documents they pass to, which ones skip.  And then we use this data to train the final model. <br></li></ul><br><h2>  How is the ranking problem solved? </h2><br>  There are three approaches to solving the ranking problem: <br><br><ul><li>  <b>Pointwise</b> , it is pointwise.  We will consider relevance as an absolute measure and will fine the model for the absolute difference between the predicted relevance and the one we know from the training sample.  For example, the assessor gave the document a rating of 3, and we would say 2, so we fine the model by 1. <br></li><li>  <b>Pairwise</b> , pairwise.  We will compare documents with each other.  For example, in the training sample there are two documents, and we know which one is more relevant for this request.  Then we will fine the model if it puts the forecast lower than the less relevant one, that is, the pair is incorrectly arranged. <br></li><li>  <b>Listwise</b> .  It is also based on relative relevance, but not inside the pairs: we rank the entire issue by the model and evaluate the result - if the most relevant document is not in the first place, we get a large fine. <br></li></ul><br>  Which approach is better to use for our target variable?  To do this, it is worth discussing an important question: ‚Äúcan clicks be used as a measure of the absolute relevance of a document?‚Äù.  It is impossible, because they depend on the position of the document in the issue.  After receiving the issue, you most likely click on the document that will be higher, because it seems to you that the first documents are more relevant. <br><br>  How can one test such a hypothesis?  We take two documents in the top of the issue and swap them.  If clicks were an absolute measure of relevance, then their number would depend only on the document itself, and not on the position.  But this is not so.  The document above always gets more clicks.  Therefore, clicks can never be used as a measure of absolute relevance.  Therefore, you can use either pairwise or listwise. <br><br><h2>  We collect a dataset </h2><br>  Now we extract the data for the training set.  We had this session: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/3c4/81c/a9e3c481c03dfce37e71ffc73485afc3.png" width="200"></div><br>  Of the four documents, there was a click on the second and fourth.  As a rule, people watch results from top to bottom.  You looked at the first document, you did not like it, clicked on the second.  Then they returned to the search, looked at the third and clicked on the fourth.  Obviously, you liked the second more than the first, and the fourth more than the first and third.  These are the pairs we generate for all queries and we use models for training. <br><br>  Everything seems to be fine, but there is one problem: people only click on documents from the very top of the issue.  Therefore, if you make the training sample in this way only, then the distribution in it will be exactly the same as in the test sample.  It is necessary to somehow align the distribution.  We do this by adding negative examples: these are documents that were at the bottom of the ranking, the user definitely did not see them, but we know that they are bad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/a4e/993/fc4a4e993e6c5611ffb36af4385fed7b.png" width="300"></div><br>  So, we got such a scheme for ranking training: they showed users the results, collected clicks from them, added negative examples to align the distribution, and retrained the ranking model.  Thus, we take into account the reaction of users to your current ranking, take errors into account and improve the ranking.  We repeat these procedures many times until convergence.  It is important to note that we search not only by the web, but also by video, by pictures, and the described scheme works fine in any type of search.  As a result, behavioral metrics grow very much.  In the second iteration, it is slightly smaller, in the third iteration it is even smaller, and as a result converges to a local optimum. <br><br>  Let's think about why we converge at a local optimum, and not at a global optimum. <br><br>  Suppose you are a football fan and in the evening did not have time to watch the match of your favorite team.  Wake up in the morning and enter the name of the team in the search bar to find out the result of the match.  See the first three documents - these are the official pages about the club, there is no useful information.  You will not leaf through the entire issue, will not pick up another request.  Perhaps you even click on some irrelevant document.  But as a result, get upset, close the SERP and open another search engine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/fdf/388/1f2fdf3881703461703e82dd9881c673.png"><br><br>  Although this problem is not only found in the search, it is especially relevant here.  Imagine an online store, which is one big tape without the ability to say which category of products you want to see.  This is exactly what happens with the search results: after sending the request, you can no longer explain what you really need: information about the football team or the score of the last match. <br><br>  Imagine that some brutal man went to such a strange online store, consisting of one tape of recommendations, and in his recommendations he sees only typically female goods.  Perhaps he even clicks on some dress, because it is worn on a beautiful girl.  We will send this click to the training set and decide that the man likes this dress more than sponge.  When he comes back into our system, he will already see some dresses.  Initially, we did not have products that were valid for the user, so this approach will not allow us to correct this error.  We were in a local optimum in which the poor person can no longer tell us that he does not like either sponges or dresses.  Often this problem is called the positive feedback problem. <br><br><h2>  Further improvement </h2><br>  How to make a search engine better?  How to get out of a local optimum?  New factors need to be added.  Suppose we made a very good factor that, upon request with the name of the football team, will raise a relevant document, that is, the results of the last match.  What could be the problem here?  If you train the model on old data, on offline data, then take the old dataset with clicks and add this attribute there.  It may be relevant, but you have not used it in the ranking before, and therefore people did not click on those documents for which this attribute is good.  It does not correlate with your target variable, so it simply will not be used by the model. <br><br>  In such cases, we often use this solution: bypassing the final model, we force our ranking to use this feature.  We forcibly show the result of the last match upon request with the name of the team, and if the user clicked on it, then for us this is the information that allows us to understand that the sign is good. <br><br>  Let's look at an example.  Recently we made beautiful pictures for Instagram documents: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/229/b9f/da0/229b9fda0570937619fc62b946ff81cb.png"><br><br>  It seems that such beautiful pictures should satisfy our users as much as possible.  Obviously, we need to make a sign that the document has such a picture.  We add to the dataset, retrain the ranking model and see how this feature is used.  And then we analyze the change in behavioral metrics.  They have improved a bit, but is this the best solution? <br><br>  No, because for many requests you do not show beautiful pictures.  You did not give the user the opportunity to show how he likes them.  To solve this problem, we, for some requests that involve showing Instagram documents, forcibly bypassing the model showed beautiful pictures and looked whether they clicked on them.  As soon as users appreciated the innovation, they began to retrain the model on datasets, in which users had the opportunity to show the importance of this factor.  After this procedure, on a new dataset, the factor began to be used many times more often and significantly increased user metrics. <br><br><hr><br>  So, we examined the statement of the ranking problem and discussed the pitfalls that will await you when learning feedback from users.  The main thing that you should take out of this article: using feedback as a training target, remember that the user can leave this feedback only where the current model allows him.  Such feedback can play a trick on you when trying to build a new machine learning model. </div><p>Source: <a href="https://habr.com/ru/post/461927/">https://habr.com/ru/post/461927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461913/index.html">Mobile usability in e-Commerce: analysis of the TOP-20 online stores in Russia</a></li>
<li><a href="../461919/index.html">Reusing forms on React</a></li>
<li><a href="../46192/index.html">Nokia E61: How to open a local HTML file</a></li>
<li><a href="../461921/index.html">HDMI-LVDS. Development on TSUMV59 from MStar</a></li>
<li><a href="../461923/index.html">JetBrains Open Day in St. Petersburg: video</a></li>
<li><a href="../461929/index.html">Monitoring and checking SSD status on Linux</a></li>
<li><a href="../46193/index.html">Keith Chambers' Wood Watch</a></li>
<li><a href="../461935/index.html">How to work with Postgres in Go: practices, features, nuances</a></li>
<li><a href="../461937/index.html">Parkinson's law and how to break it</a></li>
<li><a href="../461939/index.html">Year of adventure with graphene-python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>