<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Frogger game development for Vectrex computer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I was translating the story of Chris Salomon about his development of the Frogger game for the Vectrex computer . That story, written by...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Frogger game development for Vectrex computer</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I was translating the story of Chris Salomon about his development of the Frogger game for the <a href="https://habrahabr.ru/post/313218/">Vectrex computer</a> .  That story, written by him in 1998, is, in my opinion, a very interesting document, allowing you to feel the spirit of this unusual platform, and the specifics of development in assembly language in general. <br><br>  Chris did not abandon Vectrex and, relatively recently, brought to release his own Vectrex emulator for Windows (the best at the moment) called ‚ÄúVide‚Äù.  By the way, I am pleased that my <a href="http://enlight.ru/post/9575">Electric Force</a> sources helped him to implement decent support for displaying vector curves in this emulator. <br><br>  And now, having received such a powerful tool, Chris could not deny himself the pleasure of returning to his old Frogger to refine and improve it.  He told about it in his <a href="http://vide.malban.de/">blog</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, here I publish two parts of my translation - the first, about the original development of 1998 (from the file <a href="http://oldies.malban.de/firstvectrex/vectrex/DIS/CHRIS/VFROGGER/SOURCE/PROGGER.TXT">progger.txt</a> , wandered along with the source of the game) and the second - about its continuation (from <a href="http://vide.malban.de/">the author‚Äôs blog</a> ). <br><a name="habracut"></a><br><h2>  Year 1998. Start </h2><br><img src="https://habrastorage.org/files/631/fab/e7e/631fabe7e828465196e129841858601c.jpg"><br><br>  This file contains notes that may be of interest to other developers under Vectrex. <br>  It also includes a ‚Äúbrief‚Äù history of the development of the Vectrex Frogger. <br><br>  Image update in Vectrex Frogger always occurs at 50Hz.  Everything is drawn no more than 30,000 cycles.  Below are some notes about optimization techniques that allow this to be achieved. <br><br>  Actually, I am very much a city achieved speed!  It is possible that my functions for working with sprites are the fastest of all existing in games under Vectrex (at least, I like to think so ...) <br><br>  Sprites look a bit strange on a real Vectrex - slightly "spotty", however, you can get used to it.  They are spotted because I used for each of them a fixed scale (scale) 6. Long lines had to be made up of shorter ones.  Vectrex, by its nature, does not always turn off the beam when needed (two or three clocks later than necessary).  And it always turns on the beam for a few bars before starting drawing ... <br><br>  This leads to a bright point (it would be possible to write new functions for drawing vectors that do not use a timer and calculate time differently, more precisely, but who wants to do this?). <br><br>  Vectrex Frogger, among other things, was supposed to serve as a well-documented program for teaching programming on this computer.  It seems to me that I could not do it. <br>  Because of the gigantic number of vectors that had to be rendered in tiny intervals, it was necessary to optimize each beat.  Because of these optimizations, it seems to me, the program has ceased to be well read.  In the main loop, the call remains for a single BIOS function (polling the status of the digital joystick). <br><br>  All other calls were successively deleted and replaced by optimized (for specific situations) macros or subroutines. <br><br>  It is extremely difficult to grasp all this, unless you wrote it yourself. <br><br>  One of the applied optimization techniques: <br><br>  Explanation of how to draw a vector. <br><br>  ... <br><br>  Anyway, to move the beam to the desired position, you specify its speed, direction and time during which this speed is applied.  Then wait for that time to expire. <br><br>  Time is the scale you set.  If you set the scale to $ 90, this value should be written to timer 1 (VIA_t1_cnt_lo. Approx. Lane) and then, in a ‚Äúuseless‚Äù cycle, it is expected when it expires. <br><br>  What I did was make this cycle useful.  A significant part of the computation is done at Vectrex Frogger just at this, usually useless, time. <br><br>  I used this approach mainly when moving the beam.  A big plus here is that no matter how much I did at this time, it does not affect anything!  The only thing you have to watch out for is not to occupy time LESS than the timer value.  However, this is easily solved by the same timer polling cycle (VIA_int_flags - approx. Lane) at the end of your calculations. <br><br>  The same approach can be used while drawing a vector.  Drawing and moving a vector are the same.  The only difference is the ‚Äúpattern‚Äù written to the shift register.  0 is written to move there, $ FF for drawing (unless, of course, you want to draw a solid line). <br><br>  However, when drawing, you need to make sure that you turn off the beam (by writing 0 to the shift register) on time.  Otherwise, get a bright dot at the end of the vector! <br><br>  Another optimization method was to write a special function (macro) for drawing a list of vectors.  Each beat won there was worth its weight in gold. <br><br>  Suppose I print 30 sprites and each sprite consists of, say, 20 vectors.  This is about 600 vectors.  If I write an optimized function that will save about 10 cycles per vector, we will win about 6000 cycles with one blow !!! <br><br>  And yet - the unfolding of cycles!  In fact, I used this approach all the time with my programs on Watcom C, but I never thought that I would implement this myself.  Today I tried my luck by expanding the function of drawing the list of vectors.  Luck!  I won more than 10 cycles per EVERY vector.  This gave me another acceleration of almost 3000 clock cycles!  I spun only one cycle - the main sprite drawing cycle. <br><br>  The other important cycle of drawing sprites (for sprites of houses) would remain intact, although if I had optimized all the cycles in this way, I would probably have won between 500 and 1000 cycles.  But there is also a negative side - it makes the program much longer.  Well, we can't get everything, can we? <br><br>  Another technique has not been used, since it seems no longer necessary: <br>  The implementation of a new type of vector list, which would include information about the scale, can give a gain of several cycles, since many long lines would now be drawn short.  This can reduce losses if the list includes a second variable for length. <br><br>  <i>By the way:</i> <br>  The assembler that I used is VERY good.  For optimization, be sure to look at the * .lst file created by it.  It contains not only the code, but also the number of cycles for each instruction and their length ... True, very cool) <br><br>  A little about object definitions (specifically for the subroutines used in Vectrex Frogger): <br><br>  All items displayed in the game are now called objects.  These objects consist of two different entities - a list of vectors and an object structure definition.  The list of vectors is common for Vectrex.  First comes the number of vectors (minus 1), then the relative coordinates of the vectors (displacements). <br><br>  To facilitate collision fixation, all of these vector lists should start from the leftmost point.  In the earlier version of the subroutine, they should have been necessarily closed, but this is no longer required. <br><br>  The following is an example of the structure of an object (taken from Vectrex Frogger): <br><br><pre><code class="hljs pgsql">otter1a_object: DB <span class="hljs-number"><span class="hljs-number">0</span></span> ;  +  DW otter1a_sprite ;   DB <span class="hljs-number"><span class="hljs-number">0</span></span> ;   SCALE_FACTOR_GAME DB <span class="hljs-number"><span class="hljs-number">5</span></span> ;    DW otter1b_object ;      DB <span class="hljs-number"><span class="hljs-number">-4</span></span> ;  y  <span class="hljs-string"><span class="hljs-string">'SCALE_IN_HOME'</span></span>,    "" DB <span class="hljs-number"><span class="hljs-number">0</span></span> ;  x  <span class="hljs-string"><span class="hljs-string">'SCALE_IN_HOME'</span></span>,    "" DB <span class="hljs-meta"><span class="hljs-meta">$60</span></span> ;  DB <span class="hljs-number"><span class="hljs-number">0</span></span> ;  </code> </pre> <br>  Sprites are drawn with a fixed scale of 6 (this may change in future versions - I am thinking about a new list of vectors that will include information about the scale). <br><br>  Due to the highly optimized drawing routines, this cannot (and should not) be changed.  In fact, the subroutines are so optimized that they no longer draw exactly what they need. <br><br>  There are two problems: <br><br><ul><li>  The last vector in the list is truncated 2-4 bars before the one needed. <br><br></li><li>  Between objects in the list of objects (not yet mentioned), we always zero the beam (talking about zeroing integrators and setting the beam to the center by calling Reset0Ref - approx. Lane) <br>  This reset is not 100% correct (only 98% or something like that) <br><br>  In fact, the subroutine is slightly quick.  The beam does not have enough time to reach zero (this is in view of the fact that I have already slowed down the subroutine by 4 or 5 cycles, but this is not enough ...), which leads to a slightly noticeable inaccuracy in the positioning of objects. </li></ul><br>  Emulator Notes: <br><br>  Vectrex Frogger normally works on an emulator (here we are talking about DVE - approx. Lane), <i>however</i> : <br><br>  Optimization was done using this Vectrex, the emulator can not yet cope with some of the small things that are needed to verify the code.  They work fine as they are now.  But if you yourself will optimize something, you need a Vectrex - you will be upset, if on a real hardware everything works completely differently.  Especially it concerns exact observance of time intervals. <br><br>  The emulator does many things immediately, while a real Vectrex takes time.  For example, this is true for zeroing the beam and accessing any VIA register ... <br>  There are many interesting exponential functions for viewing on the screen of your Vectrex-a) <br>  (such as charging and discharging integrator capacitors). <br><br><h3>  Story </h3><br><img src="https://habrastorage.org/files/d6b/470/295/d6b470295aec47c8a028abf246d4bda1.jpg"><br><br>  My programming history is under Vectrex and, in particular, Vectrex Frogger. <br><br>  I first became interested in Vectrex in 1983, but I didn't have the money to buy it.  In 1996, I thought that I could test my skills as a programmer and write a Vectrex emulator.  However, Kate Wilkins thought in the same direction.  He laid out his source at the moment when I had only the first sketches of my emulator, so I threw them and began to look at the sources of Keith. <br><br>  Over the next 2 years, I improved his emulator in some aspects and I think that I now, like, am responsible for it. <br><br>  A few months ago, I thought it would be fun to turn DVE into Vectrex development environment, as it seemed to me that emulation was now good enough for this (although I now know that it‚Äôs not and may never be the case unless the Pentium III 500 MHz is released soon, and at an affordable price). <br>  Once again, I looked at the Internet for everything related to Vectrex programming to figure out what a programmer would need. <br><br>  Found quite a few.  A bit of disassembled game images, however, well documented.  Something from Clay and John, although I would not say that it is well documented (especially yours, John).  There was no ‚Äúreal‚Äù programming information.  So I decided that I had to figure it out myself. <br><br>  Somehow, one day, I sat down and tried to write my first game for Vectrex - VPONG.  It was written in about 4-5 hours and worked surprisingly well for a beginner, although it does not mean achievements in terms of playability (there is one player and it is rather difficult to play).  However, all that was needed was sound, vectors, text, joystick, buttons, scaling, fading, etc. <br><br>  The following week, the idea of ‚Äã‚Äãa Vectrex Frogger came to my mind, from which the first prototype of the sprite engine was born.  Then I made a ‚Äúdiscovery‚Äù that scaling with large values ‚Äã‚Äãis a bad idea. <br><br>  I thought about the speed of my program and the goal was one update (hereinafter we are talking about the complete rendering of one conditional ‚Äúframe‚Äù - until the next Wait_Recal call. Appro. Per.) At least 70,000 cycles, otherwise I would quit.  I figured that if this happens in 70,000 cycles, the refresh rate will be more than 20 Hz - i.e.  with an acceptable shimmer. <br><br>  At that time I already had Vectrex, but it was not connected to the parallel port of my computer yet (and well, as if I had figured out the connection then, I would have abandoned the whole project rather quickly). <br><br>  Experimenting with scale values, I learned that large values ‚Äã‚Äãcause updates to last more than 100,000 cycles.  Further checks revealed that small values ‚Äã‚Äãwork fine and I came up with about 50,000 ticks (by the way, the fact that I was responsible for the emulator sometimes helped a lot. I wrote an emulator function to measure the number of ticks - it was enough for me to type 'rc' and issued cycles required for updating) <br>  (now it‚Äôs quite clear that the scale actually affects, because this is a timer ... but then, knowing this too, I really didn‚Äôt know what that meant). <br><br>  In any case, I had in my hands a working sprite engine and all sorts of strange vector drawings moving across the screen in the manner of a frog.  My routines for working with sprites already supported animation, however, after making two or three sprites, I was completely tired of it.  Drew sprites in pencil on paper and translated coordinates into coordinates for Vectrex.  To do this for a heap of sprites - full! $ "$" &amp;! "$ &amp; = (!!! <br>  Fortunately, I found a friend who was looking for something to do and convinced him to make a small program for drawing vectors that saved coordinates in a way that I could easily work with in my program.  James (my friend) made such a program, and I was in charge of the main program. <br><br>  Pretty quickly, the joystick and collision detection routines were arranged. <br><br>  The first version of Frogger (initial levels) could be played after three days of programming, although you could not enter the house and no other special features were implemented. <br><br>  Again, I was a little tired of doing sprites.  I thought about some of the sub-programs even on the bus on the way home from work.  Subroutines that I generously dubbed "morphing routines." <br><br>  I had the idea that one list of vectors could slowly be changed into another, and that the result would be a cool effect.  I thought about this a bit and found that in 6809 there was no DIV instruction, and MUL was unsigned. <br><br>  I wrote two such functions and two (still existing) morphing routines (setup and do_one_step).  Oh, they were very slow - for dividing and multiplying many times per frame through handwritten subroutines I had to pay dearly, I tell you.  Soon, I replaced the divide function with an optimized version that worked as it should. <br><br>  So far, I had a morph function that could morph in any (8 bit) number of steps.  But it was still too slow for practical use.  After numerous optimizations, I came to the morphing function with a fixed number of steps - 16. This is the function that is used during the launch of the game and in some intermediate episodes. <br><br>  Having finished with this, I switched to sound.  I was always interested in what notes were what, until finally I figured it out (meaning BIOS-related Vectrex-a).  I can't read music and I am anyone, but not a musician. <br><br>  Having searched the Internet for notes of ‚ÄúThe yankee doodle‚Äù, I could not find anything.  It all ended midi file.  Then I started looking for a midi player / editor.  As a result, I found one that displayed the notes of a melody in a readable form.  In the end, I ‚Äúwrote‚Äù the yankee doodle music for Frogger. <br>  For me it was a great feat, really !!! <br><br>  In the beginning, I wanted the drum set theme, but it sounded pretty bad.  In the way that the melody is played now, three voices are used, with an octave shift in each.  It sounds so normal to me - in any case, I can‚Äôt recognize errors :-( <br><br>  Now it's time to add a couple of details.  This was what I was afraid of, because it meant entertainment with already ready code and the introduction of new things into it (of course, filled with bugs).  New items were flies, crocodiles, snakes, girls, a timer, a clock, an otter, floating turtles ... <br><br>  I programmed them all with my eyes closed, but I didn‚Äôt like a single minute of this activity.  To tell you the truth, I hated it.  However, these were things that I had to do in order for Frogger to be Frogger.  These damn games with idiotic time variables when flies appear, checking the coordinates again and again, if the frog is close to the snake's head, etc. ... I couldn‚Äôt tolerate it. <br><br>  But as you can see, I did it.  However, everything has its price.  Frogger became slow - he again became close to those 70,000 bars. <br><br>  At that time, I just received a cartridge with an EPROM for my Vectrex-a and running several different games, found that slow games flicker a lot :-(. I really did not like it. I still could not transfer my Frogger to Vectrex, because the ordered PROM emulator has not arrived yet, but I had several PROMs and I looked at them ... <br><br>  At that moment I was very worried about how Frogger would look on a real Vectrex, but I could not find anyone with a programmer. <br><br>  However, I realized that Frogger, as it is, was too slow, so I started thinking about optimization and trade-offs.  The first thing I did was delete the scoring of points, lives and the level indicator from the main screen.  Can you believe that one call to this idiotic 'print string' function takes more than 10,000 clock cycles !? <br><br>  Next, I edited all the sprites, trimmed them so that no more than 20 were used, but only 10-15 vectors, which resulted in a gain of about 10,000 strokes (I could not bear to edit all these sprites again!) <br>  (by the way, the turtle you see in the scrolling text is the ancestor of those turtles that crawl in the game itself). <br><br>  After that, I was sure that I could achieve my timing goal.  This goal has now become the rendering of each frame within 50,000 cycles, since all the measurements made on commercial games available to me meant that this value was reliable, and some games even went beyond its limits. <br><br>  <i>(Still waiting for the PROM emulator ...)</i> <br><br>  Since so far there was some free time, I decided that it would be good to implement the scrolling text.  Having a nearly finished frogger with ten lanes of moving sprites, I figured that making one strip of moving letters wouldn't be too difficult.  And indeed, after drawing all the letters 3 or 4 times (the vector drawing program had a serious bug) and after spending a certain amount of nerves, I got rid of it. <br><br>  However, now there is a new problem.  Vectrex has so much RAM!  (One kilobyte. Approx. Lane.).  Having information about levels and sprites, the need to store many other variables in RAM, do morphing and still have scrolling text - this was another challenge.  I changed the distribution of the RAM cells and began to use some of them twice and three times.  This was also done, although I later thought that Vectrex programming was still easy at the time. <br><br>  <i>(Still waiting for the PROM emulator ...)</i> <br><br>  So I just waited and the time went without any changes in the code. <br>  For a couple of weeks, I didn‚Äôt do anything, because the final check was to be done on a real Vectrex.‚Ä¶ <br><br>  Finally he arrived, connected and ... does not work ( <br>  I checked something ... Yes, it works, but the only PROM cartridge that I had had addresses only up to 8K, and Frogger had already exceeded this size by that time, so I couldn‚Äôt play my game ( <br>  (although, I played almost all the other games for the first time). <br>  Since I myself do not understand electronics and do not know how to remake a cartridge so that it works with a 16KB (or 32KB) PROM, I loudly called for help.  John heard my screams and sent me a couple of PROM cartridges that worked perfectly (it took another two weeks). <br>  The ability to have access to 8Kb for starters was also not so bad, so I was able to split the Frogger into a couple of parts and check them one by one.  Although it did not allow to evaluate all the features of the game, it is quite enough for partial verification. <br><br>  Here I discovered a strong wobble effect that the emulator could not reproduce.  After studying the issue, I realized that it was related to timings.  The reel was, for the most part, noticeable at startup.  And only when ‚Äúmotionless‚Äù vectors were drawn, animated or moving, somehow acquired something of an immunity type to this (strange?) <br>  Anyway, having caught a few gray hairs, I figured out that if the frame update takes more than 30,000 cycles, the fixed vectors start to wobble (at least on my Vectrex-e).  This concerned not only my game, but almost all games that had motionless vectors anywhere and required more than 30,000 frame updates. <br><br>  This was true even for Minestorm - the game built into Vectrex.  When the game was launched, after a few seconds, when the first mines appeared on the screen, the points were reeling (of course on my Vectrex, since I could only check on it). <br><br>  As soon as you know what this effect looks like, you begin to detect it quite often. <br>  Needless to say, I, as a perfectionist, did not like this at all. <br><br>  Other games can stagger as they please, but not my game.  And certainly not on the start screen that you see when you launch it. <br><br>  I still do not know what causes this effect - any technical information on this topic is welcome.  I thought that the only thing that would happen if the update took too much time was flickering.  But even if I set the ‚Äúrecalibration wait time‚Äù timer to more than the standard 30,000 clock ticks, the value, fixed vectors GO!  (usually the value of this timer is initialized when Vectrex is turned on and checked in Wait_Recal so that all the ‚Äúframes‚Äù take at least 3000 clock cycles. Approx.  I think there is a second ‚Äúfixing‚Äù value, somewhere in the region of 50,000, but the flickering is unacceptable. <br><br>  I changed the code so that the inscription 'VECTREX FROGGER' and everything else did not appear on the screen at the same time (this stupid text also requires about 5000-6000 cycles for drawing).  Reel (at start) is gone. <br><br>  But now I have found another effect ((which can still be seen on the present Vectrex, since I could not fix it in any reasonable way). The coordinates always drift slowly to +, + (up to the right). <br><br>  If you leave the beam alone for quite a long time, it will go up to the right.  Drawing a large frog at the beginning of the game by traversing a large list of vectors using a large scale is quite long.  To completely draw a giant frog, it takes about 2000-3000 cycles.  During this time, the beam floats about half a centimeter.  It is necessary to recalibrate the ray between the renderings, which would solve the problem.  But there is not enough time for this :-( (the frog consists of 63 vectors, and the positioning of 63 vectors at a given scale is impossible in no way that would not be time critical! <br><br>  (63 * $ 90 = 9000 net time of movement of the beam, without overhead <br>  63 * $ 70 = 7000 net time drawing vectors, no overhead <br>  overhead = 1000 cycles.  This is about 17,000 cycles only for a frog.  And I also wanted a scrolling text, plus the morph of the frog should be short!)). <br><br>  In addition, a fixed offset cannot be specified because the said drift is not constant.  It depends on the mood of my Vectrex (after all, this is an old analog machine).  So, the frog looks good on the emulator (if there is no drift in it), but on the real Vectrex, its tip is lost.  It bothers me a little, but cannot be fixed easily! <br><br>  Apart from this, everything seems to work just fine.  I spent a couple of weeks without doing Vectrex Frogger (and I didn‚Äôt miss him very much - after working for a while, I was happy to leave him, after all, alone). <br><br>  One day, John's cartridges finally arrived. <br>  I tried Frogger ... And he earned !!!  (disgusting :() <br><br>  Somehow, I avoided this before, but there were also motionless "wobbling" vectors in the game itself.  And they WENT :-( At that moment I was ready to quit everything. I was glad that I had achieved the goal of 50,000 cycles, considering that I wanted 70,000 at first. However, this was far from enough. To get rid of the reel, there was no other way than to achieve 30,000 cycles (in fact, this can be understood from the source Wait_Recal in the BIOS. Approx. Lane.) <br><br>  For some time I experimented to get rid of fixed vectors, inventing ‚Äúmoving‚Äù houses, dotted lines, etc.  But it almost did not help.  I was ALL upset.  My friend tried to console me by saying ‚Äúthis is not so bad,‚Äù but from my point of view it was bad.  I wanted to make a full-fledged full game of Vectrex Frogger WITHOUT compromise with "reel". <br><br>  I was thinking of changing all the sprites again in order to reduce the use of vectors, but this would lead to sprites as in the Atari 2600 - more guessable than distinguishable.  So, I refused this idea. <br><br>  Here I first tried to use the DP register (which was always always set to D0).  Its more or less reasonable use, together with other optimizations, saved me from 1,000 to 2,000 bytes of code.  This allowed me to again transfer some BIOS functions to my code and optimize them.  I won another 10,000 cycles and reached 40,000, but I wondered what else could be optimized. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Step by step, going through the code and looking at the * .lst file created by the assembler, I looked for bottlenecks in critical areas ... I did this for a day and a half ... moving in small steps and saving 10-20, sometimes even 100 cycles, I reached about 37,000. a long way and every next step was harder. I need a break ... I </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">played Diddy Kong perfectly on my N64 (yes, I have other consoles besides Vectrex) and I got the idea ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why not use the wait cycles in the beam positioning and vector drawing functions for something more useful than just waiting when the timer expires?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Said and done - after two days of hassle, the implementation of too fast functions, the appearance of exhibitors on the Vectrex screen, strange effects and ... and ... and ... I saved 5000 more ticks! (it was easy to say, but pretty much spoiled my nerves - see the source for details). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, I was at 32,000 (this is at worst - with four houses occupied, a girl, a crocodile, an otter and snakes on the screen ...) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, I couldn't think more about all these optimizations. I edited all levels, changed them, deleted sprites, rearranged sprites, turned off all sorts of chips, ..., etc., although the levels still had the character that I asked them at the beginning, despite the fact that most of them changed slightly . In the end, I did it! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVERY LEVEL UPDATED LESS THAN 30,000 TAKTS !!!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I really am very proud of my achievement. </font><font style="vertical-align: inherit;">And now I consider Vectrex Frogger an outstanding program for Vectrex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps this is just vanity on my part, but I put a lot of effort into Vectrex Frogger and hope that people will enjoy the game, and some may find the source useful and / or instructive. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP STOP </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another optimization success! </font><font style="vertical-align: inherit;">Today I spun a couple of cycles, which gave a speed gain of about 3000 clock cycles! </font><font style="vertical-align: inherit;">Hip-hip hooray! </font><font style="vertical-align: inherit;">I rolled back the changes of all levels and they still do not require more than 30,000 cycles ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I even have about 1500 cycles in stock :-) </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FINISHING THE FILE (Finally)</font></font></i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AHVY29DRTpA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Year 2016 </font><font style="vertical-align: inherit;">A fresh look at frogger</font></font></h2><br><img src="https://habrastorage.org/files/7a1/e5e/3ef/7a1e5e3ef38540e581f70bc596271435.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... this week I began to program Frogger closely. </font><font style="vertical-align: inherit;">In my plans:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Music and sound effects </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smoother graphics </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fit in with 30000 cycles </font></font></li><li>  Animation </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> View from the top down (many do not like the side view) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two player mode (take turns) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probably keeping records </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Screensaver prettier </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In recent weeks, I occasionally edited separate lists of vectors in Vide, but only this week I collected them together and transferred them to Frogger (see the gif). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I had to change the original source more than I expected, because the player's sprite had no animation. And entering the old source code, which is already 18 years old, did not simplify the matter either. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One way or another, as you can see, an animated frog from the top-down view is implemented. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I wrote earlier (almost 20 years ago, I remind you), one of my main tasks was to keep within 30 thousand cycles in order to avoid image oscillations. </font><font style="vertical-align: inherit;">Since I now wanted to add additional features, I had to peer into the code again.</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/757/e42/d4b/757e42d4b53b4f6e908c593c1ed9a55f.jpg"></a> <br><br> <a href=""><img src="https://habrastorage.org/files/ce1/04f/0a9/ce104f0a964c4d12b739bbc7ee15d4db.jpg"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I changed and tightened up the part that generated the lists of vectors, until it became mega-efficient. </font><font style="vertical-align: inherit;">True, the first level of the game (the most loaded) began to be drawn in just 22 thousand clock cycles! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One problem - the graphics were of the same type as before - ‚Äútypical‚Äù Vectrex'a vector graphics, when you often see a ‚Äúpoint‚Äù at one end of the line, because the beam ignites too early.</font></font><br><br>  Voila! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look at the new frog: isn't he beautiful? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although I did it myself, but still extremely excited about how vectors without dots look) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those in the subject:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At first I tried to go the usual way, using the timer T1 for scale and ramp, and shift for damping. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No matter how hard I tried, there was still some ‚Äúoverlap‚Äù. </font></font></li><li>      PB7 (ramp)  CB2 (blank) ‚Äî    .  ,     ,     ,     ,      Frogger'a. </li><li>  [  , . .]        ‚Äî    T1   ramp,   blank (CB2)   (..     ). </li><li>   ,        ,            . </li><li>   Frogger'a     (   )    25  . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Needless to say that, despite the fact that the Vide is a very good emulator, this kind of experiments with precise time keeping require this Vectrex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another great news is that it looks like this code works flawlessly on all three of my Vectrexes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, some videos - the first steps as a level in slot machines (however, as you can see, the transitions are not completed yet).</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/EFEBb2qNBx8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Continued ... </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I added a dispatcher to Frogger‚Äôs code. The old code for MoveTo-InBetween is called from the dispatcher. The dispatcher uses subroutines so, theoretically, clocks are spent on JSR and RTS, but the code looks so much nicer that I left it as it is (since I didn't really need extra clocks). </font><font style="vertical-align: inherit;">YM decoding [music, note] is done through the controller - I broke the decoding into 9 parts, each of which is independent of the others and they are called in different parts of MoveTo. Thus, YM decoding uses almost no extra clock cycles. </font><font style="vertical-align: inherit;">Almost finished editing sprites for the top view (see picture) - the sprites of two different cars, a van, a racing car and a tractor more or less resemble the originals.</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/46a/857/1c9/46a8571c9f844a0593949d4692edbefc.png"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, lists of vectors are about a third longer than those that were before. Although, I think it is now drawn about 40 vectors more than in the original Frogger for Vectrex. I counted only drawn objects, but in some scenes the number of vectors matters. The tractor alone consists of 26 individual vectors. For Vectrex this is a giant number. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also improved the playability somewhat by slightly stretching the game area. Frogger is now not so easy to go beyond the borders. It was very difficult to get to the far right house. Now jumping a little slower (because of the animation) and it is even more difficult. However, adding animation was a good idea. Jumping feels more like a frogger than it used to be.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is necessary to test a lot more gameplay, make sound effects and other things, but things are going well with the new version. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The continuation continues ... </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frogger again. Twice I checked the first 7 levels and changed their structure to reflect the changes made in the sprites. </font><font style="vertical-align: inherit;">Measurements in the Vide showed that Frogger again became a little slower - the 7th level with 4 occupied houses requires about 32 thousand cycles. Damn - I will have to fight again for tact - I thought it was over. </font><font style="vertical-align: inherit;">If you look at the available resources, I‚Äôve got a lot more behind me now than when I went to the university (look at the picture on the right - this is a self-made slot machine based on MAME - guess what Frogger is :) [here‚Äôs an intrigue, see further - approx. lane.] </font><font style="vertical-align: inherit;">Having gone beyond the limit of 30 thousand clock cycles, I no longer consider the possibility of adding a display of information about records during the game and this worries me!</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/696/177/dc5/696177dc5a0947fbab4b041bed08839d.jpg"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is another example of the current Frogger gameplay. I think I will add the missing sound effects last - when I double check and correct the levels.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ma0rQqCm9d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It feels like I'm moving back in time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just finished optimizing the code, winning about a thousand more cycles. However, I can not think of what else can be done. I have to save about a thousand more cycles (in the most difficult levels). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By optimizing the code, I can‚Äôt get it anymore, so I‚Äôll be editing new sprites - change them slightly. 26 vectors per tractor (for example) - not a ride. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I calculated that each drawn vector uses about 50 cycles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the most full levels, I need to save 50 vectors. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since about 20-25 objects are displayed, I have to shave about two vectors from each of them - this should be doable :-)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After each level will again fit into less than 30 thousand, I will do the rest of the effects, then it will all really look and feel like Frogger. </font><font style="vertical-align: inherit;">You also need to lick the "intermission" and make a better screensaver ... and, voila, I will finish somewhere in 2017 ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ten minutes of continuation .... </font></font></h2><br><img src="https://habrastorage.org/files/f9b/8f1/e0d/f9b8f1e0d4f14215a6fc7b94dcaa4038.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A small report on the progress in the work on the new version of Frogger. </font></font><br><br>  Almost done! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probably I'm still fixing something, optimizing and improving, but adding features is complete. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compared to the original Vectrex Frogger, the following things have changed:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> top view of cars and frog </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> smoother vectors </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> during gameplay points are displayed, levels and lives </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the game area is slightly extended </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> more sounds and music </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> one and two player options </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the single player mode, the option "training" is added </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> option to turn on / off music </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 best records saved in PR24 DS2431 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> new main screen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demo mode </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also deleted: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Intermissions" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pause mode </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far I have been wondering whether it is necessary to change the levels so that they look more like the ‚Äúoriginal‚Äù. </font><font style="vertical-align: inherit;">In the original Frogger (from slot machines), two adjacent strips of water moved in the same direction - this I have not yet taken into account. </font><font style="vertical-align: inherit;">So, the stripes above are felt differently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, enough talk ... Here is a ten-minute video of the current version:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kddLpfE7V3Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No more frogger! </font></font></h2><br><img src="https://habrastorage.org/files/e00/30d/bbb/e0030dbbbbc04c66b5e4dc9f7c994dac.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I stopped working on the source code and decided that there would be no new version of Vectrex Frogger. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to certain circumstances, which I will discuss below, Vectrex Frogger is dead and the only available version will be the one I did 18 years ago. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why am I not going to work on it anymore? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Everything is complete! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Except for possible bug fixes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why not be a new version of frogger? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Because I decided to rename it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know frogger is a popular name. However, to be honest, not one Vectrex game will reach the glory of the original. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, although the game on which I was working inspired Frogger, this is definitely another game! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So I decided to change the working title to the final one:</font></font><br><br><img src="https://habrastorage.org/files/1e9/96a/6d2/1e996a6d27ca4980bcc08950fe91261d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This title probably doesn‚Äôt tell you anything, but in the early 1990s I wrote a game under DOS, which was called that way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(see: </font></font><a href="http://malban.de/oldies/software/software-karl-quappe-like-frogger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karl Quappe - DOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or, on an older page: </font></font><a href="http://oldies.malban.de/firstpage/OWN_FROG.HTM"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karl Quappe - AOL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For readers who do not read German, the same title information as on the AOL page: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúKAULQUAPPE‚Äù translates as ‚ÄúTadpole‚Äù, ‚ÄúQUAPPE‚Äù is short for tadpole, and KARL is just a name similar to ‚ÄúKAUL‚Äù (homophone). So, if you want to translate it, for example, into English, you will get something like ‚ÄúCHARLES POLE‚Äù (Charles - English version of Karl) or Tedpole ('Ted' - a name that sounds like 'tad') '</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next is another short video. </font><font style="vertical-align: inherit;">There are no big changes, just something polished. </font><font style="vertical-align: inherit;">I let the game run itself - did not touch the buttons, so the gameplay that you see is a demo mode.</font></font><br><br>  Enjoy! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQKsjTAgY4c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/317656/">https://habr.com/ru/post/317656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317644/index.html">Ransomware Trojans - security theme of the year</a></li>
<li><a href="../317648/index.html">How we solved the problem of parental committees and earned a million rubles.</a></li>
<li><a href="../317650/index.html">Overclocking Swift build project in Xcode</a></li>
<li><a href="../317652/index.html">We supplement Scrum with architectural processes. Part 1. Requirements</a></li>
<li><a href="../317654/index.html">Another story about migration to the EU</a></li>
<li><a href="../317660/index.html">PostgreSQL slave + btrfs and systemd = hot test database</a></li>
<li><a href="../317662/index.html">Using Github as a user data store</a></li>
<li><a href="../317664/index.html">Briefly about the optimistic UI. Optimistic interface in pictures</a></li>
<li><a href="../317666/index.html">Limits Telegram bot API and work with them on Go</a></li>
<li><a href="../317668/index.html">Virtual keys to the real world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>