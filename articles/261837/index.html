<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32, C ++ and FreeRTOS. Development from scratch. Part 3 (LCD and Screens)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the two previous parts of STM32, C ++ and FreeRTOS. Development from scratch. Part 1 and STM32, C ++ and FreeRTOS. Development from ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32, C ++ and FreeRTOS. Development from scratch. Part 3 (LCD and Screens)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In the two previous parts of <a href="http://habrahabr.ru/post/261807//">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261807//">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261807//">Part 1</a> and <a href="http://habrahabr.ru/post/261823/">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261823/">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261823/">Part 2</a> I have already implemented the requirements of SR0, SR7, SR4 and SR6.  Again, you need to remember what the general requirements are. <br>  SR0: The device should measure three parameters (have three variables): <u>microprocessor temperature</u> , <u>voltage VDDA</u> , <u>voltage from a variable resistor</u> <br>  SR1: The device should display the value of these variables on the <b>indicator</b> . <br>  SR2: The unit of measurement for the <u>microprocessor temperature</u> is degrees Celsius, for the other parameters it is volts. <br>  SR3: When you press <b>button 1</b> , the <b>display</b> should show a screen with the next variable to be measured, <br>  SR4: When you press <b>button 1,</b> <b>LED 1</b> must change its state <br>  SR5: When you press <b>button 2</b> , the <b>display</b> should change the display mode of variables from constantly showing the variable to consecutive (changing screens every 1.5 seconds) when you next press from consecutive to constant, <br>  SR6: When you press <b>button 2,</b> <b>LED 2</b> should change its state. <br>  SR7: <b>LED 3</b> should blink once every 1 second. <br><br>  This means that the most ‚Äútasty‚Äù requirements related to the display of all measured information on the indicator have remained: SR1, SR2, SR3, SR5.  Well, let's start. <br><a name="habracut"></a><br><h4>  Development: indicator driver </h4><br>  I'll start with the indicator driver.  I remember (all the same notorious project of 8 years ago), I already wrote a conclusion to the indicator and it didn‚Äôt cause any particular problems for me, but it was a simple microcontroller, and then a whole ‚Äúprocessor‚Äù with a bunch of settings.  It is good that there are many detailed articles on how to properly configure the indicator driver and others like it.  For example, the publication of <a href="https://habrahabr.ru/users/halleffect/" class="user_link">HallEffect</a> <a href="http://habrahabr.ru/post/173709/">Working with the LCD indicator on the STM32L-Discovery debug board</a> , plus I dig into the source code of the demo project for the Olimex board, and of course I read the documentation in order to immediately understand all the "tricks" of modern microcontrollers.  And it gave its fruits - I got acquainted with such a wonderful thing as Bit Banding, it is very accessible here: <a href="http://blablacode.ru/%25D0%25BC%25D0%25B8%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B5%25D1%2580%25D1%258B/%25D1%2587%25D1%2582%25D0%25BE-%25D1%2582%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B5-bit-banding-%25D0%25BD%25D0%25B0-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B5-stm32.html">What is Bit Banding on the example of stm32</a> . <br><br>  Having lifted technical skills, I sat down for the next drawing, to describe the class of the driver cLcdDriver.  First, let's see how the indicator looks like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/edd/53e/3de/edd53e3de21d47078a30fe059bd56cbf.png" alt="image">  . <br><cut></cut><br>  As you can see in it, 2 lines are small (top) and BIG bottom and a bunch of other segments that I need.  I also decided to use only the bottom BIG line.  It will be enough to display the value of variables and units of measurement.  Well, we decided on where and what to display, and after drawing we got a class: <br><br><img src="https://habrastorage.org/files/28a/cb4/bd6/28acb4bd63834ddf98775c68dc4397af.png" alt="image"><br><br>  Now it's time to implement.  To begin with, it was necessary to configure a bunch of ports, namely 47 :) for an alternative LCD function.  But I am stubborn, I also had to switch the clocking of the LCD to the source from an external generator, because it didn‚Äôt work from the internal one when I debugged through it once.  It was all shoved into __low_level_init (). <br><br><div class="spoiler">  <b class="spoiler_title">indicator setting in __low_level_init</b> <div class="spoiler_text"><pre><code class="cpp hljs">/  LCD    ,   - <span class="hljs-comment"><span class="hljs-comment">//    RCC-&gt;CSR |= RCC_CSR_RTCRST; RCC-&gt;CSR &amp;= ~RCC_CSR_RTCRST; RCC-&gt;CSR |= RCC_CSR_LSEON; while(!(RCC-&gt;CSR&amp;RCC_CSR_LSERDY)) { } RCC-&gt;CSR |= RCC_CSR_RTCSEL_LSE; //   // PA.08  LCD COM0 //.08    .  174. CD00240194.pdf GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; //PA.08  LCD 0,  .189 CD00240194.pdf GPIOA-&gt;AFR[1]|= GPIO_AF_LCD; // PA.09  LCD COM1 //.09    .  174,189 CD00240194.pdf GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;AFR[1] |= GPIO_AF_LCD &lt;&lt; PIN9_SHIFT; // PA.10  LCD COM2 //.10    .  174,189 CD00240194.pdf GPIOA-&gt;MODER |= GPIO_MODER_MODER10_1; GPIOA-&gt;AFR[1] |= GPIO_AF_LCD &lt;&lt; PIN10_SHIFT; // PB.09  LCD COM3 //B.09    .  174,189 CD00240194.pdf GPIOB-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOB-&gt;AFR[1] |= GPIO_AF_LCD &lt;&lt; PIN9_SHIFT; // PA.01  LCD SEG0 //.01    .  174,189 CD00240194.pdf GPIOA-&gt;MODER |= GPIO_MODER_MODER1_1; GPIOA-&gt;AFR[0] |= GPIO_AF_LCD &lt;&lt; PIN1_SHIFT; // PA.02  LCD SEG1 //.02    .  174189 CD00240194.pdf GPIOA-&gt;MODER |= GPIO_MODER_MODER2_1; GPIOA-&gt;AFR[0] |= GPIO_AF_LCD &lt;&lt; PIN2_SHIFT; ... // PD.02  LCD SEG43 //D.02    .  174,189 CD00240194.pdf GPIOD-&gt;MODER |= GPIO_MODER_MODER2_1; GPIOD-&gt;AFR[0] |= GPIO_AF_LCD &lt;&lt; PIN2_SHIFT; // LCD: DUTY = 1/4, BIAS=1/4, MUX_SEG = disable //VSEL = 0 (  ) //PRESCALLER= 1/2, DIVIDER = ck_ps/20, BLINK =0, BLINKF=0, CC=VLCD4, DEAD = 0 //PON = 3, UDDIE = 0,SOFIE = 0, HD = 0, .  377-378 CD00240194.pdf //DUTY 1/4 //   1/2,   20   378. CD00240194.pdf LCD-&gt;FCR = LCD_FCR_PS_1 | (LCD_FCR_DIV_0 | LCD_FCR_DIV_2) | (LCD_FCR_PON_0 | LCD_FCR_PON_1) | LCD_FCR_CC_2 | LCD_FCR_CC_1; //     FCR while (!(LCD-&gt;SR &amp; LCD_SR_FCRSR )) { } LCD-&gt;CR |= (LCD_CR_DUTY_1 | LCD_CR_DUTY_0); //  LCD-&gt;CR |= LCD_CR_LCDEN;</span></span></code> </pre> <br></div></div><br>  Go ahead, the indicator driver built into the microcontroller has its own RAM, you need to write to it, and then display it on the indicator at once.  Here came to the rescue, and Bit Banding came, which allowed us to create an pTableSegs array of 166 elements (by the number of indicator segments) of the pointer to the addresses of tU32 cells - which are bits in RAM registers.  Setting 1 or 0 to such a tU32 cell automatically sets or resets the bit in the RAM register to which it is mapped.  The addresses of these cells are calculated using a sophisticated formula that I took from the documentation and the demo project. <br><br><pre> <code class="cpp hljs">/  BitBanding .  <span class="hljs-number"><span class="hljs-number">49.</span></span> CD00240194.pdf <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_MASK(seg) (seg &amp; (32-1)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_EL(seg,com) (volatile tU32 *)(PERIPH_BASE + 0x2000000 + ((0x2400 + 0x14 + ((com*2) + ((seg&lt;32)?0:1))*4)*32) + SEG_MASK(seg)*4)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    bitBandinga    volatile tU32* cLcdDriver::pTableSegs[] = { SEG_EL(39,3), // + 0 SEG_EL(39,0), // - 1 SEG_EL(37,3), // 1A 2 SEG_EL(37,2), // 1B 3 SEG_EL(37,1), // 1C 4 SEG_EL(37,0), // 1D 5 SEG_EL(39,1), // 1E 6 SEG_EL(39,2), // 1F 7 ... SEG_EL(5 ,1), // 11F 165 SEG_EL(4 ,1), // 11G 166 };</span></span></span></span></code> </pre><br><br>  Then everything was already a matter of technology.  The BIG LINE segments are composed like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ()  // _______a_______ // |\ | /| // fhjkb |col // | \ | / | // |___g__\ /__m___| // | / \ | | // eqpnc // | / | \ | // |/______d______\| |dp #define SEG_A ((tU32)1&lt;&lt;0) #define SEG_B ((tU32)1&lt;&lt;1) #define SEG_C ((tU32)1&lt;&lt;2) ... #define SEG_DP ((tU32)1&lt;&lt;14) #define SEG_COL ((tU32)1&lt;&lt;15)</span></span></code> </pre><br>  Accordingly, in order to derive, say, the letter C, you need to light a, d, e, f segments, so C looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Symbol_C (SEG_A | SEG_D | SEG_E | SEG_F)</span></span></code> </pre><br>  A little more had to tinker with a dot to bring it to the same place where the figure is displayed.  Well, in general, after quite a long and tedious work, such a footwoman came out: <br><br><div class="spoiler">  <b class="spoiler_title">lcddriver.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   tU32, tBoolean class cLcdDriver { public: explicit cLcdDriver(void); void showBigString(const char* pStr); private: void updateDisplay(void); tBoolean isReady(void); void showBigSymbol(const tU32 digitPlace, const char character, const tBoolean bDot); static volatile tU32* pTableSegs[]; static const tU32 charToLcdSymbol[]; static const tU32 bigDigitOffset[]; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">lcddriver.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lcddriver.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include &lt;stm32l1xx.h&gt; // STM32 #include "susuassert.h" // ASSERT #include "types.h" //  tPort, tU16, tU8 #include "bitutil.h" //     SETBIT, CLRBIT #include &lt;stddef.h&gt; // NULL #define BIG_SYMBOLS_COUNT 7 //   ()  //  BitBanding .  49. CD00240194.pdf //   : https://plus.google.com/115316880241890152471/posts/M7tzhpQiC9M #define SEG_MASK(seg) (seg &amp; (32-1)) #define SEG_EL(seg,com) (volatile tU32 *)(PERIPH_BASE + 0x2000000 + ((0x2400 + 0x14 + ((com*2) + ((seg&lt;32)?0:1))*4)*32) + (SEG_MASK(seg)*4)) #define SEG_A ((tU32)1&lt;&lt;0) #define SEG_B ((tU32)1&lt;&lt;1) #define SEG_C ((tU32)1&lt;&lt;2) #define SEG_D ((tU32)1&lt;&lt;3) #define SEG_E ((tU32)1&lt;&lt;4) #define SEG_F ((tU32)1&lt;&lt;5) #define SEG_G ((tU32)1&lt;&lt;6) #define SEG_H ((tU32)1&lt;&lt;7) #define SEG_J ((tU32)1&lt;&lt;8) #define SEG_K ((tU32)1&lt;&lt;9) #define SEG_M ((tU32)1&lt;&lt;10) #define SEG_N ((tU32)1&lt;&lt;11) #define SEG_P ((tU32)1&lt;&lt;12) #define SEG_Q ((tU32)1&lt;&lt;13) #define SEG_DP ((tU32)1&lt;&lt;14) #define SEG_COL ((tU32)1&lt;&lt;15) //     ()  // _______a_______ // |\ | /| // fhjkb |col // | \ | / | // |___g__\ /__m___| // | / \ | | // eqpnc // | / | \ | // |/______d______\| |dp #define Symbol_20 (tU32)0 #define Symbol_21 (tU32)0 #define Symbol_22 (tU32)0 #define Symbol_23 (tU32)0 #define Symbol_24 (tU32)0 #define Symbol_25 (tU32)0 #define Symbol_26 (tU32)0 #define Symbol_27 (tU32)0 #define Symbol_28 (tU32)0 #define Symbol_29 (tU32)0 #define Symbol_2A (tU32)0 #define Symbol_2B (SEG_J | SEG_M | SEG_P | SEG_G) // '+' #define Symbol_2C (SEG_DP) // ',' #define Symbol_2D (SEG_J | SEG_M) // '-' #define Symbol_2E (SEG_DP) // '.' #define Symbol_2F (SEG_K | SEG_Q) // '/' #define Digit_0 (SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_H | SEG_N) #define Digit_1 (SEG_B | SEG_C) #define Digit_2 (SEG_A | SEG_B | SEG_G | SEG_E | SEG_D | SEG_M) #define Digit_3 (SEG_A | SEG_B | SEG_C | SEG_D | SEG_G | SEG_M) #define Digit_4 (SEG_F | SEG_B | SEG_C | SEG_G | SEG_M) #define Digit_5 (SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_M) #define Digit_6 (SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E | SEG_M) #define Digit_7 (SEG_A | SEG_B | SEG_C) #define Digit_8 (SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G | SEG_M) #define Digit_9 (SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G | SEG_M) #define Symbol_3A (SEG_DP) //  ':' #define Symbol_3B (SEG_COL) //  ';' #define Symbol_3C (SEG_K | SEG_N) //  '&lt;' #define Symbol_3D (SEG_A | SEG_G | SEG_M) // '=' #define Symbol_3E (SEG_H | SEG_Q) // '&gt;' #define Symbol_3F (tU32)0 // '?'     :) #define Symbol_40 (SEG_D | SEG_E | SEG_F | SEG_A | SEG_B | SEG_M| SEG_J) // '@' #define Symbol_A (SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G | SEG_M) #define Symbol_B (SEG_A | SEG_K | SEG_N | SEG_D | SEG_E | SEG_G | SEG_F) #define Symbol_C (SEG_A | SEG_D | SEG_E | SEG_F) #define Symbol_D (SEG_A | SEG_B | SEG_C | SEG_D | SEG_J | SEG_P) #define Symbol_E (SEG_A | SEG_G | SEG_M | SEG_D | SEG_E | SEG_F) #define Symbol_F (SEG_A | SEG_G | SEG_M | SEG_E | SEG_F) #define Symbol_G (SEG_A | SEG_N | SEG_D | SEG_E | SEG_F) #define Symbol_H (SEG_F | SEG_E | SEG_G | SEG_M | SEG_B | SEG_C) #define Symbol_I (SEG_G | SEG_P) #define Symbol_J (SEG_B | SEG_C | SEG_D) #define Symbol_K (SEG_F | SEG_E | SEG_G | SEG_K | SEG_N) #define Symbol_L (SEG_F | SEG_E | SEG_D) #define Symbol_M (SEG_E | SEG_F | SEG_H | SEG_K | SEG_B | SEG_C) #define Symbol_N (SEG_E | SEG_F | SEG_H | SEG_N | SEG_B | SEG_C) #define Symbol_O Symbol_D #define Symbol_P (SEG_E | SEG_F | SEG_A | SEG_B | SEG_M | SEG_G) #define Symbol_Q (SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_N) #define Symbol_R (SEG_A | SEG_B | SEG_M | SEG_N | SEG_G | SEG_E | SEG_F) #define Symbol_S (SEG_A | SEG_F | SEG_G | SEG_M | SEG_C | SEG_D) #define Symbol_T (SEG_A | SEG_J | SEG_P) #define Symbol_U (SEG_F | SEG_E | SEG_D | SEG_C | SEG_B) #define Symbol_V (SEG_H | SEG_N | SEG_C | SEG_B) #define Symbol_W (SEG_F | SEG_E | SEG_Q | SEG_N | SEG_C | SEG_B) #define Symbol_X (SEG_H | SEG_Q | SEG_N | SEG_K) #define Symbol_Y (SEG_H | SEG_K | SEG_P) #define Symbol_Z (SEG_A | SEG_K | SEG_Q | SEG_D) #define BIG_SYMBOL_SIZE (16) //1  16 ,    // 1     2 (+  - ),    pTableSegs #define Big_Digit_0_offset (tU32)2 #define Big_Digit_1_offset (tU32)18 #define Big_Digit_2_offset (tU32)34 #define Big_Digit_3_offset (tU32)50 #define Big_Digit_4_offset (tU32)66 #define Big_Digit_5_offset (tU32)82 #define Big_Digit_6_offset (tU32)97 //   7   ,           . const tU32 cLcdDriver::bigDigitOffset[] = { Big_Digit_0_offset, Big_Digit_1_offset, Big_Digit_2_offset, Big_Digit_3_offset, Big_Digit_4_offset, Big_Digit_5_offset, Big_Digit_6_offset }; //  (ASCI   - ASCI  ' '())      const tU32 cLcdDriver::charToLcdSymbol[] = { Symbol_20, Symbol_21, Symbol_22, Symbol_23, Symbol_24, Symbol_25, Symbol_27, Symbol_27, Symbol_28, Symbol_29, Symbol_2A, Symbol_2B, Symbol_2C, Symbol_2D, Symbol_2E, Symbol_2F, Digit_0, Digit_1, Digit_2, Digit_3, Digit_4, Digit_5, Digit_6, Digit_7, Digit_8, Digit_9, Symbol_3A, Symbol_3B, Symbol_3C, Symbol_3D, Symbol_3D, Symbol_3F, Symbol_40, Symbol_A, Symbol_B, Symbol_C, Symbol_D, Symbol_E, Symbol_F, Symbol_G, Symbol_H, Symbol_I, Symbol_J, Symbol_K, Symbol_L, Symbol_M, Symbol_N, Symbol_O, Symbol_P, Symbol_Q, Symbol_R, Symbol_S, Symbol_T, Symbol_U, Symbol_V, Symbol_W, Symbol_X, Symbol_Y, Symbol_Z }; //    bitBandinga    volatile tU32* cLcdDriver::pTableSegs[] = { SEG_EL(39,3), // + 0 SEG_EL(39,0), // - 1 SEG_EL(37,3), // 1A 2 SEG_EL(37,2), // 1B 3 SEG_EL(37,1), // 1C 4 SEG_EL(37,0), // 1D 5 SEG_EL(39,1), // 1E 6 SEG_EL(39,2), // 1F 7 SEG_EL(38,2), // 1G 8 SEG_EL(38,3), // 1H 9 SEG_EL(36,3), // 1J 10 SEG_EL(36,2), // 1K 11 SEG_EL(36,1), // 1M 12 SEG_EL(36,0), // 1N 13 SEG_EL(38,0), // 1P 14 SEG_EL(38,1), // 1Q 15 SEG_EL(35,0), // 1DP 16 SEG_EL(35,3), // 2COL 17 SEG_EL(33,3), // 2A 18 SEG_EL(33,2), // 2B 19 SEG_EL(33,1), // 2C 20 SEG_EL(33,0), // 2D 21 SEG_EL(35,1), // 2E 22 SEG_EL(35,2), // 2F 23 SEG_EL(34,2), // 2G 24 SEG_EL(34,3), // 2H 25 SEG_EL(32,3), // 2J 26 SEG_EL(32,2), // 2K 27 SEG_EL(32,1), // 2M 28 SEG_EL(32,0), // 2N 29 SEG_EL(34,0), // 2P 30 SEG_EL(34,1), // 2Q 31 SEG_EL(31,0), // 2DP 32 SEG_EL(31,3), // 3COL 33 SEG_EL(29,3), // 3A 34 SEG_EL(29,2), // 3B 35 SEG_EL(29,1), // 3C 36 SEG_EL(29,0), // 3D 37 SEG_EL(31,1), // 3E 38 SEG_EL(31,2), // 3F 39 SEG_EL(30,2), // 3G 40 SEG_EL(30,3), // 3H 41 SEG_EL(28,3), // 3J 42 SEG_EL(28,2), // 3K 43 SEG_EL(28,1), // 3M 44 SEG_EL(28,0), // 3N 45 SEG_EL(30,0), // 3P 46 SEG_EL(30,1), // 3Q 47 SEG_EL(27,0), // 3DP 48 SEG_EL(27,3), // 4COL 49 SEG_EL(25,3), // 4A 50 SEG_EL(25,2), // 4B 51 SEG_EL(25,1), // 4C 52 SEG_EL(25,0), // 4D 53 SEG_EL(27,1), // 4E 54 SEG_EL(27,2), // 4F 55 SEG_EL(26,2), // 4G 56 SEG_EL(26,3), // 4H 57 SEG_EL(24,3), // 4J 58 SEG_EL(24,2), // 4K 59 SEG_EL(24,1), // 4M 60 SEG_EL(24,0), // 4N 61 SEG_EL(26,0), // 4P 62 SEG_EL(26,1), // 4Q 63 SEG_EL(23,0), // 4DP 64 SEG_EL(23,3), // 5COL 65 SEG_EL(21,3), // 5A 66 SEG_EL(21,2), // 5B 67 SEG_EL(21,1), // 5C 68 SEG_EL(21,0), // 5D 69 SEG_EL(23,1), // 5E 70 SEG_EL(23,2), // 5F 71 SEG_EL(22,2), // 5G 72 SEG_EL(22,3), // 5H 73 SEG_EL(20,3), // 5J 74 SEG_EL(20,2), // 5K 75 SEG_EL(20,1), // 5M 76 SEG_EL(20,0), // 5N 77 SEG_EL(22,0), // 5P 78 SEG_EL(22,1), // 5Q 79 SEG_EL(19,0), // 5DP 80 SEG_EL(19,3), // 6COL 81 SEG_EL(17,3), // 6A 82 SEG_EL(17,2), // 6B 83 SEG_EL(17,1), // 6C 84 SEG_EL(17,0), // 6D 85 SEG_EL(19,1), // 6E 86 SEG_EL(19,2), // 6F 87 SEG_EL(18,2), // 6G 88 SEG_EL(18,3), // 6H 89 SEG_EL(16,3), // 6J 90 SEG_EL(16,2), // 6K 91 SEG_EL(16,1), // 6M 92 SEG_EL(16,0), // 6N 93 SEG_EL(18,0), // 6P 94 SEG_EL(18,1), // 6Q 95 SEG_EL(15,0), // 6DP 96 SEG_EL(13,3), // 7A 97 SEG_EL(13,2), // 7B 98 SEG_EL(13,1), // 7C 99 SEG_EL(13,0), // 7D 100 SEG_EL(15,1), // 7E 101 SEG_EL(15,2), // 7F 102 SEG_EL(14,2), // 7G 103 SEG_EL(14,3), // 7H 104 SEG_EL(12,3), // 7J 105 SEG_EL(12,2), // 7K 106 SEG_EL(12,1), // 7M 107 SEG_EL(12,0), // 7N 108 SEG_EL(14,0), // 7P 109 SEG_EL(14,1), // 7Q 110 SEG_EL(1 ,3), // A1 111 SEG_EL(1 ,2), // A2 112 SEG_EL(1 ,1), // A3 113 SEG_EL(1 ,0), // A4 114 SEG_EL(2 ,0), // BRBL 115 SEG_EL(2 ,3), // B0 116 SEG_EL(2 ,2), // B1 117 SEG_EL(2 ,1), // B2 118 SEG_EL(0 ,3), // PL 119 SEG_EL(0 ,2), // P0 120 SEG_EL(0 ,1), // P1 121 SEG_EL(0 ,0), // P2 122 SEG_EL(43,0), // P3 123 SEG_EL(43,1), // P4 124 SEG_EL(43,2), // P5 125 SEG_EL(43,3), // P6 126 SEG_EL(42,3), // P7 127 SEG_EL(42,2), // P8 128 SEG_EL(42,1), // P9 129 SEG_EL(42,0), // PR 130 SEG_EL(3 ,0), // AL 131 SEG_EL(3 ,1), // AU 132 SEG_EL(3 ,2), // AR 133 SEG_EL(3 ,3), // AD 134 SEG_EL(15,3), // SB 135 SEG_EL(10,0), // 8A 136 SEG_EL(10,1), // 8B 137 SEG_EL(10,2), // 8C 138 SEG_EL(11,3), // 8D 139 SEG_EL(11,2), // 8E 140 SEG_EL(11,0), // 8F 141 SEG_EL(11,1), // 8G 142 SEG_EL(10,3), // 8P 143 SEG_EL(8 ,0), // 9A 144 SEG_EL(8 ,1), // 9B 145 SEG_EL(8 ,2), // 9C 146 SEG_EL(9 ,3), // 9D 147 SEG_EL(9 ,2), // 9E 148 SEG_EL(9 ,0), // 9F 149 SEG_EL(9 ,1), // 9G 150 SEG_EL(8 ,3), // 10P 151 SEG_EL(7 ,3), // 10COLON 152 SEG_EL(7 ,0), // 10A 153 SEG_EL(6 ,0), // 10B 154 SEG_EL(6 ,2), // 10C 155 SEG_EL(6 ,3), // 10D 156 SEG_EL(7 ,2), // 10E 157 SEG_EL(7 ,1), // 10F 158 SEG_EL(6 ,1), // 10G 159 SEG_EL(5 ,0), // 11A 160 SEG_EL(4 ,0), // 11B 161 SEG_EL(4 ,2), // 11C 162 SEG_EL(4 ,3), // 11D 163 SEG_EL(5 ,2), // 11E 164 SEG_EL(5 ,1), // 11F 165 SEG_EL(4 ,1), // 11G 166 }; /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cLcdDriver::cLcdDriver(void) { this-&gt;updateDisplay(); } /******************************************************************************* * Function: showBigString * Description:    ()  . ******************************************************************************/ void cLcdDriver::showBigString(const char* pStr) { tU32 digitPlace = 0; tBoolean bDot = FALSE; //   const char *pNextChar = pStr; pNextChar++; //  RAM    //  ,       //       TRUE //    while (digitPlace &lt; BIG_SYMBOLS_COUNT) { if (( *pNextChar == '.' ) || (*pNextChar == ',')) { bDot = TRUE; } if ((*pStr != '.') &amp;&amp; (*pStr != ',')) { if (*pStr != NULL) { this-&gt;showBigSymbol(digitPlace, *pStr, bDot); } else { this-&gt;showBigSymbol(digitPlace, ' ', FALSE); } digitPlace++; } pStr++; pNextChar++; bDot = FALSE; } //   this-&gt;updateDisplay(); } /******************************************************************************* * Function: showBigSymbol * Description:  ( )    , *      ******************************************************************************/ void cLcdDriver::showBigSymbol(const tU32 digitPlace, const char character, const tBoolean bDot) { ASSERT(character &gt; 0); ASSERT(character &lt; 61); volatile tU32 **p_data = &amp;this-&gt;pTableSegs[this-&gt;bigDigitOffset[digitPlace]]; tU32 mask = charToLcdSymbol[character - ' ']; //   ,     if (bDot == TRUE) { mask |= SEG_DP; } //      LCD-&gt;RAM   for(tU32 i = 0, j = 1; i &lt; BIG_SYMBOL_SIZE; i++, j &lt;&lt;= 1) { if(mask &amp; j) { **p_data = 1; } else { **p_data = 0; } ++p_data; } } /******************************************************************************* * Function: isReady * Description:    ******************************************************************************/ tBoolean cLcdDriver::isReady(void) { tBoolean result = FALSE; if (!CHECK_BITS_SET(LCD-&gt;SR,LCD_SR_UDR)) { result = TRUE; } return result; } /******************************************************************************* * Function: updateDisplay * Description:     ,    *    LCD ******************************************************************************/ void cLcdDriver::updateDisplay(void) { SETBIT(LCD-&gt;SR, LCD_SR_UDR); }</span></span></span></span></code> </pre><br></div></div><br>  I checked it simply by creating directly the indicator driver object in the main () function like this: <br><br><pre> <code class="cpp hljs">cLcdDriver *pLcdDriver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cLcdDriver(); pLcdDriver-&gt;showBigString(<span class="hljs-string"><span class="hljs-string">"HELLO"</span></span>);</code> </pre><br><br><h4>  Development: Logic of displaying information on the indicator </h4><br>  Well, that's all done with the driver.  It's time to start the logic of displaying information on the indicator.  I decided to think a little and not to rush right away to make an active class, but to think about how to form screens.  Since we have 3 different variables that should be displayed differently, there should be three different classes of screens for each of the variables.  But I wanted to manage them as one.  Therefore, it was necessary to first draw a single interface for all screens.  All screens should at least have access to the indicator driver and variables.  The driver here is the cLcdDriver class, and all the variables are in the cVariableDirector container, and the screen should be able to draw itself.  And now we draw: <br><br><img src="https://habrastorage.org/files/c88/207/960/c882079604274804b9b2dd420af5d8b0.png" alt="image"><br><br>  It's time to draw heirs to display the Temperature, Vdda and Trimmer screens.  They just have to implement a single virtual show () method, and therefore everything looks very trivial: <br><br><img src="https://habrastorage.org/files/1ca/9ee/2ba/1ca9ee2ba84a43588ca24eedaa49b5ee.png" alt="image"><br><br>  When implementing, I chose to convert tF32 to a string, and decided not to bathe, I used an old acquaintance sprintf, I could write a utility class for conversion, but I didn‚Äôt, and therefore the implementation looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">iscreen.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "lcddriver.h" // cLcdDriver #include "variablesdirector.h" //  cVariableDirector class iScreen { public: explicit iScreen(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector); virtual void show(void) = 0; protected: cLcdDriver *pLcdDriver; const cVariablesDirector *pVariablesDirector; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">iscreen.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iscreen.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "susuassert.h" //  ASSERT /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ iScreen::iScreen(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector) { ASSERT(pLcdDriver != NULL); ASSERT(pVariablesDirector != NULL); this-&gt;pLcdDriver = pLcdDriver; this-&gt;pVariablesDirector = pVariablesDirector; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">screentemperature.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lcddriver.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// cLcdDriver #include "variablesdirector.h" //  cVariableDirector #include "iscreen.h" // iScreen class cScreenTemperature : public iScreen { public: explicit cScreenTemperature(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector); void show(void); };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">screentemperature.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screentemperature.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "types.h" //    #include &lt;stdio.h&gt; //  sprintf /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cScreenTemperature::cScreenTemperature(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector) : iScreen(pLcdDriver, pVariablesDirector) { } /******************************************************************************* * Function: show * Description:    ******************************************************************************/ void cScreenTemperature::show(void) { char str[10]; tF32 value = this-&gt;pVariablesDirector-&gt;pTemperature-&gt;getValue(); sprintf(str, "T %4.1f C", value); this-&gt;pLcdDriver-&gt;showBigString(str); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">screentrimmer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"lcddriver.h"</span></span> <span class="hljs-comment"><span class="hljs-comment">// cLcdDriver #include "variablesdirector.h" //  cVariableDirector #include "iscreen.h" // iScreen class cScreenTrimmer : public iScreen { public: explicit cScreenTrimmer(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector); void show(void); };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">screentrimmer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screentrimmer.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "types.h" //    #include &lt;stdio.h&gt; //  sprintf /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cScreenTrimmer::cScreenTrimmer(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector) : iScreen(pLcdDriver, pVariablesDirector) { } /******************************************************************************* * Function: show * Description:       ******************************************************************************/ void cScreenTrimmer::show(void) { char str[10]; tF32 value = this-&gt;pVariablesDirector-&gt;pTrimmer-&gt;getValue(); sprintf(str, "P %3.2f V", value); this-&gt;pLcdDriver-&gt;showBigString(str); }</span></span></span></span></code> </pre><br></div></div><br>  Well, now we need a class to manage the entire <s>farm</s> family, and call it cScreenManager.  Recall the requirements: SR3: When you press the <b>button 1</b> , the screen should show the screen with the next variable to be measured.  Yeah, we need the NextScreen () method.  And the following requirement says: SR5: When you press <b>button 2</b> , the <b>indicator</b> should change the mode of displaying variables from constantly showing the variable to sequential (changing screens every 1.5 seconds) the next time you press from sequential to constant.  It is not difficult to guess that the desired method should be called NextMode () :) <br>  In addition, this cScreenManager should create all types of screens (we have three cTemperatureScreen, cTrimmerScreen and VddaScreen), but must work with them through a single interface, therefore all created screens will be stored in the iScreen array * pScreen [SCREEN_NUM]; <br><br>  So, draw again for clarity: <br><br><img src="https://habrastorage.org/files/9d6/fa9/eac/9d6fa9eac120435a9191826016aa3582.png" alt="image"><br><br>  And without departing from the cash register we realize: <br><br><div class="spoiler">  <b class="spoiler_title">screenmanager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "iscreen.h" // iScreen #define SCREEN_NUM (tU32)3 #define TEMPERATURE_SCREEN_ID (tU32)0 #define TRIMMER_SCREEN_ID (tU32)1 #define VDDA_SCREEN_ID (tU32)2 typedef enum { SM_single = 0, SM_sequence = 1 }tScreenMode; class cScreenManager { public: explicit cScreenManager(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector); void nextScreen(void); void nextMode(void); void show(void); private: iScreen *pScreen[SCREEN_NUM]; iScreen *pCurrentScreen; tU32 screenId; tScreenMode eMode; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">screenmanager.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screenmanager.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "screentemperature.h" // ScreenTemperature #include "screentrimmer.h" // ScreenTrimmer #include "screenvdda.h" // ScreenVdda #include "susuassert.h" //  ASSERT /******************************************************************************* * Function: constructor * Description:  3   ,   Vdda ******************************************************************************/ cScreenManager::cScreenManager(cLcdDriver *pLcdDriver, const cVariablesDirector *pVariablesDirector) { ASSERT(pLcdDriver != NULL); ASSERT(pVariablesDirector != NULL); this-&gt;pScreen[TEMPERATURE_SCREEN_ID] = (iScreen*)(new cScreenTemperature(pLcdDriver, pVariablesDirector)); this-&gt;pScreen[TRIMMER_SCREEN_ID] = (iScreen*)(new cScreenTrimmer(pLcdDriver, pVariablesDirector)); this-&gt;pScreen[VDDA_SCREEN_ID] = (iScreen*)(new cScreenVdda(pLcdDriver, pVariablesDirector)); this-&gt;screenId = TEMPERATURE_SCREEN_ID; this-&gt;pCurrentScreen = this-&gt;pScreen[this-&gt;screenId]; this-&gt;eMode = SM_single; } /******************************************************************************* * Function: show * Description:   ,           ******************************************************************************/ void cScreenManager::show(void) { switch (eMode) { case SM_single: this-&gt;pCurrentScreen-&gt;show(); break; case SM_sequence: this-&gt;pCurrentScreen-&gt;show(); this-&gt;nextScreen(); break; default: break; } } /******************************************************************************* * Function: nextScreen * Description:     ******************************************************************************/ void cScreenManager::nextScreen(void) { this-&gt;screenId ++; if (this-&gt;screenId &gt;= SCREEN_NUM) { this-&gt;screenId = TEMPERATURE_SCREEN_ID; } this-&gt;pCurrentScreen = this-&gt;pScreen[this-&gt;screenId]; } /******************************************************************************* * Function: nextMode * Description:      ******************************************************************************/ void cScreenManager::nextMode(void) { if (this-&gt;eMode == SM_single) { this-&gt;eMode = SM_sequence; } else { this-&gt;eMode = SM_single; } }</span></span></span></span></code> </pre><br></div></div><br>  Well, the final finishing touch is to make the active object for periodically displaying information on the indicator: <br><br><img src="https://habrastorage.org/files/e28/ea0/6d9/e28ea06d9bbc4e22a43742d114fcd661.png" alt="image"><br><br>  And the implementation is generally simple and clear: <br><br><div class="spoiler">  <b class="spoiler_title">lcddirector.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iactiveobject.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537   iActiveObject #include "lcddriver.h" //lint !e537  cLcdDriver #include "screenmanager.h" //lint !e537  cScreenManager #include "variablesdirector.h" //lint !e537  pVariableDirector class cLcdDirector : public iActiveObject { public: explicit cLcdDirector(const cVariablesDirector *pVariableDirector); virtual void run(void); private: cLcdDriver* pLcdDriver; cScreenManager *pScreenManager; };</span></span></span></span></code> </pre><br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lcddirector.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #include "susuassert.h" //  ASSERT #include "types.h" //    #include "buttonscontroller.h" //  tButton #include &lt;limits.h&gt; //  ULONG_MAX #define LCD_DELAY (tU32) (1500/portTICK_PERIOD_MS) /******************************************************************************* * Function: constructor * Description:    cLcdDriver      *   cScreenManager,     Lcd ******************************************************************************/ cLcdDirector::cLcdDirector(const cVariablesDirector *pVariablesDirector) { ASSERT(pVariablesDirector != NULL); this-&gt;pLcdDriver = new cLcdDriver(); this-&gt;pScreenManager = new cScreenManager(this-&gt;pLcdDriver, pVariablesDirector); } /******************************************************************************* * Function: run * Description:     .     *     ,    . ******************************************************************************/ void cLcdDirector::run(void) { tU32 button = (tU32) 0; tBoolean status = FALSE; tButtons eButton = BT_none; for(;;) { status = (tBoolean)oRTOS.taskNotifyWait((tU32)0, (tU32)ULONG_MAX, &amp;button, LCD_DELAY); if (status == TRUE) //lint !e731     { eButton = (tButtons)button; switch (eButton) { case BT_button1: this-&gt;pScreenManager-&gt;nextScreen(); break; case BT_button2: this-&gt;pScreenManager-&gt;nextMode(); break; case BT_none: break; default: break; } } this-&gt;pScreenManager-&gt;show(); } }</span></span></span></span></code> </pre><br>  And here it is the result of a 4 week trial with an AWP controller: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HH6YhvC8sbg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  When finished, I cleaned the project with a lint, he found a lot of things, here‚Äôs an example of an error found: <br>  Info 750: local macro 'Symbol_26' (line 65, file AHardware \ Lcd \ lcddriver.cpp) not referenced <br>  Info 750: local macro 'Symbol_3E' (line 89, file AHardware \ Lcd \ lcddriver.cpp) not referenced <br><br>  But the truth is, here in this array of the lcddriver.cpp file, the copy-paste worked and the two characters just disappeared, maybe it would have been discovered during the testing, but maybe not, but the lint is a good thing. <br><br>  <i>// conversion table (ASCI letter code - ASCI code "(space)) to a value on the indicator segments</i> <i><br></i>  <i>const tU32 cLcdDriver :: charToLcdSymbol [] =</i> <i><br></i>  <i>{</i> <i><br></i>  <i>Symbol_20,</i> <i><br></i>  <i>Symbol_21, Symbol_22, Symbol_23, Symbol_24, Symbol_25,</i> <i><br></i>  <i><b>Symbol_27</b> , Symbol_27, Symbol_28, Symbol_29, Symbol_2A,</i> <i><br></i>  <i>Symbol_2B, Symbol_2C, Symbol_2D, Symbol_2E, Symbol_2F,</i> <i><br></i>  <i>Digit_0, Digit_1, Digit_2, Digit_3, Digit_4,</i> <i><br></i>  <i>Digit_5, Digit_6, Digit_7, Digit_8, Digit_9,</i> <i><br></i>  <i>Symbol_3A, Symbol_3B, Symbol_3C, Symbol_3D,</i> <i><br></i>  <i><b>Symbol_3D</b> , Symbol_3F, Symbol_40, Symbol_A,</i> <i><br></i>  <i>Symbol_B, Symbol_C, Symbol_D, Symbol_E, Symbol_F,</i> <i><br></i>  <i>Symbol_G, Symbol_H, Symbol_I, Symbol_J, Symbol_K,</i> <i><br></i>  <i>Symbol_L, Symbol_M, Symbol_N, Symbol_O, Symbol_P,</i> <i><br></i>  <i>Symbol_Q, Symbol_R, Symbol_S, Symbol_T, Symbol_U,</i> <i><br></i>  <i>Symbol_V, Symbol_W, Symbol_X, Symbol_Y, Symbol_Z</i> <i><br></i>  <i>};</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that's all for now. </font><font style="vertical-align: inherit;">All the requirements set for me (me for me) are implemented, the RTOS is used, without a single semaphore and critical section (except for synchronization by notification, no additional ‚Äúcomplicated things‚Äù, the rest of the data is taken atomically and does not require blocking). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My personal observation and opinion - in 8 years microprocessors have stepped forward. </font><font style="vertical-align: inherit;">Programming is more and more like a high-level, many new useful blocks have appeared, and I think that students will like it a lot.</font></font></div><p>Source: <a href="https://habr.com/ru/post/261837/">https://habr.com/ru/post/261837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261827/index.html">DIY Robot Vacuum Cleaner</a></li>
<li><a href="../261829/index.html">Cackle Reviews full text search feedback system</a></li>
<li><a href="../261831/index.html">How to mount an image fsa</a></li>
<li><a href="../261833/index.html">The digest of interesting materials for the mobile # 110 developer (June 29-July 5)</a></li>
<li><a href="../261835/index.html">Polymorphic bonds for the smallest</a></li>
<li><a href="../261847/index.html">Adaptive carousel on AngularJS</a></li>
<li><a href="../261849/index.html">Elm or functional programming for the web, understandable to the teapot</a></li>
<li><a href="../261851/index.html">Windows 10 IoT - a small overview of the new edition of the OS for small devices</a></li>
<li><a href="../261853/index.html">Xonix to Javascript with pictures</a></li>
<li><a href="../261855/index.html">RTCOMM fell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>