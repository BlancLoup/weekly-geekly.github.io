<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fountain codes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about fountain codes . They are also called "non-fixed speed codes." Fountain code allows you to take, for example, any file, and c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fountain codes</h1><div class="post__text post__text-html js-mediator-article">  Today we will talk about <a href="http://en.wikipedia.org/wiki/Fountain_code">fountain codes</a> .  They are also called "non-fixed speed codes."  Fountain code allows you to take, for example, any file, and convert it into a virtually unlimited number of coded blocks.  Having some subset of these blocks, you can restore the original file, provided that the size of this subset is slightly larger than the file size.  In other words, this code allows you to create a "fountain" of the encoded data.  The recipient can restore the original data by collecting enough ‚Äúdrops‚Äù from the fountain, and it doesn't matter what ‚Äúdrops‚Äù he has, and which ones he missed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f94/cb2/99e/f94cb299e3594da6be19eedf0d602f19.jpg"></div><br>  A remarkable property of fountain codes is that their use allows you to send data via unreliable communication channels, for example, via the Internet, without relying on knowledge of the level of packet loss, and without requiring the recipient to contact the sender to recover the missing data fragments.  It is easy to see that such opportunities will be very useful in many situations.  Among them, for example, sending information over broadcast communication channels, as in video transmission systems on request.  The same category of tasks includes the operation of the Bittorrent protocol and other similar ones, when fragments of a file are distributed among a large number of peers. <br><a name="habracut"></a><br><h2>  <font color="#c75733">Basic principles</font> </h2><br>  It may seem that the fountain codes should be arranged terribly difficult.  But this is not the case.  There are different implementations of this algorithm, we suggest starting with the simplest of them.  This is the so-called Labie transform code, commonly referred to as LT code, from <a href="http://en.wikipedia.org/wiki/LT_codes">Luby Transform Code</a> .  When using this variant of fountain codes, the blocks are encoded as follows: <br><br><ol><li>  Choose from a range of 1 - k a random number d.  The range corresponds to the number of blocks in the file.  Below we talk about how best to choose d. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  Randomly select d file blocks and combine them.  In our case, the operation XOR is well suited. <br><br></li><li>  The block received at the previous step is transmitted along with information on which blocks it was created from. </li></ol><br>  As you can see, there is nothing complicated.  But it should be noted that much in this scheme depends on the so-called distribution of powers of the code symbols, on how they choose the number of blocks to be combined.  To this question we will return.  From the description, you can see that some of the coded blocks are actually created using only one block of source data, while several source blocks are involved in coding most of the blocks. <br><br>  Here is another coding feature, not quite obvious at first glance.  It lies in the fact that as long as we allow the recipient to know exactly which blocks we combine in order to get the output block, we do not need to explicitly transmit this list.  If the sender and the recipient agree on a certain pseudo-random number generator, you can initialize the generator with a randomly chosen number and use it to select the degree distribution and the set of source blocks.  The initial number is simply sent along with the coded block, and the recipient can use the same procedure as the sender used to encode to restore the list of source blocks. <br><br>  The decoding procedure is a bit more complicated, although it is also quite simple. <br><br><ol><li>  Restore the list of source blocks that were used to create the coded block. <br><br></li><li>  For each source block from this list, if it has already been decoded, perform an XOR operation with the encoded block and remove it from the list of source blocks. <br><br></li><li>  If at least two source blocks remain in the list, add the coded block to the temporary storage area. <br><br></li><li>  If only one source block remains in the list, it means that the next source block was successfully decoded!  You need to add it to the decoded file and go through the list of temporary storage, repeating this procedure for any source blocks that contain the found block. <br></li></ol><br><h2>  <font color="#c75733">0x48 0x65 0x6C 0x6C 0x6F, world!</font> </h2><br>  Consider the decoding example in order to better understand everything.  Suppose we get five coded blocks, each one byte long.  We also obtained information on the source blocks from which each of them was constructed.  These data can be represented as a graph. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/488/53f/b2e/48853fb2e0a984cb7c3ad7a491dfc329.png"></div><br>  <font color="#999999"><i>Graph</i> representing <i>the data</i></font> <br><br>  Nodes on the left are coded blocks received.  The nodes on the right are source blocks.  The first of the received blocks, 0x48, as it turned out, was formed with the participation of only one source block, the first one.  So we already know what that block was.  Moving in the opposite direction along the arrows pointing to the first source block, we see that the second and third coded blocks depend only on the first source block and on one another.  And, since the first source block is already known, we can perform an XOR operation on the received blocks and the first source block and decode a few more blocks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27e/6c2/662/27e6c26624a97332cced46306593e2d8.png"></div><br>  <font color="#999999"><i>Continue decoding the message</i></font> <br><br>  Repeating the same procedure again, you can see that it is now known enough to decode the fourth block, which depends on the second and third source blocks, each of which is already decoded.  Performing an XOR operation on them allows you to find the fifth, that is, the last source block in the list, as shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6db/fca/690/6dbfca6903a36fbf5a5a06e1830a92e2.png"></div><br>  <font color="#999999">Decoded <i>fifth source block</i></font> <br><br>  And, finally, you can now decode the last of the remaining source blocks, which, ultimately, will give the message that the sender wanted to send to the recipient. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b28/541/ddcb285410a3b484c3c182d29434970c.png"></div><br>  <font color="#999999">Fully <i>decoded message</i></font> <br><br>  Admittedly, the example is artificial.  Here we proceed from the assumption that only the blocks necessary for decoding the original message are received.  In addition, among the blocks there is nothing superfluous, and the blocks themselves are arranged in a very convenient order.  But this is just a demonstration of the principles of operation of fountain codes.  We are sure that thanks to this example you will be able to understand how the same procedures work with larger blocks and longer files. <br><br><h2>  <font color="#c75733">About perfect distribution</font> </h2><br>  It was said earlier that how the number of source blocks is selected, of which each of the encoded blocks should consist of, or the distribution of powers of the code symbols, is very important.  And, in fact, the way it is.  Ideally, the algorithm should generate a small number of coded blocks, to create which only one source block is used.  It is necessary for the recipient to proceed with the decoding of the message.  However, the majority of coded blocks should depend on a small number of other blocks.  The whole thing - in the correct selection of the distribution.  A similar distribution, perfect for our purposes, exists.  It is called the ideal <a href="http://en.wikipedia.org/wiki/Soliton_distribution">distribution of the soliton</a> . <br><br>  Unfortunately, in practice, this distribution is not so perfect.  The fact is that random variations lead to the fact that some blocks of the source are not used, or to the fact that decoding stops when the decoder ends with known blocks.  One of the variants of such a distribution, called the robust soliton distribution, makes it possible to improve the performance of the algorithm, generating more blocks from a very small number of source blocks, as well as generating some blocks that are a combination of all or nearly all of the source blocks.  This is done to facilitate the decoding of a certain number of the last blocks. <br><br>  Here, in brief, how fountain codes work, and, in particular, LT codes.  It must be said that LT codes are the least effective known fountain codes, but they are also the easiest to understand. <br><br><h2>  <font color="#c75733">Peer Networks and the Problem of Trust</font> </h2><br>  Before we end this conversation, here‚Äôs another thought.  Fountain codes can look perfect for systems like Bittorrent, allowing sids to generate and distribute a virtually unlimited number of blocks, more or less eliminating the ‚Äúlast block‚Äù problem in cases where there are few of them, and ensuring that two random peers almost always have useful information which can be shared with each other.  However, there is one important problem.  The fact is that it is very difficult to verify the data received from peers. <br><br>  Peering protocols use secure hashing functions, such as SHA1, while the trusted party, the creator of the distribution, provides a list of valid hashes to all peers.  Each peer, using this data, can check loaded fragments of a file.  However, when using fountain codes, this scheme of work becomes more complicated.  There is no way to calculate, for example, the SHA1 hash of the encoded fragment, even knowing the hashes of the individual fragments that took part in its formation.  And we cannot trust other peers to calculate this hash for us, since they can simply deceive us.  We can wait until we collect the entire file, and then, using the list of invalid fragments, we can try to find the incorrect encoded fragments, but this is difficult and unreliable.  Moreover, with this approach, errors can be found only in the final assembly of the file, that is, it will most likely take too much time.  One possible alternative is for the distribution creator to publish the public key and sign each generated block.  Thus, we can check the coded blocks, but there is a serious minus here.  The fact is that only the creator of the distribution can generate the correct blocks, which means we immediately lose most of the advantages of using fountain codes.  It seems that here we are at an impasse.  However, there are alternatives, for example, a very clever scheme called homomorphic hashing.  Although it is not perfect. <br><br><h2>  <font color="#c75733">Conclusion</font> </h2><br>  We talked about the basics of fountain codes.  Varieties of this algorithm have found <a href="http://ieeexplore.ieee.org/xpl/login.jsp%3Ftp%3D%26arnumber%3D5407203">practical application</a> in areas where its merits clearly outweigh the disadvantages.  If you are interested in this topic and you want to go deeper into it, read <a href="http://switzernet.com/people/emin-gabrielyan/060112-capillary-references/ref/MacKay05.pdf">this material</a> on fountain codes.  In addition, it will be useful to get acquainted with <a href="http://en.wikipedia.org/wiki/Raptor_codes">Raptor-codes</a> , which, slightly complicating LT-codes, significantly improve their effectiveness.  Thanks to their use, you can reduce the amount of transmitted data and the computational complexity of the algorithm. <br><br><blockquote><div class="spoiler">  <b class="spoiler_title">Oh, and come to work with us?</b>  <b class="spoiler_title">:)</b> <div class="spoiler_text">  <a href="http://wunderfund.io/"><b>wunderfund.io</b></a> is a young foundation that deals with <a href="https://en.wikipedia.org/wiki/High-frequency_trading">high-frequency algorithmic trading</a> .  High-frequency trading is a continuous competition of the best programmers and mathematicians of the whole world.  By joining us, you will become part of this fascinating fight. <br><br>  We offer interesting and challenging data analysis and low latency tasks for enthusiastic researchers and programmers.  Flexible schedule and no bureaucracy, decisions are quickly made and implemented. <br><br>  Join our team: <a href="http://wunderfund.io/">wunderfund.io</a> </div></div></blockquote></div><p>Source: <a href="https://habr.com/ru/post/302638/">https://habr.com/ru/post/302638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302626/index.html">Artificial Intelligence is changing SEO faster than you think.</a></li>
<li><a href="../302628/index.html">A bit about the Stream API (Java 8)</a></li>
<li><a href="../302630/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ214 (May 30 - June 5, 2016)</a></li>
<li><a href="../302632/index.html">Digest of grocery design, May 2016</a></li>
<li><a href="../302634/index.html">Simultaneously Mounting Encrypted Folders in Synology DSM</a></li>
<li><a href="../302642/index.html">How to raise CI for iOS developers in a day. Part 2</a></li>
<li><a href="../302644/index.html">Hacking VKontakte: data stolen 171 million users</a></li>
<li><a href="../302646/index.html">Why Gorodor can be useful to you if you already have an RA or media?</a></li>
<li><a href="../302648/index.html">Aytreker in the service of a presentation consultant</a></li>
<li><a href="../302650/index.html">Inertial sensors: cooking recipes for positioning systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>