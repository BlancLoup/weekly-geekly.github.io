<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Structure and execution model of .NET Core applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will look at the components of the .NET Core 2.0 platform that are required to load and run .NET Core applications, as well as the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Structure and execution model of .NET Core applications</h1><div class="post__text post__text-html js-mediator-article">  In this article, I will look at the components of the .NET Core 2.0 platform that are required to load and run .NET Core applications, as well as the artifacts for two possible types of deployment. <br><br>  The text is voluminous and designed for: <br><br><ul><li>  novice developers who are just familiar with the .NET Core platform; </li><li>  experienced developers performing the role of DevOps-engineers in the production environment. </li></ul><br>  The article does not mention the process of creating applications using the SDK (dotnet CLI), but this information will be useful for understanding how the SDK works, namely its main component (core) - ‚Äúdriver‚Äù dotnet.dll, since this library is a managed assembly and running on .NET core. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Examples of execution processes are described for Windows OS, but they work on the same principle on other OSs (taking into account various extensions of executable files and native libraries). <br><a name="habracut"></a><br><h2>  0. Pay-for-Play </h2><br><img src="https://habrastorage.org/webt/oc/eo/-p/oceo-pikk2apsui2ky-cmch9a7m.jpeg"><br><br>  Every .NET developer knows from the cradle: to run any .NET application, the .NET Framework, namely CLR + BCL, must be installed on the target computer. <br><br>  BCL is located in the GAC, from where the applications load the dependencies necessary for the operation. <br><br>  In general, the .NET Core architecture looks the same: .NET Core = Core CLR + Core FX (new name for BCL), but differs in the way these components are enabled, as well as in the way of loading the runtime environment (CLR).  Instead of the header in the managed assembly MyApp.exe in the .NET Framework, in .NET Core, MyApp.exe itself is the native Core CLR download program. <br><br>  In .NET Core, all program components that we define at compile time are application dependencies (including Core CLR, JIT) that the .NET Core infrastructure treats as packages.  Such a package is called <b>asset</b> , and it can be either a NuGet package or a regular file. <br><br>  Examples of components that are shipped via NuGet: <br><br><ul><li>  Microsoft.NETCore.Runtime.CoreCLR - Core CLR. </li><li>  Microsoft .NETCore.Jit - JIT compiler. </li><li>  System.Private.CoreLib - the base types are System.Object, System.Int32, System.String (analog mscorlib.dll). </li><li>  System.Console - console access. </li></ul><br>  When the application is launched, these uncompressed dependencies must be located in one of the specific directories (the .NET Core framework - Core FX folder, the application folder, or any NuGet cache). <br><br>  Thanks to this model, the .NET Core application consists of a frighteningly huge number of small modules, but this is done to reduce the amount of unnecessary dependencies. <br><br>  This approach is called pay-for-play;  in other words, applications download only the functionality that they need, but each such functionality is contained in a separate assembly. <br><br><h2>  1. FDD vs SCD </h2><br>  There are <a href="https://docs.microsoft.com/en-us/dotnet/articles/core/deploying/index">two types of deployment of .NET Core applications</a> : <br><br><ul><li>  Portable (Framework-dependent deployment - FDD) </li><li>  Standalone (Self-contained deployment - SCD) </li></ul><br>  <b>A portable (FDD)</b> application is similar to a traditional .NET Framework application.  In this case, a specific version of the .NET Core framework (the terms shared framework, .NET Core Runtime, redist are also used) must reside on the target computer, and when it starts, the host process will load Core CLR, Core FX from the framework folder. <br><br>  In the <b>Standalone (SCD)</b> application, all components for execution (CoreCLR, CoreFX), as well as third-party libraries, that is, absolutely all dependencies, are shipped with the application itself (most often in the same folder). <br><br>  It is important to understand that a standalone application is tied to a specific OS and architecture (for example, Windows 7 x64 or OSX 10.12 x64).  This identifier is called the <a href="https://docs.microsoft.com/en-us/dotnet/articles/core/rid-catalog">Runtime identifier (RID)</a> .  Each OS / architecture has its own version of the Core CLR library (and other native components), so for the Standalone applications, at the compilation stage, in the RuntimeIdentifier property, you must specify the target system parameters (RID). <br><br>  Such an application will work on any computer with a specific OS / architecture, regardless of whether .NET Core is installed or not. <br><br><h2>  2. .NET Core Runtimes (shared frameworks) </h2><br>  To run portable applications, at least one <a href="https://www.microsoft.com/net/download/core">.NET Core Runtime</a> (shared framework) must be installed on the target machine. <br><br>  The .NET Core Runtime is installed in the <i>C: \ Program Files \ dotnet folder</i> : <br><br><img src="https://habrastorage.org/web/ea5/a76/b9f/ea5a76b9fe784a578ed08939d28a2ceb.png"><br><br>  The framework files (s) are stored in the <i>C: \ Program Files \ dotnet \ shared</i> folder. <br><br>  The main components of the .NET Core Runtime: <br><br><ul><li>  "Utility" dotnet.exe to run. NET Core-applications.  It is called a <b>multiplexer (muxer)</b> , and is the main driver of the .NET Core infrastructure.  This program serves as an ‚Äúentry point‚Äù for launching any applications and executing development commands.  if the .NET Core SDK is installed, that is, the host process of any application is <a href=""><b>corehost</b></a> . </li><li>  Runtime components (CoreCLR, CoreFX, etc.) are installed into a separate folder of the C: \ Program Files \ dotnet \ shared \ [Framework name] \ [Framework version] framework. </li><li>  Host framework resolver - the native library, located in the folder <br>  C: \ Program Files \ dotnet \ host \ [version] \ hostfxr.dll.  When the application is launched, the maximum version of this library performs the resolution of the framework version for the subsequent execution of the application. </li></ul><br>  <a href="">File structure when installing the .NET Core Runtime</a> . <br><br>  You can install multiple versions of the framework: <br><br><img src="https://habrastorage.org/web/926/763/c8a/926763c8aa04410abff017ec74eef610.png"><br><br>  To execute a portable application, you must run the dotnet.exe host process and pass the path to the managed assembly as an argument. <br><br>  "C: \ Program Files \ dotnet" is added to the value of the PATH environment variable, so that Portable applications can now be run from the command line: <br><br> <code>&gt; dotnet path/to/App.dll</code> <br> <br>  In the application folder (where [AppName] .dll is located) the [AppName] .runtimeconfig.json file should be located.  It contains the name and version of the framework that should be used to run the Portable application.  For example: <br><br>  <b>MyApp.runtimeconfig.json</b> <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"runtimeOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Microsoft.NETCore.App"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0.0"</span></span> } } }</code> </pre> <br>  This file is required for portable applications. <br><br>  Having the above configuration, the runtime components will be downloaded from the <i>C: \ Program Files \ dotnet \ shared \ <b>Microsoft.NETCore.App</b> \ <b>2.0.0</b></i> folder. <br><br><h2>  3. Structure of a Portable (FDD) .NET Core application </h2><br>  Any Portable .NET Core application consists of the following required files: <br><br><ul><li>  [AppName] .dll - application IL, entry point. </li><li>  [App dependencies] *. Dll - all application dependencies that are not part of CoreFX (project builds, third-party libraries, FCL). </li><li>  [AppName] .runtimeconfig.json - runtime <a href="">configuration</a> , here are the name and version of the .NET Core framework (runtime components).  The file is something like MyApp.exe.config in .NET Frameowork.  This configuration can be changed if you need to explicitly specify a specific framework. </li><li>  [AppName] .deps.json - a list of all application dependencies.  It is not recommended to change this file because it is generated at compilation.  The file is not mandatory, but if you delete it, the host process at startup will not be able to check the paths of all dependency files, and execution will start at your own risk. </li></ul><br>  <a href="https://docs.microsoft.com/en-us/aspnet/core/hosting/directory-structure">Documentation</a> <br><br>  Artifacts of the same Portable application for different versions of the .NET Core platform: <br><br> <a href=""><img src="https://habrastorage.org/webt/ty/x-/br/tyx-brjjjwt4-xxxxy6jvferohi.png"></a> <br><br>  The reduction in the number of files is due to the fact that many libraries were missing from Core FX 1.0, so they went as part of the application, like normal dependencies.  In Core FX 2.0, these assemblies have been added, so they are no longer shipped with the application, but are taken from the framework folder. <br><br><h2>  4. Standalone (SCD) .NET Core Application Structure </h2><br>  Same as for a Portable (FDD) application, but additionally contains all the runtime components (CoreCLR, CoreFX) and its own dotnet.exe <b>multiplexer</b> , renamed [AppName] .exe.  For .NET Core pre-2.0, the multiplexer for running a standalone application is identical to C: \ Program Files \ dotnet.exe (the same file, just renamed).  For .NET Core 2.0, a multiplexer from the Microsoft .NETCore.DotNetAppHost NuGet is used.  The package contains one apphost.exe file, which, when compiled, is ‚Äústitched‚Äù in the assembly name (MyApp.dll), and the file itself is renamed to MyApp.exe.  When you start a standalone application, the binding of the executable file (MyApp.exe) to the name of the assembly that it can run (MyApp.dll) is checked. <br><br>  The contents of the same Standalone application for different versions of the .NET Core platform: <br><br> <a href=""><img src="https://habrastorage.org/web/18f/e60/b03/18fe60b03c1f4b9281b33098d18dda4a.png"></a> <br><br>  There is a picture opposite of Portable applications - the more Core FX becomes, the more files comes with the application. <br><br>  <b>Deployment Type Guidelines</b> <br><br><ul><li>  Always give preference to a portable deployment, because this type is much smaller and more stable when running large applications with a large number of dependencies.  In addition, portable applications are easier to set up, because they do not depend on the RID. </li><li>  Choose Standalone if it is not possible to install the .NET Core Runtime, or if the duration of the application launch is critical.  In the Standalone version, you can win 1-2 seconds at startup by deleting the configuration file [AppName] .deps.json (remember, this also makes you responsible for having all the dependency files). </li></ul><br><h2>  5. Runtime Configuration Files </h2><br>  The [AppName] .runtimeconfig.json and [AppName] .deps.json files are called the <a href="">Runtime Configuration Files</a> (* .deps.json are called the dependency manifest file).  They are created during the compilation process and contain all the information necessary to run dotnet.exe and run the application. <br><br>  In <b>[AppName] .runtimeconfig.json, the</b> name and version of .NET Core runtime are specified (it also indicates whether the patch version ( <a href="http://semver.org/">SemVer</a> ) will be taken into account when searching for the framework), and the Core CLR operation parameters (garbage collector operation mode) are set.  This file is required for Portable and optional for Standalone applications. <br><br>  dotnet.exe ([AppName] .exe) uses the <b>[AppName] .deps.json file</b> to determine the absolute paths of all dependencies of the application when it is started. <br><br>  Structure <b>[AppName] .deps.json</b> : <br><br><ul><li>  Targets section <br><br>  The term <i>target</i> refers to the target platform (name and version) on which this application should run (for example, .NET Framework 4.6.2, .NET Core App 1.1, Xamarin.Mac 1.0, .NET Standard 1.6).  This configuration is similar to the <a href="https://docs.microsoft.com/en-us/nuget/schema/target-frameworks">NuGet target framework</a> . <br><br>  The <i>targets</i> section defines a platform and a dependency tree for it in the format <br><blockquote>  [Dependency ID (package)] / [version]: { <br>  dependencies: {list of dependencies (packages) of this package}, <br>  relative paths to the managed and native files of this package <br>  } </blockquote><br>  To run any application, the target must contain the RID, for example <i>.NETCoreApp, Version = v1.1 / win10-x64</i> .  The standalone application's deps.json file is always one and contains the target platform RID.  For a portable application, there are two deps.json files - one in the framework folder, the second in the application folder.  The RID for Portable Applications is listed in the [FrameworkName] .deps.json file in the framework folder.  After dotnet.exe has defined a framework for executing an application, it first loads the deps file for this framework (for example, <i>C: \ Program Files \ dotnet \ shared \ Microsoft.NETCore.App \ 2.0.0 \ Microsoft.NETCore.App. deps</i> ), and then the deps file of the application.  Deps-file application has a higher priority. <br><br>  Let's take a closer look at the contents of the Standalone application's deps.json file: <br><br><div class="spoiler">  <b class="spoiler_title">SampleApp.deps.json</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"targets"</span></span>: { <span class="hljs-string"><span class="hljs-string">".NETCoreApp,Version=v1.1/win7-x64"</span></span>: { ... <span class="hljs-string"><span class="hljs-string">"libuv/1.9.1"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"Microsoft.NETCore.Platforms"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.1.0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"native"</span></span>: { <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/libuv.dll"</span></span>: {} } }, ... <span class="hljs-string"><span class="hljs-string">"system.data.sqlclient/4.3.0"</span></span>: { <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"System.Data.Common"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.3.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.IO.Pipes"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.3.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.Text.Encoding.CodePages"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.3.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"runtime.native.System.Data.SqlClient.sni"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.3.0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"runtimeTargets"</span></span>: { <span class="hljs-string"><span class="hljs-string">"runtimes/unix/lib/netstandard1.3/System.Data.SqlClient.dll"</span></span>: { <span class="hljs-string"><span class="hljs-string">"rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"unix"</span></span>, <span class="hljs-string"><span class="hljs-string">"assetType"</span></span>: <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> }, <span class="hljs-string"><span class="hljs-string">"runtimes/win/lib/netstandard1.3/System.Data.SqlClient.dll"</span></span>: { <span class="hljs-string"><span class="hljs-string">"rid"</span></span>: <span class="hljs-string"><span class="hljs-string">"win"</span></span>, <span class="hljs-string"><span class="hljs-string">"assetType"</span></span>: <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> } } }, ... <span class="hljs-string"><span class="hljs-string">"runtime.win7-x64.microsoft.netcore.runtime.coreclr/1.1.1"</span></span>: { <span class="hljs-string"><span class="hljs-string">"runtime"</span></span>: { <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/lib/netstandard1.0/SOS.NETCore.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/lib/netstandard1.0/System.Private.CoreLib.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/lib/netstandard1.0/mscorlib.dll"</span></span>: {} }, <span class="hljs-string"><span class="hljs-string">"native"</span></span>: { <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/System.Private.CoreLib.ni.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/clretwrc.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/coreclr.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/dbgshim.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/mscordaccore.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/mscordbi.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/mscorlib.ni.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/mscorrc.debug.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/mscorrc.dll"</span></span>: {}, <span class="hljs-string"><span class="hljs-string">"runtimes/win7-x64/native/sos.dll"</span></span>: {} } }</code> </pre><br></div></div><br>  The <b>dependencies</b> property lists dependencies (packages) for a particular package. <br>  The <b>runtimeTargets</b> property <b>is</b> used in the deps file of the Portable application and determines the library file paths for a particular RID.  <b>Such RID-specific libraries are shipped with the Portable application in the <u>runtimes</u> folder</b> . <br><br>  The <b>runtime</b> and <b>native</b> properties contain relative paths of managed and native libraries, respectively.  The <b>resources</b> property contains relative paths and localities of localized resource assemblies. <br><br>  <b>Paths are relative to the NuGet package cache, not the deps file.</b> <br><br>  You can add a third-party deps file by passing the value of the argument <b>--additional-deps</b> or the environment variable <b>DOTNET_ADDITIONAL_DEPS</b> . <br><br>  <b>This feature is available only for Portable applications.</b> <br><br>  The value of the argument can contain the full path to the deps-file, as well as the path to the directory where the common deps-files are located.  Inside this directory, deps files must be located in the \ shared \ [FX name] \ [FX version] \ *. Deps structure.  For example, <i>shared \ Microsoft.NETCore.App \ 2.0.3 \ MyAdditional.deps.json</i> . <br><br><blockquote>  This approach uses Visual Studio to implicitly add to the Application Insights project through a file. <br>  C: \ Program Files \ dotnet \ additionalDeps \ Microsoft.AspNetCore.ApplicationInsights.HostingStartup \ <br>  shared \ Microsoft.NETCore.App \ 2.0.3 \ Microsoft.AspNetCore.ApplicationInsights.HostingStartup.deps.json <br></blockquote><br>  When dotnet.exe (MyApp.exe) defines application dependency paths, a list of runtime and native paths is compiled for each individual library. <br><br>  If there is a library in runtimeTargets for a specific RID, it is added to the runtime or native list based on the specified <i>assetType</i> . <br></li><li>  <b><a href="">RuntimeTarget</a></b> section <br>  contains the name and version of the target platform to execute.  The targets section actually contains two elements - for compiling (without RID) and execution (always with RID).  The runtimeTarget section is used for convenience and duplicates the value from the targets section so that dotnet.exe does not waste time processing the targets section.  As already mentioned, for the Standalone application, the RID target OS is contained in the deps file of the application, and for Portable, in the deps file of the framework. <br></li><li>  <b><a href="">Libraries</a></b> section <br>  defines a list of all application dependencies (in package ID / version format: {metadata}) and contains metadata about each of them.  Metadata indicates: <br><ul><li>  dependency type (project, package, reference), </li><li>  serviceable (for the package type only) ‚Äîan indicator of whether the package is <a href="https://blogs.msdn.microsoft.com/dotnet/2014/01/22/net-4-5-1-supports-microsoft-security-updates-for-net-nuget-libraries/">Serviceable</a> (determines if the package <a href="https://blogs.msdn.microsoft.com/dotnet/2014/01/22/net-4-5-1-supports-microsoft-security-updates-for-net-nuget-libraries/">build</a> can be patched (replaced) by external services, Windows Update or <a href="">.NET Core Servicing Index</a> ). </li><li>  package hash (for package dependencies) </li><li>  other data </li></ul></li></ul><br><h2>  6. The process of launching a portable .NET Core application </h2><br>  The target computer must have a .NET Core Runtime installed that matches the configuration of the application being launched. <br><br>  <b>6.1.</b>  <b>Application launch</b> <br>  is performed using the multiplexer (muxer) from the command line (the same on any OS). <br><br> <code>&gt; dotnet path\to\MyApp.dll</code> <br> <br>  dotnet.exe - renamed <a href="">corehost.exe</a> , this program is the host process of any .NET Core-application, it starts the startup process. <br><br>  <b>6.2.</b>  <b>[corehost] Search and download Framework Resolver (hostfxr.dll)</b> <br>  At this point, dotnet.exe goes to the [own directory] <b>/ host / fxr / folder</b> .  For portable applications, this library is located in the shared folder <i>C: \ Program Files \ dotnet \ host \ fxr \ [FXR version] \ hostfxr.dll</i> .  If there are several versions, dotnet.exe will always use the latest one. <br><br>  After downloading <b>hostfxr.dll</b> (Framework Resolver), the startup process <a href="">goes</a> into the scope of this library. <br><br>  <b>6.3.</b>  <b>[hostfxr] Determining the execution mode (standalone, muxer, split / FX)</b> <br>  The first task of hostfxr is to <a href="">determine the mode</a> in which the host process will work and thus the type of application - Portable (FDD) or Standalone (SCD).  In Portable (FDD) mode, it also determines whether it is a running application or an SDK command. <br><br><blockquote>  The type of execution (program or SDK command) <a href="">is</a> determined <a href="">as follows</a> : <br><br>  - if among the arguments there is one whose value ends in .dll or .exe - the launch process will continue in the mode of execution of the specified file.  If there is no such argument, the SDK will pass control.  To do this, the dotnet.dll (as Portable application) will be launched from the [own directory] \ sdk \ [version] folder (if it exists), and the arguments of the current host process will be passed to this assembly. </blockquote><br>  Also for a Portable (FDD) application, the hostfxr determines the framework (.NET Core Runtime) from which the components will be loaded for execution. <br><br>  <a href="">The verification algorithm is</a> very simple - if coreclr.dll or [AppName] .dll is <b>missing</b> from the folder from which the [AppName] .exe multiplexer (in our case dotnet.exe) was launched, then the Portable application.  If one of these two files exists, then there is a check - the Portable (split / FX) or Standalone application.  If there is [AppName] .dll, then the application Standalone, otherwise - Portable (split / FX). <br><br><blockquote>  Split / FX mode is used to run xunit and means that the application is launched as Portable, with its own hostfxr.dll.  This mode is not used in .NET Core 2.0. </blockquote><br>  The launch of a portable application can also be carried out in the so-called <b>Exec mode</b> . <br>  To do this, the start command must contain exec <i>C: \&gt; dotnet exec ... as the</i> first argument. <br><br>  When running in this mode, you can explicitly specify the paths to the configuration files: <br>  <b>--depsfile &lt;PAH&gt;</b> <b><br></b>  <b>--runtimeconfig &lt;TH&gt;</b> <br>  which will be used instead of the files in the application folder. <br><br>  <b>6.4.</b>  <b>[hostfxr] .NET Core Runtime Definition</b> <br>  First of all, hostfxr detects and loads the deps and runtimeconfig configuration files.  If nothing is overridden in the arguments, these files are taken from the application folder. <br><br>  At the current stage, hostfxr determines ( <a href="">according to the configuration file</a> ) whether the application is Portable or Standalone. <br><br>  After loading the configuration files and determining the mode, hostfxr <a href="">determines the framework folder</a> (.NET Core Runtime). <br><br>  To do this, hostfxr will first determine which versions are installed in the shared folder, and then select a release version from this list, <a href="">taking into account the values ‚Äã‚Äãin [AppName] .runtimeconfig.json</a> . <br><br>  When choosing a version, the <a href="">Roll Forward On No Candidate Fx</a> parameter is taken into account, which indicates the severity of compliance with the specified version and those available on the machine. <br><br>  <b>6.5.</b>  <b>[hostfxr] Search and download hostpolicy.dll</b> <br>  At the current stage, everything is ready to determine the paths of runtime components.  This task is handled by the <b>hostpolicy.dll</b> library, which is called the Host library. <br><br>  <a href="">The process of searching for</a> hostpolicy.dll is in sequential checks of various locations.  But first, the hostpolicy version is determined from the framework's deps file (eg <i>C: \ Program Files \ dotnet \ shared \ Microsoft.NETCore.App \ 2.0.0 \ Microsoft.NETCore.App.deps</i> ).  A package named <b>Microsoft</b> .NETCore.DotNetHostPolicy will be found in this file and its version will be taken. <br><br>  Then, a patch (replacement) of hostpolicy.dll (taking into account the version, if it was defined in the previous step, and RID) is searched in the .NET Core Servicing folder (for <a href="">Windows</a> , in the C: \ Program Files [(x86)] \ <b>coreservicing \ folder pkgs</b> ).  If such a file is found, it is downloaded for future use. <br><br>  If the file was not found in the previous step, the hostpolicy.dll will be found in the framework folder. <br><br>  Once hostpolicy.dll is defined, hostfxr loads this library and <a href="">transfers control to it</a> . <br><br>  <b>6.6.</b>  <b>[hostpolicy] Defining a dependency list</b> <br>  The <a href="">hostpolicy.dll</a> library <a href="">is</a> responsible for determining the absolute paths of all dependencies of the application. <br><br>  First of all, hostpolicy <a href="">will create a</a> component called Dependencies Resolver, which in turn will <a href="">load two deps files</a> - the framework file and the application file. <br><br>  First, the list is loaded from the deps file of the framework, where dependencies such as CoreCLR and CoreFX libraries will be defined.  Then a list from the deps-file of the application, which shows the assembly of our application and their dependencies. <br><br>  For each deps file, Dependency Resolver <a href="">lists</a> all dependencies for the specified <b>runtimeTarget</b> . <br><br>  For each package, a list of files from all runtimeTargets (RID specific dependencies) sections is first compiled, then a list of all files from the native and runtime sections.  Such a combined list of relative paths of all dependencies in a conditional format. <br>  <i>Package ID - RID - type of asset (runtime, native) - file paths are</i> called Target assets. <br><br>  After these two lists of dependency files (RID and non-RID) have been compiled, a process called <b><a href="">Reconciling libraries with targets</a></b> is performed.  It lies in the fact that for each package from the libraries section it is checked whether there are RID specific files that should be overridden by regular ones. <br><br>  <b>6.7.</b>  <b>[hostpolicy] TPA, Core CLR and CLR Jit Path Definition</b> <br>  Next, the Dependency resolver lists the absolute paths of the files of the managed assemblies ‚Äî application dependencies.  This list is called TPA (Trusted Platform Assemblies) and is passed to the Core CLR to configure the AppDomain.  It also compiles a list of absolute paths of directories in which the rest of the dependency files are located (except coreclr, corejit). <br><br>  The determination of the absolute paths of the managed assemblies is done by searching the files in the Probe paths.  By default, there are two of them - the framework folder and the application folder, and they are based on the location of the deps-files.  You can also add additional paths: <br><br>  1) passing the argument <b>--additionalprobingpath</b> , for example <br> <code>--additionalprobingpath %UserProfile%\\.nuget\\packages</code> <br> <br>  2) specifying in the file [AppName] .runtimeconfig.json (priority is lower than the argument), for example <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"runtimeOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"additionalProbingPaths"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"C:\\Users\\username\\.nuget\\packages"</span></span> ] } }</code> </pre> <br>  In the framework and application folder, the presence of the file is checked (provided that it was specified in the corresponding deps file) without regard to the relative path, in other directories with respect to the path, because these directories are considered as a cache of the NuGet package. <br><br>  Search sequence: <br><br><ul><li>  application folder; </li><li>  framework folder </li><li>  Probe paths </li></ul><br>  If the deps file of the application is missing, then all the files with the extension .ni.dll, .dll, .ni.exe, .exe from the application folder are included in the TPA. <br><br>  After compiling the TPA list, the CoreCLR and CLRJit paths are determined. <br><br>  If there is no application deps file, dotnet.exe will first try to find these libraries in [app directory] \ lib \.  During normal execution, the paths are taken from the framework folder (discarding the relative path and taking only the file name). <br><br>  The following CoreCLR settings are set: <br><br><ul><li>  TRUSTED_PLATFORM_ASSEMBLIES - a list of absolute paths of all managed application libraries. </li><li>  NATIVE_DLL_SEARCH_DIRECTORIES - absolute paths of directories where native dependencies are found. </li><li>  PLATFORM_RESOURCE_ROOTS - absolute paths of directories where resource dependencies are found </li><li>  AppDomainCompatSwitch is a constant "UseLatestBehaviorWhenTFMNotSpecified". </li><li>  APP_CONTEXT_BASE_DIRECTORY - application folder. </li><li>  APP_CONTEXT_DEPS_FILES - absolute paths of the deps-files of the application and the framework. </li><li>  FX_DEPS_FILE - the absolute path of the framework's deps file. </li><li>  PROBING_DIRECTORIES - additional probing paths (if they were specified). </li></ul><br>  Then control passes to coreclr.dll. <br><br><h2>  7. The process of starting Standalone (SCD) .NET Core applications </h2><br>  The process of launching a Standalone application differs from Portable only in the initial stage, as well as in the location of the components, which by default should be located in the application folder. <br><br>  <b>7.1.</b>  <b>Application launch</b> <br>  performed by running your own multiplexer MyApp.exe.  In .NET Core &lt;2.0, this multiplexer is the renamed common dotnet.exe multiplexer.  Starting with .NET Core 2.0, a separate multiplexer apphost.exe is used (slightly modified version of dotnet.exe). <br><br>  This file (apphost.exe) is supplied via NuGet in the Microsoft .NETCore.DotNetAppHost package. <br>  Inside the file is a text placeholder (its value is the SHA-256 hash of the foobar string). <br>  When executing the <i>dotnet build command, the</i> value of the placeholder is changed to the name of the assembly being launched (for example, MyApp.dll), and apphost.exe is renamed to MyApp.exe.  Thus, the executable file is bound to the assembly.  When you run a .NET Core&gt; = 2.0 application, this ‚Äúbinding‚Äù is first checked. <br><br>  <b>7.2.</b>  <b>Startup process</b> <br>  it is the same as with a Portable application, except that there is only one deps file and all dependencies are searched in the application folder or by the specified - additionalprobepaths. <br><br><h2>  8. To summarize </h2><br><ul><li>  The component model .NET Core (Runtime, BCL) consists entirely of NuGet packages. </li><li>  There are two types of deployment - FDD and SCD.  Whenever possible, it is recommended to use Framework Dependent-Deployment to avoid difficulties with platform-dependent components and not to deliver unnecessary dependencies. </li><li>  As we could see, there are many opportunities to influence the launch process on the target machine, and if necessary, override / patch the dependency files, as well as add implicit (dynamically started) dependencies. </li><li>          Dependency manifest (*.deps.json) . </li><li>  --additional-deps  --additionalprobepaths    runtime-     . </li><li>  Exec mode     . </li><li>  Trace-   ,    <b>COREHOST_TRACE=1</b> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/327686/">https://habr.com/ru/post/327686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327676/index.html">We raise our VPN server on Amazon EC2 under Windows Server 2008 r2</a></li>
<li><a href="../327678/index.html">Linus Torvalds introduced the Linux kernel 4.11</a></li>
<li><a href="../327680/index.html">Crowd Marketing: Top 10 Popular Questions</a></li>
<li><a href="../327682/index.html">Encryption in EXT4. How it works?</a></li>
<li><a href="../327684/index.html">How to raise your i2p-site (eepsite) on VDS (VPS) under Ubuntu (LAMP). Briefing for beginners</a></li>
<li><a href="../327688/index.html">Structural Classification: Examples and Misconceptions</a></li>
<li><a href="../327690/index.html">Carousel on Vanilla.JS. Part 2</a></li>
<li><a href="../327692/index.html">Java, first cup</a></li>
<li><a href="../327694/index.html">Search in the Django REST Framework using Elasticsearch</a></li>
<li><a href="../327698/index.html">How to share the environment for building and running a service in Docker today and how to do it tomorrow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>