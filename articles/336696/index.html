<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 2. Core MAX RTOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to lay out the chapters of the Knowledge Book of the MAKS RTOS. The first part was common. Today is the second part, dedicated to the core ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 2. Core MAX RTOS</h1><div class="post__text post__text-html js-mediator-article">  I continue to lay out the chapters of the Knowledge Book of the MAKS RTOS.  <a href="https://habrahabr.ru/post/336308/">The first part</a> was common.  Today is the second part, dedicated to the core and priority of tasks. <br><br>  Content (published and unpublished articles): <br><br>  <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  Part 2. Kernel of the MAKS RTOS (this article) <br>  <a href="https://habrahabr.ru/post/336944/">Part 3. The structure of the simplest program</a> <br>  <a href="https://habrahabr.ru/post/337476/">Part 4. Useful theory</a> <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  <a href="https://habrahabr.ru/post/338682/">Part 6. Thread synchronization tools</a> <br>  <a href="https://habrahabr.ru/post/339498/">Part 7. Means of data exchange between tasks</a> <br>  <a href="https://habrahabr.ru/post/340032/">Part 8. Work with interruptions</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Task </h2><br>  As <a href="https://habrahabr.ru/post/336308/">already mentioned</a> , the task in the MAKS RTOS is analogous to a stream in a general purpose OS.  At the same time, an arbitrary number of tasks can be executed in the system (within the available resources, of course).  In a general-purpose OS, it would be possible to stop theorizing and move on to practice, but in the case of a real-time OS, the programmer must be sure that he did everything right and the tasks are guaranteed to receive as much processor time as they need.  And to do everything right, you need to know some theory.  Therefore, we consider the work tasks in more detail. <a name="habracut"></a><br><br><h2>  Types of multitasking </h2><br>  In the MAKS RTOS (as in most other real-time operating systems) three different types of multitasking are possible: displacing, cooperative, mixed.  Why so much?  The fact is that in different systems it is more convenient to use different types.  Therefore, the choice of the most convenient type remains for the developer of a specific application program. <br><br><h3>  Preemptive multitasking </h3><br>  This type is the most familiar for many programs, moreover, displacing multitasking is similar to that used in general-purpose OS.  The scheduler gives each task a fixed time quantum (set using the MAKS_TICK_RATE_HZ constant, which is 1000 Hz by default, that is, the quantum is equal to one millisecond by default), and then displaces this task, putting the next one to execution.  The principle of sorting the tasks will be discussed below, but here we just note that tasks are executed in turn, according to the system timer.  In general, this scheme looks pretty nice (no wonder it is used in general-purpose operating systems) until the battles for equipment begin. <br><br><h3>  Problems of preemptive multitasking when working with equipment </h3><br>  One of the main tasks of microcontrollers is working with equipment.  And this feature imposes a number of responsibilities on the programmer.  It may happen that the same SPI bus serves several devices separated by different CS lines.  Until you have finished working with one device, you cannot begin to work with another. <br><br><img src="https://habrastorage.org/web/d24/763/ce0/d24763ce062745e5bd13ac306758d957.png" alt="An example of using SPI bus with multiple devices"><br><br>  <b>Fig.</b>  <b>1. An example of using a single SPI bus with multiple devices</b> <br><br>  The I2C bus is originally designed for connecting many devices. <br><br>  Sometimes it is required to maintain any time diagrams with a sufficiently high accuracy.  If the time quantum leaves, the diagram will be distorted. <br><br>  But with preemptive multitasking, the planner is merciless.  No one knows when the timer to switch tasks will work, so in the cases described above, it is necessary to use synchronization mechanisms.  With a certain scheme, it is enough to implement several synchronization primitives.  But it may turn out that the programmer will be forced to think not so much about the program as about synchronization.  And in this case it is better to abandon the preemptive multitasking in favor of the cooperative. <br><br><h3>  Cooperative multitasking </h3><br>  With cooperative multitasking, switching is performed not by timer, but by command from the task itself.  When she did everything she was supposed to do in a given time slice, she calls the task switching function Yield () herself.  Calling this function serves as a signal to the scheduler that it is time to transfer control to the next task.  As a result, the task has a guarantee that its execution will not be interrupted until she herself requests the system about it.  But needless to say, the other side of the coin is a big burden of responsibility on the programmer.  It is the application programmer who must ensure that the task does not take the processor too long.  It is also customary to write that the hang of the task will hang the entire system, but in my opinion, this is even better.  The hardware must either work or not.  If one of the subsystems fails - the equipment becomes unsafe, the consequences can be terrible.  So it‚Äôs better that the device fails completely, it will serve as a signal to search for an error.  However, in the case of preemptive multitasking, the hang of one task will not interrupt the work as a whole, and in the case of cooperative - the task simply will not give control to the other. <br><br>  Also cooperative multitasking can be used to quickly port applications from single-tasking systems.  Consider a fragment of the Marlin ‚Äúfirmware‚Äù for a 3D printer (in fact, a CNC machine): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buflen &lt; (BUFSIZE<span class="hljs-number"><span class="hljs-number">-1</span></span>)) get_command(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SDSUPPORT card.checkautostart(false); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(buflen) { ... process_commands(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SDSUPPORT buflen = (buflen-1); bufindr = (bufindr + 1)%BUFSIZE; } //check heater every n milliseconds manage_heater(); manage_inactivity(); checkHitEndstops(); lcd_update(); }</span></span></span></span></code> </pre> <br>  The loop () function is called by the Arduino runtime in an infinite loop.  Such a cycle is an analogue of the scheduler that switches tasks.  If you redo everything on a real scheduler, then you can easily throw out the loop () function, and form its components in the form of tasks that spin in an infinite loop, calling Yield () before the next iteration.  This will ensure that the tasks do not conflict with each other over the equipment and create each other timeouts.  And in the future, as the system adapts, you can try to switch to preemptive multitasking. <br><br><h3>  Mixed multitasking </h3><br>  The last possible option, when the system works in the preemptive multitasking mode, but some (or some) of the tasks call the Yield () function.  In particular, if the task got control, but found out that the data for it is not yet ready.  Then, in order not to occupy resources, it can call the function Yield () to give control to another task.  However, in the current version of the MAX RTOS, this is permissible, but should be used with caution.  I would rather highlight the cause in red to enhance the impact. <br><br>  <font color="#cc0000">Please note that mixed multitasking in the current MAXROS RTX should be used with caution.</font>  <font color="#cc0000">The point is that the preemptive task switching takes place on a timer, which operates at a fixed frequency.</font>  <font color="#cc0000">Forced task switching does not affect this timer.</font>  <font color="#cc0000">Suppose task A is always executed for 700 ¬µs, after which it transfers control to the scheduler using the Yield () function.</font>  <font color="#cc0000">The scheduler assigns task B. But after 300 ms an interrupt from the timer arrives, and the scheduler transfers control to the next task B. Since the transfer of control occurs sequentially, task B will be forever impaired.</font>  <font color="#cc0000">She will always be given a defective time quantum, and the remainder of the quantum of task A.</font> <br><br><h2>  Task status </h2><br>  Now that we are familiar with the types of multitasking, we can consider the problem and the logic of transferring control of it closer.  The graph of task states and transitions between them is shown in Fig.  2 <br><br><img src="https://habrastorage.org/web/b69/040/568/b69040568f6b46cfae8a9bd5340fb9b9.png" alt="Fig.  2. Task states and transition graph between them"><br><br>  <b>Fig.</b>  <b>2. Task states and transition graph between them</b> <br><br><table><tbody><tr><td width="100">  running </td><td>  The most pleasant condition.  The task is executed.  Every moment in time, in this state there can be only one task. </td></tr><tr><td>  ready </td><td>  When a task has a time slice, or it has independently called the function Yield (), it enters this state and will stay in it until the scheduler again puts it to execution. </td></tr><tr><td>  blocked </td><td>  The task will go to this state if it has requested any busy resource.  These can be synchronization primitives (mutex or semaphore), it can be waiting for an event, it can be waiting for a message from a queue.  Until the resource is released, the task will be in a locked state, without spending processor cycles.  This is an extremely important state for the task, because the fewer tasks are executed, the more processor time is left for the others.  It is highly recommended not to organize waiting for something in the loop, but to block tasks so that the scheduler knows that they should not be called. <br><br>  When the resource is released, depending on the situation, the task can either immediately go to execution, or go into a state of readiness for planning.  The latter will happen if the resource is released, which several tasks were waiting for at once (after all, only one can be executed), or if tasks with a higher priority are currently being executed. </td></tr><tr><td>  inactive </td><td>  The state in which the task passes at the time of creation, or at the end of its work.  That is, if the task is not yet connected to the scheduler, or, on the contrary, it is already disconnected from the scheduler.  An auxiliary state that has no relation to the work of the task. </td></tr></tbody></table><br><h2>  Task priority </h2><br>  Each task is assigned its own priority. <br><br>  Priority is an integral and extremely important property of the task.  In general, it would be possible to assign priorities to just numeric values.  But, firstly, it is accepted to call priorities in general-purpose OS (another thing is that there it makes sense, but here, in principle, it would be possible to manage), and secondly, the object-oriented approach is closely connected with typification.  Some abstract numbers are easily confused, and when naming you can associate names with a specific type of "priority." <br><br>  So, both for the purposes of observing traditions and for ensuring strict typing, the following priorities of tasks are identified in the MAKS RTOS: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Priority { PriorityIdle, <span class="hljs-comment"><span class="hljs-comment">///&lt;   (   IDLE) PriorityLow, ///&lt;   PriorityBelowNormal, ///&lt;    PriorityNormal, ///&lt;   (  ) PriorityAboveNormal, ///&lt;    PriorityHigh, ///&lt;   PriorityRealtime, ///&lt;   ( ) PriorityMax = MAKS_MAX_TASK_PRIORITY };</span></span></code> </pre><br><h2>  Task switching order </h2><br>  When describing a general-purpose operating system, usually this section has a huge size, while the authors add that they describe the mechanism briefly, since the mechanism changes from version to version.  This is due to the fact that the general purpose OS should try to ensure the operation of all threads of all processes.  In the case of real-time OS, everything is simple.  The tasks are switched using the Round Robin algorithm, the diagram is shown in Fig.  3. The essence of this algorithm is that the list task is executed in order, and when the end is reached, the OS switches to the top of the list.  Inside the list, when selecting a task for execution, the task next in the list is taken.  If it has a ready state, it is put to execution.  If bloked - proceed to the next task. <br><br><img src="https://habrastorage.org/web/cac/412/898/cac4128981c047fe9213afd5d734eba9.png" alt="Fig.  3. Switching tasks according to the Round Robin algorithm"><br><br>  <b>Fig.</b>  <b>3. Switching tasks according to the Round Robin algorithm</b> <br><br>  It should be noted that tasks with the highest priority are executed, that is, there can be several lists in a real system.  For example, a task list with priority PriorityNormal and a list with priority PriorityHigh.  At the same time, if all the tasks are not in the waiting state, the scheduler will always put on execution only tasks from the list with a higher priority. <br><br><img src="https://habrastorage.org/web/71d/843/aa5/71d843aa568349b1bdfa2d83f5f116dc.png" alt="Fig.  4. An example of performing tasks 1-6"><br><br>  <b>Fig.</b>  <b>4. Example of execution of tasks 1-6 (with a higher priority) and complete idleness of tasks 7-12 (their priority is low for work)</b> <br><br>  However, this does not mean that some tasks are ignored: with a properly designed program, time will be transferred to all tasks.  Simply, tasks with higher priorities should be designed to be in the blocked state as often as possible - waiting for any resources (semaphores, data from the queue, etc.). <br><br><img src="https://habrastorage.org/web/84b/01b/811/84b01b81177a4145b2e581c9baa8bde4.png" alt="is 5. An example of performing tasks 7-12"><br><br>  <b>Fig.</b>  <b>5. Example of performing tasks 7-12 (with low priority), since all high-priority tasks are blocked</b> <br><br>  Tasks with normal priority are ‚Äúworkhorses.‚Äù  They constantly perform repetitive actions: they monitor slow equipment, provide input of control actions, display of results, etc. <br><br>  Tasks with a priority below normal can be entered into the program, if there is a guaranteed chance that even tasks with normal priority once all can go into the blocked state (that is, a simple call to the Yield function does not help, you must either wait for resources or call the function Delay (admittedly, make all tasks fall asleep with the current priority)). <br><br>  Practical examples of the application of tasks with high priority will be given below.  They are designed to handle "fast" equipment.  In the meantime, enough to remember a few basic rules: <br><br><ul><li>  Unlocked tasks with the highest priority are set for execution. </li><li>  Tasks are selected in a circle, one after the other (Round Robin algorithm). </li><li>  The programmer should take care that high-priority tasks are basically in a locked state.  Otherwise, tasks with lower priorities will never be executed. </li></ul><br><h2>  Energy saving features </h2><br>  When all tasks are in a locked state, the processor must do something, or it should be put to sleep.  The system has a special preprocessor constant that allows you to choose one of the behaviors. <br><br>  <b>MAKS_SLEEP_ON_IDLE</b> <br><br>  If this constant is defined with a value of 1, then the scheduler, not finding any active tasks at any of the priority levels, will lull the processor, which will lead to a decrease in power consumption.  Awakening will occur when any interrupt request (including system timer) arrives.  If the determination value is zero, in such cases the idle task will be executed, forcibly launched by the operating system itself and having the lowest possible priority: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MAKS_DEBUG ++ IdleTaskCnt; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><h2>  Normal and privileged task operation modes </h2><br>  The current equipment on which the MAX RTOS can operate does not support memory virtualization, but supports some elements of its protection.  Thanks to this, you can catch some errors in the program.  Classical is the protection of a section of memory in the region of zero address in order to record attempts to access by null pointers (for example, the memory manager did not allocate memory, returned a null pointer, and the program, without checking, began to use it). <br><br>  In addition, you can prevent a user program from changing interrupt priorities by blocking access to NVIC hardware. <br><br>  Usually in the literature they write that memory protection allows you to keep the system working when an application fails, but I do not agree that the equipment should be maintained.  On the contrary, when fixing such failures, it is necessary to transfer the equipment to the off state as soon as possible and signal the problem.  Just all the tips on maintaining performance relate to general-purpose OS.  Solitaire flew out - they launched a miner, there won't be much difference.  In the case of equipment, one application is running in the system.  Launching another is impossible.  And the failure of any of the subsystems can lead to the fact that the mechanical or electrical part of the system will go astray.  That is why you should transfer everything to a safe state as soon as possible and inform the developers about the problem. <br><br>  But, as they say in a well-known joke, some say that they should drink less, others - that they should drink more, but everyone agrees on one thing: it is necessary to drink.  Also here: for whatever purpose it is done (to ensure survivability at any cost, or to ensure a safe shutdown), and protecting the memory is an extremely useful thing. <br><br>  Accordingly, to ensure this protection, the application can be transferred to normal operation.  The OS will also work in a privileged mode. <br>  However, given that applications running under the MAKS RTOS can be quite simple, their operation in privileged mode is also allowed.  In this case, the application programmer has access to the same as the system programmer, but the hardware does not track any wrong actions. <br><br>  First, you can start individual tasks with privileged access by specifying it in the arguments of the Task :: Add () function of the task.  In addition, you can set the conditional compilation option MAKS_PROFILING_ENABLED to 1, after which all tasks will run in privileged mode. <br><br>  In the <a href="https://habrahabr.ru/post/336944/">next article</a> I will introduce the structure of the simplest program running under the MAKS RTOS. </div><p>Source: <a href="https://habr.com/ru/post/336696/">https://habr.com/ru/post/336696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336686/index.html">Boot from GPT disk from BIOS</a></li>
<li><a href="../336688/index.html">Ad render v.2.0. Book One. Overview</a></li>
<li><a href="../336690/index.html">RailsClub 2017: Interview with Nick Sutterer. Rails dies (Ruby doesn't)</a></li>
<li><a href="../336692/index.html">Animation in WPF and Blend SDK</a></li>
<li><a href="../336694/index.html">The practice of forming requirements in IT projects from A to Z. Part 1. Introduction</a></li>
<li><a href="../336698/index.html">What are the favicons</a></li>
<li><a href="../336702/index.html">Kickico - a crowdfunding revolution, or ICO for ICO (comparison with other platforms)</a></li>
<li><a href="../336704/index.html">Development of a mobile application for RosEvroBank: case</a></li>
<li><a href="../336706/index.html">How we created a new product, removing 130 thousand lines of code from the old</a></li>
<li><a href="../336708/index.html">How do i use git</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>