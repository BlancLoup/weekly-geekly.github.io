<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go to the global pile without traffic jams. Explore memory managers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Somehow, analyzing a defect in a developed product, I came across an architectural feature of the memory manager that we used. The defect led to an in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go to the global pile without traffic jams. Explore memory managers</h1><div class="post__text post__text-html js-mediator-article">  Somehow, analyzing a defect in a developed product, I came across an architectural feature of the memory manager that we used.  The defect led to an increase in the creation time of some objects.  The peculiarity of the architecture was to use the Singleton pattern when working with the memory manager (hereinafter referred to as X allocator).  Schematically it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5a/1a7/667/b5a1a766718daf36bfac230c6b320e77.png" alt="image"><br>  Figure 1 - Block diagram of the X allocator <br><br>  From the diagram it is clear that access to the global heap is protected by a mutex.  Such an architecture, with the intensive creation of objects of the same type from several threads, can lead to threads being queued on this mutex.  But one of the main features of the product is the ability to scale it by increasing the number of processing threads (threads performing the same actions).  Therefore, this approach could potentially become a bottleneck. <br><a name="habracut"></a><br>  Realizing the scale of the threat, I decided to clarify and climbed into the Internet to look for information about multi-threaded memory managers (multi-threaded pooled allocators).  While searching, I came across several projects: <br>  ‚Ä¢ Hoard (http://www.hoard.org/), distributed under the GPL v.2.0 license; <br>  ‚Ä¢ TBB Memory Allocator from Intel (discarded, because the library is paid); <br>  ‚Ä¢ Thread-Caching Malloc from Google gperftools (https://code.google.com/p/gperftools/). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Also in the search process I found a very interesting article that describes various approaches when working with dynamic memory - <a href="http://www.realcoding.net/article/view/2747">www.realcoding.net/article/view/2747</a> . <br><br>  Having several solutions in my hands, I decided to experiment: to compare the performance of various memory managers and look for a solution to optimize the X allocator. <br><br>  When I analyzed the implementation of Hoard and TCMalloc, I had an understanding that the memory managers implemented in them use caching by threads (an alternative to this approach is to use lock-free lists).  Caching allows, when deleting an object, to return the memory not to the global heap, but to put in the cache of this stream.  So, when re-creating the same object, the thread will not have to go under the mutex into the common heap.  Schematically, this approach can be depicted as follows (Figure 2): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/051/821/66d0518217e990f857c2d540b0e42609.png" alt="image"><br>  Figure 2 - Block diagram of the X allocator with the use of caching flows <br><br>  Having implemented caching on the knee in the X allocator (hereinafter pooled X allocator), I proceeded to a performance comparison. <br><br>  The study of the behavior of memory managers was carried out with intensive CPU consumption.  The test was to create X objects on N threads, while testing the hypothesis that the test time is inversely proportional to the number of threads.  An example for an ideal world: the creation of 1000 objects on 1 stream will be performed 2 times longer than the creation of 1000 objects on 2 threads (500 objects per stream). <br><br>  The tests performed can be divided into the following categories: <br>  1. OS Type: <br>  a.  Windows; <br>  b.  Linux <br>  2. Size of objects: <br>  a.  128b; <br>  b.  1Kb; <br>  c.  1Mb. <br>  3. Memory Manager: <br>  a.  system memory manager; <br>  b.  TCMalloc (Google); <br>  c.  Hoard; <br>  d.  pooled X allocator (replaced X allocator singleton with an array of X allocators, when allocating and freeing memory, the number of X allocator is calculated by the tid of the flow). <br>  e.  X allocator; <br>  4. Number of threads: from 1 to 8; <br>  5. I conducted each experiment 5 times, after calculating the arithmetic average value. <br><br>  Below I will cite only one graph (Figure 3) and the results of the experiment for it (Table 1), since for all cases the results were similar.  The results are shown for Linux OS objects with a size of 1 Kb. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ad/f0f/43d/4adf0f43da03be178034f961f1e2b78a.png" alt="image"><br>  Figure 3 - Results of a study of the performance of memory managers <br><br>  On the graph, the abscissa axis is the number of streams, the ordinate axis is the relative test run time (100% takes the test run time on one thread using the system memory manager). <br><br>  Table 1 - Results of a study of the performance of memory managers <br><img src="https://habrastorage.org/getpro/habr/post_images/2f7/325/8ca/2f73258ca94740d62a7dc0f4723eb297.png" alt="image"><br><br>  Based on the results obtained, the following conclusions can be drawn: <br>  1. The X allocator, which we use, showed good performance only on 1 thread, with an increase in the number of threads, performance drops (due to competition on the mutex); <br>  2. the rest of the memory managers coped with the task of paralleling, indeed, with an increase in the number of threads, the task began to run faster; <br>  3. TCMalloc showed better performance. <br><br>  Of course, I understood that the experiment was artificial and in real conditions the growth of productivity would not be as significant (some tests showed an increase in productivity 80 times).  When I replaced X allocator with TCMalloc in my project and conducted an experiment on real data, the performance increase was 10%, and this is quite a good increase. <br>  Performance is certainly great, but the X allocator provides the ability to analyze memory consumption and look for leaks.  And what about the rest of the memory managers?  I will try to explain this comparison in detail in the next article. </div><p>Source: <a href="https://habr.com/ru/post/238787/">https://habr.com/ru/post/238787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238775/index.html">Windows 10 Technical Preview is available for download.</a></li>
<li><a href="../238777/index.html">Epson Contest Reminder for Android Developers</a></li>
<li><a href="../238779/index.html">IDE Atom from GitHub. Published roadmap to version 1.0</a></li>
<li><a href="../238783/index.html">What will happen if you mix nuts, Arduino, OpenCV and Delphi. Part 2</a></li>
<li><a href="../238785/index.html">Holy Grail on steroids: total synchronization and isomorphic JavaScript on Swarm.js</a></li>
<li><a href="../238793/index.html">Drupal 8 beta</a></li>
<li><a href="../238795/index.html">We read Habr by mail</a></li>
<li><a href="../238797/index.html">What can we expect from 14 nanometers?</a></li>
<li><a href="../238801/index.html">Media Center with IPTV from laptop and monitor</a></li>
<li><a href="../238803/index.html">The company is planned to introduce SED? 10 recommendations to an IT specialist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>