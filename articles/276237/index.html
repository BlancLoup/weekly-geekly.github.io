<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analytics Instagram and GAE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago on Habr√© an article was published about the search for similar accounts on Twitter. Unfortunately, the author did not react to the comme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analytics Instagram and GAE</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/7f7/5dd/abd/7f75ddabddaa459ca5ac986c82f947fd.png"><br><br>  Some time ago on Habr√© an <a href="http://habrahabr.ru/post/273531/">article</a> was published about the search for similar accounts on Twitter.  Unfortunately, the author did not react to the comments, so I had to reinvent the wheel.  But in order not to do exactly the same thing, it was decided to look for similar accounts on Instagram using Google App Engine, so much so that everyone could use the service.  So came <a href="http://instalytics.ru/">instalytics.ru</a> *. <br><br><a name="habracut"></a><br>  The most difficult thing, of course, was to implement a service for everyone (well, stay within the free quotas of Google App Engine and take into account the limitations of the <a href="https://www.instagram.com/developer/">Instagram API</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything is implemented as follows - <br><ol><li>  User request for analysis of the account is checked in Instagram - if the specified user is found, then the request for its analysis is added to the database.  In addition, each request has its own priority (as long as all requests are the same). </li><li>  Once every 15 minutes, a task is launched using cron, which selects one request from the queue from the database and creates a new task ‚Äî to get all the subscribers of the user from the request.  The task in case of an error is repeated again: <br><pre><code class="xml hljs">- name: followers-get rate: 1/m # 1 task per minute bucket_size: 1 max_concurrent_requests: 1 retry_parameters: task_retry_limit: 2 min_backoff_seconds: 30</code> </pre> <br>  Each task, in case if not all subscribers were received in one request, creates a new task: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'next_cursor'</span></span>): cursor = users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'next_cursor'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'/task/followers-get?user_id='</span></span>+user_id url += <span class="hljs-string"><span class="hljs-string">'&amp;cursor='</span></span> + cursor taskqueue.add(queue_name=<span class="hljs-string"><span class="hljs-string">'followers-get'</span></span>, url=url, method=<span class="hljs-string"><span class="hljs-string">'GET'</span></span>)</code> </pre><br></li><li>  After completing the acquisition of all subscribers, each analysis begins.  To do this, a huge number of tasks are created to get a list of those users to whom each subscriber is subscribed (each task can create new tasks, as is the case with the subscribers above).  In order to be in line with the Instagram limit of 5,000 requests per hour, the task queue is configured as follows: <br><pre> <code class="xml hljs">- name: subscriptions-get rate: 5000/h</code> </pre><br>  At the same time, after each request is completed, just in case, we sleep for 0.72 seconds (= 60 * 60/5000). <br>  Unfortunately, in the free version of Google App Engine, you can only make 50,000 entries per day in the database.  Since  each task can create a new task, then the initial option - write the result of each task to the database - had to be replaced with a new one - the result of the previous task is transferred as a parameter to the new task, and only the last task writes the result to the database: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'next_cursor'</span></span>): cursor = users.get(<span class="hljs-string"><span class="hljs-string">'pagination'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'next_cursor'</span></span>) params = { <span class="hljs-string"><span class="hljs-string">'user_id'</span></span>: user_id, <span class="hljs-string"><span class="hljs-string">'f_user_id'</span></span>: f_user_id, <span class="hljs-string"><span class="hljs-string">'cursor'</span></span>: cursor } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> more_subscriptions: params[<span class="hljs-string"><span class="hljs-string">'subscriptions'</span></span>] = <span class="hljs-string"><span class="hljs-string">','</span></span>.join(more_subscriptions) taskqueue.add(queue_name=<span class="hljs-string"><span class="hljs-string">'subscriptions-get'</span></span>, url=<span class="hljs-string"><span class="hljs-string">'/task/subscriptions-get'</span></span>, params=params, method=<span class="hljs-string"><span class="hljs-string">'POST'</span></span>)</code> </pre><br>  Some users (such as <a href="https://www.instagram.com/instagram/">@instagram</a> , for example) have millions of subscribers.  In order not to waste precious resources on getting all their subscribers, the task is completed after receiving 100'000 subscribers. <br></li><li>  Due to the restriction on the number of write operations to the database, it is not possible to properly monitor whether all tasks for a particular user have completed or not.  The normal solution would be to write a list of running tasks to the database and, at the end of each task (or if the last attempt was made to complete the task), exclude the task from the list.  But a huge number of tasks multiplied by all users does not allow it.  Because the task list is stored in memcache: <br><pre> <code class="python hljs">memcache.set(<span class="hljs-string"><span class="hljs-string">'subscriptions'</span></span>+str(user_id), <span class="hljs-string"><span class="hljs-string">','</span></span>.join(str(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> followers), <span class="hljs-number"><span class="hljs-number">1209600</span></span>)</code> </pre><br>  Data from memcache can be deleted at any time.  To avoid the situation with a ‚Äúhung up‚Äù request (when all the tasks on request were completed, but memcache was deleted and we don‚Äôt know about it, respectively), every few hours a task is started that checks whether there are no requests that have received the status of receiving subscribers than 2 weeks ago (for the time being it is considered that this is the time during which all tasks will be completed).  If such requests are found, then they are "forcefully" transferred to the next stage. <br></li><li>  At the next stage, all previously obtained data from the database is read.  As it turned out, there can be quite a lot of data and there may not be enough allocated GAE memory for them.  Therefore, the data is read in chunks; for each chunk, an intermediate result is calculated, which is then added to the next intermediate result.  In this process, I had to disable the automatic caches: <br><pre> <code class="python hljs">ctx = ndb.get_context() ctx.set_cache_policy(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> key: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) ctx.set_memcache_policy(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> key: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre><br>  As a result of numerous calculations at this stage, 300 of the most popular users are selected, on which your users are subscribed. <br></li><li>  For each of the 300 users, tasks are launched to obtain data on them (names, pictures, number of subscribers, etc.).  By analogy with the process described above, either the completion of all tasks is expected, or a new stage will be forced after some time. <br></li><li>  At the last stage, the calculation and selection of the most similar users is made (taking into account the number of your subscribers and subscribers in total).  It turns out something like <a href="http://instalytics.ru/result/ahFlfmluc3RhLWFuYWx5dGljc3IUCxIHUmVxdWVzdBiAgICAgICACgw">this</a> , the link to the result is sent to the e-mail. <br></li></ol><br>  The above approaches and optimizations so far allow us to remain within the framework of free quotas allocated by GAE, although obtaining a result takes a lot of time.  I need your help - <a href="http://instalytics.ru/">add</a> your users to the queue, let's see how long their analysis will take. <br><br>  In the future I plan to add to the service the recognition of real people / companies on Instagram, but I cannot do without machine learning - so this will be a separate task. <br><br>  <sup>* Russian language on the site does not work yet - <a href="http://stackoverflow.com/questions/34979813/how-to-use-django-translation-with-gae">I can not figure out</a> why django translation does not work on GAE.</sup> </div><p>Source: <a href="https://habr.com/ru/post/276237/">https://habr.com/ru/post/276237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276221/index.html">Typescript 1.8: a lot of new and useful</a></li>
<li><a href="../276223/index.html">UX as Kung Fu (a guide for trolling and staffing adjustments)</a></li>
<li><a href="../276227/index.html">man! (C => D)</a></li>
<li><a href="../276229/index.html">Greetings from FOSDEM 2016</a></li>
<li><a href="../276235/index.html">How we stopped being afraid of UI tickets</a></li>
<li><a href="../276239/index.html">TotalView extends status monitoring for IP PBX 3CX Phone System</a></li>
<li><a href="../276247/index.html">Working with JSON in Swift</a></li>
<li><a href="../276249/index.html">Top free vector icon collections</a></li>
<li><a href="../276251/index.html">Procedurally generated world maps on Unity C #, part 1</a></li>
<li><a href="../276253/index.html">How programming makes it logical to express thoughts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>