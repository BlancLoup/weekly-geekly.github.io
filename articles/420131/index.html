<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitcoin Probabilistic Mining Method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think a little nonsense on Tuesday won't hurt the work week much. I have a hobby, at leisure I try to figure out how to crack a bitcoin mining algor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitcoin Probabilistic Mining Method</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/oi/lh/dt/oilhdtkhhgrgz2gpjy00mjrxhaq.jpeg"><br><br>  I think a little nonsense on Tuesday won't hurt the work week much.  I have a hobby, at leisure I try to figure out how to crack a bitcoin mining algorithm, avoid stupid busting nonses, and find a solution to the problem of selecting a hash with minimal power consumption.  I‚Äôll say the result right away, of course, I haven‚Äôt reached it yet, but nevertheless, why not put in writing the ideas that are born in my head?  Somewhere they need to do ... <br><br>  Despite the delusional ideas outlined below, I think this article may be useful to someone who studies 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  C ++ language and its templates </li><li>  some digital circuitry </li><li>  a bit of probability theory and probabilistic arithmetic </li><li>  detailed bitcoin hashing algorithm </li></ol><a name="habracut"></a><br>  Where do we start? <br><br>  Maybe from the last and most boring item on this list?  Be patient, more will be more fun. <br>  Let us consider in detail the algorithm for calculating the bitcoin hashing function.  It is simple F (x) = sha256 (sha256 (x)), where x is the input data 80 bytes, the block header with the block version number, prev block hash, merkle root, timestamp, bits and nonce.  Here are examples of pretty fresh block headers that are passed to the hashing function: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//blk=533522 0x00,0x00,0x00,0x20, 0x6d,0xa5,0xdd,0xb5,0x78,0x04,0x08,0x80,0xae,0x3d,0xed,0xc5,0x8e,0xe9,0x74,0x93,0x93,0x6d,0x6a,0xf4,0x0e,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xdf,0x3e,0xb0,0xf4,0x92,0xbf,0xe9,0xb8,0xc8,0x12,0x1f,0x84,0xdd,0x35,0xe1,0x38,0x09,0xcc,0x28,0xc2,0x33,0x53,0x90,0x4e,0x15,0x49,0x5e,0xc7,0xb0,0x78,0x35,0x91, 0x82,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xAA,0x02,0x44,0x22, //blk=533523 0x00,0x00,0x00,0x20, 0x6a,0x27,0x37,0xc3,0x1f,0x68,0xf8,0xe3,0x03,0xa3,0x5d,0xff,0x2d,0x97,0x39,0xaf,0x81,0xa2,0xf5,0xf0,0x7c,0xdb,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xa1,0xb8,0x4f,0x75,0x66,0xf3,0xf3,0x8e,0x78,0xf7,0xa2,0xa2,0xa2,0x19,0xa1,0x18,0x45,0xfa,0x58,0x53,0xe4,0x05,0x50,0x12,0x57,0xa1,0xab,0x2c,0x39,0xe6,0x1f,0x63, 0xA0,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0x84,0x7B,0x86,0xE7, //blk=533524 0x00,0x00,0x00,0x20, 0xb3,0xc7,0xaa,0x07,0x26,0xdb,0xe8,0x58,0x19,0xa8,0xb9,0x53,0x08,0x62,0x8b,0xca,0x58,0x00,0x69,0x64,0x58,0x69,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x4e,0xfc,0xf4,0x5c,0xad,0x31,0x44,0x5b,0xb1,0x13,0x80,0x03,0xe0,0xfd,0x04,0x24,0x86,0xcc,0x7a,0x8c,0xa7,0x7c,0x30,0x60,0x05,0x6f,0x43,0xcf,0x25,0x45,0x8f,0xd8, 0x80,0xDE,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xF7,0x2B,0x3B,0x42,</span></span></code> </pre> <br>  This set of bytes is quite valuable material, since it is often not easy to understand the source code of miners in which order the bytes should follow when forming the header, often using reversal by places of lower and higher bytes (endians). <br><br>  So, from the block header, 80 bytes is considered the sha256 hash and then the result is still sha256. <br>  The sha256 algorithm itself, if viewed from different sources, usually consists of four functions: <br><br><ol><li>  void sha256_init (SHA256_CTX * ctx); </li><li>  void sha256_transform (SHA256_CTX * ctx, const BYTE data []); </li><li>  void sha256_update (SHA256_CTX * ctx, const BYTE data [], size_t len); </li><li>  void sha256_final (SHA256_CTX * ctx, BYTE hash []); </li></ol><br>  The first function that is called when calculating the hash is sha256_init (), which initializes the SHA256_CTX structure.  There is so much nothing important except the eight 32-bit words state, which are initially filled with special words: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;bitlen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x6a09e667</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbb67ae85</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x3c6ef372</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0xa54ff53a</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0x510e527f</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0x9b05688c</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0x1f83d9ab</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0x5be0cd19</span></span>; }</code> </pre><br>  Suppose we have a file whose hash needs to be calculated.  We read the file in blocks of arbitrary size and call the function sha256_update () where we pass a pointer to the block data and block length.  The function accumulates a hash in the SHA256_CTX structure in the state array: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE data[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { ctx-&gt;data[ctx-&gt;datalen] = data[i]; ctx-&gt;datalen++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx-&gt;datalen == <span class="hljs-number"><span class="hljs-number">64</span></span>) { sha256_transform(ctx, ctx-&gt;data); ctx-&gt;bitlen += <span class="hljs-number"><span class="hljs-number">512</span></span>; ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  By itself, sha256_update () calls the work horse sha256_transform () function, which already accepts blocks of only 64-byte fixed length: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************** MACROS ******************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROTLEFT(a,b) (((a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32-(b)))) #define ROTRIGHT(a,b) (((a) &gt;&gt; (b)) | ((a) &lt;&lt; (32-(b)))) #define CH(x,y,z) (((x) &amp; (y)) ^ (~(x) &amp; (z))) #define MAJ(x,y,z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z))) #define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22)) #define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25)) #define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) &gt;&gt; 3)) #define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) &gt;&gt; 10)) /**************************** VARIABLES *****************************/ static const uint32_t k[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; /*********************** FUNCTION DEFINITIONS ***********************/ void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) { uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; for (i = 0, j = 0; i &lt; 16; ++i, j += 4) m[i] = (data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) | (data[j + 2] &lt;&lt; 8) | (data[j + 3]); for (; i &lt; 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16]; a = ctx-&gt;state[0]; b = ctx-&gt;state[1]; c = ctx-&gt;state[2]; d = ctx-&gt;state[3]; e = ctx-&gt;state[4]; f = ctx-&gt;state[5]; g = ctx-&gt;state[6]; h = ctx-&gt;state[7]; for (i = 0; i &lt; 64; ++i) { t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i]; t2 = EP0(a) + MAJ(a, b, c); h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2; } ctx-&gt;state[0] += a; ctx-&gt;state[1] += b; ctx-&gt;state[2] += c; ctx-&gt;state[3] += d; ctx-&gt;state[4] += e; ctx-&gt;state[5] += f; ctx-&gt;state[6] += g; ctx-&gt;state[7] += h; }</span></span></span></span></code> </pre><br>  When the hashed file is read and transferred to the sha256_update () function, all that remains is to call the terminating sha256_final () function, which, if the file size was not a multiple of 64 bytes, will add additional padding bytes, write the total data length in bits and will make the final sha256_transform (). <br>  The result of the hash remains in the state array. <br><br>  This is a high level <br><br>  In relation to the Bitcoin miner, of course, developers think how to be considered smaller and more efficient. <br><br>  It's simple: the header contains only 80 bytes, which is not a multiple of 64 bytes.  Thus, it would be necessary for the first sha256 to already do two sha256_transform ().  However, fortunately for miners, a nonce block is at the end of the header, so the first sha256_transform () can be performed only once - this will be the so-called midstate.  Next, the miner enumerates all non-options, of which 4 billion, 2 ^ 32, and substitutes them in the appropriate field for the second sha256_transform ().  This transform completes the first function of sha256.  Its result is eight 32-bit words, that is 32 bytes.  From them it is easy to find sha256 - the final sha256_transform () is called and everything is ready.  Notice that the input data is 32 bytes smaller than the 64 bytes needed for sha256_transform ().  This means again the block will be padded with zeros and the block length will be entered at the end. <br><br>  There are a total of three calls to sha256_transform () of which the first must be read only once to calculate the midstate. <br><br>  I tried to deploy all the data manipulations that occur when calculating the hash of the bitcoin block header into a single function, so that it is clear how the whole calculation occurs specifically for bitcoin and this is what happened: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//get bitcoin header via ptr to 80 bytes and calc hash template &lt;typename T&gt; void full_btc_hash(const uint8_t* ptr80, T nonce, T* presult) { //-1------------------------------------------ //init sha256 state s[7:0] T s[16]; for (int i = 0; i &lt; 8; i++) { s[i] = sha256_init_state[i]; presult[i] = sha256_init_state[i]; } uint8_t tail2[] = { 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00, }; uint32_t* p = (uint32_t*)tail2; for (int i = 0; i &lt; 8; i++) { s[i + 8] = ntohl(p[i]); } //get first block for sha256 uint8_t tail[] = { /* 2nd sha256 block padding */ 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x80 }; T blk1[32]; p = (uint32_t*)ptr80; for (int i = 0; i &lt; 19; i++) { blk1[i] = ntohl(p[i]); } //put nonce here blk1[19] = nonce; p = (uint32_t*)tail; for (int i = 0; i &lt; 12; i++) { blk1[i + 20] = ntohl(p[i]); } sha256_transform(s, &amp;blk1[0]); //warning! this can be called only once and produce MIDSTATE sha256_transform(s, &amp;blk1[16]); sha256_transform(presult, s); }</span></span></code> </pre><br>  I implemented this function as a c ++ template, it can operate with me not just with 32-bit words, say uint32_t, but also with words of another type ‚ÄúT‚Äù.  I have here and the state of sha256 is stored as an array of type ‚ÄúT‚Äù and sha256_transform () is called with a parameter with a pointer to an array of type ‚ÄúT‚Äù and the result is returned the same.  Transform function is now also in the form of c ++ template: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ror32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T word, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (word &gt;&gt; shift) | (word &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - shift)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z ^ (x &amp; (y ^ z)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &amp; y) | (z &amp; (x | y)); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e0(x) (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e1(x) (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s0(x) (ror32(x, 7) ^ ror32(x,18) ^ (x &gt;&gt; 3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s1(x) (ror32(x,17) ^ ror32(x,19) ^ (x &gt;&gt; 10)) unsigned int ntohl(unsigned int in) { return ((in &amp; 0xff) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24) | ((in &amp; 0xff00) &lt;&lt; 8) | ((in &amp; 0xff0000) &gt;&gt; 8) | ((in &amp; 0xff000000) &gt;&gt; 24); } template &lt;typename T&gt; void LOAD_OP(int I, T *W, const u8 *input) { //W[I] = /*ntohl*/ (((u32*)(input))[I]); W[I] = ntohl(((u32*)(input))[I]); //W[I] = (input[3] &lt;&lt; 24) | (input[2] &lt;&lt; 16) | (input[1] &lt;&lt; 8) | (input[0]); } template &lt;typename T&gt; void BLEND_OP(int I, T *W) { W[I] = s1(W[I - 2]) + W[I - 7] + s0(W[I - 15]) + W[I - 16]; } template &lt;typename T&gt; void sha256_transform(T *state, const T *input) { T a, b, c, d, e, f, g, h, t1, t2; TW[64]; int i; /* load the input */ for (i = 0; i &lt; 16; i++) // MJ input is cast to u32* so this processes 16 DWORDS = 64 bytes W[i] = input[i]; /* now blend */ for (i = 16; i &lt; 64; i++) BLEND_OP(i, W); /* load the state into our registers */ a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; // t1 = h + e1(e) + Ch(e, f, g) + 0x428a2f98 + W[0]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x71374491 + W[1]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb5c0fbcf + W[2]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xe9b5dba5 + W[3]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x3956c25b + W[4]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x59f111f1 + W[5]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x923f82a4 + W[6]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xab1c5ed5 + W[7]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xd807aa98 + W[8]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x12835b01 + W[9]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x243185be + W[10]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x550c7dc3 + W[11]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x72be5d74 + W[12]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x80deb1fe + W[13]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x9bdc06a7 + W[14]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc19bf174 + W[15]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xe49b69c1 + W[16]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xefbe4786 + W[17]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x0fc19dc6 + W[18]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x240ca1cc + W[19]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x2de92c6f + W[20]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4a7484aa + W[21]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5cb0a9dc + W[22]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x76f988da + W[23]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x983e5152 + W[24]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa831c66d + W[25]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb00327c8 + W[26]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xbf597fc7 + W[27]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xc6e00bf3 + W[28]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd5a79147 + W[29]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x06ca6351 + W[30]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x14292967 + W[31]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x27b70a85 + W[32]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x2e1b2138 + W[33]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x4d2c6dfc + W[34]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x53380d13 + W[35]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x650a7354 + W[36]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x766a0abb + W[37]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x81c2c92e + W[38]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x92722c85 + W[39]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xa2bfe8a1 + W[40]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa81a664b + W[41]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xc24b8b70 + W[42]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xc76c51a3 + W[43]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xd192e819 + W[44]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd6990624 + W[45]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xf40e3585 + W[46]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x106aa070 + W[47]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x19a4c116 + W[48]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x1e376c08 + W[49]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x2748774c + W[50]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x34b0bcb5 + W[51]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x391c0cb3 + W[52]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4ed8aa4a + W[53]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5b9cca4f + W[54]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x682e6ff3 + W[55]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x748f82ee + W[56]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x78a5636f + W[57]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x84c87814 + W[58]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x8cc70208 + W[59]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x90befffa + W[60]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xa4506ceb + W[61]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xbef9a3f7 + W[62]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc67178f2 + W[63]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; }</span></span></span></span></code> </pre><br>  Using the C ++ template functions is convenient because I can calculate the hash I need from ordinary data and get the usual result: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> header[] = { <span class="hljs-number"><span class="hljs-number">0x02</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x5b</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0xc1</span></span>,<span class="hljs-number"><span class="hljs-number">0x8e</span></span>,<span class="hljs-number"><span class="hljs-number">0xd1</span></span>,<span class="hljs-number"><span class="hljs-number">0xf7</span></span>, <span class="hljs-number"><span class="hljs-number">0xe2</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0xf2</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x59</span></span>,<span class="hljs-number"><span class="hljs-number">0x9b</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>, <span class="hljs-number"><span class="hljs-number">0x33</span></span>,<span class="hljs-number"><span class="hljs-number">0x0e</span></span>,<span class="hljs-number"><span class="hljs-number">0xda</span></span>,<span class="hljs-number"><span class="hljs-number">0xb8</span></span>,<span class="hljs-number"><span class="hljs-number">0x78</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x8a</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x29</span></span>,<span class="hljs-number"><span class="hljs-number">0x5a</span></span>,<span class="hljs-number"><span class="hljs-number">0x27</span></span>,<span class="hljs-number"><span class="hljs-number">0x47</span></span>,<span class="hljs-number"><span class="hljs-number">0xb4</span></span>,<span class="hljs-number"><span class="hljs-number">0xf1</span></span>, <span class="hljs-number"><span class="hljs-number">0xa0</span></span>,<span class="hljs-number"><span class="hljs-number">0xb3</span></span>,<span class="hljs-number"><span class="hljs-number">0x94</span></span>,<span class="hljs-number"><span class="hljs-number">0x8d</span></span>,<span class="hljs-number"><span class="hljs-number">0xf3</span></span>,<span class="hljs-number"><span class="hljs-number">0x99</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x44</span></span>, <span class="hljs-number"><span class="hljs-number">0xc0</span></span>,<span class="hljs-number"><span class="hljs-number">0xe1</span></span>,<span class="hljs-number"><span class="hljs-number">0x9f</span></span>,<span class="hljs-number"><span class="hljs-number">0xa6</span></span>,<span class="hljs-number"><span class="hljs-number">0xb2</span></span>,<span class="hljs-number"><span class="hljs-number">0xb9</span></span>,<span class="hljs-number"><span class="hljs-number">0x2b</span></span>,<span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">0x19</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0xe6</span></span>,<span class="hljs-number"><span class="hljs-number">0xba</span></span>, <span class="hljs-number"><span class="hljs-number">0xdc</span></span>,<span class="hljs-number"><span class="hljs-number">0x14</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x87</span></span>, <span class="hljs-number"><span class="hljs-number">0x35</span></span>,<span class="hljs-number"><span class="hljs-number">0x8b</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x53</span></span>, <span class="hljs-number"><span class="hljs-number">0x53</span></span>,<span class="hljs-number"><span class="hljs-number">0x5f</span></span>,<span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x19</span></span>, <span class="hljs-number"><span class="hljs-number">0x48</span></span>,<span class="hljs-number"><span class="hljs-number">0x75</span></span>,<span class="hljs-number"><span class="hljs-number">0x08</span></span>,<span class="hljs-number"><span class="hljs-number">0x33</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> test_nonce = <span class="hljs-number"><span class="hljs-number">0x48750833</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result[<span class="hljs-number"><span class="hljs-number">8</span></span>]; full_btc_hash(header, test_nonce, result); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* presult = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * )result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%02X "</span></span>, presult[i]);</code> </pre><br>  It turns out: <br><br>  92 98 2A 50 91 FA BD 42 97 8A A5 2D CD C9 36 28 02 4A DD FE E0 67 A4 78 00 00 00 00 00 00 00 <br><br>  At the end of the hash there are a lot of zeros, beautiful hash, bingo, etc. <br><br>  And now I can pass to this hashing function not ordinary uint32_t data, but my special C ++ class, which will override all arithmetic. <br><br>  Yes Yes.  I am going to apply ‚Äúalternative‚Äù probabilistic mathematics. <br>  He invented himself, realized himself, tested himself.  It doesn't seem to work very well.  Joke.  Should work.  Maybe not even the first I am trying to crank. <br><br>  Now we come to the most interesting. <br>  All arithmetic in digital electronics is performed as bit operations, and it is strictly defined by AND, OR, NOT, EXCLUSIVE OR operations.  Well, we all know what truth tables are in Boolean algebra. <br><br>  I propose to add a little uncertainty in the calculations, to make them probabilistic. <br>  Let every bit in a word have not only possible values ‚Äã‚Äãof ZERO and ONE, but also all intermediate values!  I propose to consider the value of a bit as the probability of an event that may or may not occur.  If all the original data are reliably known, then the result is reliable.  And if some data is a bit lacking, then the result will be obtained with a certain probability. <br><br>  Indeed, suppose there are two independent events ‚Äúa‚Äù and ‚Äúb‚Äù, the probabilities of falling out of which are naturally zero to one, respectively, Pa and Pb.  What is the probability that events will happen at the same time?  I am sure that each of us will answer P = Pa * Pb without hesitation and this is the correct answer! <br><br>  The 3D graph of this function will look like this (from two different points of view): <br><br><img src="https://habrastorage.org/webt/-e/ll/pw/-ellpwuzq9bxl8fi_b3l1drhutc.png"><br><br>  And what is the probability that a Pa event or a Pb event will happen? <br>  Probability P = Pa + Pb-Pa * Pb.  The graph of the function is as follows: <br><br><img src="https://habrastorage.org/webt/vs/sd/wk/vssdwknevb1dijfbqcy3lsnib0w.png"><br><br>  And if we know the probability of a Pa event, then what is the probability that an event will not occur? <br>  P = 1 - Pa. <br><br>  Now we make an assumption.  Imagine that we have logical elements that calculate the probability of an output event, knowing the probability of input events: <br><br><img src="https://habrastorage.org/webt/tn/qk/-v/tnqk-v5-dce15dkr0-zsb1wmiww.gif"><br><br>  Having such logical elements, you can easily make them more complex, for example, exclusive or, XOR: <br><br><img src="https://habrastorage.org/webt/l0/e8/ju/l0e8judlmw-uh6plwsuj5sjnutq.png"><br><br>  Now, looking at the diagram of this XOR logical element, one can understand what the probability of an event at the output of a probabilistic XOR will be: <br><br><img src="https://habrastorage.org/webt/oj/xy/re/ojxyrexx8xkmcrmoyfohfl6bqyw.png"><br><br>  But that's not all.  We know the typical logic circuit of a full adder and we know how a multi-digit adder is made from a full adder: <br><br><img src="https://habrastorage.org/webt/_s/fh/qs/_sfhqsmrhygqasjfv6inengna38.png"><br><br>  So now, according to its scheme, we can now calculate the probabilities of the signals at its output, with known probabilities of the signals at the input. <br><br>  Thus, I can implement my own 32-bit class in c ++ (I‚Äôll call it x32) with probabilistic arithmetic, redefine all the necessary operations for sha256 such as AND, OR, XOR, ADD and shifts.  The class will store inside 32 bits, but each bit as a floating point number.  Each logical or arithmetic operation on such a 32-bit number will calculate the probability of the value of each bit with known or little-known input parameters of a logical or arithmetic operation. <br><br>  Consider such a very simple example that uses my probabilistic mathematics: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); x32 a = <span class="hljs-number"><span class="hljs-number">0xaabbccdd</span></span>; x32 b = <span class="hljs-number"><span class="hljs-number">0x12345678</span></span>; &lt;b&gt;<span class="hljs-comment"><span class="hljs-comment">//b.setBit( 4, 0.75 );&lt;/b&gt; x32 c = a + b; cout &lt;&lt; std::hex &lt;&lt; "result = 0x" &lt;&lt; c.get32() &lt;&lt; "\n" &lt;&lt; std::dec; for (int i = 0; i &lt; 32; i++) cout &lt;&lt; "bit" &lt;&lt; i &lt;&lt; " = " &lt;&lt; c.get_bvi(i) &lt;&lt; "\n"; cout &lt;&lt; "ok\n"; }</span></span></code> </pre><br>  In this example, two 32-bit numbers are summed. <br>  While the line is b.setBit (4, 0.75);  the result of addition is commented out precisely predictable and predetermined, because all the input data for addition is known.  The program will type this into the console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">result</span></span> = 0xbcf02355 bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  If, however, uncommenting the line b.setBit (4, 0.75); then by this I‚Äôm saying to the program: "add these two numbers to me, but I don‚Äôt really know the meaning of bit 4 of the second argument, I think with probability 0.75 this is one." <br><br>  Then the addition occurs, as it should, with a full calculation of the probabilities of the output signals, that is, the bits: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> result = <span class="hljs-number"><span class="hljs-number">0xbcf02305</span></span> bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">0.75</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0.1875</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">0.8125</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Due to the fact that the input data were not very well known, the result is not very well known.  At the same time, what can be reliably calculated is considered credible  What cannot be counted is considered with probability. <br><br>  Now, when I have such a wonderful 32-bit c ++ class for fuzzy arithmetic, I can transfer to the full_btc_hash () function an array of x32 variables and get a probabilistic estimated result of the hash. <br><br><div class="spoiler">  <b class="spoiler_title">Some of the x32 class implementation here:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;stdint.h&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; #include &lt;boost/math/constants/constants.hpp&gt; #include &lt;boost/multiprecision/cpp_dec_float.hpp&gt; using boost::multiprecision::cpp_dec_float_50; //typedef double MY_FP; typedef cpp_dec_float_50 MY_FP; class x32 { public: x32(); x32(uint32_t n); void init(MY_FP val); void init(double* pval); void setBit(int i, MY_FP val) { bvi[i] = val; }; ~x32() {}; x32 operator|(const x32&amp; right); x32 operator&amp;(const x32&amp; right); x32 operator^(const x32&amp; right); x32 operator+(const x32&amp; right); x32&amp; x32::operator+=(const x32&amp; right); x32 operator~(); x32 operator&lt;&lt;(const unsigned int&amp; right); x32 operator&gt;&gt;(const unsigned int&amp; right); void print(); uint32_t get32(); MY_FP get_bvi(uint32_t idx) { return bvi[idx]; }; private: MY_FP not(MY_FP a); MY_FP and(MY_FP a, MY_FP b); MY_FP or (MY_FP a, MY_FP b); MY_FP xor(MY_FP a, MY_FP b); MY_FP bvi[32]; //bit values }; #include "stdafx.h" #include "x32.h" x32::x32() { for (int i = 0; i &lt; 32; i++) { bvi[i] = 0.0; } } x32::x32(uint32_t n) { for (int i = 0; i &lt; 32; i++) { bvi[i] = (n&amp;(1 &lt;&lt; i)) ? 1.0 : 0.0; } } void x32::init(MY_FP val) { for (int i = 0; i &lt; 32; i++) { bvi[i] = val; } } void x32::init(double* pval) { for (int i = 0; i &lt; 32; i++) { bvi[i] = pval[i]; } } x32 x32::operator&lt;&lt;(const unsigned int&amp; right) { x32 t; for (int i = 31; i &gt;= 0; i--) { if (i &lt; right) { t.bvi[i] = 0.0; } else { t.bvi[i] = bvi[i - right]; } } return t; } x32 x32::operator&gt;&gt;(const unsigned int&amp; right) { x32 t; for (unsigned int i = 0; i &lt; 32; i++) { if (i &gt;= (32 - right)) { t.bvi[i] = 0; } else { t.bvi[i] = bvi[i + right]; } } return t; } MY_FP x32::not(MY_FP a) { return 1.0 - a; } MY_FP x32::and(MY_FP a, MY_FP b) { return a * b; } MY_FP x32::or(MY_FP a, MY_FP b) { return a + b - a * b; } MY_FP x32::xor (MY_FP a, MY_FP b) { //(~(A &amp; B)) &amp; (A | B) return and( not( and(a,b) ) , or(a,b) ); } x32 x32::operator|(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = or ( bvi[i], right.bvi[i] ); } return t; } x32 x32::operator&amp;(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = and (bvi[i], right.bvi[i]); } return t; } x32 x32::operator~() { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = not(bvi[i]); } return t; } x32 x32::operator^(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = xor (bvi[i], right.bvi[i]); } return t; } x32 x32::operator+(const x32&amp; right) { x32 r; r.bvi[0] = xor (bvi[0], right.bvi[0]); MY_FP cout = and (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); r.bvi[i] = xor( xor_a_b, cout ); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); cout = or (and1,and2); } return r; } x32&amp; x32::operator+=(const x32&amp; right) { MY_FP cout = and (bvi[0], right.bvi[0]); bvi[0] = xor (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); bvi[i] = xor (xor_a_b, cout); cout = or (and1, and2); } return *this; } void x32::print() { for (int i = 0; i &lt; 32; i++) { cout &lt;&lt; bvi[i] &lt;&lt; "\n"; } } uint32_t x32::get32() { uint32_t r = 0; for (int i = 0; i &lt; 32; i++) { if (bvi[i] == 1.0) r = r | (1 &lt;&lt; i); else if (bvi[i] == 0.0) { //ok } else { //oops.. cout &lt;&lt; "bit not stable\n"; } } return r; }</span></span></span></span></code> </pre><br></div></div><br>  What is all this for? <br><br>  Miner Bitcoin does not know in advance what to choose the value of 32-bit nonce.  Miner is forced to sort through all 4 billion to count the hash until it becomes ‚Äúbeautiful‚Äù until the hash value is less than the target. <br><br>  Fuzzy probabilistic arithmetic theoretically allows you to get rid of brute force. <br><br>  Yes, I initially do not know the meaning of all the necessary bits of nonce.  If I don‚Äôt know them, let them be anything-and-nothing - the initial probability of non-bits is 0.5.  Even in this situation, I can calculate the probability of the output bits of the hash.  Somewhere, they also turn out to be about 0.5 plus or minus half a penny. <br><br> ,          0.5  0.9   0.1   1.0  ,            .       .                       . <br><br> ,  ,         ,       0.5   ,  ,    nonce[0] = 0.9: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); <span class="hljs-comment"><span class="hljs-comment">//--------------------------------- //hash: 502A989242BDFA912DA58A972836C9CDFEDD4A0278A467E00000000000000000 const u8 strxx[] = { 0x02,0x00,0x00,0x00, 0x17,0x97,0x5b,0x97,0xc1,0x8e,0xd1,0xf7, 0xe2,0x55,0xad,0xf2,0x97,0x59,0x9b,0x55, 0x33,0x0e,0xda,0xb8,0x78,0x03,0xc8,0x17, 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x8a,0x97,0x29,0x5a,0x27,0x47,0xb4,0xf1, 0xa0,0xb3,0x94,0x8d,0xf3,0x99,0x03,0x44, 0xc0,0xe1,0x9f,0xa6,0xb2,0xb9,0x2b,0x3a, 0x19,0xc8,0xe6,0xba, 0xdc,0x14,0x17,0x87, 0x35,0x8b,0x05,0x53, 0x53,0x5f,0x01,0x19, 0x48,0x75,0x08,0x33 }; double nonce_bits[32]; for (int i = 0; i &lt; 32; i++) nonce_bits[i] = 0.5; x32 nonce_x32_a; x32 nonce_x32_b; nonce_x32_a.init(nonce_bits); nonce_bits[0] = 0.9; nonce_x32_b.init(nonce_bits); x32 result_x32_a[8]; x32 result_x32_b[8]; full_btc_hash(strxx, nonce_x32_a, result_x32_a); full_btc_hash(strxx, nonce_x32_b, result_x32_b); for (int i = 0; i &lt; 32; i++) cout &lt;&lt; result_x32_a[7].get_bvi(i) &lt;&lt; " " &lt;&lt; result_x32_b[7].get_bvi(i) &lt;&lt; "\n";</span></span></code> </pre><br>   x32::get_bvi()      . <br>   ,      nonce[0]  0.5  0.9,        ,     : <br><br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540883948</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540840074</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.55268174813167364</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5526817481315932</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725359399</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725360606</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978928474</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978930477</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561406703</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561407746</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53237003739057907</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5323700373905661</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138096</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138162</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57631236396381141</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5763123639638157</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960149</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960219</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54955992675177704</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5495599267517755</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879686</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879733</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744952</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744984</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387693</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387655</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899101</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899102</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287194</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287198</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354913</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354916</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366491</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366487</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913003</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913005</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776142</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776143</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552812</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552813</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889921</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889922</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span></code> </pre><br>   ,        10   .    ‚Ä¶      - .  , ? <br><br> ,       ,   ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nonce_bits[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) nonce_bits[i] = (real_nonce32&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; x32 nonce_x32; nonce_x32.init(nonce_bits); full_btc_hash(strxx, nonce_x32, result_x32);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then calculating a probabilistic hash, we obtain a logical correct result - a ‚Äúbeautiful‚Äù hash on the output, bingo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So with math, it's all right. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to learn to analyze the breath of the wind ... and the hash is broken. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It sounds like nonsense, but this is nonsense - and I warned at the very beginning. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other useful materials:</font></font><br><br><ol><li> <a href="https://habr.com/post/258181/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minn Bitcoin with paper and pen.</font></font></a> </li><li>  <a href="https://habr.com/post/318174/">Can bitcoins be calculated faster, easier or easier?</a> </li><li>  <a href="https://habr.com/post/351118/">As i blakecoin miner did</a> </li><li> <a href="https://marsohod.org/projects/proekty-dlya-platy-marsokhod3/340-miner-bitcoin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGA Miner Bitcoin on Rover Rover3</font></font></a> </li><li> <a href="https://marsohod.org/projects/proekty-dlya-platy-marsokhod3/363-blake"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGA Miner with Blake algorithm</font></font></a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/420131/">https://habr.com/ru/post/420131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420119/index.html">10 Python web frameworks to work with in 2018</a></li>
<li><a href="../420121/index.html">Strength test: Termite LT450, LXI</a></li>
<li><a href="../420123/index.html">What is Node.js really?</a></li>
<li><a href="../420125/index.html">Automation in the field of finance: bank employees may be left without work due to robots</a></li>
<li><a href="../420129/index.html">Patterns corinne asyncio: outside of await</a></li>
<li><a href="../420133/index.html">Modeling Dynamic Systems: How does the moon move?</a></li>
<li><a href="../420139/index.html">The book "Site Reliability Engineering. Reliability and reliability as in Google "</a></li>
<li><a href="../420141/index.html">From loaded MPP, the DBMS is a vigorous Data Lake with analytical tools: sharing the creation details</a></li>
<li><a href="../420143/index.html">Kotlin performance on Android</a></li>
<li><a href="../420145/index.html">How is the working day of the members of the PC AppsConf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>