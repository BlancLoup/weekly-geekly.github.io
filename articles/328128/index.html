<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quake 2 source code overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I spent about a month of free time reading the Quake II source code. It was an amazing and instructive experience, because a big change was made to id...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quake 2 source code overview</h1><div class="post__text post__text-html js-mediator-article"><img src="http://fabiensanglard.net/quake2/shadow_issue_zoom.jpg" alt="image"><br><br>  I spent about a month of free time reading the Quake II source code.  It was an amazing and instructive experience, because a big change was made to idTech3: Quake 1, Quake World and QuakeGL are combined into one beautiful code architecture.  Of particular interest was the way modularity was achieved, despite the fact that the C programming language does not provide polymorphism. <br><br>  Quake II is in many ways a brilliant example of software, because it was the most popular (by the number of licenses) three-dimensional engine of all time.  Based on it, more than 30 games were created.  In addition, he marked the transition of the gaming industry from software / 8-bit color system to hardware / 24-bit.  This transition occurred around 1997. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, I highly recommend everyone who loves programming to learn this engine.  As usual, I kept an infinite number of notes, then cleaned them up and published them as an article to save you a few hours. <br><br>  The process of ‚Äúerasure‚Äù I was very fascinated: the article now has more than 40 megabytes of video, screenshots and illustrations.  Now I don‚Äôt know if my works were worth it, and whether it‚Äôs necessary to publish in the future unprocessed notes in ASCII, express your opinion. <br><a name="habracut"></a><br><h3>  First meeting and compilation </h3><br>  The source code is freely available on <a href="">the</a> id Software <a href="">ftp site</a> .  The project can be opened in Visual Studio Express 2008, which can also be freely downloaded from the Microsoft website. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb2/601/da4/fb2601da4cd59d0598e116907210191d.png"><br><br>  The first problem is that the working environment in Visual Studio 6 creates not one, but five projects.  This is because Quake2 was developed modular (I will talk more about this later).  Here is what comes out of the projects: <br><table><tbody><tr><td align="center">  <b>Projects</b> </td><td align="center">  <b>Assembly</b> </td></tr><tr><td align="center">  ctf </td><td align="center">  gamex86.dll </td></tr><tr><td align="center">  game </td><td align="center">  gamex86.dll </td></tr><tr><td align="center">  quake2 </td><td align="center">  quake.exe </td></tr><tr><td align="center">  ref_soft </td><td align="center">  ref_soft.dll </td></tr><tr><td align="center">  ref_gl </td><td align="center">  ref_gl.dll </td></tr></tbody></table>  <u><b>Note:</b></u> the ctf and game projects overwrite each other, more on this later. <br><br>  <u><b>Note 2:</b></u> first, the build fails due to the lack of a DirectX header: <br><br><pre><code class="cpp hljs">fatal error C1083: Cannot open include file: <span class="hljs-string"><span class="hljs-string">'dsound.h'</span></span>: No such file <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory</code> </pre> <br>  I installed the Direct3D SDK and Microsoft SDK (for MFC), and everything compiled normally. <br><br>  <u><b>Software erosion:</b></u> it looks like what happened to the Quake code base begins to happen with Quake 2: it‚Äôs impossible to open the work environment in Visual Studio 2010. You must use VS 2008. <br><br>  <u>Note:</u> if an error occurs after compilation <br><br> <code>"Couldn't fall back to software refresh!"</code>  , <br><br>  This means that the renderer DLL could not be loaded correctly.  But it is easy to fix: <br><br>  Quake2 core loads two of its DLLs using win32 API: LoadLibrary.  If the DLL is not the one that is expected or it is impossible to resolve the DLL dependencies, then the failure occurs without displaying an error message.  Therefore: <br><br><ul><li>  Connect all five projects with one library - right-click on each project -&gt; properties -&gt; C / C ++: make sure that ‚Äúruntime library‚Äù = Multi-threaded Debug DLL (with ‚ÄúDebug‚Äù configuration, otherwise use release). </li></ul><br>  If you use the quake2 version released by id Software, this will eliminate the error. <br><br><ul><li>  If you are using my version: I added the ability to save screenshots to PNG in the engine, so you need to also compile libpng and libz (they are in a subdirectory).  Make sure the Debug DLL configuration is selected.  When building, do not forget to place the libpng and zlib DLLs in the same folder as quake2.exe. </li></ul><br><h3>  Quake2 architecture </h3><br>  When I read the Quake 1 code, I divided the <a href="http://fabiensanglard.net/quakeSource/index.php">article</a> (its translation is <a href="https://habrahabr.ru/post/324804/">here</a> ) into three parts: ‚ÄúNetwork‚Äù, ‚ÄúPrediction‚Äù and ‚ÄúVisualization‚Äù.  Such an approach would also be appropriate for Quake 2, because the engine is not very different in its core, but it is easier to notice the improvements if you divide the article into three main types of projects: <br><table><tbody><tr><td>  <b>Type of project</b> </td><td>  <b>Project Information</b> </td></tr><tr><td>  Main engine (.exe) </td><td>  The kernel that calls the modules and exchanges information between the client and the server.  In a production environment, this is a <code>quake2</code> project. </td></tr><tr><td>  Renderer Module (.dll) </td><td>  Responsible for visualization.  The working environment contains the software renderer ( <code>ref_soft</code> ) and the OpenGL renderer ( <code>ref_gl</code> ). </td></tr><tr><td>  Game Module (.dll) </td><td>  Responsible for the gameplay (game content, weapons, monster behavior ...).  The production environment contains a single-user module ( <code>game</code> ) and a module Capture The Flag ( <code>ctf</code> ). </td></tr></tbody></table>  Quake2 has a single-threaded architecture, the entry point is in <code>win32/sys_win.c</code> .  The <code>WinMain</code> method performs the following tasks: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">game_export_t</span></span> *ge; <span class="hljs-comment"><span class="hljs-comment">//     dll  refexport_t re; //     dll  WinMain() // quake2.exe { Qcommon_Init (argc, argv); while(1) { Qcommon_Frame { SV_Frame() //   { //        if (!svs.initialized) return; //   game.dll    ge-&gt;RunFrame(); } CL_Frame() //   { //       if (dedicated-&gt;value) return; //   renderer.dll    re.BeginFrame(); //[...] re.EndFrame(); } } } }</span></span></code> </pre> <br>  A completely disassembled cycle can be found in my <a href="http://fabiensanglard.net/quake2/notes.html">notes.</a> <br><br>  You may ask: "why do we need such changes in architecture?".  To answer this question, let's look at all versions of Quake from 1996 to 1997: <br><br><ul><li>  Quake </li><li>  WinQuake. </li><li>  GLQuake. </li><li>  Vquake  (a few words from one of the developers Stefan Podell (Stefan Podell) about the <a href="http://groups.google.com/group/comp.sys.ibm.pc.hardware.video/msg/4d9ce71f1e1f6484">difficulties of the V2200 in Z-buffering</a> ( <a href="">mirror</a> )). </li><li>  Quake World Server. </li><li>  Quake World Client. </li></ul><br>  Many executable files were created, and each time it was required to fork or configure the code through the <code>#ifdef</code> preprocessor.  It was a complete chaos, and to get rid of it, it was necessary: <br><br><ul><li>  Unify client / server. </li><li>  Build a kernel capable of loading interchangeable modules. </li></ul><br>  A new approach can be illustrated in this way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57c/55a/008/57c55a0085d2977ff4ad0efacac2966b.jpg"><br><br>  Two major improvements: <br><br><ul><li>  <b>Client-server unification:</b> there was no longer one exe for the client and another for the server, the main executable file could work as a server, client, or both.  Even in single-user mode, the client and server were still running in the same executable file (although in this case the data was exchanged via a local buffer, and not via TCP IP / IPX). </li><li>  <b>Modularity:</b> thanks to the dynamic connection, part of the code has become interchangeable.  The renderer and game code became modules that could be switched without changing the core of Quake2.  Thus, polymorphism was achieved using two structures containing function pointers. </li></ul><br>  These two changes made the code base extremely elegant and more readable than Quake 1, which suffered from code entropy. <br><br>  From the point of view of implementation, DLL projects should disclose only one method <code>GetRefAPI</code> for renderers and <code>GetGameAPI</code> for a game (look at the <code>GetGameAPI</code> file in the ‚ÄúResource Files‚Äù folder): <br><br> <code>reg_gl/Resource Files/reg_soft.def</code> <br> <br><pre> <code class="cpp hljs"> EXPORTS GetGameAPI</code> </pre> <br>  When the kernel needs to load a module, it loads the DLL into the process space, gets the <code>GetRefAPI</code> address from <code>GetProcAddress</code> , gets the necessary function pointers and that's it. <br><br>  <u><b>An interesting fact:</b></u> in the local game, the connection between the client and the server is not performed through sockets.  Instead, the commands are dropped into the ‚Äúloopback‚Äù buffer using the <code>NET_SendLoopPacket</code> in the client side of the code.  The server reconstructs the command from the same buffer using the <code>NET_GetLoopPacket</code> . <br><br>  <u><b>Random fact:</b></u> if you have ever seen this photo, you probably wondered what John Carmack used for the giant display around 1996: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cb/9df/046/9cb9df0460e01b75292d8a849fbee326.jpg"><br><br>  It was a 28-inch InterView 28hd96 monitor manufactured by Intergraph.  This brute provided a resolution of up to 1920x1080, which is quite impressive for 1995 (you can read more <a href="http://www.ceu-inc.com/intergr_6d.html">here</a> ( <a href="">mirror</a> )). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/495/74a/6b5/49574a6b5a8575373f28812720a3307f.jpg"><br><br>  Nostalgic Youtube Video: <a href="http://www.youtube.com/watch%3Fv%3DRUghjj0cxgU">Intergraph Computer Systems Workstations</a> . <br><br>  <u>Addition:</u> it looks like this article inspired someone on geek.com because they wrote the article <a href="http://www.geek.com/articles/games/john-carmack-coded-quake-on-a-28-inch-169-1080p-monitor-in-1995-20110920/">‚ÄúJohn Carmack created Quake in 1995 on a 28-inch 16: 9 1080p monitor‚Äù</a> ( <a href="">mirror</a> ). <br><br>  <u>Addition:</u> it seems that John Carmack still used this monitor when developing Doom 3. <br><br><h3>  Visualization </h3><br>  The modules of the software renderer ( <code>ref_soft</code> ) and the hardware accelerated renderer ( <code>ref_gl</code> ) were so large that I wrote separate sections about them. <br><br>  Again, it is noteworthy that the kernel did not even know which renderer is connected: it simply caused the function pointer in the structure.  That is, the visualization pipeline was completely abstracted: and who needs this C ++? <br><br>  <u><b>Interesting fact:</b></u> id Software still uses the coordinate system from the 1992 Wolfenstein 3D game (at least that's how it was in Doom3).  This is important to know when reading the source code of the renderer: <br><br>  <u>In system id:</u> <br><ul><li>  X axis = left / right </li><li>  Y axis = front / rear </li><li>  Z axis = up / down </li></ul><br>  <u>In the OpenGL coordinate system:</u> <br><ul><li>  X axis = left / right </li><li>  Y axis = up / down </li><li>  Z axis = front / rear </li></ul><br>  Therefore, the OpenGL renderer uses the <code>GL_MODELVIEW</code> matrix to ‚Äúfix‚Äù the coordinate system in each frame using the <code>R_SetupGL</code> method ( <code>glLoadIdentity</code> + <code>glRotatef</code> ). <br><br><h3>  Dynamic connection </h3><br>  Much can be said about kernel / module interactions: I have written a separate section on dynamic connectivity. <br><br><h3>  Modding: gamex86.dll </h3><br>  Reading this part of the project was not so interesting, but the rejection of Quake-C for the compiled module led to two good and one very bad consequences. <br><br>  <u>The bad:</u> <br><br><ul><li>  Portability has been sacrificed, the game module must be recompiled for different platforms with specific linker parameters. </li></ul><br>  <u>Good:</u> <br><br><ul><li>  Speed: The Quake-C language of the Quake1 game was interpreted code, but the Quake2 <code>gamex86.dll</code> dynamic library <code>gamex86.dll</code> is native. </li><li>  Freedom: modders gained access to EVERYTHING, not just what was available through Quake-C. </li></ul><br>  <u>An interesting fact:</u> ironically, id Software has moved Quake3 back to using a virtual machine (QVM) for gaming, artificial intelligence and modding. <br><br><h3>  My quake2 </h3><br>  During the hacking process, I changed the Quake2 source code a bit.  I highly recommend adding a DOS console to see the <code>printf</code> output in the process, rather than pause the game to learn the Quake console: <br><br>  Adding a DOS-style console to a Win32 window is quite simple: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// sys_win.c int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { AllocConsole(); freopen("conin$","r",stdin); freopen("conout$","w",stdout); freopen("conout$","w",stderr); consoleHandle = GetConsoleWindow(); MoveWindow(consoleHandle,1,1,680,480,1); printf("[sys_win.c] Console initialized.\n"); ... }</span></span></code> </pre> <br>  Since I was running Windows on a Mac using Parallels, it was difficult to press "printscreen" while playing the game.  To create screenshots, I set the "*" key from the digital block: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// keys.c if (key == '*') { if (down) //  ! Cmd_ExecuteString("screenshot"); }</span></span></code> </pre> <br>  And finally, I added a lot of comments and diagrams.  Here is the "my" complete source code: <br>  <a href="">archive</a> <br><br><h3>  Memory management </h3><br>  Doom and Quake1 had its own memory manager called ‚ÄúZone Memory Allocation‚Äù: at startup, <code>malloc</code> executed and the memory block was controlled using a list of pointers.  The Memory Zone could be marked for quick cleaning of the desired category of memory.  Zone Memory Allocator ( <code>common.c: Z_Malloc, Z_Free, Z_TagMalloc , Z_FreeTags</code> ) remained in Quake2, but it is rather useless: <br><br><ul><li>  Markings are not used and memory allocation / release is performed on top of <code>malloc</code> and <code>free</code> (I have no idea why id Software decided to entrust this work to C Standard Library). </li><li>  Overflow detector (using the constant <code>Z_MAGIC</code> ) is also never used. </li></ul><br>  It is still very useful to measure memory consumption due to the <code>size</code> attribute in the header inserted before allocating each block of memory: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Z_MAGIC 0x1d1d typedef struct zhead_s { struct zhead_s *prev, *next; short magic; short tag; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    int size; } zhead_t;</span></span></span></span></code> </pre> <br>  The surface caching system has its own memory manager.  The amount of distributed memory depends on the resolution and is determined by a strange formula, which however, very effectively protects against garbage: <br><br><pre> <code class="cpp hljs">  <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>  : ============================== size = SURFCACHE_SIZE_AT_320X240; <span class="hljs-comment"><span class="hljs-comment">//1024*768 pix = vid.width*vid.height; if (pix &gt; 64000) size += (pix-64000)*3;</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/66e/fdb/50e/66efdb50e13617648cff2f3203423bc6.jpg"><br><br>  ‚ÄúHunk allocator‚Äù is used to load resources (images, sounds and textures).  It is pretty good, trying to use <code>virtualAlloc</code> and correlate data with the size of the page (8 KB, despite the fact that 4 KB was used in Win98! What kind of things ?!). <br><br>  And finally, there are also a lot of FIFO stacks <b>(among other things, for storing intervals)</b> , and despite the obviously limited possibilities, they work very well. <br><br><h3>  Memory management: ordering trick </h3><br>  Because Quake2 manages many of the usual pointers, a good trick is used to place the pointer in 32 bits (or placement in 8 KB to minimize PAGE_FAULT ... despite the fact that Windows 98 used 4 KB pages). <br><br>  <u>The layout of the pages (8 KB):</u> <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundUpToPageSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ size = (size + <span class="hljs-number"><span class="hljs-number">8191</span></span>) &amp; ~<span class="hljs-number"><span class="hljs-number">8191</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br><br>  <u>Memory Location (4 B):</u> <br><br><pre> <code class="cpp hljs"> memLoc = (memLoc + <span class="hljs-number"><span class="hljs-number">3</span></span>) &amp; ~<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   4- .</span></span></code> </pre> <br><h3>  Console subsystem </h3><br>  The Quake2 core contains a powerful console system that actively uses pointer lists and linear search. <br><br>  It has three types of objects: <br><br><ul><li>  Commands: give a function pointer for the given string value. </li><li>  Cvar: store a string value for the specified string name. </li><li>  Nickname: provides a replacement for the given string value. </li></ul><br>  In terms of code, each type of object has a list of pointers: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">cmd_function_t</span></span> *cmd_functions <span class="hljs-comment"><span class="hljs-comment">//  ,        : void (*)() . cvar_t *cvar_vars //  ,        . cmdalias_t *cmd_alias //  ,        .</span></span></code> </pre> <br>  When each line is entered into the console, it is scanned, supplemented (using aliases and corresponding cvar), and then divided into tokens stored in two global variables: <code>cmd_argc</code> and <code>cmd_argv</code> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cmd_argc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cmd_argv[MAX_STRING_TOKENS];</code> </pre> <br>  Example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d10/fbc/685/d10fbc685f8ab55bc22eae34a5df82e0.jpg"><br><br>  Each token identified in the buffer is copied <code>memcpy</code> to the location indicated by <code>malloc</code> <code>cmd_argv</code> .  The process is rather inefficient and shows that little attention was paid to this subsystem.  And this, by the way, is fully justified: it is rarely used and has little effect on the game, so optimization was not worth the effort.  The best approach would be to patch the source line in place and write the pointer value for each token: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b3/972/2ac/6b39722ac60a911bba1cb2a62f2d9591.jpg"><br><br>  Since the tokens are in the array of arguments, <code>cmd_argv[0]</code> checked in a very slow and linear way to match all the functions declared in the list of function pointers.  If a match is found, the function pointer is called. <br><br>  If no match is found, the list of alias pointers is linearly checked to determine if the token is a function call.  If the alias replaces a function call, then it is called. <br><br>  And finally, if none of the above work, then Quake2 processes the token as a variable declaration (or as its update, if the variable is already in the list of pointers). <br><br>  There are many linear searches in the list of pointers: the ideal solution would be to use a hash table.  It would allow O (n) complexity instead of O (n¬≤). <br><br>  <u><b>An interesting fact about parsing 1</b> : the</u> ASCII table is cleverly organized: when parsing a string to create tokens, you can skip delimiters and space characters simply by checking if the character i is smaller than the character '' (space). <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;&amp; *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }</code> </pre> <br>  <u><b>An interesting fact about parsing 2</b> : the</u> ASCII table was organized very cleverly: you could convert the character c to an integer as follows: <br><br>  int value = c - '0'; <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charToInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v - <span class="hljs-string"><span class="hljs-string">'0'</span></span> ; }</code> </pre> <br>  <u>Caching cvar values:</u> <br><br>  Since the search for cvar in memory ( <code>Cvar_Get</code> ) in this system has O (n¬≤) complexity (linear search + <code>strcmp</code> for each record), renderers cache the cvar in memory: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  cvar_t *crosshair; //    ,   //    Cvar  . crosshair = Cvar_Get ("crosshair", "0", CVAR_ARCHIVE); //  // ,   . void SCR_DrawCrosshair (void) { if (!crosshair-&gt;value) //  return; }</span></span></code> </pre> <br>  Access to this value can then be obtained for O (1). <br><br><h3>  Protection from villains </h3><br>  To protect against cheating, several mechanisms were inserted: <br><ul><li>  Even though UDP has its own CRC, Quake CRC ( <code>COM_BlockSequenceCRCByte</code> ) is added to each packet to protect against modification. </li><li>  Before the start of the dematch, levels are hashed using MD4.  This hash is sent to the server to make sure that the client does not use modified cards ( <code>Com_BlockChecksumM</code> ). </li><li>  There is even a system that checks the number of teams per second from each player ( <code>SV_ClientThink</code> ), but I do not know exactly how effective it was. </li></ul><br><h3>  Internal assembler </h3><br>  As in every version of Quake, some of the useful functions were optimized using assembly language (however, there are still no traces of the famous ‚Äúquick back square root‚Äù that was present in Quake3). <br><br>  <u>The fast absolute value of a 32-bit floating point number</u> (most compilers today do this automatically): <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_fabs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = * ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * ) &amp;f; tmp &amp;= <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> * ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * ) &amp;tmp; }</code> </pre> <br>  <u>Fast Float to Integer conversion</u> <br><br><pre> <code class="cpp hljs"> __declspec( naked ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_ftol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp; __asm fld dword ptr [esp+<span class="hljs-number"><span class="hljs-number">4</span></span>] __asm fistp tmp __asm mov eax, tmp __asm ret }</code> </pre> <br><h3>  Code statistics </h3><br>  Analysis of the code in Cloc showed that there are a total of 138,240 lines in the code.  As usual, this number does NOT give an idea of ‚Äã‚Äãthe effort invested, because much has been abandoned in the iterative cycle of engine versions, but, as it seems to me, this is a good indicator of the total engine complexity. <br><br><pre> <code class="cpp hljs"> $ cloc quake2<span class="hljs-number"><span class="hljs-number">-3.21</span></span>/ <span class="hljs-number"><span class="hljs-number">338</span></span> text files. <span class="hljs-number"><span class="hljs-number">319</span></span> unique files. <span class="hljs-number"><span class="hljs-number">34</span></span> files ignored. http:<span class="hljs-comment"><span class="hljs-comment">//cloc.sourceforge.net v 1.53 T=3.0 s (96.0 files/s, 64515.7 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- C 181 24072 19652 107757 C/C++ Header 72 2493 2521 14825 Assembly 22 2235 2170 8331 Objective C 6 1029 606 4290 make 2 436 67 1739 HTML 1 3 0 1240 Bourne Shell 2 17 6 54 Teamcenter def 2 0 0 4 ------------------------------------------------------------------------------- SUM: 288 30285 25022 138240 -------------------------------------------------------------------------------</span></span></code> </pre> <br>  <u><b>Note: the</b></u> entire assembly code is designed for a manually created software renderer. <br><br><h3>  Tools recommended for working with Quake2 hacking </h3><br><ul><li>  Visual Studio Express 2008. </li><li>  Free Quake2 demo from website id. </li><li>  <a href="">Pak explorer</a> written by me. </li><li>  <a href="">Wally</a> : WAL image format viewer. </li><li>  The famous research tool pak ( <a href="">PakExpl</a> ) </li><li>  <a href="http://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml">An article about the BSP format</a> ( <a href="">mirror</a> ) from the FlipCode website. </li><li>  Profilers C: VTune (intel), CodeAnalysis (AMD), Visual Studio Team Profiler (the best, in my opinion). </li><li>  Large 24/30 inch screen. </li><li>  Keyboard IBM Model M. </li></ul><br>  Quake2 consists of one core and two modules loaded during execution: Game and Renderer.  It is very interesting that thanks to polymorphism, anything can be connected to the kernel. <br><br>  Before continuing to read, I recommend to make sure that you understand the principle of the virtual memory well with the help of this <a href="http://www.ualberta.ca/CNS/RESEARCH/LinuxClusters/mem.html">wonderful article</a> ( <a href="http://www.ualberta.ca/CNS/RESEARCH/LinuxClusters/mem.html">mirror</a> ). <br><br><h3>  Polymorphism in C with dynamic connectivity </h3><br>  Dynamic connectivity offers many benefits: <br><br><ul><li>  Renderer: <br><ul><li>  Pure Quake2 kernel code, reduced code entropy, no crazy <code>#ifdef</code> everywhere. </li><li>  The release of the game with several renderers (software, openGL). </li><li>  Renderer can be changed when playing the game. </li><li>  Ability to create a new renderer for equipment created after the release of the game (Glide, Verity). </li></ul></li><li>  Modding games: <br><ul><li>  More options for authors of mods, the game can be completely changed through game.dll. </li><li>  Full game speed in mods, no need to rely on QuakeC and Quake Virtual Machine. </li><li>  No need to learn QuakeC, DLLs were written in C. </li></ul></li></ul><br>  But Quake2 was written in C, which is not an object-oriented programming language, so the question was: "How to implement polymorphism in a language that is not OO?" <br><br>  The technique of simulating OO is similar to the method used in Java and C ++: the use of structures containing function pointers. <br><br>  Therefore, four structures were used to exchange function pointers: <code>refimport_t</code> and <code>refexport_t</code> acted as a container for exchanging function pointers when loading the renderer module.  <code>game_import_t</code> and <code>game_export_t</code> used when loading the game module. <br><br><h3>  A small illustration is better than a long speech. </h3><br>  Step 1: Initially: <br><br><ul><li>  <code>quake2.exe</code> contains the <code>ref_OpenGL_t</code> structure with function pointers to <code>NULL</code> (gray). </li><li>  The DLL module ( <code>ref_opengl.dll</code> ) also contains a <code>kernel_fct_t</code> structure with function pointers to <code>NULL</code> (gray). </li></ul><br>  The task of the process is to transfer the addresses of the functions so that each part can call the others. <br><br><img src="http://fd.fabiensanglard.net/quake2/poly_stage1.png"><br><br>  Step 2: The kernel that calls the function fills the structure containing the pointers to its own functions and sends these DLL values. <br><br><img src="http://fd.fabiensanglard.net/quake2/poly_stage2.png"><br><br>  Step 3: The host DLL copies the kernel function pointers and returns a structure containing its own function addresses. <br><br><img src="http://fd.fabiensanglard.net/quake2/poly_stage3.png"><br><br>  The process with real names is described in detail in the next two sections. <br><br><h3>  Renderer Library </h3><br>  The method that gets the renderer module is called <code>VID_LoadRefresh</code> .  It is called every frame so that Quake can switch between renderers (but due to the pre-processing renderer, you need to restart the level). <br><br>  This is what happens on the Quake2 core side: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">refexport_t</span></span> re; <span class="hljs-function"><span class="hljs-function">qboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VID_LoadRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">refimport_t</span></span> ri; GetRefAPI_t GetRefAPI; ri.Sys_Error = VID_Error; ri.FS_LoadFile = FS_LoadFile; ri.FS_FreeFile = FS_FreeFile; ri.FS_Gamedir = FS_Gamedir; ri.Cvar_Get = Cvar_Get; ri.Cvar_Set = Cvar_Set; ri.Vid_GetModeInfo = VID_GetModeInfo; ri.Vid_MenuInit = VID_MenuInit; ri.Vid_NewWindow = VID_NewWindow; GetRefAPI = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) GetProcAddress( reflib_library, <span class="hljs-string"><span class="hljs-string">"GetRefAPI"</span></span> ); re = GetRefAPI( ri ); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above code, the Quake2 kernel retrieves a pointer to the function of the method </font></font><code>GetRefAPI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the renderer DLL using </font></font><code>GetProcAddress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(built-in win32 method). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is what happens in the </font></font><code>GetRefAPI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderer DLL:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">refexport_t</span></span> GetRefAPI (<span class="hljs-keyword"><span class="hljs-keyword">refimport_t</span></span> rimp ) { <span class="hljs-keyword"><span class="hljs-keyword">refexport_t</span></span> re; ri = rimp; re.api_version = API_VERSION; re.BeginRegistration = R_BeginRegistration; re.RegisterModel = R_RegisterModel; re.RegisterSkin = R_RegisterSkin; re.EndRegistration = R_EndRegistration; re.RenderFrame = R_RenderFrame; re.DrawPic = Draw_Pic; re.DrawChar = Draw_Char; re.Init = R_Init; re.Shutdown = R_Shutdown; re.BeginFrame = R_BeginFrame; re.EndFrame = GLimp_EndFrame; re.AppActivate = GLimp_AppActivate; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end, a two-way exchange of data between the kernel and the DLL is established. </font><font style="vertical-align: inherit;">It is polymorphic, because the renderer DLL returns its own function addresses inside the structure and the Quake2 kernel doesn‚Äôt see the difference, it always calls the same function pointer.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game library </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The exact same process is done with the kernel-side game library: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">game_export_t</span></span> *ge; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SV_InitGameProgs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">game_import_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.linkentity = SV_LinkEdict; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.unlinkentity = SV_UnlinkEdict; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.BoxEdicts = SV_AreaEdicts; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.trace = SV_Trace; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.pointcontents = SV_PointContents; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.setmodel = PF_setmodel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.inPVS = PF_inPVS; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.inPHS = PF_inPHS; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>.Pmove = Pmove; <span class="hljs-comment"><span class="hljs-comment">//   30   ge = (game_export_t *)Sys_GetGameAPI (&amp;import); ge-&gt;Init (); } void *Sys_GetGameAPI (void *parms) { void *(*GetGameAPI) (void *); //[...] GetGameAPI = (void *)GetProcAddress (game_library, "GetGameAPI"); if (!GetGameAPI) { Sys_UnloadGame (); return NULL; } return GetGameAPI (parms); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is what happens on the DLL side of the game: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">game_import_t</span></span> gi; <span class="hljs-keyword"><span class="hljs-keyword">game_export_t</span></span> *GetGameAPI (<span class="hljs-keyword"><span class="hljs-keyword">game_import_t</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>) { gi = *<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>; globals.apiversion = GAME_API_VERSION; globals.Init = InitGame; globals.Shutdown = ShutdownGame; globals.SpawnEntities = SpawnEntities; globals.WriteGame = WriteGame; globals.ReadGame = ReadGame; globals.WriteLevel = WriteLevel; globals.ReadLevel = ReadLevel; globals.ClientThink = ClientThink; globals.ClientConnect = ClientConnect; globals.ClientDisconnect = ClientDisconnect; globals.ClientBegin = ClientBegin; globals.RunFrame = G_RunFrame; globals.ServerCommand = ServerCommand; globals.edict_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">edict_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;globals; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using function pointers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After passing the method pointers, polymorphism is enabled. </font><font style="vertical-align: inherit;">Here in the code, the kernel "jumps" to different modules: The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderer "jumps" to </font></font><code>SCR_UpdateScreen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   quake.exe,  ,  quake2.exe  ,   . SCR_UpdateScreen() { // re -  struct refexport_t, BeginFrame   BeginFrame  DLL. re.BeginFrame( separation[i] ); //      DLL SCR_CalcVrect() SCR_TileClear() V_RenderView() SCR_DrawStats SCR_DrawNet SCR_CheckDrawCenterString SCR_DrawPause SCR_DrawConsole M_Draw SCR_DrawLoading re.EndFrame(); //    quake.exe. }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The game "jumps" to </font></font><code>SV_RunGameFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SV_RunGameFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sv.framenum++; sv.time = sv.framenum*<span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      if (!sv_paused-&gt;value || maxclients-&gt;value &gt; 1) ge-&gt;RunFrame (); .... } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Software renderer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Quake2 software renderer is the largest, most complex, and therefore the most interesting module for research. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/softRendererStruct.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are no hidden mechanisms here, starting with the disk and ending with pixels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All code is neatly written and optimized by hand. </font><font style="vertical-align: inherit;">He is the last of its kind and marked the end of an era. </font><font style="vertical-align: inherit;">Later, the industry completely switched exclusively to hardware accelerated rendering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fundamental difference between software rendering and rendering OpenGL - using the 256-color palette system instead of the usual 24-bit True Color RGB system today: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/renderer.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we compare the hardware accelerated renderer and the software renderer, we notice two of the most obvious differences:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lack of color lighting </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No bilinear filtering </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But with the exception of this, the engine managed to perform amazing work using the very clever use of the palette, which I will discuss later: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quick selection of color gradients (64 values). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fullscreen mixing of post-effect colors. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel translucency. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the Quake2 palette is loaded from the PAK archive file </font></font><code>pics/colormap.pcx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="http://fabiensanglard.net/quake2/quake2_palette.jpg"><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the black value is 0, the white is 15, the green is 208, the red is 240 (in the lower left corner), the transparent is 255. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, the 256 colors are rearranged according to </font></font><code>pics/colormap.pcx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/COLORMAP.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This 256x320 scheme is used as a lookup table, and it is extremely clever, because it provides many interesting features:</font></font><br><br><ul><li> 64     :     256  ¬´¬ª .  63           ,   255 .          : <br><br><ul><li>        [0,255] (    ). </li><li>   x*256,  x    [0,63]        (     ). </li></ul><br>    64  256 .       256   .  Awesome </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rest of the image is created from 16x16 squares, which allows you to use pixel blending based on a palette. </font><font style="vertical-align: inherit;">It is clearly visible that all the squares are created from the original color, the final color and intermediate colors. </font><font style="vertical-align: inherit;">This is how water translucency is realized in the game. </font><font style="vertical-align: inherit;">For example, black and white are mixed in the upper left square.</font></font></li></ul><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting fact:</font></font></u></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Quake2 software renderer was originally based on MMX technology and should have been based on RGB, not on the palette, as John Carmack said after the release of Quake1 in this video (moment at 10 minute 17 second):</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LXw6BkZ-gdY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MMX is a SIMD technology that allows you to work with all three RGB channels at the cost of just one channel, thus providing mixing with acceptable CPU consumption. </font><font style="vertical-align: inherit;">I assume that it was abandoned for the following reasons:</font></font><br><br><ul><li>  Pentium   MMX     1997 ,          . </li><li>   RGB (16   32   )    (8   )      ,       . </li></ul><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having defined the main constraint (palette), you can go to the general architecture of the renderer. </font><font style="vertical-align: inherit;">His philosophy used Pentium's strengths (floating-point calculations) to reduce the effect of weaknesses: bus speed, which influenced the recording of pixels in memory. </font><font style="vertical-align: inherit;">Most of the rendering path is focused on achieving </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redrawing. </font><font style="vertical-align: inherit;">In essence, the software rendering path is similar to the Quake 1 software rendering method. It used BSP and PVS (a set of potentially visible polygons) to bypass the map to get a set of polygons that need to be rendered. </font><font style="vertical-align: inherit;">Each frame renders three different elements:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Map: using the coherent line-by-line image construction algorithm based on BSP (more about it later). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entities: either as ‚Äúsprites‚Äù (windows), or as ‚Äúobjects‚Äù (players, enemies) using a simple line-by-line image creation algorithm. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Particles </font></font></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you are not familiar with these ‚Äúold‚Äù algorithms, I highly recommend reading chapters 3.6 and 15.6 of </font></font><a href="http://books.google.com/books%3Fid%3D-4ngT05gmAQC%26printsec%3Dfrontcover%26source%3Dgbs_ge_summary_r%26cad%3D0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer graphics: principles and practice of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> James D. Foley. </font><font style="vertical-align: inherit;">You can also find a lot of information in chapters 59-70 of </font><font style="vertical-align: inherit;">Michael Abrash's </font></font><a href="http://www.gamedev.net/page/resources/_/reference/programming/140/283/graphics-programming-black-book-r1698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics programming black book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the high level pseudocode:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering maps </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passing through a pre-processed BSP tree to determine the cluster in which we are. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Query the PVS database about this particular cluster: getting and unpacking the PVS. </font></font></li><li>     PVS:     ,   ,   . </li><li>    BSP.    ,      -  .  ,       . </li><li>            : <br><ul><li>   BSP,   : <br><ul><li>            :    . </li><li>     (=+ )    . </li><li>       (   ). </li></ul></li><li>                  .        .        Z-. </li></ul></li></ul></li><li>  ,  Z-     . </li><li>               . </li><li>  . </li><li>   (        ). </li></ol><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screen visualization:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> palette indexes are written to the voice-over buffer. </font><font style="vertical-align: inherit;">Depending on the mode (fullscreen / windowed), DirectDraw or GDI is used. </font><font style="vertical-align: inherit;">After the frame-by-frame buffer is completed, it is transferred to the video card's on-screen buffer (GDI =&gt;</font></font><code>rw_dib.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectDraw =&gt;</font></font><code>rw_ddraw.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) using either</font></font><code>BitBlt</code> <code>WinGDI.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or</font></font><code>BltFast</code> <code>ddraw.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DirectDraw or GDI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Those problems that programmers had to meet in 1997 were simply depressing: John Carmack left a funny comment in the source code: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      DIB</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If Quake2 was working in full screen mode with DirectDraw, it had to draw the offscreen buffer from top to bottom: that was how it was displayed on the screen. But when it was executed in windowed mode with GDI, it was necessary to draw the voice-over buffer in the DIB buffer ... reflected vertically, because most of the drivers for video card manufacturers transferred the DIB image from RAM to the video memory in reflected mode (one wonders if I really in the acronym GDI stands for "Independent"). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the transition to the frame-by-frame buffer was supposed to become abstract. We needed a structure and values ‚Äã‚Äãthat were initialized differently to abstract from these differences. This is a primitive way to implement polymorphism in C.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pixel_t</span></span> *buffer; <span class="hljs-comment"><span class="hljs-comment">//    pixel_t *colormap; //   :  256 * VID_GRADES pixel_t *alphamap; //  :   256 * 256 int rowbytes; //    ,     //      DIB int width; int height; } viddef_t; viddef_t vid ;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the method required to render the frame buffer, it was </font></font><code>vid.buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initialized as the first pixel:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First line for DirectDraw </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Last line for WinGDI / DBI </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To go up or down, </font></font><code>vid.rowbytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initialized as </font></font><code>vid.width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or as </font></font><code>-vid.width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/buffer_GDI.jpeg"><br><br><img src="http://fd.fabiensanglard.net/quake2/buffer_directdraw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now for the transition it does not matter how the drawing is performed: normal or with vertical reflection:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//     byte* pixel = vid.buffer + vid.rowbytes * 0; //     pixel = vid.buffer + vid.rowbytes * (vid.height-1); //    i (    0) pixel = vid.buffer + vid.rowbytes * i; //       memset(vid.buffer,0,vid.height*vid.height) ; // &lt;--      DirectDraw //      !</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This trick allows the rendering pipeline to not worry about how the transfer is performed at the lower level, and I think this is quite remarkable. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preprocessing card </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Before digging deeper into the code, you need to understand two important databases generated by preprocessing the map: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Binary partitioning of space (BSP) / set of potentially visible polygons (PVS). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radiation-based lighting map texture. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cutting BSP, generating PVS </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I recommend to study deeper the binary partitioning of space: </font></font><br><br><ul><li> <a href="http://en.wikipedia.org/wiki/Binary_space_partitioning"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Russian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article </font></font><a href="http://downloads.gamedev.net/pdf/gpbb/gpbb59.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Idea of ‚Äã‚ÄãBSP Trees by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Michael Abrash.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article </font></font><a href="http://downloads.gamedev.net/pdf/gpbb/gpbb60.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiling BSP Trees by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Michael Abrash.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An ASCII-style article, </font></font><a href="http://www.gamers.org/dhs/helpdocs/bsp_faq.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an old bible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in Quake1, Quake2 cards undergo serious preliminary processing: their volume is recursively cut as in the figure below: </font></font><br><br><img src="http://fabiensanglard.net/quakeSource/bsp.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, the card is completely cut into convex 3D spaces (called clusters). </font><font style="vertical-align: inherit;">As in Doom with Quake1, they can be used to sort all polygons from front to back and from behind to the front. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A great addition is PVS, a set of bit vectors (one per cluster). </font><font style="vertical-align: inherit;">Treat it as a database to which you can query and retrieve clusters that are potentially visible from any cluster. </font><font style="vertical-align: inherit;">This database is huge (5 MB), but effectively compressed to several hundred kilobytes and fits well into RAM. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compression is used for PVS compression, passing only 0x00 values, this process is explained below.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radiation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in Quake1, the effect of level lighting is calculated in advance and stored in textures called light maps. </font><font style="vertical-align: inherit;">However, unlike Quake1, Quake2 uses radiation and color illumination in preliminary calculations. </font><font style="vertical-align: inherit;">The lighting maps are then stored in the archive </font></font><code>PAK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and used in the process of playing the game: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A couple of words from one of the creators: Michael Abrash in Black Book of Programming (chapter ‚ÄúQuake: a post-mortem and a glimpse into the future‚Äù):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The most interesting graphics changes consisted in preliminary calculations, where John added support for the emitted light ... </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processing Quake 2 levels took up to an hour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(However, it is worth noting that it included the creation of BSP, the calculation of PVS and the emitted light, which I will consider later.)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to know about the radiated light, then read this stunningly well-illustrated </font></font><a href="http://freespace.virgin.net/hugo.elias/radiosity/radiosity.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): this is just a masterpiece. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the first level with a superimposed radiation texture: unfortunately, the stunning RGB colors needed to be resampled for a software renderer in grayscale (more on this later). </font></font><br><br><img src="http://fabiensanglard.net/quake2/3colors_01.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The low resolution of the irradiance map is striking here, but since it passes bilinear filtering (yes, even in the software renderer), the final result combined with the color texture is very good. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting fact:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lighting maps can be any size from 2x2 to 17x17 (despite the stated maximum size of 16 in the </font><font style="vertical-align: inherit;">flipcode </font></font><a href="http://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )) and do not have to be square. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code architecture </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most software renderer code is in the method </font></font><code>R_RenderFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is a brief description, a more detailed analysis, read in my </font></font><a href="http://fabiensanglard.net/quake2/softwareRenderer.notes.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preliminary notes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><ul><li> <code>R_SetupFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: gets current viewpoint by BSP bypass (call </font></font><code>Mod_PointInLeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), saves the viewpoint's clusterID to </font></font><code>r_viewcluster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>R_MarkLeaves</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: for the current review cluster ( </font></font><code>r_viewcluster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) retrieves and unzips the PVS. </font><font style="vertical-align: inherit;">Uses PVS to mark visible faces.</font></font></li><li> <code>R_PushDlights</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: uses BSP again to traverse faces from front to back. </font><font style="vertical-align: inherit;">If the face is marked as visible, it checks if the light affects it.</font></font></li><li> <code>R_EdgeDrawing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : level visualization. </font></font><br><ul><li> <code>R_RenderWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : BSP bypass front to back </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projecting all visible polygons into screen space: building a global edge table. </font></font></li><li>         (   ). </li></ul></li><li> <code>R_ScanEdges</code> :     ,  .   : <br><ul><li> <code>R_InsertNewEdges</code> :         ,      . </li><li> <code>(*pdrawfunc)()</code> :  ,       .        .    . </li><li> <code>D_DrawSurfaces</code> :     ,          . </li></ul></li></ul></li><li> <code>R_DrawEntitiesOnList</code> :  ,   BModel (BModel ‚Äî   ).      (, , )... </li><li> <code>R_DrawAlphaSurfaces</code> :        </li><li> <code>R_CalcPalette</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : calculation of post-effects, for example, mixing colors (when receiving damage, collecting items, etc.) </font></font></li></ul><br><pre> <code class="cpp hljs"> R_RenderFrame { R_SetupFrame <span class="hljs-comment"><span class="hljs-comment">//    pdrawfunc    ,    : GDI  DirectDraw { Mod_PointInLeaf //  ,       ( BSP-)      r_viewcluster } R_MarkLeaves //        (r_viewcluster) //  PVS R_PushDlights //  ,    ,   dlight_t*   r_newrefdef.dlights. //            R_EdgeDrawing //   { R_BeginEdgeFrame //    pdrawfunc,      R_RenderWorld //     //           (surf_max -   ) R_DrawBEntitiesOnList//   ,    . R_ScanEdges //         :      //   Z- (  ) { for (iv=r_refdef.vrect.y ; iv&lt;bottom ; iv++) { R_InsertNewEdges //  AET  GET (*pdrawfunc)(); //   D_DrawSurfaces //     } //    R_InsertNewEdges //  AET  GET (*pdrawfunc)(); //   D_DrawSurfaces //     } } R_DrawEntitiesOnList //  ,   .... //  Z-    . R_DrawParticles // ! R_DrawAlphaSurfaces //          &lt;code&gt;pics/colormap.pcx&lt;/code&gt;. R_SetLightLevel //       ( !) R_CalcPalette //   (     ),     }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_SetupFrame: BSP Management </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traversing the binary tree of space is performed throughout the code. </font><font style="vertical-align: inherit;">This is a powerful mechanism with stable speed, allowing you to sort polygons from front to back or from behind. </font><font style="vertical-align: inherit;">To understand it, you need to understand the structure </font></font><code>cplane_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cplane_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> normal; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist; } <span class="hljs-keyword"><span class="hljs-keyword">cplane_t</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To calculate the distance or point from the section plane in a node, simply insert its coordinates into the equation of the plane: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = DotProduct (p,plane-&gt;normal) - plane-&gt;dist;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to the sign </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we find out whether we are in front of or behind the plane, and we can perform the sorting. </font><font style="vertical-align: inherit;">This process has been used in engines starting with Doom and ending with Quake3.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_MarkLeaves: group unzipping of PVS </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The way I understood the decompression of PVS in my </font></font><a href="https://habrahabr.ru/post/324804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analysis of the Quake 1 source code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was completely wrong: it is not the distance between bits 1 that is encoded, but only the number of 0x00 bytes to be written. </font><font style="vertical-align: inherit;">In PVS, only group compression 0x00 is performed: when reading a compressed stream:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If a non-zero byte is read from compressed PVS, it is written to the unzipped version. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If byte 0x00 is read from compressed PVS, then the next byte shows how many bytes to skip. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first case, nothing is compressed. </font><font style="vertical-align: inherit;">Group compression is performed only in the second case:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">byte *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mod_DecompressVis</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte *in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">model_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *model)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte decompressed[MAX_MAP_LEAFS/<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  = 1 ,   65536 / 8 = 8 192  //      PVS. int c; byte *out; int row; row = (model-&gt;vis-&gt;numclusters+7)&gt;&gt;3; out = decompressed; do { if (*in) //   ,              . { *out++ = *in++; continue; } c = in[1]; //   "",    :    (in[1])   in += 2; //      PVS. while (c) { *out++ = 0; c--; } } while (out - decompressed &lt; row); return decompressed; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can skip up to 255 bytes (255 * 8 leaves), if necessary, after them you need to again add a zero with the number that you want to skip next 255 bytes. </font><font style="vertical-align: inherit;">That is, the pass 511 bytes (511 * 8 leaves) takes 4 bytes: 0 - 255 - 0 - 255</font></font><br><br>  Example: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    80 ,   10 : =1, =0   PVS 0000 0000 0000 0000 0000 0000 0000 0000 0011 1100 1011 1111 0000 0000 0000 0000 0000 0000 0000 0000   PVS 0x00 0x00 0x00 0x00 0x39 0xBF 0x00 0x00 0x00 0x00 // !! !!   PVS 0000 0000 0000 1000 0011 1100 1011 1111 0000 0000 0000 1000   PVS 0x00 0x04 0x39 0xBF 0x00 0x04</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After unpacking the PVS of the current cluster, each individual face belonging to the cluster that is considered visible in PVS is also marked as visible: </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How can I check the visibility of a cluster with a given identifier </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using unzipped PVS? </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit AND between byte i / 8 PVS and 1 &lt;&lt; (i% 8)</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isVisible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte* pvs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// i&gt;&gt;3 = i/8 // i&amp;7 = i%8 return pvs[i&gt;&gt;3] &amp; (1&lt;&lt;(i&amp;7)) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just like in Quake1, there is a good trick used to mark the polygon as visible: instead of using flags and resetting each one at the beginning of each frame, it applies </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At the beginning of each frame, the frame counter is </font></font><code>r_visframecount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incremented by one in </font></font><code>R_MarkLeaves</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">After unpacking the PVS, all zones are marked as visible by assigning a </font></font><code>visframe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current value to the </font><font style="vertical-align: inherit;">field </font></font><code>r_visframecount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Later in the code, the visibility of the node / cluster is always checked in the following way:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;visframe == r_visframecount) { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_PushDlights: dynamic lighting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each identifier lightID of the active dynamic light source, a recursive BSP traversal is performed starting from the position of the light source. </font><font style="vertical-align: inherit;">The distance between the source and the cluster is calculated, and if the illumination intensity is greater than the distance from the cluster, then all surfaces in the cluster are marked as affected by this source identifier. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> surfaces are marked with two fields:</font></font><br><br><ul><li> <code>dlightframe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is the flag </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in the same way as in the case of marking the visibility of clusters (instead of resetting all the flags in each frame, the global variable increases </font></font><code>r_dlightframecount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For the light to affect, it </font></font><code>r_dlightframecount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must be equal to </font></font><code>surf.dlightframe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>dlightbits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a bit vector </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to store indices of various arrays of light sources acting on a given face.</font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_EdgeDrawing: level visualization </font></font></h3><br> <code>R_EdgeDrawing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a monster software renderer, the most difficult to understand. </font><font style="vertical-align: inherit;">To deal with it, you need to look at the basic data structure: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stack </font></font><code>surf_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(acting as a proxy </font></font><code>m_surface_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is placed on the CPU stack.</font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surf_stack.png"><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   surf_t *surfaces ; //    surf_t *surface_p ; //    surf_t *surf_max ; //     //   bsp-   " ",    //  ,     // surfaces[1]  ,       Note:   surfaces -    Note:    surfaces -   </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This stack is filled when traversing a BSP from front to back. Each visible polygon is inserted into the stack as a proxy surface. Later, when traversing the table of active edges to generate a screen row, it allows you to very quickly see which polygon is in front of everyone else by comparing the address in memory (the lower the stack, the closer to the viewpoint). This is how ‚Äúconnectivity‚Äù is realized for the algorithm for converting line-by-line image construction. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each stack item also has a list of pointers (called a chain of textures) pointing to items in the interval buffer stack (discussed below). Intervals are stored in a buffer and drawn from a chain of textures for deeply grouping intervals and maximizing the CPU pre-caching buffer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stack is initialized at the very beginning </font></font><code>R_EdgeDrawing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R_EdgeDrawing</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  : 64  surf_t lsurfs[NUMSTACKSURFACES +((CACHE_SIZE - 1) / sizeof(surf_t)) + 1]; surfaces = (surf_t *) (((long)&amp;lsurfs[0] + CACHE_SIZE - 1) &amp; ~(CACHE_SIZE - 1)); surf_max = &amp;surfaces[r_cnumsurfs]; //  0     ;  ,    0 //   ,  ,       surfaces--; R_SurfacePatch (); R_BeginEdgeFrame (); // surface_p = &amp;surfaces[2]; //  -   1, //  0 -   R_RenderWorld { R_RenderFace } R_DrawBEntitiesOnList R_ScanEdges //  Z- (  ) { for (iv=r_refdef.vrect.y ; iv&lt;bottom ; iv++) { R_InsertNewEdges //  AET  GET (*pdrawfunc)(); //   D_DrawSurfaces //     } //    R_InsertNewEdges //  AET  GET (*pdrawfunc)(); //   D_DrawSurfaces //     } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here are the details: </font></font><br><ul><li> <code>R_BeginEdgeFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : clears the global edge table from the last frame. </font></font></li><li> <code>R_RenderWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : BSP bypass (note that it does NOT render anything on the screen): </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each surface, which is considered visible, is added to the stack with a proxy </font></font><code>surf_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projecting the vertices of all polygons to the screen space and filling the global edge table. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also generating a 1 / Z value for all vertices so that the Z-buffer can be generated at intervals. </font></font></li></ul><br></li><li> <code>R_DrawBEntitiesOnList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : I have no idea what this fragment does. </font></font></li><li> <code>R_ScanEdges</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : combining all the information received at the moment to render the level: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialization of the active edge table. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialization of the interval buffer (also a stack): </font></font><br><img src="http://fd.fabiensanglard.net/quake2/span_stack.png"><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    espan_t *span_p; //      espan_t *max_span_p; // . span_p  ,   // :   (basespans)     void R_ScanEdges (void) { int iv, bottom; byte basespans[MAXSPANS*sizeof(espan_t)+CACHE_SIZE]; ... }</span></span></code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Launching the line-by-line image algorithm from top to bottom on the screen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For each line: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Updating the active edge table from the global edge table. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the table of active edges for the whole row: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The definition of the visible polygon using the address in the stack surfaces. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfer interval to interval buffer. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the interval buffer is full: drawing all intervals and resetting the interval stack. </font></font></li></ul></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check remaining intervals in the buffer. </font><font style="vertical-align: inherit;">If there is something left in it: drawing all the intervals and resetting the stack of intervals.</font></font></li></ul></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_EdgeDrawing video </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the video below, the engine works with a resolution of 1024x768. </font><font style="vertical-align: inherit;">It is also slowed down using a special cvar </font></font><code>sw_drawflat 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allowed rendering polygons without textures, but in different colors:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4o5GMdqh39U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this video you can see a lot of interesting things: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The screen is generated from top to bottom; this is a typical algorithm for line-by-line imaging. </font></font></li><li>      ,  .        Pentium:    textureId   ,  ¬´ ¬ª.    .   ,       . </li><li>         ,          . </li><li>    ,    :         ,       . </li><li>    40% ,    10%.   ,     ,         . </li><li> OMG, <i> </i>     . </li></ol><br><h3>   :   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, beautiful 24-bit RGB lighting maps need to be resampled to 6-bit grayscale (by selecting the brightest channel from R, G, and B) to meet the palette restrictions: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is stored in the archive </font></font><code>PAK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(24 bits): </font></font><br><br><img src="http://fabiensanglard.net/quake2/3colors_01.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After downloading from disk and resampling to 6-bit: </font></font><br><br><img src="http://fabiensanglard.net/quake2/3colors_01.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then all together: the texture of the face gives the color in the range [0,255]. This value indexes the color in the palette from </font></font><code>pics/colormap.pcx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/soft_rend_1_text.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lighting maps are filtered: as a result, we get a value in the range [0.63]. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/soft_rend_0_lightmap.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now using the top of the </font></font><code>pics/colormap.pcx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slider can select the desired position of the palette. To get the final result, it uses the input value of the texture as the X coordinate and the illumination * 63 as the Y coordinate: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/COLORMAP_upper.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And voila:</font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/soft_rend_2_surface.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Personally, I think it's amazing: imitation of 64 gradients of 256 colors ... only 256 colors! </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface subsystem </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the previous screenshots it is obvious that the generation of surfaces is the most demanding of the CPU part of Quake2 (this is confirmed by the results of the profiler below). </font><font style="vertical-align: inherit;">Acceptable with respect to speed and memory consumption, the generation of surfaces provides two mechanisms:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MIP texturing (mipmapping) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caching </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface subsystem: MIP texturing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a polygon is projected into the screen space, 1 / Z of its distance is generated. The nearest vertex is used to determine which level of MIP textures to use. Here is an example of the lighting map and how it is filtered according to the level of the MIP textures: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/lightmap.jpg"><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/mipmap.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a mini-project I worked on to test the quality of Quilke2 bilinear filtering on random images: an </font></font><a href="http://bilinearfiltering.zip/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below are the results of a test performed for a 13x15 texel lighting map: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/q2.test.surface.mipmap3.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 3 of MIP textures: the block is 2x2 texels. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/q2.test.surface.mipmap2.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 2 MIP-textures: the block is 4x4 texel. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/q2.test.surface.mipmap1.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 1 MIP-textures: the block is 8x8 texels. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/q2.test.surface.mipmap0.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 0 MIP textures: the block is 16x16 texels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key to understanding filtering is that everything is based on the size of polygons in the space of the world (width and height are called </font></font><code>extent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Quake2 preprocessor ensures that the size of the polygon (X or Y) is less than or equal to 256, and is also a multiple of 16. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From the size of the polygon in the space of the world, we can derive: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size of lightmap (in texels): LmpDim = PolyDim / 16 + 1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface size (in blocks): SurDim = LmpDim -1 = PolyDim / 16 </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the figure below, the dimensions of the polygon (3.4), the lighting maps are (4.5) texels, and the degenerate surface </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has the size (3.4) of the block. Levels of MIP-textures determine the size of the block in texels, and hence the total size of the surface in texels. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surface_gen.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this is done in </font></font><code>R_DrawSurface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The level of MIP-textures is selected using an array of function pointers ( </font></font><code>surfmiptable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which selects the desired rasterization function:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*surfmiptable[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { R_DrawSurfaceBlock8_mip0, R_DrawSurfaceBlock8_mip1, R_DrawSurfaceBlock8_mip2, R_DrawSurfaceBlock8_mip3 }; R_DrawSurface { pblockdrawer = surfmiptable[r_drawsurf.surfmip]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (u=<span class="hljs-number"><span class="hljs-number">0</span></span> ; u&lt;r_numhblocks; u++) (*pblockdrawer)(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the modified engine below you can see three levels of MIP-textures: 0 - gray, 1 - yellow and 2 - red: </font></font><br><br><img src="http://fabiensanglard.net/quake2/soft_renderer_mipmapping.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtering is performed by the block when generating a block [i] [j] surface, the filter uses the values ‚Äã‚Äãof the light map: lightmap [i] [ j], lightmap [i + 1] [j], lightmap [i] [j + 1] and lightmap [i + 1] [j + 1]: in essence, using four texels directly in the coordinates and three below and to the right . </font><font style="vertical-align: inherit;">Notice that this is not done by weight interpolation, but rather linear interpolation, first vertically and then horizontally on the generated values. </font><font style="vertical-align: inherit;">In short, it works exactly the same as in the </font></font><a href="http://en.wikipedia.org/wiki/Bilinear_filtering"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on bilinear filtering. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now all together:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/lightmap_inverted.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Original lighting map, 13x15 texels.</font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/q2.test.surface.mipmap0_inverted.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filtering, level 0 of MIP-textures (16x16 blocks) = 192x224 texel. </font></font><br><br>  Result: <br><br><img src="http://fd.fabiensanglard.net/quake2/surfaces/quake00_outligned.jpg"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surface Subsystem: Caching </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even despite the fact that the engine is actively used to manage memory </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it still uses its own memory manager for caching surfaces. </font><font style="vertical-align: inherit;">The memory block is initialized immediately after the rendering resolution is known:</font></font><br><br><pre> <code class="cpp hljs"> size = SURFCACHE_SIZE_AT_320X240; pix = vid.width*vid.height; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pix &gt; <span class="hljs-number"><span class="hljs-number">64000</span></span>) size += (pix<span class="hljs-number"><span class="hljs-number">-64000</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span>; size = (size + <span class="hljs-number"><span class="hljs-number">8191</span></span>) &amp; ~<span class="hljs-number"><span class="hljs-number">8191</span></span>; sc_base = (<span class="hljs-keyword"><span class="hljs-keyword">surfcache_t</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size); sc_rover = sc_base;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rover </font></font><code>sc_rover</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the very beginning is located in the block to keep track of what was occupied. </font><font style="vertical-align: inherit;">When the rover reaches the end of memory, it collapses, in effect, replacing old surfaces. </font><font style="vertical-align: inherit;">The amount of reserved memory can be seen on the graph: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/Surface%20Cache.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is how a new fragment of memory is allocated from the block:</font></font><br><br><pre> <code class="cpp hljs"> memLoc = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&amp;((<span class="hljs-keyword"><span class="hljs-keyword">surfcache_t</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;data[size]; <span class="hljs-comment"><span class="hljs-comment">//   +       . memLoc = (memLoc + 3) &amp; ~3; // FCS:   ,  4 sc_rover = (surfcache_t *)( (byte *)new + size);</span></span></code> </pre> <br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: a</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trick with a quick cache assignment (can go to the memory system) </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: the</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> header is placed on top of the requested memory. </font><font style="vertical-align: inherit;">A very strange string that uses the NULL ( </font></font><code>((surfcache_t *)0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">pointer </font><font style="vertical-align: inherit;">(but everything is fine with it, because there is no delay).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perspective projection for the poor? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In various articles on the Internet, it is assumed that Quake2 uses ‚Äúperspective projection for the poor‚Äù using a simple formula and without homogeneous coordinates or matrices (code below from </font></font><code>R_ClipAndDrawPoly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="cpp hljs"> XscreenSpace = X / Z * XScale YscreenSpace = Y / Z * YScale</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where XScale and YScale are defined by the field of view and the aspect ratio of the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a perspective projection is actually similar to what happens in OpenGL at the stage of dividing GL_PROJECTION + W:</font></font><br><br><pre> <code class="cpp hljs">  : =======================    | X | Y | Z | <span class="hljs-number"><span class="hljs-number">1</span></span> --------------------------------------------------    | | XScale <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | XClip <span class="hljs-number"><span class="hljs-number">0</span></span> YScale <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | YClip <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> V1 V2 | ZClip <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | WClip  : ================ XClip = X * XScale YClip = Y * YScale ZClip = / WClip = -Z  NDC   W: ========= XNDC = XClip/WClip = X * XScale / -Z YNDC = YClip/WClip = Y * YScale / -Z</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first naive proof: compare the superimposed screenshots. </font><font style="vertical-align: inherit;">If we look at the code: projecting for the poor?</font></font> Not! <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_DrawEntitiesOnList: Sprites and Objects </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage of the visualization process, the level is already rendered on the screen: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/soft_rend_2_surface.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The engine also generated a 16-bit z-buffer (it was recorded but not yet read): </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/depthBeforeEntities.jpg"><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we see that the closer the values, the ‚Äúbrighter‚Äù they are (in contrast to OpenGL) where closer is ‚Äúdarker‚Äù). </font><font style="vertical-align: inherit;">This is because 1 / Z is stored in the Z-buffer instead of Z. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A 16-bit z-buffer is stored starting with a pointer </font></font><code>d_pzbuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *d_pzbuffer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As stated above, 1 / Z is preserved by directly applying the formula described in Michael Abrash‚Äôs article ‚ÄúConsider the Alternatives: Quake's Hidden-Surface Removal‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">She is in </font></font><code>D_DrawZSpans</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> zi = d_ziorigin + dv*d_zistepv + du*d_zistepu;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in the mathematical proof that you can really interpolate 1 / Z, then here‚Äôs the Kok-Lim Low article: </font></font><a href="http://fabiensanglard.net/quake2/Perspective-Correct%2520Interpolation.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The z-buffer outputted at the stage visualization stage is now used as input for correct trimming of entities. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about animated entities (players and enemies):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quake1 only rendered keyframes, but now all vertices are exposed to LERP ( </font></font><code>R_AliasSetUpLerpData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) for smooth animation.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quake1 for rendering considered entities as BLOBs: this is an inaccurate, but very fast way to render. </font><font style="vertical-align: inherit;">In Quake2, this was abandoned, and entities are rendered normally, after testing BoundingBox and testing the front faces with a vector product.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In terms of lighting: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not all shadows are rendered. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polygons have Gouraud shading with a strictly defined direction of illumination ( </font></font><code>{-1, 0, 0}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>R_AliasSetupLighting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The intensity of illumination is based on the intensity of the source of illumination of the surface to which it is directed. </font></font></li></ul><br><img src="http://fd.fabiensanglard.net/quake2/quake2_withEntities.jpg"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Translucency in R_DrawAlphaSurfaces </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparency should be performed using palette indexes. </font><font style="vertical-align: inherit;">I guess I‚Äôve repeated it for the tenth time in the article, but this is the only way I can express how </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amazing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it seems to me </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The translucent polygon is rendered as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projecting all the vertices into the screen space. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definition of left and right edges. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the surface is not distorted (animated water), then a visualization into the system of caching in RAM is performed. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, if the surface is not completely opaque, then it needs to be mixed with the voice-over frame buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The trick is performed using the second part of the image </font></font><code>pics/colormap.pcx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, used as a lookup table for mixing the source pixel from the surface cache with the target pixel (in the off-frame frame buffer): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source input data generates the X coordinate, and the target coordinates the Y coordinate. The resulting pixel is loaded into the frame-by-frame buffer: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/COLORMAP_lower.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The animation below shows a frame before and after a pixel-by-one mixing palette:</font></font><br><br><img src="https://habrastorage.org/web/dbd/6f0/94f/dbd6f094f9c24dd798ead00bdcddafae.gif"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R_CalcPalette: post-effects operations and gamma correction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The engine is capable of performing not only ‚Äúpixel-by-pixel mixing of the palette‚Äù and ‚Äúchoosing a color gradient based on a palette‚Äù, it can also change the whole palette to transmit information about health deterioration or collecting items: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/quake_damage.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the ‚Äúanalyzer‚Äù in the game DLL on the server side needed to mix colors at the end of the rendering process, he just needed to set the value of the RGBA variable </font></font><code>float player_state_t.blend[4]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for any player in the game. This value is transferred over the network, copied to </font></font><code>refdef.blend[4]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then transferred to the renderer DLL (well, the journey!). Upon detection, it is mixed with every 256 RGB elements in the palette index. After the gamma correction, the palette is loaded into the video card again. </font></font><br><br> <code>R_CalcPalette</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>r_main.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// newcolor = color * alpha + blend * (1 - alpha) alpha = r_newrefdef.blend[3]; premult[0] = r_newrefdef.blend[0]*alpha*255; premult[1] = r_newrefdef.blend[1]*alpha*255; premult[2] = r_newrefdef.blend[2]*alpha*255; one_minus_alpha = (1.0 - alpha); in = (byte *)d_8to24table; out = palette[0]; for (i=0 ; i&lt;256 ; i++, in+=4, out+=4) for (j=0 ; j&lt;3 ; j++) v = premult[j] + one_minus_alpha * in[j];</span></span></code> </pre> <br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting fact:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after changing the palette by the above method, it is necessary to perform gamma correction (c</font></font><code>R_GammaCorrectAndSetPalette</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/gamma_correction.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma correction is a resource-intensive operation, including challenge</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and division ... besides, it had to be performed for each of the R, G and B color values!</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newValue = <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span> ( (value+<span class="hljs-number"><span class="hljs-number">0.5</span></span>)/<span class="hljs-number"><span class="hljs-number">255.5</span></span> , gammaFactor ) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A total of three calls </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, three division operations, six summation operations and three multiplications for each of the 256 values ‚Äã‚Äãin the palette index are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a lot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But since the input data is limited to eight bits per channel, full correction can be calculated in advance and caching into a small array of 256 elements:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw_BuildGammaTable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, inf; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> g; g = vid_gamma-&gt;value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g == <span class="hljs-number"><span class="hljs-number">1.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i&lt;<span class="hljs-number"><span class="hljs-number">256</span></span> ; i++) sw_state.gammatable[i] = i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i&lt;<span class="hljs-number"><span class="hljs-number">256</span></span> ; i++) { inf = <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span> ( (i+<span class="hljs-number"><span class="hljs-number">0.5</span></span>)/<span class="hljs-number"><span class="hljs-number">255.5</span></span> , g ) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inf &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) inf = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inf &gt; <span class="hljs-number"><span class="hljs-number">255</span></span>) inf = <span class="hljs-number"><span class="hljs-number">255</span></span>; sw_state.gammatable[i] = inf; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the lookup table ( </font></font><code>sw_state.gammatable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is </font><font style="vertical-align: inherit;">used for this trick </font><font style="vertical-align: inherit;">and it greatly accelerates the gamma correction process.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R_GammaCorrectAndSetPalette</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *palette )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++ ) { sw_state.currentpalette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>] = sw_state.gammatable[palette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>]]; sw_state.currentpalette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>] = sw_state.gammatable[palette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>]]; sw_state.currentpalette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>] = sw_state.gammatable[palette[i*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>]]; } SWimp_SetPalette( sw_state.currentpalette ); }</code> </pre> <br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You may decide that LCD screens do not have such gamut problems as CRTs ... however, they usually</font></font><a href="http://developer.nvidia.com/book/export/html/181"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mimic the behavior of CRT screens</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code statistics </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bit of analysis of the Cloc code to close the topic of the software renderer: this module has 14,874 lines. </font><font style="vertical-align: inherit;">This is a little more than 10% of the total, but does not give an idea of ‚Äã‚Äãthe effort involved, because several others were tested before choosing this scheme.</font></font><br><br><pre> <code class="cpp hljs"> $ cloc ref_soft/ <span class="hljs-number"><span class="hljs-number">39</span></span> text files. <span class="hljs-number"><span class="hljs-number">38</span></span> unique files. <span class="hljs-number"><span class="hljs-number">4</span></span> files ignored. http:<span class="hljs-comment"><span class="hljs-comment">//cloc.sourceforge.net v 1.53 T=0.5 s (68.0 files/s, 44420.0 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- C 17 2459 2341 8976 Assembly 9 1020 880 3849 C/C++ Header 7 343 293 2047 Teamcenter def 1 0 0 2 ------------------------------------------------------------------------------- SUM: 34 3822 3514 14874 -------------------------------------------------------------------------------</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly optimization in nine files </font></font><code>r_*.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains 25% of the entire code base, and this is quite an impressive ratio. </font><font style="vertical-align: inherit;">I think it quite clearly shows the amount of labor invested in the software renderer: most of the rasterization procedure is manually optimized for the x86 processor by Michael Abrash. </font><font style="vertical-align: inherit;">Most of the Pentium optimization discussed in his book ‚ÄúGraphics Programming Black Book‚Äù is used in these files. </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting fact:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> some of the names of the methods in the book and in the Quake2 code are the same (for example, </font></font><code>ScanEdges</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profiling </font></font></h3><br><img src="http://fd.fabiensanglard.net/quake2/Visual%20Studio%20Team%20Profiling.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I tried using different profilers, they are all integrated in Visual Studio 2008: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AMD Code Analysis </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel VTune Amplifier XE 2011 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio Team Profiler </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binding to time sampling has shown </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> different results. </font><font style="vertical-align: inherit;">For example, Vtune considered the cost of transferring from RAM to video memory ( </font></font><code>BitBlit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), but other profilers missed them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel and AMD profilers failed to check the hardware (and I‚Äôm not so masochist to figure out why this happened), but VS 2008 Team profiler did it ... although I don‚Äôt recommend it: the game worked at three frames per second, and for analysis 20 -second game took a whole hour! </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profiling VS 2008 Team edition:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/quake2/soft/soft_profiler.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The results speak for themselves:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The cost of software rendering is staggering: 89% of the time spent in the DLL. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game logic is barely noticeable: 0%. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surprisingly a lot of time is taken by the sound DirectX DLL. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>libc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spends more time than the quake.exe kernel.</font></font></li></ul><br><img src="http://fd.fabiensanglard.net/quake2/soft/soft_profiler_rend_dll_module.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's take a closer look at the time spent ref_soft.dll: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As I mentioned above, writing a byte to memory is very expensive: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huge costs (33%) are associated with building a Z-buffer ( </font></font><code>D_DrawZSpans</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huge costs (22%) are associated with recording intervals in the voice-over buffer ( </font></font><code>D_DrawZSpans16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Huge costs (13%) are associated with the generation of a cache skip surface. </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The costs of the line-by-line algorithm are obvious: </font></font><br><ul><li> <code>R_LeadingEdge</code> </li> <li> <code>R_GenerateSpans</code> </li> <li> <code>R_TrailingEdge</code> </li> </ul></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel VTune profiling: The</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/quake2/ref_sof_full.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> following is noticeable:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18% of the time is devoted to the standard problem of software renderers: the cost of transferring a rendered image from RAM to video memory ( </font></font><code>BitBlit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">34% of the time is devoted to rendering and caching surfaces ( </font></font><code>D_DrawSurfaces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8% is dedicated to LERP vertices for animating players / enemies ( </font></font><code>R_AliasPreparePoints</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here is a more </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detailed profyling of ref_sof Quake2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using VTune. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD Code Analysis profiling</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and ref_sof </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Texture filtering </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I received a lot of questions about how to improve texture filtering (go to bilinear filtering or dithering </font></font><a href="http://www.flipcode.com/archives/Texturing_As_In_Unreal.shtml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar to that used in Unreal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )). If you want to experiment with this aspect, then study </font></font><code>D_DrawSpans16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>ref_soft/r_scan.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initial coordinates (X, Y) of the screen space are in </font></font><code>pspan-&gt;u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>pspan-&gt;v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, there is also an interval width in </font></font><code>spancount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to calculate what the target screen pixel will be generated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the texture coordinates: </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and are </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initialized in the original texture coordinates and are incremented by (respectively) </font></font><code>sstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>tstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to control the texture sampling.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some, for example, Szilard Biro, have got quite good results when using the Unreal I dithering technique: </font></font><br><br><img src="https://habrastorage.org/web/d38/270/015/d38270015eae469e83b5aebaaeb56e61.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of a software renderer with dithering can be found in my </font></font><a href="https://github.com/fabiensanglard/Quake-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quake2 fork on github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The dithering is activated by assigning cvar sw_texfilt to the value 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source dithering from the Unreal software renderer 1:</font></font><br><br><img src="https://habrastorage.org/web/318/f33/d6d/318f33d6d194469492f3bcd2841a1474.gif"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Renderer opengl </font></font></h3><br><img src="http://fd.fabiensanglard.net/quake2/glRendererStruct.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quake2 was the first engine released with native support for hardware accelerated rendering. </font><font style="vertical-align: inherit;">He demonstrated undeniable improvements due to bilinear texture filtering, increased multitexturing, and 24-bit color mixing. </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/renderer.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the user's point of view, the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hardware accelerated version provided the following improvements:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bilinear filtering </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color lighting </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30% higher frame rate at high resolutions </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I can not refrain from quoting from ‚ÄúMasters of Doom‚Äù about how John Romero first saw the color lighting </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[app. </font><font style="vertical-align: inherit;">Lane: before starting work on Quake 2, he already left id Software and created his own company Ion Storm]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote>      id [...]. <br><br>    ,     Quake II.    ,   : <b> !</b>      ,   .        ,      ,          .   ,      .        ,    Softdisk,    Dangerous Dave in Copyright Infringement <i>[. .:    1990      PC   ]</i> . <br><br> ¬´ ¬ª, ‚Äî  .     . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This feature has had a strong influence on the development of Daikatana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terms of code, the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renderer is 50% smaller than the software renderer (see "Code Statistics" at the bottom of the page). </font><font style="vertical-align: inherit;">This meant that developers needed less work. </font><font style="vertical-align: inherit;">Also, this implementation was much simpler and more elegant than the software / assembly-optimized version:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Z-buffer eliminated the stack of active polygons (this dependence on a fast Z-buffer led to problems when developing VQuake for V2200 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The high speed of the rasterizer chips in combination with the speed of the Z-buffer RAM made the task of zero redrawing unnecessary. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The built-in procedure of line-by-line construction of the image eliminated the need for a global edge table and a table of active edges. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The illumination maps were filtered in the video processor (and in RGB instead of grayscale): these calculations did not fall into the CPU at all. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all, the OpenGL renderer is more a resource manager than a renderer: it passes vertices, loads a satin of lightmaps on the fly, and assigns texture states. </font></font><br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting fact: the</font></font></u></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quake2 frame usually contains 600-900 polygons each: a striking difference from the millions of polygons in any modern engine.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Global code architecture </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The rendering phase is very simple and I will not discuss it in detail, because it is almost identical to software rendering: </font></font><br><br><pre> <code class="cpp hljs"> R_RenderView { R_PushDlights <span class="hljs-comment"><span class="hljs-comment">//  ,      R_SetupFrame R_SetFrustum R_SetupGL //  GL_MODELVIEW  GL_PROJECTION R_MarkLeaves //  PVS      R_DrawWorld //  ,      BoundingBox { } R_DrawEntitiesOnList //   R_RenderDlights //    R_DrawParticles //   R_DrawAlphaSurfaces //     - R_Flash //  (          ....) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All stages are clearly shown in the video, in which the engine is "slowed down": </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DYBrqiKnemI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualization order: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> World. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entities (in Quake2, they are called "alias"). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Particles </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Translucent surfaces. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fullscreen post effects. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main complexity of the code arises from different paths, depending on whether the video card supports multi-texturing and whether vertex group rendering is enabled. </font><font style="vertical-align: inherit;">For example, if the multi-texturing is supported, </font></font><code>DrawTextureChains</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>R_BlendLightmaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the following piece of code is not doing anything and just confusing when reading the code:</font></font><br><br><pre> <code class="cpp hljs"> R_DrawWorld { <span class="hljs-comment"><span class="hljs-comment">// ,   100%        ()   R_RecursiveWorldNode //    ,      { //   PVS      BBox/  //   ! //  :  GL_RenderLightmappedPoly { if ( is_dynamic ) { } else { } } } //      ( ) DrawTextureChains //    ,        bindTexture. { for ( i = 0, image=gltextures ; i&lt;numgltextures ; i++,image++) for ( ; s ; s=s-&gt;texturechain) R_RenderBrushPoly (s) { } } //      ( :  ) R_BlendLightmaps { //     //       if ( gl_dynamic-&gt;value ) { LM_InitBlock GL_Bind for ( surf = gl_lms.lightmap_surfaces[0]; surf != 0; surf = surf-&gt;lightmapchain ) { //   .   ,    ,       } } } R_DrawSkyBox R_DrawTriangleOutlines }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> World visualization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level rendering is done in </font></font><code>R_DrawWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A vertex has five attributes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color texture identifier. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coordinates color texture. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The texture ID of the static lightmap. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The coordinates of the static map of the lighting. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the OpenGL renderer there is no ‚ÄúSurface‚Äù: colors and lighting map are combined on the fly and never cached. </font><font style="vertical-align: inherit;">If the video card supports multitexturing, then only one pass is needed, indicating the texture identifier and its coordinates:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The color texture is tied to the OpenGL GL_TEXTURE0 state. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The lightmap texture is tied to the OpenGL GL_TEXTURE1 state. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transmitted vertices with the coordinates of the color texture and lighting map texture. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the video card does NOT support multi-texturing, then two passes are performed: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mixing is turned off. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The color texture is tied to the OpenGL GL_TEXTURE0 state. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertices are sent with color texture coordinates. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mixing is turned on. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The lightmap texture is tied to the OpenGL GL_TEXTURE0 state. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transmitted vertices with the coordinates of the lighting map texture. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texture Management </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since all rasterization is performed in the video processor, at the beginning of the level all textures should be loaded into the video memory: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color textures </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pre-calculated lighting map textures </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the OpenGL gDEBugger debugger, you can easily dig into the memory of a video processor and get statistics: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/gDEBugger.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we can see, each color texture has its own texture identifier (textureID). Static lighting maps are loaded as a texture atlas (called a ‚Äúblock‚Äù in quake2) in the following form: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/quake2-Context1-Texture1025level0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is the color texture in a separate texture if the lighting maps are collected in a texture atlas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimization of the chains of textures</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to increase performance when working with a video processor, then you need to strive for it to change its state as little as possible. This is especially true for texture binding ( </font></font><code>glBindTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Here is a bad example:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; polys.num ; i++) { glBindTexture(polys[i].textureColorID , GL_TEXTURE0); glBindTexture(polys[i].textureLightMapID , GL_TEXTURE1); RenderPoly(polys[i].vertices); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If each polygon has a color texture and a lighting map texture, then there is little that can be done, but Quake2 collects its lighting maps into atlases, which can be easily grouped by identifier. </font><font style="vertical-align: inherit;">Therefore, polygons are not rendered in the order returned from BSP. </font><font style="vertical-align: inherit;">Instead, they are grouped into texture chains based on which atlas of lightmap textures they belong to:</font></font><br><br><pre> <code class="cpp hljs"> glBindTexture(polys[textureChain[<span class="hljs-number"><span class="hljs-number">0</span></span>]].textureLightMapID , GL_TEXTURE1); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; textureChain.num ; i++) { glBindTexture(polys[textureChain[i]].textureColorID , GL_TEXTURE0); RenderPoly(polys[textureChain[i]].vertices); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The video below shows the process of rendering ‚Äúchains of textures‚Äù: polygons are rendered not depending on the distance, but on the basis of a block of lighting maps to which they belong: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hMog9IMohGw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to achieve constant translucency, only completely opaque polygons fall into the texture chain, and translucent polygons are still rendered back to front.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic lighting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the very beginning of the visualization phase, all polygons are marked to show that they are affected by dynamic lighting ( </font></font><code>R_PushDlights</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Therefore, a pre-calculated static lighting map is not used. Instead, a new irradiance map is generated, combining a static irradiance map with the addition of light projected onto the plane of the polygon ( </font></font><code>R_BuildLightMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the lighting map has a maximum size of 17x17, the phase of generating a dynamic lighting map is not very expensive, but loading changes into the video processor using a </font></font><code>qglTexSubImage2D</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slow one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To store all dynamic lighting maps, a block of lighting maps of 128x128 is used, its id = 1024. </font><font style="vertical-align: inherit;">See the ‚ÄúLighting Map Management‚Äù section for an explanation of how all dynamic lighting maps are combined on the fly into a texture atlas. </font></font><br><br><img src="https://habrastorage.org/web/17d/a83/29f/17da8329fe814c6f82d228801f863bee.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. The initial state of the dynamic lighting unit. </font><font style="vertical-align: inherit;">2. After the first frame. </font><font style="vertical-align: inherit;">3. After ten frames. </font></font></i> <br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the dynamic lighting map is full, group rendering is performed. </font><font style="vertical-align: inherit;">The rover tracks whether the allocated space has been cleared and the generation of dynamic lighting maps is resumed.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lighting map management </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said earlier, in the OpenGL version of the renderer there is no concept of "surface" ("surface"). </font><font style="vertical-align: inherit;">The lighting map and color texture are combined on the fly and are NOT cached. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The static lighting maps are loaded into the video memory, they are still stored in RAM: if the polygon is affected by dynamic lighting, a new lighting map is generated, combining a static lighting map with the light projected on it. </font><font style="vertical-align: inherit;">The dynamic lightmap is then loaded into textureId = 1024 and used for texturing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture atlases are called ‚Äúblocks‚Äù (‚ÄúBlock‚Äù) in Quake2, consist of 128x128 texels and are controlled by three functions:</font></font><br><br><ul><li> <code>LM_InitBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Reset tracking of memory consumption by block. </font></font></li><li> <code>LM_UploadBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Download or update texture contents. </font></font></li><li> <code>LM_AllocBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Find a suitable place to store your lighting map. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The video below shows how the lighting maps are combined into blocks. </font><font style="vertical-align: inherit;">Here the engine plays in "Tetris": scans from left to right and remembers where the lighting map will fit completely in the highest coordinate of the image.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8r_F0QiU-VM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm should pay attention: rover ( </font></font><code>int gl_lms.allocated[BLOCK_WIDTH]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) tracks across the entire width, which height each column of pixels occupied.</font></font><br><br><pre> <code class="css hljs"> //  "<span class="hljs-selector-tag"><span class="hljs-selector-tag">best</span></span>"     "<span class="hljs-selector-tag"><span class="hljs-selector-tag">bestHeight</span></span>" //  "<span class="hljs-selector-tag"><span class="hljs-selector-tag">best2</span></span>"     "<span class="hljs-selector-tag"><span class="hljs-selector-tag">tentativeHeight</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">qboolean</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LM_AllocBlock</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">w</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>) { int i, j; int best, best2; //<span class="hljs-attribute"><span class="hljs-attribute">FCS</span></span>:        best = BLOCK_HEIGHT; for (i=0 ; i&lt;BLOCK_WIDTH-w ; i++) { best2 = 0; for (j=0 ; j&lt;w ; j++) { if (gl_lms.allocated[i+j] &gt;= best) break; if (gl_lms.allocated[i+j] &gt; best2) best2 = gl_lms.allocated[i+j]; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">j</span></span> == <span class="hljs-selector-tag"><span class="hljs-selector-tag">w</span></span>) { //    *x = i; *y = best = best2; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">best</span></span> + <span class="hljs-selector-tag"><span class="hljs-selector-tag">h</span></span> &gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">BLOCK_HEIGHT</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>=0 ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">w</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>++) <span class="hljs-selector-tag"><span class="hljs-selector-tag">gl_lms</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.allocated</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[*x + i]</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">best</span></span> + <span class="hljs-selector-tag"><span class="hljs-selector-tag">h</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note: the rover design pattern (‚Äúrover‚Äù) is very elegant and is also used in the system of memory caching of the surfaces of the software renderer. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel fill rate and rendering passes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As can be seen from the following video, redrawing can be quite significant: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UOYdpHxlNbY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the worst case, a pixel can be overwritten 3-4 times (not counting redrawing): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> World: 1-2 passes (depending on multitexturing support). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Particle mixing: 1 pass. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Post-effect mixing: 1 pass. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GL_LINEAR </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bilinear filtering worked well with color textures, but really blossomed when filtering lighting maps: </font></font><br><br>  It was: <br><br><img src="http://fabiensanglard.net/quake2/3colors_01.jpg" alt="image"><br><br>  It became: <br><br><img src="http://fabiensanglard.net/quake2/3colors_00.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now all together: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/full_pipeline01_annotated.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Texture: dynamic / static lighting map. </font></font></i> <br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/full_pipeline02_annotated.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Texture: color. </font></font></i> <br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/full_pipeline03_annotated.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Mixing result: one or two passes.</font></font></i> <br><br><img src="https://habrastorage.org/web/510/c1d/52c/510c1d52c43845c58072da02b5aea0a4.gif"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity visualization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entities are rendered in groups: vertices, texture coordinates, and color array pointers are collected and sent using </font></font><code>glArrayElement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before rendering, LERP is performed for the vertices of all entities to smooth the animation (in Quake1, only keyframes were used). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud's lighting model is used: an array of colors is intercepted by Quake2 to store the lighting value. Before rendering, the light value is calculated for each vertex and stored in an array of colors. The value of this array is interpolated in the video processor and a good result is obtained with Guro lighting.</font></font><br><br><pre> <code class="cpp hljs"> R_DrawEntitiesOnList { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!r_drawentities-&gt;value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   for (i=0 ; i &lt; r_newrefdef.num_entities ; i++) { R_DrawAliasModel { R_LightPoint ///         GL_Bind(skin-&gt;texnum); //    GL_DrawAliasFrameLerp() //  { GL_LerpVerts //  LERP   //     ,     colorArray for ( i = 0; i &lt; paliashdr-&gt;num_xyz; i++ ) { } qglLockArraysEXT qglArrayElement // ! qglUnlockArraysEXT } } } //    for (i=0 ; i &lt; r_newrefdef.num_entities ; i++) { R_DrawAliasModel { [...] } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cutting off the rear edges is performed in a video processor (well, since the tessellation and lighting were performed at that time in the CPU, I think we can say that it was performed at the driver stage). </font></font><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to accelerate calculations, the direction of light has always been taken to be the same ( </font></font><code>{-1, 0, 0}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), but this is not reflected in the engine. The illumination color is accurate and is selected according to the current polygon on which the entity is based. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is very clearly seen in the screenshot below, where the light and shade are in the same direction, despite the incorrect definition of the light source. </font></font><br><br><img src="http://fabiensanglard.net/quake2/shadow_issue_zoom.jpg"><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, this system is not always perfect, the shadow is emitted into the void, and the edges overwrite each other, leading to different levels of shadows, but this is still pretty impressive for 1997. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More about shadows:</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many do not know that Quake2 was able to calculate the approximate shadows of entities. </font><font style="vertical-align: inherit;">Although this feature is disabled by default, it can be enabled with a command </font></font><code>gl_shadows 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shadow is always directed in one direction (does not depend on the nearest source of light), the faces are projected onto the plane of the essence level. </font><font style="vertical-align: inherit;">In the code, it </font></font><code>R_DrawAliasModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generates a vector </font></font><code>shadevector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used </font></font><code>GL_DrawAliasShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to project the faces onto the plane of the entity level.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Visualization Lighting: Discretization Trick </font></font></h3><br>   ,             /   ‚Ä¶  .         <code>float r_avertexnormal_dots[SHADEDOT_QUANT][256]</code> ,  <code>SHADEDOT_QUANT</code> =16. <br><br>  :    : {-1,0,0}. <br><br>     16  ,        Y. <br><br>     16       256  .     MD2 ‚Äî      .    X,Y,Z     256 . <br><br> -         <code>r_avertexnormal_dots</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16x256 size. </font><font style="vertical-align: inherit;">Since the normal index cannot be interpolated during the animation process, the closest normal index is used for the keyframe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More on this: </font></font><a href="http://www.quake-1.com/docs/quakesrc.org/97.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.quake-1.com/docs/quakesrc.org/97.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Good old OpenGL ... </font></font></h3><br> <u>  glGenTextures?!:</u> <br><br>  openGL-  textureID    <code>glGenTextures</code> . Quake2       .      0,        1024,      1025  1036. <br><br> <u>   Immediate mode:</u> <br><br>        ImmediateMode.       ( <code>glVertex3fv</code>  <code>glTexCoord2f</code> )    (   ,      ). <br><br>      (, )   <code>glEnableClientState (GL_VERTEX_ARRAY)</code> . ,   <code>glVertexPointer</code>  <code>glColorPointer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to transmit the value of the illumination calculated in the CPU. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitexturing:</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The code is complicated by the fact that it seeks to adapt to the equipment that supports and does not support the new technology ... multitexturing. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No use </font></font><code>GL_LIGHTING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since all calculations were performed in the CPU (generating textures for the world and the value of the vertex illumination for entities), there are no traces in the code </font></font><code>GL_LIGHTING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since OpenGL 1.0 still performed Gouraud shading (interpolating colors between vertices) instead of Phong shading (where normals are interpolated for real ‚Äúpixel-by-pixel illumination‚Äù), using </font></font><code>GL_LIGHTING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it would look bad for the world because it would require creating vertices on the fly.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It could be applied to entities, but at the same time, we would have to send vertex normal vectors. </font><font style="vertical-align: inherit;">This seems to be considered unsuitable, therefore the calculation of the illumination values ‚Äã‚Äãis performed in the CPU. </font><font style="vertical-align: inherit;">The light value is transferred from the color array, the values ‚Äã‚Äãare interpolated to the CPU to get Gouro shading.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fullscreen post effects </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The palette-based software renderer performed elegant full color mixing of the palette and additional gamma correction using a lookup table. </font><font style="vertical-align: inherit;">But the OpenGL-version is not necessary, and this can be seen on the example of the ‚Äúbrute force‚Äù method in </font></font><code>R_Flash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do you need to make the screen a little more red? </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solution:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> just draw a huge red rectangle GL_QUAD on the whole screen with alpha channel mixing turned on.</font></font> Is done. <br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: the</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> server controlled the client in the same way as the software renderer: if the server needed to perform full-screen color mixing for the post-effect, it simply assigned the value of the </font></font><code>float player_state_t.blend[4]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGBA </font><font style="vertical-align: inherit;">variable </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The value of the variable is then transmitted through the quake2 kernel over the network and sent to the renderer DLL.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profiling </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual Studio 2008 Team Profiler is just wonderful, that's what it turned out for OpenGL Quake2: </font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/openGL_profiler.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No wonder: most of the time is spent on OpenGL-driver NVidia and Win32 ( </font></font><code>nvoglv32.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>opengl32.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), only about 30%. The visualization is performed in the video processor, but a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lot of time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is spent on a multiple call of the immediate mode methods, as well as on copying data from RAM to the video memory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following are the renderer module ( </font></font><code>ref_gl.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23%) and the quake2 kernel ( </font></font><code>quake2.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15%). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even in spite of the fact that the engine actively uses malloc, we see that time ( </font></font><code>MSVCR90D.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>msvcrt.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">is almost not wasted on it </font><font style="vertical-align: inherit;">. The time spent on the game logic ( </font></font><code>gamex86.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is </font><font style="vertical-align: inherit;">also irrelevant </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unexpected amount of time spent on directX ( </font></font><code>dsound.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">sound library </font><font style="vertical-align: inherit;">: 12% of total time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a closer look at the OpenGL Quake2 renderer dll:</font></font><br><br><img src="http://fd.fabiensanglard.net/quake2/openGL/openGL_profiler_rend_dll_module.jpg"><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the time is spent on rendering the world ( </font></font><code>R_RecurseiveWorldNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost the same - for rendering enemies (alias models): ( </font></font><code>GL_DrawAliasFrameLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5%). </font><font style="vertical-align: inherit;">The costs are quite high, despite the fact that the dot product is calculated in advance.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The generation of lighting maps (when dynamic lighting prevents the use of a previously computed static lighting map) also takes 2.5% of the time ( </font></font><code>GL_RenderLightMappedPoly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In general, the OpenGL dll is well balanced, there are NO obvious bottlenecks. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code statistics </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An analysis of the Cloc code shows that there are a total of 7,265 lines of code. </font></font><br><br><pre> <code class="cpp hljs"> $ cloc ref_gl <span class="hljs-number"><span class="hljs-number">17</span></span> text files. <span class="hljs-number"><span class="hljs-number">17</span></span> unique files. <span class="hljs-number"><span class="hljs-number">1</span></span> file ignored. http:<span class="hljs-comment"><span class="hljs-comment">//cloc.sourceforge.net v 1.53 T=1.0 s (16.0 files/s, 10602.0 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- C 9 1522 1403 6201 C/C++ Header 6 237 175 1062 Teamcenter def 1 0 0 2 ------------------------------------------------------------------------------- SUM: 16 1759 1578 7265 -------------------------------------------------------------------------------</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compared to the software renderer, the difference is astounding: 50% less code, WITHOUT assembler optimization, while the speed is 30% higher and there is color lighting and bilinear filtering. </font><font style="vertical-align: inherit;">It is easy to understand why id Software did not bother with the software renderer for Quake3.</font></font></div><p>Source: <a href="https://habr.com/ru/post/328128/">https://habr.com/ru/post/328128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328116/index.html">The story of creating a classic RTS at home from scratch (Part 2: "Resurrection"). Continuation of the article: GUI</a></li>
<li><a href="../328118/index.html">The story of creating a classic RTS at home from scratch (Part 2: "Resurrection") End of article: Network</a></li>
<li><a href="../328120/index.html">Hachim IntegerCache in Java 9</a></li>
<li><a href="../328122/index.html">We do GraphQL API on PHP and MySQL. Part 1: Installation, layout and queries</a></li>
<li><a href="../328126/index.html">Parallels Mac Management: Transition Difficulties</a></li>
<li><a href="../328130/index.html">Pygest # 8. Releases, articles, interesting projects from the world of Python [April 11, 2017 - May 7, 2017]</a></li>
<li><a href="../328134/index.html">Recovering data from damaged RAID 5 to Linux NAS</a></li>
<li><a href="../328138/index.html">Neuroculture Part 0. Or neuro-free chicken coop</a></li>
<li><a href="../328144/index.html">Docker containers slightly increase server power consumption</a></li>
<li><a href="../328146/index.html">A simple model of the adaptive Kalman filter by means of Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>