<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I am writing a toy OS (about the implementation of sleep)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Another post for a blog dedicated to working on a toy OS. Last time I wrote about the need for a simple driver AHCI (SATA). Before starting to move in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I am writing a toy OS (about the implementation of sleep)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/827/a91/73d/827a9173dc67d1991ccd09b036473572.jpeg"><br>  Another post for a blog dedicated to working on a toy OS.  <a href="http://habrahabr.ru/post/179561/">Last time</a> I wrote about the need for a simple driver AHCI (SATA).  Before starting to move in this direction, I decided to sketch a driver infrastructure: a common driver interface + a refined storage device driver interface.  The formulation of these interfaces revealed a problem to which I had previously not paid attention - the problem of portability. <br><br>  Platform-independent code (for example, most of the scheduler, an auxiliary code of type kprintf, ...) is mixed with code sharpened only under x86_64 (system descriptor tables, APIC, interrupts, ...).  Although nothing prevented me from formulating a driver interface tied to x86_64 (in particular, to freely operate PCI addresses), it became clear to me that without a clear separation of code specific to a specific platform from the general portable code, I would only aggravate the situation.  So, I decided to sort through everything written, separating the common code (in the root src /) from the code specific to the platform (in src / x86_64 /).  This is what I've been doing for the last two weeks. <br><a name="habracut"></a><br>  I will describe briefly the code separation mechanism on the example of the scheduler.  The src / schedule.h scheduler interface enables (#include) the special src / x86_64 / schedule.inc file, which contains platform-dependent static inline functions (both interface and internal).  All internal characters (not related to the interface, but not static) are preceded by the prefix "__".  The main implementation of the scheduler is in src / schedule.c, separate internal functions and assembler code in src / x86_64 / schedule.c.  Thus, the scheduler code is ‚Äúsprayed‚Äù into two directories.  Of course, this complexity is only for the general case, while many modules are constructed in a simplified way.  For example, for cpu_info (information about logical processors), the header is in src /, and the implementation is in src / x86_64 /.  Or a fully platform-specific APIC is placed entirely in src / x86_64 /. <br><br>  Now about the promised function sleep.  Unlike the mutex, the implementation of sleep required some modification of the scheduler (albeit minimal).  The following functions were added to the interface part ( <a href="">src / schedule.h</a> ): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*timer_proc)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticks)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> get_ticks(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-function">timer_proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_timer_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> get_timer_ticks(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-comment"><span class="hljs-comment">// is zeroed after triggering void set_timer_proc(timer_proc proc); // called within a timer interrupt void set_timer_ticks(uint64_t ticks); // not thread-safe</span></span></code> </pre> <br>  Those.  Now the scheduler also acts as a timer: it stores the tick counter (internal timer interrupts) and also calls the handler function as soon as the number of ticks reaches the specified number.  Consider the implementation of this mechanism ( <a href="">src / schedule.c</a> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cpu)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu == get_bsp_cpu()) ticks++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timer_ticks[cpu] &amp;&amp; timer_ticks[cpu] &lt;= ticks) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> prev_ticks = timer_ticks[cpu]; timer_ticks[cpu] = <span class="hljs-number"><span class="hljs-number">0</span></span>; set_outer_spinlock(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); timer_proc_(prev_ticks); set_outer_spinlock(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre><br>  The handle_timer function is called on every timer interrupt.  Despite the fact that the ticks counter is incremented only for the bootstrap processor, the timer is independently programmable for each of the logical processors.  Wrapping a call to a handler in set_outer_spinlock is necessary so that a call to release_spinlock inside a handler does not accidentally execute an STI instruction (do not forget that we are in the context of an interrupt). <br><br>  Now, using this advanced functionality of the scheduler, we can implement sleep ( <a href="">src / sync.c</a> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> thread_id thread; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ticks; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_pool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pool</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spinlock</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">;</span></span> } sleeping[CONFIG_CPUS_MAX]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep_timer_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNUSED </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticks)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_data</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slp</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleeping</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_cpu</span></span></span><span class="hljs-class">()];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slp-&gt;tail) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slp</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">;</span></span> slp-&gt;tail = slp-&gt;tail-&gt;next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slp-&gt;tail) set_timer_ticks(slp-&gt;tail-&gt;ticks); resume_thread(node-&gt;thread); free_block(&amp;slp-&gt;pool, node); } } <span class="hljs-function"><span class="hljs-function">err_code </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> period)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_data</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slp</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleeping</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_cpu</span></span></span><span class="hljs-class">()];</span></span> err_code err = ERR_NONE; acquire_spinlock(&amp;slp-&gt;lock, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sleep_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alloc_block</span></span></span><span class="hljs-class">(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slp</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pool</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node) { node-&gt;thread = get_thread(); node-&gt;ticks = get_ticks() + period / CONFIG_SCHEDULER_TICK_INTERVAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!slp-&gt;tail || slp-&gt;tail-&gt;ticks &gt; node-&gt;ticks) { <span class="hljs-comment"><span class="hljs-comment">// is first to wake up node-&gt;next = slp-&gt;tail, slp-&gt;tail = node; set_timer_ticks(node-&gt;ticks); } else { struct sleep_node *prev = slp-&gt;tail; while (prev-&gt;next &amp;&amp; prev-&gt;next-&gt;ticks &lt;= node-&gt;ticks) prev = prev-&gt;next; node-&gt;next = prev-&gt;next, prev-&gt;next = node; } pause_this_thread(&amp;slp-&gt;lock); } else err = ERR_OUT_OF_MEMORY; if (err) release_spinlock(&amp;slp-&gt;lock); return err; }</span></span></code> </pre><br>  The above code needs some explanation: <br><br>  1. An instance of the sleep_data structure corresponds to a logical processor.  The sleep pool for each processor is independent, since mem_pool is not thread safe. <br><br>  <i>That is why the mutex code hides a serious mistake: for all mutexes there is a single pool for mutex_node, and it is necessary that each mutex has its own pool.</i>  <i>I plan to fix it soon.</i> <br><br>  2. As can be seen from the code, when added to the list, the threads are ranked by wake-up time (in ticks). <br><br>  3. The sleep_timer_proc function is the handler that is called by the scheduler in the context of a timer interrupt.  Its task is to wake up the desired flow. <br><br>  The rest seems fairly transparent. </div><p>Source: <a href="https://habr.com/ru/post/181870/">https://habr.com/ru/post/181870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181854/index.html">How to stop noticing the limited traffic with free WiFi</a></li>
<li><a href="../181858/index.html">Course lectures "Startup". Peter Thiel. Stanford 2012. Session 14</a></li>
<li><a href="../181860/index.html">6 hours with MegaFon Login or looking for a budget smartphone with android for a vacation trip</a></li>
<li><a href="../181864/index.html">Graphene photosensor is 1000 times more sensitive to light than CMOS and CCD</a></li>
<li><a href="../181868/index.html">Juniper Wireless Systems - First Meet</a></li>
<li><a href="../181872/index.html">Battleship as a recognition task</a></li>
<li><a href="../181874/index.html">Managed random in javascript</a></li>
<li><a href="../181876/index.html">What touch technologies are used on large screens?</a></li>
<li><a href="../181878/index.html">Recognition of psychological testing forms from scratch</a></li>
<li><a href="../181880/index.html">Comparison of the effectiveness of minimizers CSS-and JavaScript-code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>