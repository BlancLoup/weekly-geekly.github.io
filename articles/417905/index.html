<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>11 ways to (not) become a victim of hacking in Kubernetes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : The original of this article was published on the official Kubernetes blog and was written by Andrew Martin, one of the founders of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>11 ways to (not) become a victim of hacking in Kubernetes</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: The original of this article was published on the official Kubernetes blog and was written by Andrew Martin, one of the founders of the young British company Control Plane, specializing in security for cloud native applications running in K8s.</i> <br><br><img src="https://habrastorage.org/webt/em/sv/dw/emsvdwgvf4ym5fydg8ob7jxomcq.jpeg"><br><br>  Security in Kubernetes has come a long way since the project was launched, however, it still contains pitfalls.  We offer a list of useful recommendations on how to protect the clusters and increase their stability in the event of hacking: let's start with the control plane, continue with workloads and network security, and finish with an assessment of future security. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Part 1: Control Plane </h2><br>  <a href="https://kubernetes.io/docs/concepts/">The control plane</a> is the Kubernetes brain.  He has a general idea of ‚Äã‚Äãeach container and a pod running in a cluster, can plan new pods (in which containers with root access to their parent nodes can be located) and can read all secrets stored in the cluster.  This is a very important component that needs real-time protection against accidental data leakage and malicious actions: both when it is accessed, and when nothing happens, and when data is transmitted over the network. <br><br><h3>  1. Ubiquitous TLS </h3><br>  <b>For each component that supports TLS, it must be enabled ‚Äî to prevent traffic sniffing, server identity, and (in the case of Mutual TLS) client identity.</b> <br><br><blockquote>  "Please note that some components and installation methods can activate local ports for HTTP, so administrators need to familiarize themselves with the settings of each component in order to identify possible paths for unsafe traffic." <br><br>  <i><a href="https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/">Kubernetes documentation</a></i> </blockquote><br>  The following network diagram from <a href="https://docs.google.com/presentation/d/1Gp-2blk5WExI_QR59EUZdwfO2BWLJqa626mK2ej-huo/edit">Lucas K√§ldstr√∂m</a> demonstrates where TLS should ideally be used: between each component on the wizard, and between Kubelet and the API server.  The classic ‚Äú <a href="">Kubernetes The Hard Way</a> ‚Äù by <a href="https://twitter.com/kelseyhightower/">Kelsey Hightower</a> and the <a href="https://coreos.com/etcd/docs/latest/op-guide/security.html">safety documentation in etcd</a> offer detailed instructions for achieving these goals. <br><br><img src="https://habrastorage.org/webt/tl/z6/9p/tlz69p-_qgydpvdbkb8i0wkwjlm.png"><br><br>  Historically, the automatic scaling of Kubernetes nodes was not easy, since each node required a TLS key to connect to the master, and storing secrets in basic images was a bad practice.  <a href="https://medium.com/%40toddrosner/kubernetes-tls-bootstrapping-cf203776abc7">Kubelet TLS bootstrapping</a> enables the new Kubelet to create a certificate signing request so that certificates are generated at boot time: <br><br><img src="https://habrastorage.org/webt/js/7x/bw/js7xbwddp6cgld-bgcp20r657qy.png"><br><br><h3>  2. Minimum privileges in RBAC, disabling ABAC, monitoring logs </h3><br>  <b>Role-based access control (RBAC) provides fine management of the policies by which users access resources such as namespaces.</b> <br><br><img src="https://habrastorage.org/webt/if/so/hz/ifsohz4fgeo5alqvpe4pbvimujq.png"><br><br>  The attribute-based access control system (ABAC, Attribute Based Access Control) in Kubernetes has been replaced by RBAC since K8s 1.6 release and should not be enabled on the server side of the API.  Use RBAC instead: <code>--authorization-mode=RBAC</code> (or this flag for GKE: <code>--no-enable-legacy-authorization</code> ). <br><br>  There are many <a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/">good examples of</a> <a href="https://github.com/uruddarraju/kubernetes-rbac-policies">RBAC policies</a> for various services in a cluster, as well as <a href="https://kubernetes.io/docs/admin/authorization/rbac/">documentation</a> .  But you should not be limited to this: the correct settings for RBAC-policies can be obtained using <a href="https://github.com/liggitt/audit2rbac">audit2rbac</a> from <code>audit</code> logs. <br><br>  Incorrect or over-authorizing RBAC policies are a security risk in the event of a compromise of the hearth.  Supporting RBAC rules with minimal privileges, their ongoing audit and improvement should be part of the ‚Äútechnical duty hygiene‚Äù that teams apply in the development life cycle. <br><br>  <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/audit/">Audit logging</a> (beta in Kubernetes 1.10) offers a custom logging API for workloads (for example, querying and responding to it) and at the metadata level.  The logging level can be configured in accordance with the organization‚Äôs security policy ‚Äî <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/audit-logging">GKE</a> applies reasonable defaults to those who are just starting to work with it. <br><br>  For read requests, such as <i>get</i> , <i>list</i> and <i>watch</i> , only the requested object is saved in the audit logs, without a response object.  For requests that affect sensitive data like <i>Secret</i> or <i>ConfigMap</i> , only metadata is exported.  For all other requests, both objects are recorded in the audit logs: both the request and the response. <br><br>  Do not forget: storing these logs inside the cluster is a security risk in the event of a compromise.  These logs, like any other security-sensitive, should be placed outside the cluster in order to avoid negative consequences in case of vulnerability. <br><br><h3>  3. Use third-party authentication for API Server </h3><br>  <b>Centralizing authentication and authorization for the entire organization (ie, Single Sign On) helps in the process of accepting and leaving new employees, ensuring consistent access rights.</b> <br><br>  Integrating Kubernetes with third-party authentication providers (such as Google or GitHub) guarantees identity from a remote platform (with protection like two-factor authentication) and eliminates the need for administrators to reconfigure the API server in Kubernetes to add / remove users. <br><br>  <a href="https://github.com/coreos/dex">Dex</a> is an OpenID Connect Identity Provider (OIDC) and OAuth 2.0 with <i><a href="https://github.com/coreos/dex">connectors</a></i> .  Pusher went even further by providing <a href="https://thenewstack.io/kubernetes-single-sign-one-less-identity/">customizable tools</a> , in addition to which there are <a href="https://github.com/negz/kuberos">some</a> <a href="https://github.com/micahhausler/k8s-oidc-helper">other</a> helpers focused on other uses. <br><br><h3>  4. Separate and place your cluster etcd behind the firewall </h3><br>  <b>etcd stores information about the status of Kubernetes and secrets, is a critical component of K8s - it must be protected separately from the rest of the cluster.</b> <br><br>  Access to write to etcd at the API server is equivalent to granting root-rights to the entire cluster, and even read access can be easily used to escalate privileges. <br><br>  The scheduler Kubernetes in etcd looks for definitions of hearths that do not have a node.  Then he sends all the found pods to the available Kubelet for planning.  These pods are validated by the API server before they are written to etcd, so attackers who write directly to etcd can bypass many security mechanisms ‚Äî for example, <code>PodSecurityPolicies</code> . <br><br>  etcd must be configured with <a href="">both TLS certificates</a> ( <i>client</i> and <i>peer</i> ) and deployed to the selected nodes.  To reduce the risk of theft and the use of private keys from work nodes, you can also restrict the cluster server's API firewall. <br><br><h3>  5. Rotation of encryption keys </h3><br>  <b>Regular rotation of security keys and certificates is the best practice in security, which allows you to limit the "radius of destruction" when a key is compromised.</b> <br><br>  Kubernetes will <a href="https://kubernetes.io/docs/tasks/tls/certificate-rotation/">automatically rotate</a> some certificates (in particular, Kubelet‚Äôs client and server certificates) by creating new CSRs after the expiration of the current ones. <br><br>  However, the <a href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">symmetric keys</a> used by the API server to encrypt etcd values ‚Äã‚Äãare not automatically rotated ‚Äî this must be <a href="https://www.twistlock.com/2017/08/02/kubernetes-secrets-encryption/">done manually</a> .  This operation requires master level access, so managed services (like GKE and AKS) hide the problem from the user. <br><br><h2>  Part 2: Workloads </h2><br>  With minimal security at the control plane, the cluster can already function safely.  However, as for a ship with potentially dangerous cargo, the containers of such a vessel must protect the cargo in case of an unforeseen accident or leakage.  The same is true for workloads in Kubernetes ( <i>Pods</i> , <i>Deployments</i> , <i>Jobs</i> , <i>Sets</i> , etc.) - they can be trusted at the time of deployment, but if they are accessible from the outside, there is always the risk that they will be used later by [attackers].  This risk can be reduced by running workloads with minimal privileges and their safe configuration. <br><br><h3>  6. Use security features in Linux and PodSecurityPolicies </h3><br>  <b>The Linux kernel has many overlapping security extensions (capabilities, SELinux, AppArmor, seccomp-bpf) that can be configured to provide minimal privileges to applications.</b> <br><br>  Utilities like <a href="https://github.com/genuinetools/bane">bane</a> will help generate profiles for AppArmor, and <a href="https://github.com/docker-slim/docker-slim">docker-slim</a> profiles will help seccomp, but be careful: a comprehensive test suite that checks all application code is required to identify all the side effects of using these policies. <br><br>  <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/">PodSecurityPolicies</a> govern the use of these security extensions, as well as other Kubernetes security directives.  They are responsible for the minimum requirements that must conform to in order to get to the API server, including security profiles, privilege flag, sharing of the host network, processes or namespaces for IPC. <br><br>  These directives are important because they help prevent containerized processes from escaping their isolated boundaries.  <a href="https://gist.github.com/tallclair/11981031b6bfa829bb1fb9dcb7e026b0">The</a> <a href="https://twitter.com/tallclair">Tim Allclair PodSecurityPolicy example is</a> quite versatile - it can be used as a basis and customized for your own case. <br><br><h3>  7. Perform a static YAML analysis. </h3><br>  <b>If PodSecurityPolicies restrict access to the API server, then static analysis can also be used in the design process to model the organization's regulatory requirements and risk appetite.</b> <br><br>  Sensitive information should not be stored in YAML resources like pods ( <i>Pods</i> , <i>Deployments</i> , <i>Sets</i> , etc.), and sensitive <i>ConfigMaps</i> and <i>Secrets</i> must be encrypted with utilities like <a href="https://github.com/coreos/vault-operator">Vault</a> (with an operator from CoreOS), <a href="https://github.com/AGWA/git-crypt">git-crypt</a> , <a href="https://github.com/bitnami-labs/sealed-secrets">sealed secrets</a> or <a href="https://cloud.google.com/kms/">KMS cloud provider</a> . <br><br>  Static analysis of the YAML configuration can be used as a basis for security during startup.  <a href="https://kubesec.io/">kubesec</a> generates risk assessments for resources: <br><br><pre> <code class="plaintext hljs">{ "score": -30, "scoring": { "critical": [{ "selector": "containers[] .securityContext .privileged == true", "reason": "Privileged containers can allow almost completely unrestricted host access" }], "advise": [{ "selector": "containers[] .securityContext .runAsNonRoot == true", "reason": "Force the running image to run as a non-root user to ensure least privilege" }, { "selector": "containers[] .securityContext .capabilities .drop", "reason": "Reducing kernel capabilities available to a container limits its attack surface", "href": "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" }] } }</code> </pre> <br>  And <a href="https://github.com/garethr/kubetest">kubetest</a> is a framework for unit testing of Kubernetes configurations: <br><br><pre> <code class="go hljs">#<span class="hljs-comment"><span class="hljs-comment">// vim: set ft=python: def test_for_team_label(): if spec["kind"] == "Deployment": labels = spec["spec"]["template"]["metadata"]["labels"] assert_contains(labels, "team", "should indicate which team owns the deployment") test_for_team_label()</span></span></code> </pre> <br>  These utilities implement the ‚Äú <a href="https://en.wikipedia.org/wiki/Shift_left_testing">shift left</a> ‚Äù approach (i.e., move checks and verification to the early stages of the development cycle).  Security testing at the design stage provides users with quick code and configuration feedback, which can be further rejected by manual or automated verification, and can also facilitate the introduction of additional security practices. <br><br><h3>  8. Run non-root containers </h3><br>  <b>Containers that run as root are often much more privileged than their workloads require, and in the case of compromise they help attackers to achieve greater opportunities.</b> <br><br>  Containers still rely on the traditional UNIX security model (called the DAC, <a href="https://www.linux.com/learn/overview-linux-kernel-security-features">discretionary access control</a> ) - everything is a file, and rights are granted to users and groups. <br><br>  Namespaces for users do not work in Kubernetes.  This means that the table of user IDs in the container is mapped to the table of users of the host, and starting the process with root rights inside the container will start it with root rights on the host.  Although mechanisms are added to all of this to prevent the container from going out of limits, launching as root within the container is not recommended. <br><br>  Many container images use the root user to run PID 1: if this process is compromised, the attacker gets root in the container and with any configuration error, the operation becomes much easier. <br><br>  Bitnami <a href="https://engineering.bitnami.com/articles/running-non-root-containers-on-openshift.html">did a great job</a> of translating their container images to <a href="https://github.com/bitnami/bitnami-docker-nginx/blob/b068b8bd01eb2f5a7314c09466724f86aa4548f9/1.12/Dockerfile">regular (non-root) users</a> (besides, this is the default OpenShift requirement), which can simplify your migration to non-root images. <br><br>  This fragment of PodSecurityPolicy prevents processes with root rights in the container from starting and escalating to root: <br><br><pre> <code class="plaintext hljs"># Required to prevent escalations to root. allowPrivilegeEscalation: false runAsUser: # Require the container to run without root privileges. rule: 'MustRunAsNonRoot'</code> </pre> <br>  Containers that do not use root cannot occupy privileged ports, i.e.  up to 1024 (the corresponding capability in the Linux kernel, <code>CAP_NET_BIND_SERVICE</code> , is responsible for this), but using <i>Services</i> helps to circumvent this limitation.  Here is an example for the MyApp application, which occupies port 8443 in a container, but <i>Service</i> makes it available on port 443, proxying requests to the <code>targetPort</code> : <br><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: my-service spec: selector: app: MyApp ports: - protocol: TCP port: 443 targetPort: 8443</code> </pre> <br>  The need to run workloads without using root will persist until the namespace for users is running or the <a href="https://rootlesscontaine.rs/">runtime</a> for launching containers without root is included in the executable media for containers. <br><br><h3>  9. Use network policies </h3><br>  <b>By default, the network in Kubernetes allows all traffic between the hooks.</b>  <b>This setting can be limited by network policy - <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/"><i>NetworkPolicy</i></a> .</b> <br><br><img src="https://habrastorage.org/webt/kd/cv/xu/kdcvxufrkq2dm0jw13vk8hvowae.png"><br><br>  Traditional services are limited to firewalls that use static IP addresses and port ranges for each service.  Since these IP addresses change very rarely, they have historically been used as a form of identification.  Containers rarely have static IP - their nature implies the ability to quickly fall and re-create, for them, instead of static IP-addresses, service discovery is used.  These features greatly complicate the configuration and testing of firewalls. <br><br>  Since Kubernetes stores all system state data in etcd, it is possible to configure a dynamic firewall - if there is the necessary support in the CNI network plugin.  Calico, Cilium, kube-router, Romana and Weave Net - all these plugins support network policies. <br><br>  It is important to note that the policies work on the principle of fail-closed, that is, the absence of the <code>podSelector</code> here by default equates to all possible values ‚Äã‚Äã(wildcard): <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny spec: podSelector:</code> </pre> <br>  The following is an example of <i>NetworkPolicy</i> , which prohibits everything from egress except UDP 53 (DNS), which also prevents incoming connections to the application.  <i>NetworkPolicies</i> policies <a href="https://www.weave.works/blog/securing-microservices-kubernetes/">are stateful</a> , so the application will still receive responses to outgoing connections. <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: myapp-deny-external-egress spec: podSelector: matchLabels: app: myapp policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP - to: - namespaceSelector: {}</code> </pre> <br>  Kubernetes network policies cannot be applied to DNS names.  The reason is that DNS supports round-robin to multiple IP addresses and dynamic responses dependent on the addressing IP, so network policies apply only to fixed IP addresses or <code>podSelector</code> 's (for dynamic IP addresses Kubernetes). <br><br>  The best practice is to start with a ban on all traffic for the namespace and add the routes required by the application to pass acceptance testing step by step.  The process can be tricky, so ControlPlane developed <a href="https://github.com/controlplaneio/netassert">netassert</a> , a utility for testing network security in DevSecOps scripts with a highly parallelized nmap: <br><br><pre> <code class="plaintext hljs">k8s: # used for Kubernetes pods deployment: # only deployments currently supported test-frontend: # pod name, defaults to `default` namespace test-microservice: 80 # `test-microservice` is the DNS name of the target service test-database: -80 # `test-frontend` should not be able to access test-database's port 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API new-namespace:test-microservice: # `new-namespace` is the namespace name test-database.new-namespace: 80 # longer DNS names can be used for other namespaces test-frontend.default: 80 169.254.169.254: -80, -443 # AWS metadata API metadata.google.internal: -80, -443 # GCP metadata API</code> </pre> <br>  The metadata API from the cloud provider is a constant source of potential escalation (demonstrated <a href="https://hackerone.com/reports/341876">by Shopify‚Äôs</a> recent <a href="https://hackerone.com/reports/341876">bug bounty</a> ), so special tests that confirm the blocking of the API in the container network will help protect against configuration errors. <br><br><h3>  10. Scan the images and run IDS </h3><br>  <b>Web servers are a springboard for attacking the networks to which they are attached.</b>  <b>Scanning files installed in images helps to ensure that there are no known vulnerabilities that an attacker could use to gain remote access to the container.</b>  <b>Intrusion Detection Systems (IDS) capture these events if they occur.</b> <br><br>  Kubernetes allows submissions to the cluster through a set of supervisory checks (in the <a href="https://kubernetes.io/docs/admin/admission-controllers/">admission controller</a> ), applied not only to submissions, but also to other resources like <i>Deployments</i> .  In them, each of them can be validated for admission or its contents can be changed, in addition to which webhooks on the backend side are now also supported. <br><br><img src="https://habrastorage.org/webt/0s/-h/fw/0s-hfwbv4xf-izil5ljtxjxdyjm.png"><br><br>  These webhooks can be used by container imaging tools to validate images before they are deployed to a cluster.  Images that fail validation will not receive controller approval. <br><br>  Scanning container images for known vulnerabilities helps reduce the time it takes for an attacker to take advantage of an open CVE.  To prevent rolling out images with critical vulnerabilities in the deployment pipeline, you can use free utilities like <a href="https://github.com/coreos/clair">Clair</a> from CoreOS and <a href="https://github.com/aquasecurity/microscanner">Micro Scanner</a> from Aqua. <br><br>  Tools such as <a href="https://grafeas.io/">Grafeas</a> allow you to store image metadata for constant compliance and vulnerability checks using a unique container signature (or a special <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B5_%25D1%2585%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25BB%25D0%25B8%25D1%2589%25D0%25B5_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">content-addressed</a> hash).  Scanning an image of a container with this hash is equivalent to scanning images deployed in production, and can be done continuously without the need to have access to production environments. <br><br>  Unknown 0day vulnerabilities will always exist, so Kubernetes should deploy an intrusion detection system like <a href="https://www.twistlock.com/">Twistlock</a> , <a href="https://www.aquasec.com/">Aqua</a> or <a href="https://sysdig.com/product/secure/">Sysdig Secure</a> .  IDS detects unusual behavior in a container and stops or kills it.  <a href="https://github.com/draios/falco">Falco by Sysdig</a> is an open source rules engine and a starting point for this ecosystem. <br><br><h2>  Part 3: The Future </h2><br>  The next stage of security in the ‚Äúevolution of cloud native‚Äù seems to be the service mesh, although its adoption will not happen right away: this migration requires shifting the complexity of applications into the mesh infrastructure, and organizations will have to realize this best practice. <br><br><img src="https://habrastorage.org/webt/rm/qu/_m/rmqu_mfve6uvnnlaidl_bkjutqm.png"><br><br><h3>  11. Run the service mesh </h3><br>  <b>Service mesh is a network of permanent encrypted connections made between ‚Äúside-connected‚Äù <i>(similar to ‚Äúsidecar‚Äù)</i> , high-performance proxy servers like Envoy and Linkerd.</b>  <b>It brings traffic management, monitoring and policies - all without changes in microservices.</b> <br><br>  The transfer of security and network-related code from microservices to a shared and tested set of libraries was already possible with <a href="https://linkerd.io/">Linkerd</a> , and the emergence of <a href="https://istio.io/">Istio</a> from Google, IBM and Lyft brought an alternative to this space.  With the addition of <a href="https://spiffe.io/">SPIFFE</a> for the cryptographic identity of each hearth and many other features, Istio can simplify the deployment of next-generation network security. <br><br>  In zero trust networks, there may be no need for a traditional firewall or Kubernetes network policies, since each interaction takes place using mTLS (mutual TLS), which not only guarantees the security of the interaction, but also confirms the identity of both services . <br><br>  This transition from traditional networking approaches to the security principles of the Cloud Native world will not be easy for those with traditional security thinking.  As an introduction to this new world, we highly recommend the <a href="https://amzn.to/2Gg6Pav">book ‚ÄúZero Trust Networking‚Äù</a> by <a href="https://twitter.com/evan2645">Evan Gilman</a> from SPIFFE. <br><br>  <a href="https://istio.io/about/notes/0.8/">Istio 0.8 LTS</a> is currently available, and the project is rapidly approaching its release 1.0.  The project is versioned in terms of stability in the same way as the Kubernetes model: a stable core with separate APIs, for which their alpha or beta status is indicated using namespaces.  Expect to see an increase in the spread of Istio in the coming months. <br><br><h2>  Conclusion </h2><br>  Cloud Native applications have a more detailed set of lightweight security primitives to protect workloads and infrastructure.  The power and flexibility of such tools is both a blessing and a curse: not having enough automation [to use them], it was even easier to put out unsafe applications that allow you to go beyond the container or their insulating model. <br><br>  Utilities for protection available more than ever, but to reduce the opportunities for attack and the potential of incorrect configurations, you must use them with caution. <br><br>  If security slows down the organization‚Äôs speed in delivering change, it will never be high priority.  Using the principles of Continuous Delivery in relation to the software supply chain allows an organization to achieve regulatory compliance, continuous auditing and enhanced management without affecting business performance. <br><br>  Rapidly progressive security improvements are the easiest way with a comprehensive test suite.    Continuous Security ‚Äî          pipeline', ,    ,     . <br><br><h2>  PS from translator </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habr.com/company/flant/blog/353808/">OPA and SPIFFE - two new projects at CNCF for the security of cloud applications</a> ‚Äù; </li><li> ¬´ <a href="https://habr.com/company/flant/blog/337154/">Vulnerable Docker VM ‚Äî -  Docker  pentesting</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/company/flant/blog/327536/">  service mesh      [    ]?</a>  "; </li><li> ¬´ <a href="https://habr.com/company/flant/blog/349496/">Conduit ‚Äî  service mesh  Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/company/flant/blog/346304/">      Kubernetes</a> ¬ª; </li><li>  " <a href="https://habr.com/company/flant/blog/341760/">Infrastructure with Kubernetes as an affordable service</a> ." </li></ul></div><p>Source: <a href="https://habr.com/ru/post/417905/">https://habr.com/ru/post/417905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417895/index.html">Repair of 3D printers and machines: how the Top 3D Shop service works in Moscow and St. Petersburg</a></li>
<li><a href="../417897/index.html">PHP Digest 135 (July 9 - 23, 2018)</a></li>
<li><a href="../417899/index.html">Search for control dispersion nodes (how to stop doing stupid work and transfer it to another)</a></li>
<li><a href="../417901/index.html">How we began to do awesome long meetings, and why it is no longer universal evil</a></li>
<li><a href="../417903/index.html">Code Review case 1</a></li>
<li><a href="../417909/index.html">Why do you need Splunk? Application Performance Analytics</a></li>
<li><a href="../417911/index.html">Continuous design in development: methodology and principle</a></li>
<li><a href="../417913/index.html">Optimizing the rendering of scenes from the Disney cartoon "Moana". Part 3</a></li>
<li><a href="../417915/index.html">How to play a roommate</a></li>
<li><a href="../417917/index.html">ASC'18: Perseverance and regular training as a way to achieve a goal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>