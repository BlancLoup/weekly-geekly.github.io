<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 4.9 - Geometric Shader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Geometric Shader 
 Between the stages of the execution of the vertex and fragment shader there is an optional stage intended for the execution of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 4.9 - Geometric Shader</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><h1>  Geometric Shader </h1><br>  Between the stages of the execution of the vertex and fragment shader there is an optional stage intended for the execution of the geometric shader.  At the input, the geometry shader has a set of vertices that form one of the primitives that are valid in OpenGL (points, triangles, ...).  As a result of its work, the geometry shader can transform this set of vertices at its discretion, before passing it to the next shader stage.  It is worth noting the most interesting feature of the geometry shader: during its operation, a set of input vertices can be converted to a completely different primitive representation, and can also generate completely new vertices based on the input data, increasing the total number of vertices. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li></ol><br></div></div><br>  Let's not harness for a long time and immediately turn to the example of a geometric shader: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (points) in; layout (line_strip, max_vertices = 2) out; void main() { gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0); EmitVertex(); EndPrimitive(); }</span></span></code> </pre> <br>  At the beginning of the shader code, you must specify the type of primitive, the data of which comes from the vertex shader stage.  This is done using the <i>layout</i> specifier, located before the in keyword.  The primitive type specified in the specifier can take one of the following values, corresponding to the type of primitive processed by the vertex shader: <br><br><ul><li>  <i>points</i> : When outputting GL_POINTS (1). </li><li>  <i>lines</i> : When outputting GL_LINES or GL_LINE_STRIP (2). </li><li>  <i>lines_adjacency</i> : When outputting GL_LINES_ADJACENCY or GL_LINE_STRIP_ADJACENCY (4). </li><li>  <i>triangles</i> : When outputting GL_TRIANGLES, GL_TRIANGLE_STRIP or GL_TRIANGLE_FAN (3). </li><li>  <i>triangles_adjacency</i> : When outputting GL_TRIANGLES_ADJACENCY or GL_TRIANGLE_STRIP_ADJACENCY (6). </li></ul><br>  As a result, almost all types of primitives are listed here that are valid for passing render functions like <i>glDrawArrays ()</i> to the call.  If rendered using <i>GL_TRIANGLES</i> , then in the specifier you should specify the parameter <i>triangles</i> .  The number in brackets here means the minimum number of vertices that is contained in one primitive. <br><br>  Further, you must also specify the type of output primitive for this shader.  Accordingly, this is done through the <i>layout</i> specifier before the out keyword.  In this example, a line_strip with a maximum of two vertices will be generated at the output. <br><br>  If you forgot: the <i>Line Strip</i> primitive connects the points in the set, forming a continuous line between them, starting at two points in the set.  Each additional point over two results in another drawn line segment stretching from a new point to the previous one.  Below is an image of a five point segment: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/yl/eu/fjyleujhuqzcbgeg1cfakucseok.png"></div><br>  The presented example of a shader can produce only individual straight segments, since we explicitly set the maximum number of vertices in the primitive to be two. <br><br>  For the shader to be able to do something useful, it is necessary to obtain data from the output of the previous shader stage.  GLSL provides the built-in variable <i>gl_in</i> , which can be represented approximately by the following structure: <br><br><pre> <code class="cpp hljs">in gl_Vertex { vec4 gl_Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_PointSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_ClipDistance[]; } gl_in[];</code> </pre> <br>  Thus, the variable is similar to the interface blocks discussed in the <a href="https://habrahabr.ru/post/350156/">previous lesson</a> , and contains several fields of which we are currently most interested in <i>gl_Position</i> , which contains the vertex position vector, which was set as a result of the vertex shader. <br>  Note that this variable is an array, since most primitives contain more than one vertex, and the geometry shader stage receives all vertices of the primitive being processed as inputs. <br><br>  Having received the vertex data from the vertex shader output, you can start generating new data, which is done using two special functions of the geometry shader: <i>EmitVertex ()</i> and <i>EndPrimitive ()</i> .  It is expected that in the code you will generate at least one primitive declared as an output.  In our example, you should issue at least one <i>line_strip</i> primitive. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = gl_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].gl_Position + vec4(<span class="hljs-number"><span class="hljs-number">-0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>); EmitVertex(); gl_Position = gl_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].gl_Position + vec4( <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>); EmitVertex(); EndPrimitive(); }</code> </pre> <br>  Each call to <i>EmitVertex ()</i> adds the current value in the variable <i>gl_Position</i> to the current instance of the primitive.  When we call <i>EndPrimitive ()</i> , all generated vertices are finally connected to the specified output primitive type.  By repeating <i>EndPrimitive ()</i> calls after one or more <i>EmitVertex ()</i> calls, you can continue to create new instances of the primitives.  Specifically, in the example, two vertices are generated, displaced a short distance from the position of the input vertex, and then the <i>EndPrimitive ()</i> call is <i>made</i> , forming one line strip containing two vertices from these two generated vertices. <br><br>  So, knowing (in theory) how the geometry shader works, you probably already guessed what the effect of this example is.  At the input, the shader accepts point primitives and creates horizontal lines based on them, where the input vertex lies exactly in the middle.  The output of the program using such a shader is presented below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/z9/bk/59z9bkljaqodz70lp-vrhbgwyy8.png"></div><br>  Not too impressive, but already interesting, given the fact that we got such results by executing just one draw call: <br><br><pre> <code class="cpp hljs">glDrawArrays(GL_POINTS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Although this example is quite simple, it demonstrates an important principle: the ability to dynamically create new shapes using geometric shaders.  Later we will look at some more interesting effects implemented on the basis of geometry shaders, but in the meantime let's work on the basics using simple shaders. <br><br><h3>  Using a geometric shader </h3><br>  To demonstrate the use of the geometry shader, we use a simple program that renders four points lying on the XoY plane in normalized device coordinates (NDC).  Coordinates of points: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> points[] = { <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-comment"><span class="hljs-comment">// - 0.5f, 0.5f, // - 0.5f, -0.5f, // - -0.5f, -0.5f // - };</span></span></code> </pre> <br>  The vertex shader is simple - you just need to map the points to the desired plane: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec2 aPos; void main() { gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); }</span></span></code> </pre> <br>  The fragment shader is also trivial and simply uses a hard-coded color for the fragments: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; void main() { FragColor = vec4(0.0, 1.0, 0.0, 1.0); }</span></span></code> </pre> <br>  In the program code, we, as usual, create VAO and VBO for vertex data and render the render call with <i>glDrawArrays ()</i> : <br><br><pre> <code class="cpp hljs">shader.use(); glBindVertexArray(VAO); glDrawArrays(GL_POINTS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  As a result, on the screen is total darkness and four barely noticeable green dots: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/-q/p8/wy-qp8k5amiimosket8ekcuojcc.png"></div><br>  It is somehow sad if we have learned so much just to bring out such a depressing picture.  Therefore, we will urgently intervene in the scene and dilute this darkness using the capabilities of the geometric shader. <br><br>  But first, for training purposes, you have to create and figure out how the <i>end-to-end</i> geometry shader works, which simply takes the data of the input primitive and sends it to the output unchanged: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (points) in; layout (points, max_vertices = 1) out; void main() { gl_Position = gl_in[0].gl_Position; EmitVertex(); EndPrimitive(); }</span></span></code> </pre> <br>  At the moment, you can already understand the shader code without prompts.  Here we simply generate the vertex in the position obtained from the vertex shader, and then generate all the same point primitive. <br><br>  A geometric shader requires compilation and linking to a program object exactly the same as the vertex and fragment shaders.  However, this time the shader object is created with <i>GL_GEOMETRY_SHADER</i> as the shader type: <br><br><pre> <code class="cpp hljs">geometryShader = glCreateShader(GL_GEOMETRY_SHADER); glShaderSource(geometryShader, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gShaderCode, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glCompileShader(geometryShader); ... glAttachShader(program, geometryShader); glLinkProgram(program);</code> </pre> <br>  In fact, the compilation code is exactly the same as for other types of shaders.  Do not forget about checking for compilation and linking errors! <br><br>  When performing should get a familiar picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/-q/p8/wy-qp8k5amiimosket8ekcuojcc.png"></div><br>  Got the same thing as without a geometric shader ... Boring!  But, since the points are still displayed, we at least made sure that our shader is working and you can move on to something more interesting. <br><br><h3>  We build houses </h3><br>  Drawing simple lines and points is not exactly what we expected, so we will try to add some creativity and draw houses at the points specified by the input vertices.  To do this, we need to change the type of the output primitive to <i>triangle_strip</i> and draw three triangles: two to create a square base and one for the roof. <br><br>  Primitive <i>Triangle Strip</i> in OpenGL is a more efficient method of drawing triangles requiring fewer vertices at the entrance.  After rendering the first triangle, each subsequent vertex creates another triangle adjacent to the previous one.  If six vertices are specified in the <i>triangle strip</i> , then the result will be the following sequence of triangles: (1,2,3), (2,3,4), (3,4,5) and (4,5,6), that will result in four drawn triangles.  This primitive requires specifying at least three vertices for a successful rendering.  In general, N-2 triangles will be output;  with six vertices, we got 6-2 = 4 triangles, which is illustrated below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/kh/r-/mdkhr-mecnyq2eevflchtlkb330.png"></div><br>  Using the <i>triangle strip,</i> you can easily create the desired shape of the house of all three adjacent triangles by specifying them in the correct order.  The following image shows the order in which you want to display the vertices in order to get the desired type of triangles.  The blue dot shows the position of the input vertex: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/67/nh/fe67nhjcjkdgb6vgnkeuh7fqae4.png"></div><br>  Resulting Geometric Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (points) in; layout (triangle_strip, max_vertices = 5) out; void build_house(vec4 position) { gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 1:bottom-left EmitVertex(); gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0); // 2:bottom-right EmitVertex(); gl_Position = position + vec4(-0.2, 0.2, 0.0, 0.0); // 3:top-left EmitVertex(); gl_Position = position + vec4( 0.2, 0.2, 0.0, 0.0); // 4:top-right EmitVertex(); gl_Position = position + vec4( 0.0, 0.4, 0.0, 0.0); // 5:top EmitVertex(); EndPrimitive(); } void main() { build_house(gl_in[0].gl_Position); }</span></span></span></span></code> </pre> <br>  The shader creates five vertices in positions that are offset from the position of the input vertex, putting them all in a single <i>triangle strip</i> primitive.  This primitive is then sent to rasterization, and a fragmentary shader paints its surface in green.  We get one green house for each entry point: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/09/if/rp09ifjudlzoco_rev4uczekzpu.png"></div><br>  Here you can see that each house is really made up of three triangles - and all this is built on the basis of a single point of input data. <br><br>  But something still looks boring!  Let's try to paint each of the houses in their own color.  To do this, we will organize another vertex attribute storing vertex color information.  The vertex shader reads the attribute value for the vertex and passes it to the geometric shader, which in turn sends the color value to the fragment shader. <br><br>  The updated vertex data is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> points[] = { <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-comment"><span class="hljs-comment">// - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, // - 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // - -0.5f, -0.5f, 1.0f, 1.0f, 0.0f // - };</span></span></code> </pre> <br>  Next, we specify the vertex shader code for transmitting the color attribute to the geometric shader using the interface unit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec2 aPos; layout (location = 1) in vec3 aColor; out VS_OUT { vec3 color; } vs_out; void main() { gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); vs_out.color = aColor; }</span></span></code> </pre> <br>  Obviously, we will need to define an interface unit of the same type (but with a different name) in a geometric shader: <br><br><pre> <code class="cpp hljs">in VS_OUT { vec3 color; } gs_in[];</code> </pre> <br>  Since the geometry shader is executed on entire sets of input vertices, its input parameter is always an array, even in cases when a single vertex is supplied to the input. <br><blockquote>  In fact, we do not need to use interface blocks to transfer data to the geometry shader.  If the vertex shader transmitted a vector with color as <i>out vec3 vColor</i> , then it would be possible to write like this: <br><br><pre> <code class="cpp hljs">in vec3 vColor[];</code> </pre> <br>  However, in general, working with interface blocks is much easier, especially in geometry shaders.  In practice, the input parameters of geometry shaders are often represented by fairly large data sets and combining them into a single interface unit, represented by an array, is quite an expected step. </blockquote><br>  You should also declare the output variable that sends the color data to the fragment shader: <br><br><pre> <code class="cpp hljs">out vec3 fColor;</code> </pre> <br>  Since the fragment shader expects one (interpolated) color value, there is no point in sending arrays of color vectors.  That is why <i>fColor</i> here is not an array, but a single vector.  When we generate a vertex, each of them will remember the last value that was in the variable <i>fColor</i> for its call to the fragment shader.  Accordingly, for our houses we can fill <i>fColor</i> only once with the color obtained from the vertex shader stage to set the color of the whole house: <br><br><pre> <code class="cpp hljs">fColor = gs_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].color; <span class="hljs-comment"><span class="hljs-comment">//  gs_in[0]        gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0); // 1:- EmitVertex(); gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0); // 2:- EmitVertex(); gl_Position = position + vec4(-0.2, 0.2, 0.0, 0.0); // 3:- EmitVertex(); gl_Position = position + vec4( 0.2, 0.2, 0.0, 0.0); // 4:- EmitVertex(); gl_Position = position + vec4( 0.0, 0.4, 0.0, 0.0); // 5: EmitVertex(); EndPrimitive();</span></span></code> </pre> <br>  As a result, all generated vertices will store the color value from the <i>fColor</i> variable, which corresponds to the colors from the vertex attributes.  Now each house is painted in its own color: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/cj/tx/gdcjtxk0zm5knsunbcufuzq9www.png"></div><br>  Add a little more creativity and arrange a virtual winter by sprinkling snow on the roofs of the houses.  For this last vertex, we separately assign white color: <br><br><pre> <code class="cpp hljs">fColor = gs_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].color; gl_Position = position + vec4(<span class="hljs-number"><span class="hljs-number">-0.2</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1:- EmitVertex(); gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0); // 2:- EmitVertex(); gl_Position = position + vec4(-0.2, 0.2, 0.0, 0.0); // 3:- EmitVertex(); gl_Position = position + vec4( 0.2, 0.2, 0.0, 0.0); // 4:- EmitVertex(); gl_Position = position + vec4( 0.0, 0.4, 0.0, 0.0); // 5: fColor = vec3(1.0, 1.0, 1.0); EmitVertex(); EndPrimitive();</span></span></code> </pre> <br>  As a result, we have: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/of/mz/fk/ofmzfkix3bb8ky3gkuprhkm-wgc.png"></div><br>  You can compare your application code with <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/9.1.geometry_shader_houses/geometry_shader_houses.cpp">an example</a> . <br><br>  I think at this point it is already clear to you that geometric shaders give ample creative possibilities, even using simple primitives.  Since the geometry is created dynamically inside the super-high speed GPU core, this turns out to be much more efficient than specifying similar geometry using vertex buffers.  Geometric shaders offer ample opportunities to optimize the rendering of simple and frequently repeated cubic-type figures for voxel renders or grass stalks in open space scenes. <br><br><h3>  Exploding objects </h3><br>  Drawing houses is, of course, great, but not something we often have to work with.  Therefore, let us add heat and proceed directly to blasting three-dimensional models!  Hmm, you probably won't have to do this too often, but it will be an excellent demonstration of the capabilities of geometric shaders. <br><br>  By object blasting, we mean not the literal destruction of our precious peaks, but the movement of each triangle along the normal direction over time.  As a result, this effect gives the semblance of an explosion of an object, dividing it into separate triangles moving in the direction of its normal vector.  Below is the effect applied to the nanosuit model: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/vp/g5/bsvpg5z7fp8g2_5n1d29qu-zjji.png"></div><br>  What is great is that using a geometric shader allows the effect to work on any object, regardless of its complexity. <br><br>  Since we need to move the triangles along the normal vector, we have to start counting it.  Specifically, we need to find a vector perpendicular to the surface of the triangle, having only three of its vertices.  From the <a href="https://habrahabr.ru/post/319144/">transformational</a> lesson you probably remember that a vector perpendicular to the other two can be obtained using the vector product multiplication ( <i>cross product</i> ).  If we could find two vectors <i>a</i> and <i>b</i> parallel to the surface of the triangle, then the vector perpendicular to the surface would simply be the result of their vector product.  Actually, the geometry shader code below does just that: it calculates the normal vector using three vertices of the input triangle: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 a = vec3(gl_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].gl_Position) - vec3(gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position); vec3 b = vec3(gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position) - vec3(gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(cross(a, b)); }</code> </pre> <br>  Here, using subtraction, we obtain two vectors <i>a</i> and <i>b</i> parallel to the surface of the triangle.  Subtracting vectors gives another vector representing the difference of the two original ones.  Since all three vertices lie in the plane of the triangle, the difference between any vectors representing the vertices of the triangle generates vectors parallel to the surface of the triangle.  Pay attention to the order of the parameters in taking out the <i>cross ()</i> function: if we swapped <i>a</i> and <i>b</i> , then the direction of the normal vector would be opposite. <br><br>  Now that you have a way to find the normal, you can go to the implementation of the <i>explode ()</i> function. The function accepts the normal vector and the vertex position vector, and returns the new vertex position shifted along the normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">explode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec4 position, vec3 normal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> magnitude = <span class="hljs-number"><span class="hljs-number">2.0</span></span>; vec3 direction = normal * ((<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(time) + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) / <span class="hljs-number"><span class="hljs-number">2.0</span></span>) * magnitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position + vec4(direction, <span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  The code is pretty obvious.  The <i>sin ()</i> function depends on the <i>time</i> variable associated with the current time, and periodically returns values ‚Äã‚Äãin the interval [-1., 1.].  Since the explosion effect inside (implosion) is of no interest to us, we limit the <i>sin ()</i> values ‚Äã‚Äãto the interval [0., 1.].  The resulting value and the <i>magnitude</i> control constant are then used to scale the normal vector in the calculation of the final direction vector.  This vector is added to the input parameter of the vertex position to get a new, shifted position. <br><br>  The full code of the geometric shader of the explosion effect when using the render code of the 3D model files from the <a href="https://habrahabr.ru/post/338998/">corresponding lesson is</a> given below: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (triangles) in; layout (triangle_strip, max_vertices = 3) out; in VS_OUT { vec2 texCoords; } gs_in[]; out vec2 TexCoords; uniform float time; vec4 explode(vec4 position, vec3 normal) { ... } vec3 GetNormal() { ... } void main() { vec3 normal = GetNormal(); gl_Position = explode(gl_in[0].gl_Position, normal); TexCoords = gs_in[0].texCoords; EmitVertex(); gl_Position = explode(gl_in[1].gl_Position, normal); TexCoords = gs_in[1].texCoords; EmitVertex(); gl_Position = explode(gl_in[2].gl_Position, normal); TexCoords = gs_in[2].texCoords; EmitVertex(); EndPrimitive(); }</span></span></code> </pre> <br>  Notice that before each vertex is spawned, we pass in the corresponding texture coordinates. <br><br>  Also, do not forget to set the value for the uniforms <i>time</i> in your client code: <br><br><pre> <code class="cpp hljs">shader.setFloat(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, glfwGetTime());</code> </pre> <br>  The result is a scene with a model that periodically explodes and returns to its original state.  The example is frivolous, but it leads well to the in-depth use of geometric shaders. <br><br>  The resulting code can be compared with <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/9.2.geometry_shader_exploding/geometry_shader_exploding.cpp">an example</a> . <br><br><h3>  Display normal vectors </h3><br>  This time we will try to implement something really useful in practice using the geometry shader: the mapping of normal vectors of the rendered geometry.  When implementing lighting algorithms, you will inevitably encounter strange results and visual glitches, the cause of which will be difficult to determine.  One of the most common errors when working with lighting is setting incorrect normals, as if due to errors with loading vertex data, errors specifying the format of vertex attributes, or simply conversion errors directly in the shaders.  It would be great to have a tool to determine the correctness of the provided normals.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal rendering is one such tool, and geometric shaders are simply created to implement it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea is simple: first, we render the scene in the usual way without the geometry shader turned on, then we do the second pass, but displaying only the normals generated by the geometry shader. The shader will accept a triangle-type primitive at the input and create three segments in the direction of the normal vector at the position of each vertex. In the form of pseudocode it looks something like this:</font></font><br><br><pre> <code class="cpp hljs">shader.use(); DrawScene(); normalDisplayShader.use(); DrawScene();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time, the geometry shader will use the normals, supplied as a vertex attribute, instead of on the fly. </font><font style="vertical-align: inherit;">The geometric shader receives at the input of the position vector in the clip space ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clip space</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), so we should convert the normal vector into the same space. </font><font style="vertical-align: inherit;">But before we do this, we will need to transform the normal vectors using a normal matrix - so we take into account the scaling and rotation (given the species and model matrices). </font><font style="vertical-align: inherit;">All this is done in the vertex shader:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aNormal; out VS_OUT { vec3 normal; } vs_out; uniform mat4 projection; uniform mat4 view; uniform mat4 model; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); mat3 normalMatrix = mat3(transpose(inverse(view * model))); vs_out.normal = normalize(vec3(projection * vec4(normalMatrix * aNormal, 0.0))); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The normal vector converted into the clip space is transmitted to the next shader stage via the interface unit. </font><font style="vertical-align: inherit;">The geometry shader reads the vertex attributes (position vector and normal) and outputs a segment in the direction of the normal at the position of each vertex:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (triangles) in; layout (line_strip, max_vertices = 6) out; in VS_OUT { vec3 normal; } gs_in[]; const float MAGNITUDE = 0.4; void GenerateLine(int index) { gl_Position = gl_in[index].gl_Position; EmitVertex(); gl_Position = gl_in[index].gl_Position + vec4(gs_in[index].normal, 0.0) * MAGNITUDE; EmitVertex(); EndPrimitive(); } void main() { GenerateLine(0); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      GenerateLine(1); // ...   GenerateLine(2); // ...   }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think at the moment the code does not require additional explanations. </font><font style="vertical-align: inherit;">I will only note that the normal vector is scaled using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAGNITUDE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constant </font><font style="vertical-align: inherit;">, which allows you to limit the length of the displayed segment (otherwise it would be a bit too large). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the output of the normals serves primarily a debugging target, they can be output simply by lines of the same color, using the fragment shader:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; void main() { FragColor = vec4(1.0, 1.0, 0.0, 1.0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, the combination of rendering the model using a regular shader and re-rendering using a fresh normal rendering shader will give the following picture: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/nc/ak/gjncakbhmktudkcj8gewdxz-5ui.png"></div><br>    ,           ,                 .       ,  ,  -     ,   . <br><br>      <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/9.3.geometry_shader_normals/normal_visualization.cpp"></a> . <br><br>  <b>PS</b> : We have a <a href="https://t.me/joinchat/Cpb05A46UPpMWdNVVCb4Vg">telegram-konf</a> to coordinate transfers.  If there is a serious desire to help with the translation, then you are welcome! </div><p>Source: <a href="https://habr.com/ru/post/350782/">https://habr.com/ru/post/350782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350772/index.html">Convert React to Angular using a universal abstract tree. Proof of concept</a></li>
<li><a href="../350774/index.html">Java 9 - Have you switched? Not? Do not need ...!?</a></li>
<li><a href="../350776/index.html">Is it easy to speak at a conference for the first time?</a></li>
<li><a href="../350778/index.html">How do you work with Laravel?</a></li>
<li><a href="../350780/index.html">Thin diskless client based on Ubuntu that does not require mounting the file system over the network</a></li>
<li><a href="../350786/index.html">Do not deny yourself anything: giving carte blanche to uncensored reviews of our events in our blog</a></li>
<li><a href="../350788/index.html">Issue # 14: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../350790/index.html">Lightning Network In Depth, part 2: HTLC And Payment Routing</a></li>
<li><a href="../350792/index.html">Goldman Sachs lured away Google‚Äôs lead engineer to develop an API for his services</a></li>
<li><a href="../350794/index.html">Hessian-Free Optimization with TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>