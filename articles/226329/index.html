<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apple Metal API: what's the trick?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At WWDC 2014, a surprise was waiting for all of us: the announcement of a new 3D graphic API called Metal. But this time we are not dealing with a new...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apple Metal API: what's the trick?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/1fd/afb/4a6/1fdafb4a6fc15cf9d844b7883254f0f4.jpg" alt="image" align="right">  At WWDC 2014, a surprise was waiting for all of us: the announcement of a new 3D graphic API called Metal.  But this time we are not dealing with a new high-level API on top of OpenGL ES (as was the case with the Scene Kit), but with a new low-level API for rendering and computing, which can serve as a replacement for OpenGL in games.  According to Apple, Metal can be up to 10 times faster than OpenGL ES (more precisely, it can generate <i>draw calls</i> [transfer <i>calls</i> ; transfer data to the GPU] 10 times faster) and is available only on devices with iOS and the latest generation A7 processor. <br><br>  This announcement provoked a new wave of discussion and controversy about the need for the emergence of new graphics APIs that should (or should not - who knows) replace OpenGL.  The post offered to your attention does not intend to participate in this discussion - its purpose is to clarify what Metal does differ from OpenGL ES, whose replacement it is.  To understand what is so special (or vice versa, nothing special) is in the Metal API, we will have to look a bit under the ‚Äúhood‚Äù of graphic API and GPU. <br><a name="habracut"></a><br><h5>  How do GPU and graphics APIs work? </h5><br>  A naive reader may assume that calling an API directly does something on the GPU or allows something to occur inside the GPU.  An even more naive reader assumes that the GPU finishes handling this call when the API returns a result.  Both of these statements are far from reality.  If the driver was performing the rendering commands at the same moment when they were created and waiting for the rendering process to complete before returning the result to the API call, neither the CPU nor the GPU could work efficiently, since one of the processors would always be blocked for the sake of to another. <br><br>  For a simple improvement in the performance of the GPU, this process should be started asynchronously;  then the GPU will not block the CPU and the API calls will return the result almost instantly.  In this case, the GPU may not be used to 100%, since it may have to wait for the CPU to render new calls (= start of frame), while the calls of the remaining teams will wait for the previous ones to complete.  This is the reason why most graphics drivers collect all the <i>draw calls</i> (and other tasks that need to be performed on the GPU ‚Äî for example, changing states) to draw the entire frame before sending it to the GPU.  These buffered commands will then be sent back after the command to draw the next frame is received, so that the GPU will be used as efficiently as possible.  Of course, this will add one delay frame: while the CPU creates the task for the current frame, the last frame will be rendered on the GPU.  In fact, it is possible to buffer more than one frame and thus achieve a higher frame rate - at the expense of an even greater delay. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another mistake in our naive assumption is in the assumption of what the state change calls are doing. <br><br>  So, we learned at least two important things about what is happening behind the scenes of OpenGL collaboration with modern GPUs: state changes can be complicated if a new combination of states is required and all operations on the GPU will be delayed for a certain amount of time. <br><br>  In the application, one stream of actual commands for one frame, which must be executed on the GPU, is formed and sent to the GPU all at once at once (in fact, everything is a bit more complicated, but let's not go deep yet). <br><br>  You can read more about how modern computer graphics pipeline works in the Fabian Giesens series of articles - ‚Äú <a href="http://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">A trip down the Graphics Pipeline</a> ‚Äú. <br><br><h5>  Why another software model may have advantages </h5><br>  As you have already seen, a huge number of difficulties and cunning tricks are hidden from the programmer (they are probably even more than I mentioned), which hide what is happening directly.  Some of them make the life of a simple developer easier, others - make him look for ways to trick the driver or ‚Äúdig‚Äù towards the side effects of API calls. <br><br>  Some graphical APIs today are trying to remove most of these tricks by uncovering the "intricacies" they hide ‚Äî and in some cases leaving the program to the solution to all related problems.  The graphics API of the PS3 went in this direction, AMD goes with the Mantle, and the upcoming DirectX 12 and Apple Metal are also going there. <br><br><h5>  What has changed? </h5><br>  The command buffers are now open and the application must fill these buffers and send them to the command queue that will execute these buffers in the specified order on the GPI - so the application will have full control over the task sent to the GPU and determine how many delay frames you need to add (adding a delay, but at the same time increasing the degree of use of the GPU).  Buffering commands to the GPU and sending them asynchronously to the next frame must be implemented by the application itself. <br><br>  Since it becomes clear that these buffers will not be executed directly immediately (that is, at the time of creation) and that multiple buffers can be created and added to the queue for execution in a specific order, the application can afford to build them in multiple threads in parallel.  It also becomes more obvious to the programmer which of the results of the calculations are already available and which are not. <br><br>  State changes are now organized into state objects that can simply switch, while creating these objects will be more expensive.  For example, MTLRenderPipelineState contains shaders and all states that are implemented by their patching. <br><br>  Another plus from the new API is that it does not have to bear the burden of compatibility with previous versions and therefore will not be so conservative. <br><br>  There is a nuance in the sharpening under the A7 - thanks to him Metal is sharpened for work on systems with shared memory, i.e.  The CPU and GPU can directly access the same data without having to transfer it over the PCI bus.  Metal gives direct access to the program to the buffers from the CPU, and the responsibility for the fact that this data is not used simultaneously by the GPU rests on the programmer‚Äôs shoulders.  This useful feature allows you to mix the product of computing on the GPU and CPU. <br><br><h5>  And how is it 10 times faster? </h5><br>  Each draw call costs some time on the CPU and some time on the GPU.  Metal API reduces the time spent by the CPU, by simplifying condition monitoring and by reducing the number of error checks from the driver for correct state combinations.  The preliminary calculation of states also helps: you can not just check for errors during the build, but the state itself will require fewer API calls.  The ability to build concurrent command buffers increases the number of draw calls even more if the application is attached to the CPU. <br><br>  But rendering on the GPU on the other hand does not become faster, an application that makes very few draw calls for large meshes (a <a href="http://gamedev.stackexchange.com/questions/38412/whats-the-difference-between-mesh-and-a-model"><i>mesh</i></a> is a part of the model consisting of object vertices] will not get any benefit from switching to Metal. <br><br><h5>  Can the same thing be done on OpenGL? </h5><br>  At GDC 14, there was a great presentation of ‚Äú <a href="http://gdcvault.com/play/1020791/">Approaching Zero Driver Overhead</a> ‚Äù by Cass Everitt, John McDonald, Graham Sellers and Tim Foley.  Its main idea was to reduce the work of the driver in OpenGL by increasing the amount of work produced by draw calls, and using new GL objects and fewer GL calls to increase efficiency. <br><br>  This and other ideas will require further expansion of OpenGL and the emergence of new versions of this API, but much of this can be transferred to OpenGL ES.  What we will lose is the ability to directly control the command buffers, with all our pros and cons. <br><br>  What is the probability of seeing this in the future?  Because of the backward compatibility support, it remains to hope only for the appearance of a certain set of functions, which can be called the ‚Äúmodern kernel‚Äù, but it will most likely have to be made compatible with everything up to the original function glBegin ().  This restriction will work throughout the entire potential future of OpenGL and will become the limit of its evolution, making alternatives such as the Metal API increasingly preferred ... <br><br>  Original article: <br>  <a href="http://renderingpipeline.com/2014/06/whats-the-big-deal-with-apples-metal-api/">http://renderingpipeline.com/2014/06/whats-the-big-deal-with-apples-metal-api/</a> </div><p>Source: <a href="https://habr.com/ru/post/226329/">https://habr.com/ru/post/226329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226317/index.html">Small network single board computer for 20 USD</a></li>
<li><a href="../226321/index.html">Speedran on 13 vulnerabilities on sites. Basic concepts and means of protection</a></li>
<li><a href="../226323/index.html">Waterfall and Agile: and yet, where does the effect come from?</a></li>
<li><a href="../226325/index.html">An interesting task for the interview, currying and partial application of the function</a></li>
<li><a href="../226327/index.html">What should "PHP Junior Developer without experience" know?</a></li>
<li><a href="../226331/index.html">Setting up a remote interpreter on Pycharm for Django</a></li>
<li><a href="../226333/index.html">Reduced component connectivity of C ++ code</a></li>
<li><a href="../226335/index.html">How did SQL Server switch every two to three hours to using a non-optimal query execution plan?</a></li>
<li><a href="../226337/index.html">Let's play evolution? Genetic Algorithms in a Screensaver</a></li>
<li><a href="../226339/index.html">How to assemble an electric bike in seven days</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>