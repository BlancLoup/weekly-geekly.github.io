<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Crackme Chiwaka1 study</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article attempts to describe in detail the study of one entertaining crackme. It will be interesting first of all for beginners in reverse engine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Crackme Chiwaka1 study</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4dc/3d3/c1b/4dc3d3c1bb9540a9a93353e5593fd1ab.jpg" alt="image" align="right">  This article attempts to describe in detail the study of one entertaining crackme.  It will be interesting first of all for beginners in reverse engineering (whom I am and on which the article is mainly designed), but perhaps more serious experts will find the technique used in it interesting.  To understand what is happening will require basic knowledge of the assembler and WinAPI. <br><a name="habracut"></a><br><h3>  Foreword </h3><br>  The university assembler course awakened a dormant couple of years the spirit of the researcher, which originated in high school.  This spirit was quickly sacrificed for some unpretentious crackme, but soon there was a more interesting copy on the hard disk.  Unfortunately, over the years, the original source of this crackme could not be found, so I uploaded the <a href="https://drive.google.com/open%3Fid%3D0BwNfG861C7W8TzhWOGxuN0U1MVU">archive</a> to Google Drive. <br><br>  <b>Tools used:</b> <br><ul><li>  Debugger (I used <a href="http://www.ollydbg.de/">OllyDbg</a> ) </li><li>  A utility for getting window handles of running programs (for example, <a href="https://tuts4you.com/download.php%3Fview.432">Zero Dump</a> or supplied with Visual Studio Spy ++) </li><li>  Some files included in the <a href="">fasm archive</a> </li></ul><br><h3>  First look at the enemy </h3><br><img src="https://habrastorage.org/files/840/785/615/840785615ded4982b2b2c63977d1ff78.jpg" align="left">  The appearance of the main window of the experimental is very simple: two edit'a and a few buttons.  Moreover, the first input field is intended to give the opportunity to write to the second, which, judging by the Check button located next to it, will be the main obstacle to the registration of cracks. <br>  The About window contains one interesting inscription <i>‚ÄúPatching is allowed, but where where‚Äù</i> , preceding the most interesting.  The whole essence of this inscription will be revealed in the process of research, but for now we will not spoil. <br>  By the way, if someone has already seen this crackme and found a way to patch it (well, or if it seemed very simple to someone and he did it with one left hand in the process of reading the article), then I ask you to tell everyone about success, preferably with comments. <br>  Attempts to cause at least some reaction of the program are not crowned with success: no reaction should be made to pressing the Enable and Check buttons.  However, it is striking that in the active input field, you can only write in Latin letters and put a minus sign.  We notice this fact and begin work. <br><br><h3>  To battle! </h3><br>  To win this crackme, we need to deal with two input fields. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  First edit and Enable button </h4><br>  After loading the program in OllyDbg, we immediately notice an interesting <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v%3Dvs.85).aspx">GetProcAddress</a> near the entry point: <br><br><pre> 00401086 |.  68 56504000 PUSH OFFSET 00405056;  / Procname = "" 10, "&amp; 7", 14, "* - ', 4", 0F, ", - $", 02
 0040108B |.  FF35 9C504000 PUSH [DWORD DS: 40509C];  | hModule = NULL
 00401091 |.  E8 C0020000 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  \ KERNEL32.GetProcAddress
</pre><br>  To see what is being transmitted to it, set the bryak directly on the call to GetProcAddress.  Stopping here, we see that the SetWindowLongA function was ‚Äúdrawn‚Äù in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633591(v%3Dvs.85).aspx">Procname</a> , and the user32.dll descriptor was ‚Äúdrawn‚Äù in hModule: <br><br><pre> 00401086 |.  68 56504000 PUSH OFFSET 00405056;  / Procname = "SetWindowLongA"
 0040108B |.  FF35 9C504000 PUSH [DWORD DS: 40509C];  | hModule = 767F0000 ('USER32')
 00401091 |.  E8 C0020000 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  \ KERNEL32.GetProcAddress
</pre><br>  Calling this function through GetProcAddress hints that they wanted to hide it from us and something important is happening here.  To find out what exactly is happening there, let's look at the parameters passed to this function.  This can be done very quickly by placing a bryak on call eax, located a few teams below. <br><div class="spoiler">  <b class="spoiler_title">Why call eax?</b> <div class="spoiler_text">  By convention, the <a href="https://msdn.microsoft.com/ru-ru/library/zxk0tw93.aspx">stdcall</a> call used in WinAPI functions, an integer value (i.e., the address of the desired function), which GetProcAddress returns, must be in the eax register. <br></div></div><br>  After stopping at call eax, you can take a closer look at what went on the stack.  Olly kindly offers us a decoding of the transmitted values: <br><br><pre> 0018FC04 / 00020876;  | hWnd = 00020876, class = Edit
 0018FC08 | FFFFFFFC;  | Index = GWL_WNDPROC
 0018FC0C | 0040302B;  \ NewValue = Chiwaka1.40302B
</pre><br>  A quick look at the description of the function and it becomes clear that there is a replacement window procedure of one of the edit'ov.  The instinct tells you that this is an active edit, but to be sure, you need to use the Zero Dump utility (the Spy ++ analog that is on hand).  Dragging the Finder Tool sight to active edit, we find that its descriptor matches the one passed to SetWindowLongA. <br>  <i>When you restart the crack, this value will change, so the check should be done in one go.</i> <br><br>  Now it becomes clear where the legs grow from filtering input, which we found earlier.  Let's see what else the new window procedure does.  Let's go to the address (Go To -&gt; Expression or Ctrl + G in OllyDbg), which was passed by the NewValue parameter (40302b): <br><br><pre> 0040302B 55 PUSH EBP
 0040302C 8BEC MOV EBP, ESP
 0040302E 817D 0C 0201000 CMP [DWORD SS: EBP + 0C], 102
 00403035 75 61 JNE SHORT 00403098
 00403037 8B45 10 MOV EAX, [DWORD SS: EBP + 10]
</pre><br>  The constant 102, with which a comparison is made on 40302E, is <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646276(v%3Dvs.85).aspx">WM_CHAR</a> .  I looked at the list of all constants denoting the type of message in the <code>%fasm_directory%\INCLUDE\EQUATES\USER32.INC</code> (link to the archive with the fasm in the list of used tools), since the Internet was not at hand, but the fasm in <s>gentlemen‚Äôs</s> student suite was available. <br>  We proceed further along the code, as if the next JNE jump is not being executed.  The code after the JNE will be executed if the WM_CHAR message arrives, which is sent to the window after pressing (more precisely, after the WM_KEYDOWN message is processed) of the key, in accordance with which the ASCII code is set.  In this message, we are interested in wParam, which contains the character code of the key pressed.  Next, this value is written to EAX and a series of checks begins, preventing entry of anything other than Latin and minus. <br><br><pre> 0040303A 3C 41 CMP AL, 41
 0040303C 72 04 JB SHORT 00403042
 0040303E 3C 5A CMP AL, 5A
 00403040 76 10 JBE SHORT 00403052
 00403042 3C 61 CMP AL, 61
 00403044 72 04 JB SHORT 0040304A
 00403046 3C 7A CMP AL, 7A
 00403048 76 08 JBE SHORT 00403052
 0040304A 3C 08 CMP AL, 8
 0040304C 74 04 JE SHORT 00403052
 0040304E 3C 2D CMP AL, 2D
 00403050 75 61 JNE SHORT 004030B3
 00403052 3C 08 CMP AL, 8
 00403054 75 12 JNE SHORT 00403068
 00403056 833D D5504000 0 CMP [DWORD DS: 4050D5], 0
 0040305D 74 09 JE SHORT 00403068
 0040305F 832D D5504000 0 SUB [DWORD DS: 4050D5], 1
</pre><br>  An interesting reaction to the backspace (code 8 in ASCII): at 403056, some value in the memory is checked for equality to zero and the value of this value is one if it is not zero.  This behavior means that the length of the entered string is being counted.  And yes, it does happen a little further (last command): <br><br><pre> 00403069 8B0D D5504000 MOV ECX, [DWORD DS: 4050D5]
 0040306F 8881 70504000 MOV [BYTE DS: ECX + 405070], AL
 00403075 8305 D5504000 0 ADD [DWORD DS: 4050D5], 1
</pre><br>  Also here it is clearly seen that the entered character is written into memory at the end of the already entered sequence.  In calculating the place to write a character, the same address appears (4050D5), the value at which is the length of the entered string. <br><br>  <b>Conclusion: the</b> search for a suitable GetDlgItemText will not help to find the place where the input data is being checked (as it will not be here), but it will be helped by the memory stick that is being written to. <br><br>  So, set the breakpoint to read a few bytes, starting at address 405070. It also makes sense to be safe and to set breakpoint to read the number of characters entered (it was previously established that it is 4050D5).  The second is best done immediately before clicking Check, so as not to be distracted by stopping while entering a line.  Now run the program, enter something in the first edit and click on Check. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  The bytes located at the point where the breakpoint is triggered (as well as many more where there is a crack) go in such a sequence that it can be interpreted differently.  If you try to move higher on the commands, then the place where the breakpoint is triggered will be reanalysed and will look different.  To fix this, it is enough to go to the address of the breakpoint with the Go to -&gt; Expression command (Ctrl + G). <br></div></div><br>  We see that the stop occurred on the record of the number of characters entered in EAX, and the next command compares the 11th character (405070 + A) of the entered string with a minus (2D is the minus code in ASCII). <br><br><pre> 00402007 A1 D5504000 MOV EAX, [DWORD DS: 4050D5] &lt;- memory breakpoint when reading 4050D5
 0040200C 803D 7A504000 2 CMP [BYTE DS: 40507A], 2D
 00402013 75 1E JNE SHORT 00402033
 00402015 33C9 XOR ECX, ECX
 00402017 33DB XOR EBX, EBX
 00402019 80B9 70504000 0 CMP [BYTE DS: ECX + 405070], 0               
 00402020 74 11 JE SHORT 00402033
 00402022 8A99 70504000 MOV BL, [BYTE DS: ECX + 405070]              
 00402028 03C3 ADD EAX, EBX
 0040202A 83C1 03 ADD ECX, 3
 0040202D EB EA JMP SHORT 00402019
 0040202F 33C0 XOR EAX, EAX
 00402031 5E POP ESI
 00402032 58 POP EAX
 00402033 C605 7A504000 0 MOV [BYTE DS: 40507A], 0
 0040203A C3 RETN
</pre><br>  It is clearly noticeable that after the comparison we do not need a jump, since then (from 402019) a certain cycle is started, which we hardly want to miss.  Let us check this assumption and falsify the result of comparing the 11th character with a minus by modifying the ZF flag (or just restart the check with a suitable string for this comparison). <br>  In this cycle, every third character entered is checked to the first zero and the codes of these characters are added to the EAX register, which, as we remember, is the length of the entered string.  On 4020300 instead of minus zero is recorded and the test is completed. <br>  We follow on RETN. <br><br><pre> 004010F8 /.  3D 0A030000 CMP EAX, 30A
 004010FD |.  0F85 C6000000 JNE 004011C9
 00401103 |.  FF75 08 PUSH [DWORD SS: EBP + 8]
 00401106 |.  E8 380F0000 CALL 00402043
 0040110B |.  C605 A4504000 MOV [BYTE DS: 4050A4], 1
 00401112 |.  6812504000 PUSH OFFSET 00405012;  / Text = "Well done! Keep going ;-)"
 00401117 |.  6A 65 PUSH 65;  | ControlID = 101.
 00401119 |.  FF75 08 PUSH [DWORD SS: EBP + 8];  | hDialog =&gt; [ARG.EBP + 8]
 0040111C |.  E8 23020000 CALL &lt;JMP. &amp; USER32. SetDlgItemTextA&gt;;  \ USER32.SetDlgItemTextA
</pre><br>  The first team can see the comparison of the value of EAX c 30A and jump somewhere in case of inequality.  Further, the desired <i>‚ÄúWell done!</i>  <i>Keep going ;-) ¬ª</i> .  Now you need to see how to get there.  Next to the cherished SetDlgItemTextA noticeable call, in which we definitely need to go.  To get there, you must pass the test at 30A.  The easiest way to do this is to modify the ZF flag before jumping the JNE. <br>  Having executed Call, we see the following: <br><br><pre> 00402043 55 PUSH EBP
 00402044 8BEC MOV EBP, ESP
 00402046 53 PUSH EBX
 00402047 68 70504000 PUSH OFFSET 00405070;  start of the entered string
 0040204C FF35 9C504000 PUSH [DWORD DS: 40509C]
 00402052 E8 FFF2FFFF CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  Jump to kernel32.GetProcAddress
 00402057 6A 66 PUSH 66
 00402059 FF75 08 PUSH [DWORD SS: EBP + 8]
 0040205C FFD0 CALL EAX
 0040205E 50 PUSH EAX
 0040205F 68 7B504000 PUSH OFFSET 0040507B;  12th character of the entered string
 00402064 FF35 9C504000 PUSH [DWORD DS: 40509C]
 0040206A E8 E7F2FFFF CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  Jump to kernel32.GetProcAddress
 0040206F 5B POP EBX
 00402070 53 PUSH EBX
 00402071 FFD0 CALL EAX
 00402073 68 70504000 PUSH OFFSET 00405070;  start of the entered string                     
 00402078 FF35 9C504000 PUSH [DWORD DS: 40509C]
 0040207E E8 D3F2FFFF CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  Jump to kernel32.GetProcAddress
 00402083 68 E8030000 PUSH 3E8
 00402088 FF75 08 PUSH [DWORD SS: EBP + 8]
 0040208B FFD0 CALL EAX
 0040208D 50 PUSH EAX
 0040208E 68 7B504000 PUSH OFFSET 0040507B;  12th character of the entered string
 00402093 FF35 9C504000 PUSH [DWORD DS: 40509C]
 00402099 E8 B8F2FFFF CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  Jump to kernel32.GetProcAddress
 0040209E 5B POP EBX
 0040209F 6A 00 PUSH 0
 004020A1 53 PUSH EBX
 004020A2 FFD0 CALL EAX
</pre><br>  Four GetProcAddress, in which parts of the string entered by us are transferred!  The first time is the address of the beginning of the line, the second is the address of 12 characters, and then again the beginning and again the 12th character.  As we remember, in place of 11 characters (which should be a minus) zero is written.  Now it is clear that this is necessary in order to pass a string to GetProcAddress null-terminated. <br>  Now you can set a well-defined task: find two functions from user32.dll (this is indicated by the handle passed to GetProcAddress), each of which has two parameters (the number of push'e before the call eax), and the first has a length of ten characters. <br>  Let's narrow down the search by looking at the transmitted parameters and comparing them with what should happen after clicking the Enable button.  We have already seen SetDlgItemTextA with a cheering inscription, and there is a possibility that it will appear in the first input field, since we still need the second one.  And the second field should be made active, we after all still click on the Enable button! <br>  To quickly look at all the functions having a length of 10 characters from user32.dll, I used the search in the built-in spotlight editor for the file <code>%fasm_directory%\INCLUDE\API\USER32.INC</code> .  For the search applied regexp <code>'\s\i{10}\,'</code> .  It was possible to further select from the functions found those that I have two parameters, but this was not necessary, since <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms645481(v%3Dvs.85).aspx">GetDlgItem</a> ideally fits the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms645481(v%3Dvs.85).aspx">meaning</a> .  A confirmation of this thought is the ‚Äúmagic constant‚Äù 66h, which is the ID of the second, as yet inactive input field (this can be seen with the help of zDump or a similar utility).  This value is the first parameter of GetDlgItem. <br>  It remains only to activate the second input field.  For two parameters, this is perfectly able to do <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646291(v%3Dvs.85).aspx">EnableWindow</a> . <br>  Check the found string <b>GetDlgItem-EnableWindow</b> and ... success! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/948/6a9/d7f/9486a9d7fa1b41da9245e9e376e760f5.jpg"></div><br><br>  With the first input field sorted out, go to the "main dish". <br><br><h4>  Second edit and decisive blow to the Check button </h4><br>  Since the replacement of the window procedure was done only for one edit'a, the text from the second should (in any case there is reason to hope for it) be extracted in a more trivial way.  Use the command Search for -&gt; All intermodular calls and see what can be used to get the text from the second input field. <br><br><div class="spoiler">  <b class="spoiler_title">All intermodular calls</b> <div class="spoiler_text"><pre> 0040103C CALL &lt;JMP. &amp; USER32.DialogBoxParamA&gt; 7684CB0C USER32.DialogBoxParamA TemplateName = 1, hParent = NULL, DialogProc = Chiwaka1.401061, InitParam = 0
 004011B2 CALL &lt;JMP. &amp; USER32.DialogBoxParamA&gt; 7684CB0C USER32.DialogBoxParamA TemplateName = 2, hParent = NULL, DialogProc = Chiwaka1.401206, InitParam = 0
 004011C4 CALL &lt;JMP. &amp; USER32.EndDialog&gt; 7682B99C USER32.EndDialog Result = 0
 00401214 CALL &lt;JMP. &amp; USER32. EndDialog&gt; 7682B99C USER32. EndDialog Result = 1
 0040123D CALL &lt;JMP. &amp; USER32.EndDialog&gt; 7682B99C USER32.EndDialog Result = 1
 0040104C CALL &lt;JMP. &amp; KERNEL32.ExitProcess&gt; 765779C8 kernel32.ExitProcess
 00401072 CALL &lt;JMP. &amp; USER32. GetDlgItem&gt; 7682F1BA USER32. GetDlgItem ItemID = 101.
 00401002 CALL &lt;JMP. &amp; KERNEL32. GetModuleHandleA&gt; 76571245 kernel32. GetModuleHandleA ModuleName = NULL
 00401091 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt; 76571222 kernel32. GetProcAddress Procname = "" 10, "&amp; 7", 14, "* - ', 4", 0F, ", - $", 02
 00401168 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt; 76571222 kernel32. GetProcAddress Procname = "" 04, "&amp; 7", 07, "/ $", LF, "7 &amp;.", 17, "&amp;; 7", 02
 00401268 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt; 76571222 kernel32. GetProcAddress
 004010C4 CALL &lt;JMP. &amp; USER32.SendMessageA&gt; 7681612E USER32.SendMessageA Msg = WM_COMMAND
 0040111C CALL &lt;JMP. &amp; USER32. SetDlgItemTextA&gt; 7681C4D6 USER32. SetDlgItemTextA ControlID = 101., Text = "Well done! Keep going ;-)"
 004011DC CALL &lt;JMP. &amp; USER32.SetDlgItemTextA&gt; 7681C4D6 USER32.SetDlgItemTextA ControlID = 101., Text = "Careful now !!"
</pre></div></div><br>  The most suitable candidate for the function, the text from the second input field, seems to be one of GetProcAddress, which probably gets the address <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms645489(v%3Dvs.85).aspx">GetDlgItemTextA</a> .  To verify this, run the program, unlock the second field with the found string, and then set the breakpoints on all three GetProcAddress.  Now you can click on Check and make sure that the predictions are correct. <br><br><pre> 0040115D |&gt; \ 68 46504000 PUSH OFFSET 00405046;  / Procname = "GetDlgItemTextA"
 00401162 |.  FF35 9C504000 PUSH [DWORD DS: 40509C];  | hModule = 767F0000 ('USER32')
 00401168 |.  E8 E9010000 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  \ KERNEL32.GetProcAddress    
 0040116D |.  6A 40 PUSH 40
 0040116F |.  68 70504000 PUSH OFFSET 00405070
 00401174 |.  6A 66 PUSH 66
 00401176 |.  FF75 08 PUSH [DWORD SS: EBP + 8]
 00401179 |.  FFD0 CALL EAX
</pre><br>  Next, it checks the number of characters entered (GetDlgItemText returns it to EAX), writes this value to memory, and calls four functions.  Most likely, it is in these four functions that some actions take place with the string, so we examine them in turn. <br><br>  Having glanced in the first call, we observe some frauds with characters in the string, performed in a loop until the detection of the first zero (402126): <br><br><div class="spoiler">  <b class="spoiler_title">CALL 00402101</b> <div class="spoiler_text"><pre> 00402101 8D05 70504000 LEA EAX, [405070];  string entered
 00402107 EB 1D JMP SHORT 00402126
 00402109 8038 40 CMP [BYTE DS: EAX], 40;  40h = @ (the last character in ASCII before the uppercase Latin letter)
 0040210C 76 0A JBE SHORT 00402118
 0040210E 8038 5B CMP [BYTE DS: EAX], 5B;  5Bh = [(first character after uppercase latin)
 00402111 73 05 JAE SHORT 00402118
 00402113 8000 20 ADD [BYTE DS: EAX], 20;  20h - the difference between letters in different registers
 00402116 EB 0D JMP SHORT 00402125
 00402118 8038 60 CMP [BYTE DS: EAX], 60;  60h = '(the last character before the Latin in lowercase)
 0040211B 76 08 JBE SHORT 00402125
 0040211D 8038 7B ‚Äã‚ÄãCMP [BYTE DS: EAX], 7B;  7Bh = {(the first character after the Latin in lowercase)
 00402120 73 03 JAE SHORT 00402125
 00402122 8028 20 SUB [BYTE DS: EAX], 20;  20h - the difference between letters in different registers                 
 00402125 40 INC EAX
 00402126 8038 00 CMP [BYTE DS: EAX], 0
 00402129 75 DE JNE SHORT 00402109
 0040212B C3 RETN
</pre></div></div><br>  Looking closely at the constants that are encountered here, and then to the ASCII table, it is easy to see that this call inverts the register of each of the entered characters.  It was all very simple. <br><br><div class="spoiler">  <b class="spoiler_title">CALL 00402133</b> <div class="spoiler_text"><pre> 00402133 53 PUSH EBX
 00402134 33DB XOR EBX, EBX
 00402136 33D2 XOR EDX, EDX
 00402138 8D05 70504000 LEA EAX, [405070];  string entered
 0040213E 50 PUSH EAX
 0040213F 8B0D A5504000 MOV ECX, [DWORD DS: 4050A5]
 00402145 51 PUSH ECX
 00402146 49 DEC ECX
 00402147 8A1401 MOV DL, [BYTE DS: EAX + ECX]
 0040214A 8893 A9504000 MOV [BYTE DS: EBX + 4050A9], DL
 00402150 43 INC EBX
 00402151 83F9 00 CMP ECX, 0
 00402154 ^ 75 F0 JNE SHORT 00402146
 00402156 59 POP ECX
 00402157 58 POP EAX
 00402158 49 DEC ECX
 00402159 33DB XOR EBX, EBX
 0040215B 33D2 XOR EDX, EDX
 0040215D 33C0 XOR EAX, EAX
 0040215F EB 1A JMP SHORT 0040217B
 00402161 8A99 70504000 MOV BL, [BYTE DS: ECX + 405070];  string entered
 00402167 8A90 70504000 MOV DL, [BYTE DS: EAX + 405070];  string entered
 0040216D 8891 70504000 MOV [BYTE DS: ECX + 405070], DL
 00402173 8898 70504000 MOV [BYTE DS: EAX + 405070], BL
 00402179 49 DEC ECX
 0040217A 40 INC EAX
 0040217B 83F8 05 CMP EAX, 5
 0040217E ^ 72 E1 JB SHORT 00402161
 00402180 C605 7A504000 4 MOV [BYTE DS: 40507A], 41
 00402187 5B POP EBX
 00402188 C3 RETN
</pre></div></div><br>  The second call is a little bigger, and several actions are performed in it.  The first thing is to copy the entered string back to another place in memory using the following cycle: <br><br><pre> 00402146 49 DEC ECX
 00402147 8A1401 MOV DL, [BYTE DS: EAX + ECX]
 0040214A 8893 A9504000 MOV [BYTE DS: EBX + 4050A9], DL
 00402150 43 INC EBX
 00402151 83F9 00 CMP ECX, 0
 00402154 ^ 75 F0 JNE SHORT 00402146
</pre><br>  Next, the same thing happens with the source string, but only 10 characters are inverted.  This may indicate that in the future only they will be used, but it is too early to make plans. <br>  Finally, the 11th position of the original string of the character 'A' is written: <br><br><pre> 00402180 C605 7A504000 4 MOV [BYTE DS: 40507A], 41
</pre><br>  Remembering what technique has already been used in this crack, it can be assumed that there will be something similar here, but the WinAPI function will not be introduced in a ready-made form. <br><br>  CALL 00401285 brings us one more call: <br><br><div class="spoiler">  <b class="spoiler_title">CALL 004012C4</b> <div class="spoiler_text"><pre> 004012C4 / $ 8D05 BD504000 LEA EAX, [4050BD]
 004012CA |.  33D2 XOR EDX, EDX
 004012CC |.  8A15 F0204000 MOV DL, [BYTE DS: 4020F0]
 004012D2 |.  8810 MOV [BYTE DS: EAX], DL
 004012D4 |.  8A15 31214000 MOV DL, [BYTE DS: 402131]
 004012DA |.  8850 01 MOV [BYTE DS: EAX + 1], DL
 004012DD |.  8A15 AE204000 MOV DL, [BYTE DS: 4020AE]
 004012E3 |.  8850 02 MOV [BYTE DS: EAX + 2], DL
 004012E6 |.  8A15 CF204000 MOV DL, [BYTE DS: 4020CF]
 004012EC |.  8850 03 MOV [BYTE DS: EAX + 3], DL
 004012EF |.  8A15 41204000 MOV DL, [BYTE DS: 402041]
 004012F5 |.  8850 04 MOV [BYTE DS: EAX + 4], DL
 004012F8 |.  8A15 40204000 MOV DL, [BYTE DS: 402040]
 004012FE |.  8850 05 MOV [BYTE DS: EAX + 5], DL
 00401301 |.  8A15 31214000 MOV DL, [BYTE DS: 402131]
 00401307 |.  8850 06 MOV [BYTE DS: EAX + 6], DL
 0040130A |.  8A15 05204000 MOV DL, [BYTE DS: 402005]
 00401310 |.  8850 07 MOV [BYTE DS: EAX + 7], DL
 00401313 |.  8A15 83124000 MOV DL, [BYTE DS: 401283]
 00401319 |.  8850 08 MOV [BYTE DS: EAX + 8], DL
 0040131C |.  8A15 5B124000 MOV DL, [BYTE DS: 40125B]
 00401322 |.  8850 09 MOV [BYTE DS: EAX + 9], DL
 00401325 \.  C3 RETN
</pre></div></div><br>  Here there are manipulations with memory, which is not connected either with the source line or with its copy, so without going into the details of what is happening, let's see what happens after the return.  After the return, a copy of the entered string is processed using xor'a.  Most likely, one of these two lines should end up being a WinAPI function, and something should be a message about successful registration. <br><br>  Everything will clarify the last call. <br><br><div class="spoiler">  <b class="spoiler_title">CALL 0040125D</b> <div class="spoiler_text"><pre> 0040125D / $ 68 70504000 PUSH OFFSET 00405070;  / Procname = "the entered string backwards with an inverted register and an 'A' at the end"
 00401262 |.  FF35 9C504000 PUSH [DWORD DS: 40509C];  | hModule = 767F0000 ('USER32')
 00401268 |.  E8 E9000000 CALL &lt;JMP. &amp; KERNEL32. GetProcAddress&gt;;  \ KERNEL32.GetProcAddress
 0040126D |.  6A 30 PUSH 30
 0040126F |.  68 BB124000 PUSH 004012BB;  ASCII "API API"
 00401274 |.  68 A9504000 PUSH OFFSET 004050A9;  ASCII "entered string backwards with inverted register, to which xor is applied"
 00401279 |.  6A 00 PUSH 0
 0040127B |.  FFD0 CALL EAX
 0040127D \.  C3 RETN
</pre></div></div><br>  It remains quite a bit: again to solve the puzzle to find a suitable WinAPI function.  Here is what we know about her: <br><ul><li>  the length of the name is 11 characters; the letter A is at the end </li><li>  is in user32.dll </li><li>  four parameters are passed, two of them are strings </li></ul><br>  To search for a suitable function, I used the <code>%fasm_directory%\INCLUDE\PCOUNT\USER32.INC</code> using the following regular expression <code>'^\i{10}\%\s\=\s\s4'</code> .  The ANSI versions of functions are not duplicated in this file, so a large A at the end cannot be specified.  There were not so many suitable functions, but only one is perfect in its meaning: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms645505(v%3Dvs.85).aspx">MessageBoxA</a> . <br>  Remembering what operations are performed with it before passing it to GetProcAddress, we transform accordingly: MessageBox - (case inversion) - mESSAGEbOX - (character order inversion) - <b>XObEGASSEm</b> . <br>  Let's enter the treasured line in the second input field and get a winning MessageBox with a window title that reminds of adventures! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e2e/f0d/8d3/e2ef0d8d36ed4cc68712cb7883600586.jpg"></div><br><br><h3>  Instead of conclusion </h3><br>  Crackmy examined demonstrates an interesting way to firmly bind protection to the work of the program itself.  The mechanism used makes it very difficult to patch.  It is hard for me to imagine the use of such a method in commercial protection (but I will be happy if someone talks about examples), but for a puzzle for a couple of days it is very good, especially for beginners. </div><p>Source: <a href="https://habr.com/ru/post/263093/">https://habr.com/ru/post/263093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263083/index.html">Build docker containers with docker containers</a></li>
<li><a href="../263085/index.html">Site security audit through the eyes of the customer</a></li>
<li><a href="../263087/index.html">IOS development testing</a></li>
<li><a href="../263089/index.html">Automatic search for routers with standard passwords</a></li>
<li><a href="../263091/index.html">Pacemaker-based HA-Cluster for LXC and Docker container virtualization</a></li>
<li><a href="../263097/index.html">Event-oriented Python backtesting step by step. Part 1</a></li>
<li><a href="../263099/index.html">Skype turned to people?</a></li>
<li><a href="../263101/index.html">Work with passwords: how to protect your accounts (expert opinion)</a></li>
<li><a href="../263103/index.html">Unobvious performance problems in Doctrine related to the hydration of objects</a></li>
<li><a href="../263105/index.html">Getting rid of the ‚Äúhistorical reasons‚Äù in cmd.exe in an easier and standard way.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>