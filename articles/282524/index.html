<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Message system or ‚Äúsoft coupling‚Äù between components for Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This article will address topics related to the implementation of the ‚Äúsoft coupling‚Äù of game logic components based on the message sys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Message system or ‚Äúsoft coupling‚Äù between components for Unity3D</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  This article will address topics related to the implementation of the ‚Äúsoft coupling‚Äù of game logic components based on the message system when developing games on Unity3D. <br><br>  It is not a secret for anybody that in the overwhelming majority of cases the means provided by the engine in its basic form are not enough to fully implement data exchange systems between game components.  In the most primitive version, from which everyone starts, we get information through an object instance.  This instance can be obtained in various ways from a reference to the scene object, to the Find functions.  This is not convenient, makes the code non-flexible, and forces the programmer to provide for a variety of non-standard logic behaviors: from ‚Äúthe object disappeared from the scene‚Äù to ‚Äúthe object is not active‚Äù.  Among other things, the speed of the written code may suffer. <br><a name="habracut"></a><br>  Before we begin to consider ways to solve a problem, let us dwell on its assumptions and basic terms, which will be mentioned below.  To begin with, what is meant by a ‚Äúsoft bond‚Äù.  In this case, it is the exchange of data between the components of the game logic in such a way that these components know absolutely nothing about each other.  On this basis, any references to objects of the scene or the search for an object in the scene by name or type give us a ‚Äúhard link‚Äù.  If these connections begin to line up in chains, then in case of need to change the behavior of logic, the programmer will have to reconfigure everything anew.  As it is not difficult to guess, the flexibility here does not smell.  Of course, you can write an extension for the editor that will automatically fill in the links, but this does not solve another problem - component-wise testing of game logic. <br><br>  To make the above written more understandable, consider a simple example.  In the logic of our spherical game there are several components: a weapon, an enemy, and a bullet.  Having made a shot from the weapon, we should receive the following information: whether or not a bullet hit the enemy, if it hit, how much damage it caused to the enemy, if it did damage, then the enemy died or not.  In addition, we have to transfer some of this information to other components, such as a graphical interface, which will show us the amount of damage done, the amount of health the enemy has and the amount of ammunition in the weapon.  This may also include the display of the corresponding effects of the shot, hit, and also animation, etc ... It is not difficult to imagine the number of relationships and the transmitted data.  Implementing this on a ‚Äúhard link‚Äù can be, however, what happens if we need to test the logic of a bullet, if we still have no weapons and no enemies, or test the logic of the interface, but we have neither weapon logic nor enemies, no bullets, or we wanted to replace the bullet with a rocket.  It is precisely the solution of this problem that dictates the need to create ‚Äúsoft connection‚Äù systems, which will allow us to easily imitate various components, even if they do not already exist, and also to change them without changing the code associated with them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us dwell in more detail on the basic principle of the implementation of the ‚Äúsoft connection‚Äù.  As mentioned above, in order to ‚Äúsoftly‚Äù connect the two components, we must transfer data from one to another, so that they do not know anything about each other.  In order to ensure this, we need to get data not on request (having an object instance on hand), but to use a notification mechanism.  In fact, this means that when any events occur in the object / component, we do not ask this object about its state, the object itself notifies that changes have occurred in it.  A set of such notifications forms an interface (not to be confused with an interface in C #), through which the game logic gets data about our object.  It can be visualized as follows: <br><br><img src="https://habrastorage.org/files/908/761/6de/9087616de12a4677a0795a9c44bb859c.png"><br><br>  Thus, any component of the system through the notification interface can get the necessary data about the object of the game logic, while the presence of the object itself for testing the related components is optional, we just have to implement the interface and then replace it with a working instance. <br><br>  Let us consider in more detail how to implement the mechanism described above, as well as their pros and cons. <br><br><h4>  UnityEvents / UnityAction based messaging system </h4><br>  This system appeared relatively recently (in version 5 of the Unity3D engine).  An example of how to implement a simple message system can be viewed at this <a href="https://unity3d.com/ru/learn/tutorials/modules/intermediate/live-training-archive/events-creating-simple-messaging-system">link</a> . <br><br>  Advantages of using this method: <br><br><ul><li>  Built in Unity feature. </li></ul><br>  Minuses: <br><br><ul><li>  Built-in Unity feature (not always native systems are better). </li><li>  Not flexible due to the use of <b>UnityAction</b> (although this can be bypassed), which gives a limit on the number of parameters (four maximum). </li><li>  Not flexible because of the difficulties with changing the parameters of the message, as it is necessary in many places of the code to change types, handlers, etc. </li><li>  It is not clear why to use if there is an <b>event / delegate</b> in C #. </li></ul><br><h4>  Classic C # on Event / Delegate </h4><br>  The easiest and most efficient way to implement communication of components based on notifications is to use the <b>event / delegate</b> pair, which is part of the C # language (for more information, see the articles on habr or msdn). <br><br>  There are many different options for implementing a message system based on <b>event / delegate</b> , some of them can be found on the Internet.  I will give an example, in my opinion, the most convenient system, but first I want to mention one important detail associated with the use of event.  If the event has no subscribers, then an error will occur when the event is triggered, so a null check is required before use.  This is not very convenient.  Of course, you can write a wrapper for each event, where a check for null will be performed, but this is no longer convenient.  Let's turn to implementation. <br><br><div class="spoiler">  <b class="spoiler_title">First, we define the message interface for our logic object:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Message Interface public partial class GameLogicObject { public delegate void StartEventHandler(); public delegate void ChangeHealthEventHandler(int health); public delegate void DeathEventHandler(); public static event StartEventHandler StartEvent; public static event ChangeHealthEventHandler ChangeHealthEvent; public static event DeathEventHandler DeathEvent; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">The call for notifications is done as follows (example):</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameLogicObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StartEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { StartEvent(); } StartCoroutine(ChangeHealth()); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeHealth</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Health = Mathf.Clamp(Health - UnityEngine.Random.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ChangeHealthEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ChangeHealthEvent(Health); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DeathEvent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { DeathEvent(); } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StartCoroutine(ChangeHealth()); } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">The interface and logic are formed, now nothing prevents us from using it in any other place and subscribing to the necessary notifications:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GUILogic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text HealthInfo; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text StateInfo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameLogicObject.StartEvent += GameLogicObject_StartEventHandler; GameLogicObject.ChangeHealthEvent += GameLogicObject_ChangeHealthEventHandler; GameLogicObject.DeathEvent += GameLogicObject_DeathEventHandler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameLogicObject_DeathEventHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StateInfo.text = <span class="hljs-string"><span class="hljs-string">"Im died"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameLogicObject_ChangeHealthEventHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> healthValue</span></span></span><span class="hljs-function">)</span></span> { HealthInfo.text = healthValue.ToString(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameLogicObject_StartEventHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StateInfo.text = <span class="hljs-string"><span class="hljs-string">"Im going"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameLogicObject.StartEvent -= GameLogicObject_StartEventHandler; GameLogicObject.ChangeHealthEvent -= GameLogicObject_ChangeHealthEventHandler; GameLogicObject.DeathEvent -= GameLogicObject_DeathEventHandler; } }</code> </pre><br></div></div><br>  As you can see from the example, the subscription occurs in the <b>OnEnable</b> method, and the unsubscribe in <b>OnDisable is</b> , in this case, mandatory, otherwise a memory leak and a null reference exception are guaranteed if the object is removed from the game.  The subscription itself can be done at any desired time, it is not necessary to do this only in <b>OnEnable</b> . <br><br>  It is easy to see that with this approach, we can test without any problems the work of the <b>GUILogic</b> class, even in the absence of real <b>GameLogicObject</b> logic.  It is enough to write a simulator using the notification interface and use calls of the form <b>GameLogicObject.StartEvent</b> (). <br><br>  What are the benefits of this implementation: <br><br><ul><li>  The standard mechanism of the language C #, as a result of 100% cross-platform without dancing with tambourines. </li><li>  The simplicity of the system implementation (without additional investments in the code). </li></ul><br>  Minuses: <br><br><ul><li>  It is necessary to monitor the memory (unsubscribe from notifications).  With large amounts of code, it is easy to forget to unsubscribe from one event and then catch bugs for a long time. </li><li>  It is necessary to unsubscribe from events if the scene object is deactivated for a while, otherwise the handler will be called for it. </li><li>  Not flexible due to the difficulties with changing the parameters of the message, as it is necessary in many places in the code to change the types, handlers, calls, etc. </li><li>  Please note that the event may not have subscribers. </li></ul><br><h4>  Reflection message system with identification on string </h4><br>  Before proceeding to the description of the system and its implementation, I would like to highlight the prerequisites that pushed for its creation.  Before coming to these thoughts in my applications, I used the system described above based on event / delegate.  Those projects that I had to develop at that time were relatively simple, they needed speed of implementation, a minimum of bugs on the tests, the exception to the maximum of the human factor in the development phase of the game logic.  Based on this, a number of some requirements regarding the exchange of data between components were born: <br><br><ul><li>  Automatically subscribe to events. </li><li>  No need to keep track of memory (self-cleaning system). </li><li>  No need to follow subscribers, the system should work even if they are not. </li></ul><br>  The result of a brief reflection was the birth of the idea to use reflection through the attributes of class / component methods. <br><br><div class="spoiler">  <b class="spoiler_title">Identify the class method as an event handler:</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">GlobalMessanger.MessageHandler</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCustomEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre><br></div></div><br>  <b>GlobalMessanger.MessageHandler</b> is an attribute that tells us that the method is an event handler.  In order to determine the type of event that this method handles, there are two ways (although in fact there may be more): <br><br><ol><li>  Specify event type in attribute parameters: <pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">GlobalMessanger.MessageHandler(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CustomEvent"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre></li><li>  Use event type in method name with ‚ÄúOn‚Äù prefix (or any other).  I use this method, because in 100% of cases, so as not to be confused, I name the methods in this way. </li></ol><br>  In order to make a subscription in automatic mode, again, there are two ways: <br><br><ol><li>  Use the script that will search for all components on the object, and then, through reflection, look for methods with an attribute in them.  In order not to add this script by hand, it will be enough in all components where it is needed, put down <pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">RequireComponent(typeof(AutoSubsciber))</span></span>]</code> </pre><br>  I personally find this method less convenient than the second, since it requires extra gestures. <br></li><li>  Creating a wrapper on the MonoBehaviour class: <br><br><div class="spoiler">  <b class="spoiler_title">CustomBehaviour</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomBehaviour</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BindingFlags m_bingingFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> methodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType().GetMethod(methodName, m_bingingFlags); GlobalMessanger.Instance.RegisterMessageHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> methodName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType().GetMethod(methodName, m_bingingFlags); GlobalMessanger.Instance.UnregisterMessageHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methods = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType().GetMethods(m_bingingFlags); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(MethodInfo mi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> methods) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mi.GetCustomAttributes(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GlobalMessanger.MessageHandler), <span class="hljs-literal"><span class="hljs-literal">true</span></span>).Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GlobalMessanger.Instance.RegisterMessageHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, mi); } } } }</code> </pre><br></div></div></li></ol><br>  As you can see, this wrapper contains two methods that allow you to subscribe and unsubscribe from the event (the type of event is taken from the method name).  They are necessary if we need to subscribe to the event in the course of the logic.  Automatic subscription is done in the Awake method.  Cancellation of events is carried out automatically, but more on that later. <br><br><div class="spoiler">  <b class="spoiler_title">We define the subscription and event call management system:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GlobalMessanger</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GlobalMessanger m_instance; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GlobalMessanger Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_instance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"!GlobalMessanger"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GlobalMessanger)); m_instance = go.GetComponent&lt;GlobalMessanger&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_instance; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHandler</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHandlerData</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Container; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MethodInfo Method; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Hashtable m_handlerHash = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hashtable(); }</code> </pre><br></div></div><br>  The <b>GlobalMessanger</b> class is a regular Unity component, accessed on the basis of a Unity-singleton.  In this case, a separate scene object is created for this component, which exists only inside it and will be deleted when the scene is unloaded.  Since our events are identified on the basis of strings, I decided to store information about events and subscribers in a hash table. <br><br><div class="spoiler">  <b class="spoiler_title">Now we need methods to register / delete subscribers:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterMessageHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> container, MethodInfo methodInfo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodName = methodInfo.Name; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageID = methodName.Substring(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_handlerHash.ContainsKey(messageID)) { RegisterMessageDefinition(messageID); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageHanlders = (List&lt;MessageHandlerData&gt;)m_handlerHash[messageID]; messageHanlders.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageHandlerData() { Container = container, Method = methodInfo }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterMessageHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> container, MethodInfo methodInfo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodName = methodInfo.Name; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageID = methodName.Substring(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_handlerHash.ContainsKey(messageID)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageHanlders = (List&lt;MessageHandlerData&gt;)m_handlerHash[messageID]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; messageHanlders.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mhd = messageHanlders[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mhd.Container == container &amp;&amp; mhd.Method == methodInfo) { messageHanlders.Remove(mhd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Next, we need a method to call events and subscribers to them:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Call</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> messageID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] parameter = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_handlerHash.ContainsKey(messageID)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hanlderList = (List&lt;MessageHandlerData&gt;) m_handlerHash[messageID]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hanlderList.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mhd = hanlderList[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unityObject = (MonoBehaviour)mhd.Container; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unityObject != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unityObject.gameObject.activeSelf) { mhd.Method.Invoke(mhd.Container, parameter); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m_removedList.Add(mhd); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_removedList.Count; i++) { hanlderList.Remove(m_removedList[i]); } m_removedList.Clear(); } }</code> </pre><br></div></div><br>  As you can see, when an event is triggered, a check is made for the existence of the object and the activity of the object.  In the first case, the deleted object is removed from the subscribers, in the second it is ignored when calling event-handling methods.  Thus, it is not necessary to follow the unsubscribing of events at the remote object, everything is done automatically.  At the same time, if the object was temporarily deactivated, it is not possible to unsubscribe from the events and re-subscribe, as well as to call the presence of subscribers to the event is not necessary. <br><br><div class="spoiler">  <b class="spoiler_title">The last thing that is required of us is to clean up the scene after unloading:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> m_handlerHash.Values) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageHanlders = (List&lt;MessageHandlerData&gt;)handlers; messageHanlders.Clear(); } m_handlerHash.Clear(); m_handlerHash = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br></div></div><br>  It is easy to see that the system described above does not represent anything extraordinary and does not carry revelations, but it is simple and convenient and well suited for relatively small projects. <br><br><div class="spoiler">  <b class="spoiler_title">An example of using this system:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Message Interface public partial class GameLogicObject { public static void StartEvent() { GlobalMessanger.Instance.Call("StartEvent"); } public static void ChangeHealthEvent(int value) { GlobalMessanger.Instance.Call("ChangeHealthEvent", new object[] { value }); } public static void DeathEvent() { GlobalMessanger.Instance.Call("DeathEvent"); } } // Event source public partial class GameLogicObject : MonoBehaviour { public int Health = 100; void Start() { StartEvent(); StartCoroutine(ChangeHealth()); } IEnumerator ChangeHealth() { yield return new WaitForSeconds(1f); Health = Mathf.Clamp(Health - UnityEngine.Random.Range(1, 20), 0, 100); ChangeHealthEvent(Health); if (Health == 0) { DeathEvent(); }else { StartCoroutine(ChangeHealth()); } } } // Event subsciber public class GUILogic : MonoBehaviour { public Text HealthInfo; public Text StateInfo; [GlobalMessanger.MessageHandler] private void OnDeathEvent() { StateInfo.text = "Im died"; } [GlobalMessanger.MessageHandler] private void OnChangeHealthEvent(int healthValue) { HealthInfo.text = healthValue.ToString(); } [GlobalMessanger.MessageHandler] private void OnStartEvent() { StateInfo.text = "Im going"; } }</span></span></code> </pre><br></div></div><br>  I think it is immediately noticeable how much the code has reduced compared to the event / delegate, which personally pleases me. <br><br>  What are the benefits of this implementation: <br><br><ul><li>  Automatically subscribe to events. </li><li>  There is no need to follow the unsubscribe from the events (even in the case of a manual subscription). </li><li>  Relatively simple implementation. </li><li>  Convenient reading of the code, the attributes easily show who is the event handler and which ones. </li><li>  Less code than event / delegate </li><li>  There is no need to think that the event has no subscribers. </li></ul><br>  Minuses: <br><br><ul><li>  Since the cancellation of events takes place in a deferred mode, on very large projects, it will probably take up extra memory, but this can be easily solved by manually unsubscribing events, just as it was shown in the section on event / delegate. </li><li>  Binding to strings, because if you want to make the event name more beautiful, you will have to change it in many places. </li><li>  There is no flexibility in the parameters and data types of events, changes require many actions on the code. </li><li>  There may be problems with cross-platform due to the use of reflection. </li></ul><br><h4>  Reflection message system with identifications on data types </h4><br>  In the previous section, the system was described as more convenient (in my opinion) as compared to <b>event / delegate</b> , but it still has a number of flaws that greatly affect the flexibility of our code, so the next step was its development taking these factors into account. <br><br>  So, we need to retain all the advantages of the previous system, but to make it more flexible and more resistant to possible changes in the game logic.  Since the main problem is the change of the name of the event and the parameters passed, the idea arose to identify the events by them.  In fact, this means that any event that occurs in a component is characterized by nothing more than the data that it transmits.  Since we cannot simply bind to standard types (int, float, etc.), because in logic such data can transmit many components, the logical step was to make a wrapper over them that would be convenient, easy to read, and unambiguously interpretive. event. <br><br><div class="spoiler">  <b class="spoiler_title">Thus, our messaging interface took the following form:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObjectLogic</span></span> { [GEvents.EventDescription(HandlerRequirement = GEvents.HandlerRequirementType.NotRequired)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StartEvent</span></span> : <span class="hljs-title"><span class="hljs-title">GEvents</span></span>.<span class="hljs-title"><span class="hljs-title">BaseEvent</span></span>&lt;<span class="hljs-title"><span class="hljs-title">StartEvent</span></span>&gt; { } [GEvents.EventDescription(HandlerRequirement = GEvents.HandlerRequirementType.Required)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChangeHealthEvent</span></span> : <span class="hljs-title"><span class="hljs-title">GEvents</span></span>.<span class="hljs-title"><span class="hljs-title">BaseEvent</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ChangeHealthEvent</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeHealthEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } [GEvents.EventDescription(HandlerRequirement = GEvents.HandlerRequirementType.Required)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeathEvent</span></span> : <span class="hljs-title"><span class="hljs-title">GEvents</span></span>.<span class="hljs-title"><span class="hljs-title">BaseEvent</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DeathEvent</span></span>&gt; { } }</code> </pre><br></div></div><br>  As you can see, events have attributes.  This gives us the opportunity to get debug information if the event requires a subscriber, but for some reason it is not in the code. <br><br>  The Call event method (and its overloads), which we previously had in the <b>GlobalMessanger</b> class, is now static and is in <b>GEvents.BaseEvent</b> and now takes as an argument an instance of the class that describes the type of event. <br><br><div class="spoiler">  <b class="spoiler_title">The notification call code will now be like this:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameLogicObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartEvent.Call(); <span class="hljs-comment"><span class="hljs-comment">//    StartCoroutine(ChangeHealth()); } IEnumerator ChangeHealth() { yield return new WaitForSeconds(1f); Health = Mathf.Clamp(Health - UnityEngine.Random.Range(1, 20), 0, 100); ChangeHealthEvent.Call(new ChangeHealthEvent(Health)); //    if (Health == 0) { DeathEvent.Call(); //    }else { StartCoroutine(ChangeHealth()); } } }</span></span></code> </pre><br></div></div><br>  Subscribing and unsubscribing to events is carried out in the same way as before, through the method attributes, but now the event type is not identified by a string value (method name or attribute parameter), but by the method parameter type (in the example, these are StartEvent, ChangeHealthEvent and DeathEvent). <br><br><div class="spoiler">  <b class="spoiler_title">Example handler method:</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">GEvents.EventHandler</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDeathEventHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameLogicObject.DeathEvent ev</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     }</span></span></code> </pre><br></div></div><br>  Thus, using the implementation described above, we received the greatest possible flexibility in the code, because now we can change the transmitted data in events without any significant costs, we just need to change the body of the handler for the new parameters.  In the case, if we want to change the name of the event (class name), the compiler will tell us where the old version is used.  In this case, the need to change the name of the handler method completely disappears. <br><br><h4>  Total </h4><br>  I tried to describe in this article all possible methods of building data exchange systems between components based on notifications in my subjective opinion.  All these methods have been used by me in different projects and different complexity: from simple mobile projects to complex PCs.  What system to use in your project is up to you. <br><br>  PS: I deliberately did not describe in the article the construction of a message system based on SendMessage-functions, because compared to the others, it does not stand up to criticism not only in terms of convenience, but also in terms of speed. </div><p>Source: <a href="https://habr.com/ru/post/282524/">https://habr.com/ru/post/282524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282513/index.html">Microsoft Research Summer School 2016 in Kazan - Internet of Things</a></li>
<li><a href="../282517/index.html">Perfect HTTP performance</a></li>
<li><a href="../282518/index.html">How to choose a server for a small company: a guide for doubters</a></li>
<li><a href="../282520/index.html">Lightning Talk: Get your five minutes on PHDays VI</a></li>
<li><a href="../282522/index.html">Monte Carlo method for tree search</a></li>
<li><a href="../282528/index.html">Multiphone in FreePBX: full connection automation</a></li>
<li><a href="../282530/index.html">Certified FSTEK version of Veeam Backup and Replication: backing up confidential information</a></li>
<li><a href="../282532/index.html">We are looking for free IPv4 in BGP full-view</a></li>
<li><a href="../282534/index.html">Yandex Font - Yandex Sans</a></li>
<li><a href="../282536/index.html">We create a game for the smallest on Phaser in Intel XDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>