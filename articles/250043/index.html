<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing microservices using Scala, Spray, MongoDB, Docker and Ansible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The purpose of this article is to show a possible approach for building microservices using Scala , RESTful JSON, Spray and Akka . We will use MongoDB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing microservices using Scala, Spray, MongoDB, Docker and Ansible</h1><div class="post__text post__text-html js-mediator-article">  The purpose of this article is to show a possible approach for building <a href="http://technologyconversations.com/2015/01/07/monolithic-servers-vs-microservices/">microservices</a> using <a href="http://www.scala-lang.org/">Scala</a> , RESTful JSON, <a href="http://spray.io/">Spray</a> and <a href="http://akka.io/">Akka</a> .  We will use <a href="http://www.mongodb.org/">MongoDB</a> as the database.  As a result of our work, we will pack our project in a Docker container, and <a href="https://www.vagrantup.com/">Vagrant</a> and <a href="http://www.ansible.com/home">Ansible</a> will allow us to manage the application configuration. <br><br>  In this article you will not find details about the Scala language and other technologies that will be used in the project.  In it, you will not find a manual that will answer all your questions.  The purpose of the article is to show a technique that can be used in the development of microservices.  In fact, most of this article is not tied to a specific technology.  Docker has a wider scope of use than microservices.  Ansible allows you to quickly deploy any desired environment, and Vagrant is a great tool for creating virtual machines. <br><a name="habracut"></a><br>  So, let's start creating the ‚ÄúBook Service‚Äù with the following methods: <br><br><ul><li>  Get all the books </li><li>  Get information about the book </li><li>  Update existing book </li><li>  Delete existing book </li></ul><br><h4>  Environment </h4><br>  We will use Ubuntu as a server.  The easiest way to create one is to use Vagrant.  If you have not installed it yet, please download it and install it.  You will also need <a href="http://git-scm.com/">Git</a> to clone the repository with the source code.  The rest of the article does not require you to manually install additional packages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start repository cloning <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/vfarcic/books-service.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> books-service</code> </pre> <br>  Next, you need to create a Ubuntu server using Vagrant with the following settings: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- mode: ruby -*- # vi: set ft=ruby : VAGRANTFILE_API_VERSION = "2" Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.box = "ubuntu/trusty64" config.vm.synced_folder ".", "/vagrant" config.vm.provision "shell", path: "bootstrap.sh" config.vm.provider "virtualbox" do |v| v.memory = 2048 end config.vm.define :dev do |dev| dev.vm.provision :shell, inline: 'ansible-playbook /vagrant/ansible/dev.yml -c local' end config.vm.define :prod do |prod| prod.vm.provision :shell, inline: 'ansible-playbook /vagrant/ansible/prod.yml -c local' end end</span></span></code> </pre><br><br>  We defined the <i>box</i> (OS) as Ubuntu, <i>synced_folder</i> means that everything inside the ./vagrant directory on the host machine will be available inside the virtual machine.  The rest of the work on installing applications and preparing the environment we will impose on Ansible, which will be installed using bootstrap.sh.  There are two virtual machines in Vagrantfile: dev and prod.  Each of them will use Ansible, so make sure it is installed correctly. <br><br>  The classic way to work with Ansible is to divide the configuration into roles.  In our case, we have 4 roles that are in ansible / roles.  The first role includes the installation of Scala and SBT.  One more installs docker.  The third installs the MongoDB container.  The last role (books) will be used to deploy the application to the combat virtual machine. <br>  As an example, declare a mongodb role as follows: <br><br><pre> <code class="ruby hljs">- <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> Directory is present <span class="hljs-symbol"><span class="hljs-symbol">file:</span></span> path=<span class="hljs-regexp"><span class="hljs-regexp">/data/db</span></span> state=directory <span class="hljs-symbol"><span class="hljs-symbol">tags:</span></span> [mongodb] - <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> Container is running <span class="hljs-symbol"><span class="hljs-symbol">docker:</span></span> name=mongodb image=dockerfile/mongodb ports=<span class="hljs-number"><span class="hljs-number">27017</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">27017</span></span> volumes=<span class="hljs-regexp"><span class="hljs-regexp">/data/db</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/data/db</span></span> <span class="hljs-symbol"><span class="hljs-symbol">tags:</span></span> [mongodb]</code> </pre><br>  This role ensures that the folder exists and the mongodb container is running.  The ansible / dev.yml playbook links these roles together: <br><br><pre> <code class="ruby hljs">- <span class="hljs-symbol"><span class="hljs-symbol">hosts:</span></span> localhost <span class="hljs-symbol"><span class="hljs-symbol">remote_user:</span></span> vagrant <span class="hljs-symbol"><span class="hljs-symbol">sudo:</span></span> yes <span class="hljs-symbol"><span class="hljs-symbol">roles:</span></span> - scala - docker - mongodb</code> </pre><br>  Every time we start a playbook, all tasks from the scala, docker and mongodb roles are executed. <br><br>  One of the charms of Ansible is that it performs tasks only when needed.  If you run it a second time, he will check that everything is in place and will not do anything.  However, if you delete the / data / db folder, Ansible will notice the loss and create it again. <br><br>  Time to run a virtual machine!  The first launch will be a bit long since Vagrant needs to download the Ubuntu distribution, install the packages and download the MongoDB Docker image.  Subsequent launches will be noticeably faster. <br><br><pre> <code class="bash hljs">vagrant up dev vagrant ssh dev ll /vagrant</code> </pre><br><br>  The vagrant up command creates a new virtual machine or starts one of the existing ones.  With vagrant ssh, we go to the newly created machine.  Finally, ll / vagrant displays a list of files and directories as proof that our local files are available inside the virtual machine. <br>  It's all.  Our development server with Scala, SBT and MongoDB is ready for work.  Let's start developing our service. <br><br><h4>  "Book Service" </h4><br>  I like Scala, it is a very powerful language, and akka is my favorite framework for building message-driven JVM applications.  Despite the fact that Akka came from Scala, nothing prevents to use it in Java. <br>  Spray is a simple but powerful tool for building REST / HTTP services.  It is asynchronous due to the use of Akka-actors and has a wonderful DSL for describing HTTP routes. <br>  In <a href="http://technologyconversations.com/2014/09/30/test-driven-development-tdd/">TDD</a> fashion, we write tests before implementation.  Here is an example of tests that checks the route on which the list of books is given. <br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"GET /api/v1/books"</span></span> should { <span class="hljs-string"><span class="hljs-string">"return OK"</span></span> in { <span class="hljs-type"><span class="hljs-type">Get</span></span>(<span class="hljs-string"><span class="hljs-string">"/api/v1/books"</span></span>) ~&gt; route ~&gt; check { response.status must equalTo(<span class="hljs-type"><span class="hljs-type">OK</span></span>) } } <span class="hljs-string"><span class="hljs-string">"return all books"</span></span> in { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expected = insertBooks(<span class="hljs-number"><span class="hljs-number">3</span></span>).map { book =&gt; <span class="hljs-type"><span class="hljs-type">BookReduced</span></span>(book._id, book.title, book.author) } <span class="hljs-type"><span class="hljs-type">Get</span></span>(<span class="hljs-string"><span class="hljs-string">"/api/v1/books"</span></span>) ~&gt; route ~&gt; check { response.entity must not equalTo <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> books = responseAs[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">BookReduced</span></span>]] books must haveSize(expected.size) books must equalTo(expected) } } }</code> </pre><br>  This is a simple test, which, I hope, will show the direction in which you need to move in order to develop tests for APIs built on Spray.  The first thing we check is the server, it should return the code 200 (OK) for this request.  The second thing we pay attention to is that after adding a book to the database, it returns correctly.  You can view the full source code with tests in ServiceSpec.scala <br><br>  How are these checks implemented?  The code that allows this is shown below: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> route = pathPrefix(<span class="hljs-string"><span class="hljs-string">"api"</span></span> / <span class="hljs-string"><span class="hljs-string">"v1"</span></span> / <span class="hljs-string"><span class="hljs-string">"books"</span></span>) { get { complete( collection.find().toList.map(grater[<span class="hljs-type"><span class="hljs-type">BookReduced</span></span>].asObject(_)) ) } }</code> </pre><br><br>  We defined the route / api / v1 / books, the GET method and the answer inside the complete () statement.  In our case, we received a list of all books from the database and converted it to the BookReduced case class.  All source code including all methods (GET, PUT, DELETE) can be found in ServiceActor.scala <br>  Both tests and implementation are given as an example, in practice they are usually more difficult.  But Spray copes with this really great. <br><br>  During development, you can run tests in quick mode. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#[  ] cd /vagrant sbt ~test-quick</span></span></code> </pre><br>  Each time the source code changes, all affected tests will be run again.  Usually, I have a terminal window open with test results; this gives me the opportunity to receive instant feedback on the quality of the code I'm working on. <br><br><h4>  Testing, building and deploying </h4><br>  Our application, like any other, needs testing, building and deploying. <br>  Let's create a Docker container with a service.  You can specify the required settings in the Dockerfile. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#[  ] cd /vagrant sbt assembly sudo docker build -t vfarcic/books-service . sudo docker push vfarcic/books-service</span></span></code> </pre><br>  We compiled the JAR (passing the tests is part of the build phase), collected the Docker container and sent it to the Docker Hub.  If you plan to reproduce these steps again, please create an account at hub.docker.com and change ‚Äúvfarcic‚Äù to your login. <br>  The container that we created contains everything you need to run our service.  It is based on Ubuntu, contains a JDK7 with MongoDB and a compiled JAR file.  This container can be run on any machine with Docker installed.  It does not require installation of additional dependencies on the server, the container is self-sufficient and can be run anywhere. <br>  Let's deploy (run) the container that we created on another virtual machine.  This is very similar to deploying an application in a production-based environment. <br>  To create a production-virtual machine, with our service you need to run the following commands: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#[    ] vagrant halt dev vagrant up prod</span></span></code> </pre><br>  The first command stops the dev-virtual machine.  Each machine requires 2GB of RAM, and if you have enough free RAM, you can skip this step.  The second command starts the production-machine, with the expanded service. <br>  After some waiting time, the virtual machine will be created, Ansible will install and start the playbook prod.yml.  It will install Docker and launch the vfarcic / books-service compiled in the previous step and sent to the Docker Hub.  During operation, it will use port 8080 and have a shared / data / db folder with the host system. <br>  Let's try what we did.  First, let's try to send a PUT request to add test data: <br><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -X PUT -d <span class="hljs-string"><span class="hljs-string">'{"_id": 1, "title": "My First Book", "author": "John Doe", "description": "Not a very good book"}'</span></span> http://localhost:8080/api/v1/books curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -X PUT -d <span class="hljs-string"><span class="hljs-string">'{"_id": 2, "title": "My Second Book", "author": "John Doe", "description": "Not a bad as the first book"}'</span></span> http://localhost:8080/api/v1/books curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -X PUT -d <span class="hljs-string"><span class="hljs-string">'{"_id": 3, "title": "My Third Book", "author": "John Doe", "description": "Failed writers club"}'</span></span> http://localhost:8080/api/v1/books</code> </pre><br>  Let's check that the service returned us the correct data: <br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> http://localhost:8080/api/v1/books</code> </pre><br>  We can delete a book: <br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -X DELETE http://localhost:8080/api/v1/books/_id/3</code> </pre><br>  Verify that the deleted book no longer exists: <br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> http://localhost:8080/api/v1/books</code> </pre><br>  In conclusion, we will try to extract a specific copy of the book: <br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> http://localhost:8080/api/v1/books/_id/1</code> </pre><br>  We tried a quick way to develop, build and deploy microservice.  Docker simplifies deployment and does not require additional dependencies.  Each service requiring JDK and MongoDB does not require installed applications on the target machine.  This is all part of a container that is running as a Docker process. <br><br><h4>  Results </h4><br>  The idea of ‚Äã‚Äãmicroservices has existed for a long time, and until recently has not received due attention, due to application compatibility problems required for the simultaneous operation of hundreds and thousands of different instances of services.  The advantages that arose through the use of microservices (separation, reduced development time, scalability, etc.) were not as significant as compared with the problems that they had while providing the right environment and deployment.  Docker and tools such as Ansible help significantly reduce effort.  With the avoidance of this problem, the most diverse microservices become in vogue because of the advantages that they carry. <br><br>  Spray is an excellent choice for microservice.  Docker-containers contain everything that is needed for the application to work, and nothing superfluous.  Using large web servers such as JBoss and WebSphere may be unreasonable for a small service.  Even small servers like Tomcat are usually not necessary.  Play!  - This is a great framework for building the RESTFul API, but it contains many things that we do not use.  Spray, on the other hand, does only one thing ‚Äî it provides asynchronous routing for the RESTFul API, and it does it perfectly. <br><br>  We can continue to expand the functionality of the service.  For example, we can add a registration and authentication module. <br>  However, this will bring us one step closer to a monolithic application.  In the world of microservices, new services should be new applications, and in the case of Docker, separate containers, each of which listens to its port and responds to requests addressed to it. <br><br>  When building microservices, you need to try to create them in such a way that they only do one or a small amount of work.  Complexity is solved by combining them together, rather than building a large monolithic application. </div><p>Source: <a href="https://habr.com/ru/post/250043/">https://habr.com/ru/post/250043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250027/index.html">Export Favorites on Habr√© to PDF. Version 2.0</a></li>
<li><a href="../250029/index.html">Compiling nested classes: javac and ecj</a></li>
<li><a href="../250031/index.html">Interval reps "in the pocket"</a></li>
<li><a href="../250035/index.html">The digest of interesting materials for the mobile developer # 89 (February 2-8)</a></li>
<li><a href="../250039/index.html">Symfony2. Universal tool for quick cooking of table lists in the administrative panel</a></li>
<li><a href="../250045/index.html">Imarker usage statistics (SORM-like web analytics system)</a></li>
<li><a href="../250047/index.html">Raspberry Pi 2 freezes from flash</a></li>
<li><a href="../250049/index.html">DevCon 2015: announcement of key speakers of the plenary session</a></li>
<li><a href="../250053/index.html">Why developers don't like Unit Tests</a></li>
<li><a href="../250055/index.html">WSGI / Rack for PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>