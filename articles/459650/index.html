<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to lose money in a black box: billing testing methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Checking paid services is one of the key engineering issues in testing Badoo. Our application is integrated with 70 payment providers in 250 countries...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to lose money in a black box: billing testing methods</h1><div class="post__text post__text-html js-mediator-article">  Checking paid services is one of the key engineering issues in testing Badoo.  Our application is integrated with 70 payment providers in 250 countries of the world, and a bug in at least one of them can lead to unpredictable consequences. <br><br>  In this article I will talk about the testing methods that we use in Badoo, and the limits of applicability of these methods - the stages of testing at which they are most effective. <br><br>  The article will be useful for testers, developers and product managers whose projects are already integrated with payment providers, or the integration process is just beginning.  If in your work you are faced with the problem of choosing methods for testing such integrations, welcome under the cat! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/u0/dg/6k/u0dg6kdremnwjnqjqiabc_wq1m8.jpeg"><br><br><a name="habracut"></a><br>  <i>My name is Vladimir Solodov, I am Billing QA Engineer in Badoo: I am checking test integration and payment processing.</i>  <i>My colleague Viktor Koronevich helped me in the preparation of the text: together with him we gave a talk at the Heisenbug conference ( <a href="https://youtu.be/PWxE0KZLU8Q">video</a> ).</i>  <i>In the article, we expanded the description area to all integrations with payment providers that are used in Badoo; we further classified and described the practices of removing external dependencies.</i> <br><br>  Using the example of business cases, I will tell you why you should be more attentive to testing paid services and how not to aggravate problems if they do arise.  And then we proceed to the description of the technical problems of testing integrations and how to solve them. <br><br>  We are already preparing the second part of the article, in which we will tell you more about the automation of testing paid services in iOS applications. <br><br>  Go! <br><br><h2>  Billing testing specificity </h2><br>  Usually the goal of a business is to generate income.  In Badoo, a social network for dating, income brings loans and premium subscriptions.  Credits are the internal currency of Badoo.  With their help, for example, you can raise your profile in the search results in the first place, make a gift to another user and so on.  A premium subscription is valid for a certain period of time and gives you several options at once: turn on stealth mode, see people who are interested in you, confirm the authenticity of your account, and much more. <br><br>  In order for these paid services to work, we use integrations with more than 70 payment providers.  The choice of provider depends on the platform, country, device, mobile operator and other factors.  Therefore, the issue of testing paid services is very serious. <br><br>  To begin, consider why testing paid services should be approached with special attention.  There are two reasons. <br><br><h4>  1. Billing bugs are critical for business. </h4><br>  The first problem is reputational.  The user who paid money for the service becomes more sensitive (and less tolerant) to the bugs in the application.  Any feedback in a public space, be it a review of a blog application or a comment on the App Store or Google Play, from a user who has encountered a bug in a paid service will be more emotional - this is a factor that leads to reputational losses. <br><br>  The second problem is that as soon as you start receiving money from the user for the service, you become an object of the right to protect the consumer of services.  And reputational losses can easily turn into financial ones. <br><br>  Companies lose money in three ways. <br><br>  The first way is <b>refandy (refunds)</b> .  Suppose a user finds that you have sold a service to him that does not quite match his expectations.  In this case, he turns to your support service.  Its employees are investigating and find out that the user's expectations did not really come true because of a bug in the application.  You initiate a refund.  In this case, there is a refand: as a result, the company is faced with lost profits, and this is the most harmless way to lose money. <br><br>  The second way is <b>chargebacks</b> .  Suppose the same situation occurred, only the user turned not to your support service, but to the bank that issued him the card, or to the payment provider.  Bank / provider initiates a refund.  In this case, we are dealing with chargeback.  The danger for business here is not only in lost profits.  After a certain number of chargebacks, the company receives a fine, and its risk rating decreases.  The downgrade, in turn, leads to a rise in the cost of payment service providers. <br><br>  The third way - <b>lawsuits (claims)</b> .  In the most neglected cases, there may be lawsuits (including collective ones) leading to the most serious consequences.  For example, in 2015, after a lawsuit from the Ofgem regulator, British Gas was forced to pay multimillion-dollar compensation to users who were charged a higher fee due to an error in the payroll system.  Read more about this <a href="https://www.telegraph.co.uk/business/2018/08/29/british-gas-pays-265m-invalid-exit-fees-overcharging/">here</a> . <br><br><h4>  2. For testing integrations, knowledge and expertise are needed. </h4><br>  Commands that are just starting to integrate with payment providers often face this problem.  Not knowing all the possible cases of billing, they miss the important nuances when they implement the system's reaction to the notification of payment providers. <br><br>  This can lead to unpredictable consequences - from lost profits to disgruntled users. <br><br>  Let's turn to the scheme, which lists the types of paid services, and consider the problem more closely. <br><br><img src="https://habrastorage.org/webt/k0/qu/he/k0quhers6cgrorlijjpdjb8pex4.jpeg"><br>  <i><font color="gray">Figure 1. Possible billing cases</font></i> <br><br>  There are three main cases: error, successful payment and refund to the user.  But each case has parts, each case your system must handle differently. <br><br>  <b>Errors</b> can be critical and uncritical.  The non-critical error can be attributed to the notification - when the payment provider informs about the lack of funds in the user's account, and the critical one - blocking the payment method of the user.  And if in the first case you can try to make payment later, in the second case it would be nice to find out why the method is blocked.  Perhaps the user has been spotted in a fraud and you should be more careful about his transactions. <br><br>  <b>Returns</b> .  You already know that there are two types of returns: refands and chargebacks.  Your system must respond to them differently.  For example, after chargeback it makes sense to think about blocking some functions of your application for a user, because chargeback is one of the most popular methods of fraud. <br><br>  <b>A successful payment</b> can be a one-time, or it can be a subscription. <br><br>  One-off payments can be consumable and non-consumable.  We considered an example of the expendable payment at the very beginning of the article - these are loans in Badoo.  An example of a non-consumable payment can be cited from the games.  Suppose you have a character that you play.  You want to buy for him superpowers that are valid for some time.  In this case, the purchase belongs to the class of non-consumable payments. <br><br>  <b>Subscriptions (subscriptions)</b> .  Here is the largest variety of cases.  In addition to the initial purchase of a subscription, you may have: <br><br><ul><li>  renewal of a subscription (renew); <br></li><li>  cancel subscription; <br></li><li>  trial subscription (trial); <br></li><li>  grace period subscription: when we are unable to renew a subscription and are trying to pay again for a period of time called the grace period.  For the user, the grace period looks like this.  Suppose you bought a monthly subscription to a newspaper.  The company that sends you newspapers is trying to write off the payment for the next month‚Äôs subscription at the end of the first month, but cannot do it (due to the blocking of the card, lack of funds in the account, etc.).  If the duration of the grace period is ten days, then during this time the company is trying to write off the payment, while the subscription remains valid.  If the company fails to debit the money, the subscription is canceled.  If it is, the subscription is renewed from the date of the last payment; <br></li><li>  partial billing  For example, PayPal allows you to make a partial payment if there are not enough funds on the user's account (partial pay), or to split the payment into parts (partial invoice). <br></li></ul><br>  You also need to take into account two characteristics that are completely dependent on the payment provider: the subscription can be controlled by your application or controlled externally. <br><br><ul><li>  An internally managed subscription is, for example, a credit card or PayPal subscription, when after the first payment you receive a token with which you reapply to the provider without having any payment details of the user. <br></li><li>  A externally managed subscription is when the payment aggregator takes over the management of your subscriptions and simply sends you notifications about their current states. <br></li></ul><br>  In the figure, the most obvious areas are highlighted in purple, the reaction to which is usually implemented in the first place.  All others begin to be taken into account much later, as the accumulation of expertise.  This is largely due to the incorrect application of iterative development methodologies in the field of billing. <br><br><img src="https://habrastorage.org/webt/7x/kf/bj/7xkfbjf-z3shfhzuftrl3p0tms4.jpeg"><br>  <i><font color="gray">Figure 2. Billing cases that are primarily implemented in systems</font></i> <br><br>  Such a phased implementation can lead to unpredictable consequences.  For example, in one of the projects I was working on before Badoo, the possibility of a refund was not taken into account.  As a result, all returns were made not through refands, but through chargebacks, which negatively affected the company's risk rating and led to failures in collecting income statistics.  Ignorance of the diversity of billing cases can lead to lost profits or the company's vulnerability to users who feel cheated. <br><br>  So, on the one hand, bugs in payment processing must be found before the release, because they can lead to the most negative consequences.  If this was not possible, then it is important to understand as quickly as possible that the bug got into the release version of the application, fix it and - most importantly, many people forget - to ‚Äúreassure‚Äù users who are faced with this bug. <br><br>  On the other hand, the situation is complicated by the fact that integration with payment providers is always interaction with the ‚Äúblack box‚Äù, which adds many variables to the testing process. <br><br><h2>  Technical problems in the process of testing billing </h2><br>  Let's consider them on the example of Badoo integration with the App Store. <br><br>  App Store subscriptions belong to the class of externally managed ones, that is, they are fully managed on the provider's side, and our system can only request the current status or receive a notification about its change. <br><br>  We specifically chose this integration because it is the most complex and contains all the diversity of cases that can be found in the process of integrating the service with other payment providers. <br><br>  To begin, let's turn to a one-time expendable purchase. <br><br><img src="https://habrastorage.org/webt/ob/xi/rd/obxirdlzjhofj6uvioqwixp-r2k.png"><br>  <i><font color="gray">Figure 3. The process of making a one-time expendable payment</font></i> <br><br>  In step 1, the user makes a request to purchase the service.  The application decides that payment must be made, and in step 2 control is transferred to the payment provider (App Store).  Step 3: the user is given a form to make a payment.  Step 4: the user provides the data for payment.  Step 5: The provider performs the transaction and reports the result to the application, returning the receipt (receipt) containing the full information about the purchase (date, service, status, etc.).  Step 6: The check, supplemented by user data, is sent to the server for processing.  The server processes the check data and generates a push notification for the application in step seven.  In the eighth step, the notification is shown to the user. <br><br>  The problem is that steps 3, 4 and 5 are performed on the side of the payment provider, are practically not controlled by us and may have different variations.  Thus, the process does not actually have a linear structure, as shown in Figure 2, but a branching one (see Figure 4), and each branch must be processed differently by the application. <br><br><img src="https://habrastorage.org/webt/8h/ur/mv/8hurmv5_d6mact7vy90jcdb9s_i.png"><br>  <i><font color="gray">Figure 4. One-time payment status branch</font></i> <br><br>  Buying subscriptions starts just like a one-time payment, but further control of the process is quite difficult to control. <br><br><img src="https://habrastorage.org/webt/lj/di/eb/ljdiebqce8tfo236xv8gir0jaa4.png"><br>  <i><font color="gray">Figure 5. Externally managed subscription states</font></i> <br><br>  Recall that the Apple subscription, which we consider as an example, is manageable externally.  This means that the user after the purchase can manage it asynchronously: close, change the expiration date, request a refund.  We see this at step 9. Since the action takes place outside our system, in the figure I marked it with a dotted line. <br><br>  In step 10, the App Store can change the subscription status: renew, close, enter in the grace period window. <br><br>  So that we can find out what state the subscription is in, there is step 11, which is specific to aggregators such as the App Store and Google Wallet.  At this step, the system sends a token, which is used as a receipt (receipt), received at the very beginning when purchasing a subscription or after its previous renewal. <br><br>  Step 12 is the provider response.  We receive a check with the current state of the subscription.  The result of this step depends on asynchronous steps 9 and 10. <br><br>  In the fall of 2018, Apple implemented the <b>server-to-server notification</b> mechanism for everyone, which allows you to notify about changes that occurred with the subscription.  Receiving such a notification is displayed in step 13. For most other providers, the server-to-server notification mechanism is unique, so it can be argued that the example from Apple covers the entire diversity of cases.  In the case of other providers, step 13 allows you to exclude steps 11 and 12 from the scheme. <br><br>  In step 14, the server generates a response for the application to change the subscription state. <br><br>  Thus, we have a complete state graph that must be passed to check the paid services. <br><br><img src="https://habrastorage.org/webt/tg/he/vx/tghevxtlppxvc9xuqt4wczbav0s.png"><br>  <i><font color="gray">Figure 6. The complete process of changing the status of payments (for example, managed externally subscription)</font></i> <br><br>  Orange colored parts that we do not control in our system, and they are black boxes for us. <br><br><h2>  Billing Testing Methods </h2><br>  So, the main technical problem when testing paid services is the presence of "black boxes", the state of which we have very little control.  This defines a set of methods that can cover all the variety of cases. <br><br>  There are not so many of these methods, and we have divided them into three categories: real payments, sandboxes, and the elimination of external dependencies on black boxes. <br><br><h3>  Real payments </h3><br>  Real payments as a test method are good because they give a clear idea of ‚Äã‚Äãthe state of integration.  Error when making a real payment is an unconditional evidence of a bug. <br><br>  Otherwise, real payments are bad.  First, it is expensive: it is obvious that in order to make a real payment, you need to spend real money.  You are mistaken if you think that ultimately the entire amount will return to the company: first, providers charge a commission on each transaction, the amount of which, as described above, depends on the organization‚Äôs risk rating and can reach 40% (and even more) ;  secondly, you can lose money when testing payments in other countries because of the currency spread - the difference between the purchase and sale rates of the currency (you will make a purchase at the bank's rate for selling currency, and the return will come at the rate of purchase). <br><br>  In addition, this method can take a long time, because you have to wait for the end of the renewal period of subscriptions, the completion of grace periods, and this may be months. <br><br><h3>  Sandboxes </h3><br>  Sandboxes are beautiful.  This is, in essence, the same functionality that the payment provider gives us in the case of a real payment, but without spending real money.  It is fully supported by the provider, which means that integration with the sandbox is cheap. <br><br>  The problem of the length of testing in time is solved, as a rule, using various tricks.  For example, in the App Store sandbox, the following subscription expiration conversion is used. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Real time subscription <br></td><td>  Apple sandbox subscription time <br></td></tr><tr><td>  Week 1 <br></td><td>  3 minutes <br></td></tr><tr><td>  1 month <br></td><td>  5 minutes <br></td></tr><tr><td>  2 months <br></td><td>  10 minutes <br></td></tr><tr><td>  3 months <br></td><td>  15 minutes <br></td></tr><tr><td>  6 months <br></td><td>  30 minutes <br></td></tr><tr><td>  1 year <br></td><td>  1 hour <br></td></tr></tbody></table></div>  <i><font color="gray">Table 1. Ratio between the validity of a real subscription and a subscription in the Apple sandbox</font></i> <br><br>  The default validity of the Google Wallet sandbox subscriptions is shown in Table 2, and it can be configured in the merchant console. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Real time subscription <br></td><td>  Google Sandbox subscription time <br></td></tr><tr><td>  Week 1 <br></td><td>  5 minutes <br></td></tr><tr><td>  1 month <br></td><td>  5 minutes <br></td></tr><tr><td>  3 months <br></td><td>  10 minutes <br></td></tr><tr><td>  6 months <br></td><td>  15 minutes <br></td></tr><tr><td>  1 year <br></td><td>  30 minutes <br></td></tr></tbody></table></div>  <i><font color="gray">Table 2. Setting a subscription term in the Google sandbox</font></i> <br><br>  Unlike the Apple sandbox, you can also check the trial, grace-period, etc. in the Google sandbox using the ratio from table 3. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Real time subscription <br></td><td>  Google Sandbox Subscription Time <br></td></tr><tr><td>  Trial period <br></td><td>  3 minutes <br></td></tr><tr><td>  Introductory period <br></td><td>  Equal to the time of the corresponding subscription <br></td></tr><tr><td>  Grace period (3/7 days) <br></td><td>  5 minutes <br></td></tr><tr><td>  Temporary account lock (hold) <br></td><td>  10 minutes <br></td></tr><tr><td>  Pause (1/2/3 months) <br></td><td>  5/10/15 minutes (respectively) <br></td></tr></tbody></table></div>  <i><font color="gray">Table 3. Expiration dates for additional features in the Google sandbox</font></i> <br><br>  Closing a subscription can also be implemented in different ways: in the App Store sandbox, closing is performed after the fifth extension, and in Google Wallet it is done from the merchant console or on a device from the Play Store. <br><br>  The problem of sandboxes is that providers treat their quality differently.  Our experience shows that of more than 70 payment providers that are integrated into Badoo, only two sandboxes can boast of full functionality and stable operation.  These are Adyen and PayPal sandboxes.  The remaining providers have either stable sandboxes that are trimmed in terms of functionality (like Google Wallet), or unstable and heavily trimmed in functionality (like App Store and Fortumo).  And there are providers that do not have at all and are not going to have a sandbox. <br><br><img src="https://habrastorage.org/webt/iz/as/im/izasimha0d95e0w214ym9kyfhcy.png"><br>  <i><font color="gray">Figure 7. Sandbox classification by stability and functionality</font></i> <br><br><h3>  Elimination of external dependencies </h3><br>  If we have convinced you that testing using real payments is expensive and inefficient, and payment providers do not provide the sandbox of proper quality, then it remains to turn to various ways to eliminate external dependencies.  There are only three of them: moki, fakie and stubs. <br><br>  Moki in billing is the formation of your system's responses to requests with predetermined parameters without actually addressing the payment provider (see Figure 8).  For example, a request to the provider of SMS payments to the number + 7111-111-11-11 is intercepted at the stage of sending a request to the provider and forms the response of the system in the form of a successful payment.  The request to the number + 7111-111-11-12 is also intercepted, but leads to a reaction to the error with the code ‚ÄúThere is not enough funds for the transaction.‚Äù <br><br><img width="340" src="https://habrastorage.org/webt/cb/zi/xy/cbzixy8v5c16-fjdnobzksxoij4.png"><br>  <i><font color="gray">Figure 8. Moka scheme</font></i> <br><br>  Fakes in billing are fakes of notifications (as if they come from a real provider) (see Figure 9).  Integration with each provider implies a limited set of system responses to a limited set of notification types or reseits.  Based on this information, for each individual payment you can form a set of notifications (with signatures and other fake security attributes), which our system will consider as real notifications from a payment provider. <br><br><img width="340" src="https://habrastorage.org/webt/t5/nz/_h/t5nz_hwuq-49im9ow_csqennjh4.png"><br>  <i><font color="gray">Figure 9. Scheme fake</font></i> <br><br>  Billing stubs are a redirect to a page with a list of possible system responses instead of sending and processing a request (see Figure 10), when we provide all possible payment provider reactions for the current payment status and trigger this reaction instead of sending a request to a real provider or sandbox . <br><br><img width="340" src="https://habrastorage.org/webt/-z/3p/f8/-z3pf8attjz-fiitaqbanlhmbbe.png"><br>  <i><font color="gray">Figure 10. Diagram stub</font></i> <br><br>  All these methods allow you to avoid wasting real money and time, but you can‚Äôt call them very cheap, because to use them you need to make maps of all possible billing states for each provider and keep them up to date.  Also, to use all the methods (except, perhaps, fake), it is required to make significant changes to the code.  In addition, as various options for modeling a real payment, moki, stubs and fakes have a certain degree of approximation to reality and the risks of use that must be considered. <br><br>  Let's return to the process of making a one-time payment.  Steps 3, 4, 5 are the key for integration: transferring control to the payment provider, sending a request to the provider and receiving a response.  When using each of the considered methods of eliminating external dependencies, the focus is directed to some of these steps: when using mock, we simulate the transfer of control and sending a request, when using a stub, only the transfer of control, when using a fake, a response is received.  The remaining steps are ‚Äúout of the brackets‚Äù. <br><br><img src="https://habrastorage.org/webt/2p/cu/w-/2pcuw-rvhju4ngyzr3ez7rqlhco.png"><br>  <i><font color="gray">Figure 11. Modeling the interaction of the application with the provider with different methods of eliminating external dependencies (for example, a one-time purchase in the App Store)</font></i> <br><br>  On the one hand, such elimination of steps leads to risks (for example, you can skip a bug in untestable steps).  On the other hand, modeling each step makes the method more expensive because it requires changes in the system.  Therefore, in practice, we use a combination of methods.  For example, mocks and fakes, when sending a request to a specific number does not generate a system response, but a fake notification is sent to the entry point for notifications on our server.  Or stubs and fakes, when fake notification is also sent from stub when choosing a reaction.  Naturally, such implementations should be limited to developer environments and should not fall on the prod. <br><br><h2>  Limitations of billing testing methods </h2><br>  All described methods are not a panacea.  How to understand at what point it is better to use one or another of them?  To do this, we propose to evaluate them according to the following criteria: <br><br><ul><li>  reproducibility and coverage - which method will help cover and reproduce as many cases as possible? <br></li><li>  the ability to check end-to-end - what method does it better: allows you to check the whole process of making a payment or to carefully and quickly test only one of its stages? <br></li><li>  Cheapness - estimate the full cost: not only real cash spending, but also the cost of writing and maintaining the code. <br></li></ul><br>  The results of the evaluation we have tabulated. <br><br><img src="https://habrastorage.org/webt/ck/sn/re/cksnrehqrplo3q14juwsyrar31m.png"><br>  <i><font color="gray">Table 4. Comparative characteristics of billing testing methods</font></i> <br><br>  <b>Real payment.</b>  Quite a limited number of cases.  Annual subscription needs to be tested a year.  But this is the only method that allows you to test the entire integration process.  It is quite expensive: we constantly spend real money, paying transactions to providers. <br><br>  <b>Sandbox.</b>  Sandboxes, for example, at Apple and Google, differ.  Therefore, they can cover a different number of cases (and certainly not all).  The sandbox does not provide the ability to complete end-to-end testing: even the code in the sandbox itself may differ from the code on the sale.  However, this is probably the cheapest method. <br><br>  <b>Fakes, moki, stubs</b> - the most flexible method.  We can cover the entire set of cases.  Due to the specifics of this method, we do not test the entire payment process.  The method is not cheap: you need to write code and keep it up to date. <br><br><h2>  Choosing a test method </h2><br>  In order to determine which method to use at what stage, let us turn to the classical testing pyramid. <br><br>  At the bottom of the pyramid is a large number of tests that should fully cover all the functionality of our system.  These should be very small cases and fairly cheap. <br><br>  At the top of the pyramid, the cover may be incomplete: it may be expensive cases.  The main test that we want to perform here is to check the full path of our service from request to delivery to the user. <br><br>  If we relate this to the criteria for evaluating the testing methods, then we get the following ratio: for the tests at the bottom of the pyramid - fakes, mocks, stubs;  for tests at the top of the pyramid - integration-oriented methods: real payment and sandbox. <br><br><img src="https://habrastorage.org/webt/hc/rg/ka/hcrgka-jxqtj6rftvexttwrlvqw.jpeg"><br>  <i><font color="gray">Figure 12. Correlation of stages and methods of testing on the pyramid of testing</font></i> <br><br><h2>  Antipatterns when choosing a method </h2><br>  Information about what happens if the ratio of tests in the test pyramid is violated can be found in a large number of articles, for example <a href="https://habr.com/en/post/358178/">, this one</a> . <br><br>  Let's look at examples of three testing anti-patterns that do not match the ratio in Figure 12 that we encountered in Badoo. <br><br><h4>  Real payments at the bottom of the pyramid </h4><br>  For testing using real payments a special card was instituted.  It was available only to a narrow circle of people.  But one day a QA engineer from our team recognized her data.  Having good intentions, he decided to implement autotests.  Naturally, at some point the bank saw that it received requests for several thousand payments for a very short period of time, and blocked the card.  Moreover, I blocked it so that we could not unlock it for about two weeks. <br><br>  The conclusion is this: you do not need to use real payments everywhere. <br><br><h4>  Sandboxes at the top and bottom of the pyramid </h4><br>  The first problem arising from excessive dependence on sandboxes is a malfunction in their work.  For example, to test payments to Apple, the sandbox has long been the only way.  As a result, we are faced with the consequences of her unstable work.  There were two cases when the sandbox did not work at all.  It did not work for two weeks: as a result, four releases of the client application, we had to release without some kind of adequate testing. <br><br>  The second problem is the limitations that sandboxes have.  First, it‚Äôs the difficulty of changing the subscription‚Äôs validity period.  Secondly, this is the absence of such features as grace-period, refandy and others, that is, a part of the functionality is not covered at all by tests. <br><br>  The consequences of using sandboxes at the bottom of the pyramid are the emergence of various infrastructural problems: when using the same account in the sandbox for a large number of payments, the size of the transferred resource or notification can increase, because Apple accumulates the purchase history.  For one of the users, the resit reached 1 GB - naturally, the test bench simply could not withstand the transfer of such a volume of data. <br><br><h4>  Elimination of external dependencies at the top of the pyramid </h4><br>  For one of the payment providers, we used only a combination of mocks and fakes.  As a result, the format of notifications was changed for one of the operators, and the test at the same time gave false positive results.  The problem of the provider was the impossibility of making a real payment, since this required a SIM card from a specific operator in another country. <br><br>  In such cases, it is necessary to carry out an assessment of the risks of eliminating external dependencies, it is important to track real notifications and check them for compliance with the template or pattern (in case of non-compliance, such notifications should be studied separately). <br><br><h2>  findings </h2><br><ol><li>  Paid services should be tested especially carefully, since even the most insignificant bugs can lead to unexpected consequences. <br></li><li>  When implementing integration with a payment provider (especially when using iterative development methodologies), it is important to study and map out all possible provider states.  Iterativeness can be used to complicate the response of a system to certain states, but the system itself should classify states correctly from the very beginning. <br></li><li>  The payment provider is always a ‚Äúblack box‚Äù for us, testing its work is very difficult.  You should not try to use any one method and test everything with its help - this will lead to sad consequences.  It is better to test everything in combination, in composition: with fakes, mocks and stubs - all cases, a sandbox and a real payment - a couple of cases to check the integration. <br></li><li>  When using fakes, mocks and stubs, it is important to remember that these are real payment models, and, like any model, they have a degree of approximation to reality and risks.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These risks should be assessed and covered either with real payments or additional checks. </font></font><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will describe how we managed to achieve stable and inexpensive automation of testing paid services in an iOS application in the next article. </font></font><br><br>  Thanks for attention!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All big profits and fewer bugs! </font></font></div><p>Source: <a href="https://habr.com/ru/post/459650/">https://habr.com/ru/post/459650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45963/index.html">Software Engineering and Miyamotopoliya course</a></li>
<li><a href="../459630/index.html">Tic Tac Toe, Part 2: Undo / Redo with state storage</a></li>
<li><a href="../459638/index.html">Create a global knowledge base on nutrients</a></li>
<li><a href="../459640/index.html">Docs as Code. Part 1: Automate the Update</a></li>
<li><a href="../459644/index.html">Dimmers for LED lamps</a></li>
<li><a href="../459652/index.html">Automated regression testing approach</a></li>
<li><a href="../459656/index.html">OData service without writing code</a></li>
<li><a href="../45966/index.html">MySQL file storage and distribution</a></li>
<li><a href="../459662/index.html">PVS-Studio wanted, but could not find bugs in robots.txt</a></li>
<li><a href="../459668/index.html">How to recognize a text with a photo: new possibilities of the Vision framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>