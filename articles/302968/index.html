<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>D3.js. Graph visualization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D3.js is a JavaScript library for managing documents based on data. D3 helps put data into practice using HTML, SVG, and CSS. D3 allows you to bind ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>D3.js. Graph visualization</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>D3.js</b> is a JavaScript library for managing documents based on data.  <b>D3</b> helps put data into practice using HTML, SVG, and CSS.  D3 allows you to bind arbitrary data to the DOM, and then apply the results of manipulating them to the document. <br></blockquote><br>  For understanding the article, <a href="https://habrahabr.ru/company/datalaboratory/blog/217905/">knowledge of the fundamentals of D3 is</a> useful, and in it we will look at the implementation of the force-based graph algorithms visualization algorithms ( <a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">Force-graph graph drawing algorithms</a> ), which in D3 (version 3) is called <i><a href="">Force Layout</a></i> .  This is a class of graph visualization algorithms that compute the position of each node, simulating the force of attraction between each pair of connected nodes, as well as the repulsive force between the nodes. <br><br><img src="https://habrastorage.org/files/d89/00e/09e/d8900e09e31643f59a0267fe64140dac.png" alt="image"><br><a name="habracut"></a><br>  In the picture above, you can see how the notorious edition of the New Yourk Times <a href="http://www.nytimes.com/interactive/2013/02/20/movies/among-the-oscar-contenders-a-host-of-connections.html">visualized the connections</a> between the candidates for the next Oscar.  The final layout is static, but the positions of the nodes of the graph were calculated just with the help of Force Layout.  An internal editor was built for the graph, allowing you to save the coordinates of the nodes for use in a static version. <br><br>  <b>NB!</b>  Just yesterday <a href="https://twitter.com/mbostock/status/747810877001203712">a</a> new version (version 4) of D3.js was released, so the article I started can already be considered obsolete.  Nevertheless, I hope that it will be useful for understanding the capabilities of the new version.  You can read about the changes made in the new version in the graph visualization API <a href="">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Little about layouts </h1><br>  The D3.js API contains several hundred functions, and for convenience they are divided into logical blocks, one of which is the Layouts block.  It contains the functionality of visual display of data-related elements relative to each other.  Layouts receive a series of input data, apply an algorithm or a heuristic to it, and output the result as a graphical representation of the data. <br><br>  Layouts are not much different from the <a href="">d3.svg path generators</a> in that they help transform the data for their visual presentation.  However, layouts tend to work with the data set as a whole, rather than separately.  In addition, the results of Layout are not limited to one SVG.  Some Layouts are dynamic in time: for example, Force Layout, where, after executing the <b><i>.start ()</i></b> method of the <b><i>d3.layout.force ()</i></b> instance, you can track the events of the <b><i>tick</i></b> update of the layout. <br><br>  More than a dozen layouts are built into D3.  Their instances are often functions (although not necessarily) that can be configured and then applied to the data set.  In other cases, separate methods or event handlers are used to enter data and present the result.  To use you need to look at the documentation of each particular Layout. <br><br><h1>  Force layout </h1><br>  The flexible force-directed graph is visualized using <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2592%25D0%25B5%25D1%2580%25D0%25BB%25D0%25B5">Verlet‚Äôs numerical integration method</a> to impose restrictions on the movement of graph elements relative to each other.  Read more about physical modeling <a href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">here</a> .  This implementation uses the <a href="">quadtree module</a> (quad tree) to accelerate the interaction of the nodes of the graph between themselves, using the <a href="https://en.wikipedia.org/wiki/Barnes%25E2%2580%2593Hut_simulation">Barnes-Hut approximation</a> .  In addition to the repulsive force of the <b><i>charge</i></b> node, the pseudo-gravitational force <b><i>gravity</i></b> holds the nodes in the visible region and avoids pushing unbound subgraphs out of scope, while the graph links have a fixed length of <b><i>linkDistance</i></b> and act as geometric constraints.  Additional user effects and restrictions can be applied in the <b><i>'tick'</i></b> event, by updating the x and y attributes of the nodes. <br><br> <a href="http://bl.ocks.org/mbostock/4062045"><img src="https://habrastorage.org/files/d85/b73/a8d/d85b73a8dad44be0b7bfc829decf683b.png"></a> <br><br>  For a comprehensive overview of the possibilities with examples, see the <a href="https://vimeo.com/29458354">video report of</a> one of the key D3 developers Mike Bostock and a <a href="http://mbostock.github.io/d3/talk/20110921/">presentation</a> from this report. <br><br>  Some amusing examples are: <a href="http://bl.ocks.org/mbostock/1021841">divergent forces</a> , <a href="http://bl.ocks.org/mbostock/929623">graphical constructor</a> , <a href="http://bl.ocks.org/mbostock/1062288">force-driven tree</a> , <a href="http://bl.ocks.org/mbostock/1062383">power-driven symbols</a> , <a href="http://bl.ocks.org/mbostock/950642">power</a> <a href="http://bl.ocks.org/mbostock/3750558">sticky law</a> . <br><br>  Like the other classes in D3, Layouts follow <a href="https://en.wikipedia.org/wiki/Method_chaining">method chaining</a> when the setter methods return their Layout, allowing you to build many setters into a single chain of calls.  Unlike some other implementations of Layouts, Force Layout retains a link to nodes and graph links within itself;  thus, each Force Layout instance can be used with only one dataset. <br><br><h3>  d3.layout.force () </h3><br>  Creates a new force-directed layout with the following default settings: size 1 √ó 1, link strength 1, friction 0.9, distance 20, charge strength -30, gravity strength 0.1, theta parameter 0.8 (these parameters will be described below).  By default, nodes and graph links are empty arrays, and when the Layout starts, the internal cooling parameter alpha is set to 0.1.  The general template for building force-directed layouts is setting all configuration properties, and then calling the <b><i>.start ()</i></b> method: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> force = d3.layout.force() .nodes(nodes) .links(links) .size([w, h]) .linkStrength(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) .friction(<span class="hljs-number"><span class="hljs-number">0.9</span></span>) .linkDistance(<span class="hljs-number"><span class="hljs-number">20</span></span>) .charge(<span class="hljs-number"><span class="hljs-number">-30</span></span>) .gravity(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) .theta(<span class="hljs-number"><span class="hljs-number">0.8</span></span>) .alpha(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) .start();</code> </pre> <br>  Please note that, unlike other D3 Layouts, the force-directed layout is not associated with a specific visual representation.  Usually nodes are displayed as SVG elements of a circle, and links are displayed as SVG elements of a line.  But you can also display nodes as <a href="http://bl.ocks.org/mbostock/1062383">symbols</a> or <a href="http://bl.ocks.org/mbostock/950642">images</a> . <br><br><h3>  force.size ([width, height]) </h3><br>  If the <b><i>size</i></b> parameter is passed, sets the available layout size (width and height).  Otherwise, it returns the current size, which by default is [1, 1].  In the force-directed layout, size affects two things: the gravity center and the initial random position of the nodes being added (their x and y coordinates).  The center of gravity is calculated simply [x / 2, y / 2].  When adding nodes to the Force Layout, if they do not have the x and y attributes already set, then these attributes are initialized using a uniform random distribution in the range [0, x] and [0, y], respectively. <br><br><h3>  force.linkDistance ([distance]) </h3><br>  If the <b><i>distance</i></b> parameter is passed, it sets the distance between the connected nodes (the length of the links) specified in it.  Otherwise, it returns the current link length, which defaults to 20. If <b><i>distance is a</i></b> constant, then all links will have the same length.  Otherwise, if <b><i>distance</i></b> is a function, then this function is calculated for each connection (in order).  The function takes two arguments ‚Äî link and its index;  The context for <code>this</code> function is set to the current Force Layout.  The return value of the function is used to set the length of each link.  The function is calculated at startup (method <b>. <i>Start ()</i></b> ) of the layout. <br><br>  Connections are implemented not as ‚Äúelastic forces‚Äù, which is common in other force-directed layouts, but as weak geometric constraints.  For each <b><i>'tick'</i></b> event of the layout, the distance between each pair of connected nodes is calculated and compared with the target distance;  then the bonds move closer or farther from each other until they meet at the right distance.  This approach, coupled with Verlet‚Äôs numerical integration method, is much more stable than the approaches using elastic forces, and also allows for a flexible implementation of other constraints in the <b><i>'tick'</i></b> event handler, such as a hierarchical representation. <br><br><h3>  force.linkStrength ([strength]) </h3><br>  If the <b><i>strength</i></b> parameter is passed, sets the specified bond stiffness in the range [0,1].  Otherwise, it returns the current stiffness, which defaults to 1. If the <b><i>strength is a</i></b> constant, then all the connections will have the same stiffness.  Otherwise, if <b><i>strength</i></b> is a function, then this function is calculated for each connection (in order).  The function takes two arguments ‚Äî link and its index;  The context for <code>this</code> function is set to the current Force Layout.  The return value of the function is used to set the stiffness of each bond.  The function is calculated at startup (method <b>. <i>Start ()</i></b> ) of the layout. <br><br><h3>  force.friction ([friction]) </h3><br>  If the <b><i>friction</i></b> parameter is passed, sets the specified friction coefficient.  Otherwise, it returns the current coefficient, which is 0.9 by default.  The name of this parameter may be misleading;  it does not comply with the standard friction coefficient (from physics).  Rather, it is more similar to the damping rate: for each <b><i>'tick'</i></b> event of the modeling process, the speed of the nodes is calculated based on the <b><i>friction</i></b> parameter.  Thus, the value 1 corresponds to a friction-free medium, and the value 0 freezes all nodes in place.  Values ‚Äã‚Äãoutside the [0,1] range are not recommended and may have destabilizing effects. <br><br><h3>  force.charge ([charge]) </h3><br>  If the <b><i>charge</i></b> parameter is transferred, sets the specified charge power of the node.  Otherwise, it returns the current charge strength, which by default is -30.  If <b><i>charge is a</i></b> constant, then all nodes will have the same charge force.  Otherwise, if <b><i>charge</i></b> is a function, then this function is calculated for each node (in order).  The function takes two arguments - the node and its index;  The context for <code>this</code> function is set to the current Force Layout.  The return value of the function is used to set the charge strength of each node.  The function is calculated at startup (method <b>. <i>Start ()</i></b> ) of the layout. <br><br>  The negative value of the charge force leads to the repulsion of the nodes, and a positive value leads to the attraction of the nodes.  Negative values ‚Äã‚Äãshould be used to represent the graph;  To <a href="http://mbostock.github.com/protovis/ex/nbody.html">simulate the</a> <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_N_%25D1%2582%25D0%25B5%25D0%25BB">problem of N bodies</a> , positive values ‚Äã‚Äãcan be used.  All nodes are assumed to be infinitely small points with equal charge and mass.  The charge forces are effectively implemented using <a href="http://arborjs.org/docs/barnes-hut">the Barnes-Hut algorithm</a> by calculating <a href="">a quad tree</a> for each <b><i>'tick'</i></b> event.  Setting the charge strength to 0 disables the quad tree calculation, which <b>can significantly improve performance</b> if you do not need this functionality. <br><br><h3>  force.chargeDistance ([distance]) </h3><br>  If the <b><i>distance</i></b> parameter is transmitted, sets the maximum distance at which the node's charge forces act.  Otherwise, it returns the current maximum distance, which defaults to infinity.  Determining the end distance improves the performance of the Force Layout and gives a more localized layout output;  This is especially useful in conjunction with gravity user <b><i>gravity</i></b> . <br><br><h3>  force.theta ([theta]) </h3><br>  If the <b><i>theta</i></b> parameter is passed, sets the criterion for the Barnes-Hut approximation.  Otherwise, returns the current value, which defaults to 0.8.  Unlike links, which affect only two connected nodes, the charge power is universal: each node affects all other nodes, even if they are located on uncoupled subgraphs. <br><br>  To avoid delays associated with quadratic time complexity, Force Layout uses <a href="http://en.wikipedia.org/wiki/Barnes-Hut_simulation">the Barnes-Hut algorithm</a> , which has O (n log n) <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D0%25B0">time complexity</a> for one <b><i>'tick'</i></b> .  For each <b><i>'tick'</i></b> event, a quad tree is created to save the current position of the node;  then for each node the sum of the forces of charges of all other nodes is calculated.  For groups of nodes that are far away, the charge force is approximated by treating the remote group of nodes as one large node.  <b><i>Theta</i></b> determines the accuracy of the calculation: if the ratio of the quadrant area in the quadrant tree to the distance between the node and the center of mass of the quadrant is less than <b><i>theta</i></b> , all the nodes in this quadrant are treated as one large node and not calculated separately. <br><br><h3>  force.gravity ([gravity]) </h3><br>  If the <b><i>gravity</i></b> parameter is passed, sets the gravitational pull force.  Otherwise, it returns the current gravitational force, which defaults to 0.1.  The name of this parameter may be misleading;  it does not correspond to <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">physical gravity</a> (which can be simulated by assigning a positive value to the <b><i>charge</i></b> parameter).  Instead, the <b><i>gravity</i></b> parameter is implemented as a small geometric constraint, like a virtual spring, connecting each node to the center of the layout.  This approach has remarkable properties: near the center of the layout, the force of gravitational attraction is practically zero, which prevents any local distortion of the layout;  since the nodes are extended further from the center, the force of gravitational attraction increases in linear proportion to the distance.  Thus, the force of gravitational attraction will always overcome the repulsive forces of charge on a certain threshold, preventing the release of disconnected nodes beyond the boundaries of the layout. <br><br>  Gravity can be turned off by setting the gravitational attraction force to zero.  When gravity is turned off, it is recommended to implement some other geometric constraint to prevent knots from leaving the boundaries of the layout. <br><br><h3>  force.nodes ([nodes]) </h3><br>  If the <b><i>nodes</i></b> parameter is passed, installs the graph nodes specified in the array.  Otherwise, it returns the current array of nodes, which is empty by default.  Each node has the following attributes: <br><br><ul><li>  index - index (counting index from 0) of the node in the nodes array. </li><li>  x - the x coordinate of the current position of the node. </li><li>  y - the y coordinate of the current node position. </li><li>  px - the x coordinate of the previous position of the node. </li><li>  py - the y coordinate of the previous node position. </li><li>  fixed - a boolean value that indicates whether the position of the node is fixed. </li><li>  weight is the number of edges associated with the node. </li></ul><br>  You do not need to set these attributes before passing the Force Layout node;  if they are not set, the corresponding default values ‚Äã‚Äãwill be initialized by Force Layout when calling the <b><i>.start ()</i></b> method.  However, keep in mind that if you store any other data in your nodes, your data attributes should not conflict with the above properties used by Force Layout. <br><br><h3>  force.links ([links]) </h3><br>  If the <b><i>links</i></b> parameter is passed, sets the graph <b><i>links</i></b> specified in the array.  Otherwise, it returns the current array of links, which is empty by default.  Each link has the following attributes: <br><br><ul><li>  source - the start node (element of the nodes array) </li><li>  target - final node (element of the nodes array) </li></ul><br>  Note: the values ‚Äã‚Äãof the source and target attributes can be initially specified as indices in the array of nodes;  they will be replaced by references after calling the <b><i>.start ()</i></b> method.  Link objects may have additional user-defined fields;  This data can be used to calculate the stiffness of the <b><i>linkStrength of the</i></b> connection and the distance of the <b><i>linkDistance</i></b> between the communication nodes using the access function. <br><br><h3>  force.start () </h3><br>  Starting the modeling process;  This method should be called when creating a Force Layout, after installing nodes and links.  In addition, it needs to be called again when nodes or links change.  Force Layout uses the ‚Äúcooling‚Äù parameter <b><i>alpha</i></b> , which controls the temperature. Force Layout: since physical modeling is reduced to a static layout, the temperature decreases, resulting in the nodes slowing down.  Ultimately, <b><i>alpha</i></b> drops below a certain threshold, and the simulation stops completely, freeing resources.  Force Layout can be re-warmed using the <b><i>.resume ()</i></b> method or by restarting;  this also happens automatically when using the <b><i>drag</i></b> mode. <br><br>  When launched, Force Layout initializes various attributes of its associated nodes.  The index of each node is calculated by iterating over the array, starting from 0. The initial coordinates of the node x and y, if not specified, are calculated based on the neighboring nodes: if the associated node already has an initial value of x and y, the corresponding coordinates are applied to the new node.  This increases the stability of the graph's layout when adding new nodes, in contrast to the use of default values, which initialize the coordinates randomly within the dimension of the layout.  The coordinates px and py of the previous position of the node (if not specified) take the value of the initial coordinates, which gives the new nodes an initial speed of zero.  Finally, the default value of fixed is false. <br><br>  Force Layout also initializes the source and target attributes of links links: these attributes can be set not only by direct links to nodes, but also by numerical indexes of nodes (this is convenient when reading data from a JSON file or other static description).  The source and target attributes of links are replaced with the corresponding entries in <b><i>nodes</i></b> only if these attributes are numbers;  thus, these attributes are not affected on existing connections when the Force Layout is restarted.  The <b><i>linkDistance</i></b> and <b><i>linkStrength</i></b> links parameters are also calculated at startup. <br><br><h3>  force.alpha ([value]) </h3><br>  Gets or sets the ‚Äúcooling‚Äù <b><i>alpha</i></b> parameter of the Force Layout modeling process.  If passed, sets the <b><i>alpha</i></b> parameter and returns Force Layout.  If the value passed is greater than zero, this method also restarts Force Layout, if it is not already running, causing a <b><i>'start'</i></b> event and including a <b><i>'tick'</i></b> timer.  If the value passed is not positive and Force Layout is started, this method stops the Force Layout on the next <b><i>'tick'</i></b> event and raises the <b><i>'end'</i></b> event.  If no value is specified, this method returns the current value of the ‚Äúcooling‚Äù parameter. <br><br><h3>  force.resume () </h3><br>  Equivalent to calling: <br><br><pre> <code class="javascript hljs">force.alpha(<span class="hljs-number"><span class="hljs-number">.1</span></span>);</code> </pre><br>  Sets the ‚Äúcooling‚Äù parameter <b><i>alpha</i></b> to 0.1 and then restarts the <a href="">timer</a> .  As a rule, you do not need to call this method directly;  it is called automatically by the <b><i>.start ()</i></b> method.  It is also called automatically by the <b><i>.drag ()</i></b> method when dragging. <br><br><h3>  force.stop () </h3><br>  Equivalent to calling: <br><br><pre> <code class="javascript hljs">force.alpha(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Terminates the simulation process by setting the cooling parameter <b><i>alpha</i></b> to 0. This method can be used to explicitly stop the simulation process.  Unless you explicitly stop the Force Layout, this will happen automatically after the <b><i>alpha</i></b> ‚Äúcooling‚Äù parameter drops below a certain threshold. <br><br><h3>  force.tick ([value]) </h3><br>  Performs one step of Force Layout modeling.  This method can be used together with the <b><i>.start ()</i></b> and <b><i>.stop ()</i></b> methods to calculate the static layout.  For example: <br><br><pre> <code class="javascript hljs">force.start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) force.tick(); force.stop();</code> </pre><br>  The number of iterations depends on the size of the graph and its complexity.  Choosing initial positions is also important.  For example, here the nodes are located diagonally: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = nodes.length; nodes.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d, i</span></span></span><span class="hljs-function">) </span></span>{ dx = dy = width / n * i; });</code> </pre><br>  If you do not initialize the positions of the nodes manually, Force Layout initializes them randomly, leading to a somewhat unpredictable approach. <br><br><h3>  force.on ([type, listener]) </h3><br>  Registers a specific <b><i>listener</i></b> to handle event types of a specific <b><i>type</i></b> from Force Layout.  Currently only <b><i>'start'</i></b> , <b><i>'tick'</i></b> , and <b><i>'end'</i></b> events are supported. <br><br>  Event objects that are passed to a handler function are user objects created using <a href="">d3.dispatch ()</a> .  Each event object has two properties: type (string, 'start', 'tick', or 'end'), and alpha, which is the current value of the ‚Äúcooling‚Äù <b><i>alpha</i></b> parameter.  The <b><i>event.alpha</i></b> property can be used to monitor the progress of Force Layout modeling or to make your own adjustments to this process. <br><br>  The <b><i>'start'</i></b> event is sent both at the initial start of the simulation process, and every time the simulation is restarted. <br><br>  The <b><i>'tick'</i></b> event is dispatched at each simulation step.  Track 'tick' events to update the displayed positions of nodes and links.  For example, if you initially display nodes and links as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> link = vis.selectAll(<span class="hljs-string"><span class="hljs-string">"line"</span></span>) .data(links) .enter().append(<span class="hljs-string"><span class="hljs-string">"line"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = vis.selectAll(<span class="hljs-string"><span class="hljs-string">"circle"</span></span>) .data(nodes) .enter().append(<span class="hljs-string"><span class="hljs-string">"circle"</span></span>) .attr(<span class="hljs-string"><span class="hljs-string">"r"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br>  You can set their positions for each step of the modeling process: <br><br><pre> <code class="javascript hljs">force.on(<span class="hljs-string"><span class="hljs-string">"tick"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ link.attr(<span class="hljs-string"><span class="hljs-string">"x1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.source.x; }) .attr(<span class="hljs-string"><span class="hljs-string">"y1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.source.y; }) .attr(<span class="hljs-string"><span class="hljs-string">"x2"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.target.x; }) .attr(<span class="hljs-string"><span class="hljs-string">"y2"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d.target.y; }); node.attr(<span class="hljs-string"><span class="hljs-string">"cx"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dx; }) .attr(<span class="hljs-string"><span class="hljs-string">"cy"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dy; }); });</code> </pre><br>  In this case, we saved a set of nodes (node) and links (link) during the initialization stage, so that we do not need to re-select nodes at each modeling step.  You can optionally display nodes and links in a different way;  for example, you can use <a href="">symbols</a> instead of circles. <br><br>  The <b><i>'end'</i></b> event is dispatched when the internal ‚Äúcooling‚Äù parameter <b><i>alpha</i></b> drops below the threshold value (0.005) and is reset. <br><br><h3>  force.drag () </h3><br>  Associates behavior with nodes for interactive dragging, both mouse and touch.  Use it in conjunction with the <a href="">call</a> method for nodes;  for example, call <b><i>node.call (force.drag)</i></b> to initialize.  In drag mode, when you hover the mouse over a node, its <b><i>fixed</i></b> attribute is set to true, thereby stopping its movement.  Fixing a node when the mouseover (mouseover), in contrast to the fixation when clicking on the node (mousedown), simplifies the task of trapping the desired node.  When the 'mousedown' event occurs, and for each subsequent 'mousemove' event up to the 'mouseup' event, the center of the node is set to the current mouse position.  In addition, each mousemove event triggers the Force Layout <b><i>.resume ()</i></b> method, ‚Äúwarming up‚Äù the modeling process.  If you want the moved nodes to commit after dragging, set the <b><i>fixed</i></b> attribute to true on the 'dragstart' event, as done in <a href="http://bl.ocks.org/mbostock/3750558">this example</a> . <br><br>  <i>Implementation note</i> : the 'mousemove' and 'mouseup' event handlers are registered for the current window, so that when the user starts dragging a node, the dragging process will not stop even if the mouse cursor goes beyond the limits of the layout.  Each event handler uses the force namespace to avoid conflicts with other event handlers that a user can bind to nodes or to a window.  If a node is moved by dragging and dropping, the subsequent 'click' event, which will be triggered when the mouse button is released ('mouseup'), will be canceled.  If you register a 'click' event handler, you can ignore the 'click' events that occur when dragging, as follows: <br><br><pre> <code class="javascript hljs">selection.on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d3.event.defaultPrevented) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ignore drag otherwiseDoAwesomeThing(); });</span></span></code> </pre><br>  Finally, check out these two examples: <a href="http://bl.ocks.org/mbostock/1093130">collapsible force layout</a> and <a href="http://bl.ocks.org/mbostock/1021841">divergent forces</a> . </div><p>Source: <a href="https://habr.com/ru/post/302968/">https://habr.com/ru/post/302968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302958/index.html">Pitfalls when using Linked Server</a></li>
<li><a href="../302960/index.html">Does your AngularJS work on 3.5Mb of RAM?</a></li>
<li><a href="../302962/index.html">Delimobil agreement. We abstract and divide</a></li>
<li><a href="../302964/index.html">Documentation - the basis of the game</a></li>
<li><a href="../302966/index.html">Intel Media SDK 2016 R2 - what's new?</a></li>
<li><a href="../302970/index.html">Interview with Andrei Svetlov about the Python language and not only</a></li>
<li><a href="../302974/index.html">The essence of photography: the ability to see and create</a></li>
<li><a href="../302976/index.html">Microsoft revealed the technical aspects of the implementation of the Linux subsystem in Windows 10</a></li>
<li><a href="../302984/index.html">Developer Meeting on Sphinx, June 18 (Saturday)</a></li>
<li><a href="../302986/index.html">It's simple. You come up we do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>