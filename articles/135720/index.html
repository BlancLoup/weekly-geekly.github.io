<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>D programming language - continuation 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good all the time of day! 
 Today I continue the story about the wonderful programming language D. 
 In my previous articles, I led a story about mult...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>D programming language - continuation 2</h1><div class="post__text post__text-html js-mediator-article">  Good all the time of day! <br>  Today I continue the story about the wonderful programming language D. <br>  In my <a href="http://habrahabr.ru/blogs/programming/135044/">previous</a> <a href="http://habrahabr.ru/blogs/programming/135248/">articles,</a> I led a story about multi-paradigm and metaprogramming in D. <br>  Besides, I can not fail to note the remarkable <a href="http://habrahabr.ru/blogs/programming/135670/">article by</a> <a href="http://habrahabr.ru/users/volfram/" class="user_link">Volfram</a> , in which he continued the topic of metaprogramming, I recommend. <br>  Outside the holidays, people relax, celebrate, rejoice, so I don‚Äôt want to burden you with heavy information and today I‚Äôll give you a simple, but equally pleasant topic: operator overloading. <br>  You can say that it‚Äôs generally trivial and not very interesting, but just in D operator overload is an important part of language design and, more importantly, I can show several examples of using CTFE (Compile-time function evaluation), about which was discussed in the previous article.  No wonder I admired him so much, right? <br>  In addition, the topic of operator overloading in D involves a lot of important concepts related to it, which in turn I will reveal in the article. <br>  So, who are interested - welcome under cat. <br><br><a name="habracut"></a><br><br>  So, the specificity of this topic is such that there will be fewer words and more deeds, because the introduction will be short: <br>  In D, operators, like in C ++, are overloaded with the help of overloading of special functions, however, unlike C ++ and C #, the functions here are not special, but quite normal names. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We begin with the definition of the first polygon, I have chosen for this purpose a class of complex numbers. <br>  So: <br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.math; //    . struct Complex { private: <span class="hljs-type"><span class="hljs-type">double</span></span> re; <span class="hljs-type"><span class="hljs-type">double</span></span> im; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: //        this(<span class="hljs-type"><span class="hljs-type">double</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>) { re = r; im = i; } @property nothrow pure <span class="hljs-type"><span class="hljs-type">double</span></span> Re() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } @property nothrow pure <span class="hljs-type"><span class="hljs-type">double</span></span> Im() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> im; } @property nothrow pure <span class="hljs-type"><span class="hljs-type">double</span></span> Abs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqrt(re ^^ <span class="hljs-number"><span class="hljs-number">2</span></span> + im ^^ <span class="hljs-number"><span class="hljs-number">2</span></span>); } @property nothrow pure <span class="hljs-type"><span class="hljs-type">double</span></span> Arg() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atan(im/re); } }</code> </pre> <br>  Here are the set of complex numbers and their forms are written, however, as we all know from the course of general algebra, the sets are very useful to consider together with the operations on them.  So, what kind of operations do we want to see? <br>  First, we would certainly like to be able to compare these numbers.  Well, it's a good goal, let's try to achieve it.  In D, the comparison operator is specified by the opEquals function. <br>  Looking ahead a bit: in general, all operators in D are overloaded by overloading the function op Something.  I will try to cover all overloaded operators in the article. <br>  So, the comparison: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">pure nothrow </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opEquals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Complex v</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.re == re &amp;&amp; v.im == im; }</code> </pre><br><br>  And check our efforts for success: <br><pre> <code class="hljs swift">unittest { <span class="hljs-type"><span class="hljs-type">Complex</span></span> a, b; <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(a == b); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(!(a != b)); <span class="hljs-comment"><span class="hljs-comment">// ,   ? }</span></span></code> </pre><br><br>  Yes, D is smart enough and knows that a! = B is the same as! (A == b), so there is no need to define an operator! =. <br>  Now, a logical continuation would be to realize the desire to compare complex numbers using the opCmp method: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">pure nothrow </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Complex v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = Abs; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> va = v.Abs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a == va) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; va) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br><br>  And complement our unit test: <br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Complex</span></span> a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,   ? assert(a == b); assert(!(a != b)); assert(a &gt;= b); assert(c &gt;= b);</span></span></code> </pre><br><br>  Now I will explain.  Yes, it was painful for me to write this code without any understatement.  Because this comparison is simply mathematically incorrect - it does not satisfy the necessary axioms. <br>  On the other hand, I did not use the&gt; operator, but only&gt; =, so I decided to consider this as a partial non-strict order on the set of complex numbers.  D, of course, will not test axioms, so the use of the&gt; operator is still correct in terms of language, but not mathematics. <br>  Here, with the excuse done, now it is necessary to clarify that the language automatically generates code that allows you to write the expression c = 1. And since I define the order of the fields as {re, im}, this assignment will give exactly the result that I expect - the first field is assigned 1. <br>  In any case, I clearly note: the definition of opCmp makes it possible to use not one, but four comparison operators at once.  It's more convenient for me than in C ++, but this is a matter of taste. <br>  Now we need to assign values ‚Äã‚Äãto Complex, for this we will overload opAssign: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opAssign</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Complex v</span></span></span><span class="hljs-function">)</span></span> { re = v.re; im = v.im; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><br>  I have considered the special operators of equality, order and copying, now I will move on to more general arithmetic operators.  Let's start with unary.  Here D gives us a pleasant surprise: no need to memorize a bunch of operator functions, all unary operators are defined by one function: T.opUnary (string op) (); <br>  Let me explain with an example: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"++"</span></span></span></span></span><span class="hljs-function">)</span></span> { ++re; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"--"</span></span></span></span></span><span class="hljs-function">)</span></span> { --re; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"-"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex(-re, -im); } <span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"+"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex(re, im); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"!"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !re &amp;&amp; !im; }</code> </pre><br><br>  And here is an example of work: <br><br><pre> <code class="hljs swift">unittest { <span class="hljs-type"><span class="hljs-type">Complex</span></span> a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(a == b); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(!(a != b)); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(a &gt;= b); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> &gt;= b); auto d = ++<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>; d = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>++; <span class="hljs-comment"><span class="hljs-comment">// ,  ? d--; //   ? a = -d; b = +d; assert(d == Complex(1, 0) &amp;&amp; c == Complex(3, 0)); assert(b == d &amp;&amp; a == Complex(-1, 0)); }</span></span></code> </pre><br><br>  I note that in the code I described the prefix increment and decrement, the postfix language was added for me myself. <br>  C ++ programmers would be pleased with this implementation of operators, but we write to D, right?  Therefore, we notice an unforgivable lot of code duplication.  Those who read articles about metaprogramming remember what mixin is and know that string op is a compile time argument and is known at compile time, and accordingly, you can stick it in mixin, since it is a string.  Let's try? <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"++"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"--"</span></span></span></span></span><span class="hljs-function">)</span></span> { mixin(op ~ <span class="hljs-string"><span class="hljs-string">"re;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opUnary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"+"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"~"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex(mixin(op ~ <span class="hljs-string"><span class="hljs-string">"re"</span></span>), mixin(op ~ <span class="hljs-string"><span class="hljs-string">"im"</span></span>)); }</code> </pre><br><br>  With a flick of the wrist, the four methods turn into two!  We described the pattern in which we ‚Äúmix in‚Äù the name of the operator in an elementary way.  Nothing is easier! <br>  Well, let's move on.  Or rather, continue the description of our complex arithmetic - now we need binary operators. <br>  As everyone probably guessed, binary operators are built on the same principle as unary ones: they are all defined by a single T.opBinary (string op) function (V a). <br>  I will not stretch the article and immediately identify them using mixin expressions: <br><pre> <code class="hljs lua">Complex opBinary(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> op)(Complex v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op == <span class="hljs-string"><span class="hljs-string">"-"</span></span> || op == <span class="hljs-string"><span class="hljs-string">"+"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex(mixin(<span class="hljs-string"><span class="hljs-string">"v.re"</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">"re"</span></span>), mixin(<span class="hljs-string"><span class="hljs-string">"v.im"</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">"im"</span></span>)); } Complex opBinary(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> op)(Complex v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op == <span class="hljs-string"><span class="hljs-string">"*"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex(re*v.re - im*v.im, im*v.re + re*v.im); } Complex opBinary(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> op)(Complex v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op == <span class="hljs-string"><span class="hljs-string">"/"</span></span>) { auto r = v.Abs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex((re*v.re + im*v.im) / r, (im*v.re - re*v.im) / r); } //    ,    Complex opBinary(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> op)(int v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op == <span class="hljs-string"><span class="hljs-string">"^^"</span></span>) { Complex r = Complex(re, im), t = r; //    opAssign <span class="hljs-built_in"><span class="hljs-built_in">foreach</span></span>(i; <span class="hljs-number"><span class="hljs-number">1.</span></span>.v) r = r * t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre><br><br>  And here is an example (albeit obvious) of use: <br><pre> <code class="hljs swift">unittest { <span class="hljs-type"><span class="hljs-type">Complex</span></span> a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; a = <span class="hljs-number"><span class="hljs-number">1</span></span>; b = <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); d = a + b; auto k = a * b; auto p = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> ^^ <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(d == <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; k == <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(p == <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><br>  It is also possible to define the operators%, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, &amp;, |, ^ with the usual meaning, but due to my use of a floating point number it makes little sense, and it does not carry anything new in the technique of operator overloading. <br>  Just above, I defined the exponentiation operator, but there is a clear code excess.  To correct the situation a bit, I will need the * = operator, which, like all others like it, is defined as opOpAssign (yes, this is a tautology). <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opOpAssign</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Complex v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"-"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"+"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"*"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/"</span></span></span></span></span><span class="hljs-function">)</span></span> { auto t = Complex(re, im); mixin(<span class="hljs-string"><span class="hljs-string">"auto r = t"</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">"v;"</span></span>); re = r.re; im = r.im; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"^^"</span></span></span></span></span><span class="hljs-function">)</span></span> { Complex r = Complex(re, im), t = r; <span class="hljs-comment"><span class="hljs-comment">//    opAssign foreach(i; 1..v) r *= t; return r; }</span></span></code> </pre><br><br>  It remains only to deal with the situation when the variable Complex is not on the left, but on the right, like this: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Complex</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Complex</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span> * a;</code> </pre><br><br>  I would like the correct operation of this code.  Want - please!  There is a special, right-handed version of all binary operators, which is usually easiest to determine by commutativeness: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinaryRight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"+"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"*"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex.opBinary!op(v); }</code> </pre><br><br>  And if the operation is not non-commutative, you can use the direct type conversion: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">Complex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opBinaryRight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"-"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || op == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/"</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Complex.opBinary!op(Complex(v,<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><br>  That's all, arithmetic is over.  What further do you want to do with our complex numbers?  Well, for example, some of them are valid.  Let's define a transform operator: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T == </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span></span><span class="hljs-function">))</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(im != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not real!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; }</code> </pre><br><br>  Another nice moment is associated with the conversion operator.  Namely, the expressions ‚Äúif (expr)‚Äù and ‚Äúexpr?  a: b; "are automatically converted accordingly to" if (cast (bool) expr) "and" cast (bool) expr?  a: b; ".  We use this: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T == </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span></span><span class="hljs-function">))</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; im == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Now we can write type expressions: <br><pre> <code class="hljs kotlin">Complex a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br><br>  It is time to show the overloading of the indexing operation.  Unfortunately, our Complex class will look a little awkward, but this is just an example, right? <br>  Indexing can be of two types: read and write.  They are represented by opIndex and opIndexAssign, respectively.  Let's try to implement them: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> opIndex(size_t a) { switch(a) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Re; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Im; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("Ur doin it wrong."); } } <span class="hljs-type"><span class="hljs-type">void</span></span> opIndexAssign(<span class="hljs-type"><span class="hljs-type">double</span></span> v, size_t a) { switch(a) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: re = v; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: im = v; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("Ur doin it wrong."); } } // , ,   ,   -  : a[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> // re = <span class="hljs-number"><span class="hljs-number">0</span></span>, im = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> opIndexAssign(<span class="hljs-type"><span class="hljs-type">double</span></span> v, size_t a, size_t b) { switch(a) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: re = v; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: im = v; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("Ur doin it wrong."); } switch(b) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: re = v; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: im = v; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("Ur doin it wrong."); } }</code> </pre><br><br>  Everything is logical, but what will happen if we suddenly want to write such code: <br><pre> <code class="hljs lisp">Complex a = <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-comment"><span class="hljs-comment">; a[1] += 1;</span></span></code> </pre><br><br>  In C ++, opIndex returns a ref, everything is clear, and here?  And there is a special form of the indexing operator: opIndexAssignUnary (string op) (v, i1) <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opIndexAssignUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: mixin(<span class="hljs-string"><span class="hljs-string">"re "</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">"= v"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: mixin(<span class="hljs-string"><span class="hljs-string">"im "</span></span> ~ op ~ <span class="hljs-string"><span class="hljs-string">"= v"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Ur doin it wrong."</span></span>); } }</code> </pre><br><br>  Let's try: <br><pre> <code class="hljs swift">unittest { ... <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(p == <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); p[<span class="hljs-number"><span class="hljs-number">0</span></span>] /= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(p == <span class="hljs-type"><span class="hljs-type">Complex</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><br>  On this topic, D supports ‚Äúslicing‚Äù arrays and generally arbitrary data structures with the syntax a [n..k] (k is not included), where n, k are any expressions in which, moreover, you can use the special $ character, which symbolizes the length of the array. <br>  Thus, D supports operators: opSlice, which returns a range, and opDollar, which can be used in a slice expression.  Similarly, if the operators opSilceAssign and opSliceOpAssign with the same meaning as analogs for indexers. <br>  I will not give them, because for this we need a new polygon and a lot of code, and the article has already grown and is not going to end until the end, so let's move on. <br><br>  Everyone knows that in modern languages ‚Äã‚Äã(even C ++ has imitation) there is a foreach operator - a safe analogue of iteration over a collection.  To use it in C ++, you need to implement an iterator interface.  Similarly in C #.  In D there is the same possibility: implement a simple interface: <br><pre> <code class="hljs ruby"> { @property bool empty(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> - iterator != <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>() @property ref T front(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>() void popFront(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>()  iterator++ }</code> </pre><br><br>  However, unlike the above languages ‚Äã‚Äãin D, this is not the only possibility.  If you tried to implement this interface, for example, for a tree, then you know what kind of hemorrhagic it is, because D just saves the situation! <br>  Here you can transfer the processing of the foreach loop body into the collection.  This not only saves from dancing with a tambourine for popFront () for the tree, but also fully corresponds to the spirit of encapsulation. <br>  How is everything going?  And this is how: the body of foreach turns around to the delegate and is passed to the appropriate method of the object. <br>  Making a new test class will take up a lot of space, so I, while risking the reputation, I'm sorry, pervert, still try to demonstrate this concept on my complex numbers.  Just don't try this at home! <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opApply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">delegate</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span></span><span class="hljs-function">) f)</span></span> { auto res = f(re); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; res = f(im); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res ? res : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  I wonder what happened? <br><pre> <code class="hljs matlab">auto p = Complex(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>); foreach(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; p) writeln(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>);</code> </pre><br><br>  Displays: <br>  ten <br>  five <br><br>  Great, right?  Especially if you imagine that you are writing a tree, and use this opportunity for its intended purpose ... <br>  But do you think this is a really cool opportunity?  And no!  The next is better. <br>  I am very sorry, but then there will be an example almost literally from the book - I honestly tried, but could not think of a more impressive example. <br>  Remember the prototype inheritance from the first article?  So now there will be a full, fully dynamic prototype inheritance. <br>  And how can it be achieved in a statically typed language?  Using the operator point overload!  Yes, yes, unlike other languages ‚Äã‚Äãin D, this is also possible. <br>  And help us in this type of Variant.  So: <br><pre> <code class="hljs markdown">import std.variant; //   ,         . alias Variant delegate(DynamicObj self, Variant[<span class="hljs-string"></span><span class="hljs-string"></span>]args...) DynamicMethod; //   -   class DynamicObj { private Variant[<span class="hljs-string"><span class="hljs-string">string</span></span>] fields; private DynamicMethod[<span class="hljs-string"><span class="hljs-string">string</span></span>] methods; void AddMethod(string name, DynamicMethod f) { methods[<span class="hljs-string"><span class="hljs-string">name</span></span>] = f; } void RemoveMethod(string name) { methods.remove(name); } //   Variant opDispatch(string name, Args)(Args args...) { Variant[<span class="hljs-string"></span><span class="hljs-string"></span>] as = new Variant[<span class="hljs-string"><span class="hljs-string">args.length</span></span>]; foreach(i, arg; args) as[<span class="hljs-string"><span class="hljs-string">i</span></span>] = Variant(arg); return methods[<span class="hljs-string"><span class="hljs-string">name</span></span>](<span class="hljs-link"><span class="hljs-link">this, args</span></span>); } Variant opDispatch(string name)() { return fields[name]; } }</code> </pre><br><br>  And try to use it: <br><pre> <code class="hljs pgsql">unittest { auto obj = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Dynamic; DynMethod ff = cast(DynMethod) (Dynamic, Variant[]) { writeln("Hello, world!"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Variant(); }; obj.AddMethod("sayHello", ff); obj.sayHello(); }</code> </pre><br><br>  Displays: Hello, world! <br><br>  So, that's all for today.  It turned out a great article, in which a lot of interesting, and at the same time, no complex concepts.  Operator overloading, as I said in the introduction, is nothing more than syntactic sugar, it does not introduce any significant new features, however, it makes writing and reading D programs more pleasant. <br>  In fact, this is exactly what I like most of all in D - the language is made so that I am pleased to write programs on it. <br>  Thanks for attention! <br><br></div><p>Source: <a href="https://habr.com/ru/post/135720/">https://habr.com/ru/post/135720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135712/index.html">Rust programming language overview</a></li>
<li><a href="../135713/index.html">Free cloud-based PHP-MySQL hosting for a small site based on Amazon AWS</a></li>
<li><a href="../135717/index.html">Release MODx 2.2</a></li>
<li><a href="../135718/index.html">Contribute to ReactOS or CFI @ habrahabr</a></li>
<li><a href="../135719/index.html">Configure Synology Server: Web Server</a></li>
<li><a href="../135721/index.html">Anonymous against neo-Nazis</a></li>
<li><a href="../135722/index.html">Routing requests in Autodaf√©</a></li>
<li><a href="../135723/index.html">ARM v8 architecture processors go to server</a></li>
<li><a href="../135724/index.html">XEN is ported to ARMv5 and v7</a></li>
<li><a href="../135725/index.html">Programming for the PlayStation 2: Controller Library - Part One</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>