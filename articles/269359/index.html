<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is wrong with this code?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all. 
 As I work with Delphi, I find interesting pitfalls that lead to errors. A couple of them I want to share with you in the form of probl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is wrong with this code?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/126/f63/314/126f633143ba7a5cb18e518876963848.gif" alt="image" align="right">  Hello to all. <br>  As I work with Delphi, I find interesting pitfalls that lead to errors.  A couple of them I want to share with you in the form of problems.  I will post the answers to them in a couple of days, but for now you can try to figure out the obvious behavior on your own.  If interested - welcome under cat. <br><a name="habracut"></a><br><h4>  Task 1 </h4><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> IData = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-function">:</span></span> Pointer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data1, Data2: IData; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OutData: IData)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OutData := CreateMerged_IData(Data1.Ptr, Data2.Ptr); <span class="hljs-comment"><span class="hljs-comment">// Create_IData    IData end; var DataArr: array of IData; procedure AddDataToAll(const AExtraData: IData); var i: Integer; begin if not Assigned(AExtraData) then Exit; for i := 0 to Length(DataArr) - 1 do AddData(DataArr[i], AExtraData, DataArr[i]); end;</span></span></code> </pre> <br>  So, we have an IData interface that stores some data.  The AddData function should create a new IData instance based on the other two. <br>  We also have a DataArr array, in which there are no null elements, and at some point we call AddDataToAll.  But the procedure does not work as we expect.  Why? <br><br><h4>  Task 2 </h4><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FCollection: TDictionary&lt;TObject, Integer&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KillObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Obj: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FCollection.ContainsKey(Obj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//DoSomething obj.Free; FCollection.Remove(obj); obj := nil; end; end;</span></span></code> </pre><br>  Here, FCollection was created like this: FCollection: = TDictionary &lt;TObject, Integer&gt; .Create;  No one has set OnKeyNotify and OnValueNotify notifications. <br>  Obj is always a valid existing object.  But meanwhile, this code sometimes falls.  Why? <br><br><h4>  The answer to the puzzle 1 </h4><br>  As you know, Delphi automatically works with a reference count. <br>  This means that when we assign a new variable to the interface variable under the hood, Delphi does something like this: <br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// Value := NewValue; //     : if Assigned(Pointer(Value)) then Value._Release; if Assigned(Pointer(NewValue)) then NewValue._AddRef; Pointer(Value) := Pointer(NewValue);</span></span></code> </pre><br>  Now let's look at passing parameters inside functions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AValue: IUnknown)</span></span></span><span class="hljs-function">;</span></span></code> </pre>  AValue can change inside a function.  At the same time outside the value should not change.  This means that the variable must be explicitly copied onto the stack, increasing its reference count.  After all, if inside the function this variable is assigned a new value, then ._Release will be called.  Also inside the DoWork compiler will carefully insert AValue._Release when exiting; <br>  Pseudocode manipulations with the counter: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AValue: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//DoWork implementation finally IUnknown(AValue)._Release; end; end; MyValue._AddRef; DoWork(Pointer(MyValue));</span></span></code> </pre><br><br>  In case of: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: IUnknown)</span></span></span><span class="hljs-function">;</span></span></code> </pre>  The compiler based on the fact that the value of AValue inside the function does not change - there will be nothing to do with the reference count.  The interface pointer will simply be copied onto the stack. <br>  Pseudocode: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//DoWork implementation end; DoWork(Pointer(MyValue));</span></span></code> </pre><br><br>  For the case of transfer by reference: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: IUnknown)</span></span></span><span class="hljs-function">;</span></span></code> </pre>  Data which can be read is transferred to function, and outside it is expected that the data can be changed.  Here the compiler, as in the case of const, does not make any gestures with a reference counter. <br>  Pseudocode: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//DoWork implementation end; DoWork(Pointer(MyValue));</span></span></code> </pre><br><br>  However, for the case of: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: IUnknown)</span></span></span><span class="hljs-function">;</span></span></code> </pre>  Everything works differently from var.  Out parameter means that uninitialized data can be passed to the function.  For uninitialized data ._Release cannot be called.  Therefore, before calling Delphi, it necessarily inserts ._Release, and inside the function cleans this out parameter. <br><br>  Pseudocode manipulations with the counter: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AValue: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Pointer(AValue) := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,          ._Release   //DoWork implementation end; MyValue._Release; DoWork(Pointer(MyValue));</span></span></code> </pre><br><br>  In the case of the function: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">:</span></span> IUnknown;</code> </pre>  The compiler allocates a temporary variable on the stack, and works with it as with the var parameter. <br>  The pseudocode is as follows: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Result: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//DoWork implementation end; var FuncResult: IUnknown; Pointer(FuncResult) := nil; DoWork(Pointer(FuncResult)); MyValue := FuncResult;</span></span></code> </pre><br><br>  Now we can go directly to the answer to the problem. <br>  Look at the announcement <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data1, Data2: IData; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OutData: IData)</span></span></span><span class="hljs-function">;</span></span></code> </pre>  Here, before calling, the reference count will be increased for Data1, Data2, and reduced for OutData. <br>  In the case of our challenge <pre> <code class="delphi hljs">AddData(DataArr[i], AExtraData, DataArr[i]);</code> </pre>  With DataArr [i], the counter will be increased and decreased.  If the counter is first reduced and becomes zero, then the object will be destroyed. <br>  However, the order of manipulations with the reference counter is not defined.  Therefore, if DataArr [i] ._ Release is called first, then inside AddData, when accessing Data1, we risk getting Access Violation at address: 00000000 <br>  The correct solution is to change AddData to <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data1, Data2: IData)</span></span></span><span class="hljs-function">:</span></span> IData;</code> </pre>  or set up a temporary variable before calling: <br><pre> <code class="delphi hljs">AddData(DataArr[i], AExtraData, TmpData); DataArr[i] := TmpData;</code> </pre>  Congratulations to <a href="http://habrahabr.ru/users/kemet/" class="user_link">Kemet</a> for correctly explaining the problem in Task 1. <br><br><h4>  The answer to the puzzle 2 </h4>  The fact that an object is first destroyed and then removed from the collection is naturally noticed by many.  It is understandable, because in the example, in fact, only this is demonstrated.  But what is wrong with that?  After all the code: <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj: TObject; obj := <span class="hljs-keyword"><span class="hljs-keyword">Nil</span></span>; FCollection.Add(obj, <span class="hljs-number"><span class="hljs-number">13</span></span>); WriteLn(FCollection.Items[obj]); <span class="hljs-comment"><span class="hljs-comment">//  13, ..     FCollection.Remove(obj)</span></span></code> </pre>  quite working and has no problems.  The hash seems to be taken from the pointer ... but it seems to be. <br>  In fact, when we create a TDictionary, we can pass it an IEqualityComparer comparator, or TDictionary will use its default comparator.  The problem is specifically stated that the TDictionary is created without parameters, and therefore uses the default comparator.  Let's take a look at it. <br>  It is described in Generics.Defaults.  When created, it is called <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupVtableInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intf: TDefaultGenericInterface; info: PTypeInfo; size: Integer)</span></span></span><span class="hljs-function">:</span></span> Pointer;</code> </pre>  which, from the comparators table, VtableInfo gets the necessary function pointer depending on the type passed to info: PTypeInfo.  For objects (tkClass) there will be a pointer in the table to EqualityComparer_Instance_Class: Pointer = @EqualityComparer_Vtable_Class; <br>  EqualityComparer_Vtable_Class is such a table of functions: <br><pre> <code class="delphi hljs"> EqualityComparer_Vtable_Class: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Pointer = ( @NopQueryInterface, @NopAddref, @NopRelease, @Equals_Class, @GetHashCode_Class );</code> </pre>  Here we are interested in: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals_Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Inst: PSimpleInstance; Left, Right: TObject)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Left = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Right = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := Left.Equals(Right); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode_Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Inst: PSimpleInstance; Value: TObject)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := Value.GetHashCode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  As you can see, if nil is passed to the function, then 42. Otherwise, some TObject methods are called.  Here they are: <br><pre> <code class="delphi hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Obj: TObject)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;</code> </pre>  These are two virtual methods.  This means that in the case of the transfer of an object that is not nil, the pointer is guaranteed to be renamed. <br>  These two methods are very similar to how it works in C #.  However, C # is a managed language, and we simply cannot have a reference to garbage in memory.  Therefore, the name here is always valid.  Personally, I find it not logical to copy this behavior.  It would be much more correct to declare these two methods as follows: <br><pre> <code class="delphi hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Instance: TObject; Other: TObject)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Instance: TObject)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;</code> </pre>  Overlap capabilities are preserved, with this default behavior: a hash on pointers can be implemented.  Anyway. <br>  I agree that you must first remove from the collections, and only then destroy the data.  But I am sure that the code above is simply suspicious for many, when in fact it contains a gross error. <br>  In addition, I would like to draw attention to how the hash is implemented by the pointers in TObject (at least in Delphi 2010): <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObject</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Integer(Self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  As we see it is very bad.  In the case of allocations, we are more likely to get aligned data + granular size of the object, which potentially gives rise to many collisions. </div><p>Source: <a href="https://habr.com/ru/post/269359/">https://habr.com/ru/post/269359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269343/index.html">On the road with clouds: the reality of data centers and the role of SPLA in it</a></li>
<li><a href="../269347/index.html">Celery: best practices</a></li>
<li><a href="../269349/index.html">New animation tabs in the assembly Vivaldi 1.0.303.23</a></li>
<li><a href="../269351/index.html">Swipe banner with navigation buttons and progress bar: use the jQuery Cycle2 plugin</a></li>
<li><a href="../269355/index.html">How to start a newbie in Go</a></li>
<li><a href="../269361/index.html">The digest of interesting materials from the world of Drupal # 14</a></li>
<li><a href="../269367/index.html">Experiment: Is it possible to create an effective trading strategy using machine learning and historical data</a></li>
<li><a href="../269369/index.html">Gyro and accelerometer in web design</a></li>
<li><a href="../269371/index.html">The introduction of AspectJ in the Android application</a></li>
<li><a href="../269373/index.html">Zombie code Code that lives its own life</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>