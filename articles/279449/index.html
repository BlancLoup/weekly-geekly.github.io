<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some thoughts and tips on optimizing C ++ code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wrote this article a long time ago for my blog, which is now abandoned. It seems to me that there is very useful information in it, so I would not l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some thoughts and tips on optimizing C ++ code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/143/ebc/18c/143ebc18c42f4b30ac136e05bd4d263b.jpg"><br><br>  I wrote this article a long time ago for my blog, which is now abandoned.  It seems to me that there is very useful information in it, so I would not like it to just disappear.  It may well be that something is already outdated, I will be grateful if they point it out to me. <br><br>  As a rule, the C ++ language is used where high speed is required.  But in C ++, you can effortlessly get code that runs slower than some Python / Ruby.  It is with this code that numerous comparisons of <i>Any-Lang</i> vs C ++ are operated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, optimization can be of three types: <br><br><ol><li>  Optimization of ready, tested and working code. </li><li>  Initially writing optimal code. </li><li>  Just use optimal designs. </li></ol><br>  Specially deal with the optimization of the finished code should be only after the project is completed and used.  As a rule, optimization is required only in a small part of the project.  Therefore, you first need to find places in the code that eat up most of the CPU time.  After all, what's the point of speeding up the code, even by 500%, if it takes only 1% of computer time?  And it should be remembered that, as a rule, optimization of the algorithms themselves, and not of the code, provides a much greater speed gain.  It is about her appearance that they say: ‚Äúpremature optimization is evil‚Äù (c). <br><br>  The second type of optimization is the initial design of the code, taking into account the performance requirements.  This design is not an early optimization. <br><br>  The third type is not even completely optimization.  Rather, it is the avoidance of non-optimal language constructs.  The C ++ language is quite complex, when using it you often need to know how the code used is implemented.  It is quite low-level, so that the programmer had to take into account the peculiarities of the processors and operating systems. <br><a name="habracut"></a><br><h1>  1. Features of C ++ </h1><br><h3>  1.1.  Passing arguments </h3><br>  Pass arguments by reference or pointer, and not by value.  Passing arguments by value leads to a complete copy of the object.  And the more this object, the more you have to copy.  And if a class object allocates memory in a heap, then it‚Äôs quite a disaster.  Of course, simple types can and should be passed by value.  But complex ones should be transmitted only by reference or by pointer. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    void func1(Foo foo) { } // ,    void func2(const Foo &amp;foo) { }</span></span></code> </pre> <br><br><h3>  1.2.  Exceptions </h3><br>  Use exceptions only where it is really necessary.  The fact is that exceptions are a rather heavy mechanism.  Therefore, do not use them as a <code>goto</code> substitute, exit nested loops, and the like.  Simple rule: exceptions are generated only in exceptional situations.  This does not mean that they should be abandoned altogether.  The very use of exceptions gives meager overhead due to the small amount of additional code.  The only real impact on performance is their improper use. <br><br><h3>  1.3.  RTTI </h3><br>  In code that requires high performance, do not use RTTI.  The RTTI mechanism in most compilers (or in all?) Is implemented through string comparison.  Most often this is not critical.  But sometimes the code may require high speed.  In this case, another solution should be invented, for example, numeric class identifiers. <br><br><h3>  1.4.  Increment and decrement </h3><br>  Use the prefix increment and decrement form.  A C ++ developer should get into the habit of using only the prefix form everywhere ( <code>++i</code> and <code>--i</code> ) and only if necessary the postfix form ( <code>i++</code> ).  The postfix form is implemented by saving and returning the temporary value of the object before changing it.  Of course, in simple cases, in operations with built-in types, the compiler will be able to optimize the code and do without creating a temporary variable.  But in the case of a custom class, it probably won't be optimized. <br><br><h3>  1.5.  Do not create temporary objects - 1 </h3><br>  Temporary objects are created, for example, with this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s1, s2, s3; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = s1 + s2 + s3;</code> </pre><br>  In this case, two unnecessary temporary objects are created: <code>std::string tmp1 = s1 + s2;</code>  and <code>std::string tmp2 = tmp1 + s3;</code>  .  The correct string concatenation looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s1, s2, s3; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = s1; s += s2; s += s3;</code> </pre><br><h3>  1.6.  Do not create temporary objects - 2 </h3><br>  Variable can be declared anywhere.  And if this variable is a complex object, then it should not be declared in places where it may not be needed.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b, c; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-comment"><span class="hljs-comment">//      return if( x == 0 ) return; ... }</span></span></code> </pre><br><h3>  1.7.  Memory reservation </h3><br>  Returning to the previous example (Section 1.5) - the completely correct concatenation method should be as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s1, s2, s3; ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; s.reserve( s1.size() + s2.size() + s3.size() ); s += s1; s += s2; s += s3;</code> </pre><br>  Memory allocation is very expensive.  And, after first selecting it once with the <code>reserve</code> call, you can save a lot of CPU time.  In the case of STL, this applies to the <code>vector</code> and <code>string</code> classes. <br><br><h3>  1.8.  Generally avoid extra work </h3><br>  It seemed to me that this advice is in any book for a beginner, and the basic understanding of C ++ should be enough to understand ... However, I see that some inexperienced programmers stumble upon it. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 s = ""; // 2</span></span></code> </pre><br>  Line 1 calls the constructor <code>std::string(const char *)</code> , which does not know that the string is empty.  It will try to figure out its length, perform memory allocation and copy cycles, have a memory shortage handler, etc. This is more expensive than just <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br>  In line 2, the same situation.  It <code>operator = (const char *s)</code> , which also does not know that the "programmer" just wanted to get an empty string.  A simple call will be more effective: <br><pre> <code class="cpp hljs">s.clear(); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br><h3>  1.9.  Estimate the cost of calling a function in for / while loops </h3><br>  Using STL, you do not have to worry about calling the roads function: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec; ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vec.size(); ++i) { ... }</code> </pre><br>  Because in this case it is cheap.  This will be equivalent to the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = vec.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; ++i)</code> </pre><br>  However, this is not always the case.  A frequent misconception up to C ++ 11 was that programmers expected the same algorithmic complexity from <code>std::list::size</code> , although in many implementations its complexity was O (N).  It looked especially unpleasant where instead of the <code>if( list.empty() )</code> call, <code>if( list.size() &gt; 0 )</code> . <br><br><h3>  1.10.  Do not use vector where list or deque could do. </h3><br>  The <code>vector</code> container is designed to store in memory a continuous sequence of bytes.  Therefore, when adding new items, if there is not enough memory, the container will have to allocate a new memory and copy the data from the old place to the new one.  If this happens frequently, then the performance of the code can be significantly reduced.  Unlike <code>vector</code> , <code>list</code> or <code>deque</code> containers do not store a continuous sequence of data, so copying is not required. <br><br>  On the other hand, the use of a <code>vector</code> with a preliminary reservation (that is, a single allocation of all the necessary memory) is the fastest and most economical way.  Because in the case of a <code>list</code> or <code>deque</code> small chunks of memory are allocated many times.  When choosing a container, you should think about exactly what operations will be performed on it. <br><br><h3>  1.11.  Links or pointers? </h3><br>  Try to use links, not pointers.  Links do not require checks.  The link directly points to the object, and the pointer contains the address to be read. <br><br><h3>  1.12.  Constructor initialization list </h3><br>  Initialize the variables in the constructor initialization list.  Otherwise, it turns out that first they will be initialized, and then they are assigned a value. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Foo { public: Foo() { a = 0; //  a    s = "string"; //     } private: int a; std::string s; }; //   class Foo { public: Foo() : a(0), s("string") //    {} private: int a; std::string s; };</span></span></code> </pre><br><h1>  2. Compilers </h1><br>  The compiler is able to perform many different optimizations.  Sometimes he should be helped.  Sometimes, on the contrary, an attempt to optimize manually will lead to the fact that the compiler will not be able to optimize the code as it would have done without such "help". <br><br><h3>  2.1.  Unrolling loops </h3><br>  Modern processors contain several functional devices (ALUs and FPUs) and are able to execute commands in parallel, i.e., several commands can be executed in a single clock cycle on one core.  Therefore, expanding the loop allows you to perform the operation in fewer steps.  Also, the deployment reduces the number of comparisons and conditional transitions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { sum += s[i]; }</code> </pre><br>  Must be deployed to something like <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( len &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; i &lt; len - <span class="hljs-number"><span class="hljs-number">3</span></span>; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { sum += s[i]; sum += s[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; sum += s[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; sum += s[i + <span class="hljs-number"><span class="hljs-number">3</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(len % <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: sum += s[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: sum += s[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: sum += s[i]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Here is a part of the assembly code, without a <code>switch</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.L5</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+1+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r11</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+2+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r10</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+3+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r9</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+4+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r8</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+5+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+6+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movsx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbx+7+rax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>, 8 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r11</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r10</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r9</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jne</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L5</span></span></code> </pre><br>  It can be seen that in this case the increment is not 4, but 8 byte each.  Additional conditions inside the loop or calculations affecting the loop counter will make it impossible to deploy the loop. <br><br>  The compiler does the unrolling of loops independently.  He should be helped only so that it can be done.  Also, small cycles, it is desirable to combine into one.  But in the presence of conditions or a large loop body, on the contrary, it is better to divide it into several cycles so that at least one of them is deployed by the compiler. <br><br><h3>  2.2.  Laziness of calculations - 1 </h3><br>  It should be remembered that the terms <code>&amp;&amp;</code> (logical AND) and <code>||</code>  (logical OR) compiler processes from left to right.  When calculating the logical AND, if the first condition is false, the second will not even be calculated.  Accordingly, in logical OR, if the first condition is true, there is no sense in calculating the second.  Here is a simple example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(s) &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'y'</span></span> ) { ... }</code> </pre><br>  We need a string of more than three characters so that the first character is y.  In this case, <code>strlen(s)</code> is an expensive operation, and <code>s[0] == 'y'</code> is a cheap one.  Accordingly, if you swap them, it is possible to calculate the length of the string and not have to: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s &amp;&amp; s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'y'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(s) &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> ) { ... }</code> </pre><br><h3>  2.3.  Laziness of calculations - 2 </h3><br>  The laziness of calculations only works until you overload the <code>&amp;&amp;</code> or <code>||</code> operator  .  An overloaded statement is a function call: <br><br> <code>bool operator &amp;&amp; (1, 2)</code> <br> <br>  Therefore, all arguments must be evaluated before the call. <br><br><h3>  2.4.  Switch or if? </h3><br>  Whenever possible, try using <code>switch</code> .  Unlike the <code>if</code> condition, the <code>switch</code> often optimized through a table.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i == <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i == <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i == <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i == <span class="hljs-number"><span class="hljs-number">5</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; }</code> </pre><br>  broadcast on <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 2 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, 20 <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 3 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, 30 <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, 40 <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, 50 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, 100 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmovne</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span></code> </pre><br>  And here is the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; } }</code> </pre><br>  broadcast on <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">dec</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 100 <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 4 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ja</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L10</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CSWTCH</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0+rdi*4]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CSWTCH</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 10 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 20 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 30 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 40 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 50</code> </pre><br><h3>  2.5.  Inline keyword </h3><br>  It would seem that this keyword was invented in order to speed up the program.  But some understand it too literally and begin to insert <code>inline</code> before each function.  This causes the code to swell.  The larger the code, the more memory it needs, and especially the memory in the processor's cache.  Modern compilers have long ceased to pay attention to this word and decide for themselves when to do the function embedded, and when not.  But programmers still try to inflate the code by inserting something like <code>__forceinline</code> .  Use <code>inline</code> should only be where it is really necessary. <br><br><h3>  2.6.  RVO - Return Value Optimization </h3><br>  This optimization allows the C ++ compiler to not create a copy of the return value.  The compiler should be helped to use this optimization. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   std::string foo() { std::string s = "string"; return s; //     RVO } //   std::string foo() { return std::string("string"); //    RVO }</span></span></code> </pre><br>  Therefore, one exit point, though more beautiful, but less effective: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x ) { result = foo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-comment"><span class="hljs-comment">//   ,  RVO   } std::string bar(...) { if( x ) { return foo(); //    RVO } else { return std::string(); //    RVO } }</span></span></code> </pre><br>  This advice has almost lost relevance, since the compilers have learned how to use NRVO well, and there is also the possibility of movement.  However, NRVO may not always be involved, and not all objects have a motion constructor. <br><br><h3>  2.7.  Alignment of structures </h3><br>  In the declaration of classes and structures, try to arrange the variables in descending order of their size.  Particular attention should be paid to grouping together variables whose size is less than 8 bytes.  Compilers, in order to optimize, align the addresses of variables, because accessing a variable of the <code>long</code> type at the aligned address takes only one processor clock cycle, and if the variable is not aligned, then two clock cycles on the i386 architecture.  On some architectures, reading at an unallocated address is generally not possible.  Roughly speaking, a non-aligned variable is located in several memory cells: the first part is in one and part is in the next.  So, thanks to this alignment, a variable of 1 byte size will take 4 or 8 bytes.  Here is an illustrative example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; class Foo { int a; char b; int c; char d; }; class Bar { int a; int c; char b; char d; }; int main() { printf( "%d - %d\n", sizeof(Foo), sizeof(Bar) ); return 0; }</span></span></span></span></code> </pre><br>  On my machine, the output will be as follows: <br><br><pre> <code class="bash hljs">$ g++ test.cpp &amp;&amp; ./a.out 16 - 12</code> </pre><br>  Here it can be seen that the alignment was carried out on the border of four bytes.  And absolutely identical classes <code>Foo</code> and <code>Bar</code> occupy a different volume in memory.  Usually you can and do not pay attention.  But if you want to create thousands of instances of a class, then the <code>Bar</code> option is preferable.  Of course, the compiler itself has no right to rearrange the variables. <br><br>  Of course, one should not calculate the size of each variable in order to pack them as closely as possible.  The size of the variables may depend on the compiler, compilation parameters and architecture.  Also, do not suppress alignment without real need. <br><br><h1>  3. Multithreading </h1><br>  It is important to know that writing multi-threaded code is not to place synchronization objects in the right place, but to write code that does not require synchronization. <br><br><h3>  3.1.  Atomic operations </h3><br>  In general, almost any reference to the kernel is an expensive operation.  As with memory, and with many other challenges.  The fewer such calls the program makes, the better.  In the case of synchronization, the additional overhead creates the need to switch the context while competing.  Therefore, if there is a lot of competition and synchronization is performed using a mutex / critical section, the overhead can be very serious.  And the more competition, the more significant they are.  Here is an example of bad code from fairly well-known programs (as of this writing) LinuxDC ++ / StrongDC ++ and, probably, other similar programs based on the same code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeInc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ pthread_mutex_lock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret = ++v; pthread_mutex_unlock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeDec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ pthread_mutex_lock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret = --v; pthread_mutex_unlock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ pthread_mutex_lock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret = target; target = value; pthread_mutex_unlock(&amp;mtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  This code is compiled for building under Linux.  For Windows, the code is correct: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeInc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InterlockedIncrement(&amp;v); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeDec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InterlockedDecrement(&amp;v); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InterlockedExchange(&amp;target, value); }</code> </pre><br>  The difference is that critical sections are used for Linux, and atomic operations for Windows that do not require heavy mutexes. <br><br><h3>  3.2.  Cache line </h3><br>  Try not to allow access of different streams to closely located parts of memory.  For example, there is such a structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shared</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; };</code> </pre><br>  and threads accessing one of the variables.  If the threads will be running on different cores, an event called <i>Cache line ping-pong</i> will occur: when two different cores need to see each other's changes and for this you have to flush the cache and request data from the RAM.  In such cases, when threads need shared data, you need to insert a piece of memory between variables that will fit in the processor's <i>Cache-Line</i> .  The difficulty is that the size of this <i>Cache-Line is</i> different for each processor.  I am guided by the value of 128 bytes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shared</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pad1[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pad2[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; };</code> </pre><br><h1>  4. Operating systems </h1><br>  This is the level to which you should go down only if you understand well the functions used.  Traps can trap in unexpected places. <br><br><h3>  4.1.  Memory </h3><br>  Try to avoid frequent memory allocation.  This is a very expensive operation.  And the difference between ‚Äúallocate 100 MB‚Äù and ‚Äúallocate 1 MB‚Äù is small.  Therefore, we must try to organize the code so as to allocate a large amount of memory in advance and use it without referring to the OS kernel. <br><br>  If it is necessary to allocate memory often, keep in mind that the allocator built into the standard library is inefficient, especially in the case of active memory operations from parallel threads.  Consider using an alternative allocator like <a href="http://www.nedprod.com/programs/portable/nedmalloc/">nedmalloc</a> or <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> or memory pools like <a href="http://www.boost.org/libs/pool">Boost.Pool</a> . <br><br><h3>  4.2.  I / O Buffering </h3><br>  System calls like <code>read/write</code> or <code>ReadFile/WriteFile</code> do not use buffering.  Therefore, when reading one byte, a whole block of data will be read and a single byte will be given from it.  When reading the next byte, the same block will be read again.  Similarly, when writing: writing one byte will immediately write this byte.  It is very, very inefficient.  Therefore, you should use functions that provide buffering, for example <code>fread/fwrite</code> . <br><br><h1>  5. Processors </h1><br><h3>  5.1.  RAM is no longer RAM </h3><br>  RAM stands for Random Access Memory.  However, to date, an attempt to use memory as a source with fast random access will not lead to anything good.  Because memory access takes several hundred CPU cycles! <br><br>  And the only thing that saves is the processor's cache, access to which costs about a dozen cycles ( <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">source</a> ).  From this it follows that you should try to do so that all the necessary data are placed in the processor cache.  This is not only the program data, but the code itself.  If possible, use sequential memory access.  When organizing a structure such as a hash table or associative structure, the keys should not contain unnecessary information so that their maximum number fits in the cache. <br><br><h3>  5.2.  Signed or unsigned? </h3><br>  Most often, programmers do not think about whether a variable should be signed or not.  For example, the length of the string - it can not be negative, as well as the weight or price of something and many other values.  Probably, the range of values ‚Äã‚Äãfor the sign number is enough to store the desired value, but there is still a difference in the processor instructions.  For example, this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre><br>  will be broadcast in <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">lea</span></span> eax, [rdi+<span class="hljs-number"><span class="hljs-number">3</span></span>] test edi, edi cmovns eax, edi sar eax, <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  And this one: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre><br>  get much shorter: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> eax, edi shr eax, <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Typical places where it is preferable to use unsigned numbers: division and multiplication, counters in cycles, array indices. <br><br>  Floating-point data types cannot be unsigned.  But for them, special processor commands are used. <br><br><h3>  5.3.  Branching </h3><br>  The processor pipeline is called a pipeline, which processes a continuous stream of commands.  The processor continually delivers commands to the pipeline, so that after the execution of one command, it immediately starts another.  But when a branch occurs, that is, an <code>if</code> ... <code>else</code> , the processor does not know for which branch the commands should be used - for <code>if</code> or <code>else</code> .  Therefore, he is trying to predict which one will be used.  In case of an error in the prediction, you have to reset the pipeline data and load new commands into it, while the pipeline is idle. <br><br>  This means that the sooner the transition predictor understands which branch the program will run, the less likely the pipeline will be reset.  It is usually recommended to locate the most likely branch at the very beginning (that is, in the if condition). <br><br><h1>  6. Conclusion </h1><br>  So, in this article we looked at some ways to optimize C ++ code.  I hope some of them were useful to you.  If you know other methods not mentioned in the article, write them in the comments! <br><br>  And finally, two more tips: <br><br><ol><li>  Prefer ready-made solutions.  They have already been tested, it is not necessary to spend time on their support and refinement, they will be developed and corrected by the forces of other people.  The invention of bicycles is very good for self-development, but very bad for team development. </li><li>  Think more about how to make simple and understandable code, not fast.    . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/279449/">https://habr.com/ru/post/279449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279439/index.html">A simple and not very obvious way to hang chrome, firefox and nodejs inside a native function</a></li>
<li><a href="../279441/index.html">MSLibrary. Implementing multiple selection of conditions using bitmasks, for iOS and not only ...</a></li>
<li><a href="../279443/index.html">Persistent RAM</a></li>
<li><a href="../279445/index.html">How to turn a conference trip into a cool weekend?</a></li>
<li><a href="../279447/index.html">What to write desktop client for a web service?</a></li>
<li><a href="../279451/index.html">Happy birthday, Richard Stallman</a></li>
<li><a href="../279453/index.html">Why does a programmer need to know algorithms</a></li>
<li><a href="../279455/index.html">What is in Visual Studio 2015 for a developer in Python</a></li>
<li><a href="../279457/index.html">New useragent search robot Google Smartphone</a></li>
<li><a href="../279459/index.html">What makes software quality?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>