<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prism Developer Guide - Part 3, managing dependencies between components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


1. Introduction 
2. Initializing Prism Applications 
3. Manage dependencies between components 
4. Modular Application Developmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prism Developer Guide - Part 3, managing dependencies between components</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>Table of contents</b> <br><ol><li>  <a href="http://habrahabr.ru/post/176851/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/176853/">Initializing Prism Applications</a> </li><li>  <a href="http://habrahabr.ru/post/176861/">Manage dependencies between components</a> </li><li>  <a href="http://habrahabr.ru/post/176863/">Modular Application Development</a> </li><li>  <a href="http://habrahabr.ru/post/176867/">Implementation of the MVVM pattern</a> </li><li>  <a href="http://habrahabr.ru/post/176869/">Advanced MVVM scripts</a> </li><li>  <a href="http://habrahabr.ru/post/176895/">Creating user interface</a> <br><ol><li>  <a href="http://habrahabr.ru/post/177925/">User Interface Design Recommendations</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/178009/">Navigation</a> <ol><li>  <a href="http://habrahabr.ru/post/182052/">View-Based Navigation (View-Based Navigation)</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/182580/">The interaction between loosely coupled components</a> </li></ol></blockquote><br>  Applications created with the Prism library are typically composite applications, potentially consisting of loosely coupled services and components.  They must interact with each other so as to provide content to the user interface and receive notifications about user actions.  Since they are loosely coupled, they need a way to interact, without which the necessary functionality cannot be obtained. <br><br>  To link all the pieces together, Prism applications rely on the DI container.  DI containers reduce dependencies between objects by providing a way to instantiate classes and control their lifetime depending on the configuration of the container.  When creating objects using a container, it injects the necessary dependencies into them.  If the dependencies have not yet been created, the container first creates them and resolves their own dependencies.  In some cases, the container itself is implemented as a dependency.  For example, when using Unity, a container is inserted into modules so that they can register their views and services in it. <br><br>  There are several advantages to using a container: <br><ul><li>  The container eliminates the need for the component to locate its dependencies or control their lifetime. </li><li>  The container allows you to replace the implementation without affecting the components. </li><li>  The container facilitates testability, allowing you to embed fake dependencies on objects. </li><li>  The container simplifies maintenance by allowing new components to be easily added to the system. </li></ul><br>  In the context of an application based on the Prism library, there are certain advantages to using a container: <br><ul><li>  The container resolves dependencies of the module when it is loaded. </li><li>  The container is used to register and create view models and views. </li><li>  The container can create view models and embed views. </li><li>  The container implements composite application services, such as a region manager, or event aggregator. </li><li>  A container is used to register module-specific services with module-specific functionality. </li></ul><br><a name="habracut"></a><br><blockquote>  <b>The note</b> <br>  Some examples in the Prism manual use the Unity Application Block (Unity) container.  Others, such as <i>Modularity QuickStarts</i> , use the Managed Extensibility Framework (MEF).  The Prism library itself is independent of the container used, and you can use its services and patterns with other containers, such as Castle Windsor, Autofac, Structuremap, Spring.NET, or with any other. </blockquote><br><h3>  Key solution: select dependency deployment container </h3><br>  The Prism library provides two default DI containers: Unity and MEF.  Prism is extensible, so you can use other containers by writing a small amount of code to adapt them.  Both Unity and MEF provide the same basic functionality needed to implement dependencies, even considering that they work very differently.  Some of the features provided by both containers are: <br><ul><li>  Both allow you to register types in a container. </li><li>  Both allow you to register instances in a container. </li><li>  Both allow you to force instantiation of registered types. </li><li>  Both embed instances of registered types in constructors. </li><li>  Both embed instances of registered types in properties. </li><li>  They both have declarative attributes for managing types and dependencies. </li><li>  They both resolve dependencies in the object graph. </li></ul><br>  Unity provides several features not found in MEF: <br><ul><li>  Permits specific types without registration. </li><li>  Allows open generalizations ( <i>Generics</i> ). </li><li>  Can use method call hooking to add additional functionality to the target object ( <i>Interception</i> ). </li></ul><br>  MEF provides several features not found in Unity: <br><ul><li>  Independently detects assemblies in the file system directory. </li><li>  Loads XAP files and looks for assemblies in them. </li><li>  Conducts a recomposition of properties and collections when new types are detected. </li><li>  Automatically exports derived types. </li><li>  Comes with the .NET Framework, starting with the fourth version. </li></ul><br>  Containers vary in capacity and work differently, but Prism can work with any container, providing the same functionality.  When considering which container to use, keep in mind your previous experience and determine which container is best for your application scenarios. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Container Considerations </h3><br>  What should be considered before using containers: <br><ul><li>  Consider whether it is appropriate to register and resolve components using a container: <br><ul><li>  Consider whether the performance impact of registering with the container and allowing instances is acceptable for your case.  For example, if you have to create 10,000 polygons to draw something inside a drawing method, creating all the polygons through a container can lead to a significant loss of performance. <br><blockquote>  <b>The note.</b> <br>  Some containers are able to resolve instances of objects almost as quickly as creating them through the new keyword.  But, in any case, the resolution through the container of a large number of objects in the cycle should be seriously justified. <br></blockquote></li><li>  If there are a lot of deep dependencies, then the time spent on their resolution can increase significantly. </li><li>  If the component has no dependencies or is not itself a dependency for other types, it may not make sense to use the container when creating it, or to place it in a container, respectively. </li><li>  If a component has a single set of dependencies that are an integral part of it and will never change, it may not make sense to use the container when creating it.  Although, in this case, testing it can be complicated. </li></ul><br></li><li>  Consider whether the component should be registered as a singleton, or as an instance: <br><ul><li>  If a component is a global service that acts as a manager of a single resource, for example, a logging service, then you can register it as a singleton. </li><li>  If the component gives access to the general state to numerous consumers, then it can be registered as a singleton. </li><li>  If an object needs to create a new instance every time it is deployed, then it cannot be registered as a singleton.  For example, each view probably needs a new instance of the view model. </li></ul><br></li><li>  Consider whether you want to configure the container in code or through the configuration file: <br><ul><li>  If you want to centrally manage all services, use the configuration file. </li><li>  If you want to register different services depending on any circumstances, configure the container in code. </li><li>  If you have module-level services, configure the container via code so that they are registered only when the module is loaded. </li></ul><br></li></ul><br><blockquote>  <b>The note</b> <br>  Some containers, such as MEF, cannot be configured through the configuration file and must be configured in code. </blockquote><br><h3>  Basic scripts </h3><br>  Containers are used for two main purposes, namely, registration and authorization. <br><br><h4>  check in </h4><br>  Before you can embed dependencies in an object, the types of dependencies must be registered in the container.  Type registration usually involves passing an interface to a container and a specific type that implements this interface.  First of all, there are two ways of registering types and objects: in code, or through a configuration file.  Implementation details may vary by container. <br><br>  As a rule, there are two ways to register types and objects in a container in code: <br><ul><li>  You can register a type, or a display of one type to another.  At the appropriate time, the container will create an instance of the type you specified. </li><li>  You can register an existing instance of an object as a singleton.  The container will return a reference to an existing object. </li></ul><br><br><h5>  Type Registration in <i>UnityContainer</i> </h5><br>  During initialization, a type can register other types, such as views and services.  Registration allows you to resolve their dependencies container and become available to other types.  To do this, you need to embed the container in the module's constructor.  The following code shows how <code>OrderModule</code> from <i>Commanding QuickStart</i> registers a repository type during initialization as a singleton. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderModule</span></span> : <span class="hljs-title"><span class="hljs-title">IModule</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.RegisterType&lt;IOrdersRepository, OrdersRepository&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerControlledLifetimeManager()); ... } ... }</code> </pre> <br>  Depending on which container you are using, registration can also be performed out of code through the configuration file.  For an example, see "Registering Modules using a Configuration File" in Chapter 4, " <a href="http://msdn.microsoft.com/en-us/library/gg405479(v%3DPandP.40).aspx">Modular Application Development</a> ." <br><br><h5>  Type Registration with MEF Container </h5><br>  For registering types in a container, MEF uses an attribute-based system.  As a result, it is quite easy to add a type registration to a container: this requires adding the <code>[Export]</code> attribute to the type that you want to register in the container, as shown in the following example. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(ILoggerFacade))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CallbackLogger</span></span>: <span class="hljs-title"><span class="hljs-title">ILoggerFacade</span></span> { ... }</code> </pre> <br>  Another use case for MEF could be to create an instance of a class and register that particular instance in a container.  <code>QuickStartBootstrapper</code> in <i>Modularity for Silverlight with MEF QuickStart</i> shows an example of this in the <code>ConfigureContainer</code> method. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.ConfigureContainer(); <span class="hljs-comment"><span class="hljs-comment">//    CallbackLogger,     , //    ,     (),   . this.Container.ComposeExportedValue&lt;CallbackLogger&gt;(this.callbackLogger); }</span></span></code> </pre> <br><blockquote>  <b>The note</b> <br>  When using MEF as a container, it is recommended that attributes be used to register types. </blockquote><br><h4>  Resolution </h4><br>  After the type is registered, it can be enabled or implemented as a dependency.  When a type is resolved, and the container must create a new instance of this type, it injects dependencies into that instance. <br><br>  In general, when a type is allowed, one of three things happens: <br><ul><li>  If the type has not been registered, the container throws an exception. <br><blockquote>  <b>The note</b> <br>  Some containers, including Unity, allow you to resolve a specific type that was not registered. </blockquote></li><li>  If the type was registered as a singleton, the container returns an instance of the singleton.  If this is the first call, the container can create an instance and save it for future calls. </li><li>  If the type was not registered as a singleton, the container returns a new instance. <br><blockquote>  <b>The note</b> <br>  By default, types registered in MEF are singletones, and the container stores references to objects.  In Unity, by default, new instances of objects are returned, and the container does not save references to them. </blockquote></li></ul><br><h5>  Resolving instances in unity </h5><br>  The following code sample from <i>Commanding QuickStart</i> shows how the <code>OrdersEditorView</code> and <code>OrdersToolBar</code> resolved from the container to bind them to their respective regions. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderModule</span></span> : <span class="hljs-title"><span class="hljs-title">IModule</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.RegisterType&lt;IOrdersRepository, OrdersRepository&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerControlledLifetimeManager()); <span class="hljs-comment"><span class="hljs-comment">//   Orders Editor    . this.regionManager.RegisterViewWithRegion("MainRegion", () =&gt;; this.container.Resolve&lt;OrdersEditorView&gt;()); //   Orders Toolbar    . this.regionManager.RegisterViewWithRegion("GlobalCommandsRegion", () =&gt; this.container.Resolve&lt;OrdersToolBar&gt;()); } ... }</span></span></code> </pre> <br>  The <code>OrdersEditorPresentationModel</code> constructor contains the following dependencies (order repository and order command proxy), which are entered when it is resolved. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrdersEditorPresentationModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrdersRepository ordersRepository, OrdersCommandProxy commandProxy</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ordersRepository = ordersRepository; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.commandProxy = commandProxy; <span class="hljs-comment"><span class="hljs-comment">//     . this.PopulateOrders(); //  CollectionView    . #if SILVERLIGHT this.Orders = new PagedCollectionView( _orders ); #else this.Orders = new ListCollectionView( _orders ); #endif //   . this.Orders.CurrentChanged += SelectedOrderChanged; this.Orders.MoveCurrentTo(null); }</span></span></code> </pre> <br>  In addition to embedding in the constructor, as shown in the previous example, Unity can also embed dependencies in properties.  Any properties to which the <code>[Dependency]</code> attribute is applied are automatically resolved and implemented when the object is resolved.  If the property is marked with the <code>OptionalDependency</code> attribute, then if it is impossible to resolve the dependency, the property is assigned a <code>null</code> and no exception is thrown. <br><br><h5>  Resolving instances in MEF </h5><br>  The following code example shows how <code>Bootstrapper</code> in <i>Modularity for Silverlight with MEF QuickStart</i> gets a shell instance.  Instead of requesting a specific type, the code might request an instance of the interface. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> DependencyObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateShell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Container.GetExportedValue&lt;Shell&gt;(); }</code> </pre> <br>  In any class that MEF resolves, you can also use injection into the constructor, as shown in the following code example from <code>ModuleA</code> in <i>Modularity for Silverlight with MEF QuickStart</i> , in which <code>ILoggerFacade</code> and <code>IModuleTracker</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ImportingConstructor</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ILoggerFacade logger, IModuleTracker moduleTracker</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logger == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"logger"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moduleTracker == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"moduleTracker"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger = logger; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moduleTracker = moduleTracker; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moduleTracker.RecordModuleConstructed(WellKnownModuleNames.ModuleA); }</code> </pre> <br>  On the other hand, you can use property injection, as shown in the <code>ModuleTracker</code> class from <i>Modularity for Silverlight with MEF QuickStart</i> , which has an instance of <code>ILoggerFacade</code> being implemented. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IModuleTracker))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ModuleTracker</span></span> : <span class="hljs-title"><span class="hljs-title">IModuleTracker</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  Silverlight/MEF,    . [Import] public ILoggerFacade Logger; }</span></span></code> </pre> <br><blockquote>  <b>The note</b> <br>  In Silverlight, the properties and fields being imported should be publicly available. </blockquote><br><h3>  Using dependency injection containers and services in Prism </h3><br>  Dependency injection containers are used to satisfy dependencies between components.  Satisfying these dependencies usually includes registration and resolution.  Prism provides support for Unity and MEF containers, but does not depend on them.  Since the library has access to the container through the <code>IServiceLocator</code> interface, the container can be easily replaced.  To do this, you must implement the <code>IServiceLocator</code> interface.  Usually, if you replace a container, you will also need to write your own container-specific loader.  The <code>IServiceLocator</code> interface <code>IServiceLocator</code> defined in the <i>Common Service Locator Library</i> .  This is an open source project to provide an abstraction of IoC containers (Inversion of Control), such as dependency injection containers, and service locators.  The purpose of using this library is to use IoC and Service Location, without providing a specific container implementation. <br><br>  Prism library provides <code>UnityServiceLocatorAdapter</code> and <code>MefServiceLocatorAdapter</code> .  Both adapters implement the <code>ISeviceLocator</code> interface, extending the type of <code>ServiceLocatorImplBase</code> .  The following illustration shows the class hierarchy. <br><br><img title="Implements Common Service Locator in Prism." src="https://habrastorage.org/getpro/habr/post_images/d71/9e2/059/d719e2059a0ae192800d3647ce2a34d7.png" alt="Implements Common Service Locator in Prism."><br><br>  Although Prism does not reference or rely on a specific container, it is typical for an application to use a very specific DI container.  This means that it is reasonable for an application to refer to a specific container, but the Prism library does not reference the container directly.  For example, the <i>Stock Trader RI</i> app and several of QuickStarts use Unity as the container.  Other examples and QuickStarts use MEF. <br><br><h3>  IServiceLocator </h3><br>  The following code shows the <code>IServiceLocator</code> interface and its methods. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IServiceLocator</span></span> : <span class="hljs-title"><span class="hljs-title">IServiceProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAllInstances</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type serviceType</span></span></span><span class="hljs-function">)</span></span>; TService GetInstance&lt;TService&gt;(); TService GetInstance&lt;TService&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> key); IEnumerable&lt;TService&gt; GetAllInstances&lt;TService&gt;(); }</code> </pre> <br>  The Service Locator extends the Prism library with extension methods, shown in the following code.  You can see that <code>IServiceLocator</code> used only for permission, not for registration. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServiceLocatorExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryResolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IServiceLocator locator, Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locator.GetInstance(type); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ActivationException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T TryResolve&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IServiceLocator locator) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locator.TryResolve(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; } }</code> </pre> <br>  The <code>TryResolve</code> extension <code>TryResolve</code> , which the Unity container does not support, returns an instance of the type that must be enabled if it was registered, otherwise it returns <code>null</code> . <br><br>  <code>ModuleInitializer</code> uses the <code>IServiceLocator</code> to resolve module dependencies during its loading, as shown in the following code examples. <br><br><pre> <code class="cs hljs">IModule moduleInstance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { moduleInstance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateModule(moduleInfo); moduleInstance.Initialize(); } ...</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IModule </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateModule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { Type moduleType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moduleType == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModuleInitializeException(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(CultureInfo.CurrentCulture, Properties.Resources.FailedToGetType, typeName)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (IModule)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceLocator.GetInstance(moduleType); }</code> </pre> <br><h3>  Considerations for using <i>IServiceLocator</i> </h3><br>  <code>IServiceLocator</code> not intended to be used as a general purpose container.  Containers may have different usage semantics, which often affect the choice of container.  Taking this into account, <i>Stock Trader RI</i> uses the dependency injection container directly instead of using the <code>IServiceLocator</code> .  This is the recommended approach when developing applications. <br><br>  In the following situations, the use of <code>IServiceLocator</code> is appropriate: <br><ul><li>  You are an independent software provider (ISV) that develops a third-party service that must support various containers. </li><li>  You are developing a service that will be used in an organization that uses different containers. </li></ul><br><h3>  Additional Information </h3><br>  For information related to DI containers, see: <br><ul><li>  ‚ÄúUnity Application Block‚Äù on MSDN: <a href="http://www.msdn.com/unity">http://www.msdn.com/unity</a> </li><li>  Unity community site on CodePlex: <a href="http://www.codeplex.com/unity">http://www.codeplex.com/unity</a> </li><li>  "Managed Extensibility Framework Overview" on MSDN: <a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx">http://msdn.microsoft.com/en-us/library/dd460648.aspx</a> </li><li>  MEF community site on CodePlex: <a href="http://mef.codeplex.com/">http://mef.codeplex.com/</a> </li><li>  "Inversion of Control containers and the Dependency Injection Pattern" on Martin Fowler's website: <a href="http://www.martinfowler.com/articles/injection.html">http://www.martinfowler.com/articles/injection.html</a> </li><li>  "Design Patterns: Dependency Injection" in <i>MSDN Magazine</i> : <a href="http://msdn.microsoft.com/en-us/magazine/cc163739.aspx">http://msdn.microsoft.com/en-us/magazine/cc163739.aspx</a> </li><li>  ‚ÄúLoosen Up: Tame Your Software Dependencies for More Flexible Apps‚Äù in <i>MSDN Magazine</i> : <a href="http://msdn.microsoft.com/en-us/magazine/cc337885.aspx">http://msdn.microsoft.com/en-us/magazine/cc337885.aspx</a> </li><li>  Castle Project: <a href="http://www.castleproject.org/container/index.html">http://www.castleproject.org/container/index.html</a> </li><li>  StructureMap: <a href="http://structurcodeap.sourceforge.net/Default.htm">http://structurcodeap.sourceforge.net/Default.htm</a> </li><li>  Spring.NET: <a href="http://www.springframework.net/">http://www.springframework.net/</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/176861/">https://habr.com/ru/post/176861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176843/index.html">Video: Samsung ATIV Smart PC XE700T Tablet Review</a></li>
<li><a href="../176851/index.html">Prism Developer Guide - Part 1, Introduction</a></li>
<li><a href="../176853/index.html">Prism Developer Guide - Part 2, Initializing Prism Applications</a></li>
<li><a href="../176857/index.html">Stanford invented a fully passive air conditioner</a></li>
<li><a href="../176859/index.html">Chronicles of LinguaLeo: how we did ‚ÄúDialogues in English‚Äù with Node.js and DynamoDB</a></li>
<li><a href="../176863/index.html">Prism Developer Guide - Part 4, Modular Application Development</a></li>
<li><a href="../176867/index.html">Prism Developer Guide - Part 5, MVVM Pattern Implementation</a></li>
<li><a href="../176869/index.html">Prism Developer Guide - Part 6, Advanced MVVM Scripts</a></li>
<li><a href="../176877/index.html">How we did the Rubens Pipe</a></li>
<li><a href="../176879/index.html">ePayService at RIF + CIB 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>