<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android Support Library 28. What's new?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Following a long tradition, along with the new version of Android, the Support Library is being updated. So far, the library has been released in the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android Support Library 28. What's new?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/6p/7y/cf/6p7ycflaeoj0qsdczduxk1b05ly.png"><br><br>  Following a long tradition, along with the new version of Android, the Support Library is being updated.  So far, the library has been released in the alpha stage, but the list of changes is already much more interesting than the same list for Android P. Google has told an unfair little and wrote about the main innovations of the main library for Android.  We have to read the source and understand what the features of the new features are and why they are needed.  I will restore justice and tell you how Google pleased us: <br><br><ul><li>  RecyclerView selection - the selection of items is now out of the box; </li><li>  Slices - a new way to display the content of another application; </li><li>  new design elements: BottomAppBar, ChipGroup and others; </li><li>  minor changes in one line. </li></ul><a name="habracut"></a><br><h2>  RecyclerView selection </h2><br>  In 2014, along with the release of Lollipop, Google added a new item to support - RecyclerView, as a replacement for the outdated ListView.  Everything was fine with it, and there was a lack of one method from ListView - setSelectionMode ().  After 4 years, this method was indirectly implemented in RecyclerView as a whole library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is magic in selection?  Selection mode - mode, which is initialized by long pressing on the list item.  Then we can select several other elements and make a general action on them.  Example: Google Photos selection mode makes life easier. <br><br><img height="500" src="https://habrastorage.org/webt/wg/f3/p6/wgf3p60noozqsth-luriiq0t8ts.gif"><br><br>  Let's understand in practice how it is in support. <br><br>  Add dependencies to the gradle.  Interestingly, Google allocated selection to a separate repository. <br><br><pre><code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">implementation</span></span> <span class="hljs-string"><span class="hljs-string">"com.android.support:recyclerview-selection:28.0.0-alpha1"</span></span> }</code> </pre> <br>  Let's write a standard adapter for RecyclerView. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordAdapter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;Word&gt;) : RecyclerView.Adapter&lt;WordViewHolder&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">, viewType: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = WordViewHolder( LayoutInflater .from(parent.context) .inflate(R.layout.item_word, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = items.size <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WordViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> item = items[position] holder.bind(item) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordViewHolder</span></span></span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text: TextView = itemView.findViewById(R.id.item_word_text) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Word</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { text.text = word.text } } }</code> </pre> <br>  Model Word is used as data. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Parcelize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Word</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text: String) : Parcelable</code> </pre> <br>  The foundation is, let's proceed to the implementation of the choice.  First you need to decide what will identify the list item.  Google offers a choice of three options: Long, String, Parcelable.  For this purpose, we have already formed Word, lacking only the implementation of Parcelable.  The implementation will add the @ Parcelize annotation, which is available in the experimental version of Kotlin.  In Android Studio 3.2, there are still problems with building a project with an experimental Kotlin, but no one has canceled studio templates. <br><br>  SelectionTracker is the main class of the library.  The object of this class has information about the elements selected by the user and allows changing this list from the code.  To initialize this class, you will need the implementation of two abstract classes: ItemKeyProvider and ItemDetailsLookup.  The first is needed for two-way communication of the position of the element in the collection and the key. <br><br><pre> <code class="hljs python">//   ItemKeyProvider       : // SCOPE_MAPPED -   .   ,       // SCOPE_CACHED -  ,       .   <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordKeyProvider</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(private val items: List&lt;Word&gt;)</span></span></span><span class="hljs-class"> :</span></span> ItemKeyProvider&lt;Word&gt;(ItemKeyProvider.SCOPE_CACHED) { override fun getKey(position: Int) = items.getOrNull(position) override fun getPosition(key: Word) = items.indexOf(key) }</code> </pre> <br>  ItemDetailsLookup is needed to get the position of an item and its key in x and y coordinates. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordLookup</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recyclerView: RecyclerView) : ItemDetailsLookup&lt;Word&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MotionEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = recyclerView.findChildViewUnder(ex, ey) ?.let { (recyclerView.getChildViewHolder(it) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? ViewHolderWithDetails&lt;Word&gt;)?.getItemDetail() } }</code> </pre> <br>  We also write an interface for receiving data from the ViewHolder and implement it. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewHolderWithDetails</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TItem</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ItemDetails&lt;TItem&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordDetails</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapterPosition: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedKey: Word?) : ItemDetails&lt;Word&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelectionKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = selectedKey <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = adapterPosition } <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordViewHolder</span></span></span></span>(itemView: View) : RecyclerView.ViewHolder(itemView), ViewHolderWithDetails&lt;Word&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = WordDetails(adapterPosition, items.getOrNull(adapterPosition)) }</code> </pre> <br>  Everywhere standard code.  It's amazing why the support library developers didn't add the classic implementation themselves. <br><br>  Let's create a tracker in the Activity. <br><br><pre> <code class="hljs ruby">val tracker = SelectionTracker .Builder&lt;Word&gt;( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-string"><span class="hljs-string">"someId"</span></span>, recyclerView, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Long ItemKeyProvider    StableIdKeyProvider WordKeyProvider(items), WordLookup(recyclerView), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     Long  String StorageStrategy.createParcelableStorage(Word::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) ).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">()</span></span></code> </pre> <br>  Let's correct the ViewHolder, add a reaction to a change in the selection state. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setActivatedState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isActivated: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { itemView.isActivated = isActivated }</code> </pre> <br>  Add the tracker to the adapter, redefine onBindViewHolder with payload.  If the changes relate only to the selection status, then the SelectionTracker.SELECTION_CHANGED_MARKER constant will appear in the payloads. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WordViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, payloads: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { holder.setActivatedState(tracker.isSelected(items[position])) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SelectionTracker.SELECTION_CHANGED_MARKER !<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> payloads) { holder.changeText(items[position]) } }</code> </pre> <br>  Tracker is ready and works like a clock.  Add a little beauty and meaning.  Let the AppBar change color, the title will display the number of selected items and the Clear button will be added to the menu when the user selects something.  For this, there is an ActionMode and its support in AppCombatActivity. <br><br>  First of all, let's write the implementation of ActionMode.Callback. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionModeController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tracker: SelectionTracker&lt;*&gt; ) : ActionMode.Callback { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateActionMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ActionMode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, menu: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Menu</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { mode.menuInflater.inflate(R.menu.action_menu, menu) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroyActionMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ActionMode</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { tracker.clearSelection() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPrepareActionMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ActionMode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, menu: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Menu</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActionItemClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ActionMode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MenuItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (item.itemId) { R.id.action_clear -&gt; { mode.finish() <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br>  Add observer to SelectionTracker and link the changes in the tracker with the ActionMode in the Activity. <br><br><pre> <code class="hljs kotlin">tracker.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : SelectionTracker.SelectionObserver&lt;Any&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelectionChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSelectionChanged() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tracker.hasSelection() &amp;&amp; actionMode == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { actionMode = startSupportActionMode(ActionModeController(tracker)) setSelectedTitle(tracker.selection.size()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tracker.hasSelection()) { actionMode?.finish() actionMode = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { setSelectedTitle(tracker.selection.size()) } } }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSelectedTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(selected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { actionMode?.title = <span class="hljs-string"><span class="hljs-string">"Selected: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$selected</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Now for sure.  We enjoy simplicity and beauty. <br><br><img height="500" src="https://habrastorage.org/webt/bd/bu/o1/bdbuo1lkwil5vwyaxz4_tuwgces.gif"><br><br>  We have made the standard version.  Let me briefly note that Builder has many methods for customizing the selection process.  For example, using the withSelectionPredicate (predicate: SelectionPredicate) method, you can limit the number of selected items or deny the selection of specific items.  Builder also provides methods for adding behavior that may conflict with selection in the traditional way of adding.  For example, using withOnDragInitiatedListener (listener: OnDragInitiatedListener) you can configure Drag &amp; Drop. <br><br><h2>  Slices </h2><br>  Slice turned out to be the strangest novelty.  Google has devoted very little time to explaining to the community what kind of a wonder it is.  There is only code and documentation for half the classes.  Let's figure it out. <br><br>  For the basis, I‚Äôll take the code from here, because they‚Äôve figured out how to bypass the Permission bugs in Android P DP1.  I want to note that Slices is not a new support library.  The feature appeared in the Android SDK 28, and in support, the habitat has been expanded to version 24 of the SDK.  This can complete the story and continue it in a few years.  While minSdkVersion can be a maximum of 19, let's talk in general about the idea of ‚Äã‚Äãthis technology and why it is needed at all. <br><br>  Slices is a library that allows you to request from one application (client or host) a part or a static piece of another application (sender or provider).  Very similar to the description of RemoteViews, which is often used for programming custom widgets and notifications. <br><br>  Slice is data in a framework without design and interactivity, like HTML without CSS and Js.  The design will adapt to the theme of the host application.  <a href="">Sample slice</a> . <br><br>  The sender is the ContentProvider, which needs to implement a simple onBindSlice method (sliceUri: Uri): Slice and inside the method to form a Slice.  Our provider will send the time and number of calls. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SliceContentProvider</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SliceProvider</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindSlice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sliceUri: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Slice { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (sliceUri.path) { <span class="hljs-string"><span class="hljs-string">"/time"</span></span> -&gt; createTimeSlice(sliceUri) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Bad url"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateSliceProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { Toast.makeText(context, <span class="hljs-string"><span class="hljs-string">"Slice content provider is launched"</span></span>, Toast.LENGTH_LONG).show() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTimeSlice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sliceUri: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Slice = ListBuilder(context, sliceUri) .apply { counter++ setHeader( ListBuilder.HeaderBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setTitle(<span class="hljs-string"><span class="hljs-string">"What's the time now?"</span></span>) ) addRow( ListBuilder.RowBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setTitle(<span class="hljs-string"><span class="hljs-string">"It is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SimpleDateFormat("HH:mm").format(Calendar.getInstance().time)}</span></span></span><span class="hljs-string">"</span></span>) ) addRow( ListBuilder.RowBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setTitle(<span class="hljs-string"><span class="hljs-string">"Slice has called </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$counter</span></span></span><span class="hljs-string"> times"</span></span>) ) } .build() }</code> </pre> <br>  The client needs to make a request for the URI to the provider, request slice through it, receive it and send it to SliceView.  All actions are performed via SliceManager.  It is important not to forget about permission. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseSliceUri: Uri = Uri.parse(<span class="hljs-string"><span class="hljs-string">"content://ru.touchin.provider/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeSliceUri = baseSliceUri.buildUpon().appendPath(<span class="hljs-string"><span class="hljs-string">"time"</span></span>).build() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sliceManager: SliceManager <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//    View sliceManager = SliceManager.getInstance(this) findViewById&lt;View&gt;(R.id.get_slice).setOnClickListener { tryShowingSlice(timeSliceUri) } } override fun onStart() { super.onStart() if (providerAppNotInstalled(packageManager, baseSliceUri.authority)) { showMissingProviderDialog(this, { finish() }, baseSliceUri) return } } private fun tryShowingSlice(sliceUri: Uri) { if (sliceManager.missingPermission(sliceUri, appName = getString(R.string.app_name))) { //  permission   - Android P DP1 } } else { getSliceAndBind(sliceUri) } } private fun getSliceAndBind(sliceUri: Uri) { sliceView.setSlice(sliceManager.bindSlice(sliceUri)) }</span></span></code> </pre> <br>  SliceManager provides the ability to subscribe to Slice changes in the provider using SliceLiveData and update the SliceView within the subscription.  Unfortunately, it is not working now.  We used the less reactive version. <br><br>  We start the provider, we start the application.  Observe the result of the work.  Everything cool.  It's funny that the counter is incremented twice. <br><br><img height="500" src="https://habrastorage.org/webt/lm/n3/yh/lmn3yhpnmn4ot8r79xux-xq5btu.gif"><br><br>  In most cases, RemoteView is used for widgets and notifications.  Slices are poorly suited for these purposes, they are not very customizable and, as I already wrote, adapt to the design of the application.  Ideal for applications that use data from other applications.  Under the category of comprehensive fit voice assistants - Google Assistant, Alice, and so on.  As noted in the Novada blog, using the slice constructor, you can collect slices that are very similar to the answers for Google Assistant. <br><br><img src="https://habrastorage.org/webt/nz/rt/mh/nzrtmhdtznerrvjxpq8dq1wqc5e.png"><br><br>  And then it's time for a theory. <br><br>  Let's take as a basis what Slice was made for programming answers in Google Assistant - a strategically important product for the company.  Obviously, we live in a time when the graphical interface is gradually replaced by voice: the popularity of home assistants is growing and there is progress in the development of voice artificial intelligence through AI, neural networks and other hyip technologies. <br><br>  For Google, the most logical option would be to develop and increase Google Assistant so that in a year or two it would become a powerful tool.  Slice is theoretically a great tool for pumping add-ons from third-party developers.  So the assistant will become more powerful, all actions can be carried out through it and the need for desktops and icons will disappear.  Then Google Assistant will be the basis for Android. <br><br>  At the moment, we didn‚Äôt really tell us anything about Slice: neither goals nor advantages over RemoteView.  Although the number of code in the new version of support Slice takes almost the first place.  So I think on the next I / O they will tell us in detail about Slice.  And maybe talk about plans for the evolution of the OS, or even present the Android version with a voice interface for developers. <br><br>  But all this is speculation and the desire of the author to reveal the conspiracy theory and get to the truth.  The only thing that can be said for one hundred percent, on Google I / O is waiting for us the outcome of the story. <br><br><h2>  New items: </h2><br><h3>  MaterialCardView and MaterialButton </h3><br>  MaterialCardView is inherited from CardView and is practically no different from it.  Only the ability to set the borders of the card is added and another drawable is used as the background.  Find 10 differences. <br>  MaterialButton is the successor to AppCombatButton and the differences are noticeable here.  The developers have added more ways to customize the button: the color of the ripple effect, the different radii of the buttons, the borders, like in MaterialCardView. <br><br><img height="500" src="https://habrastorage.org/webt/m1/fi/n1/m1fin1jbzm7ngxwswvpmdcyc3uc.gif"><br><br><h3>  Chip and ChipGroup </h3><br>  Here and the words are superfluous. <br><br><img height="500" src="https://habrastorage.org/webt/ad/ea/er/adeaerrumxrbxh5elfkooj-gieo.gif"><br><br><h3>  Bottomomappbar </h3><br>  The most interesting and unexpected widget in this collection, although the idea is very simple, AppBar to place below.  It is inconvenient for a user with small hands and large screens to reach the menu button or just the buttons on the AppBar at the top.  But there is no other benefit in this element. <br><br>  The menu on BottomAppBar needs to be added artificially, for this is the replaceMenu method (@MenuRes int newMenu). <br><br>  Designers coolly figured out how to combine FloatingActionButton and BottomAppBar.  But without the BottomAppBar button, it looks superfluous.  The cut is removed, the chin remains with the menu buttons on one side.  The problem with the menu on large screens could be solved more interestingly, for example, by long pressing the FloatingActionButton to transform it into the menu at the bottom of the screen. <br><br><img height="500" src="https://habrastorage.org/webt/8v/d3/eg/8vd3egrtl1-rxzfosy-3j2toucu.gif"><br><br><h3>  List of short innovations: </h3><br><ul><li>  Android KTX, which was announced earlier.  A bunch of <a href="https://github.com/android/android-ktx">open-source</a> extensions on Kotlin.  Very useful. </li><li>  HEIF Writer.  A new format for encoding one or a sequence of images reached Android one year after the announcement on ios.  This is not about a complete replacement of formats, like Apple.  Just a library with conversion. </li><li>  Browser Actions is a protocol for customizing the browser context menu for a specific url.  Customization is limited to adding several MenuItem with its own icon, text, and Intent.  The protocol implies the implementation of logic by the browser as well.  Chrome is not yet implemented. </li></ul><br><h2>  For those who want to dig out: </h2><br><ol><li>  Use Android studio 3.1 and above.  These versions are not yet in release, but they work stably, I worked with 3.2. </li><li>  A little mess in build.gradle with versions.  Well, of course, you need to add the necessary dependencies. <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">android</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">compileSdkVersion</span></span> <span class="hljs-string"><span class="hljs-string">'android-P'</span></span> defaultConfig { <span class="hljs-attribute"><span class="hljs-attribute">targetSdkVersion</span></span> <span class="hljs-string"><span class="hljs-string">'P'</span></span> //  <span class="hljs-number"><span class="hljs-number">28</span></span> } }</code> </pre> </li><li>  So far, the code that used support 28 was run only on an emulator with Android P. Everything that was older cursed and gave a lot of errors when trying to start. </li></ol><br>  The list of new features is not final.  If we analyze the library‚Äôs changelog for the previous 2-3 years and extrapolate the data for this year, then in May we will have many, many more interesting things to expect.  We wait. <br><br><h2>  Useful links: </h2><br><ul><li>  <a href="https://github.com/TouchInstinct/Support28Test">All the code from the article</a> . </li><li>  <a href="https://medium.com/%40lupajz/the-place-for-bottomappbar-31e0db8f70b1">Good article about BottomAppBar</a> .  From here I took the code for the demonstration. </li><li>  <a href="https://blog.novoda.com/android-p-slices-missing-documentation-part-1/">A detailed story about the Slices is again not from Google</a> .  Some ideas and the basis for the code took from here. </li><li>  <a href="https://habrahabr.ru/company/funcorp/blog/349014/">Detailed analysis of useful trivia from Android KTX</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/351920/">https://habr.com/ru/post/351920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351910/index.html">Monster of advanced threats and targeted attacks.</a></li>
<li><a href="../351912/index.html">Gartner Data & Analytics Summit 2018</a></li>
<li><a href="../351914/index.html">Marvin Minsky "The Emotion Machine": Chapter 2 "Impressors"</a></li>
<li><a href="../351916/index.html">Application architecture on the Akili framework</a></li>
<li><a href="../351918/index.html">Who's there? In the European Union offered to hide the data of the owners of domain names</a></li>
<li><a href="../351922/index.html">Feel Neural Network or Neural Network Designer</a></li>
<li><a href="../351924/index.html">What do we know about the terrain loss of machine learning?</a></li>
<li><a href="../351926/index.html">Welcome to Front-end MeetUp in Raiffeisenbank. UPD: Broadcast Mitap</a></li>
<li><a href="../351928/index.html">Conference DEFCON 22. "Mass scanning of the Internet through open ports." Robert Graham, Paul McMillan, Dan Tantler</a></li>
<li><a href="../351930/index.html">How to stay in the TOP when changing search algorithms (a guide for novice SEOs)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>