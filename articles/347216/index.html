<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The principle of the stream cipher with examples in C #. From One-time pad to stream cipher based on hashf and CTR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the course of the article, developing the idea of ‚Äã‚Äã"One-time Notepad", "invent" a stream cipher based on the hash function. We learn what Counter ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The principle of the stream cipher with examples in C #. From One-time pad to stream cipher based on hashf and CTR</h1><div class="post__text post__text-html js-mediator-article">  In the course of the article, developing the idea of ‚Äã‚Äã"One-time Notepad", "invent" a stream cipher based on the hash function.  We learn what Counter Mode Encryption CTR is. <br><br>  Knowledge of the terms "hash function" and "One-time notebook" for reading is not necessary. <br><br><h2>  Disposable notebook </h2><br>  In "One-time Notepad" ciphertext is obtained by imposing a key on the plaintext.  Overlaying can be done, for example, using bitwise XOR: each bit of plaintext XOR is followed by the corresponding (same in order) key bit. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/697/5af/7c36975afb97e2dc4654b7ad2492a2b5.png" alt="Each bit of plaintext XOR is with the same bit of the key"></div><br>  Figure 1. Every bit of plaintext XOR is with the same key bit in order. <br><a name="habracut"></a><br>  Accordingly, to decrypt, you need to XOR-write the ciphertext with the key. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoding = Encoding.GetEncoding(<span class="hljs-number"><span class="hljs-number">1251</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plainText = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"111111"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"123456"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// encrypt: key XOR plainText byte[] cipherText = new byte[plainText.Length]; new BitArray(key).Xor(new BitArray(plainText)) .CopyTo(cipherText,0); // decrypt: key XOR chipherText var decripted = new byte[cipherText.Length]; new BitArray(key).Xor(new BitArray(cipherText)) .CopyTo(decripted, 0); var decriptedStr = encoding.GetString(decripted);  1.    ,   ,      </span></span></code> </pre> <br>  The more random and unpredictable the key, the better, the harder it is to pick it up.  For this "One-time Notepad" key must be random: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plainText = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"111111"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> randomGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RNGCryptoServiceProvider()) randomGenerator.GetBytes(key);  <span class="hljs-number"><span class="hljs-number">2.</span></span>     </code> </pre> <br><h2>  The key must be one-time </h2><br>  Obviously, the key length must be not less than the length of the text to be encrypted.  If the key is shorter than the clear text, you can try to repeat it cyclically - Figure 2: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/59e/18e/42a59e18ebfe48d024fc247e30dde2bb.png" alt="The key is shorter than the plaintext. Just repeat the key to cover all the encrypted text."></div><br>  Figure 2. The key is shorter than the plaintext.  Just repeat the key to cover all the encrypted text. <br><br><blockquote>  Key overlays on text are called gamming.  In this terminology, the key of the ‚ÄúOne-time Notepad‚Äù will be called the gamut. </blockquote><br>  An example of the method of cyclic overlay gamma <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  XOR //    data    XOR, //   static IEnumerable&lt;byte&gt; XORStrimmed(byte[] gamma, IEnumerable&lt;byte&gt; data) { var gammaIndex = 0; foreach (var bb in data) { // XOR yield return (byte)(bb ^ gamma[gammaIndex]); if (gammaIndex &lt; gamma.Length - 1) gammaIndex++; else gammaIndex = 0; } }  3.   XOR   </span></span></code> </pre> <br>  Let's see what happens if the text is longer than the key and we will simply repeat the gamma cyclically: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plainText = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"11111111111111111111111111111111111111111111111111"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> randomGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RNGCryptoServiceProvider()) randomGenerator.GetBytes(key); <span class="hljs-comment"><span class="hljs-comment">// encrypt: key XOR plainText var cipherText = XORStrimmed(key, plainText); // decrypt: key XOR chipherText var decripted = XORStrimmed(key, cipherText); var decriptedStr = encoding.GetString(decripted.ToArray());  4.      </span></span></code> </pre> <br>  You do not need to be a cryptographer to notice that the ciphertext was not very persistent (at least it is clear that the symbols in the plaintext are repeated): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/6e2/4ed/8f36e24edbbfe5b0e9b366ee1aaced72.png" alt="Ciphertext with a simple repetition of gamma is unstable"></div><br>  Fig. 3. Ciphertext with a simple repetition of the gamma unstable <br><br>  For the same reason, the notebook is called disposable - you cannot use the same key twice. <br><blockquote>  Such plaintext in the example is chosen for clarity.  A good cipher, even for such a string, will produce a ciphertext without repeating patterns. </blockquote><br><h2>  Stream cipher </h2><br>  As we have seen gamma should not be repeated.  Every time the gamma ends for the next round, you need to somehow get a new gamma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/a4c/8cc/564a4c8cc07114527a03edd71386afd8.png" alt="Every time the gamma ends, you need to make a new gamma. Each round has its own gamma."></div><br>  Figure 4. Every time the gamma ends, you need to make a new gamma.  Each round has its own gamma. <br><br>  We also know that gamma should not only not be repeated, but should also be as random as possible.  However, if we generate a truly random gamut at each round, we will get a one-time notebook: the key will be the size of a ciphertext.  This is not what we need. <br><br>  We need a mechanism for generating a pseudo-random gamma, depending on the key.  When decrypting, knowing the key, we should be able to generate the same gamma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/496/9fc/19c/4969fc19c3fad9336ef629204ba3e157.png" alt="Stream cipher scheme"></div><br>  Figure 5. Stream cipher scheme <br><br>  If our generator will make a pseudo-random gamut, depending on the key, for all plaintext, we will get a stream cipher. <br><br><h2>  Counter Mode Encryption CTR </h2><br>  Let's add picture 4: we need a function that will generate a gamma depending on the key and the round number: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d36/532/480/d36532480ba70c504134a8e5dc0ae5b9.png" alt="The gamma function for each round is made depending on the key and the round number."></div><br>  Figure 6. Gamma for each round is made by a function depending on the key and the round number. <br><br>  This is the Counter Mode Encryption CTR - the gamma generator receives a counter (counter) of the round at the input: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/058/b87/bf6/058b87bf6ab0c5acaead6d118d355de3.png" alt="3 rounds of stream cipher with Counter Mode Encryption CTR (except for one component, see below)"></div><br>  Figure 7. 3 rounds of stream cipher with Counter Mode Encryption CTR (except for one component, see below) <br><br><h2>  Hash function as gamma generator </h2><br>  A hash function is a function that converts plaintext into a pseudo-random sequence of a given length.  Knowing the hash (the result of the hash function) it is impossible to recover the plaintext.  Changing even one bit of cleartext results in a completely different, pseudo-random hash. <br><br>  Those.  we can use the hash function as a gamma generator: <br><br>  Gamma Round = HASH (key + RoundIndex) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XorCounterModeEncryptDecrypt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyBytes == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(keyBytes)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(data)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roundIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] roundGamma = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gammaIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gammaIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// create gamma var counterBlock = keyBytes.Concat(BitConverter.GetBytes(roundIndex)).ToArray(); using (var sha = new SHA512Managed()) roundGamma = sha.ComputeHash(counterBlock); } yield return (byte)(d ^ roundGamma[gammaIndex]); if (gammaIndex &lt; roundGamma.Length - 1) gammaIndex++; else { gammaIndex = 0; roundIndex++; } } // foreach }  5.   XOR,          </span></span></code> </pre> <br>  Usage example <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plainText = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"11111111111111111111111111111111111111111111111111"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"1123456"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// encrypt: key XOR plainText var cipherText = XorCounterModeEncryptDecrypt(key, plainText); // decrypt: key XOR chipherText var decripted = XorCounterModeEncryptDecript(key, cipherText); var decriptedStr = encoding.GetString(decripted.ToArray());  6. /   Counter Mode Encryption  </span></span></code> </pre> <br><h2>  Nonce, HMAC </h2><br>  The cipher implementation is not finished yet.  In the current implementation, the same key with the same plaintext will always produce the same ciphertext.  This is unacceptable: Imagine that the same encrypted commands ‚Äúurgently sell bitcoins‚Äù are transmitted via a communication channel - this is a joke, but you get the idea. <br><br>  So, one more requirement is added: each time during encryption, a different ciphertext should be obtained.  In our case, this means that the gamma generator needs to be modified. <br><br>  The problem is solved by the so-called Nonce: <br><br><ul><li>  each time, during encryption, a random bit sequence is generated - Nonce </li><li>  Nonce is involved in the formation of gamma </li><li>  Gamma Round = HASH (Nonce + key + RoundIndex) </li><li>  Nonce is the same for all rounds. </li><li>  Nonce is distributed / stored with ciphertext.  Those.  Knowledge of Nonce, which was used to create a ciphertext, is not a secret. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb4/3ba/e8c/eb43bae8cbded3651eff47d87c978b1f.png" alt="3 rounds of stream cipher with Counter Mode Encryption CTR with the addition of Nonce"></div><br>  Figure 8. 3 rounds of stream cipher with Counter Mode Encryption CTR with the addition of Nonce <br><br>  HMAC is a way to add a dependency on a hash to some additional parameter.  We achieved the same result (to make the cache dependent on several parameters) using concatenation.  Those.  logically <br><br>  HASH (RoundIndex + key) <br><br>  Same thing <br><br>  HMAC (RoundIndex, key) <br><br>  The conclusion is different, but logically the same thing. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XorCounterModeEncryptDecrypt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] nonceBytes, IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyBytes == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(keyBytes)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(data)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonceBytes == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(nonceBytes)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nonceBytes.Length &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(nonceBytes)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nonce = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitArray(nonceBytes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roundIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] roundGamma = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gammaIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gammaIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// create gamma // create counter block: Nonce + Counter // another way: Nonce XOR Counter (has some constraints) var counterBlock = nonceBytes.Concat(BitConverter.GetBytes(roundIndex)).ToArray(); using (var hmacSHA = new HMACSHA512(keyBytes)) roundGamma = hmacSHA.ComputeHash(counterBlock); } yield return (byte)(d ^ roundGamma[gammaIndex]); if (gammaIndex &lt; roundGamma.Length - 1) gammaIndex++; else { gammaIndex = 0; roundIndex++; } } // foreach }  7.   XOR,          .  Nonce  HMAC</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plainText = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"11111111111111111111111111111111111111111111111111"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = encoding.GetBytes(<span class="hljs-string"><span class="hljs-string">"1123456"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nonce = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> randomGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RNGCryptoServiceProvider()) randomGenerator.GetBytes(nonce); <span class="hljs-comment"><span class="hljs-comment">// encrypt: key XOR plainText var cipherText = nonce.Concat( XorCounterModeEncryptDecrypt(key, nonce, plainText) ); // decript: key XOR chipherText var decripted = XorCounterModeEncryptDecrypt( keyBytes: key, nonceBytes: cipherText.Take(4).ToArray(), data: cipherText.Skip(4)); var decriptedStr = encoding.GetString(decripted.ToArray());  8.  </span></span></code> </pre> <br><h2>  Algorithm </h2><br>  We briefly describe the resulting algorithm: <br><br><ol><li>  We make random nonce.  One Nonce is used for all rounds. </li><li>  For each round, we calculate a unique CounterBlock, which will be used to generate a gamma. <br><br>  CounterBlock = Nonce + Round Number </li><li>  Generating gamma for the round <br><br>  Gamma = HMAC (CounterBlock, Key) </li><li>  Putting Gamm on plain text with bitwise XOR </li><li>  When the gamma ends, the next round begins.  Increasing the number of round by 1 ‚Äìthat way the new round gets a new gamut </li></ol><br><h2>  Disclaimer </h2><br>  The above bicycle is for educational purposes only.  The idea of ‚Äã‚Äãusing hash functions in stream ciphers is not new (see below).  As far as I know there is no unequivocal opinion on the persistence of such schemes.  Perhaps this question is simply not relevant - hashes work slower. <br><br>  In defense of the idea, I will give a comment from the initial discussion on <a href="http://www.pgpru.com/forum/kriptografija/potokovyjjshifrnaosnoveheshfunkciiicountermodeencryptionctr%3Fshow_comments%3D1%26p%3D1">pgpru.com</a> : <br>  using a hash as a PRF to create a stream with which XOR data could be encrypted is not new. <br><br>  For example, in the description of one of the SHA3 finalists, the hash function Skein (http://www.skein-hash.info/sites/default/files/skein1.3.pdf), a similar use-case is described in the PDF hash itself. <br><br>  If you see an inaccuracy, a mistake - treat with understanding.  I am not a cryptographist, I am engaged in information security only for applied purposes when developing projects, without exceeding the requirements for information security. <br><br><h2>  Links </h2><br>  <a href="https://github.com/AlexeyBoiko/StreamCipherOnHashAndCTRMode">GitHub StreamCipherOnHashAndCTRMode</a> <br><br>  <a href="http://www.pgpru.com/forum/kriptografija/potokovyjjshifrnaosnoveheshfunkciiicountermodeencryptionctr">Primary discussion on pgpru.com</a> <br>  <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Block cipher mode of operation</a> <br>  <a href="https://crypto.stackexchange.com/questions/29232/implementing-5-modes-of-operation-with-a-hash-function/29244">Implementing 5 modes of operation with a hash function</a> <br>  <a href="http://solutionmes.wikidot.com/st-crypto-one-5">Information Theory and One-Time Notebook</a> <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580">Stream cipher</a> </div><p>Source: <a href="https://habr.com/ru/post/347216/">https://habr.com/ru/post/347216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347204/index.html">IT solutions architecture. Part 1. Enterprise architecture</a></li>
<li><a href="../347206/index.html">As simple as possible about sorting combinations in real business problems</a></li>
<li><a href="../347208/index.html">Kodein is an interesting alternative to Dagger 2 for dependency injection in Kotlin</a></li>
<li><a href="../347210/index.html">Behaviors - Erlang behaviors</a></li>
<li><a href="../347212/index.html">Configuring squid or how not to buy a paid solution</a></li>
<li><a href="../347218/index.html">Projection Modeling Technique</a></li>
<li><a href="../347220/index.html">Microchip implantation: myths and reality</a></li>
<li><a href="../347222/index.html">Postgres logging experience</a></li>
<li><a href="../347224/index.html">PBX in the container. Asterisk 14 + Nginx + Freepbx 14 + srtp on Centos 7 in Proxmox VE 4 lxc container</a></li>
<li><a href="../347226/index.html">Cool internship</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>