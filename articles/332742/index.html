<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 + PPP (GSM) + LwIP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most GSM modules work on the UART interface via AT commands. But for serious projects, the use of AT commands carries certain difficulties: 

 ‚Ä¢ contr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 + PPP (GSM) + LwIP</h1><div class="post__text post__text-html js-mediator-article">  Most GSM modules work on the UART interface via AT commands.  But for serious projects, the use of AT commands carries certain difficulties: <br><br>  ‚Ä¢ control and error handling <br>  ‚Ä¢ the result of the command is returned with a long delay <br>  ‚Ä¢ it is necessary to disassemble incoming lines on the fly <br><br>  It is necessary to understand that with the result of the command execution, the URC code from an incoming call, SMS, received data, etc. can be included in the buffer. very different format.  For these reasons, the use of AT introduces additional delay, it is practically impossible to eliminate it algorithmically, because the reason is in the module itself and the imperfection of its firmware. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this example, I used the SIM800C.  After looking at the specification and convinced of the support of PPP, I began to study ways of implementation.  To use PPP, the module is switched by several configuration commands, then the AT mode becomes inaccessible and in fact communicates with the operator‚Äôs tower directly, bypassing the internal stack of the module, which significantly speeds up the data exchange. <br><br>  Example PPP package: <br><br><img src="https://habrastorage.org/web/a49/1bf/16f/a491bf16fa3c4d0ca73c5b0948375de9.png"><br><a name="habracut"></a><br>  Each PPP packet starts and ends with ~ (0x7E).  The protocol supports connection authentication, encryption, and data compression, which makes it rather difficult to write your own solution.  It is more logical to use a ready-made stack that supports PPP, for example LwIP.  It supports PPPOS and PPPOE (Over serial and Ethernet), PAP and CHAP authentication protocols, has a good reputation and is widely distributed. <br><br>  <b>Demo project</b> <br><br>  Flow Chart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/bea/25e/07a/bea25e07abbe48d48dec043046202522.png"></div><br>  Examples were developed for the STM32 microcontroller under FreeRTOS. <br><br><div class="spoiler">  <b class="spoiler_title">Starting the program, setting up peripherals, creating tasks</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_DMA_Init(); <span class="hljs-comment"><span class="hljs-comment">//  gsm,    LwIP InitGsmUart(); //    -     xTaskCreate(StartThread, "Start", configMINIMAL_STACK_SIZE*2, 0, tskIDLE_PRIORITY+1, &amp;taskInitHandle); //   osKernelStart(NULL, NULL); while (1) {} } void StartThread(void * argument) { gsmTaskInit(); // , /  xTaskCreate(connectTask, "connectTask", configMINIMAL_STACK_SIZE*1, 0, tskIDLE_PRIORITY+1, NULL); //    vTaskDelete(NULL); }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">"Upper level.</b>  <b class="spoiler_title">Connection setup, data reception and mirroring</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// - .    <span class="hljs-number"><span class="hljs-number">1</span></span>,   ,   RAM    LwIP (  ) #define GSM_MAX_CONNECTION <span class="hljs-number"><span class="hljs-number">1</span></span> //      typedef struct{ uint8_t *rxBuff; uint16_t rxLen; }sBuff[GSM_MAX_CONNECTION]; sBuff buff = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-type"><span class="hljs-type">void</span></span> connectTask(<span class="hljs-type"><span class="hljs-type">void</span></span> *pServiceNum) { <span class="hljs-type"><span class="hljs-type">bool</span></span> connectState = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; eRetComm status = eError; uint16_t delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint8_t serviceNum = *(uint8_t*)pServiceNum; xSemaphoreHandle xRxPppData; //     ppp xRxPppData = GsmLLR_GetRxSemphorePoint(serviceNum); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connectState == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { //     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(GsmLLR_ConnectServiceStatus(serviceNum) == eOk) { //    buff[serviceNum].rxLen = getRxData(serviceNum, xRxPppData,&amp;(buff[serviceNum].rxBuff)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buff[serviceNum].rxLen != <span class="hljs-number"><span class="hljs-number">0</span></span>) { //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_TcpSend(serviceNum, buff[serviceNum].rxBuff, buff[serviceNum].rxLen) == eOk) { printf("Connect:#%i SendData OK\r\n", serviceNum); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ printf("Connect:#%i SendData ERROR\r\n", serviceNum); connectState = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } //   printf("Connect:#%i connection lost\r\n", serviceNum); GsmLLR_DisconnectService(serviceNum); connectState = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; delay = <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //  ,  printf("Connect:#%i connecting...", serviceNum); //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_ConnectService(serviceNum) == eOk) { printf("Connect:#%i connected", serviceNum); connectState = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    printf("Connect:#%i ERROR", serviceNum); delay = GSM_CONNECTION_ERROR_DELAY; connectState = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } vTaskDelay(delay/portTICK_RATE_MS); } } //   uint16_t getRxData(uint8_t serviceNum, xSemaphoreHandle xRxPppData, uint8_t **ppBufPacket) { uint16_t retLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint16_t size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xSemaphoreTake(xRxPppData, <span class="hljs-number"><span class="hljs-number">1000</span></span>/portTICK_PERIOD_MS) == pdTRUE) { size = gsmLLR_TcpGetRxCount(serviceNum); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">1512</span></span>) { retLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { retLen = GsmLLR_TcpReadData(serviceNum, ppBufPacket, size); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retLen; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">GSM setting, details</b> <div class="spoiler_text"><pre> <code class="hljs bash">void gsmTaskInit(void) { xTaskCreate(vGsmTask, <span class="hljs-string"><span class="hljs-string">"GSM"</span></span>, configMINIMAL_STACK_SIZE*2, 0, tskIDLE_PRIORITY+1, &amp;gsmInitTaskId); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((!gsmState.init) || (!pppIsOpen)) {vTaskDelay(100/portTICK_PERIOD_MS);} } /*     GSM  */ void vGsmTask( void * pvParameters ) { //   GsmLLR_Init(); GsmLLR2_Init(); GsmPPP_Init(); //     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((gsmState.initLLR != <span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; (gsmState.initLLR2 != <span class="hljs-literal"><span class="hljs-literal">true</span></span>)){}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_PowerUp() != eOk) { GsmLLR_ModuleLost(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { //  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gsmState.init == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gsmState.notRespond == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: INIT Module lost\r\n"</span></span>); GsmLLR_ModuleLost(); <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_ATAT() != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_WarningOff() != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_FlowControl() != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } //  IMEI <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_GetIMEI(aIMEI) != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } DBGInfo(<span class="hljs-string"><span class="hljs-string">"GSM: module IMEI=%s\r\n"</span></span>, aIMEI); //  IMSI <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_GetIMSI(aIMSI) != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: module IMSI=%s\r\n"</span></span>, aIMSI); //  Software <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_GetModuleSoftWareVersion(aVerionSoftware) != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } //      (URC) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_AtCREG() != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: CREG OK\r\n"</span></span>); //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_UpdateCSQ(&amp;gsmCsqValue) != eOk) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: Get CSQ ERROR, -RELOAD\r\n"</span></span>); gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: CSQ value %d\r\n"</span></span>, gsmCsqValue); //  SMS <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_SmsModeSelect(sms_TEXT) != eOk) { gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } // sms vTaskDelay(DELAY_REPLY_INIT/portTICK_RATE_MS); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_SmsClearAll() != eOk) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: clear SMS ERROR, -RELOAD\r\n"</span></span>); gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: Clear SMS Ok\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: INIT PPPP\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_StartPPP(&amp;connectionSettings.gsmSettings) == eOk) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: INIT PPPP - PPP RUN\r\n"</span></span>); xQueueReset(uartParcerStruct.uart.rxQueue); uartParcerStruct.ppp.pppModeEnable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; uartParcerStruct.uart.receiveState = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; gsmState.init = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSM: INIT PPPP - PPP ERROR!!!\r\n"</span></span>); gsmState.notRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; } } } vTaskDelay(1000/portTICK_RATE_MS); } }</code> </pre> <br></div></div><br>  Raising PPP. <br><br>  To start the session 4 commands are used - comPPP_0-4.  How they are sent and the answer is analyzed we do not consider, this is a topic for a separate article.  Consider only in general terms: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">char</span></span> *comPPP_0[] = {"AT+CGDCONT=1,\"IP\","}; <span class="hljs-type"><span class="hljs-type">char</span></span> *comPPP_2[] = {"AT+CGQMIN=1,0,0,0,0,0"}; <span class="hljs-type"><span class="hljs-type">char</span></span> *comPPP_3[] = {"AT+CGQREQ=1,2,4,3,6,31"}; <span class="hljs-type"><span class="hljs-type">char</span></span> *comPPP_4[] = {"ATD*99***1#"}; eRetComm GsmLLR_StartPPP(sGsmSettings *pSettings) { printf("StartPPP\r\n"); sResultCommand resultCommand; <span class="hljs-type"><span class="hljs-type">char</span></span> **comPPP_Mass[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {comPPP_2, comPPP_3, comPPP_4}; uint8_t *pData = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_GetMutex() == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { pData = pvPortMalloc(GSM_MALLOC_COMMAND_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pData != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { memset(pData, <span class="hljs-number"><span class="hljs-number">0</span></span>, GSM_MALLOC_COMMAND_SIZE); sprintf((<span class="hljs-type"><span class="hljs-type">char</span></span>*)pData, "%s%s", comPPP_0[<span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-type"><span class="hljs-type">char</span></span>*)pSettings-&gt;gprsApn); RunAtCommand((<span class="hljs-type"><span class="hljs-type">char</span></span>*)pData, &amp;resultCommand); //  ,     uint8_t stepIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(stepIndex != (<span class="hljs-number"><span class="hljs-number">3</span></span>)) { uint16_t len = strlen((<span class="hljs-type"><span class="hljs-type">char</span></span>*)*comPPP_Mass[stepIndex]); sprintf((<span class="hljs-type"><span class="hljs-type">char</span></span>*)pData, "%s", (<span class="hljs-type"><span class="hljs-type">char</span></span>*)*comPPP_Mass[stepIndex]); RunAtCommand((<span class="hljs-type"><span class="hljs-type">char</span></span>*)pData, &amp;resultCommand); stepIndex++; } memset(pData, <span class="hljs-number"><span class="hljs-number">0</span></span>, GSM_MALLOC_COMMAND_SIZE); vPortFree(pData); } GsmLLR_GiveMutex(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eOk; }</code> </pre> <br></div></div><br>  From the vGsmTask task code, it follows that in case of successful execution of ‚ÄúGsmLLR_StartPPP‚Äù, the pppModeEnable flag is set and the uartParcerStruct.uart.rxQueue queue is cleared.  The pppModeEnable flag displays the current mode of the module.  The exchange between the interruption of the UART and the stack / command parser goes through a queue. <br><br><div class="spoiler">  <b class="spoiler_title">Task Session PPP at GSM Level</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> GsmPPP_Tsk(<span class="hljs-type"><span class="hljs-type">void</span></span> *pvParamter) { <span class="hljs-type"><span class="hljs-type">int</span></span> timeout = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint8_t i; <span class="hljs-type"><span class="hljs-type">bool</span></span> stateInit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; uint16_t tskStackInit; LwipStack_Init(); pppInit(); pppSetAuth(PPPAUTHTYPE_CHAP, connectionSettings.gsmSettings.gprsUser, connectionSettings.gsmSettings.gprsPass); sioWriteSemaphore = xSemaphoreCreateBinary(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;GSM_MAX_CONNECTION; i++) { connectionPppStruct.semphr[i] = xSemaphoreCreateBinary(); connectionPppStruct.rxData[i].rxSemh = xSemaphoreCreateBinary(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { //      PPP     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uartParcerStruct.ppp.pppModeEnable == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { pppNumport = pppOverSerialOpen(<span class="hljs-number"><span class="hljs-number">0</span></span>, linkStatusCB, &amp;pppIsOpen); pppStop = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout = <span class="hljs-number"><span class="hljs-number">0</span></span>; stateInit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(timeout &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pppIsOpen) { printf("PPP init - OK\r\n"); lwip_stats.link.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; lwip_stats.link.chkerr = <span class="hljs-number"><span class="hljs-number">0</span></span>; lwip_stats.link.err = <span class="hljs-number"><span class="hljs-number">0</span></span>; stateInit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; break; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ timeout ++; vTaskDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>/portTICK_RATE_MS); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stateInit != <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { printf("PPP init - TIMEOUT-ERROR\r\n"); pppClose(pppNumport); pppIsOpen = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; uartParcerStruct.ppp.pppModeEnable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; gsmState.init = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; gsmState.notRespond = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((lwip_stats.link.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> !=<span class="hljs-number"><span class="hljs-number">0</span></span>) || (lwip_stats.link.chkerr !=<span class="hljs-number"><span class="hljs-number">0</span></span>)) { lwip_stats.link.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; lwip_stats.link.chkerr = <span class="hljs-number"><span class="hljs-number">0</span></span>; printf("GSMM: DROPING FAIL!!! RESTART PPP\r\n"); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;SERVERS_COUNT; i++) { GsmPPP_Disconnect(i); } pppClose(pppNumport); pppIsOpen = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; uartParcerStruct.ppp.pppModeEnable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; gsmState.init = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; gsmState.notRespond = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; vTaskDelay(<span class="hljs-number"><span class="hljs-number">500</span></span>/portTICK_PERIOD_MS); } } } vTaskDelay(<span class="hljs-number"><span class="hljs-number">500</span></span>/portTICK_RATE_MS); } }</code> </pre> <br></div></div><br>  Common functions working with PPP <br><br><div class="spoiler">  <b class="spoiler_title">Connect-Disconnect, read connection status, send, etc.</b> <div class="spoiler_text"><pre> <code class="hljs bash">bool GsmPPP_Connect(uint8_t numConnect, char *pDestAddr, uint16_t port) { struct ip_addr resolved = {0}; bool useDns = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; uint8_t ipCut[4] = {0}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } sscanf(pDestAddr, <span class="hljs-string"><span class="hljs-string">"%i.%i.%i.%i"</span></span>, &amp;ipCut[0], &amp;ipCut[1], &amp;ipCut[2], &amp;ipCut[3]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((ipCut[0]!=0)&amp;&amp;(ipCut[1]!=0)&amp;&amp;(ipCut[2]!=0)&amp;&amp;(ipCut[3]!=0)) { IP4_ADDR(&amp;connectionPppStruct.ipRemoteAddr[numConnect], ipCut[0],ipCut[1],ipCut[2],ipCut[3]); //31,10,4,158); useDns = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ useDns = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connectionPppStruct.connected[numConnect] == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { connectionPppStruct.tcpClient[numConnect] = tcp_new(); // create tcpPcb tcp_recv(connectionPppStruct.tcpClient[numConnect], server_recv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(useDns == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { switch(dns_gethostbyname(pDestAddr, &amp;resolved, destServerFound, &amp;numConnect)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR_OK: // numeric or cached, returned <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> resolved connectionPppStruct.ipRemoteAddr[numConnect].addr = resolved.addr; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR_INPROGRESS: // need to ask, will <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> data via callback <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xSemaphoreTake(connectionPppStruct.semphr[numConnect], 10000/portTICK_PERIOD_MS) != pdTRUE) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_close(connectionPppStruct.tcpClient[numConnect]) != ERR_OK) { vTaskDelay(100/portTICK_PERIOD_MS); } connectionPppStruct.connected[numConnect] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: dns-ERROR\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } } tcp_connect(connectionPppStruct.tcpClient[numConnect], &amp;connectionPppStruct.ipRemoteAddr[numConnect], port, &amp;TcpConnectedCallBack); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xSemaphoreTake(connectionPppStruct.semphr[numConnect], 10000/portTICK_PERIOD_MS) == pdTRUE) { connectionPppStruct.connected[numConnect] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: connected %s\r\n"</span></span>, inet_ntoa(connectionPppStruct.ipRemoteAddr)); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ tcp_abort(connectionPppStruct.tcpClient[numConnect]);//tcp_close(connectionPppStruct.tcpClient[numConnect]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_close(connectionPppStruct.tcpClient[numConnect]) != ERR_OK) { vTaskDelay(100/portTICK_PERIOD_MS); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: connectTimeout-ERROR\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GsmLLR_ConnectServiceStatus(numConnect) == eOk) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT-already connected %s\r\n"</span></span>, inet_ntoa(connectionPppStruct.ipRemoteAddr)); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT CLOSE!!!\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } bool GsmPPP_Disconnect(uint8_t numConnect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connectionPppStruct.tcpClient[numConnect] == NULL) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_close(connectionPppStruct.tcpClient[numConnect]) != ERR_OK) { vTaskDelay(100/portTICK_PERIOD_MS); } connectionPppStruct.connected[numConnect] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } bool GsmPPP_ConnectStatus(uint8_t numConnect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connectionPppStruct.tcpClient[numConnect]-&gt;state == ESTABLISHED) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } bool GsmPPP_SendData(uint8_t numConnect, uint8_t *pData, uint16_t len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tcp_write(connectionPppStruct.tcpClient[numConnect], pData, len, NULL) == ERR_OK) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_close(connectionPppStruct.tcpClient[numConnect]) != ERR_OK) { vTaskDelay(100/portTICK_PERIOD_MS); } connectionPppStruct.connected[numConnect] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; connectionPppStruct.rxData[numConnect].rxBufferLen = 0; memset(connectionPppStruct.rxData[numConnect].rxBuffer,0, sizeof(connectionPppStruct.rxData[numConnect].rxBuffer)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } uint16_t GsmPPP_GetRxLenData(uint8_t numConnect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> connectionPppStruct.rxData[numConnect].rxBufferLen; } uint16_t GsmPPP_ReadRxData(uint8_t numConnect, uint8_t **ppData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!pppIsOpen) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: CONNECT ERROR - PPP closed\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connectionPppStruct.rxData[numConnect].rxBufferLen != 0) { *ppData = (uint8_t *) connectionPppStruct.rxData[numConnect].rxBuffer; uint16_t retLen = connectionPppStruct.rxData[numConnect].rxBufferLen; connectionPppStruct.rxData[numConnect].rxBufferLen = 0; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> retLen; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } static void destServerFound(const char *name, struct ip_addr *ipaddr, void *arg) { uint8_t *num = (uint8_t*)arg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*num &lt; SERVERS_COUNT) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: DEST FOUND %s\r\n"</span></span>, inet_ntoa(ipaddr-&gt;addr)); connectionPppStruct.ipRemoteAddr[*num].addr = ipaddr-&gt;addr; xSemaphoreGive(connectionPppStruct.semphr[*num]); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: DNS != SERVER%s\r\n"</span></span>, inet_ntoa(ipaddr-&gt;addr)); } } static err_t TcpConnectedCallBack(void *arg, struct tcp_pcb *tpcb, err_t err) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint8_t i=0; i&lt;SERVERS_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tpcb == connectionPppStruct.tcpClient[i]) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: connected (callback)%s\r\n"</span></span>, inet_ntoa(tpcb-&gt;local_ip.addr)); xSemaphoreGive(connectionPppStruct.semphr[i]); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } } } static err_t server_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) { LWIP_UNUSED_ARG(arg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(err == ERR_OK &amp;&amp; p != NULL) { tcp_recved(pcb, p-&gt;tot_len); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP:server_recv(): pbuf-&gt;len %d byte\n [%s]"</span></span>, p-&gt;len, inet_ntoa(pcb-&gt;remote_ip.addr)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint8_t i=0; i&lt;SERVERS_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pcb-&gt;remote_ip.addr == connectionPppStruct.tcpClient[i]-&gt;remote_ip.addr) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: server_recv (callback) [%s]\r\n"</span></span>, inet_ntoa(pcb-&gt;remote_ip.addr)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p-&gt;len &lt; sizeof(connectionPppStruct.rxData[i].rxBuffer)) { memcpy(connectionPppStruct.rxData[i].rxBuffer, p-&gt;payload, p-&gt;len); connectionPppStruct.rxData[i].rxBufferLen = p-&gt;len; xSemaphoreGive(connectionPppStruct.rxData[i].rxSemh); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: server_recv (callback) GIVE SEMPH[%s][%d]\r\n"</span></span>, inet_ntoa(pcb-&gt;remote_ip.addr), p-&gt;len); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: server_recv p-&gt;len &gt; sizeof(buf) -ERROR\r\n"</span></span>); } } } pbuf_free(p); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nserver_recv(): Errors-&gt; "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != ERR_OK) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"1) Connection is not on ERR_OK state, but in %d state-&gt;\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == NULL) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"2) Pbuf pointer p is a NULL pointer-&gt;\n "</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"server_recv(): Closing server-side connection..."</span></span>); pbuf_free(p); server_close(pcb); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> ERR_OK; } xSemaphoreHandle * GsmPPP_GetRxSemaphorePoint(uint8_t numService) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> (connectionPppStruct.rxData[numService].rxSemh); }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Functions related to TCP connection in LwIP, callback-s</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> err_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, struct tcp_pcb *pcb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">1</span></span>; LWIP_UNUSED_ARG(arg); LWIP_UNUSED_ARG(pcb); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nserver_poll(): Call number %d\n"</span></span>, counter++); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR_OK; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> err_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server_err</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">err_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> err)</span></span></span><span class="hljs-function"> </span></span>{ LWIP_UNUSED_ARG(arg); LWIP_UNUSED_ARG(err); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nserver_err(): Fatal error, exiting...\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR_OK; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tcp_pcb *pcb)</span></span></span><span class="hljs-function"> </span></span>{ tcp_arg(pcb, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); tcp_sent(pcb, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); tcp_recv(pcb, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_close(pcb) != ERR_OK) { vTaskDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>/portTICK_PERIOD_MS); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;SERVERS_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pcb == connectionPppStruct.tcpClient[i]) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: server_close (callback)%s\r\n"</span></span>, inet_ntoa(pcb-&gt;local_ip.addr)); connectionPppStruct.connected[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"GSMPPP: server_recv p-&gt;len &gt; sizeof(buf) -ERROR\r\n"</span></span>); } } }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Functions connecting the LwIP level with the UART and the GSM module, a very important point</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//      -    LwIP u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len) { unsigned long i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uartParcerStruct.ppp.pppModeEnable) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(xQueueReceive(uartParcerStruct.uart.rxQueue,&amp;data[i], <span class="hljs-number"><span class="hljs-number">0</span></span>) == pdTRUE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i==<span class="hljs-number"><span class="hljs-number">0</span></span>) { printf("Reading PPP packet from UART\r\n"); } printf("%0.2x ", data[i]); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pppStop||(i==len)) { pppStop = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { printf("\n"); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } //   LwIP  UART (GSM) u32_t sio_write(sio_fd_t fd, u8_t *data, u32_t len) { u32_t retLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uartParcerStruct.ppp.pppModeEnable) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_UART_Transmit_IT(&amp;huart3, data, len) == HAL_OK) { xSemaphoreTake(sioWriteSemaphore, portMAX_DELAY); retLen = len; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ printf("HAL ERRROR WRITE [sio_write]\r\n"); } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ printf("sio_write not in PPP mode!\r\n"); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retLen; } //  ,   <span class="hljs-type"><span class="hljs-type">void</span></span> sio_read_abort(sio_fd_t fd) { pppStop = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; xQueueReset(uartParcerStruct.uart.rxQueue); } u32_t sys_jiffies(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xTaskGetTickCount(); } //          static <span class="hljs-type"><span class="hljs-type">void</span></span> linkStatusCB(<span class="hljs-type"><span class="hljs-type">void</span></span> * ctx, <span class="hljs-type"><span class="hljs-type">int</span></span> errCode, <span class="hljs-type"><span class="hljs-type">void</span></span> * arg) { printf("GSMPP: linkStatusCB\r\n"); <span class="hljs-comment"><span class="hljs-comment">/* just wait */</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> *connected = (<span class="hljs-type"><span class="hljs-type">bool</span></span>*)ctx; struct ppp_addrs * addrs = arg; switch (errCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PPPERR_NONE: { <span class="hljs-comment"><span class="hljs-comment">/* We are connected */</span></span> printf("ip_addr = %s\r\n", inet_ntoa(addrs-&gt;our_ipaddr)); printf("netmask = %s\r\n", inet_ntoa(addrs-&gt;netmask)); printf("dns1 = %s\r\n", inet_ntoa(addrs-&gt;dns1)); printf("dns2 = %s\r\n", inet_ntoa(addrs-&gt;dns2)); *connected = <span class="hljs-number"><span class="hljs-number">1</span></span>; break; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PPPERR_CONNECT: { printf("lost connection\r\n"); <span class="hljs-comment"><span class="hljs-comment">/* just wait */</span></span> *connected = <span class="hljs-number"><span class="hljs-number">0</span></span>; break; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/* We have lost connection */</span></span> printf("connection error\r\n"); <span class="hljs-comment"><span class="hljs-comment">/* just wait */</span></span> *connected = <span class="hljs-number"><span class="hljs-number">0</span></span>; break; } } }</code> </pre> <br></div></div><br>  We send data via TCP terminal: <br><br><img src="https://habrastorage.org/web/a99/6aa/de7/a996aade73134bb39eef07dda87969f8.png"><br><br>  In the structures you can see the incoming package: <br><br><img src="https://habrastorage.org/web/1a2/0dd/016/1a20dd016b694ff786a5dfd3c21609fd.png"><br><br>  Let's sum up. <br><br>  Having abandoned AT commands, we managed to significantly reduce and simplify the code for parsing and sending commands, difficult (potentially unreliable) parsing of answers, receiving data and URC codes.  AT commands remained for initial modem setup and recording APN parameters. <br><br>  The PPP session recorded by the logic analyzer can be found <a href="https://yadi.sk/d/vxldzmMs3KbVyv">here</a> for detailed study. </div><p>Source: <a href="https://habr.com/ru/post/332742/">https://habr.com/ru/post/332742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332732/index.html">The Machine and Exaflops for the Big Data era</a></li>
<li><a href="../332734/index.html">Is robots revolt canceled?</a></li>
<li><a href="../332736/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ270 (July 3 - 9, 2017)</a></li>
<li><a href="../332738/index.html">Oracle Data Integrator. SubstitutionAPI: The order of the substitutions. Part 2</a></li>
<li><a href="../332740/index.html">Linux still not cake</a></li>
<li><a href="../332744/index.html">Why is there no Russian Amazon, or where is @ buried? Myths to close</a></li>
<li><a href="../332746/index.html">Hunting a red demon or satellite navigation direction finder</a></li>
<li><a href="../332748/index.html">Trading ASCII: Traditional Roguelike Early Access Sales Results</a></li>
<li><a href="../332750/index.html">Canvas & SVG: working with graphics</a></li>
<li><a href="../332754/index.html">Guide: Cucumber + Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>