<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Make frontend ‚Äúbackend‚Äù again</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolai Ryzhikov proposed his own version of the answer to the question of why it is so difficult to develop a user interface. Using the example of hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Make frontend ‚Äúbackend‚Äù again</h1><div class="post__text post__text-html js-mediator-article">  Nikolai Ryzhikov proposed his own version of the answer to the question of why it is so difficult to develop a user interface.  Using the example of his project, he will show that the application of some ideas from the backend on the front end affects both the reduction of the development complexity and the testability of the front end. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XBfi3Q74BnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  The material is based on the report of Nikolai Ryzhikov at the spring conference of <a href="https://holyjs-piter.ru/">HolyJS 2018 Piter</a> . <br><a name="habracut"></a><br>  At the moment, Nikolai Ryzhikov is working in the Health-IT sector to create medical information systems.  Member of the St. Petersburg community of functional programmers FPROG.  An active member of the Online Clojure community, a member of the HL7 FHIR standard for the exchange of medical information.  Engaged in programming for 15 years. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr><br>  - I was always tormented by the question: why was the graphic UI always difficult to do?  Why has it always caused a lot of questions? <br><br>  Today I will try to speculate on whether it is possible to effectively develop a user interface.  Can we reduce the complexity of its development. <br><br><h3>  What is efficiency? </h3><br>  Let's define what efficiency is.  From the point of view of developing a user interface, efficiency implies: <br><br><ul><li>  development speed, </li><li>  number of bugs </li><li>  the amount of money spent ... </li></ul><br>  There is a very good definition: <br><br><blockquote>  Efficiency is to do more by spending less </blockquote><br>  After this definition, you can put anything you want - spending less time, less effort.  For example, ‚Äúif you write less code, admit fewer bugs‚Äù and achieve the same goal.  In general, we spend a lot of energy in vain.  And efficiency is a high enough goal - to get rid of these losses and do only what is needed. <br><br><h3>  What is complexity? </h3><br>  In my opinion, complexity is the main problem in development. <br><br>  Back in 1986, Fred Brooks wrote an article called "No silver bullet".  In it, he reflects on the software.  In the gland, progress is leaps and bounds, and with software everything is much worse.  The main question of Fred Brooks - can there be such a technology that will accelerate us immediately by an order of magnitude?  And he gives a pessimistic answer, stating that in software it is not possible to achieve this, explaining his position.  I highly recommend reading this article. <br><br>  A friend of mine said that programming a UI is such a ‚Äúdirty problem.‚Äù  You can not sit down once and come up with the right option so that the problem will be solved forever.  In addition, over the past 10 years, the complexity of development has only increased. <br><br><h3>  12 years ago ... </h3><br>  We started developing a medical information system 12 years ago.  First with flash.  Then we looked at what Gmail started doing.  We liked it and we wanted to go to JavaScript with HTML. <br><br>  In fact, then we were well ahead of our time.  We took a dojo, and in fact we had all the same thing as it is now.  There were components well licked into dojo widgets, there was a modular build system and require that Google Clojure Compiler mined and minified (RequireJS and CommonJS did not even smell then). <br><br>  Everything worked out.  We looked at Gmail, were inspired, thought that everything was fine.  At the beginning, we wrote only the patient card reader.  Then they gradually moved to automating other workflows in the hospital.  And everything became difficult.  In a team like professionals - but each feature began to creak.  This feeling appeared 12 years ago - and it still does not leave me. <br><br><h3>  Rails way + jQuery </h3><br>  We did a system certification, and it was necessary to write a patient portal.  This is such a system where the patient can go and see their medical data. <br><br>  Our backend was then written on Ruby on Rails.  Despite the fact that the Ruby on Rails community is not very large, it has had a huge impact on the industry.  All your package managers, GitHub, Git, automatic makeups, etc. came from the small passionary community. <br><br>  The essence of the challenge we faced was that it was necessary to implement the patient portal in two weeks.  And we decided to try the Rails way - do everything on the server.  Such a classic web 2.0.  And they did it - they really did it in two weeks. <br><br>  We were ahead of the whole planet: we did SPA, we had a REST API, but for some reason it was inefficient.  Some features could already make units, because only they were able to contain all this complexity of components, interrelationships of the backend with the front-end.  And when we took the Rails way - a bit outdated by our standards, the features suddenly began to rivet.  The average developer started rolling out a feature in a few days.  And we even began to write simple tests. <br><br>  On this basis, I actually still have a trauma: there are still questions.  When we switched from Java to Rails on the backend, development efficiency increased about 10 times.  But when we scored on the SPA, the effectiveness of the development also increased significantly.  How so? <br><br><h3>  Why was web 2.0 effective? </h3><br>  Let's start with another question: why do we make a single page application, why do we believe in it? <br><br>  We just say: you need to do so - and we do.  And very rarely question it.  Is the REST API and SPA architecture correct?  Is it really suitable for the case where we use it?  We do not think. <br><br>  On the other hand, there are outstanding reverse examples.  Everyone enjoys github.  Did you know that GitHub is not a single page application?  GitHub is the usual ‚Äúrail‚Äù application that is rendered on the server, and where there are few widgets.  Has anyone suffered from this?  I think three people.  The rest did not even notice.  This did not affect the user in any way, but at the same time, we somehow have to pay for the development of other applications 10 times more (and strength, and complexity, etc.).  Another example is Basecamp.  Twitter was once just a Rails application. <br><br>  In fact, there are so many Rails applications.  This was partly determined by the DHH genius (David Heinemeier Hansson, creator of Ruby on Rails).  He was able to create a tool focused on business, which allowed him to immediately do what was needed, without being distracted by technical problems. <br><br>  When we used the Rails way, there was, of course, a lot of black magic.  Gradually developing, we switched from Ruby to Clojure, practically retaining the same efficiency, but making everything an order of magnitude easier.  And it was beautiful. <br><br><h3>  12 years have passed </h3><br>  Over time, new trends began to appear in the frontend. <br><br>  We completely ignored Backbone, because the dojo application we wrote before was even more sophisticated than Backbone offered. <br><br>  Then came Angular.  It was quite an interesting ‚Äúray of light‚Äù - in terms of efficiency, Angular is very good.  You take the average developer, and he rivet feature.  But from the point of view of simplicity, Angular brings a bunch of problems - it is opaque, complex, there is a watch, optimization, etc. <br><br>  React appeared, which brought a bit of simplicity (at least, the straightness of the render, which at the expense of Virtual DOM allows us to just redraw, just understand and just write) every time.  But in terms of efficiency, to be honest, React has significantly tilted us back. <br><br>  The worst thing is that in 12 years, nothing has changed.  We are still doing the same as now.  It's time to think - something is wrong here. <br><br>  Fred Brooks says that there are two problems in software development.  Of course, he sees the main problem in complexity, but divides it into two groups: <br><br><ul><li>  significant complexity that comes from the task itself.  It simply does not throw out, because it is part of the task. </li><li>  random complexity - this is the one that we bring, trying to solve this problem. </li></ul><br>  The question is, what is the balance between them.  This is exactly what we are discussing now. <br><br><h3>  Why does the User Interface hurt so much? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/667/d4e/d22667d4e3249034be27b07250a635ff.png"><br><br>  It seems to me that the first reason is our mental model of the application.  React, components are a purely OOP approach.  Our system is a dynamic graph of interconnected mutable objects.  Turing-complete types constantly generate nodes of this graph, some nodes disappear.  Have you ever tried to present your application in your head?  This is scary!  I usually present the OOP application as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cd/7b4/c7a/7cd7b4c7a846d2e973b012d566945a19.png"><br><br>  I recommend reading the theses of Roy Fielding (author of REST-architecture).  His thesis is called Architectural Styles and the Design of Network-based Software.  At the very beginning there is a very good introduction, where he tells how to get to the architecture in general, and introduces concepts: it breaks the system into components and connections between these components.  It has a ‚Äúzero‚Äù architecture, where all components can potentially be connected to all.  This is architectural chaos.  This is our object representation of the user interface. <br><br>  Roy Fielding recommends searching and imposing a set of constraints, because it is the set of constraints that determines your architecture. <br><br>  Probably the most important thing is that the restrictions are the friends of the architect.  Look for these real limitations and design a system for them.  Because freedom is evil.  Freedom means that you have a million options from which you can choose, and no criteria by which you can determine whether the choice was right.  Look for restrictions and build on them. <br><br>  There is an excellent article called OUT OF THE TAR PIT (‚ÄúEasier Pit of Pit‚Äù), in which the guys after Brooks decided to analyze what exactly contributes to the complexity of the application.  They came to the disappointing conclusion that the mutable, spread over the state system is the main source of complexity.  Here you can explain it purely combinatorially - if you have two cells, and each of them may contain (or not) a ball, how many states are possible?  - Four. <br><br>  If three cells - 2 <sup>3</sup> , if 100 cells - 2 <sup>100</sup> .  If you submit your application and understand how state is smeared, you realize that there are an infinite number of possible states of your system.  If you are not limited by this, it is too difficult.  And the human brain is weak; this has already been proven by various studies.  We are able to keep in mind up to three elements at the same time.  Some say seven, but even for this the brain uses a hack.  Therefore, complexity is really a problem for us. <br><br>  I recommend reading this article, where the guys come to the conclusion that something must be done with this mutable state.  For example, there are relational databases, there you can remove the entire mutable state.  And the rest is done in a purely functional style.  And they just come up with the idea of ‚Äã‚Äãsuch functional-relational programming. <br><br>  Thus, the problem comes from the fact that: <br><br><ul><li>  First, we do not have a good fixed user interface model.  Component approaches lead us to existing hell.  We do not impose any restrictions; we spread the mutable state; as a result, the complexity of the system at some point simply presses us; <br></li><li>  secondly, if we write a classic backend - frontend application, this is already a distributed system.  And the first rule of distributed systems - do not create distributed systems (First Distributing Object Design: Don't distribute your objects - by Martin Fowler), because you immediately increase the complexity by an order of magnitude.  Whoever wrote any integration, understands that as soon as you enter into intersystem interaction, all project estimates can be multiplied by 10. But we just forget about it and move on to distributed systems.  This was probably the main consideration when we switched to Rails, returning all control to the server. <br></li></ul><br>  All this is too hard for the poor human brain.  Let's think about what we can do with these two problems - the absence of restrictions in the architecture (graph of mutable objects) and the transition to distributed systems that are so complex that academics still puzzle how to do them correctly (at the same time condemning ourselves to these torments in the simplest business applications)? <br><br><h3>  How did the backend evolve? </h3><br>  If we write the backend in the same style in which we are creating the UI, there will be the same ‚Äúbloody mess‚Äù.  We will spend as much time on it.  So really once tried to do.  Then gradually began to impose restrictions. <br><br>  The first great backend invention is the database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/d5a/8aa/777d5a8aa62a6623e0918cdc57abdbee.png"><br><br>  At first, in the program, the entire state hung where it was unclear, and it was difficult to manage it.  Over time, the developers came up with a database and removed the entire state there. <br><br>  The first interesting difference of the database is that the data there are not some objects with their own behavior, this is pure information.  There are tables or some other data structures (for example, JSON).  They have no behavior, and this is also very important.  Because behavior is an interpretation of information, and there can be many interpretations.  And the basic facts - they remain basic. <br><br>  Another important point is that above this database we have a query language, for example, SQL.  In terms of limitations, in most cases SQL is not a turing-complete language, it is simpler.  On the other hand, it is declarative - more expressive, because in SQL you say ‚Äúwhat‚Äù and not ‚Äúhow‚Äù.  For example, when you combine two tables in SQL, SQL itself decides how to efficiently perform this operation.  When you are looking for something, he selects an index for you.  You never explicitly indicate this.  If you try to combine something in JavaScript, you have to write a bunch of code for this. <br><br>  Here, again, it is important that we have imposed restrictions and now we go to this base through a more simple and expressive language.  Redistributed complexity. <br><br>  After the backend entered the database, the application became stateless.  This leads to interesting effects - now we, for example, can not be afraid to update the application (in memory in the application layer we don‚Äôt have a state hanging, which will disappear if the application restarts).  For a stateless application layer, this is a good feature and a great limitation.  Overlay it if you can.  Moreover, an old application can be pulled on a new application, because the facts and their interpretation are not related things. <br><br>  From this point of view, objects and classes are terrible, because they stick together behavior and information.  Information is richer, it lives longer.  Bases and facts go through code written in Delphi, Perl or JavaScript. <br><br>  When the backend came to such an architecture, everything became much simpler.  The ‚Äúgolden‚Äù era of Web 2.0 has arrived.  You could get something from the database, template the data (a pure function) and return the HTML that is sent to the browser. <br><br>  On the back end, we learned how to write quite complex applications.  And most applications are written in this style.  But as soon as the backend takes a step to the side - into uncertainty - problems begin again. <br><br>  People began to think about it and came up with the idea of ‚Äã‚Äãthrowing out OOP and rituals. <br><br>  What are our systems actually doing?  They take information from somewhere - from the user, from another system and the like - put it into the base, transform it, somehow check it.  From the database they take it out with cunning queries (analytical or synthetic) and return it.  It's all.  And it is important to understand.  From this point of view, simulations are a very wrong and bad concept. <br><br>  It seems to me, in general, the whole PLO was actually born from the UI.  People tried to simulate and simulate the user interface.  They saw a certain graphic object on the monitor and thought: it would be nice to simulate it in our runtime, along with its properties, etc.  This whole story is very closely intertwined with the PLO.  But simulation is the most straightforward and naive way to solve the problem.  Interesting things are done when you step aside.  From this point of view, it‚Äôs more important to separate information from behavior, get rid of these strange objects, and everything will become much simpler: your web server receives the HTTP string, returns the HTTP response string.  If you add a base to the equation, you‚Äôll get a clean function: the server accepts the base and the request, returns the new base and the answer (the data is entered - the data is output). <br><br>  Along the way of this simplification, functionals threw another ‚Öî of baggage that had accumulated on the back end.  He was not needed, it was just a ritual.  We are still not a game dev - we do not need the patient and the doctor to somehow live in runtime, move and track their coordinates.  Our information model is something else.  We do not simulate medicine, sales or something else.  We are creating something new at the junction.  For example, Uber does not simulate the behavior of operators and machines - it introduces a new information model.  In our field, we also create something new, so you can feel freedom. <br><br>  Do not necessarily try to simulate completely - create. <br><br><h3>  Clojure = JS-- </h3><br>  It's time to tell exactly how you can throw everything.  And here I want to mention Clojure Script.  In fact, if you know JavaScript, you know Clojure.  In Clojure, we don‚Äôt add features to JavaScript, but remove them. <br><br><ul><li>  We throw out the syntax - there is no syntax in Clojure (in Lisp).  In ordinary language, we write some code, which is then parsed and obtained by AST, which is compiled and executed.  In Lisp, we immediately write AST, which can be executed - interpreted or compiled. <br></li><li>  We throw out mutability.  Clojure has no mutable objects or arrays.  Each operation generates, as it were, a new copy.  However, this copy is very cheap.  That's so cleverly done so that it is cheap.  And it allows us to work, as in mathematics, with values.  We do not change anything - we generate something new.  Safe, easy. <br></li><li>  We throw out classes, play games with prototypes, etc.  This is just not there. </li></ul><br>  As a result, we still have functions and data structures over which we operate, as well as primitives.  Here is the whole Clojure.  And on it you can do the same thing that you do in other languages, where there are a lot of unnecessary tools that nobody knows how to use. <br><br><h4>  Examples </h4><br>  How do we get to Lisp via AST?  Here is the classic expression: <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  If we try to write it AST, for example, in the form of an array, where the head is the type of the node, and what's next is a parameter, we will get something like this (we are trying to write it in Java Script): <br><br><pre> <code class="hljs json">['minus', ['plus', <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Now let's throw out extra quotes, minus can be replaced with <code>-</code> , and plus with <code>+</code> .  Throw away the commas, which in Lisp are whitespace.  We get the same AST: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  And in Lisp, we all write it this way.  We can check that this is a pure mathematical function (my emacs is connected to the browser; I throw a script there, it‚Äôs there an eval command and sends me back to emacs - you see the value after the <code>=&gt;</code> symbol): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  We can also declare a function: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> xplus [ab] (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) ((<span class="hljs-name"><span class="hljs-name">fn</span></span> [xy] (<span class="hljs-name"><span class="hljs-name">*</span></span> xy)) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Or an anonymous function.  Perhaps it looks a bit scary: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">type</span></span> xplus)</code> </pre><br>  Her type is a JavaScript function: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> xplus) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  We can call it by passing it a parameter: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">xplus</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  That is all that we do - we write AST, which is then either compiled into JS or bytecode, or interpreted. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> mymin [ab] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">a</span></span> &gt; b) ba))</code> </pre><br>  Clojure is hosted language.  Therefore, it takes primitives from the parent runtime, that is, in the case of Clojure Script we will have JavaScript types: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[Number]</code> </pre><br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "string") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[String]</code> </pre><br>  This is how regexps are written: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> #"^Cl.*$") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[RegExp]</code> </pre><br>  Our functions are functions: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> (fn [x] x)) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Next we need some composite types. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  This can be read as if you would create an object in JavaScript: <br><br><pre> <code class="hljs pgsql">(def <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span>: "niquola" ‚Ä¶</code> </pre><br>  Clojure calls this hashmap.  This is a container in which values ‚Äã‚Äãlie.  If square brackets are used, then this is called a vector - this is your array: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} =&gt; #'intro/user (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Any information we write hashmaps and vectors. <br><br>  Strange names with a colon ( <code>:name</code> ) are so-called characters: constant strings, which are created in order to use them as keys in hashmaps.  In different languages, they are called differently - symbols, something else.  But it can be perceived simply as a constant string.  They are quite effective - you can write long titles and not spend a lot of resources on it, because they are interned (i.e. they do not repeat). <br><br>  Clojure provides hundreds of functions that allow you to operate on these generic data structures and primitives.  We can add, add new keys.  At the same time, we have copying semantics everywhere, that is, every time we get a new copy.  First you need to get used to it, because it will not be possible to save something as before, somewhere in a variable, and then change this value.  Your calculation should always be straightforward - all arguments must be passed to the function explicitly. <br><br>  This leads to an important thing.  In functional languages, a function is an ideal component, because it receives everything explicitly at the input.  No hidden links diverging through the system.  You can take a function from one place, transfer it to another, and use it there. <br><br>  In Clojure, we have excellent equality operations by value, even for complex compound types: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">=</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) =&gt; true</code> </pre><br>  And this operation is cheap due to the fact that clever, immutable structures can be compared simply by reference.  Therefore, even a hashmap with millions of keys can be compared in one operation. <br><br>  By the way, the guys from React just copied the Clojure implementation and made immutable JS. <br><br>  Even in Clojure there are a lot of operations, for example, to get something on the nested path in a hashmap: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">get-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>])</code> </pre><br>  Put something in a hashmap along the nested path: <br><br><pre> <code class="hljs ruby">(assoc-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>] <span class="hljs-string"><span class="hljs-string">"LA"</span></span>) =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"LA"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}], <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>}</code> </pre><br>  Update some value: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">update-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span>] (<span class="hljs-name"><span class="hljs-name">fn</span></span> [old] (<span class="hljs-name"><span class="hljs-name">str</span></span> old <span class="hljs-string"><span class="hljs-string">"+++++"</span></span>)))</code> </pre><br>  Select only a specific key: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select-keys</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span>])</code> </pre><br>  The same with the vector: <br><br><pre> <code class="hljs pgsql">(def clojurists [{:<span class="hljs-type"><span class="hljs-type">name</span></span> "Rich"} {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Micael"}]) (first clojurists) (second clojurists) =&gt; {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Michael"}</code> </pre><br>  There are hundreds of operations from the base library that allow you to operate on these data structures.  There is an interop with host.  You need to get used to it a bit: <br><br><pre> <code class="hljs pgsql">(js/alert "Hello!") =&gt; nil &lt;/csource&gt;         "".    <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: &lt;source lang="clojure"&gt; (.-<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)</code> </pre><br>  There is every sugar, to walk on chain-am: <br><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -href) =&gt; "http://localhost:3000/#/billing/dashboard"</code> </pre><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -host) =&gt; "localhost:3000"</code> </pre><br>  I can take a JS date and return a year from it: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [d (<span class="hljs-name"><span class="hljs-name">js/Date</span></span>.)] (.getFullYear d)) =&gt; <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Rich Hickey - the creator of Clojure - severely limited us.  We really have nothing else, so we do everything through the generic data structure.  For example, when we write SQL, we usually write it with a data structure.  If you look carefully, you will see that it is just a hashmap in which something is nested.  Then there is some function that translates all this into a SQL string: <br><br><pre> <code class="hljs ruby">{select [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]} =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:select</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]}</code> </pre><br>  Routings we also write data structure and impose data structures: <br><br><pre> <code class="hljs ruby">{<span class="hljs-string"><span class="hljs-string">"users"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:users-list</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:welcome-page</span></span>}}</code> </pre><br><pre> <code class="hljs json">[:div.row [:div {:on-click #(.log js/console <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)} <span class="hljs-string"><span class="hljs-string">"User "</span></span>]]</code> </pre><br><h3>  DB to UI </h3><br>  So we discussed Clojure.  But earlier I mentioned that the database was a great achievement in the backend.  If you look at what is happening in the frontend now, we will see that the guys are using the same pattern - they enter the database in the User Interface (in a single page-application). <br><br>  Bases are entered in the elm-architecture, in the Clojure-script re-frame, and even in some limited form in flux and redux (here you need to install additional plug-ins to throw requests).  Elm architecture, re-frame, and flux ran at about the same time and borrowed from each other.  We write on re-frame.  Next, I'll tell you a little how it works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/11e/ddf/8ff11eddf7c9e2eb3254a3d9eee47d3d.png"><br><br>  From view-hee, we have an event crashes (this is a bit like redux), which is caught by some controller.  The controller we call event-handler.  An event-handler emits an effect, which is also someone interpreted by the data structure. <br><br>  One type of effect is to update the database.  That is, it takes the current value of the database and returns a new one.  We also have such a thing as subscription - an analogue of requests on the backend.  That is, these are some reactive queries that we can throw to this database.  These reactive requests we subsequently bandit on the view-shku.  In the case of react, we seem to completely redraw, and if the result of this query has changed, this is convenient. <br>  React is present only somewhere at the very end, but in general the architecture is in no way connected with it.  It looks something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/655/922/42b65592288ba93676e13b086f3f48b7.png"><br><br>  Here what is missing is added, for example, in redux. <br><br>  First, we separate the effects.  The application on the frontend is not independent.  He has a kind of backend - a kind of, ‚Äúsource of true.‚Äù  The application must constantly write something there and read something from there.  Even worse, if he has several backends to which it should go.  In the simplest implementation, you could do it right in the action creater, in your controller, but this is bad.  Therefore, the guys from the re-frame introduce an additional level of indirection: a kind of data structure flies out of the controller, telling you what to do.  And this message has a handler that does the dirty work.  This is a very important introduction, which we will discuss later. <br><br>  It is also important (they sometimes forget about it) - there must be some ground-facts in the database.  Everything else can be derived from the database - and requests usually do this, they transform the data - they do not add new information, but structure the existing one in the right way.  We need this query.  In redux, in my opinion, this now provides reselect, and in our re-frame it is out of the box (built-in). <br><br>  Look at the diagram of our architecture.  We reproduced a small backend (in the style of Web 2.0) with a base, controller, view.  The only thing added is reactivity.  This is very similar to MVC, except that everything is in one place.  Once upon a time, the early MVCs created their own model for each widget, but here everything is folded into one base.  In principle, you can synchronize with the backend from the controller through the effect, you can come up with a more generic-like view, so that the base works like a proxy to the backend.  There is even some kind of generic algorithm: you write to your local database, and it synchronizes with the main one. <br><br>  Now, in most cases, the base is just an object to which we write something to redux.  But in principle, you can imagine that further it will develop into a full-fledged database with a rich query language.  Perhaps with some kind of generic-sync.  For example, there is a datomic - a logical database triple-store, which is chased right in the browser.  You raise it and put there your entire state.  Datomic has a fairly rich query language, comparable in power to SQL, and in some places even winning.  Another example - Google wrote lovefield.  Everything will move somewhere there. <br><br>  Next, I will explain why we need reactive subscription. <br><br>  Now we get the first naive perception - we got the user from the backend, put it in the database and then we need to draw it.  At the time of rendering, there is a lot of definite logic, but we mix it up with rendering, with presentation.  If we immediately take on drawing this user, we‚Äôll have a big, tricky piece that does something with Virtual DOM and something else.  And it is mixed with the logical model of our view. <br><br>  A very important concept that needs to be understood: because of the complexity of the UI, it also needs to be modeled.  It is necessary to separate the way he draws (as he imagines) from his logical model.  Then the logical model will be more stable.  It can not be burdened with dependence on a specific framework - Angular, React or VueJS.  The model is the usual first class citizen in your runtime.  Ideally, if it is just some data and a set of functions above them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/52f/9c3/c7b52f9c3c048a91276c3ae8dcd33771.png"><br><br>  That is, from the backend model (subject) we can get a view model, in which, without using any rendering yet, we can recreate a logical model.  If there is any kind of menu or something like that, all this can be done in the view model. <br><br><h3>  What for? </h3><br>  Why do we do all this? <br><br>  I met good tests on the UI only where there is a staff of 10 testers. <br>  Usually there is no UI testing.  Therefore, we are trying to push this logic out of the components in the view model.  The absence of tests is a very bad sign, indicating that there is something wrong, somehow all is badly structured. <br><br>  Why is UI difficult to test?  Why did the guys on the backend learn how to test their code, provided huge coverage and it really helps to live with the backend code?  Why is the UI wrong?  Most likely, we are doing something wrong.  And everything that I described above actually moved us towards testability. <br><br><h3>  How do we do tests? </h3><br>  If you look closely, the part of our architecture that contains the controller, subscription, and database is in no way connected even with JS.  That is, it is some kind of model that operates with just data structures: we add them somewhere, somehow transform them, remove the query.  Through effects, we have cut off interaction with the outside world.  And this piece is completely portable.  You can write it on the so-called cljc - this is a common subset between Clojure Script and Clojure, which behaves the same way there and there.  We can just cut this piece from the frontend and put it in the JVM - where the backend lives.  Then we can write another effect in the JVM, which directly hits the end-point - pulls the router without any transformations of the http-shnoy line, parsing, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/b23/d1d/5b2b23d1d90d589a6cff9d99582d416d.png"><br><br>  As a result, we can write a very simple test - the same functional integral test that the guys write on the back end.  We throw a certain event, it throws an effect that directly hits the endpoint on the back end.  That returns something to us, puts in base, subscription is calculated, and in subscription logical view lies (we as much as possible put logic of the user interface there).  We will assert this view. <br><br>  Thus, we can test 80% of the code on the backend, while all the tools for backend development are available to us.  We can recreate a certain situation in the database using fixtures or some factories. <br><br>  For example, we have a new patient or something unpaid, etc.  We can go through a bunch of possible combinations. <br><br>  Thus, we can overcome the second problem - the distributed system.  Because the contract between the systems is precisely the main sore spot, because these are two different runtimes, two different systems: the backend has changed something, and something has broken on our frontend (we cannot be sure that this will not happen). <br><br><h3>  Demonstration </h3><br>  Here is how it looks in practice.  This is a backend helper who cleared the base and wrote some world into it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/ef0/e23/919ef0e23883707631e051ff6c62acf6.png"><br><br>  Next we throw subscription: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/bcb/35a/2a1bcb35a77444806d276e859f7aaebb.png"><br><br>  Typically, the URL completely defines the page and throws some event - you are now on such and such a page with a set of parameters.  Here we went to a new workflow and our subscription returned: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/956/34e/776/95634e7760690ebbef5ce5bbc51de9d6.png"><br><br>  Behind the scenes, he went to the base, got something, put it in our UI-base.  Subscription on it worked and derived from it the logical View model. <br><br>  We initialized it.  And here is our logical model: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d84/ee7/e0a/d84ee7e0a7e22ab8da638d8488df8833.png"><br><br>  Even without looking at the User interface, we can guess what will be drawn on this model: some kind of warning will come, some patient information, encounters and a set of references (this is a workflow widget that leads the front desk on certain steps when the patient arrives). <br><br>  Here we come up with a more complex world.  We made some payments and also tested them after initialization: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/032/f24/4ea032f24871cc57608dddf4687c30d7.png"><br><br>  If he has already paid for the visit, he will see this in the user interface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/71a/910/0b871a910ae3741ebd45e2b442f76d9c.png"><br><br>  We run tests, we expose on CI.  Sync between the backend and the front-end will already be guaranteed with tests, and not with an honest word. <br><br><h3>  Back to backend? </h3><br>  We entered the tests six months ago, and we really liked it.  There remains the problem of blurred logic.  The smarter the business application behaves, the more information it needs for some steps.  If you try to run some kind of workflow from the real world there, depending on everything will appear: for each user interface you need to get something from different parts of the base on the backend.  If we write accounting systems, this can not be avoided.  In the end, as I said, all the logic is spread. <br><br>  With the help of such tests, we can create the illusion at least at dev-time - at the time of development - that we, like in the old days web 2.0, are sitting on the server in the same runtime and everything is comfortable. <br><br>  There was another crazy idea (it has not yet been implemented).  Why not drop this part on the backend at all?  Why not get away from the distributed application right now?  Let this subscription and our view model be generated on the backend?  There base is available, all synchronously.  Everything is simple and clear. <br><br>  The first plus that I see in this is that we will have control in one place.  We just simplify everything at once compared to our distributed application.  Tests become simple, double validations disappear.  The fashionable world of interactive multi-user systems is opening (if two users have come to the same form, we tell them about it; they will be able to edit it at the same time). <br><br>  An interesting feature appears: by going to the backend and session prospects, we can understand who is currently in the system and what it is doing.  This is a bit like a game dev, where servers do something like this.  There the world lives on the server, and the frontend only renders.  As a result, we can get some thin client. <br><br>  On the other hand, it creates a challenge.  We will have to have a statefull server on which these sessions live.  If we have several app servers, it will be necessary to balance the load somehow or replicate sessions.  However, there is a suspicion that this problem is less than the number of advantages that we get. <br><br>  Therefore, I come back to the main slogan: there are many types of applications that can be written not distributed, to throw out complexity from them.  And you can get a multiple increase in efficiency, if you once again revise the basic tenets on which we relied in the development. <br><br><blockquote>  If you like the report, please note: on November 24-25, a new <b>HolyJS</b> will take place in Moscow, and there will also be many interesting things there.  Already known information about the program - <a href="https://holyjs-moscow.ru/">on the site</a> , and tickets can be purchased there. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/421789/">https://habr.com/ru/post/421789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421779/index.html">OceanLotus: New Backdoor, Old Schemes</a></li>
<li><a href="../421781/index.html">Yandex has deleted both pirated links and links to the sites of the copyright holder</a></li>
<li><a href="../421783/index.html">Fun State Management Huex Framework</a></li>
<li><a href="../421785/index.html">California is on the verge of a complete abandonment of carbon in energy production</a></li>
<li><a href="../421787/index.html">Design project architecture, ships and javascript</a></li>
<li><a href="../421791/index.html">Ethical Issues of Artificial Intelligence</a></li>
<li><a href="../421793/index.html">Looking for the best or how we chose the blockchain network for the project</a></li>
<li><a href="../421795/index.html">Data-driven decision on the example of choosing the color for painting walls</a></li>
<li><a href="../421797/index.html">Why do you need Splunk? Monitoring the work of the IT infrastructure</a></li>
<li><a href="../421799/index.html">How to get remotely in a company that does not take remote employees?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>