<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make friends unit testing with a database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of how the system of automatic testing of methods interacting with the database was developed, with a detailed description of the pitfalls e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make friends unit testing with a database</h1><div class="post__text post__text-html js-mediator-article"><img alt="  TDD      " title="How to make friends TDD approach when working with a database" src="https://habrastorage.org/files/a8c/dbe/d6d/a8cdbed6dd6042fb8e366b42fabc4f47"><br>  The story of how the system of automatic testing of methods interacting with the database was developed, with a detailed description of the pitfalls encountered in the development and implementation of the system in the project environment. <br><a name="habracut"></a><br><br><hr><br><h1>  Introductory word </h1><br>  When we started working on a new project, the idea was to use the <abbr title="Test Driven Development">TDD</abbr> approach and, accordingly, write unit tests for each of the components used.  Since  the whole project works closely with the database, then, of course, the question was raised about what to do with the components connected directly to the database, and how to test them.  We did not find a quick way to solve this problem and decided to postpone this issue for later.  But he did not cease to let me go for a long time and one day I managed to develop a framework within the framework of a working project that allowed us to quickly test the interaction with the database. <br><br>  The testing system was developed within the framework and context of the working project, in which its own ORM database system is used, which accepts parameterized SQL queries and, on output, independently parses the resulting tabular data into objects.  What imposes some restrictions in the development of testing systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I want to immediately say that I call the developed tests modular, but in fact they are integration tests that only have all the conveniences and advantages of modular tests. <br><br><hr><br><h1>  Motivation </h1><br>  Why do we force ourselves to write unit tests?  To improve the quality of the developed application.  The more developed a project, the more likely it is to break something, especially during refactoring.  Unit tests allow you to quickly verify the correctness of the system components.  But writing unit tests for methods that interact with the database is not such an easy task, because  For the test to work correctly, a customized environment is required, and more precisely, then: <br><br><ol><li>  Configured database server </li><li>  Correctly configured database connection strings </li><li>  Test database with all required tables </li><li>  Correctly filled tables in a test database </li></ol><br><br>  And it all looks quite difficult, so most developers do not even think about it.  Accordingly, my goal was to develop a system that would simplify the writing of tests to such an extent that they do not differ from the usual unit tests of other components of the project. <br><br><hr><br><h1>  Description of the problem </h1><br>  Before starting a story about development, I would also like to tell you how, in most cases, such things are tested and what it can lead to. <br><br><h4>  1. Testing a query in the database </h4><br>  Before the developer wrote a method that interacts with the database, he writes a normal SQL query with parameters and checks its operation on his local copy of the database.  This is the fastest and easiest way to check the request for errors.  But it is worth noting that with this approach you can make a mistake during the transfer of the request to the project code or in the code that executes this request.  As an example: you can accidentally skip the initialization of some parameters, which will lead to incorrect operation of the request. <br><br><h4>  2. Testing through a direct method call </h4><br>  Another simple way is to simply open a section of code that is always executed in our application, for example Main, call a method that interacts with the database, set a breakpoint and see the result ... Very similar to debugging through displaying informational messages on the screen. <br><br><h4>  3. Testing through the user interface of the application </h4><br>  Another very interesting and quite popular way to test the written method.  Take the application, and perform a chain of sequential actions that lead to a call to your method that interacts with the database.  The method is rather complicated and does not guarantee that the request is actually executed, because  the application could, instead of executing it, access the cache or perform another operation, because this was indicated somewhere in the settings. <br><br>  And all these difficulties lead to the fact that you have to spend a lot of time testing quite simple things.  And, as you know, if it is checked for a long time, then most likely the developer is too lazy to test it, which will lead to errors.  According to statistics, about 5% of errors associated with non-working database queries are registered in the bug tracker.  But I also want to note that the majority of such errors are discussed verbally and often enough, and unfortunately, they cannot be taken into account in these statistics. <br><br><hr><br><h1>  Development start </h1><br>  After I convinced you of the need for this system, you can proceed to the description of the process of its creation. <br><br><h2>  How to develop an automated testing system? </h2><br>  The first questions I have are how to develop such a system, what requirements should it meet?  Therefore, I had to spend time researching the subject area, despite the fact that I constantly write unit tests.  Testing system development is a completely different field.  In this study, I tried to find existing solutions, to find possible ways to implement.  But first I had to remember the principles of developing unit tests: <br><br><ol><li>  One test must match one scenario. </li><li>  The test should not depend on time and various random variables. </li><li>  The test must be atomic </li><li>  Test run time should be short </li></ol><br><br>  After that, I needed to develop a testing process that would meet these requirements. <br><br><h2>  What testing process is suitable? </h2><br>  As a result of a long reflection, a simple 3-stage process was developed: <br><br><ol><li>  <b>Initialization</b> - at this stage, a connection was made to the database server, the loading of initialization scripts of the new database, as well as its analysis.  After that, a new empty database was created, which will be used to run the test method.  And of course, its initialization is a necessary structure. </li><li>  <b>Execution</b> is a test method that meets the <abbr title="Arrange, Act, Assert">AAA</abbr> approach. </li><li>  <b>Completion</b> - at this moment the used resources are released: deletion of the used database, completion of open connections to the database server. </li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e25/3e1/64a/e253e164a8e14a38a064a96f4e758662" alt="   " title="Diagram of the developed testing process"></div><br><br>  Thus, thanks to this process, we managed to satisfy the requirements that unit tests must meet.  Since  each test method will run on a dedicated database, then we can say that they are atomic and, accordingly, can be run in parallel. <br><br><hr><br><h1>  Analysis of the developed system </h1><br><h2>  Performance </h2><br>  Perhaps now, many might think that this approach will not work quickly on big data, and they will be right.  The project is large, the database is large, contains many different tables and initial data, respectively, the initialization of the new database is prohibitively long.  The table below shows the result for one test: <br><br><table><tbody><tr><th>  Initialization stage </th><th>  Time, ms </th><th>  Share </th></tr><tr><td>  <b>File upload</b> </td><td>  6 </td><td>  &lt;1% </td></tr><tr><td>  <b>Script preparation</b> </td><td>  nineteen </td><td>  &lt;1% </td></tr><tr><td>  <b>Parsing script</b> </td><td>  211 </td><td>  one% </td></tr><tr><td>  <b>Execution of script commands</b> </td><td>  14660 </td><td>  98% </td></tr><tr><td>  <b>Total</b> </td><td>  <b>14660</b> </td><td></td></tr></tbody></table><br><br>  As you can see, it takes about 15 seconds to initialize one test database.  But the project will clearly write more than one test.  If we assume that about 100 tests are written in the project, then their total execution time will be more than half an hour!  Immediately it became clear that such tests do not meet the basic principles - short execution time. <br><br>  I had to sit down for the analysis of system performance.  I have identified four main sections of the test initialization that can be optimized.  As a result, I received a table that is presented above, and as can be seen from it, 98% of the time is spent on the stage involved in sending commands to the test database initialization script.  We had two main ideas that would help correct this situation - the use of transactions and the use of only the tables we need from the database being tested. <br><br>  The first option was to test a set of methods using a single database that was created in advance.  Next, to perform each method, including the insertion of test data, it was surrounded by a transaction.  After executing the test method, the transaction was rolled back and thus the database remained in its pure form ... had to remain in its pure form.  But as it turned out, most of the tables that are used on the project use the MyISAM engine.  Which is not known to support transactions.  But this is not the only reason this option was dropped.  As mentioned earlier, the test must be completely atomic, in order to be able to run tests in parallel.  And since  this approach relies on the use of one common database, this completely violates the atomicity of the test, which does not meet the above requirements. <br><br>  The second option is that at the time of writing the tests, the developer himself indicates which tables he will need to perform this test.  The system automatically found these tables in the database initialization script, as well as all the necessary dependencies, such as initialization data or additional tables linked by a secondary key.  This approach ensured the atomicity of each test.  After the new mechanism was implemented in already written tests, I also took a measurement of the average test initialization time, the result is presented in the table below: <br><br><table><tbody><tr><th>  Initialization stage </th><th>  Time, ms </th><th>  Share </th></tr><tr><td>  <b>File upload</b> </td><td>  6 </td><td>  one% </td></tr><tr><td>  <b>Script preparation</b> </td><td>  22 </td><td>  five% </td></tr><tr><td>  <b>Parsing script</b> </td><td>  254 </td><td>  62% </td></tr><tr><td>  <b>Execution of script commands</b> </td><td>  134 </td><td>  32% </td></tr><tr><td>  <b>Total</b> </td><td>  <b>416</b> </td><td></td></tr></tbody></table><br><br>  As you can see after this optimization, we managed to save 97% of the time!  A good step towards quick tests for testing database queries.  This table also shows that there is still room for optimization, but at the moment this test run time fully meets the needs and requirements. <br><br><h2>  Development of an automatic data generation system </h2><br>  With the performance of the system everything was fine, but for some reason most of the developers in the project still avoided this system.  I had to understand why this happens.  As it turned out, writing tests for such a system also took a lot of time and skill to fill all the necessary data.  Just take a look at this code: <br><br><pre><code class="hljs pgsql">[TestMethod] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> GetInboxMessages_ShouldReturnInboxMessages() { const <span class="hljs-type"><span class="hljs-type">int</span></span> validRecipient = <span class="hljs-number"><span class="hljs-number">1</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> wrongRecipient = <span class="hljs-number"><span class="hljs-number">2</span></span>; var recipients = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> [] { validRecipient }; //        ,    var message = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MessageEntity(); HelperDataProvider.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(message); //        var validInboxMessage = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InboxMessageEntity() { MessageId = message.MessageId, RecipientId = validRecipient }; var wrongInboxMessage = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InboxMessageEntity() { MessageId = message.MessageId, RecipientId = wrongRecipient }; //      HelperDataProvider.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(validInboxMessage); HelperDataProvider.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(wrongInboxMessage); //   var collection = _target.GetInboxMessages(recipients); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, collection.Count); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.IsNotNull(collection.FirstOrDefault(x =&gt; x.Id == validInboxMessage.Id)); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">IsNull</span></span>(collection.FirstOrDefault(x =&gt; x.Id == wrongInboxMessage.Id)); }</code> </pre> <br><br>  The test is written using the AAA approach, the first part is creating new entities, linking them and inserting them into the database.  Then the method being tested is called, and then the result is checked.  And this is another simple case when we have a secondary key binding with only one table and there are no additional requirements for the filled fields.  And now let's see the same example, but using the system of automatic generation of entities: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInboxMessages_ShouldReturnInboxMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> validRecipient = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrongRecipient = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recipientsCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesCount = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recipients = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { validRecipient }; <span class="hljs-comment"><span class="hljs-comment">//       DataFactory.CreateBuilder&lt;InboxMessageEntity&gt;() //     ,         .UseForeignKeyRule(InboxMessageEntity inboxEntity =&gt; inboxEntity.MessageId, MessageEntity messageEntity =&gt; messageEntity.MessageId) //        .UseEnumerableRule(inboxEntity =&gt; inboxEntity.RecipientId, new[] { validRecipient, wrongRecipient }) //  ,   N:N,             .SetDefaultGroup(new FixedGroupProvider(recipientsCount)) //   -        .CreateMany(messagesCount * recipientsCount) .InsertAll(); //   var collection = _target.GetInboxMessages(recipients); Assert.AreEqual(messagesCount, collection.Count); Assert.IsTrue(collection.All(inboxMessage =&gt; inboxMessage.RecipientId == validRecipient)); }</span></span></code> </pre><br><br>  Just a few lines of setting up the generator and at the output we get a completely ready for testing database with all the necessary data.  This system is based on the rules for entities, as well as on the basis of the grouping of these rules.  This approach allows you to customize relationships between entities of the form N: N or N: 1.  This system has the following rules: <br><br><ul><li>  <b>DataSetterRule</b> - allows you to specify specific values ‚Äã‚Äãfor one of the fields of the entity </li><li>  <b>EnumerableDataRule</b> - allows you to set a list of values ‚Äã‚Äãthat will alternate for different entities.  For example, the first value from the list will be set for the first created entity, the second value for the second, and so on.  using cycling </li><li>  <b>RandomDataRule</b> - generates a random value from the list of available ones; it is very convenient to use to generate big data in order to test a complex query for performance </li><li>  <b>UniqueDataRule</b> - generates a random unique value for the specified entity field.  This rule is good for the case when you need to create a set of entities in which a unique constraint is imposed on a column in a table. </li><li>  <b>ForeignKeyRule</b> - the most useful rule allows you to link two entities.  Setting for this rule the grouping of entities, you can as a result get connections between entities of the form N: N or N: 1 </li></ul><br><br>  By manipulating these rules you can create different data sets.  After the <i>CreateMany</i> or <i>CreateSingle</i> method is called to create an entity, the builder will go through all the necessary rules, fill the entity and then save it into a separate internal buffer.  And only after the <i>InsertAll</i> method is called, the <i>builder</i> will send all the entities to the database.  The scheme of work is presented below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c84/ecd/7ec/c84ecd7ecd054074b00f5666a64d461e" title="The scheme of the data generator" alt="   "></div><br><br><h2>  Implementation of the system in the project environment </h2><br>  Of course, the introduction of this system in the deployment process was mandatory, because  few developers start tests manually.  Running every time you deploy an application is the perfect way to solve this problem. <br><br>  Unfortunately, this system is not recommended to be built into the assembly process, since  the server that builds should not have access to test database servers, and the testing process itself is resource-intensive, so it was decided to postpone the process of running integration tests to a test environment.  To do this, a separate deployment step was created to run the tests, with a set of scripts that automatically started the testing agent and analyzed the result of its work.  The standard test agent from Microsoft, <i>MSTestAgent, was</i> used to run the tests.  Writing scripts for analysis facilitated the fact that the test result file was recorded in <i>XML format</i> and therefore all the analysis of the results was reduced to a couple of simple <i>XQuery</i> queries.  On the basis of the data obtained, reports were built that later were sent to the developers' mail or, if necessary, to the chat team. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/802/bcb/001/802bcb0013564c6c85510809a9eac47b" alt="      " title="The scheme of the test run and alert developers"></div><br><br><hr><br><h1>  Conclusion </h1><br>  During the development, we had to solve two serious problems that could force us to abandon the further use of this system: a long test execution time, and the complexity of test data initialization. <br><br>  After the system of automatic testing of requests to the database was developed, it became much easier to write and test the code associated with requests to the database.  The TDD approach can be safely applied not only for ‚Äúclassic‚Äù components, but also for components that interact closely with the database.  After the integration of this system into the project environment, it became much easier to monitor the quality of the project, since  the incorrect behavior of the components is detected during the project build and is immediately visible to all developers. <br><br>  And finally, I would like to know how the data access level is tested on your projects? </div><p>Source: <a href="https://habr.com/ru/post/304322/">https://habr.com/ru/post/304322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304306/index.html">NetApp ONTAP 9</a></li>
<li><a href="../304308/index.html">std :: shared_ptr and custom allocator</a></li>
<li><a href="../304312/index.html">LoRa technology</a></li>
<li><a href="../304316/index.html">How to quickly create product descriptions for your store</a></li>
<li><a href="../304320/index.html">PostgreSQL based application performance: explicit and hidden latency</a></li>
<li><a href="../304324/index.html">Second rows of associations, or how to make the robot read "between the lines"</a></li>
<li><a href="../304326/index.html">Proportions in art. Is there anything better than the golden section? Research over 1,000,000 old and modern paintings</a></li>
<li><a href="../304328/index.html">Telegram bot and PostGIS</a></li>
<li><a href="../304332/index.html">How does Apple Pay affect the payment industry?</a></li>
<li><a href="../304340/index.html">Optimize React application to display a list of items</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>