<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compilation. 5: downward parsing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Up to now they have been engaged in ascending parsing. What other options are there? 
 Put the bison aside, and return to the theory. 

 Further in th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compilation. 5: downward parsing</h1><div class="post__text post__text-html js-mediator-article">  Up to now they have been engaged in ascending parsing.  What other options are there? <br>  Put the bison aside, and return to the theory. <br><br><h3>  Further in the post: </h3><ol><li>  Idea </li><li>  Embodiment </li><li>  Holivar </li><li>  Backtracking </li></ol><a name="habracut"></a><br><h3>  Idea </h3><br>  Remember that the <a href="http://habrahabr.ru/blogs/programming/99298/">general idea of ‚Äã‚Äãan</a> upward parsing is as follows: reading the input line, we shift it one character to the stack;  as soon as a combination is formed at the top of the stack that fits any rule of grammar, we fold it into one non-terminal, and continue further. <br>  An important feature of this method is that during the convolution of the rule, we already have all its components in our hands, and we can <a href="http://habrahabr.ru/blogs/programming/99397/">build a tree of them</a> with whatever structure we want, or even <a href="http://habrahabr.ru/blogs/programming/99366/">use it for calculations</a> on the fly. <br><br>  The opposite approach is that we begin to <i>expand the</i> initial grammar symbol, choosing a rule to be expanded according to the following input symbol. <br>  For example, if we have rules in grammar <pre> OP: '{' OPS '}' // block
     |  EXPR ';'  // expression
     |  'if' '(' EXPR ')' OP
     |  'if' '(' EXPR ')' OP 'else' OP
     |  'while' '(' EXPR ')' OP
     |  'exit' ';'  ;
</pre> and we see that further in the text goes <code>while</code> , then we will unfold according to the rule <code>OP: 'while' '(' EXPR ')' OP ;</code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a store machine, such parsing can be implemented as follows: <ul><li>  During the sweep, we write the right side of the rule onto the stack: we will continue to parse the text according to it. </li><li>  If there is a terminal at the top of the stack, and the same terminal in the input text, it means that the text corresponds to the expected one.  Remove the top terminal from the stack, read the next character of the text. </li><li>  If at the top of the stack is a non-terminal, then it must be deployed.  The rule for scanning is selected based on the input symbol. </li></ul>  Immediately, we note that it is pointless to perform an action when deploying: the right side of the expanded rule has not yet been read, and it is not known whether it will be read at all.  It could be possible to put a dummy-signal ‚Äúrule read successfully, you can perform an action‚Äù on the stack under the symbols of the right part of the stack on the right side of the stack;  but at this point, the entire right-hand side has already been erased from the stack!  What is the action going to work with? <br><br>  But the main difficulty of the downward analysis is not in this, but in how to choose the appropriate rule for scanning. <br>  Recall a grammar that is too tough for a bison: <pre> WORD: S1 'a' 'i' 'l' |  S2 'a' 'l' 'e';
 S1: 's';
 S2: 's';
</pre><br>  How do we deploy the <code>WORD</code> when the next <code>'s'</code> character? <br>  It is not clear how to choose: both rules for <code>WORD</code> begin exactly at <code>'s'</code> . <br><br><h3>  Embodiment </h3><br>  You can allow the machine to look further than one character further: judging by the reviews, this approach was used in ANTLR, a popular generator of LL parsers. <br>  The technical difficulty is that each new symbol, on which the execution of the scan depends, increases the <i>dimension</i> of the transition tables;  so uncompressed tables for an automaton of N states, reading 3 characters from the text (plus the character from the stack), would contain N ¬∑ 256 <sup>4</sup> elements, and these are tens of gigabytes. <br>  Therefore, the applicability of LL parsing with a far look ahead is determined precisely by the ability of the parser generator to compress tables efficiently (recall how the bison squeezed us table 258x14 into seven short one-dimensional arrays). <br><br>  As far as I understand, LR-parsers with distant peering forward do not do it - because everyone is happy with everything: conflicts caused by insufficiently distant peeping are rare in LR parsers.  So that our grammar could recognize the bison, it is enough not to ask him to choose between two identical convolutions: <pre> WORD: 's' 'a' 'i' 'l' |  's' 'a' 'l' 'e';
</pre>  On the other hand, nothing has changed for the LL parser: both rules still match the <code>'s'</code> symbol.  Therefore, in order to ‚Äúadapt‚Äù the grammar for LL parsing, the general beginning of different rules for the same non-terminal is put into ‚Äúauxiliary non-terminal‚Äù: <pre> WORD1: 's' 'a' WORD;
 WORD: 'i' 'l' |  'l' 'e';
</pre><br>  This trick is called "left factorization": from the equally beginning rules, it is as if the "common factor" is taken out. <br>  Now, <code>WORD1</code> unambiguous, and two possible scans for <code>WORD</code> begin in different letters. <br><br>  Why bother with factorization and produce meaningless non-terminals in grammar if the ANTLR miracle constrictor is able to look in as much as it wants? <br>  Back to grammar <pre> OP: '{' OPS '}' // block
     |  EXPR ';'  // expression
     |  'if' '(' EXPR ')' OP
     |  'if' '(' EXPR ')' OP 'else' OP
     |  'while' '(' EXPR ')' OP
     |  'exit' ';'  ;
</pre><br>  How to deploy <code>OP</code> when the next <code>if</code> character?  There are two rules that can begin like this;  and their common part - <code>'if' '(' EXPR ')' OP</code> - can be of <i>arbitrary</i> length, so no matter how far the parser looks in, it will not save it. <br><br>  Another problem that LL cannot handle is left recursion.  We remember the grammar of the calculator from the market: <pre> EXPR: NUM |  EXPR OP NUM;
</pre><br>  Both rules for <code>EXPR</code> begin with <code>NUM</code> : the first is explicit, the second is implicit;  while there is no common "factor" that could be taken out of the rules out.  If we also assume that the length of the <code>NUM</code> not limited, it is clear that no peeking will solve the problem. <br><br>  To fix the grammar, we start from its <i>meaning</i> : the first <code>NUM</code> in the string is a ready-made expression, and all other expressions contain two operands. <br><pre> EXPR: NUM EXPR1;
 EXPR1: |  OP NUM EXPR1;
</pre><br>  By left factorization and the elimination of left recursion, it is possible to adapt any unambiguous grammar for LL parsing, at the cost of adding a lot of auxiliary non-terminals, which are completely meaningless. <br>  For example, in the folding rule <code>EXPR: EXPR OP NUM ;</code>  we easily built a syntax tree node: the left argument is here, in <code>$1</code> ;  The right argument is here, at <code>$3</code> .  And what can be done with <code>EXPR1: OP NUM EXPR1 ;</code>  ?  The left argument is <i>already expanded and cleared from the stack</i> ;  but in our hands we have <code>EXPR1</code> - a sub-expression after the right argument.  It would be like some good in it! <br><br>  It is important that left recursion is <i>natural</i> for all left associative operations - and most of them.  Therefore, the confusion of the type above is not a rare curiosity, but a typical case. <br><br>  On the one hand, the reduction of grammar to the LL-type is completely formal, and it can be entrusted to a soulless piece of iron.  On the other hand, how to debug an automaton that works not for a given grammar, but for some of its own? <br>  In particular, we will not be allowed to write actions for developments, because it will not be the rules that we asked, but some others that the piece of iron asked itself.  It is also good if such a parser manages to generate a given parse tree;  to do this, he will have to correlate the rules of a given grammar with the rules according to which the automaton actually works, and rebuild the tree, ‚Äúreturning‚Äù the nodes that have moved from one rule to another. <br><br><h3>  Holivar </h3><br>  Dispute about the benefits of LL vs.  LR is as old as automatic parsing in general;  both approaches have their supporters.  For example, Niklaus Wirth, deeply respected by me personally, was an active apologist for LL parsing, and one of the design goals in developing Pascal was the possibility of LL (1) parsing ‚Äî that is,  automatic, which sees only the next character of the text.  Most of the ‚Äúliving languages‚Äù in LL do not fit: for example, in C, the declaration of either a variable or a function can begin with an <code>int</code> , and we cannot distinguish one from the other until we finish the line to the end. <br><br>  As for convenience: basically, everyone praises the tool he is used to and dislikes the unusual. <br>  For example, I will quote one ‚Äúbest answer‚Äù from stackoverflow regarding the dispute ‚Äú <a href="http://stackoverflow.com/questions/212900/advantages-of-antlr-versus-say-lex-yacc-bison">ANTLR vs.</a>  <a href="http://stackoverflow.com/questions/212900/advantages-of-antlr-versus-say-lex-yacc-bison">bison</a> ": <br><blockquote>  In terms of personal taste, I think that grammars are a lot easier to construct and debug.  Whats up? What are you crying?  It is a bit more interesting. </blockquote><br>  The advantages of ANTLR in this dispute include anything other than the qualities of the actual parsing: a convenient development environment, code generation in different languages, readable generated code. <br><br>  The readable generated code is the strongest difference between ANTLR and tabular parsers.  In fact, instead of the specialized parse stack, the call stack is used, and the recognition of each grammar rule is implemented as a function call (for a recursive rule, a recursive function).  Therefore, when debugging from the call stack, you can directly see how the parser got into the current state;  whereas with bison, as we remember, it is necessary to turn on the debug printing of transitions between states, and to check the printout of the machine gun in order to understand the reason for the transitions. <br>  The disadvantages of a recursive implementation in front of a tablespace are also clear: a much larger amount of code, which means memory consumption;  the impossibility of writing ‚Äúpatches‚Äù on the generated code, because it changes when the grammar changes, and it also propagates through dozens of functions. <br><br><h3>  Backtracking </h3><br>  LL parsers that predefinely select a rule for each scan are not the only option for downward parsing.  Alternative idea: when there are several suitable rules, we will try <i>everything</i> , some yes will do.  For example, you can do something like <code>fork()</code> : create clones of the parser in the current state, and let each clone try one of the scan options.  If a clone stumbles upon a syntax error, it dies.  If all the clones have died, then no sweep option is appropriate: a syntax error in the input text. <br><br>  For correct texts, this approach is more or less acceptable;  but there are problems with detecting errors.  First, which of the detected errors to print?  Most of them are the result of an incorrectly selected scan, and not errors in the program text;  but from the point of view of the parser, everyone is absolutely equal. <br><br>  Secondly, the analysis may never end: each time we do the unfolding according to the left-recursive rule, one of the clones will be in exactly the same state as before the development;  so that at each step you will get another exactly the same clone, and so on to infinity.  If one of the clones gets to the end of the analysis, then all the others can be killed;  and if, on the contrary, all the other clones will run into syntax errors and die, and only a uselessly breeding clone will continue to live? <br><br>  Finally, what to do with ambiguous grammars?  Both LL and LR parsers will detect conflicts during compilation;  there is no compilation as such: the parser is guided by the grammar almost raw, i.e.  <i>interprets</i> it on the go. <br>  So, it may turn out that for the same text we will receive one analysis, then another: depending on which clone has time to finish the analysis. <br><br>  The last problem was solved in the most original way: they declared that the possibility of ambiguous parsing is a fundamental problem of grammars, and instead they need to use <i>expressions</i> that differ in essence only in the fact that strict rules are set between the rules of the scan.  For example, if the grammar <br> <code>OP: EXPR ';' | 'if' '(' EXPR ')' OP | 'if' '(' EXPR ')' OP 'else' OP ;</code> <br>  and <br> <code>OP: EXPR ';' | 'if' '(' EXPR ')' OP 'else' OP | 'if' '(' EXPR ')' OP ;</code> <br>  Is the same ambiguous grammar, the expression <br> <code>OP: EXPR ';' / 'if' '(' EXPR ')' OP 'else' OP / 'if' '(' EXPR ')' OP</code> <br>  unequivocally indicates to the parser ‚Äúfirst try to recognize <code>if..else</code> , and only if it fails, recognize <code>if</code> without- <code>else</code> ‚Äù.  And the expression <br> <code>OP: EXPR ';' / 'if' '(' EXPR ')' OP / 'if' '(' EXPR ')' OP 'else' OP</code> <br>  means ‚Äúfirst recognize the <code>if</code> without- <code>else</code> ‚Äù, and therefore the <code>else</code> will never be recognized by them at all. <br><br>  Now, instead of checking all possible scans at the same time, we will check them in turn, in accordance with the priority;  We proceed to the next scan only when the previous one stumbled upon an error.  The link mentioned by the commentators provides <a href="http://thedeemon.livejournal.com/9974.html">an excellent metaphor</a> for this sort of parsing method: <br><blockquote> <a href=""><img src="http://habreffect.ru/files/252/23cd77f3c/k4vs.jpg" align="right"></a>  Have you ever rode a lazy elephant?  He walks slowly and swings heavily.  And it does not go on the road, but wanders in all directions that it considers interesting, but if they do not coincide with the necessary one, then the driver will tell the elephant ‚Äúno, we are not here‚Äù.  So, having tried all the options, the elephant is at the point about which <i>they did not</i> say "not here."  So parser combinators will also try all combinations of options until one of them works.  And after each rollback, they start to do the same work again.  &lt;...&gt; The program in a couple of lines was quickly disassembled.  In three lines for a few seconds.  Five lines, I did not wait.  Remember, children, such parser combinators are only suitable for very simple grammars. </blockquote><br>  It remains to detect looping parsing, to achieve an acceptable working time, and, not badly, localization of the error. <br><br>  It‚Äôs simpler with looping: if we were in one state twice, without moving forward in the input text, it means we‚Äôll end up in it for the third time, and as many as we like.  It turns out that for each position in the input text it is necessary to keep a list of all the states in which this position has already been visited: if we come to the same state a second time, we say, ‚Äúnot enough, I won't go there anymore‚Äù. <br><br>  As a free bonus, we get a ‚Äúlinear‚Äù time of work, if we remember not just a tick ‚Äúaha, there were‚Äù, but also the result of the past analysis (the sweep approached / did not fit);  then the worst case scenario is if all the possible states are in each position of the text.  If the text is <i>N</i> characters long, and in the <s>grammar of the</s> parsing expression of <i>M</i> rules (including alternative scans of each non-terminal), then we get <i>O</i> ( <i>M</i> * <i>N</i> ) work time.  If it is clever to squint and pretend that <i>M is a</i> constant - aha, time is linear.  For comparison, traditional LL and LR parsers with a predefined action in each state are exactly the same in the worst case <i>O</i> ( <i>M</i> * <i>N</i> ): <pre> S: |  T1 S;
 T1: T2;
 T2: T3;
 ...
 TM: 't';
</pre>  Here, LR will, after each shift <code>'t'</code> perform <i>M</i> convolutions <code>'t' -&gt; TM -&gt; ... -&gt; T3 -&gt; T2 -&gt; T1</code> ;  and LL, before 'eating' each <code>'t'</code> , makes <i>M</i> sweeps <code>T1 -&gt; T2 -&gt; T3 -&gt; ... -&gt; TM -&gt; 't'</code> . <br>  The whole question is how much the average case differs from the worst: at least, the ‚Äúlinear elephant‚Äù performs more deconstructions in any analysis than LL in the same grammar. <br><br>  Another trick in memory consumption.  We will need to store the <i>M</i> * <i>N</i> results of past scans - and this is in addition to the fact that the input text will have to be stored in the memory as a whole, because the elephant needs to run on it back and forth without end.  This is despite the fact that store-assisted parsers never return to the already read text, and therefore their memory requirements depend only on grammar, but not on text. <br>  "The history of one byte" read everything?  Moreover, one of the most natural applications for new compilers is to support all sorts of compact platforms, where saved memory matters. <br><br>  And about the detection of syntax errors.  Our elephant, which actually received the name of packrat (skopidom), concludes that the text of the error, when no sweep did not fit.  Therefore, the position in which the error will be detected may well precede the place of the actual error: suppose the expression <pre> DECL: DECLVAR / DECLFN;
 DECLVAR: TYPE ID ';'  ;
 DECLFN: TYPE ID '(' ARGS ')';
</pre>  - vaguely resembling the syntax of declarations in C. <br>  If the input text met a sequence that can be parsed as <code>TYPE ID '!'</code>  then in what position is the syntax error?  Packrat will check the first sweep, it will not work, the parser will roll back to the beginning of <code>TYPE</code> and try the second sweep;  she also does not fit.  It turns out, the error will be detected before <code>TYPE</code> ;  and what if <code>TYPE</code> is a half-string hardcore expression? <br>  It is logical to show, as an error position, the rightmost one, which has been able to reach at least one scan - i.e.  the last position, to which the parser still had hopes that the text parsed successfully. <br>  I assume that there are packrat implementations in which the error localization is implemented in this way. <br><br>  Everything, it was the last post of a series in which we are engaged in syntax analysis. <br>  Next time we turn to semantics, and then our toy language will really become a <i>programming</i> language. </div><p>Source: <a href="https://habr.com/ru/post/99466/">https://habr.com/ru/post/99466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99459/index.html">Eclipse, MPICH and PTP for the user. Setting up and running tasks on a cluster</a></li>
<li><a href="../99460/index.html">The evolution of Steve Jobs</a></li>
<li><a href="../99461/index.html">Google acquired Metaweb and the Freebase knowledge base</a></li>
<li><a href="../99462/index.html">Rackspace offers an open-source project to create their own "clouds"</a></li>
<li><a href="../99464/index.html">Creating and configuring a WCF service in a Silverlight 4 application</a></li>
<li><a href="../99469/index.html">All-Russian final of World Cyber ‚Äã‚ÄãGames 2010</a></li>
<li><a href="../99471/index.html">StarCraft 2 - the most expensive game</a></li>
<li><a href="../99472/index.html">Development of an intranet portal in state organizations: year results</a></li>
<li><a href="../99475/index.html">Overview of Windows Phone 7 features from a Microsoft-Ukraine employee</a></li>
<li><a href="../99478/index.html">Plants vs. Zombies will receive a "cooperative"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>