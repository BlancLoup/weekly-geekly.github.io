<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We dive deep into: from CSS to the transistor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="70 years ago, on December 16, 1947, in the Bell Labs laboratories, John Bardeen and Walter Brattein, under the leadership of William Shockley, created...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We dive deep into: from CSS to the transistor</h1><div class="post__text post__text-html js-mediator-article">  70 years ago, on December 16, 1947, in the Bell Labs laboratories, John Bardeen and Walter Brattein, under the leadership of William Shockley, created the first active bipolar transistor.  On December 23, Brattein demonstrated that his colleagues put the first transistor amplifier.  Therefore, this day is often called the <i>Day of the transistor</i> . <br><br><img src="https://habrastorage.org/webt/6u/ty/ic/6utyic2_kroyqcpgvrcybtv7kjm.jpeg" alt="Bardin is on the left, Brattein is on the right, Shockley is sitting."><br><br>  There is no need to talk about the significance of this event.  The transistor is considered one of the most important inventions of the XX century, without which computers would still work on lamps and relays, and would occupy entire buildings.  Shockley, Bardin and Brattein for their work received in 1956 the Nobel Prize in Physics.  Over the past years, the transistor miniaturized to a few number of atoms.  Each processor has billions of transistors, so the transistor can be called the most massive device created by mankind. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what work does the transistor do for us?  Let's go on a mental journey: let's follow the path from some high-level fintifli to our birthday party - a transistor. <br><br>  What to take as a starting point?  Well, at least drawing the button habrakata. <br><a name="habracut"></a><br><h3>  HTML and CSS </h3><br>  The button consists of background pixels, text, and a border.  The code is set by the &lt;a&gt; tag, to which the CSS styling rules apply.  For example, the CSS rule for corner rounding is applied to the border: <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>;</code> </pre> <img src="https://habrastorage.org/getpro/geektimes/post_images/b36/f41/354/b36f41354796b490cd910c72747da8af.png" alt="knop"><br><br>  Thus, the boundary consists of four segments and four arcs (‚Äúquarters‚Äù of a circle). <br><br><h3>  Browser </h3><br>  For research, I took my favorite Firefox.  Before FF starts drawing our button, it needs to do a lot of work on parsing and calculating the position of elements: <br><br><ul><li>  Download HTML, parse, compile a DOM tree </li><li>  Download via CSS, conduct lexical analysis, parse </li><li>  Bind rules to page elements based on priority and inheritance </li><li>  For all visible DOM nodes, make up a tree of their rectangular areas - frames. </li><li>  For frames, calculate the size and location (see <a href="https://www.youtube.com/watch%3Fv%3DZTnIxIA5KGw">video</a> ) </li><li>  Make frames out of frames with regard to z-index and content type (&lt;canvas&gt;, SVG, &lt;video&gt;). </li><li>  Create a drawing list in order: background color, background image, border, descendants, outline. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Add.</b>  <b class="spoiler_title">reading materials:</b> <div class="spoiler_text">  <a href="https://wiki.mozilla.org/Gecko:Overview">Gecko: Overview</a> <br>  <a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How to Browsers Work: Behind the scenes of modern web browsers</a> <br>  <a href="https://habrahabr.ru/post/320430/">Understanding the critical rendering path</a> <br></div></div><br>  We will not dwell on these steps in detail.  After them comes the actual drawing of the necessary elements. <br><br><div class="spoiler">  <b class="spoiler_title">Downloading the source code to find out what is happening there</b> <div class="spoiler_text">  You need to download the <a href="https://archive.mozilla.org/pub/firefox/releases/">source code of Mozilla Firefox</a> .  According to the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Build_Instructions/Windows_Prerequisites">instructions,</a> we obtain the Firefox source code from Mercurial and Visual Studio with the C ++ tools.  In VS you need to connect symbols from <a href="http://symbols.mozilla.org/">symbols.mozilla.org</a> in debugging settings.  The code we are interested in lies obviously somewhere in / layout /. <br><br>  In order to find the desired function, I set breakpoints in the code, then I ran Firefox.  In the browser, I opened a simplified copy of the page, where there is only our button with styles, and in full screen mode so that the breakpoints do not work on the interface elements of the FF itself. <br></div></div><br>  The file <i>nsCSSRenderingBorders.cpp</i> is responsible for drawing the borders.  And the general function of drawing borders is called (who would have thought): <i>DrawBorders ()</i> .  The function selects the best rendering method for different situations.  We have a relatively simple case: there is a border-radius, but the borders on all sides are solid (solid) and of one color. <br><br><div class="spoiler">  <b class="spoiler_title">Our if</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allBordersSame &amp;&amp; mCompositeColors[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; mBorderStyles[<span class="hljs-number"><span class="hljs-number">0</span></span>] == NS_STYLE_BORDER_STYLE_SOLID &amp;&amp; !mAvoidStroke &amp;&amp; !mNoBorderRadius) { <span class="hljs-comment"><span class="hljs-comment">// Relatively simple case. gfxRect outerRect = ThebesRect(mOuterRect); RoundedRect borderInnerRect(outerRect, mBorderRadii); borderInnerRect.Deflate(mBorderWidths[eSideTop], mBorderWidths[eSideBottom], mBorderWidths[eSideLeft], mBorderWidths[eSideRight]); // Instead of stroking we just use two paths: an inner and an outer. // This allows us to draw borders that we couldn't when stroking. For example, // borders with a border width &gt;= the border radius. (ie when there are // square corners on the inside) // // Further, this approach can be more efficient because the backend // doesn't need to compute an offset curve to stroke the path. We know that // the rounded parts are elipses we can offset exactly and can just compute // a new cubic approximation. RefPtr&lt;PathBuilder&gt; builder = mDrawTarget-&gt;CreatePathBuilder(); AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, true); AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, false); RefPtr&lt;Path&gt; path = builder-&gt;Finish(); mDrawTarget-&gt;Fill(path, color); return; }</span></span></code> </pre><br></div></div><br>  There are much more complicated options, for example, docking in corners with border-radius of different types of borders is dotted and dashed, see. <i>DrawDashedOrDottedCorner ()</i> .  There in the code completely <br><div class="spoiler">  <b class="spoiler_title">smart comments</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// radius.width // |&lt;-----------------&gt;| // | | // | ___---+------------- // | __-- #|# ### // | _- ##|## ##### // | / ##+## ##+## // | / # P # ##### // | | #|# ### // | | __--+------------- // || _- ^ // || / | // | / first dot is filled // | | // | | // | | // | | // | | // +------+ // |## ##| // |## ##| // |## ##|</span></span></code> </pre><br></div></div><br>  But back to our if.  From the commentary we learn that in this case the border is drawn with the help of two rectangles - internal and external, then the created contour (path) is filled with the desired color. <br><br><pre> <code class="cpp hljs">AppendRoundedRectToPath(builder, mOuterRect, mBorderRadii, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); AppendRoundedRectToPath(builder, ToRect(borderInnerRect.rect), borderInnerRect.corners, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); RefPtr&lt;Path&gt; path = builder-&gt;Finish(); mDrawTarget-&gt;Fill(path, color);</code> </pre> <br>  Go to <i>AppendRoundedRectToPath ()</i> in gfx / 2d / PathHelpers.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Again we set breakpoints</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/geektimes/post_images/4cd/ab2/6a9/4cdab26a931ee33578231106b0bbf354.png" alt="a9430-clip-21kb"><br></div></div><br>  From the comment to the function, we learn that the corners are drawn at four control points by <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">Bezier curves</a> .  Bezier curves are often used in computer graphics, including for drawing arcs of circles and ellipses.  As we will further learn from the commentary, there are many options for choosing control points for constructing a curve.  In this case, we need the points 0 and 3 to belong to the sides of the rectangle, the points 0, 1 and C lie on one straight line, the points 3, 2 and C - on the other.  See drawing: <br><br><img src="https://habrastorage.org/files/9d2/6f9/e3a/9d26f9e3a86b42b09fe5fc35be1880a2.png" alt="mozilla rounded border bezier curve"><br><br>  It remains for us to calculate the ratio of the lengths of the segments 01 / 0C and 32 / 3C.  Here the authors use approximate calculations and get the alpha magic constant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float alpha = Float(<span class="hljs-number"><span class="hljs-number">0.55191497064665766025</span></span>);</code> </pre> <br>  Unfortunately, the article with the algorithm for selecting control points to which the comment refers is not publicly available.  But in general, it should be noted that in computer graphics algorithms often use approximation to improve performance.  For example, the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25B5%25D0%25B7%25D0%25B5%25D0%25BD%25D1%2585%25D1%258D%25D0%25BC%25D0%25B0">Brezenham algorithm</a> allows drawing segments and circles not ‚Äúhead-on‚Äù - by solving the equations y = f (x), but by more cunning integer operations.  The same with the fill, etc. <br><br>  Further in the cycle we go from corner to corner, with the help of alpha we calculate the coordinates of control points and, finally, we call the functions of drawing the boundary line and arc of the angle: <br><br><pre> <code class="cpp hljs">aPathBuilder-&gt;LineTo(p0); aPathBuilder-&gt;BezierTo(p1, p2, p3);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Add.</b>  <b class="spoiler_title">reading material</b> <div class="spoiler_text">  <a href="https://habrahabr.ru/post/247235/">Interpolation: draw smooth graphs using Bezier curves</a> <br>  <a href="https://habrahabr.ru/post/163073/">Javascript: Draw with Bezier Curves</a> <br>  <a href="http://www.slideshare.net/SamsungOSG/duel-of-two-libraries-cairo-skia">Cairo vs.</a>  <a href="http://www.slideshare.net/SamsungOSG/duel-of-two-libraries-cairo-skia">Skia</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Full code AppendRoundedRectToPath ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppendRoundedRectToPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PathBuilder* aPathBuilder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rect&amp; aRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RectCornerRadii&amp; aRadii, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aDrawClockwise)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// For CW drawing, this looks like: // // ...******0** 1 C // **** // *** 2 // ** // * // * // 3 // * // * // // Where 0, 1, 2, 3 are the control points of the Bezier curve for // the corner, and C is the actual corner point. // // At the start of the loop, the current point is assumed to be // the point adjacent to the top left corner on the top // horizontal. Note that corner indices start at the top left and // continue clockwise, whereas in our loop i = 0 refers to the top // right corner. // // When going CCW, the control points are swapped, and the first // corner that's drawn is the top left (along with the top segment). // // There is considerable latitude in how one chooses the four // control points for a Bezier curve approximation to an ellipse. // For the overall path to be continuous and show no corner at the // endpoints of the arc, points 0 and 3 must be at the ends of the // straight segments of the rectangle; points 0, 1, and C must be // collinear; and points 3, 2, and C must also be collinear. This // leaves only two free parameters: the ratio of the line segments // 01 and 0C, and the ratio of the line segments 32 and 3C. See // the following papers for extensive discussion of how to choose // these ratios: // // Dokken, Tor, et al. "Good approximation of circles by // curvature-continuous Bezier curves." Computer-Aided // Geometric Design 7(1990) 33--41. // Goldapp, Michael. "Approximation of circular arcs by cubic // polynomials." Computer-Aided Geometric Design 8(1991) 227--238. // Maisonobe, Luc. "Drawing an elliptical arc using polylines, // quadratic, or cubic Bezier curves." // http://www.spaceroots.org/documents/ellipse/elliptical-arc.pdf // // We follow the approach in section 2 of Goldapp (least-error, // Hermite-type approximation) and make both ratios equal to // // 2 2 + n - sqrt(2n + 28) // alpha = - * --------------------- // 3 n - 4 // // where n = 3( cbrt(sqrt(2)+1) - cbrt(sqrt(2)-1) ). // // This is the result of Goldapp's equation (10b) when the angle // swept out by the arc is pi/2, and the parameter "a-bar" is the // expression given immediately below equation (21). // // Using this value, the maximum radial error for a circle, as a // fraction of the radius, is on the order of 0.2 x 10^-3. // Neither Dokken nor Goldapp discusses error for a general // ellipse; Maisonobe does, but his choice of control points // follows different constraints, and Goldapp's expression for // 'alpha' gives much smaller radial error, even for very flat // ellipses, than Maisonobe's equivalent. // // For the various corners and for each axis, the sign of this // constant changes, or it might be 0 -- it's multiplied by the // appropriate multiplier from the list before using. const Float alpha = Float(0.55191497064665766025); typedef struct { Float a, b; } twoFloats; twoFloats cwCornerMults[4] = { { -1, 0 }, // cc == clockwise { 0, -1 }, { +1, 0 }, { 0, +1 } }; twoFloats ccwCornerMults[4] = { { +1, 0 }, // ccw == counter-clockwise { 0, -1 }, { -1, 0 }, { 0, +1 } }; twoFloats *cornerMults = aDrawClockwise ? cwCornerMults : ccwCornerMults; Point cornerCoords[] = { aRect.TopLeft(), aRect.TopRight(), aRect.BottomRight(), aRect.BottomLeft() }; Point pc, p0, p1, p2, p3; if (aDrawClockwise) { aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRadii[RectCorner::TopLeft].width, aRect.Y())); } else { aPathBuilder-&gt;MoveTo(Point(aRect.X() + aRect.Width() - aRadii[RectCorner::TopRight].width, aRect.Y())); } for (int i = 0; i &lt; 4; ++i) { // the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw) int c = aDrawClockwise ? ((i+1) % 4) : ((4-i) % 4); // i+2 and i+3 respectively. These are used to index into the corner // multiplier table, and were deduced by calculating out the long form // of each corner and finding a pattern in the signs and values. int i2 = (i+2) % 4; int i3 = (i+3) % 4; pc = cornerCoords[c]; if (aRadii[c].width &gt; 0.0 &amp;&amp; aRadii[c].height &gt; 0.0) { p0.x = pc.x + cornerMults[i].a * aRadii[c].width; p0.y = pc.y + cornerMults[i].b * aRadii[c].height; p3.x = pc.x + cornerMults[i3].a * aRadii[c].width; p3.y = pc.y + cornerMults[i3].b * aRadii[c].height; p1.x = p0.x + alpha * cornerMults[i2].a * aRadii[c].width; p1.y = p0.y + alpha * cornerMults[i2].b * aRadii[c].height; p2.x = p3.x - alpha * cornerMults[i3].a * aRadii[c].width; p2.y = p3.y - alpha * cornerMults[i3].b * aRadii[c].height; aPathBuilder-&gt;LineTo(p0); aPathBuilder-&gt;BezierTo(p1, p2, p3); } else { aPathBuilder-&gt;LineTo(pc); } } aPathBuilder-&gt;Close(); }</span></span></code> </pre><br></div></div><br>  But then it all depends on the backend 2D graphics, which uses Mozilla. <br><br><h3>  Graphics engine </h3><br>  Gecko uses the platform-independent library Moz2D, which in turn can use one of the backends: Cairo, Skia, Direct2D, Quartz and NV Path.  For example, for Windows, Direct2D, Cairo, Skia are available.  Skia is also a Chromium backend.  You can change the backend in about: config.  Backends, in turn, can read everything on the CPU, and can use to some extent the hardware acceleration of the GPU.  For example, Skia has its own OpenGL backend - Ganesh. <br><br>  The Direct2D code is closed, so it's better to turn on Skia and see what it does.  The function of drawing the cubic curve SkPath :: cubicTo is called.  To construct a curve, it is split by <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25B4%25D0%25B5_%25D0%259A%25D0%25B0%25D1%2581%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25B6%25D0%25BE">the de Castelgio algorithm</a> into a number of straight line segments, which are actually drawn (see core / SkGeometry.cpp). <br><br><div class="spoiler">  <b class="spoiler_title">Add.</b>  <b class="spoiler_title">reading materials</b> <div class="spoiler_text">  <a href="">skia / src / core / SkGeometry.cpp</a> <br>  <a href="http://www.antigrain.com/research/adaptive_bezier/index.html">Adaptive Subdivision of Bezier Curves</a> <a href="http://www.antigrain.com/research/adaptive_bezier/index.html"><br></a> <br>  <a href="http://www.ammarhattab.com/resources%255Cpapers%255CBezierCurves.pdf">Performance Of B√©zier Curves Rendering In Web Browsers</a> <br>  <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">Software vs.</a>  <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">GPU rasterization in Chromium</a> <br></div></div><br><h3>  Machine code </h3><br>  Honestly, I didn‚Äôt manage to fully understand the interiors of Skia, so I took a step back - to AppendRoundedRectToPath (), where all operations take place on whole numbers - what could be easier? <br><br>  Having opened the disassembled code, we have to find the operation of addition in it. <br><br><pre> <code class="hljs cs">... <span class="hljs-number"><span class="hljs-number">142B</span></span>1863 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [eax],al <span class="hljs-number"><span class="hljs-number">142B</span></span>1865 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>D <span class="hljs-number"><span class="hljs-number">43</span></span> FF <span class="hljs-number"><span class="hljs-number">0F</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [ebp<span class="hljs-number"><span class="hljs-number">-7B</span></span>F000BDh],cl <span class="hljs-number"><span class="hljs-number">142B</span></span>186B <span class="hljs-number"><span class="hljs-number">67</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> dword ptr [bx+si],eax <span class="hljs-number"><span class="hljs-number">142B</span></span>186E <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">99</span></span> <span class="hljs-number"><span class="hljs-number">0F</span></span> <span class="hljs-number"><span class="hljs-number">57</span></span> C9 F7 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [ecx<span class="hljs-number"><span class="hljs-number">-836</span></span>A8F1h],bl <span class="hljs-number"><span class="hljs-number">142B</span></span>1874 F9 stc <span class="hljs-number"><span class="hljs-number">142B</span></span>1875 <span class="hljs-number"><span class="hljs-number">8B</span></span> C3 mov eax,ebx <span class="hljs-number"><span class="hljs-number">142B</span></span>1877 <span class="hljs-number"><span class="hljs-number">8B</span></span> CA mov ecx,edx <span class="hljs-number"><span class="hljs-number">142B</span></span>1879 <span class="hljs-number"><span class="hljs-number">99</span></span> cdq <span class="hljs-number"><span class="hljs-number">142B</span></span>187A F7 <span class="hljs-number"><span class="hljs-number">7</span></span>C <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> idiv eax,dword ptr [esp+<span class="hljs-number"><span class="hljs-number">28</span></span>h] ...</code> </pre><br>  Aha  Even such a person as far from ASM as I can easily guess that the operation ADD is responsible for addition.  Take the first operation: <br><br> <code>142B1863 00 00 add byte ptr [eax],al</code> <br>  0x142B1863 - address in RAM <br>  0x00 - <i>opcode</i> - processor instruction code.  This Mozilla is compiled for x86, and by <a href="http://ref.x86asm.net/coder32.html">opening the x86 instruction table</a> , we will see that code 00 means an 8-bit addition operation with the ADD mnemonic.  The first operand can be a register or memory cell, the second - a register.  The first operand is added to the second, the result is written to the first.  Let me explain, just in case, that the register is a super-fast RAM inside the processor, for example, to store intermediate results of calculations. <br><br>  The second byte is also 0x00 and is called <a href="http://www.c-jump.com/CIS77/CPU/x86/lecture.html">MOD-REG-R / M.</a>  Its bits specify the operands and the addressing method. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/09d/264/86f/09d26486fdeabed7c7d258cadfea7cc3.png"><br><br>  MOD = 00b in combination with R / M = 000b means that <a href="https://www.intuit.ru/studies/professional_skill_improvements/1300/courses/60/lecture/1776">indirect addressing is used.</a> <br>  REG = 000b means that the AL register is used (lower 8-bit EAX register) <br>  [eax] - indicates that the addition is made with the memory cell, the address of which lies in the register EAX <br><br>  How does the processor handle the ADD command? <br><br><h3>  CPU </h3><br>  According to the description of the <a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)">Skylake</a> microarchitecture, I made a (extremely simplified) list of steps: <br><br><ol><li>  X86 instructions are selected from the instruction cache L1 32KB in the pre-decoding buffer in blocks of 16 bytes </li><li>  Pre-coded commands are organized into an Instruction Queue (2x25) and entered into decoders. </li><li>  The decoder converts x86 operation into 1-4 machine micro-operations (¬µOPs).  Our ADD will become 1 ¬µOP for ALU (arithmetic-logic unit) and 2 ¬µOP for AGU (address calculator) ( <a href="http://www.agner.org/optimize/instruction_tables.pdf">see</a> , but this is not accurate).  In order to optimize, the processor at this stage can merge two x86 instructions or two micro-operations into one. </li><li>  Microoperations fall into the Allocation Queue (IDQ).  Here, too, optimizations are applied, such as Loop Stream Detector - turning off the sample when a loop is detected. </li><li>  Execution begins: micro-operation enters the reordering buffer, where the order of future execution of operations is optimized.  To speed up the execution, the free physical registers of the processor are temporarily renamed to the operations necessary for execution.  Other optimizations are performed. </li><li>  A micro-operation enters the Unified Scheduler dispatcher, which decides at what time and to which port to send operations for execution outside the order in which they are received.  Behind each port is the actuator.  Our micro operations will fall into ALU and AGU. </li></ol><br><img src="https://habrastorage.org/webt/xs/is/ij/xsisijruqtk6obopjmtkgx-fm7o.png"><br>  <i>The core of SkyLake.</i>  <i>Image from <a href="https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)">en.wikichip.org</a> .</i> <br><br>  I repeat, this is my very simplified description and does not claim to be accurate or complete.  For further reference, I recommend reading the post <a href="https://habrahabr.ru/post/182002/">Journey through the processor's computing pipeline</a> and the article <a href="http://compress.ru/article.aspx%3Fid%3D19827">Processors of the Intel Core i7 family</a> <br><br><h3>  ALU </h3><br>  Now it would be interesting to know what is happening in the ALU: how are the numbers added?  Unfortunately, information on the specific implementation of the micro-architecture and the ALU is a trade secret of Intel, therefore, we turn further to the theory. <br><br>  A device for adding two bits (i.e. a bit) is called an <i>adder</i> .  The output is the sum and the carry bit. <br><br><img src="https://habrastorage.org/webt/un/ic/bx/unicbxzbhpwhf79hla4ssznt9rw.gif"><br>  Source: <a href="https://en.wikipedia.org/wiki/Adder_(electronics)">Wikipedia</a> <br><br>  Since  in real life, we need to add numbers consisting of several digits, the adder must also accept the carry bit from the previous bit.  This adder is called <i>complete</i> . <br><br><img src="https://habrastorage.org/webt/so/vw/jl/sovwjlxnsewbnpv5grlt8ii29_c.gif"><br>  Source: <a href="https://en.wikipedia.org/wiki/Adder_(electronics)">Wikipedia</a> <br><br>  As can be seen from the figure, the adder is composed of logical elements: XOR, AND, OR.  And each logical element <a href="https://www.intuit.ru/studies/courses/56/56/lecture/1668">can be implemented</a> using multiple transistors.  Or even a <a href="https://habrahabr.ru/post/220865/">relay</a> . <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/355/ccc/357/355ccc357f77c624fc089e5513679985.jpg" alt="Mattausch, CMOS Design, H20 / 6/6"><br>  <i>An example of the implementation of the full adder on <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%259C%25D0%259E%25D0%259F">CMOS</a> transistors.</i>  <i><a href="http://www.rnbs.hiroshima-u.ac.jp/RCNS/lecture/pdf/HJM_H20/OHP_CMOS_8(H20-6-6).pdf">A source</a></i> <br><br>  So we got to the transistor!  Although, of course, not only ALUs, but also other processor units work on transistors, and most of all transistors are used in the cache memory as its cells. <br><br>  In reality, the adder circuit in our processor can be constructed differently and be much more complicated.  For example, already Intel 8008 45 years ago was able to calculate all the carry bits in advance in order to perform addition in parallel (the so-called parallel transfer adder).  Who cares, read an interesting post about ALU Intel 8008 reverse engineering <a href="http://www.righto.com/2017/02/reverse-engineering-surprisingly.html">on</a> Ken Shirriff's <a href="http://www.righto.com/2017/02/reverse-engineering-surprisingly.html">blog</a> .  Those.  various optimizations are used: for example, multiplication is also <a href="https://habrahabr.ru/post/124258/">beneficial</a> to do not ‚Äúhead to head‚Äù. <br><br><h3>  Conclusions: what have we learned? </h3><br><ul><li>  <i>It's Complicated</i> </li><li>  It is clearly shown: to solve the problem of excessive complexity, engineers use the partitioning of complex systems into levels (layers). </li><li>  Multi-level architectures allow portability: for example, Firefox can run on different operating systems and on different hardware. </li><li>  The interaction between the levels is carried out due to the openness of specifications for interfaces, services and data formats, such as HTML and CSS, C ++, a set of x86 commands, etc. </li><li>  At the very bottom our hero of the day works - the <b>transistor</b> . </li></ul><br>  PS Because  I am an amateur (web developer), and C ++, ASM, I know the architecture of BT quite a bit - from the institute course, I could get it wrong.  Please feel free to send comments. </div><p>Source: <a href="https://habr.com/ru/post/400363/">https://habr.com/ru/post/400363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../400353/index.html">RVC and Belinfond create a joint venture fund to support startups</a></li>
<li><a href="../400355/index.html">Amazon's crowdsourcing: how half a million people get a penny for AI training</a></li>
<li><a href="../400357/index.html">Google showed a sample of charity with a triple benefit</a></li>
<li><a href="../400359/index.html">Proprioception for non-specialists. Part 3. Dynamic sitting on a chair.</a></li>
<li><a href="../400361/index.html">Foreve Elon 2016/2017 (New Year's Eve online)</a></li>
<li><a href="../400365/index.html">What promise VKontakte users in 2017</a></li>
<li><a href="../400367/index.html">What to do on the weekend: remote control intercom, budgetary remapping Nextion, disassembly with Onlaym</a></li>
<li><a href="../400369/index.html">Rostelecom buys Microsoft software for 1.26 billion rubles</a></li>
<li><a href="../400371/index.html">2017 is not just a prime number ...</a></li>
<li><a href="../400377/index.html">Review of current 3D materials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>