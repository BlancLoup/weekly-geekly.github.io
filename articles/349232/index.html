<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's talk about usernames</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of weeks ago I released django-registration 2.4.1. Build 2.4.x will be the latest in the version of django-registration 2.x, then only bug fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's talk about usernames</h1><div class="post__text post__text-html js-mediator-article">  A couple of weeks ago I released <a href="https://www.b-list.org/projects/django-registration/">django-registration</a> 2.4.1.  Build 2.4.x will be the latest in the version of django-registration 2.x, then only bug fixes will be released.  The main branch is now preparing for version 3.0, from where it is planned to remove a bunch of obsolete trash that has accumulated over the past decade of support, and I will try to take into account the best practices of modern Django applications. <br><br>  In the near future I will write more about the new version, but right now I want to talk a little about the deceptively simple problem that I have to deal with.  These are usernames.  Yes, I could write one of the most popular articles of the type <a href="https://habrahabr.ru/post/146901/">‚ÄúProgrammers misconceptions about X‚Äù</a> , but I still prefer to really explain why this is more difficult than it seems, and offer some tips on how to solve the problem.  And not just jiving without a useful context. <br><a name="habracut"></a><br><h1>  Remark: the correct way to identify </h1><br>  Usernames - in the form in which they are implemented on many sites and services and in many popular frameworks (including Django) - are almost certainly the wrong way to solve the problem that they are trying to solve with their help.  What we really need in terms of user identification is some combination of the following: <br><br><ol><li>  System-level identifier for foreign keys in the database. </li><li>  Login ID to perform credentials verification. </li><li>  Public ID to display to other users. </li></ol><br>  Many systems request a username - and use the same username for all three specified tasks.  This is probably wrong.  A more competent approach is a <a href="http://habitatchronicles.com/2008/10/the-tripartite-identity-pattern/">three-way identification template</a> , in which each identifier is different, and several login identifiers and / or public identifiers can be associated with one system identifier. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many problems and sufferings when trying to build and scale an account system are caused by ignoring this model.  An annoyingly large number of hacks are used in systems that <i>do not support such a pattern</i> so that they look and work as if they support it. <br><br>  So if you are developing a system from scratch now in 2018, I would suggest taking this model and using it as a basis.  First you have to work a little, but in the future it will provide good flexibility and save time, and one day someone might even create an acceptable universal implementation for reusable use (of course, I thought of doing this for Django, and maybe I will do it once). <br><br>  In the rest of this article, we will assume that you use a more common implementation, in which the unique user name serves as at least a system identifier and login to the system, and, most likely, a public identifier, which is shown to all users.  And by ‚Äúusername‚Äù I mean essentially any string identifier.  For example, you may have usernames like forums like Reddit or Hacker News, or you can use email addresses or some other unique string.  It doesn't matter, you're probably still using <i>some kind of</i> unique string.  So you need to know about some problems. <br><br><h1>  Uniqueness is harder than it looks. </h1><br>  Perhaps you ask the question: how difficult is it?  You can simply create a unique column in the database - and you're done!  Create a table with users in Postgres: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SERIAL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, username <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, email_address <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> );</code> </pre> <br>  Here is our table with users and a column with unique names.  Easy! <br><br>  Well, it's easy, until we start thinking about real use.  If you are registered as <code>john_doe</code> , what happens if I register as <code>JOHN_DOE</code> ?  This is another username, but can I make people think that I am you?  Will people accept my friend requests and share confidential information with me because they do not realize that for a computer, a different register is a different character? <br><br>  This is a simple thing that is incorrectly implemented in many systems.  During the research for this article, I discovered that the auth system in Django does not ensure the uniqueness of usernames case-insensitive, despite the correct approach in implementing many other things.  In the bug tracker there is a ticket to make the usernames case-insensitive, but now it is marked as WONTFIX, because creating usernames case-insensitively breaks backward compatibility - and no one is sure how to do it or whether it should be done .  I‚Äôll probably think about enforcing this in django-registration 3.0, but I‚Äôm not sure that this can be implemented even there - problems will start on any website where register-based accounts already exist. <br><br>  So if you are going to build a system from scratch today, then you need to make checks from the very beginning on the uniqueness of the user name without register: <code>john_doe</code> , <code>John_Doe</code> and <code>JOHN_DOE</code> should be considered identical names.  As soon as one of them is registered, the others become inaccessible. <br><br>  But this is only the beginning.  We live in the Unicode world, but here it‚Äôs more difficult to compare two names for a match than to simply perform the operation <code>username1 == username2</code> .  First, there is a composition and decomposition of characters.  They differ when comparing them as sequences of Unicode code points, but they look the same on the screen.  Therefore, here you need to think about <a href="https://habrahabr.ru/post/45489/">normalization</a> , choose the form of normalization (NFC or NFD), and then normalize each username to the selected form <i>before</i> performing any unique checks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b59/894/0e8/b598940e8cc9105e53b10dff46d2b186.jpg"><br>  <i><font color="gray">Illustration from the article <a href="https://habrahabr.ru/post/45489/">"Normalization Unicode"</a> - approx.</font></i>  <i><font color="gray">per.</font></i> <br><br>  Also, when developing a system for checking the uniqueness of names without regard for the register, you will have to consider non-ASCII characters.  Is the <code>Stra√üburgJoe</code> and <code>StrassburgJoe</code> user identities identical?  The answer often depends on whether you do a normalization check in lower or upper case.  And while there are still different options for decomposition in Unicode;  You can get (and get) different results for many strings depending on whether you use canonical equivalence or compatibility mode. <br><br>  If all this is confusing - and this is true, even if you are an Unicode expert!  - I recommend following the <a href="http://www.unicode.org/reports/tr36/">advice of the Unicode Technical Report 36 technical report</a> and normalizing the names according to the <abbr title="Compatibility Decomposition, Canonical Composition">NFKC</abbr> form.  If you use the Django <code>UserCreationForm</code> or its subclass (django-registration uses the <code>UserCreationForm</code> subclasses), then this is already done for you.  If you use Python, but without Django (or do not use <code>UserCreationForm</code> ), then this can be done on a single line using the helper from the standard library: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unicodedata username_normalized = unicodedata.normalize(<span class="hljs-string"><span class="hljs-string">'NFKC'</span></span>, username)</code> </pre> <br>  For other languages, look for a good Unicode library. <br><br><h1>  No, really, making uniqueness is harder than it seems. </h1><br>  Unfortunately, that's not all.  Checking uniqueness case in normalized strings is the beginning, but it does not cover all cases that need to be caught.  For example, consider the following username: <code>jane_doe</code> .  Now consider another username: <code>jane_doe</code> .  Is this the same username? <br><br>  In the font that I use for this article, and in any font available for my blog, they <i>seem to be the</i> same.  But for software, they are completely <i>different</i> , and still remain different after Unicode normalization and case-insensitive comparison (regardless of whether you chose a normal check in lower case or upper case). <br><br>  To understand the reason, pay attention to the second code point.  In one of the usernames, this is <code>U+0061 LATIN SMALL LETTER A</code>  In the other, it's <code>U+0430 CYRILLIC SMALL LETTER A</code>  And no Unicode normalization or removal of case sensitivity will make these code points the same, although they are often visually completely indistinguishable. <br><br>  This is the basis of homographic attacks, which first became widely known in the context of <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">internationalized domain names</a> .  And to solve the problem will need a little more work. <br><br>  For network hosts, one of the solutions will be to show the names in the <a href="https://en.wikipedia.org/wiki/Punycode">Punycode</a> representation created to solve this particular problem by displaying the names in any encoding using only ASCII characters.  Returning to the usernames above, the differences between them become obvious.  If you want to try it yourself, here is a one-liner in Python and the result is on a username with a Cyrillic symbol: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'jne_doe'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'punycode'</span></span>) <span class="hljs-string"><span class="hljs-string">b'jne_doe-2fg'</span></span></code> </pre> <br>  (If you have problems with copy-paste non-ASCII characters, this name can be expressed as a string literal <code>j\u0430ne_doe</code> ). <br><br>  But to display user names in this form is not suitable in practice.  Of course, you can show Punycode every time, but it will break the display of many perfectly normal usernames with characters not in ASCII.  What we really <i>want</i> is to reject the above username during registration.  How to do it? <br><br>  Well, this time we are heading to the <a href="http://www.unicode.org/reports/tr39/">Unicode Technical Report 39</a> technical report and begin to read sections 4 and 5. The sets of code points that differ from each other (even after normalization), but are visually identical or, before mixing, are similar in visualization, are called ‚Äúleading to confusables, and Unicode provides mechanisms for detecting such code points. <br><br>  The username in our example is what Unicode refers to as ‚Äúmix-script confusable‚Äù leading to confusion, and this is what we want to detect.  In other words, the username is completely in Latin with ‚Äúleading to confusion‚Äù characters, can probably be considered normal.  And the fully Cyrillic username with ‚Äúleading to confusion‚Äù characters can probably also be considered normal.  But if the name is made up predominantly of Latin characters plus a single Cyrillic code point, which, when rendered, turned out to be similar to the Latin character before mixing ... then this will not work. <br><br>  Unfortunately, in the standard library, Python does not provide the necessary access to the full set of Unicode properties and tables to make such a comparison.  But an amiable developer named <a href="https://draft.li/">Victor Felder</a> wrote the <a href="http://confusable-homoglyphs.readthedocs.io/en/latest/index.html">appropriate library</a> and released it under a free open source license.  Using the <code>confusable_homoglyphs</code> library <code>confusable_homoglyphs</code> we can identify the problem: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> confusable_homoglyphs <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusables &gt;&gt;&gt; s1 = <span class="hljs-string"><span class="hljs-string">'jane_doe'</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">'j\u0430ne_doe'</span></span> &gt;&gt;&gt; bool(confusables.is_dangerous(s1)) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; bool(confusables.is_dangerous(s2)) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  The real result of the <code>is_dangerous()</code> function for the second user name is a data structure with detailed information about potential problems, but the main thing is that you can identify a string with mixed alphabets and code points that lead to confusion.  This is what we need. <br><br>  Django allows non-ASCII characters to be used in usernames, but does not check for identical characters from different encodings.  However, since version 2.3, django-registration has <code>confusable_homoglyphs</code> dependent on the <code>confusable_homoglyphs</code> library <code>confusable_homoglyphs</code> and its <code>is_dangerous()</code> function is used in the process of validating user names and email addresses.  If you need to implement user registration in Django (or in general in Python) and you can‚Äôt or don‚Äôt want to use django-registration, then I recommend using the <code>confusable_homoglyphs</code> library in the same way. <br><br><h1>  I have already mentioned that to achieve uniqueness is difficult? </h1><br>  If we are dealing with unicode code points leading to confusion, it makes sense to think about what to do with similar characters from the <i>same alphabet</i> .  For example, <code>paypal</code> and <code>paypa1</code> .  In some fonts it is difficult to distinguish them from each other.  Until now, all my proposals were suitable for everyone in general, but here we are entering a territory specific to specific languages, alphabets and geographic regions.  Decisions should be made here with caution and taking into account possible consequences (for example, a ban on misleading Latin characters may cause more false-positive results than you would like).  This is worth thinking about.  The same applies to the names of users who are different, but still very similar to each other.  At the database level, you can check in various forms - for example, Postgres comes with support for <a href="https://en.wikipedia.org/wiki/Soundex">Soundex</a> and <a href="https://en.wikipedia.org/wiki/Metaphone">Metaphone</a> , as well as support for <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> and <a href="https://www.postgresql.org/docs/9.6/static/pgtrgm.html">fuzzy matching trigrams</a> - but then again, this will have to be done occasionally and not all the time. <br><br>  I want to mention another problem with the uniqueness of names.  True, it refers mainly to e-mail addresses, which in our time are often used as usernames (especially in services that rely on a third-party identity provider and use OAuth and similar protocols).  Suppose we need to ensure the uniqueness of email addresses.  How many different addresses are listed below? <br><br><ul><li> <code>johndoe@example.com</code> </li> <li> <code>johndoe+yoursite@example.com</code> </li> <li> <code>john.doe@example.com</code> </li> </ul><br>  There is no definite answer.  Most mail servers have long ignored all characters after the <code>+</code> sign in the local part of the address when determining the user name.  In turn, many people use this technical feature to specify an arbitrary text after the "plus" as a <i>special</i> system of labels and filtering.  And Gmail also famously ignores the dots ( <code>.</code> ) In the local part, including in the distributed domains on their services, so without a DNS query, it is generally impossible to understand whether someone else‚Äôs mail server <code>johndoe</code> and <code>john.doe</code> . <br><br>  So if you need unique email addresses or you use email addresses as a user ID, you probably need to delete all points from the local part, as well as <code>+</code> and any text after it, before performing a uniqueness check.  Currently, django-registration does not do this, but I have plans to add this feature in version 3.x. <br><br>  In addition, when processing leading to confusion of Unicode code points in email addresses, apply this check <i>separately</i> to the local part and to the domain.  People can not always change the alphabet that is used in the domain, so they cannot be punished for using different alphabets in the local part and the domain part.  If neither the local part nor the part of the domain separately contain a mixture of alphabets leading to confusion, then probably everything is in order (and the django-registration validator does such a check). <br><br>  You may encounter many other problems regarding user names that are too similar to each other, so as not to be considered ‚Äúdifferent‚Äù, but as soon as you start turning off case sensitivity, start normalization and checking for a mixture of alphabets, quickly go to the territory with diminishing returns [when the benefits decrease with every innovation - <i>approx.</i>  <i>per.</i>  ], especially since many rules are beginning to apply that depend on a language, alphabet or region.  This does not mean that you do not need to think about them.  It's just hard to give universal advice that suits everyone. <br><br>  Let's turn the situation around a bit and consider a different type of problem. <br><br><h1>  Some names should be reserved </h1><br>  Many sites use the username not only as a field in the login form.  Some create a profile page for each user and put the username in the URL.  Some create email addresses for each user.  Some create subdomains.  So a few questions arise: <br><br><ul><li>  If your site puts the username in the URL on the profile page, what happens if I create a user named <code>login</code> ?  If I post the text ‚ÄúOur login page is moved, please click here to log in‚Äù with a link to my credential site.  How many people do you think I can fool? </li><li>  If your site creates email addresses from usernames, what happens if I register as a user named <code>webmaster</code> or <code>postmaster</code> ?  Will I receive letters directed to these addresses for your domain?  Can I get an SSL certificate for your domain with the correct username and an automatically created email address? </li><li>  If your site creates subdomains from user names, what happens if I register as a user with the name <code>www</code> ?  Or <code>smtp</code> , or <code>mail</code> ? </li></ul><br>  If you think that these are just silly hypothetical questions, well, well, <a href="http://www.theregister.co.uk/2011/04/11/state_of_ssl_analysis/">some of this actually happened</a> .  And not once, but <a href="https://www.tivi.fi/Kaikki_uutiset/2015-03-18/A-Finnish-man-created-this-simple-email-account---and-received-Microsofts-security-certificate-3217662.html">several times</a> .  No, in fact, <a href="https://twitter.com/EdOverflow/status/954093588362809345">such things happened several times</a> . <br><br>  You can ‚Äî and should ‚Äî take some precautionary measures to ensure that, say, an automatically created subdomain for a user account does not conflict with an already existing subdomain that you actually use for some purpose.  Or that automatically created email addresses do not conflict with important and / or already existing addresses. <br><br>  But for maximum security, you probably just need to prevent certain usernames from being registered.  I first saw such advice ‚Äî and the list of reserved names, as well as the first two articles mentioned above ‚Äî in <a href="https://ldpreload.com/blog/names-to-reserve">this article by Jeffrey Thomas</a> .  Starting with version 2.1, django-registration comes with a list of reserved names, and this list grows with each version;  now there are about a hundred entries. <br><br>  In <a href="https://github.com/ubernostrum/django-registration/blob/1d7d0f01a24b916977016c1d66823a5e4a33f2a0/registration/validators.py">the django-registration list, the</a> names are divided into several categories, which allows you to create subsets of them depending on your needs (the validator defaults to all of them, but you can reconfigure it with only the necessary sets of reserved names): <br><br><ul><li>  The addresses of the hosts used for auto-detection / auto-tuning of some well-known services. </li><li>  Host addresses associated with commonly used protocols. </li><li>  Email addresses used by certificate authorities to verify domain ownership. </li><li>  Email addresses listed in <a href="https://tools.ietf.org/html/rfc2142">RFC 2142</a> that are not listed in any other set of reserved names. </li><li>  Common addresses no-reply @. </li><li>  Strings matching confidential file names (for example, cross-domain access policies). </li><li>  A long list of other potentially sensitive names like <code>contact</code> and <code>login</code> . </li></ul><br>  The django-registration validator will also reject any username that starts with <code>.well-known</code> to protect everything that the <a href="https://tools.ietf.org/html/rfc5785">RFC 5785</a> standard uses to indicate ‚Äúwell-known URIs‚Äù. <br><br>  As in the case of characters in user names leading to confusion, I recommend that you copy the necessary elements of the django-registration list and add it if necessary.  In turn, this list is an enhanced version of Jeffrey Thomas‚Äôs list. <br><br><h1>  This is just the beginning. </h1><br>  Not everything that can be done to verify usernames is listed here.  If I tried to write a complete list, I would be stuck here forever.  However, this is a good starting platform, and I recommend following most or all of these tips.  I hope the article has shown approximately what difficulties may be hidden behind such a seemingly ‚Äúsimple‚Äù problem as user accounts with usernames. <br><br>  As I mentioned, Django and / or django-registration already performs most of these checks.  And what does not, probably will be added at least in the version of django-registration 3.0.  By itself, Django may not be able to implement such checks in the near future (or ever) because of strong backward compatibility issues.  All source code is open (under the BSD license), so copy, adapt and improve it without any problems. <br><br>  If I missed something important, please let me know about it: you can report a bug or send a pull-request to <a href="https://github.com/ubernostrum/django-registration">django-registration on GitHub</a> or simply <a href="https://www.b-list.org/contact/">contact me directly</a> . </div><p>Source: <a href="https://habr.com/ru/post/349232/">https://habr.com/ru/post/349232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349222/index.html">Hakintosh: upgrading from macOS Sierra 10.12 to High Sierra 10.13</a></li>
<li><a href="../349224/index.html">PostgreSQL indexes - 10</a></li>
<li><a href="../349226/index.html">The blockchain program committee or how to fight off the ICO</a></li>
<li><a href="../349228/index.html">Unit tests when using Corutin in Android application</a></li>
<li><a href="../349230/index.html">How to make your code 80 times faster</a></li>
<li><a href="../349234/index.html">Security Week 4: Bots for GTA fans, malicious addons for Chrome with Yandex technologies</a></li>
<li><a href="../349236/index.html">Measuring and shaping the frequency characteristics of electric guitars</a></li>
<li><a href="../349238/index.html">My remarks on the book by L.P. Plekhanov "Fundamentals of self-timed electronic circuits"</a></li>
<li><a href="../349242/index.html">Monitoring IT Performance with Splunk IT Service Intelligence</a></li>
<li><a href="../349246/index.html">Bro, why do we need a business? Let's trade in brooms. After all, they are used in every yard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>