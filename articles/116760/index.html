<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Tutorial on the other hand</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I want to debunk the myths about the complexity and narrow specialization of functional programming in general and Haskell in particu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Tutorial on the other hand</h1><div class="post__text post__text-html js-mediator-article">  In this article, I want to debunk the myths about the complexity and narrow specialization of functional programming in general and Haskell in particular.  I will try to make this article understandable even for people with a minimal view of Haskell.  But first a small introduction. <br><br>  I categorize myself as a lazy amateur photographer.  I have a good ‚Äúmirrorless SLR‚Äù, sometimes I am attacked by the desire to click something around me.  However, I am lazy, and then I have no time or poking around in the resulting photo archive.  As a rule, photos are viewed once or twice immediately after shooting by connecting the camera to a TV via an HDMI cable.  Then the photos are sent to <s>non-existence</s> directory ~ / Pictures / Photos / Unsorted and, as a rule, remain there forever.  With various specials.  I somehow did not make friends with the software, so this mess lasted for almost two years.  And so, in the wake of exploring Haskell, I'm ripe for a solution. <br><a name="habracut"></a><br><h2>  Denial of responsibility </h2><br>  I do not claim to be a functional programming guru, I admit that the code I wrote is terrible (after all, I have been doing Haskell closely for a little more than two months in my spare time), and moreover, it may not work properly.  The purpose of this article is to show that Haskell is really a general-purpose language that can be used not only for the nightmarish, most complicated mathematical calculations, but also for quite ordinary, everyday tasks.  And great to deal with them. <br><br>  I am aware of the existence of special programs that solve this problem, but I needed a simple, elementary utility that does exactly what I want.  I am aware that this problem could be solved on any bash or perl in general, but this is the choice of the author, that is, me. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Before you start </h2><br>  I think this is the last part of the long introduction.  First, of course it is desirable to have a basic knowledge of Haskell, otherwise a lot can be incomprehensible.  It would be nice to have an idea about monads.  However, I will try to explain the "subtle" points in the process of presentation, and I hope that with some effort everyone will understand this article. <br><br>  Secondly, the necessary tools.  Further, it is assumed that all events unfold on a Linux machine, but with minor changes, all this is true for Windows, and even more so for Mac OS X. In order to be able to build the resulting program, you need to do three things: <br><ol><li>  Download and install the <a title="Haskell platform" href="http://hackage.haskell.org/platform/">Haskell platform</a> from the repository of your distribution; </li><li> Install the Haskell EXIF ‚Äã‚Äãlibrary: <code>sudo cabal install --global exif</code> ; </li><li>  install GTK + \ Glade and the corresponding Haskell <code>sudo cabal install --global glade</code> : <code>sudo cabal install --global glade</code> . </li></ol><br><br><h2>  Formulation of the problem </h2><br>  So, I needed the simplest utility for ‚Äúpacking‚Äù photos by date into the appropriate daddy, which can be invoked both for a freshly connected device, and independently for sorting an already existing archive with photos.  In principle, everything, nothing complicated. <br><br><h2>  How are we going to decide </h2><br>  It's simple.  To begin with, it is necessary to support two modes: <ul><li>  ‚ÄúAutomatic‚Äù - when the directory that you want to ‚Äúscan‚Äù is passed as a command line argument; </li><li>  ‚ÄúManual‚Äù - when a simple GUI front-end is launched, in which we independently choose the directory for processing. </li></ul><br>  Generally speaking, the GUI here is not at all mandatory, but I remind you that this is such a small learning example that will show in general and that Haskell's GUI is also never scary. <br><br>  Further, regardless of how the catalog was slipped to us, we bypass this catalog (including bypassing all the subdirectories, because many cameras (if not all) carefully put the photos in the PHOTO daddy, and then in some 100PANA, 101PANA, and t . p.) and process each individual file. <br><br>  Processing each individual file to madness is simple: we read the Exif data and, if there is any, copy it (the file with the photo) into the directory corresponding to the extracted date. <br><br>  Whether we wanted it or not, but in the process of telling what our program should do, we described its three main <u>functions</u> : <br><ul><li>  run the program and check the arguments; </li><li>  directory traversal; </li><li>  processing a specific file. </li></ul><br><br>  Let's add some sources now. <br><br><h2>  Closer to the code </h2><br>  <em>Lyrical digression.</em>  Haskell programs have a modular structure, just like in C, but of course without terrible header files.  The exported (external) functions are specified in the module description, followed by imports of other modules and code.  Haskell programs consist only of a description of data types and functions.  Everything. <br><br>  So let's start over.  Namely, with the main function of the Main module (after all, the program starts with it).  Here is the code for the entire module. <br>  Main: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#0000ff">module</font> Main <font color="#0000ff">where</font> </li><li></li><li>  import System (getArgs) </li><li>  import manager </li><li>  import GUI </li><li></li><li>  main :: IO () </li><li>  main = getArgs &gt;&gt; = launch </li><li></li><li>  - there should be a single argument with the path to the photos, otherwise we run the gui </li><li>  launch :: [String] -&gt; IO () </li><li>  launch [x] = processDirectory x </li><li>  launch _ = startGUI </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  I will dwell on the description of our first module in a little more detail, with an explanation of the main things.  So, the first line is the module description.  Next, import lines (from the System module, only the getArgs function is imported, which returns a list of command line arguments <strong>without the</strong> name of the executable file).  The Manager and GUI modules will be described later. <br><br>  Next comes the description of the <code>main</code> function.  The first line of the description is an optional type definition, generally speaking, it is not always necessary, in most cases the type of the function can be <strong>deduced</strong> from the types of arguments supplied to it.  Any function is described by a <strong>system of equations</strong> , and the second line is the equation itself. <br><br>  <em>Lyrical digression.</em>  Formally, all functions can be divided into clean and "dirty", with side effects.  I'll try to explain on the fingers. <br>  A function is pure if, regardless of anything, with the same input data, it generates the same output data, while it never changes any system states and does not depend on them (whether the state of the file system or the presence of an open TCP connection).  Take for example the addition function.  It takes two arguments, and if both of these arguments are equal to number 2, then at the output we will always (absolutely always) get the number 4. And yes, the addition function of TCP does not open connections. <br>  Functions with side effects - a separate conversation, they are just invented in order to designate the dependence of functions on any external manifestations by means of a model called the <strong>input / output monad (IO monad)</strong> .  For simplicity of perception at the moment we will think about monads only in the context of ‚Äúinput / output‚Äù (although in fact this concept is much broader).  A function with side effects is a description of the sequence of <strong>actions</strong> , as a result of which we will get some value-result.  Example: <br>  <code>readFile :: FilePath -&gt; IO (String)</code> is a function of reading a file along a specified path to this file.  More precisely, it is not a function, it is its type.  The type of functions is very simple to read, first comes the name of the function, then after two colons with the symbol -&gt; the arguments of the functions are separated and after the last -&gt; there comes the type of the return value.  This is a primitive description, but it is still sufficient.  That is, it is clear that the function takes a certain FilePath and returns <strong>an I / O action</strong> , the execution of which will give the value String. <br>  Here it is important to understand that the sequence of actions! = Sequence of calculations.  In fact, <strong>we generally do not know exactly</strong> in which sequence the calculations will actually take place; we determine only the order of the actions for which they stand.  Therefore, the presence of such an abstraction as monads does not make Haskell imperative. <br><br>  So back to our <code>main</code> .  It takes no arguments and obviously returns an I / O action.  The execution of this action is the execution of our entire program.  It's funny, but in the whole received program, not <strong>a single</strong> pure function is written, which is strikingly different from all the existing tutorials, however, this is just the problem solved by the program.  The sequence of actions is determined by the functions <code>&gt;&gt;=</code> and <code>&gt;&gt;</code> , which take two arguments.  In the first case, the result of performing the action on the left is passed as an argument to the function call on the right, and in the second, the action on the left is just silently executed, and then the action is performed on the right. <br><br>  In this case, the execution of the action defined by the <code>getArgs</code> function results in the execution of a list of application string strings, which is passed to the <code>launch</code> function.  The launch function is described below.  It takes a list of strings as an argument, and it also returns an I / O action that returns no value.  As I said before, functions in Haskell are described by systems of equations, which are graphically represented in the definition of launch. <br><br>  <em>Lyrical digression.</em>  Which equation will be selected for each particular function call is determined by the pattern matching procedure, that is, pattern matching.  The function template is defined by the part of the equation defined on the left.  The pattern matching procedure selects the controls in the order they appear in the code.  A generic pattern denoting ‚Äúanything‚Äù is a <code>_</code> character.  In templates, you can (and should!) Decompose various data structures, for example, writing <code>foo ["a",""] = 0</code> means that if the foo function comes with a list of two lines "a" and "b", then it will return 0. <br><br>  So, if a list from a single value of <code>x</code> comes into the <code>launch</code> function, we assume that this is the path to the directory and call the <code>processDirectory</code> function from the Manager module with an argument equal to <code></code> itself (note that there is no need to explicitly specify which module the function if at the same time there is no double interpretation, i.e. there is a function with one name in two modules).  And if something else is different (note the <code>_</code> pattern), then we launch the GUI. <br><br>  That's the whole module Main!  We have just implemented the function # 1 of our program, we launched it! <br>  Yes, I understand perfectly how terribly this looks to the uninitiated, but now look again at the source of the Main module.  Reread all the lyrical digressions and tell yourself, is it so difficult?  Maybe just unusual?  For those who bravely and stoically endured all the tests, it is proposed to continue reading. <br><br><h2>  EXIF data </h2><br>  Let's leave for now the main computational process and write the function of extracting data about the time of the photograph from EXIF.  For this, a separate Photo module was created.  Why separate?  Because it was dictated to me by my inner sense, it is assumed that this is a module for working with photography, what if my software grows into additional functionality?  Let's look at its source. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#0000ff">module</font> Photo ( </li><li>  getTime </li><li>  ) <font color="#0000ff">where</font> </li><li></li><li>  import <font color="#0000ff">data</font> .  <font color="#0000ff">Time</font> </li><li>  import System.Locale </li><li>  import Graphics.Exif </li><li></li><li>  getTime :: String -&gt; IO (Maybe <font color="#0000ff">Day</font> ) </li><li>  getTime filePath = </li><li>  fromFile filePath &gt;&gt; = (\ e -&gt; getTag e "DateTime") &gt;&gt; = ( <font color="#0000ff">return</font> . parseDateTime) </li><li>  <font color="#0000ff">where</font> </li><li>  parseDateTime (Just str) = parseTime defaultTimeLocale "% Y:% m:% d% H:% M:% S" str </li><li>  parseDateTime Nothing = Nothing </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  Fearfully?  Not at all.  Note that this time in the definition of the module we indicated in brackets the name of the getTime function.  Here are the functions that are accessible from outside the module.  This is a simple and elegant solution instead of header header files that have passed in C \ C ++. <br><br>  Pay attention to the getTime function.  It takes as an argument the path to the file, and returns an action that will result in <strong>Day</strong> .  Maybe here is not some keyword, it is quite a certain type, which can take two values: Just Something or Nothing.  This data type is used if, as a result, the function may not return any specific value from the value range.  For example, searching for an item in the list that meets specified conditions.  This element may not be. <br><br>  Here, the presence of Maybe tells us that there may be no time data in this file.  Day is just one of the data types representing time in Haskell.  The definition of the getTime function (that is, the right side of the equation) immediately introduces two more concepts new to us.  But first things first.  It can be seen that getTime consists of three actions: <ul><li>  first, the fromFile function from the Graphics.Exif module reads an object of Exif type, the execution of the corresponding action gives us this object and it is passed to the call of the next function; </li><li>  The following function is a lambda expression <code>\ e -&gt; getTag e "DateTime"</code> , here the backslash imperceptibly resembles the Greek symbol "lambda", it is a function of one argument, which accepts the previously received Exif, which returns the IO action (Maybe String) returned the getTag function that accepts Exif and the tag name; </li><li>  the result of the previous action is given to the final structure, we describe it in more detail. </li></ul><br><br>  First, the terrible and controversial word return.  In fact, return in Haskell does not return anything, and the definition of the function is very indirect.  return is a simple function that turns a value into <strong>action</strong> into it.  The point is that a function whose execution is an execution of a chain of actions cannot return a ‚Äúpure‚Äù value.  It cannot return ‚Äújust a String‚Äù, because getting this String is possible only when performing a certain chain of actions, that is, getting this String in itself is <strong>also an action</strong> , so we need to wrap the resulting value into a monad, i.e.  ‚ÄúReturn it‚Äù (return) to where it was received from.  It was obtained from the monad, we need to return it (wrap?) To the monad again.  As for the return value: the monadic function returns the last action defined in it, i.e.  in this case, just return. <br>  Secondly, the dot symbol is a composition of functions.  Let <code>fy = z; gx = y;</code> <code>fy = z; gx = y;</code>  , then <code>(f . g) x == f( gx ) == z</code> .  As a result of the second action, we get a <strong>string</strong> with the date, and the function itself returns <strong>Day</strong> .  Therefore, we can be this line first parsim, as a result, obviously, it turns out there can be a date, we return it.  In fact, the last action can be written as: <br><blockquote> <code>\ str -&gt; return (parseDateTime str)</code> </blockquote> <br><br>  And finally, the where block, which explains that we also used parseDateTime in the definition of getTime.  In the where block, the functions of the context are defined, let's say.  Their scope is limited to the specific definition in which this block is found.  In these context functions, you can and should refer to the input arguments of the parent function.  In this case, such a function of the context is the function of parsing values.  We carried it out in a separate block, because it must be represented by two equations (otherwise it would be possible to substitute its definition directly into the getTime definition) for two patterns ‚Äî with Just and Nothing.  In the first case, we parse the value, and in the second we return Nothing again.  Agree, quite clearly? <br><br>  With the function of extracting time is over.  Prisutpim to bypass the directory. <br><br><h2>  Function # 2 - directory traversal </h2><br><br>  <em>Lyrical digression.</em>  Haskell makes you think a little differently, not the way we used to solve problems in imperative languages.  When it comes to, say, traversing a directory with files, a C programmer would say the following: ‚ÄúI‚Äôll go through the files and check A, I‚Äôll do it B‚Äù.  However, a programmer in a functional language would say: ‚ÄúI will apply the processing function to each file in a directory‚Äù. <br><br>  Slightly rebuilding your thinking you stop regretting the lost cycles.  In the functional language, they are successfully replaced by convolutions and "maps" (map).  Convolution we do not need here, I will not bother with explanations.  I‚Äôll dwell on the map function.  The Russian word closest in meaning is ‚Äúmapping,‚Äù and this is indeed so.  The map function maps one data set to another.  It takes as input a list of elements of type <strong>a</strong> , a function of type <strong>a -&gt; b</strong> (but what, this is a functional language, here you can pass a function as an argument!) And we get a list of type b at the output.  Here is the type of map function: <br><br><blockquote> <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> </blockquote> <br><br>  Note the parentheses of the first argument, they report that the second argument is a function in itself.  Generally speaking, in Haskell, all functions are actually functions of one argument, just as a result, some of them return not values, but also functions.  Consider the addition function: <br><br><blockquote> <code>add :: Int -&gt; Int -&gt; Int</code> </blockquote> <br><br>  Her type is absolutely correct to write this: <br><br><blockquote> <code>add :: (Int -&gt; (Int -&gt; Int))</code> </blockquote> <br><br>  Feel the difference?  So, <code>add 5 2</code> returns the value 7. But <code>add 5</code> , returns a function that takes a value of type Int and returns a value of type Int!  It is on such miracles that the principle of using the map function is built.  This is how we add one to all elements of the source list: <br><br><blockquote> <code>map (+ 1) [1,2,3]</code> </blockquote> <br><br>  But you‚Äôll find similar examples in any Haskell tutorial.  Let's return to our sheep.  Now it becomes clear that with the entire list of items in the catalog you need to do a completely uniform action and get a list of the results of these actions (in fact, it will be a little wrong, but it does not matter).  Feel it?  This is where the use of map is requested.  But first we will decide on what needs to be done with each element of the catalog. <br><br><ul><li>  first, you need to know the directory or file; </li><li>  secondly, if this is a directory, then we go inside, i.e.  call the directory processing function again; </li><li>  Finally, thirdly, if this is a file, then you need to try to extract time from its EXIF ‚Äã‚Äãdata, and if it is, copy it to the appropriate place. </li></ul><br><br>  Next, I will intentionally delete part of the original code (or replace it with ‚Äúpseudo-code‚Äù stubs), leaving only the most important.  Imagine that we somehow learned the information about whether a given entry is a directory while we omit it.  Then consider the following processing function: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  - processing of the element: if the directory - enter recursion, otherwise we process the photo </li><li>  processSingle :: ( <font color="#2B91AF">String</font> , Bool) -&gt; IO () </li><li>  processSingle (path, True) = processDirectory path </li><li>  processSingle (path, False) = <font color="#0000ff">do</font> </li><li>  picturesDir &lt;- getPicturesDir </li><li>  maybeDate &lt;- getTime path </li><li>  copyPhoto picturesDir maybeDate </li><li>  <font color="#0000ff">where</font> </li><li>  - safe copying </li><li>  copyPhoto pictures Nothing = <font color="#0000ff">return</font> () </li><li>  copyPhoto pictures (Just date) = <font color="#0000ff">do</font> </li><li>  let newPath = pictures ++ <font color="#A31515">"/"</font> ++ (formatTime defaultTimeLocale <font color="#A31515">"% Y /% B /% d"</font> date) </li><li>  copyFile path newPath </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  So, we got the processSingle function.  It takes as its argument a two-element tuple (that is, a pair of values): the path to the file system element and the sign that this is a directory.  Taking advantage of the pattern matching, the function was divided into two equations: the first for the directory (going into recursion - the processDirectory function will be discussed later), the second for the file.  Here we first learn about the do-action notation. <br><br>  <em>Lyrical digression.</em>  Up to this point, we recorded the sequence of actions ‚Äúone after another‚Äù, separating them with special icons.  This is not always convenient, for example, if you need to make a comparison with the template for the value extracted from the action ‚Äúon the fly‚Äù.  Or, what happens more often, you need to perform two actions, and transfer their result to the third function.  Here do-notation comes to the rescue, which is actually more friendly to the eyes of beginners.  Here are two equivalent codes: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  foobar = action1 &gt;&gt; = action2 &gt;&gt; = action3 </li><li></li><li>  foobar '= <font color="#0000ff">do</font> </li><li>  result1 &lt;- action1 </li><li>  result2 &lt;- action2 result1 </li><li>  action3 result2 </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  In this case, two results of two different actions are used as an argument to the third function.  The copy function is trivial: <code>newPath</code> by pattern, if you find a date, then copy the file from <code>path</code> to <code>newPath</code> .  Note two features: <ul><li>  The path is an argument of the most "upper" function processSingle, i.e.  copyPhoto is a context-sensitive function; </li><li>  let is a keyword of a language, it allows you to <strong>bind</strong> some value to a certain name (please note, this is <strong>not an assignment</strong> , its value cannot be changed, although this name can be bound to another value, but if you passed it to some function before then it will not change there) - in this case it is applied simply for convenience. </li></ul><br><br>  <code>formatTime</code> is obviously a function that accepts a locale, a pattern, and a date, and returns a string with a date formatted with this pattern. <br>  <code>++</code> is a list concatenation function. <br><br>  SUDDENLY, we just described feature # 3.  Really simple?  So what will our function number 2 look like?  It will look like this: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  processDirectory :: <font color="#2B91AF">String</font> -&gt; IO () </li><li>  processDirectory dir = </li><li>  getDirectoryContents dir &gt;&gt; = checkItems &gt;&gt; = (mapM_ processSingle) </li><li>  <font color="#0000ff">where</font> </li><li>  - according to the given list of contents of the catalog we return tuples with a marker <font color="#A31515">"catalog"</font> for each element </li><li>  checkItems xs = mapM singleCheck xs </li><li>  <font color="#0000ff">where</font> </li><li>  singleCheck path = <font color="#0000ff">do</font> </li><li>  isDirectory &lt;- (doesDirectoryExist path) </li><li>  <font color="#0000ff">return</font> (path, isDirectory) </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  Take a closer look at this, in fact it is a very simple function.  But first, a few words about mapM and mapM_. <br><br>  <em>Lyrical digression.</em>  The map function, which was discussed above, works only with pure code.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have the same monadic code, so we must use a monadic map. </font><font style="vertical-align: inherit;">Consider the types of these functions:</font></font><br><blockquote> <code>mapM :: (a -&gt; IO b) -&gt; [a] -&gt; IO [b] <br> mapM_ :: (a -&gt; IO b) -&gt; [a] -&gt; IO () <br></code> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They have exactly the same meaning as in a clean map, but at the output they give not pure values, but actions that return these values. </font><font style="vertical-align: inherit;">In the first case, we are interested in the result of processing each specific value and we get an action, as a result of which a list of processed values ‚Äã‚Äãis obtained. </font><font style="vertical-align: inherit;">In the second case, we are not interested in the result of the processing, we need to just perform the actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we will read the code from the bottom up:</font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The singleCheck function is a function that checks whether a directory is located along a given path and returns a pair of marker paths (this is exactly the construction that we have processed above!); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The checkItems function takes a list of files (paths to them) and does not return an action that, when executed, will give a list of path-marker pairs (here we are interested in the result of the action, therefore mapM); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, the processDirectory function receives a list of files, sets a marker to each of them, and then processes each received pair according to the processSingle function defined above (here the processing itself does not return anything significant, we are not interested in the result of the action, we need it to be executed). </font></font></li></ul><br><br>  And it's all!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The end! </font><font style="vertical-align: inherit;">The program is ready. </font><font style="vertical-align: inherit;">Before the final part, I want to say a few words about the GUI.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GUI in declarative languages </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between declarative and imperative languages? In imperative languages, you need to describe HOW to make calculations, in declarative ones, you need to describe WHAT you want to receive. The clearest example of a declarative language is SQL. Now let's think for a second about the graphical interface. In fact, it is necessary only declaratively (in accordance with the rules of a particular toolkit) to describe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we want to see, and immediately next to describe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an object should do when interacting with it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now back to Haskell - as a functional declarative language, it miraculously falls on this structure, because, for example, to create a button click handler, it is enough to pass a certain handler function as an argument! </font><font style="vertical-align: inherit;">And it is very natural. </font><font style="vertical-align: inherit;">I use GTK to create Haskell interfaces. </font><font style="vertical-align: inherit;">It is done this way: I draw molds in Glade, and in Haskell code I place handlers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the simplified code for our task:</font></font><br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prepareGUI mainWindow startButton fileChooser = </font></font></li><li>  <font color="#0000ff">do</font> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onDestroy mainWindow mainQuit </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onClicked startButton (processClick fileChooser) </font></font></li><li>  <font color="#0000ff">where</font> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> processClick fileChooser = fileChooserGetFilename fileChooser &gt;&gt; = processDirectory </font></font></li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I think he does not need comments. </font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I posted the full source of the project on github (link below), I invite everyone interested to get acquainted, I provided them with quite detailed comments. Despite the impressive volume of the resulting article, I believe that those who carefully read it realized that this is not so complicated your Haskell, it is just a little different. It is based on other principles, but based on them it is possible to write code of any level, be it system or application programming. You can go even further: for a moment, imagine what a wonderful MVC web framework could be born on the basis of Haskell! In this tutorial, I only touched the tip of the iceberg, in fact, there is still something to learn - polymorphism, type classes, parallellism! .. I hope that at least someone with this article has ignited a spark of desire to learn this wonderful language. </font></font><br><br> <a href="https://github.com/pechlambda/photosort"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project on github</font></font></a> <br> <a href="http://book.realworldhaskell.org/read/">   Haskell</a> </div><p>Source: <a href="https://habr.com/ru/post/116760/">https://habr.com/ru/post/116760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116749/index.html">Microcomputer BK 0010-01</a></li>
<li><a href="../116752/index.html">Draw widgets in the title bar</a></li>
<li><a href="../116753/index.html">IT in medicine: the way of the USA</a></li>
<li><a href="../116754/index.html">Pop-up flash message from the depths of background tasks</a></li>
<li><a href="../116759/index.html">Adding Input Method to Arduino</a></li>
<li><a href="../116761/index.html">Encrypt files in black and white images.</a></li>
<li><a href="../116767/index.html">Repent of your sins and be happy. Or how small usability flaws spoil the whole result.</a></li>
<li><a href="../116768/index.html">Making your Gmail Motion</a></li>
<li><a href="../116769/index.html">We protect the VPS-server based on Windows 2008 R2</a></li>
<li><a href="../116771/index.html">Mono and Windows Forms on the Nokia N900? Sure, not a problem!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>