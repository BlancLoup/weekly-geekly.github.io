<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perl One-Line Programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I'm going to talk about Perl single-line programs. If you master one-line Perl, you can save a lot of time (I save). 

 The purpose of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perl One-Line Programs</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  I'm going to talk about Perl single-line programs.  If you master one-line Perl, you can save a lot of time (I save). <br><br>  The purpose of the post is to show how Perl can be used instead of find, grep, awk, sed.  At the end of the post it will be written why it is necessary. <br><a name="habracut"></a><br>  Well, first things first. <br><br><h4>  Flags </h4><br>  <b>-E flag</b> <br>  The flag allows you to run barley code directly in the console, I use this feature to check some test code. <br>  Suppose I want to know the decimal value of the hexadecimal number 0xFA23B: <br><pre><code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"print 0xFA23B"</span></span></code> </pre> <br>  <i>Note.</i>  When the single-line barley code is launched from under Windows, the code should be enclosed in double quotes: <br><pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"print 0xFA23B"</span></span></code> </pre>  , in the case of Linux / Unix, the code can be either in double quotes or in single quotes, but in Unix / Linux, the case of double quotes has to be escaped with "$" signs: <pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"\$i = 0;print \$i"</span></span></code> </pre> <br>  <i>Note.</i>  <b>After the -e flag should immediately follow the code</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>-L flag</b> <br>  This flag makes initializes the variables $ / and $ \ value "\ n"; <br>  The variable $ / sets the separator of the input fields. <br>  The variable $ \ specifies what will be output after the print command. <br><br>  Program: <br><pre> <code class="perl hljs">perl -le <span class="hljs-string"><span class="hljs-string">"print 1"</span></span></code> </pre> <br>  Equivalent to the following: <br><pre> <code class="perl hljs">BEGIN { $/ = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $\ = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Thus, in the end, you do not have to write print "\ n"; <br><br>  <b>-N flag</b> <br>  From here begins the most interesting. <br><br>  The following code: <br><pre> <code class="perl hljs">perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'print 1'</span></span></code> </pre> <br>  equivalent to this: <br><pre> <code class="perl hljs">LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Where can this be used? <br>  And here, for example, we need to add to the names of files whose names begin with numbers, the extension ‚Äúbak‚Äù: <br><br>  Voila: <br><pre> <code class="perl hljs">ls | perl -lne <span class="hljs-string"><span class="hljs-string">'rename $_, "$_.bak" if /^\d+/'</span></span></code> </pre> <br>  And for Windows?  You are welcome: <br><pre> <code class="perl hljs">dir /b | perl -lne <span class="hljs-string"><span class="hljs-string">"rename $_, \"$_.bak\" if /^\d+/"</span></span></code> </pre> <br>  Let's look at the resulting program: <br><pre> <code class="perl hljs">BEGIN { $/ = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $\ = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-keyword"><span class="hljs-keyword">chomp</span></span> $_; <span class="hljs-keyword"><span class="hljs-keyword">rename</span></span> $_, <span class="hljs-string"><span class="hljs-string">"$_.bak"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> /^\d+<span class="hljs-regexp"><span class="hljs-regexp">/; }</span></span></code> </pre><br>  chomp $ _;  took from the <b>-l</b> flag: together with <b>-n,</b> it also adds chomp $ _ ;, and not just BEGIN {$ / = "\ n";  $ \ = "\ n";  } <br><br>  <b>-A flag</b> <br>  The -a flag allows perl to be used as awk. <br><br>  The following code: <br><pre> <code class="perl hljs">perl -nae <span class="hljs-string"><span class="hljs-string">"print 1"</span></span></code> </pre> <br>  equivalent to: <br><pre> <code class="perl hljs">LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-keyword"><span class="hljs-keyword">our</span></span>(@F) = <span class="hljs-keyword"><span class="hljs-keyword">split</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>, $_, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  That is, each line is split by a split by spaces, and the resulting fields are put into an @F array. <br>  The field separator can be changed using the <b>-F</b> flag. <br><br>  Suppose you need to output usernames with their home directories from the / etc / passwd file: <br><pre> <code class="perl hljs">less /etc/passwd | perl -F: -nlae <span class="hljs-string"><span class="hljs-string">'print "$F[0]:$F[4]"'</span></span></code> </pre> <br>  And for Windows, for example, I want to know the names of the files in the folder that I last changed in September 2009: <br><pre> <code class="perl hljs">dir /TW | perl -nale <span class="hljs-string"><span class="hljs-string">"print $F[$#F] if $F[0] =~ /\.09\.2009/"</span></span></code> </pre> <br>  <b>-P flag</b> <br>  This flag does the same, that <b>-n</b> only adds another block continue c "print $ _". <br><br>  The following code: <br><pre> <code class="perl hljs">perl -pe <span class="hljs-string"><span class="hljs-string">"print 1"</span></span></code> </pre> <br>  equivalent to: <br><pre> <code class="perl hljs">LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $_; }</code> </pre><br>  Suppose we output the file / etc / passwd, simultaneously replacing 3 with 6. <br><br>  Instead of this code: <br><pre> <code class="perl hljs">less /etc/passwd | perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">"s/3/6/;print \$_"</span></span></code> </pre> <br>  We can write: <br><pre> <code class="perl hljs">less /etc/passwd | perl -pe <span class="hljs-string"><span class="hljs-string">"s/3/6/"</span></span></code> </pre> <br>  <b>-I flag</b> <br>  The i flag allows you to change files. <br><br>  Next program: <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">"s/foo/bar/"</span></span></code> </pre> <br>  equivalent to this: <br><pre> <code class="perl hljs">BEGIN { $^I = <span class="hljs-string"><span class="hljs-string">".bak"</span></span>; } LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-regexp"><span class="hljs-regexp">s/foo/bar/</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $_; }</code> </pre><br>  which in turn is equivalent to this: <br><pre> <code class="perl hljs">$extension = <span class="hljs-string"><span class="hljs-string">'.bak'</span></span>; LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (&lt;&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ARGV <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> $oldargv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($extension !~ <span class="hljs-regexp"><span class="hljs-regexp">/\*/</span></span>) { $backup = $ARGV . $extension; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ($backup = $extension) =~ <span class="hljs-regexp"><span class="hljs-regexp">s/\*/$ARGV/g</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>($ARGV, $backup); <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(ARGVOUT, <span class="hljs-string"><span class="hljs-string">"&gt;$ARGV"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(ARGVOUT); $oldargv = $ARGV; } <span class="hljs-keyword"><span class="hljs-keyword">s</span></span>/foo/bar/; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>; <span class="hljs-comment"><span class="hljs-comment"># this prints to original filename } select(STDOUT);</span></span></code> </pre><br>  In brief, I‚Äôll explain what happens when the perl -i.bak -pe ‚Äúcode‚Äù &lt;file name&gt; lines are called.  For example, we call: <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">"s/foo/bar/"</span></span> test.txt</code> </pre> <br>  The test.txt file is renamed to the test.txt.bak file, and a new test.txt file is created.  Then, in each line of the source file, foo is replaced with bar, which are written to the new test.txt file (apparently, although the file was renamed, do we still have access to its strings?) <br><br>  Suppose you need to replace \ r \ n with \ n in the file: <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">'s/\r\n/\n/'</span></span> test.txt</code> </pre> <br>  As a result of this code, you will get two files: one is test.txt.bak, which is a copy of the source file, the other is test.txt, where \ r \ n is replaced by \ n. <br><br>  <i>Note</i>  If you look closely at the program above ($ extension = '.bak'; ...), you will see that if you call it like this: perl -ibak_ * ..., the backup file will be called ‚Äúbak_test.txt‚Äù, that is, if there is an asterisk in the value of the parameter i, then this value is considered not as an extension, but as a template, where the asterisk denotes the name of the file. <br><br>  <b>-M flag</b> <br><br>  The <b>-M</b> flag allows you to connect modules <br><br>  For example, I want to know where the CGI module is: <br><br>  for Windows: <br><pre> <code class="perl hljs">perl -MCGI -le <span class="hljs-string"><span class="hljs-string">"print $INC{'CGI.pm'}"</span></span></code> </pre> <br>  for Linux: <br><pre> <code class="perl hljs">perl -MCGI -le <span class="hljs-string"><span class="hljs-string">"print \$INC{'CGI.pm'}"</span></span></code> </pre> <br>  Recently, I needed to make chmod a + x to all files with the extension ".cgi", <br>  but on the server the -R flag for chmod for some reason did not work, so what I did was something like this: <br><pre> <code class="perl hljs">perl -MFile::Find -e <span class="hljs-string"><span class="hljs-string">'finddepth(sub {print $File::Find::name . "\n"}, "."})'</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> -P <span class="hljs-string"><span class="hljs-string">'\.cgi$'</span></span> | perl -nle <span class="hljs-string"><span class="hljs-string">'`chmod a+x $_`'</span></span></code> </pre> <br>  With this code, ‚Äúperl -MFile :: Find -e 'finddepth (sub {print $ File :: Find :: name.‚Äû \ N ‚Äú},‚Äù. "})'" I called the finddepth function of the File :: Find module, which recursively went around the current directory and output the full file paths. <br><br>  Then, with the grep, I took only those files that end in '.cgi' (-P means that barley regular expressions are used), and with the following program ‚Äúperl -nle '` chmod a + x $ _`' ‚ÄùI made execution rights found files <br><br>  Although I could write this code like this: <br><pre> <code class="perl hljs">perl -MFile::Find -e <span class="hljs-string"><span class="hljs-string">'finddepth(sub {$n = $File::Find::name;`chmod a+x $n` if $n =~ /\.cgi$/}, ".")'</span></span></code> </pre> <br>  Note that you need to use the -l flag so that the $ _ name gets the file name without "\ n" <br><br>  And what if you need to connect some variables or subroutines from the plug-in package to the main package? <br>  Then you need to write: <br><pre> <code class="perl hljs">perl -MModule=foo,bar -e <span class="hljs-string"><span class="hljs-string">'...'</span></span>;</code> </pre> <br>  or <br><pre> <code class="perl hljs">perl <span class="hljs-string"><span class="hljs-string">'-Mmodule qw(foo bar)'</span></span> -e <span class="hljs-string"><span class="hljs-string">'...'</span></span>;</code> </pre> <br><h4>  BEGIN and END </h4><br>  BEGIN and END can be used for actions that should occur at the beginning and at the end, in the same way as awk. <br><pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">'BEGIN{&lt; &gt;};&lt;&gt;;END{ }'</span></span>;</code> </pre> <br>  For example, we will display lines consisting of 40 "=" characters at the beginning and end of the report: <br><pre> <code class="perl hljs">dir /b | perl -pe <span class="hljs-string"><span class="hljs-string">"sub line {print '=' x 40 . \"\n\"};BEGIN{line();};END{line()}"</span></span></code> </pre> <br><h4>  Debag </h4><br>  To debug single-line programs you need to connect the module B :: Deparse, <br><br>  If you run: <br><pre> <code class="perl hljs">perl -MO=Deparse -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">"print 1"</span></span></code> </pre> <br>  Then get the output: <br><pre> <code class="perl hljs">LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } -e syntax OK</code> </pre><br>  module B :: Deparse should be connected like this: "-MO = Deparse", and not like this: "-MB :: Deparse".  Apparently, this is done in order to clearly define that we want to use this module to display the source code of the program, and not just to use any of its methods in the program. <br><br>  This is how the B :: Deparse module will be used as a normal module; no code will be output: <br><pre> <code class="perl hljs">perl -MB::Deparse -e <span class="hljs-string"><span class="hljs-string">"print 1"</span></span></code> </pre> <br>  In the examples above, I used MO = Deparse to display the program code. <br><h4>  Examples of single-line programs </h4><br>  <b>Output of the number of lines in the file (similar to Unix wc -l)</b> <br><pre> <code class="perl hljs">perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'}{ print $.'</span></span> abc.txt</code> </pre> <br>  Equivalent program: <br><pre> <code class="perl hljs">LINE: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">defined</span></span>($_ = &lt;ARGV&gt;)) { (); } { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $.; }</code> </pre><br>  The tricky trick "} {" is used here.  We ourselves have closed the cycle. <br><br>  <b>Binary number output</b> <br><pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"printf '%b', shift"</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  <b>Replace \ r \ n with \ n in the file</b> <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">'s/\r\n/\n/'</span></span> file.txt</code> </pre> <br>  <i>Note</i>  For some reason, this code does not work in Windows: it stubbornly adds \ r \ n, I did binmode ARGV, <br>  binmode $ ARGV, binmode * ARG {FILEHANDLE}, but nothing helped, I will continue to fight.  I would be grateful if you write how to replace \ r \ n with \ n in Windows. <br><br>  <b>Conversion of IP addresses from the form of "digit-point" in the number:</b> <br><pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"print unpack('N', pack('C4', split /\./, shift))"</span></span> <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <b>Deleting .svn folders in the current folder and its subfolders (recursively)</b> <br><pre> <code class="perl hljs">perl -MFile::Find -MCwd -e <span class="hljs-string"><span class="hljs-string">'$path = getcwd;finddepth(sub {print $File::Find::name."\n"}, "$path")'</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> <span class="hljs-string"><span class="hljs-string">'\.svn$'</span></span> | perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">'system("rm -rf $_")'</span></span>;</code> </pre> <br>  same for Windows: <br><pre> <code class="perl hljs">perl -MFile::Find -e <span class="hljs-string"><span class="hljs-string">"finddepth(sub{ print $File::Find::name . \"\n\"; }, '.')"</span></span> | perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">"print if /.svn$/"</span></span> | perl -pe <span class="hljs-string"><span class="hljs-string">"s|/|\\|g"</span></span> | perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">"system(\"rd /s /q $_\");"</span></span></code> </pre> <br>  <b>Output IP address in hexadecimal</b> <br><pre> <code class="perl hljs">perl -e <span class="hljs-string"><span class="hljs-string">"printf '%02x' x 4, split /\./, shift"</span></span> <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <b>Adding the line "#! / Usr / bin / perl" to the beginning of the file</b> <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">"print \"#!/usr/bin/perl\n\" if $. == 1"</span></span> abc.pl</code> </pre> <br>  For Linux / Unix: <br><pre> <code class="perl hljs">perl -i.bak -pe <span class="hljs-string"><span class="hljs-string">'print "#!/usr/bin/perl\n" if $. == 1'</span></span> abc.pl</code> </pre> <br><h4>  Why is this necessary? </h4><br>  As promised I will write, why all this is necessary.  You can say that there is find, awk, grep, sed, why is single-line Perl? <br><br>  Well, firstly, in Windows, by default, there is no grep and awk.  Yes, of course, it is faster to use grep to select lines, but what if you need to do a little more, for example, rename a file?  You will say there is, after all, find, yes there is.  So what do I say in defense of the single-line pearl? <br><br>  Here's what: <br><br>  First, if you program in Perl, you remember Perl very well and you can immediately start writing a one-line program without looking at man.  (At first, however, it may be a little unusual, but when you get involved it will be easy) <br><br>  Secondly, it is often convenient to use Perl.  For example, when I want to have an awk equivalent (see the -a flag) with Perl power (for example, I want to use the pack, unpack, or regular Perl expression functions in a one-line program) <br><br>  Thirdly, <br>  Perl is a powerful language.  A single-line perl program is a regular Perl program, only on the command line.  So one-line programs for pearl can be used for a variety of tasks!  (But I think, it‚Äôs probably better not to write long one-line programs, it‚Äôs better to make a regular pearl-barley script). <br><br><h4>  Conclusion </h4><br>  Do not think only that I urge to abandon grep, find, sed or awk.  I do not call!  I myself continue to use grep, find.  I just wanted to talk about another useful tool as a ‚Äúsingle-line pearl‚Äù, which is convenient for Perl programmers, because: 1) you don't need to read man (you already remember everything), 2) the power of Perl is used <br><br>  Thanks for attention.  Those who are interested send here: <br><br>  perldoc.perl.org/perlrun.html - perldoc, description of all flags. <br>  <a href="http://sial.org/howto/perl/one-liner/">sial.org/howto/perl/one-liner</a> - various examples <br><br>  I advise you to google pearl barley single-line programs with the word: one-liners <br><br>  <b>Update:</b> <br>  To replace \ r \ n with \ n in Windows, you just need to write: <br><pre> <code class="perl hljs">perl -i.bak -ple <span class="hljs-string"><span class="hljs-string">"s/\r|\n//g;binmode ARGVOUT"</span></span> file.txt</code> </pre> <br>  Respect <a href="http://habrahabr.ru/users/antonshcherbinin/" class="user_link">AntonShcherbinin</a> <br><br>  <b>Update:</b> <br>  Added to the code from AntonShcherbinin, " <b>s / \ r | \ n // g;</b> ", and then in Linux just binmode does not roll, now this code is universal: it works in Windows and Linux. <br><br>  <b>Update (August 26, 2012):</b> <br>  Rewrote code examples under &lt;source lang = "Perl"&gt; &lt;/ source&gt; tags </div><p>Source: <a href="https://habr.com/ru/post/70610/">https://habr.com/ru/post/70610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../70595/index.html">GWT 1.7.1 release fixes Mac OS X Snow Leopard issues</a></li>
<li><a href="../70601/index.html">Transform blood into light</a></li>
<li><a href="../70602/index.html">TeamWox - a gift to small business!</a></li>
<li><a href="../70607/index.html">Moscow: in public institutions incandescent bulbs will be replaced with energy-saving</a></li>
<li><a href="../70608/index.html">Which virtualization system is better?</a></li>
<li><a href="../70614/index.html">Consumer Expert Social Network</a></li>
<li><a href="../70615/index.html">On a heuristic method for detecting viral injections on sites</a></li>
<li><a href="../70616/index.html">Creating an installer using WiX. Part 3</a></li>
<li><a href="../70617/index.html">Consumer Expert Social Network</a></li>
<li><a href="../70618/index.html">Ideal university</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>