<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing the undo / redo model for a complex document</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! In this article I want to show how you can organize a model for editing a document with a complex structure with the possibility of undo / re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing the undo / redo model for a complex document</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi Habr!  In this article I want to show how you can organize a model for editing a document with a complex structure with the possibility of undo / redo actions. </p><br><h2 id="predystoriya-i-problematika">  Background and Issues </h2><br><p>  It all started with the fact that I wrote a highly specialized outline-software, where the main idea is to operate a bunch of virtual paper cards on different scenes in different editors. </p><br><p>  It turned out similar to MS Visio with a certain degree of customization and plaginization.  There are no technical difficulties here, but there are a number of features. </p><br><p>  First, there are several scenes.  This means that window editors need several, each of which works by its own rules. </p><br><p>  Secondly, because  a set of cards is one, and the same card can be used in different places, this creates certain dependencies between different parts of the document.  And, if the card is removed, then it entails the elimination of this card from all the places where it is involved. </p><br><p>  Thirdly, when I did everything I wanted and showed the results to a friend (who is not even a programmer), he poked and said that it would be nice to do Ctrl + Z.  I got an idea, but it turned out to be not such a trivial task.  In this article I will describe what I came to in the end. </p><a name="habracut"></a><br><h2 id="suschestvuyuschie-resheniya">  Existing solutions </h2><br><p>  Of course, before I did something of my own, I was hoping to find something ready.  A sufficiently detailed analysis of the problems is given in <a href="https://habrahabr.ru/post/306398/">Undo and Redo - analysis and implementation</a> .  However, as it turned out, in addition to general principles and words, it is difficult to find something like a library. </p><br><p>  The first and most obvious solution is to make a version of the document for each change.  Of course, it is reliable, but takes a lot of space and unnecessary operations.  Therefore, this option was dropped immediately. </p><br><p>  More interesting is the <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> .  Here you can already save some resources by using the state of the document, and not the document itself.  But this again, depends on the specific situation.  And since  I wrote everything in C ++, here I would not get any win.  At the same time, there is even a C ++ template project <a href="https://github.com/d-led/undoredo-cpp">undoredo-cpp</a> that implements this pattern. </p><br><p>  <a href="https://en.wikipedia.org/wiki/Command_pattern">Command patter</a> is basically what you need, but unfortunately, you can find only principles, but not universal implementations.  Therefore, he was taken as a basis.  And, of course, I wanted to achieve maximum performance, which resulted in minimizing data storage. </p><br><p>  Thus, it became clear how and what I want to get at the implementation level.  And it turned out to highlight specific goals: </p><br><ol><li>  The system contains a set of editors, each of which can edit its scene. </li><li>  Any change to the document that will affect the open editor should be communicated to it, and the editor himself should respond to it as efficiently as possible (excluding the complete rebuilding of the document's scene). </li><li>  All changes are global, i.e.  Regardless which editor we are in now, the total change stack. </li><li>  It must be possible to both undo the last action, and return (Undo / Redo). </li><li>  The size of the change buffer should not be limited by anything except settings and hardware resources. </li></ol><br><p>  It should also be noted that everything was written in QT5 / C ++ 11. </p><br><h2 id="model-dokumenta">  Document model </h2><br><p>  The main essence on which actions are performed is a <strong>document</strong> .  Various atomic actions can be applied to the document, let's call them <strong>primitives</strong> .  Atomicity assumes that before and after the primitive application the document is in a consistent state. </p><br><p>  In my document, I highlighted the following entities (it should be noted that my software was intended to outline the outline of the script, hence the specificity): card, character, story card (refers to the card), character card (refers to the card), point of the storyline (referenced to the card), storyline (contains a chain of story cards), etc. Thus, entities can refer to each other, and this can be a source of problems in the future if we want to return the action to create a story card that refers to  y, the creation of which we have already rolled back.  Those.  It begs some mechanism for managing links, but about it later. </p><br><p>  When allocating primitives, the following set is obtained: create a card, change the text of the card, delete the card, create a story card, create a storyline, change the text of the storyline, add a card to the storyline, etc. Conceptually, any primitive clearly refers to some to an entity, it means it makes sense to introduce a typification of primitives according to the addressed entity (card, storyline, character, etc.). </p><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">outline_primitive</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entity_t</span></span></span><span class="hljs-class"> {</span></span> card, plot, act_break, outline_card, ...}; ... <span class="hljs-keyword"><span class="hljs-keyword">entity_t</span></span> entity; <span class="hljs-keyword"><span class="hljs-keyword">document_t</span></span> * pDoc; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref_t</span></span> = referenced_entity&lt;outline_primitive&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">ref_t</span></span>*&gt; dependencies; };</code> </pre> <br><p>  Attention should be paid to the dependencies attribute - these are just the dependencies to which the primitive refers, but its purpose will be considered a little later.  Also, primitives can be classified by type: creation;  modification;  deletion. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">operation_t</span></span> { create, modify, <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> }; operation_t operation;</code> </pre><br><p>  At the same time, modifying primitives can generate a whole tree, depending on the permissible modifications - for example, move the card, add a card to the storyline, etc. </p><br><p>  The primitive can be applied either in the forward direction or in the opposite direction.  Moreover, for removing primitives and for assertions, it is useful to store in what state the primitive is applied or rolled back. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> outline_primitive::apply() { perform_check(!applied); applied = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; pDoc-&gt;unsavedChanges = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> outline_primitive::revert() { perform_check(applied); applied = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; pDoc-&gt;unsavedChanges = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applied;</code> </pre><br><p>  Next, consider the implementation of the simplest primitive - adding a card. </p><br><h2 id="realizaciya-prosteyshego-primitiva">  Implementation of the simplest primitive </h2><br><p>  Something like this is the implementation of the card creation primitive.  I will not give obvious routine operations, such as pDoc initialization, etc. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OUTLINE_DOC_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card_create_primitive</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">outline_primitive</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_card</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pCard</span></span></span><span class="hljs-class">;</span></span> index_card::data_t cardData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    card_create_primitive::card_create_primitive(const index_card::data_t &amp; _data); void apply() { <span class="hljs-symbol"><span class="hljs-symbol">_Base:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:apply</span></span>(); auto p_card = new index_card; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   p_card-&gt;data = cardData; pDoc-&gt;cards.push_back(p_card); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   pCard = p_card; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } void revert() { <span class="hljs-symbol"><span class="hljs-symbol">_Base:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:revert</span></span>(); auto it = std::find(pdoc-&gt;cards.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(), pdoc-&gt;cards.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pCard); perform_check(it != pdoc-&gt;cards.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()); <span class="hljs-regexp"><span class="hljs-regexp">//assert</span></span> pDoc-&gt;cards.erase(it); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete pCard; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    pCard = nullptr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       } }</code> </pre><br><p>  Several assertions are specially added to the code, which confirm the consistent state of the document before and after the primitive has been applied. </p><br><h2 id="ssylochnaya-celostnost">  Referential integrity </h2><br><p>  Now consider the primitive creation of a story card.  In fact, this is the same card, but located on the plot sheet and having a coordinate.  Those.  it refers to the story card and contains additional attributes (coordinates). </p><br><p>  Thus, suppose we have a sequence of primitives ‚Äî create a card, create a story card based on it.  Then the 2nd primitive must be referenced to the first one, while providing the possibility of updating the link if it is canceled and restored (with the associated deletion / re-creation of the card itself). </p><br><p>  For this purpose, the special entity referenced_entity is introduced, which you have already met before in the list of dependencies. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">referenced_entity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primitive_t</span></span> = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> entity_ptr = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; referenced_entity(<span class="hljs-keyword"><span class="hljs-keyword">primitive_t</span></span> * prim, entity_ptr * p_ent) { ... prim-&gt;dependencies.push_back(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      } entity_ptr * get() const { if (!parent) return entity; else { auto cur_ref = this; while (cur_ref-&gt;parent) cur_ref = &amp;(cur_ref-&gt;parent-&gt;baseEntity); return cur_ref-&gt;entity; } } primitive_t * parent; entity_ptr * entity; };</span></span></code> </pre><br><p>  Here the important point is to place yourself in the list of dependencies of the primitive.  Thus, if someone already refers to the contents of the referenced_entity, you can reconnect when the primitive is placed in the buffer, and then, based on this connection, get a pointer to the current address of the object using the get () method. </p><br><h2 id="obrabotka-primitivov">  Primitive processing </h2><br><p>  To process the primitive, a special entity is introduced - command_buffer.  Her tasks include: </p><br><ul><li>  storing a sequence of primitives; </li><li>  providing reference links; </li><li>  direct and reverse application of primitives; </li><li>  tail garbage when exceeding the length; </li><li>  event generation </li></ul><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">command_buffer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primitive_id_sequence_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">primitive_t</span></span>*&gt; data; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">primitive_id_sequence_t</span></span>&gt; front; };</code> </pre><br><p>  Data stores primitives in the order in which they are created by the user.  And in front - the so-called front reference objects.  When a new primitive enters the buffer, it enters the last element of the object chain, which is stored in baseEntity.  And then linking occurs. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> command_buffer::submit(primitive_t * new_prim) { discard_horizon(); //      // ,   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp; dep : new_prim-&gt;dependencies) { auto front_it = front.find(dep-&gt;entity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (front_it != front.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()) dep-&gt;reset_parent(data[*front_it-&gt;second.rbegin()]); } unsigned new_id = add_action(new_prim); //  data   //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_prim-&gt;operation == primitive_t::operation_t::<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) { new_prim-&gt;apply(pDoc); primitive_id_sequence_t new_seq; new_seq.push_back(new_id); front.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(make_pair(new_prim-&gt;baseEntity.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), new_seq)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     - ,      { auto front_it = front.find(new_prim-&gt;baseEntity.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (front_it == front.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()) { primitive_id_sequence_t new_seq; new_seq.push_back(new_id); front.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(make_pair(new_prim-&gt;baseEntity.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), new_seq)); new_prim-&gt;apply(pDoc); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { auto &amp; seq = front_it-&gt;second; perform_check(!seq.empty()); seq.push_back(new_id); new_prim-&gt;apply(pDoc); } } }</code> </pre><br><p>  All other buffer methods are fairly trivial, and they also contain undo () and redo ().  Thus, command_buffer provides a consistent state of the document, and the question remains how to maintain the correct state of presentation, formed by the relevant editors. </p><br><h2 id="model-vzaimodeystviya">  Interaction model </h2><br><p>  To do this, you must enter a new entity - the event, and each open editor must correctly respond to the appropriate type of event.  The event is associated with the use of a primitive - before application, after application, before rollback, after rollback.  For example, after applying, you can make a reaction to the creation primitives (since there is still no object before using the object), before rolling back - to the same creation primitives, since  after the rollback, the link will be lost. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primitive_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primitive_t</span></span> = T; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kind_t</span></span></span><span class="hljs-class"> {</span></span>pre_applied, post_applied, pre_reverted, post_reverted}; <span class="hljs-keyword"><span class="hljs-keyword">kind_t</span></span> kind; <span class="hljs-keyword"><span class="hljs-keyword">primitive_t</span></span> * primitive; };</code> </pre><br><p>  These are the events that will be sent after each of the 4x operations on the primitive.  Accordingly, in each editor, you need to make a handler that will react to these events, and, accordingly, miniaturely rebuild the scene. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> my_editor::event_occured(<span class="hljs-keyword"><span class="hljs-keyword">event_t</span></span> * event) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>..<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> }</code> </pre><br><p>  Here you need to make a three-story switch..case in essence, operation and event, and it looks awful.  To do this, use the trick, based on the fact that each of the elements can be converted to an integer, and we introduce such a macro. </p><br><pre> <code class="hljs vhdl">#define PRIMITIVE_EVENT_ID(<span class="hljs-keyword"><span class="hljs-keyword">entity</span></span>, operation, event) ((<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> char)<span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | ((<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> char)operation &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> char)event</code> </pre><br><p>  Then the body of this method will take this form, and it will be possible to add it as new primitives appear, without detriment to the convenience of perception. </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (PRIMITIVE_EVENT_ID(event-&gt;primitive-&gt;entity, event-&gt;primitive-&gt;operation, event-&gt;kind)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PRIMITIVE_EVENT_ID(outline_primitive::entity_t::collision, outline_primitive::operation_t::create, event_t::kind_t::post_applied): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PRIMITIVE_EVENT_ID(outline_primitive::entity_t::collision, outline_primitive::operation_t::remove, event_t::kind_t::post_reverted): { auto p_collision = static_cast&lt;collision_t*&gt;(event-&gt;primitive-&gt;baseEntity.get()); pScene-&gt;create_image(p_collision); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br><p>  True, it should be noted that if the hierarchy of types of the modifying primitive grows for some entity, then inside it is necessary to make new branches. </p><br><h2 id="i-eto-deystvitelno-rabotaet">  And it really works. </h2><br><p>  The described method is not limited to my document model, and can be used in various document models.  If someone is interested to see this in action, then the compiled application itself can be downloaded on the <a href="http://ultraoutliner.com/">ultra_outliner</a> page. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In the framework of the proposed method, one important issue remained unexplored.  Most user actions on documents are indeed atomic, but some of them produce several primitives at once.  For example, if a user moves a card, this is one primitive.  And if he removes a card that is in 3 ways - then these are 3 primitives for excluding the card from the circuit, removing the card from the field, and then removing the card itself.  If such a chain is rolled back, then only one primitive will be rolled out in one rollback operation, while it would be logical to roll back everything at once.  This requires some refinement of the method, but we will consider this problem in the next article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313654/">https://habr.com/ru/post/313654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313642/index.html">Microsoft unveiled an update to its Cognitive Toolkit.</a></li>
<li><a href="../313644/index.html">Familiarity with the Ceph repository in pictures</a></li>
<li><a href="../313646/index.html">List of free transactional, hosting and marketing email-providers</a></li>
<li><a href="../313648/index.html">Machine Learning and Intel Xeon: Tencent In-Game Purchasing Advisory System</a></li>
<li><a href="../313652/index.html">What's New in vSphere 6.5: Security</a></li>
<li><a href="../313656/index.html">UX / UI track program at MBLTdev 16 conference</a></li>
<li><a href="../313658/index.html">Node.js 7.0.0 is released. Meet async / await without babel</a></li>
<li><a href="../313660/index.html">Experience of installing Apple iBeacon & Google Physical Web beacons in the Semenovsky shopping mall in Moscow</a></li>
<li><a href="../313664/index.html">Mobile traffic arbitration: methods and approaches</a></li>
<li><a href="../313666/index.html">Scalable nginx configuration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>