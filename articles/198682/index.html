<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Aho-Korasik Algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the post, I tried to avoid complex definitions and rigorous mathematical proofs, and some things are intuitively clear. The algorith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Aho-Korasik Algorithm</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In the post, I tried to avoid complex definitions and rigorous mathematical proofs, and some things are intuitively clear.  The algorithm is conveniently divided into interconnected parts, therefore, to grasp the principle of its operation should not be difficult. <br><br><h2>  Initial description </h2><br>  The Aho-Korasik algorithm implements an efficient search for all occurrences of all sample lines in a given string.  It was developed in 1975 by <a href="http://en.wikipedia.org/wiki/Alfred_V._Aho">Alfred Aho</a> and Margaret Corasic. <br>  We formally describe the condition of the problem.  Several lines of pattern [i] and string s come to the input.  Our task is to find all possible occurrences of pattern [i] lines in s. <br><br>  The essence of the algorithm lies in the use of a <b>boron</b> data structure and the construction of a <b>finite deterministic automaton</b> on it.  It is important to remember that the task of searching for substrings in strings is trivially implemented in quadratic time, so for effective work it is important that all parts of Aho-Korasika do not asymptotically exceed the line in relation to the length of the lines.  We will return to the assessment of complexity at the end, but for now let's take a closer look at the components of the algorithm. <br><a name="habracut"></a><br><h2>  Build on a set of sample strings </h2><br><h3>  Boron structure </h3><br>  What is boron?  Strictly speaking, boron is a tree in which each vertex denotes a string (the root denotes the zero string - Œµ).  On the edges between the vertices, 1 letter is written (this is its fundamental difference with <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">suffix trees</a> , etc.), so getting along the edges from the root to some vertex and contangling the letters from the edges in traversal order, we get the line corresponding to this vertex .  From the definition of boron as a tree, the uniqueness of the path between the root and any vertex also follows; therefore, each vertex corresponds to exactly one row (we will identify the vertex and the string it denotes). <br>  We will build boron by adding source lines sequentially.  Initially, we have 1 vertex, the root (root) is the empty string.  Adding a line is as follows: starting at the root, we move through our tree, each time choosing the edge corresponding to the next letter of the line.  If there is no such edge, then we create it along with the vertex.  Here is an example of a built-up bur for the lines: 1) acab, 2) accc, 3) acac, 4) baca, 5) abb, 6) z, 7) ac. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e1f/635/f14/e1f635f14384bac617db2a9ef839e7b5.png" alt="image"><br>  <sup><i>(Fig. 1)</i></sup> <br><br>  Note the addition of row 7. It does not create new vertices and edges, and the process of adding it stops at the inner vertex.  This shows that for each line it is necessary to additionally store a sign that it is a line from the condition or not (red circles). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/4e3/3ae/72b4e33ae76976c7d7f16d605dc69b6e.png" alt="image"><br>  <sup><i>(Fig. 2)</i></sup> <br><br>  Note also that two strings in boron have common edges, provided they have a common prefix.  Extreme case - all the line samples in pairs do not have the same initial part.  So the upper estimate for the number of vertices in boron is the sum of the lengths of all rows + 1 (root). <br><br><h3>  Implementation </h3><br>  We will store bor as an array of vertices, where each vertex has its own unique number, and the root has a zero value (root = 0).  Possible description of the vertex structure: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//k -   struct bohr_vrtx{ int next_vrtx[k],pat_num; bool flag; };</span></span></code> </pre> <br><br>  next_vrtx [i] is the number of the vertex to which we will arrive at the symbol with the number i in the alphabet, flag is the bit indicating whether our vertex is the original line, pat_num is the number of the sample line denoted by this vertex. <br>  Preferring the lengths of all added rows - extra memory overhead.  We will use the data structure from STL - vector.  In it, memory is allocated dynamically, therefore the additional costs will be zero.  Explicitly, the procedure for adding a string follows (we use the 26-letter lowercase Latin alphabet =&gt; k = 26). <br><br><div class="spoiler">  <b class="spoiler_title">Functions to create a new vertex and initialize boron:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;bohr_vrtx&gt; bohr; <span class="hljs-function"><span class="hljs-function">bohr_vrtx </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_bohr_vrtx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ bohr_vrtx v; <span class="hljs-comment"><span class="hljs-comment">//(255)=(2^8-1)=(     )=(-1     4-  int) memset(v.next_vrtx, 255, sizeof(v.next_vrtx)); v.flag=false; return v; } void bohr_ini(){ //   -  bohr.push_back(make_bohr_vrtx()); }</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">The procedure for adding a sample string to boron:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_string_to_bohr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   for (int i=0; i&lt;s.length(); i++){ char ch=s[i]-'a'; //    if (bohr[num].next_vrtx[ch]==-1){ //-1 -    bohr.push_back(make_bohr_vrtx()); bohr[num].next_vrtx[ch]=bohr.size()-1; } num=bohr[num].next_vrtx[ch]; } bohr[num].flag=true; pattern.push_back(s); bohr[num].pat_num=pattern.size()-1; }</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Check the presence of a string in boron:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_string_in_bohr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;s.length(); i++){ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch=s[i]-<span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bohr[num].next_vrtx[ch]==<span class="hljs-number"><span class="hljs-number">-1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } num=bohr[num].next_vrtx[ch]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br><br><h2>  Construction of the machine on the forest </h2><br><h3>  Description of the principle of operation </h3><br>  Our task is to build a finite deterministic automaton.  What a thing this can be seen <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">here</a> .  In short, the state of the automaton is some kind of vertex of boron.  The transition from the state is carried out by 2 parameters - the current vertex v and the symbol ch.  on which we need to move from this top.  More specifically, it is necessary to find the vertex u, which denotes the longest string, consisting of the suffix string v (possibly zero) + character ch.  If there is no such thing in boron, then we go to the root. <br><br>  Why do we need this?  Suppose we can calculate such a vertex quickly, in constant time.  Suppose that we are standing at a certain vertex of a boron corresponding to the substring [i..j] of the string s, the entry into which we are looking for.  Now we find all the lines of boron, the suffixes s [i..j].  It is argued that they can be searched quickly (described below).  After that, we simply move from the state of the automaton v to the state u by the symbol s [j + 1] and continue the search. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/f22/8ab/8def228ab5a906028cb6ec049208b3e4.png" alt="image"><br>  <sup><i>(Fig. 3)</i></sup> <br>  To implement the automaton, we need the notion of a suffix link from a vertex. <br><br><h3>  Suffix Links </h3><br>  Let us call a suffix reference of a vertex v a pointer to a vertex u, such that the string u is the largest proper suffix of the string v, or, if there is no such vertex in boron, then a pointer to the root.  In particular, the link from the root leads to it.  We will need suffix links for each vertex in boron, so we slightly change the vertex structure and vertex creation procedure by entering the additional variable suff_link. <br><div class="spoiler">  <b class="spoiler_title">Code changes:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bohr_vrtx</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">//... int suff_link; //suff_link -   }; bohr_vrtx make_bohr_vrtx(){ bohr_vrtx v; //... v.suff_link=-1; // - .   return v; }</span></span></code> </pre><br></div></div><br><br>  Here is an example of the placement of suf.  links for boron in fig.  one: <br><img src="https://habrastorage.org/getpro/habr/post_images/98a/51e/d27/98a51ed27cb769a976bdfe995c009a25.png" alt="image"><br>  <sup><i>(Fig. 4)</i></sup> <br><br><h3>  Implementation of the machine </h3><br>  Let us return to the problem of fast transition between states of the automaton.  Obviously, all possible transitions exist bohr.size () * k, since for each possible vertex and each possible symbol in the alphabet you need to know the transition.  Pre-counting significantly reduces the average operation time of the algorithm, so we will use the ideas of lazy dynamics - we will consider them as necessary and memorize the values ‚Äã‚Äãalready counted. <br>  We introduce a computed function for the transition (v, ch).  The idea here is this: if from the current vertex there is an edge with the symbol ch, then we go through it, otherwise we will follow the suffix link and start recursively from the new vertex.  Why it works is not difficult to guess. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1c/737/6d7/f1c7376d7df82db9606200e26245827f.png" alt="image"><br>  <sup><i>(Fig. 5)</i></sup> <br><br>  The only question is the correct receipt of suf.  links from the top.  In this task, you can also use lazy dynamics.  The heuristic is as follows: to get suf.  links of the vertex v (strings s [i..j]) go down to its ancestor par, go through suf.  link par and run the transition from the current vertex t on the symbol symb, which is written on the edge from par to v.  Obviously, we first get to the largest suffix s [i..j-1] such that it has an edge with the symbol symb, then we will go along this edge.  By definition, the resulting vertex is a suffix link from the vertices of v. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fed/d2f/6d1/fedd2f6d10928119cf7d4889f0e5942e.png" alt="image"><br>  <sup><i>(Fig. 6)</i></sup> <br><br>  So, it is clear that the functions of obtaining a suffix link and transition from the state of the automaton are interrelated.  Their convenient implementation represents 2 functions, each of which recursively calls the other.  The base of both recursions is suf.  a link from the root or from the son of the root leads to the root. <br><br><div class="spoiler">  <b class="spoiler_title">To begin with, we will change the vertex structure and the procedure for creating a new vertex:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bohr_vrtx</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">//... int auto_move[k],par; //auto_move -   , par - -   char symb; //    par    }; bohr_vrtx make_bohr_vrtx(int p,char c){ //         bohr_vrtx v; //... memset(v.auto_move, 255, sizeof(v.auto_move)); v.par=p; v.symb=c; return v; }</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Full implementation of the automaton requires the pre-declaration of one of the functions:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_auto_move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_suff_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bohr[v].suff_link==<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    if (v==0||bohr[v].par==0) // v -    v -  bohr[v].suff_link=0; else bohr[v].suff_link=get_auto_move(get_suff_link(bohr[v].par), bohr[v].symb); return bohr[v].suff_link; } int get_auto_move(int v, char ch){ if (bohr[v].auto_move[ch]==-1) if (bohr[v].next_vrtx[ch]!=-1) bohr[v].auto_move[ch]=bohr[v].next_vrtx[ch]; else if (v==0) bohr[v].auto_move[ch]=0; else bohr[v].auto_move[ch]=get_auto_move(get_suff_link(v), ch); return bohr[v].auto_move[ch]; }</span></span></code> </pre><br></div></div><br><br><h2>  Identifying "good" suffix links </h2><br>  With the automaton, it is easy to determine the algorithm itself: we read the string, move from state to state by the characters of the line, in each state we move in suf.  references, that is, by the suffixes of the string in the position of the machine, while checking their presence in boron. <br>  Everything would be fine, but it turns out that this variant of Aho-Korasika has quadratic asymptotics with respect to N ‚Äî the length of the readable string s.  Indeed, for a string from state v, you can find v.length () suffixes, and the transition from states can simply increase by 1 the length of this string.  Tzimes is to move along suf.  links fall only in the known among the sample lines.  We introduce the concept of "good" suf.  links suff_flink.  So, bohr [v] .suff_flink is the closest suffix in a boron for which flag = true.  The number of "jumps" in the use of such links will decrease and will be proportional to the number of the required entries ending in this position. <br><br><img src="https://habrastorage.org/storage3/667/3ce/437/6673ce437a3c703250a688e366d6d930.png" alt="image"><br>  <sup><i>(Fig. 7)</i></sup> <br><br><div class="spoiler">  <b class="spoiler_title">Again, the boy will change the structure of the vertex and the procedure for adding:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bohr_vrtx</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">//... int suff_flink; //suff_flink - "" .  }; bohr_vrtx make_bohr_vrtx(int p,char c){ bohr_vrtx v; //... v.suff_flink=-1; return v; }</span></span></code> </pre><br></div></div><br><br>  Calculate them is quite simple, all the same lazy dynamics.  We introduce the function of counting ‚Äúgood‚Äù suf.  links.  If for the top by suf.  flag = true, then this is the desired vertex, otherwise recursively run from the same vertex. <br><br><div class="spoiler">  <b class="spoiler_title">The calculation is good suf.</b>  <b class="spoiler_title">references:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_suff_flink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bohr[v].suff_flink==<span class="hljs-number"><span class="hljs-number">-1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=get_suff_link(v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (u==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// v - ,  .  v    bohr[v].suff_flink=0; else bohr[v].suff_flink=(bohr[u].flag)?u:get_suff_flink(u); } return bohr[v].suff_flink; }</span></span></code> </pre><br></div></div><br><br><h2>  The implementation of the search on the machine </h2><br>  The search is trivial.  We will need a procedure for walking on the "good" suf.  links check (v, i) from the current position of the automaton v given that this position ends in the i-th letter in the word s. <br><br><div class="spoiler">  <b class="spoiler_title">check (v, i)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=v;u!=<span class="hljs-number"><span class="hljs-number">0</span></span>;u=get_suff_flink(u)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bohr[u].flag) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;i-pattern[bohr[u].pat_num].length()+<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">" "</span></span>&lt;&lt;pattern[bohr[u].pat_num]&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Here is the search itself:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_all_pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;s.length();i++){ u=get_auto_move(u,s[i]-<span class="hljs-string"><span class="hljs-string">'a'</span></span>); check(u,i+<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Here is an example of work:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> bohr_ini(); add_str_to_bohr(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>); add_str_to_bohr(<span class="hljs-string"><span class="hljs-string">"bcdc"</span></span>); add_str_to_bohr(<span class="hljs-string"><span class="hljs-string">"cccb"</span></span>); add_str_to_bohr(<span class="hljs-string"><span class="hljs-string">"bcdd"</span></span>); add_str_to_bohr(<span class="hljs-string"><span class="hljs-string">"bbbc"</span></span>); find_all_pos(<span class="hljs-string"><span class="hljs-string">"abcdcbcddbbbcccbbbcccbb"</span></span>);</code> </pre><br><br>  Run: <br>  1 abc <br>  2 bcdc <br>  6 bcdd <br>  10 bbbc <br>  13 cccb <br>  16 bbbc <br>  19 cccb <br></div></div><br><br><h2>  Estimation of complexity and storage methods </h2><br>  The existing variant of the algorithm is looped along the length of s (N = s.length ()), from where it can already be evaluated as O (N * O (check)), but since check jumps only over obviously marked vertices for which flag = true , then the total asymptotic behavior can be estimated as O (N + t), where t is the number of all possible occurrences of all sample strings in s.  To be precise and take into account the calculations of the automaton and suf.  links, the algorithm works O (M * k + N + t), where M = bohr.size ().  Memory - constant arrays of size k for each vertex of boron, from where the estimate O (M * k) results. <br><br>  It turns out that another way of storing, and specifically, referring to the alphabet, is capable of changing this assessment.  We will use the map map &lt;char, int&gt; instead of an array.  We read <a href="http://en.cppreference.com/w/cpp/container/map">here</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE-%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">here</a> , we see that the map data structure from STL is implemented by a red-and-black tree, and the time for accessing its elements is proportional to the logarithm of the number of elements.  In our case, the binary logarithm of the size of the alphabet k (which is practically a constant).  The total time is O ((M + N) * log k + t).  In practice, this is much faster than an array.  Map does not store unnecessary memory cells for elements at all, so the memory is proportional to the number of edges in a boron (and therefore the number of vertices in a boron, because in a tree with M vertices there are M-1 edges).  The number of transition calculations for an automaton is obviously proportional to the length of the string.  The resulting estimate is O (M + N). <br><br><table><tbody><tr><td></td><td>  Option with arrays next_vrtx [k], auto_move [k] </td><td>  Option with red-black tree map &lt;char, int&gt; </td></tr><tr><td>  Time complexity </td><td>  O (M * k + N + t) </td><td>  O ((M + N) * log k + t) </td></tr><tr><td>  Space complexity </td><td>  O (M * k) </td><td>  O (M + N) </td></tr></tbody></table><br><br>  <sub><b>PS</b> : Here is a link to a fully implemented working algorithm: <a href="http://pastebin.com/cRqnPZyC">Aho-Corasick alg</a></sub> . </div><p>Source: <a href="https://habr.com/ru/post/198682/">https://habr.com/ru/post/198682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198666/index.html">IndexedDB - unlimited data storage</a></li>
<li><a href="../198668/index.html">QIWI and the new REST protocol in the examples</a></li>
<li><a href="../198672/index.html">How to start making the engine control unit from scratch</a></li>
<li><a href="../198674/index.html">Budget TimeLapse Slider do it yourself</a></li>
<li><a href="../198680/index.html">Pavel Durov's speech at the GMIC conference in San Francisco - the first public appearance of the VK founder and Telegram in Silicon Valley</a></li>
<li><a href="../198684/index.html">Step-by-step guide on binding SIP-numbers to Elastix (FreePBX, Asterisk) on the example of the provider Megaline iDPhone</a></li>
<li><a href="../198688/index.html">New concept of using VoIP on the example of Wi-Fi IP-phone Escene WS220-N</a></li>
<li><a href="../198690/index.html">Dropbox-light or my desktop on the Internet</a></li>
<li><a href="../198692/index.html">FAVORaim: we are starting to build a neural network and analyze the interests of users</a></li>
<li><a href="../198694/index.html">Delegates and events in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>