<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elm. Comfortable and awkward. Json.Encoder and Json.Decoder</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to talk about Elm 0.18 . 


 Elm. Comfortable and awkward 
 Elm. Comfortable and awkward. Composition 
 Elm. Comfortable and awkward. Http...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elm. Comfortable and awkward. Json.Encoder and Json.Decoder</h1><div class="post__text post__text-html js-mediator-article"><p>  We continue to talk about <a href="http://elm-lang.org/">Elm 0.18</a> . </p><br><p>  <a href="https://habr.com/post/424215/">Elm.</a>  <a href="https://habr.com/post/424215/">Comfortable and awkward</a> <br>  <a href="https://habr.com/post/424341/">Elm.</a>  <a href="https://habr.com/post/424341/">Comfortable and awkward.</a>  <a href="https://habr.com/post/424341/">Composition</a> <br>  <a href="https://habr.com/post/424979/">Elm.</a>  <a href="https://habr.com/post/424979/">Comfortable and awkward.</a>  <a href="https://habr.com/post/424979/">Http, Task</a> </p><br><p>  In this article we will consider the issues of encoders / decoders. </p><br><p>  Decoders / Encoders are used for: </p><br><ol><li>  conversion of responses from third-party resources (Http, WebSocket, etc.); </li><li>  port interactions.  In more detail about ports and the native code I will tell in the following articles. </li></ol><a name="habracut"></a><br><p>  As described earlier, Elm requires us to convert external data into internal application types.  The <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode">Json.Decode</a> module is responsible for this process.  Reverse process - <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Encode">Json.Encode</a> . </p><br><p>  The type that defines decoding rules is <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode">Json.Decode.Decoder a</a> .  This type is parameterized by the user type and determines how to get the user type a from the JSON object. </p><br><p>  For the encoder, only the result type is <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Encode">defined</a> - <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Encode">Json.Encode.Value</a> . </p><br><p>  Consider examples for the type UserData. </p><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Decoder for receiving user data: </p><br><pre> <code class="hljs pgsql">decodeUserData : <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.Decoder UserData decodeUserData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map3 UserData (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “id” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.int) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “<span class="hljs-type"><span class="hljs-type">name</span></span>” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) (<span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.field “email” <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.string) encodeUserData : UserData -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> encodeUserData userData = <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ ( “id”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.int userData.id) , ( “<span class="hljs-type"><span class="hljs-type">name</span></span>”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.name) , ( “email”, <span class="hljs-type"><span class="hljs-type">Json</span></span>.Encode.string userData.email) ]</code> </pre> <br><p>  The Json.Decode.map3 function accepts a UserData type constructor.  Next, three type decoders are transmitted according to the order in which they are declared in the UserData user type. </p><br><p>  The decodeUserData function can be used in conjunction with the Json.Decode.decodeString or Json.Decode.decodeValue functions.  <a href="">Example of use</a> from previous articles. </p><br><p>  The encodeUserData function encodes a custom type into a Json.Encode.Value type, which can be sent out.  By simple, Json.Encode.Value corresponds to a JSON object. </p><br><p>  Simple options are described in the documentation, they can be studied without much difficulty.  Let's look at life situations that require some finger dexterity. </p><br><h2 id="dekodery-union-tipov-ili-diskriminatory-tipov">  Union type decoders or type discriminators </h2><br><p>  Suppose we have a catalog of goods.  And each product can have an arbitrary number of attributes, each of which is of the type one of the set: </p><br><ol><li>  integer; </li><li>  line; </li><li>  enumerated.  Assumes a choice of one of the valid values. </li></ol><br><p>  JSON object is of the following form: </p><br><pre> <code class="hljs objectivec">{ “<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “name”: “Product name”, “price”: <span class="hljs-number"><span class="hljs-number">1000</span></span>, “attributes”: [ { “<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “name”: “Length”, “unit”: “meters”, “value”: <span class="hljs-number"><span class="hljs-number">100</span></span> }, { “<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “name”: “Color”, “unit”: “”, “value”: { “<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “label”: “red” } },... ] }</code> </pre> <br><p>  The remaining possible types will not be considered, working with them is similar.  Then a custom item type would have the following description: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Product = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , price: <span class="hljs-type"><span class="hljs-type">Int</span></span> , attributes: Attributes } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Attributes = List <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , <span class="hljs-type"><span class="hljs-type">name</span></span>: String , unit: String , <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: AttributeValue } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AttributeValue = IntValue <span class="hljs-type"><span class="hljs-type">Int</span></span> | StringValue String | EnumValue Enum <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Enum = { id: <span class="hljs-type"><span class="hljs-type">Int</span></span> , label: String }</code> </pre> <br><p>  Lightly discuss the types described.  There is a product (Product) that contains a list of attributes / characteristics (Attributes).  Each attribute (Attribute) contains an identifier, a name, a dimension, and a value.  An attribute value is described as a union type, one for each type of characteristic value.  The Enum type describes one value from the allowed set and contains: an identifier and a human readable value. </p><br><p>  Description of the decoder, the prefix Json.Decode omitted for brevity: </p><br><pre> <code class="hljs cpp">decodeProduct : Decoder Product decodeProduct = map4 Product (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “price” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “attributes” decodeAttributes) decodeAttributes : Decoder Attributes decodeAttributes = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> decodeAttribute decodeAttribute : Decoder Attribute decodeAttribute = map4 Attribute (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “name” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “unit” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field “value” decodeAttributeValue) decodeAttributeValue : Decoder AttributeValue decodeAttributeValue = oneOf [ <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> IntValue <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> StringValue <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> EnumValue decodeEnumValue ] decodeEnumValue : Decoder Enum decodeEnumValue = map2 Enum (field “id” <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (field “label” <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)</code> </pre> <br><p>  The whole trick is contained in the decodeAttributeValue function.  Using the Json.Decode.oneOf function, all valid decoders for an attribute value are searched.  In case of successful decompression by one of the decoders, the value is tagged with the corresponding tag from the AttributeValue type. </p><br><p>  The encoding of the Product type can be performed using the Json.Encode.object function, to which the encoded type attributes will be passed.  It is worth paying attention to the coding of the AttributeValue type.  In accordance with the previously described JSON object, the encoder can be described as, the prefix Json.Encode is omitted for brevity: </p><br><pre> <code class="hljs cs">encodeAttributeValue : AttributeValue -&gt; Value encodeAttributeValue attributeValue = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> attributeValue of IntValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> StringValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> EnumValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> [ (“id”, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.id) , (“id”, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.label) ]</code> </pre> <br><p>  As you can see, we compare the type options and use the appropriate encoders. </p><br><p>  Let's change the description of attributes and define them using a type discriminator.  The attribute JSON object, in this case, would look like this: </p><br><pre> <code class="hljs pgsql">{ “id”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “<span class="hljs-type"><span class="hljs-type">name</span></span>”: “<span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>”, “<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>”: “<span class="hljs-type"><span class="hljs-type">int</span></span>”, “value_int”: <span class="hljs-number"><span class="hljs-number">1</span></span>, “value_string”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_id”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, “value_enum_label”: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br><p>  In this case, the type discriminator is stored in the type field and determines in which field the value is stored.  Such a description structure is probably not the most convenient, but often encountered.  Whether it is worth changing the type description for this JSON object is probably not worth it; it is better to keep the types in a convenient form for internal use.  In this case, the description of the decoder may be as follows: </p><br><pre> <code class="hljs vhdl">decodeAttribute2 : Decoder <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> decodeAttribute2 = field <span class="hljs-string"><span class="hljs-string">"type"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; andThen decodeAttributeValueType |&gt; andThen (\attributeValue -&gt; map4 <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span> (field <span class="hljs-string"><span class="hljs-string">"id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (field <span class="hljs-string"><span class="hljs-string">"unit"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) (succeed attributeValue) ) decodeAttributeValueType : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Decoder AttributeValue decodeAttributeValueType valueType = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> valueType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_int"</span></span> int |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> IntValue <span class="hljs-string"><span class="hljs-string">"string"</span></span> -&gt; field <span class="hljs-string"><span class="hljs-string">"value_string"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> StringValue <span class="hljs-string"><span class="hljs-string">"enum"</span></span> -&gt; map2 Enum (field <span class="hljs-string"><span class="hljs-string">"value_enum_id"</span></span> int) (field <span class="hljs-string"><span class="hljs-string">"value_enum_label"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) |&gt; Json.Decode.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span> EnumValue _ -&gt; Json.Decode.fail <span class="hljs-string"><span class="hljs-string">"Unknown attribute type"</span></span></code> </pre> <br><p>  In the decodeAttribute2 function, we first decode the discriminator; in case of success, we decode the attribute value.  Next, we decode the remaining fields of the Attribute type, and specify the previously obtained value as the value of the value field. </p><br><p>  <a href="">Source code decoder</a> . </p><br><h2 id="chastichnoe-obnovlenie-tipa">  Partial type update </h2><br><p>  There are cases when the API does not return the entire object, but only a part of it.  For example, when registering to view or change the status of the object.  In this case, in the message it is more convenient to immediately receive the updated object, and to hide all manipulations behind the decoder. </p><br><p>  For example, take the same product, but add a status field to it and process the request to close the product. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> alias </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Attributes</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } decodeUpdateStatus : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Decoder</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> decodeUpdateStatus product = field “status” int |&gt; andThen (\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">succeed</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">product</span></span></span><span class="hljs-class"> | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newStatus</span></span></span><span class="hljs-class">} )</span></span></code> </pre> <br><p>  Or you can use the Json.Decode.map function. </p><br><pre> <code class="hljs erlang-repl">decodeUpdateStatus : Product -&gt; Decoder Product decodeUpdateStatus product = field “status” int |&gt; map (\newStatus -&gt; { product | status = newStatus} )</code> </pre> <br><h2 id="data-i-vremya">  date and time </h2><br><p>  We will use the Date.fromString function, which is implemented using a Date type constructor. </p><br><pre> <code class="hljs pgsql">decodeDateFromString : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromString = string |&gt; andThen (\stringDate -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromString stringDate <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Ok <span class="hljs-type"><span class="hljs-type">date</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.succeed <span class="hljs-type"><span class="hljs-type">date</span></span> Err reason -&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.fail reason )</code> </pre> <br><p>  If the Timestamp is used as the date / time representation, then the decoder in general can be described as: </p><br><pre> <code class="hljs pgsql">decodeDateFromTimestamp : Decoder <span class="hljs-type"><span class="hljs-type">Date</span></span>.Date decodeDateFromTimestamp = oneOf [ <span class="hljs-type"><span class="hljs-type">int</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map toFloat , <span class="hljs-type"><span class="hljs-type">float</span></span> ] |&gt; <span class="hljs-type"><span class="hljs-type">Json</span></span>.Decode.map <span class="hljs-type"><span class="hljs-type">Date</span></span>.fromTime</code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424437/">https://habr.com/ru/post/424437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424427/index.html">Roskomnadzor and Telegram bots through a proxy</a></li>
<li><a href="../424429/index.html">Science Art and Sound: 4 impressive projects</a></li>
<li><a href="../424431/index.html">Valve has introduced a rating of game controllers used in Steam</a></li>
<li><a href="../424433/index.html">What for the hackers Mikrotik and how I hid 100 thousand. RouterOS from the botnet</a></li>
<li><a href="../424435/index.html">Zoo on Nefteburovoy: we bring order</a></li>
<li><a href="../424441/index.html">What's new in the first CTP edition of SQL Server 2019</a></li>
<li><a href="../424443/index.html">Vivaldi 2.0 in our favor</a></li>
<li><a href="../424445/index.html">Translation of Neil Ford's article "Microservices as an Evolutionary Architecture"</a></li>
<li><a href="../424447/index.html">Pascal-style Lisp or 8501st programming language</a></li>
<li><a href="../424453/index.html">Learn OpenGL. Lesson 6.2 - Physically-Based Rendering. Analytical light sources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>