<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DoubleArrayList is a universal implementation of java.util.List</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I thought. that there is no excuse for using java.util.LinkedList as a java.util.List implementation. But something made me look for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DoubleArrayList is a universal implementation of java.util.List</h1><div class="post__text post__text-html js-mediator-article"> Not so long ago, I thought.  that there is no excuse for using <code>java.util.LinkedList</code> as a <code>java.util.List</code> implementation.  But something made me look for him.  Let's see.  Any competent Java specialist knows that <code>java.util.ArrayList</code> should be used when we need fast access by index, and <code>java.util.LinkedList</code> if we need to insert or delete items in the middle of the list.  Not many of them guess that if we insert or delete elements in the middle of the list with the <code>remove(int index)</code> and <code>add(int index, E element)</code> methods, then searching for the desired element will take an average time proportional to the size of the <code>O(N)</code> list. .  So when does the <code>java.util.LinkedList</code> benefit come about? <br><a name="habracut"></a><br>  When using iterators.  More precisely, when you delete or insert elements through <code>java.util.ListIterator</code> .  In the end, in search of justification, I found a very real example of code in which <code>java.util.LinkedList</code> gives a significant advantage over <code>java.util.ArrayList</code> .  This is the simplest filtering algorithm that removes all elements from the list that do not satisfy the specified condition. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Iterator&lt;E&gt; i = list.iterator(); i.hasNext(); ) { E val = i.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition(val)) { i.remove(); } }</code> </pre> <br><br>  The same code can be easily rewritten using an additional list, and then the algorithm with <code>java.util.ArrayList</code> , at least, will not have a quadratic dependence on the original size. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs">List&lt;E&gt; list1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;E&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Iterator&lt;E&gt; i = list.iterator(); i.hasNext(); ) { E val = i.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition(val)) { list1.add(val); } } list.clear(); list.addAll(list1);</code> </pre> <br><br>  But it is not correct that the data structures dictate the algorithm to us.  But it was this algorithm that suggested me how to create a list that most operations will perform in <code>O(1)</code> . <br><br>  To do this, we need an assumption: ‚ÄúThe insert and delete operations occur side by side.‚Äù Of course, we can imagine a situation in which the insert and delete operations will occur randomly, but in this case neither <code>java.util.ArrayList</code> nor <code>java.util.ArrayList</code> will save us <code>java.util.LinkedList</code> that we fight.  After all, to add or remove an arbitrary <code>java.util.ArrayList</code> element should generally shift the number of elements in the array proportional to the size of O (N), and <code>java.util.LinkedList</code> should find it <code>O(N)</code> . <br><br>  The idea is as follows.  The list is not stored in one array, but in 2x.  Moreover, each array can accommodate it entirely. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/364/30a/d18/36430ad185ebb4964b40218b76b1de61.png" alt="Before pasting"><br><br>  When you insert an item in the middle of the list, we insert it into the gap.  But after all, we may want to insert the element in the wrong place where separation occurs.  To do this, we move part of the elements so that the gap moves to the right place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c1/add/0d3/1c1add0d35e3683eed96f06e942d874d.png" alt="After insertion"><br><br>  You will say: ‚ÄúYes, we moved fewer elements than in the case of <code>java.util.ArrayList</code> , but it is still proportional to the size of the list.‚Äù You are right, but if we recall our assumption, then each time, except for the first, we will move insignificant number of elements. <br><br>  The same thing happens when you delete.  The gap is shifted to the place where the item was removed. <br><br>  I quickly wrote the implementation of this list.  And he ran the tests: filling, sequential scanning, scanning by index, filtering, deleting the entire list from the head by one element.  Since  the results vary greatly for different lists, it is quite difficult to visualize them.  So just show the table.  Charts will be, but later.  The tables show the time to perform various tasks on different volumes in milliseconds. <br><br><h3>  ArrayList </h3><br><table><tbody><tr><td>  size </td><td>  fill </td><td>  sequence </td><td>  index </td><td>  filtration </td><td>  remove first </td></tr><tr><td>  20,000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  94 </td><td>  47 </td></tr><tr><td>  40,000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  406 </td><td>  187 </td></tr><tr><td>  60,000 </td><td>  sixteen </td><td>  0 </td><td>  0 </td><td>  891 </td><td>  437 </td></tr><tr><td>  80,000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  1578 </td><td>  782 </td></tr><tr><td>  100,000 </td><td>  0 </td><td>  15 </td><td>  0 </td><td>  2453 </td><td>  1219 </td></tr><tr><td>  120,000 </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  3516 </td><td>  1750 </td></tr><tr><td>  140,000 </td><td>  sixteen </td><td>  0 </td><td>  0 </td><td>  4796 </td><td>  2391 </td></tr><tr><td>  160,000 </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  6219 </td><td>  3125 </td></tr><tr><td>  180000 </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  7969 </td><td>  3984 </td></tr><tr><td>  200,000 </td><td>  63 </td><td>  0 </td><td>  0 </td><td>  9859 </td><td>  4844 </td></tr></tbody></table><br>  As you can see from the table, <code>java.util.ArrayList</code> does an excellent job with filling and any scan, and filtering and even deleting the list from the head suffers a crushing defeat. <br><br><h3>  Linkedlist </h3><br><table><tbody><tr><td>  size </td><td>  fill </td><td>  sequence </td><td>  index </td><td>  filtration </td><td>  remove first </td></tr><tr><td>  20,000 </td><td>  0 </td><td>  0 </td><td>  406 </td><td>  0 </td><td>  0 </td></tr><tr><td>  40,000 </td><td>  31 </td><td>  0 </td><td>  1985 </td><td>  0 </td><td>  0 </td></tr><tr><td>  60,000 </td><td>  15 </td><td>  0 </td><td>  3828 </td><td>  sixteen </td><td>  0 </td></tr><tr><td>  80,000 </td><td>  0 </td><td>  0 </td><td>  8359 </td><td>  0 </td><td>  0 </td></tr><tr><td>  100,000 </td><td>  sixteen </td><td>  0 </td><td>  24891 </td><td>  0 </td><td>  15 </td></tr><tr><td>  120,000 </td><td>  sixteen </td><td>  0 </td><td>  43562 </td><td>  sixteen </td><td>  0 </td></tr><tr><td>  140,000 </td><td>  sixteen </td><td>  15 </td><td>  52985 </td><td>  0 </td><td>  15 </td></tr><tr><td>  160,000 </td><td>  sixteen </td><td>  0 </td><td>  57047 </td><td>  15 </td><td>  0 </td></tr><tr><td>  180000 </td><td>  79 </td><td>  0 </td><td>  121531 </td><td>  0 </td><td>  15 </td></tr><tr><td>  200,000 </td><td>  32 </td><td>  15 </td><td>  152250 </td><td>  sixteen </td><td>  sixteen </td></tr></tbody></table><br>  The weak point of <code>java.util.LinkedList</code> is access by index, but the filtering operation is performed much faster. <br><br><h3>  DoubleArrayList </h3><br><table><tbody><tr><td>  size </td><td>  fill </td><td>  sequence </td><td>  index </td><td>  filtration </td><td>  remove first </td></tr><tr><td>  20,000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  40,000 </td><td>  sixteen </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  60,000 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  80,000 </td><td>  0 </td><td>  0 </td><td>  sixteen </td><td>  0 </td><td>  0 </td></tr><tr><td>  100,000 </td><td>  sixteen </td><td>  0 </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  120,000 </td><td>  sixteen </td><td>  0 </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  140,000 </td><td>  sixteen </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  160,000 </td><td>  sixteen </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  180000 </td><td>  47 </td><td>  sixteen </td><td>  0 </td><td>  15 </td><td>  0 </td></tr><tr><td>  200,000 </td><td>  32 </td><td>  0 </td><td>  15 </td><td>  0 </td><td>  sixteen </td></tr></tbody></table><br>  And finally, my implementation of <code>org.kefirsf.list.DoubleArrayList</code> does not sink on any of the tests. <br><br><h1>  Let's compare with LinkedList on large volumes. </h1><br><h3>  Filling </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/5de/8d8/ec9/5de8d8ec985ccc0f6d5ea13c2fa79b87.png" alt="image"><br><h3>  Filtration </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/dc7/9e6/972/dc79e697278bd266d88d42989b219063.png" alt="image"><br><h3>  Head removal </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d2f/fbe/053/d2ffbe053bc436e05d48436c384bb78c.png" alt="image"><br>  From all these graphs, it can be seen that in various operations, <code>DoubleArrayList</code> works for a time comparable to <code>java.util.LinkedList</code> .  Even if not always better.  The main thing is that there is no quadratic dependence on the size of the array, and all operations are performed in <code>O(N)</code> , which means that single operations on average are performed in <code>O(1)</code> .  Thus, the goal is achieved. <br><br>  The <code>org.kefirsf.list.DoubleArrayList</code> code is available on GitHub: <a href="https://github.com/kefirfromperm/multi-array-list">github.com/kefirfromperm/multi-array-list</a> <br>  <b>Caution:</b> do not try to use it in industrial development.  <code>org.kefirsf.list.DoubleArrayList</code> still not well covered with tests, its use can lead to memory leaks. </div><p>Source: <a href="https://habr.com/ru/post/168129/">https://habr.com/ru/post/168129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168117/index.html">BonBon - Sweet CSS3 Buttons</a></li>
<li><a href="../168119/index.html">Network Ring on Microcontrollers</a></li>
<li><a href="../168121/index.html">Mobile subscriptions, AdWords, Vkontakte application and phishing</a></li>
<li><a href="../168123/index.html">More FineReader good and different!</a></li>
<li><a href="../168125/index.html">SALT - configuration management software for Python</a></li>
<li><a href="../168133/index.html">Finger topology</a></li>
<li><a href="../168137/index.html">Load Testing with Selenium</a></li>
<li><a href="../168139/index.html">$ 30,000 from Telerik for Windows 8 developers</a></li>
<li><a href="../168141/index.html">Cackle - year results</a></li>
<li><a href="../168143/index.html">Russian football on the "plus". And with a plus? Or we don‚Äôt need such football: Part 1 theoretical</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>