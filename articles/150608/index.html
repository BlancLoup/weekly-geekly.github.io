<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We return to the distribution or how to do the impossible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 
 Not so long ago, namely on June 5, the habrechelope named alan008 asked a question . In order not to force to go for the details, I will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We return to the distribution or how to do the impossible</h1><div class="post__text post__text-html js-mediator-article"><h4>  Prehistory </h4><br>  Not so long ago, namely on June 5, the habrechelope named <a href="https://habrahabr.ru/users/alan008/" class="user_link">alan008</a> asked a <a href="http://habrahabr.ru/qa/20183/">question</a> .  In order not to force to go for the details, I will give it here: <br><br><blockquote>  Help is needed! <br><br>  For several years, different trackers (mainly c rutracker'a) by different clients (mostly uTorrent) downloaded many gigabytes of various useful content.  The downloaded files were subsequently manually moved from one disk to another, uTorrent, respectively, does not see them.  Many .torrent files are outdated by themselves (for example, the show was distributed by adding new episodes by replacing the .torrent file). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now the question itself: is there a way to automatically (not manually) establish a correspondence between the .torrent files on a computer and the content scattered across different logical drives of the computer?  The goal: to remove unnecessary (irrelevant) .torrent files, and for the most current - to put everything into distribution.  Who has any ideas?  :) <br><br>  If necessary (if required), you can place all data files in one directory on one logical drive. <br></blockquote><br>  The discussions agreed that if this can be done, then only with pens.  This question seemed interesting to me, and after returning from a vacation I took the time to figure it out. <br><br>  Having spent a total of a week analyzing the format of a .torrent file, searching for a normally working library for parsing it, I started writing a program that would solve the problem raised in the above-mentioned question. <br><br>  Before you begin, it is worth noting a few points: <br><ol><li>  It turned out a lot, but not all. </li><li>  The format of the .torrent file will be given only the necessary explanations. </li><li>  For people who are sensitive to poor-quality code at times, I ask you to forgive me in advance - I know that much could have been written better, more optimally and more seamlessly. </li></ol><br>  For those who are interested in what came out of it, technical details and pitfalls - please under the cat. <br><a name="habracut"></a><br><br>  In this case, there is a great way to solve it - siphon again.  But we are not looking for easy ways, and such an option was offered!  So, we will solve the problem on the complex - <b>do not download</b> . <br><br>  Starting to write any program, you must first think of at least the basic algorithm of its work.  In our case, the algorithm, in fact, consists of two steps: <br><br><ol><li>  Find and read all .torrent files; </li><li>  Find in the heap of files the one that corresponds to the one described in .torrent, and move it to the folder corresponding to the path to .torrent. </li></ol><br>  To implement my idea, I used C #, but any language that has libraries for reading bencode files and the ability to read the SHA-1 hash is suitable for this. <br><br>  Well, let's get down to the task. <br><br><h4>  We are looking for torrents and read them. </h4><br><br>  After I dealt with the device of .torrent files, I faced the question of parsing the whole miracle.  Having reviewed the Internet on this issue, I found several .NET libraries for this case.  I stopped my choice on the <a href="http://bencode.codeplex.com/">BencodeLibrary</a> library, which is more or less comprehensible and working out of the box, but later I had to add it a little to fit my needs, but more on that later. <br><br>  Let's start with the simplest point - reading .torrent. <br><br>  The structure of a .torrent file is quite simple - it is a <a href="http://wiki.theory.org/BitTorrentSpecification">bencode</a> dictionary.  In this dictionary, we are only interested in a couple with the <b>info</b> key - a block of file descriptions.  This is also a dictionary and contains information about the name of files, their size.  In addition, as many know, the torrent hashes files not entirely, but in chunks of a certain length, which depends on the size of these files.  Information about the size of this piece is also contained in the <b>info</b> dictionary. <br><br>  To store information from a read file, we will use the following <code>Torrent</code> class: <br><div class="spoiler">  <b class="spoiler_title">class Torrent</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Torrent</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Torrent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, List&lt;LostFile&gt; files, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pieceLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { Name = name; Files = files; PieceLength = pieceLength; Hash = hash; FileName= fileName; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PieceLength; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] Hash; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LostFile&gt; Files; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FileName; ... }</code> </pre> </div></div><br>  Here the fields store the following information: <br><br>  * <code>Name</code> - the name of the torrent (generally speaking - the name of the folder or the file name) <br>  * <code>Files</code> - the list of files that we will need to look for in the future. <br>  * <code>PieceLength</code> - the size of those pieces, the hash of which we have to count <br>  * <code>Hash</code> - a hash of all files <br>  * <code>FileName</code> - the name of the .torrent file on disk <br><br>  Now it is necessary to focus on the string hash.  It is very simple.  All files are glued together in one (virtually of course) one after the other, thus forming one BIGGI-TIAL imaginary file.  In this imaginary file, take a piece of <code>PieceLength</code> length, consider the SHA1 hash, put the hash on the line, take the next piece, count the hash, append to the end of the line with the hash of the previous piece.  That is, this is the usual concatenation of hashes of all chunks. <br><br><img src="https://habrastorage.org/storage2/74d/ea3/b54/74dea3b54c6c8f1a20f92b43e1123ac9.png"><br><br>  As the attentive reader could notice, the file inside the class is not just a file, but a special data type in which the file is described by a certain <code>LostFile</code> type <code>LostFile</code> .  Here she is: <br><div class="spoiler">  <b class="spoiler_title">class LostFile</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LostFile</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LostFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beginFrom</span></span></span><span class="hljs-function">)</span></span> { Name = name; Length = length; BeginFrom = beginFrom; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Length; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> BeginFrom; . . . }</code> </pre> </div></div><br>  Everything is simple here: the name of the file and its size.  In addition, this class contains another field - <code>BeginFrom</code> .  It describes the beginning of this file in that BOLUSHOOOOM imaginary file.  It is needed to take the correct part of the file to calculate the hash - because the length of the file is very rarely a multiple of the length of the piece. <br><br><img src="https://habrastorage.org/storage2/d5d/ae1/d9f/d5dae1d9f5a819a851b8f10326b01686.png"><br><br>  Having prepared the structures for storing the necessary information, you can start filling them out. <br><br>  Using the <b>BencodeLibrary</b> library found on the Internet, we read our .torrent file and uproot the <b>info</b> block from it: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;LostFile&gt; files = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;LostFile&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ,   BDict torrent = (BDict)BencodingUtils.DecodeFile(filename, Encoding.UTF8); BDict fileInfo = (BDict)torrent["info"];</span></span></code> </pre><br>  Further from this block it is necessary to take data about the name of the torrent, the size of the piece. <br><br><pre> <code class="hljs pgsql">string <span class="hljs-type"><span class="hljs-type">name</span></span> = ((BString)fileInfo["name"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> pieceLength = (<span class="hljs-type"><span class="hljs-type">int</span></span>)((BInt)fileInfo["piece length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>;</code> </pre><br>  There was a problem with reading the hash, the solution of which I don‚Äôt really like, but it works.  The fact is that by specification all the lines in the .torrent file should be in UFT8.  If you read a hash that, according to the specification, is written in the format of a bencode string, as a UTF8 string, then a comparison problem will arise - the hashes of the same pieces will not match.  Reading the torrent in the proposed codepage-437 encoding, we get problems with Russian letters in the paths.  The way out of this situation, which slowed me down for two days, I found not the best, but working - to read two times in different encodings. <br><br><pre> <code class="hljs pgsql">torrent = (BDict)BencodingUtils.DecodeFile(filename, <span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>.GetEncoding(<span class="hljs-number"><span class="hljs-number">437</span></span>)); <span class="hljs-type"><span class="hljs-type">char</span></span>[] pieces = ((BString)((BDict)torrent["info"])["pieces"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.ToCharArray();</code> </pre><br>  At this point, we pass the encoding information to the `BencodingUtils.DecodeFile` method as the second parameter.  This is exactly the moment when I had to add one method to the library - initially codepage-437 was embedded in the code. <br><br>  We got to the most interesting point in this part - reading information about files.  Torrent files are of two types.  These types differ in how many files they describe.  When describing only one file, its name and size are written to .torrent. <br><br>  At first we will sort .torrent with the description of one file. <br><br><pre> <code class="hljs pgsql">long Length = ((BInt)fileInfo["length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; files.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LostFile(<span class="hljs-type"><span class="hljs-type">name</span></span>, Length, <span class="hljs-number"><span class="hljs-number">0</span></span>)); // files -  </code> </pre><br>  Everything is simple - the name of the torrent coincides with the file name.  In the case when there are a lot of files in the distribution, then the name of the folder in which they should be put is written in the <b>name</b> field (in fact, it can be anything, but for some reason everyone writes the name of the folder in which these files lay during creation).  In addition, a list of <b>files</b> appears that contains information about each file: the path to it and the size.  If the size is just an integer, then the file path is a list of strings (directory names), passing through which we will see this file. <br><br>  This is best illustrated by example.  For files <code>level_1\level_2_1\file_1.txt</code> and <code>level_1\level_2_2\file_2.txt</code> , if we want to distribute them, the <b>name</b> field will contain the name of the top level folder ( <code>"level_1"</code> ), and the <b>path</b> list for one of the files will look like this: <code>{"level_2_1", "file_1.txt"}</code> and <code>{"level_2_2", "file_2.txt"}</code> for another. <br><br>  We for .torrent with several files need to collect the path to each file in one line.  In addition, it is necessary to store the beginning of each file in BOLSHOOOOM (not forgotten, right ?!): <br><br><pre> <code class="hljs pgsql">BList filesData = (BList)fileInfo["files"]; long <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (BDict file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filesData) { BList filePaths = (BList)file["path"]; long length = ((BInt)file["length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; string fullPath = <span class="hljs-type"><span class="hljs-type">name</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (BString partOfPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filePaths) { fullPath += @"\" + partOfPath.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; } files.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LostFile(fullPath, length, <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>)); // files -   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> += length; }</code> </pre><br><br>  It is very important to note that the order of the files in the BIG file can be any, not necessarily alphabetically or in size.  But the order of the files in the <b>files</b> list will be exactly the same.  This is a key point for understanding the principle of hashing.  For example, in the situation depicted in the first figure, the list of files will be as follows: <code>{"file_3","file_1", ..., "file_2"}</code> .  Thus, considering the hash of one file, we know which file will need to be taken next. <br><br>  When we have read and calculated this whole thing, let's create and return a <code>Torrent</code> instance: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Torrent(<span class="hljs-type"><span class="hljs-type">name</span></span>, files, pieceLength, pieces, filename);</code> </pre><br>  Now collecting all the reading and parsing of a .torrent file together, we get: <br><div class="spoiler">  <b class="spoiler_title">ReadTorrent</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">static Torrent ReadTorrent(string filename) { List&lt;LostFile&gt; files = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;LostFile&gt;(); BDict torrent = (BDict)BencodingUtils.DecodeFile(filename); BDict fileInfo = (BDict)torrent["info"]; string <span class="hljs-type"><span class="hljs-type">name</span></span> = ((BString)fileInfo["name"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> pieceLength = (<span class="hljs-type"><span class="hljs-type">int</span></span>)((BInt)fileInfo["piece length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; torrent = (BDict)BencodingUtils.DecodeFile(filename, <span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>.GetEncoding(<span class="hljs-number"><span class="hljs-number">437</span></span>)); <span class="hljs-type"><span class="hljs-type">char</span></span>[] pieces = ((BString)((BDict)torrent["info"])["pieces"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.ToCharArray(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileInfo.ContainsKey("files")) // Multifile torrent { BList filesData = (BList)fileInfo["files"]; long <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (BDict file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filesData) { BList filePaths = (BList)file["path"]; long length = ((BInt)file["length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; string fullPath = <span class="hljs-type"><span class="hljs-type">name</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (BString partOfPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filePaths) { fullPath += @"\" + partOfPath.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; } files.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LostFile(fullPath, length, <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> += length; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // Singlefile torrent { long Length = ((BInt)fileInfo["length"]).<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; files.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LostFile(<span class="hljs-type"><span class="hljs-type">name</span></span>, Length, <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Torrent(<span class="hljs-type"><span class="hljs-type">name</span></span>, files, pieceLength, pieces, filename); }</code> </pre></div></div><br>  Now that we have all the necessary data, we are ready for the most interesting part - the search for our files. <br><br><h4>  Looking for files </h4><br><br>  We came close to implementing the second step of our algorithm.  For this we will use the <code>FindFiles</code> method of this type: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Torrent torrent, List&lt;FileInfo&gt; files, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> destinationPath</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br>  Here <code>files</code> is the list of files among which we will search, <code>destinationPath</code> is the path to the destination folder where the found files will be placed. <br><br>  For each file in .torrent we will iterate through all the files from the heap and compare them.  Since hash checking is quite expensive, we must first weed out obviously left files.  Well, judge for yourself: if I downloaded the discography in .mp3 and moved it, I obviously did not change the file extensions.  The name could change, but the extension is unlikely. <br><br><pre> <code class="hljs pgsql">FileInfo fileOnDisk = files[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileOnDisk.<span class="hljs-keyword"><span class="hljs-keyword">Extension</span></span> != <span class="hljs-type"><span class="hljs-type">Path</span></span>.GetExtension(fileInTorrent.Name)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre><br>  It is also worth checking the length of the file, but this is doubtful and can sometimes give false positives.  Only after we explicitly left files have been screened out by extension, can we proceed to check the hash. <br><br><pre> <code class="hljs lisp">if (!torrent.CheckHash(<span class="hljs-name"><span class="hljs-name">i</span></span>, fileOnDisk)) continue<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  After the check is completed, and we have made sure that the file matches the desired one, we move it to the destination folder with the correct path.  Before moving we will naturally check the presence of a directory, and also check whether there is already such a file or not.  <code>copyFile</code> is a variable passed from the form by the user, its purpose, I think, is clear to everyone. <br><br><pre> <code class="hljs pgsql">FileInfo fileToMove = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FileInfo(destinationPath + @"\" + fileInTorrent.Name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Directory.<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>(fileToMove.DirectoryName)) Directory.CreateDirectory(fileToMove.DirectoryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fileToMove.<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>) { // -  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copyFile) File.<span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span>(fileOnDisk.FullName, fileToMove.FullName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> File.<span class="hljs-keyword"><span class="hljs-keyword">Move</span></span>(fileOnDisk.FullName, fileToMove.FullName); //     files.Remove(fileOnDisk); //     torrent.Files.RemoveAt(i<span class="hljs-comment"><span class="hljs-comment">--); break; //      ,      torrent }</span></span></code> </pre> <br>  There are in the code above three important points for explanation.  I'll start with the last two - these lines: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">files</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Remove</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">fileOnDisk</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">torrent</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Files</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RemoveAt</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">i--</span></span>);</code> </pre><br>  I found it quite logical to remove already sorted files from consideration, which will allow to somewhat reduce the search execution time.  The second line has the construction <code>.RemoveAt(i--);</code>  since the current element is removed from the collection, the pointer must be moved back so that the next element is taken at the next iteration of the loop, and not after one. <br><br>  Now, about the first moment.  I know about the presence of <code>foreach</code> for the list, but when used it is impossible to modify this spikok, that is, we will not be able to delete already unnecessary more elements.  So, collecting all the above described in one method, we have: <br><div class="spoiler">  <b class="spoiler_title">ReadTorrent</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> FindFiles(Torrent torrent, List&lt;FileInfo&gt; files, string destinationPath, <span class="hljs-type"><span class="hljs-type">bool</span></span> copyFile) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; torrent.Files.Count; i++)// (LostFile fileInTorrent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> torrent.Files) { LostFile fileInTorrent = torrent.Files[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; files.Count; j++) { FileInfo fileOnDisk = files[j]; //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileOnDisk.<span class="hljs-keyword"><span class="hljs-keyword">Extension</span></span> != <span class="hljs-type"><span class="hljs-type">Path</span></span>.GetExtension(fileInTorrent.Name)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileOnDisk.Length != fileInTorrent.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!torrent.CheckHash(i, fileOnDisk)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //   .     //   FileInfo fileToMove = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FileInfo(destinationPath + @"\" + fileInTorrent.Name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Directory.<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>(fileToMove.DirectoryName)) Directory.CreateDirectory(fileToMove.DirectoryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fileToMove.<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (copyFile) File.<span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span>(fileOnDisk.FullName, fileToMove.FullName); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> File.<span class="hljs-keyword"><span class="hljs-keyword">Move</span></span>(fileOnDisk.FullName, fileToMove.FullName); //      files.Remove(fileOnDisk); //     torrent.Files.RemoveAt(i<span class="hljs-comment"><span class="hljs-comment">--); break; } } } }</span></span></code> </pre></div></div><br>  Here you go!  Most delicious. <br><br><h4>  Hash check </h4><br><br>  As can be seen from the code above, to verify the hash, we pass the file name on the disk and the file number in the list of torrent files.  This is necessary in order not to run a search in the file list, and immediately take it by the number, since it is known (another "+1" <code>for</code> loop). <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Torrent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PieceLength; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] Hash; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LostFile&gt; Files; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FileName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, FileInfo fileOnDisk</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre><br>  Now let's get down to implementing our hash verification method.  At this stage, we know the number in the list of torrent files and the path to the file on disk. <br><br><pre> <code class="hljs kotlin">LostFile checkingFile = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Files[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkingFile.Length &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br>  In principle, we can consider the hash of any file, but let's simplify our task a little.  We will only <code>PieceLength * 2 - 1</code> with files whose length is greater than or equal to <code>PieceLength * 2 - 1</code> .  Such a restriction will give us the opportunity to isolate at least one piece for verification, which is completely in the file.  This approach has several significant advantages: <br><ol><li>  There is no need to additionally look for adjacent files on the disk; </li><li>  The length of the piece for hashing very rarely exceeds 2-4 MB, which gives us another plus - in terms of performance and time, downloading such files is much easier than looking for them on disk. </li></ol><br>  At this stage we come to the most difficult of all that we had to do - finding the right piece for verification.  Let's move away a bit from programming and turn to mathematics, having formulated an auxiliary task. <br><br>  When a torrent client performs file hashing, it considers the hash in order, but it happens that there is no one or more files.  Then the torrent client needs to know which next piece to take and where it will start in the next available file.  To calculate these two digits, we will use the following code, in which the variable <code>firstChunkNumber</code> contains the number of the first piece that is completely contained in this file, and <code>bytesOverhead</code> - the number of bytes from the beginning of the file to the beginning of this piece.  For a better understanding of this point, take a look at the explanatory picture after the code. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">long</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">long</span></span> firstChunkNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">long</span></span> bytesOveload = checkingFile.BeginFrom % this.PieceLength; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (bytesOveload == <span class="hljs-number"><span class="hljs-number">0</span></span>) //        { <span class="hljs-attribute"><span class="hljs-attribute">start</span></span> = checkingFile.BeginFrom; <span class="hljs-attribute"><span class="hljs-attribute">firstChunkNumber</span></span> = checkingFile.BeginFrom / this.PieceLength; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">firstChunkNumber</span></span> = checkingFile.BeginFrom / this.PieceLength + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">start</span></span> = firstChunkNumber * this.PieceLength - checkingFile.BeginFrom; }</code> </pre><br><br><img src="http://habrastorage.org/storage2/05b/1d1/16c/05b1d116c7f194c1b0868db0aa7db5c5.png"><br><br>  Answer the question "Why is the number of the piece different for the case when its beginning coincides with the beginning of the file, and for the case when the piece lies inside?" Is proposed independently. <br><br>  Now, knowing the number of the piece, we must take its hash from the torrent using this design: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">char</span></span>[] hashInTorrent = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">char</span></span>[<span class="hljs-number"><span class="hljs-number">20</span></span>]; // <span class="hljs-number"><span class="hljs-number">20</span></span> -   SHA1   <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span>(this.Hash, firstChunkNumber * <span class="hljs-number"><span class="hljs-number">20</span></span>, hashInTorrent, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre><br>  After that, you need to read a piece from the file and calculate its hash: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] fileHash = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileOnDisk.FullName, FileMode.Open))) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (SHA1CryptoServiceProvider sha1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SHA1CryptoServiceProvider()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] piece = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength]; fs.BaseStream.Position = start; fs.Read(piece, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength); fileHash = Encoding.GetEncoding(<span class="hljs-number"><span class="hljs-number">437</span></span>).GetString(sha1.ComputeHash(piece)).ToCharArray(); } }</code> </pre><br>  Well, the most important thing is to check it.  For some reason, none of the <code>Equals()</code> methods that I could find, wanted to work for me, so we check it like this: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; fileHash.Length; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileHash[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] != hashInTorrent[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">false</span></span>; }</code> </pre><br>  Putting together this creation of the excited brain, we obtain the method of the following content: <br><div class="spoiler">  <b class="spoiler_title">Checkhash</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, FileInfo fileOnDisk</span></span></span><span class="hljs-function">)</span></span> { LostFile checkingFile = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Files[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkingFile.Length &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> firstChunkNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bytesOveload = checkingFile.BeginFrom % <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesOveload == <span class="hljs-number"><span class="hljs-number">0</span></span>) { start = checkingFile.BeginFrom; firstChunkNumber = checkingFile.BeginFrom / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { firstChunkNumber = checkingFile.BeginFrom / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength + <span class="hljs-number"><span class="hljs-number">1</span></span>; start = firstChunkNumber * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength - checkingFile.BeginFrom; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] hashInTorrent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">20</span></span>]; Array.Copy(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Hash, firstChunkNumber * <span class="hljs-number"><span class="hljs-number">20</span></span>, hashInTorrent, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] fileHash = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileOnDisk.FullName, FileMode.Open))) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (SHA1CryptoServiceProvider sha1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SHA1CryptoServiceProvider()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] piece = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength]; fs.BaseStream.Position = start; fs.Read(piece, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PieceLength); fileHash = Encoding.GetEncoding(<span class="hljs-number"><span class="hljs-number">437</span></span>).GetString(sha1.ComputeHash(piece)).ToCharArray(); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fileHash.Length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileHash[i] != hashInTorrent[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre></div></div><br>  On this beautiful note, the story of the methods and algorithms ends, and we turn to the story of the implementation in real life of this creation.  It is quite clear that this problem was solved by me not in order to solve it, but in order to implement it.  Therefore, I bring my creation to the public, which implements everything described above. <br><br><h4>  Program </h4><br><br>  The program is written, as already mentioned in C #.  When working is not very whimsical, requires only. NET 2.0.  However, there is one restriction on use: it is better to remove the torrent files and the collection from the root of the logical disk.  The reason for this restriction is the use of the `SearchOption.AllDirectories` parameter when scanning directories, which leads to a crash when trying to read closed directories like the basket or` System Volume Information` (if knowledgeable people tell you how to get around this, I would be very grateful).  Naturally, there are no special restrictions for the destination folder, the main thing is that it fits, and you can write to it, otherwise it will crash with an error (it did not model it, but it is logical). <br><br>  In the process, after the completion of processing the next file, the result is displayed - the name of the .torrent file on the disk and the number of processed files. <br><br><img src="http://habrastorage.org/storage2/24f/14d/793/24f14d793e98824ba599a93902b82b1f.png"><br><br>  To start a scan, you must select three directories (with .torrent files, with files to sort and a folder for sorted), optionally specify two options and start scanning. <br><br>  About performance.  It is so far low: processing 10 large torrent files took about 5 minutes. <br><br>  Since the application works in one thread, the interface hangs at runtime, but I'm working on it.  I also want to remind you that small files (less than 2 megabytes) will not be moved due to the inability to verify the hash.  False alarms are quite likely due to the fact that only one piece is checked with the number <code>firstChunkNumber</code> .  So far, checking all the pieces is too expensive, but there are plans. <br><br>  <b>Do not look for torrents recursively if they are collected in the root of the disk.</b> <b><br></b>  <b>Copying may take a long time, so the interface may hang - do not be alarmed.</b> <br><br>  Since this program was written 4fun, the quality of the code there is a little bit different, but it works for me.  This program was not tested, only obvious errors were corrected, so there may be, yes, something to hide, there are hidden bugs.  <b>BY USING THIS PROGRAM, YOU USE IT AT YOUR OWN RISK.</b> <br><br>  You can <a href="">get the</a> source code on <a href="">github</a> .  Distributed by GPLv2.  There is an archive with an executable file.  The work requires the Bencode Library, but not the original one, but the one I modified (I have it in the <a href="https://github.com/parshikov/BencodeLibrary">repository</a> , connected by a submodule). <br><br>  Thanks to everyone who showed patience and read this article to the end.  I am glad to hear your questions. All possible assistance in improving the algorithm and, in particular, the code is welcome. <br><br>  Sources: <a href="http://wiki.theory.org/BitTorrentSpecification">BitTorrentSpecification</a> . <br><br>  <b>UPD1.</b>  As a result of the discussion, it became clear to me that it would be more correct not to break existing collections by pulling out files for distribution, but on the contrary - to create hardlinks in the right place for distribution to files inside ordered collections (film and discographies, for example).  In the future, the program will work that way. <br><br>  <b>UPD2.</b>  If those who used this utility have any other suggestions on the functionality or bug reports, then please leave them on the github in the issue tracker. </div><p>Source: <a href="https://habr.com/ru/post/150608/">https://habr.com/ru/post/150608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150602/index.html">The strange logic of the programmers of Sberbank is dedicated to</a></li>
<li><a href="../150603/index.html">Introduction to frameworks (Part 2)</a></li>
<li><a href="../150604/index.html">John's Phone - the world's simplest mobile phone.</a></li>
<li><a href="../150606/index.html">Share your impressions on Yandex.Maps</a></li>
<li><a href="../150607/index.html">Recommended systems: LDA</a></li>
<li><a href="../150609/index.html">Hard disk in the printer / MFP - convenience or excess?</a></li>
<li><a href="../150610/index.html">Woven - an interactive vest for games and not only</a></li>
<li><a href="../150611/index.html">Google Online School is changing face!</a></li>
<li><a href="../150612/index.html">From you - applications, from us - new Hubs on Windows and Visual Studio 2012!</a></li>
<li><a href="../150613/index.html">- Hurry up, I'm recording! // Samsung Galaxy Note 2 at IFA 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>