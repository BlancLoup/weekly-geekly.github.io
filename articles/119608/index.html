<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rasterization of vector fonts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you write programs for coffee grinders (refrigerators, ZX Spectrum, TVs, embedded systems, old computers - underline the necessary), and you want t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rasterization of vector fonts</h1><div class="post__text post__text-html js-mediator-article">  If you write programs for coffee grinders (refrigerators, ZX Spectrum, TVs, embedded systems, old computers - underline the necessary), and you want to use beautiful fonts, do not rush to save letters in raster format.  Because now I will tell you how to make a rasterizer of vector fonts the size of a couple of kilobytes, not inferior in quality to FreeType 2 with hinting turned off. <br><br>  The article will be interesting for those who just want to find out how rasterizing libraries work. <br><br><a name="habracut"></a><br><h4>  SVG vector fonts </h4><br>  To make a rasterizer, you must first understand how the vector fonts are arranged.  I chose SVG as the main font format because it relies on XML and is perhaps the most readable and understandable to humans. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first font I took to study was DejaVu Sans Mono Bold.  Here‚Äôs how it looks from the inside: <br><br><blockquote>  <font color="#009900"><font color="#000000">&lt;? xml</font> <font color="#000066">version</font> = <font color="#ff0000">"1.0"</font> <font color="#000066">standalone</font> = <font color="#ff0000">"no"</font> <font color="#000000">?&gt;</font></font> <br>  <font color="#00bbdd">&lt;! DOCTYPE svg PUBLIC "- // W3C // DTD SVG 1.0 // EN" "http://www.w3.org/TR/2001/REC-</font> <br>  <font color="#00bbdd">SVG-20010904 / DTD / svg10.dtd "&gt;</font> <br>  <font color="#009900"><font color="#000000">&lt;svg</font> <font color="#000066">xmlns</font> = <font color="#ff0000">" <a href="http://www.w3.org/2000/svg%2522">www.w3.org/2000/svg"</a></font> <font color="#000066">width</font> = <font color="#ff0000">"100%"</font> <font color="#000066">height</font> = <font color="#ff0000">"100%"</font> <font color="#000000">&gt;</font></font> <br>  <font color="#009900"><font color="#000000">&lt;defs</font> <font color="#000000">&gt;</font></font> <br>  <font color="#009900"><font color="#000000">&lt;font</font> <font color="#000066">horiz-adv-x</font> = <font color="#ff0000">"1233"</font> <font color="#000000">&gt;</font> <font color="#000000">&lt;font-face</font></font> <br>  <font color="#009900"><font color="#000066">font-family</font> = <font color="#ff0000">"DejaVu Sans Mono"</font></font> <br>  <font color="#009900"><font color="#000066">units-per-em</font> = <font color="#ff0000">"2048"</font></font> <br>  <font color="#009900"><font color="#000066">panose-1</font> = <font color="#ff0000">"2 11 7 9 3 6 4 2 2 4"</font></font> <br>  <font color="#009900"><font color="#000066">ascent</font> = <font color="#ff0000">"1901"</font></font> <br>  <font color="#009900"><font color="#000066">descent</font> = <font color="#ff0000">"-483"</font></font> <br>  <font color="#009900"><font color="#000066">alphabetic</font> = <font color="#ff0000">"0"</font> <font color="#000000">/&gt;</font></font> <br>  <font color="#009900"><font color="#000000">&lt;glyph</font> <font color="#000066">unicode</font> = <font color="#ff0000">""</font> <font color="#000066">glyph-name</font> = <font color="#ff0000">"space"</font> <font color="#000000">/&gt;</font></font> <br>  <font color="#009900"><font color="#000000">&lt;glyph</font> <font color="#000066">unicode</font> = <font color="#ff0000">"$"</font> <font color="#000066">glyph-name</font> = <font color="#ff0000">"dollar"</font> <font color="#000066">d</font> = <font color="#ff0000">"M 694 528 V 226 Q 757 235 792 274 T</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">827 375 Q 827 437 793 476 T 694 528 Z M 553 817 V 1100 Q 491 1092 460 1059 T 428</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">967 Q 428 910 459 872 T 553 817 Z M 694-301 H 553 L 552 0 Q 465 3 370 26 T 172</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">92 V 354 Q 275 293 371 260 T 553 226 V 555 Q 356</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">594 260 689 T 164 942 Q 164 1109 266 1208 T 553 1319 V 1556 H 694 L 695 1319 Q</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">766 1315 842 1301 T 999 1262 V 1006 Q 937 1046 861 1070 T 694 1100 V 793 Q 891</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">762 991 659 T 1092 383 Q 1092 219 984 114 T 695 0 L 694 -301 Z "</font> <font color="#000000">/&gt;</font></font> <br><br>  <font color="#808080">&lt;! - ... omitted .... -&gt;</font> <br><br>  <font color="#009900"><font color="#000000">&lt;glyph</font> <font color="#000066">unicode</font> = <font color="#ff0000">"~"</font> <font color="#000066">glyph-name</font> = <font color="#ff0000">"asciitilde"</font> <font color="#000066">d</font> = <font color="#ff0000">"M 1145 811 V 578 Q 1070 518 999</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">491 T 848 463 Q 758 463 645 514 Q 623 524 612 528 Q 535 562 484 574 T 381 586 Q</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">303 586 233 557 T 88 465 V 694 Q 166 755 239 782 T 395 809 Q 448 809 498 798 T</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">622 756 Q 633 751 655 741 Q 771 686 864</font></font> <font color="#009900"><br></font>  <font color="#009900"><font color="#009900">686 Q 934 686 1003 716 T 1145 811 Z "</font> <font color="#000000">/&gt;</font></font> <br>  <font color="#009900"><font color="#000000">&lt;/ font <font color="#000000">&gt;</font></font></font> <br>  <font color="#009900"><font color="#000000">&lt;/ defs <font color="#000000">&gt;</font></font></font> <br>  <font color="#009900"><font color="#000000">&lt;/ svg <font color="#000000">&gt;</font></font></font> <br></blockquote><br><br>  The main part of the SVG format is the <b>paths</b> .  They contain most of the information about the image.  The contour tag looks like this: <br><br><pre><code class="javascript hljs">&lt;path d=<span class="hljs-string"><span class="hljs-string">" M 1145 811 V 578 Q 1070 518 999 491 T 848 463 Q 758 463 645 514 Q 623 524 612 528 Q 535 562 484 574 T 381 586 Q 303 586 233 557 T 88 465 V 694 Q 166 755 239 782 T 395 809 Q 448 809 498 798 T 622 756 Q 633 751 655 741 Q 771 686 864 686 Q 934 686 1003 716 T 1145 811 Z "</span></span> id=<span class="hljs-string"><span class="hljs-string">"path4840"</span></span> style=<span class="hljs-string"><span class="hljs-string">"fill:#000000;stroke:#000000;stroke-width:1px;stroke- linecap:butt;stroke-linejoin:miter;stroke-opacity:1"</span></span> /&gt;</code> </pre> <br><br>  <b>Style</b> describes the fill and stroke color, <b>id</b> specifies the name of the outline, and <b>d</b> is the outline itself. <br><br>  Stop ... Wait a minute!  <b>Glyph</b> tag from the font: <br><br><pre> <code class="javascript hljs">&lt;glyph unicode=<span class="hljs-string"><span class="hljs-string">"~"</span></span> glyph-name=<span class="hljs-string"><span class="hljs-string">"asciitilde"</span></span> d=<span class="hljs-string"><span class="hljs-string">" M 1145 811 V 578 Q 1070 518 999 491 T 848 463 Q 758 463 645 514 Q 623 524 612 528 Q 535 562 484 574 T 381 586 Q 303 586 233 557 T 88 465 V 694 Q 166 755 239 782 T 395 809 Q 448 809 498 798 T 622 756 Q 633 751 655 741 Q 771 686 864 686 Q 934 686 1003 716 T 1145 811 Z "</span></span> /&gt;</code> </pre> <br><br>  <b>Here it is.</b>  The shape of the letter (glyph) is described in the same way as the SVG contours.  Complete <br>  a description of the parameter d can be found in the <a href="http://www.w3.org/TR/SVGTiny12/">specification</a> , and a brief description is given below: <br><img src="https://habrastorage.org/web/a01/a36/fb6/a01a36fb68124e84a7acc15da034d2af.png"><br><br>  x_prev and y_prev - coordinates of the previous point <br>  xc_prev and yc_prev - coordinates of the previous control point <br><br><h4>  Outline (stroke) glyph and initial rasterization </h4><br>  Having a library on hand to display Bezier curves and converting commands of the SVG path tag into commands of this library, you can easily and quickly get an autline (stroke) of any glyph. <br><br>  We have vector glyphs, and the screen is raster.  This means that the task of outputting an autline is reduced to obtaining an array of pixels from a set of segments and Bezier curves.  The segments are very easy to turn into pixels, there are many algorithms, they are good and different. <br><br>  For Bezier curves, you can find the set of points of the curve along the coordinates of the initial point (xz0, yz0), the end point (xz2, yz2) and the control point (xz1, yz1).  This is done like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (step=<span class="hljs-number"><span class="hljs-number">0</span></span>;step&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>;step++) { t=step/<span class="hljs-number"><span class="hljs-number">10</span></span>; bx[step]=(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*xz0+<span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*xz1+t*t*xz2; by[step]=(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*yz0+<span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1</span></span>-t)*yz1+t*t*yz2; }</code> </pre> <br><br>  As a result, we have an array of 10 coordinates of points belonging to the Bezier curve.  Depending on the length of the curve from a complex system of differential equations, the number of points into which the curve should be broken (that is, the highest step value) is found. <br><br>  However, turning bezier curves into pixels by points is slow and bad.  If the curve is of complex shape and large length, then the calculation of the number of points will take a very long time.  And if you draw a Bezier curve by points, and these points will be less than necessary - in the outline of the glyph there will be gaps, which is unacceptable.  Therefore, the Bezier curves are divided into segments.  The initial and final coordinates of the segments are taken as the coordinates of points lying on the curve.  In most cases, this approximation gives good results. <br><br>  How to determine the number of segments?  I think it's enough to make the maximum step value proportional to the difference between the initial and final coordinates (for example, step = (xz2-yz2) / 100).  By the way, for all the fonts that I have met, with a glyph height of less than 32 pixels, it is enough to break Bezier curves into two segments. <br><br>  The result of the rasterizer will be something like this: <br><br><img src="https://habrastorage.org/web/af4/a56/00a/af4a5600a6f9492c8a6a5755aec2d4ed.png"><br><br><h4>  The glyph outline is the main stage of rasterization. </h4><br>  All this is good, but on the screen we see letters that are filled with color.  So somehow you can?  I spent about two months on improving the algorithms for filling an already rasterized contour, and in the end I was convinced that this approach was fundamentally wrong.  To fill vector images raster fill is not suitable. <br><br>  In search of a solution to this fun task, I stumbled upon a MIT OCW lecture on computer graphics.  I was interested in a lecture on rasterization of three-dimensional graphics (namely, triangular polygons).  The essence of the method was as follows: in a vector form, a projection of a triangular polygon on the screen was built, and then the vector triangle was painted over.  The painting was done as follows: the screen area was chosen, beyond which the triangle definitely does not come out, and for each point of this area it was determined whether it belongs to the given triangle.  <i>The same lecture claims that the Sweeping Line fill method (which is used by Cairo and FreeType) is outdated, but this method is a little later.</i> <br><br>  It remains to learn to determine whether the point belongs to the contour of the glyph, or does not belong.  The outline of the glyph is always closed.  So, if we draw a ray in any direction from any point, and it crosses the outline of the glyph an odd number of times, the point belongs to the glyph, and even if it does not belong. <br><br>  Interestingly, this method works even if there are self-intersections or holes in the contour.  It turns out that this algorithm is a textbook, and one of its implementations is <br>  such: <br><br><pre> <code class="javascript hljs">xp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); yp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> (<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inPoly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">)</span></span>{ npol = xp.length; j = npol - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; npol;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((yp[i]&lt;=y) &amp;&amp; (y&lt;yp[j])) || ((yp[j]&lt;=y) &amp;&amp; (y&lt;yp[i]))) &amp;&amp; (x &gt; (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i])) { c = !c;} j = i;} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c;}</code> </pre> <br><br>  Here <b>xp</b> and <b>yp</b> are arrays of coordinates of the vertices of the polygon.  InPoly (x, y) function <br>  returns 1 or 0 - the point belongs to the polygon or not.  Given that we can <br>  break the glyph contour into segments (i.e., sides of a polygon), then this function <br>  great for us. <br><br><h4>  The simplest rasterizer </h4><br>  Now, by translating the glyph into an array of vertices xp and yp, we can write the simplest rasterizer.  Let the array contain segments with coordinates from 0 to 2000. Then: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x=<span class="hljs-number"><span class="hljs-number">0</span></span>;x&lt;<span class="hljs-number"><span class="hljs-number">2000</span></span>;x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (y=<span class="hljs-number"><span class="hljs-number">0</span></span>;y&lt;<span class="hljs-number"><span class="hljs-number">2000</span></span>;y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inPoly(x,y)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) raster[x][y]=<span class="hljs-number"><span class="hljs-number">1</span></span>;}}}</code> </pre> <br><br>  This simplest function will create a rasterized glyph image in the raster [x] [y] array.  The result displayed on the screen will look something like this (I displayed several glyphs in turn, and magnified the image about 20 times): <br><br><img src="https://habrastorage.org/web/69c/c2e/eca/69cc2eeca3454c6396d67795a609ec37.png"><br><br>  The glyphs with a resolution of 2000x2000 pixels on the screen are hardly needed by anyone, and the inPoly algorithm will process them rather slowly.  To display a smaller glyph, let's do something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scalefactor</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x=<span class="hljs-number"><span class="hljs-number">0</span></span>;x&lt;<span class="hljs-number"><span class="hljs-number">2000</span></span>/scalefactor;x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (y=<span class="hljs-number"><span class="hljs-number">0</span></span>;y&lt;<span class="hljs-number"><span class="hljs-number">2000</span></span>/scalefactor;y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inPoly(x*scalefactor,y*scalefactor)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) raster[x][y]=<span class="hljs-number"><span class="hljs-number">1</span></span>;}}}</code> </pre> <br><br>  If scalefactor = 2, then the glyph will be displayed in a square of 1000x1000 pixels, and if scalefactor = 100, then in a square of 20x20 (quite normal size for screen fonts). <br><br>  This rasterizer displays the clearest (and most uneven) contours of the contours, and it needs the hinting and cut-off control algorithms more than all other rasterizers (they change the shape of the contour depending on the resolution).  To store one rasterized glyph in memory, you need x * y / 8 bytes.  The full set of ASCII characters will take up no more than x * y * 32 bytes in the memory (3200 bytes for the 10x10 font and 8192 bytes for the 16x16 font).  The rasterization process uses slightly more than points * 2 * 4 bytes of memory (where points is the number of points in the glyph, points are usually less than 100, and sometimes less than 10). <br><br><h4>  Anti-aliasing (anti-aliasing) </h4><br>  Rasterization with smoothing gives much better results.  FreeType 1 library was used <br>  5-semitone smoothing, now in FreeType2 something more substantial is used (10- or 17-semitone smoothing, I did not go into details).  Having experimented, I was convinced that 10-half-tone smoothing is much better than 5-half-tone. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aadraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scalefactor</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     (3*3)  ,    for (x=0;x&lt;size*3/scalefactor;x++) { for (y=0;y&lt;size*3/scalefactor;y++) { if (inpoly(x*scalefactor/3,y*scalefactor/3)&gt;0) landscape[x][y]=1;}} //         for (x=0;x&lt;size/scalefactor;x++) { for (y=0;y&lt;size/scalefactor;y++) { //  ,       00  FF color[x][y]=255-28*(landscape[x*3][y*3]+landscape[x*3][y*3+1]+landscape[x*3][y*3+2]+landscape[x*3+1][y*3]+landscape[x*3+1][y*3+1]+landscape[x*3+1][y*3+2]+landscape[x*3+2][y*3]+landscape[x*3+2][y*3+1]+landscape[x*3+2][y*3+2]));}}//  }// </span></span></code> </pre> <br><br>  Here size is the size of the glyph (in a simple rasterizer, I substituted 2000 instead of size).  To store intermediate data, the landscape array is used, and the final result is saved to the byte array color [x] [y]. <br><br><img src="https://habrastorage.org/web/a4d/bfc/685/a4dbfc685967462fbfaa880fa4162656.png"><br><br><h4>  Subpixel smoothing </h4><br>  Subpixel anti-aliasing is often used to display fonts on LCD monitors.  On conventional monitors, subpixel anti-aliasing gives the result almost the same as regular anti-aliasing, but on the LCD anti-aliasing on subpixels allows you to increase the horizontal resolution threefold.  The essence of the method is as follows: the human eye distinguishes between intensity and not shade much better.  Details are in many sources, and even on the <a href="http://ru.wikipedia.org/wiki/ClearType">Russian Wikipedia page</a> description is sufficient for practical use. <br><br>  The problem with simple sub-pixel anti-aliasing is that the output image quality is lower than that of the 10-half-tone smoothing algorithm.  To increase the quality, I use four-halftone anti-aliasing vertically, and sub-pixel - horizontally.  The subpixel smoothing algorithm from the reference books gives such terrible results: <br><br><img src="https://habrastorage.org/web/3db/4c4/eba/3db4c4eba853474cad5ed6ad74988980.png"><br><br>  To get rid of multicolored ‚Äústains‚Äù, I changed the blur coefficients by <br>  horizontals, and in addition slightly changed the range.  The result looks like this (the best <br>  quality is achieved when viewed on the LCD monitor): <br><br><img src="https://habrastorage.org/web/454/b7a/cd3/454b7acd36e84288998e3f8544bfedbd.png"><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xdraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scalefactor</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     (3*2)  ,     for (x=0;x&lt;size*3/scalefactor;x++) { for (y=0;y&lt;size*2/scalefactor;y++) { if (inpoly(x*scalefactor/3,y*scalefactor/2)&gt;0) landscape[x][y]=1;}} //          for (x=0;x&lt;size*3/scalefactor;x++) { for (y=0;y&lt;size*2/scalefactor;y++) { if (x&gt;2 &amp;&amp; x&lt;size*3/scalefactor-2) landscape1[x][y]=landscape[x-2][y]*(1/9)+landscape[x+2][y]*(1/9)+landscape[x-1][y]*(2/9)+landscape[x+1][y]*(2/9)+landscape[x][y]*(1/3)}} //     ,     for (x=0;x&lt;size*3/scalefactor;x++) { for (y=1;y&lt;size/scalefactor;y++) { landscape2[x][y]=landscape1[x][y*2-1]*(2/9)+landscape1[x][y*2+1]*(2/9)+landscape1[x][y*2]*(4/9); if (landscape2[x][y]==8/9) landscape2[x][y]=1;}} //   //    for (x=0;x&lt;size/scalefactor;x++) { for (y=0;y&lt;size/scalefactor;y++) { r[x][y]=Math.floor(255-255*landscape2[x*3][y]);g[x][y]=Math.floor(255-255*landscape2[x*3+1][y]);b[x][y]=Math.floor(255-255*landscape2[x*3+2][y]);}} }// </span></span></code> </pre><br><br><h4>  Sweeping line method.  main idea </h4><br>  Let's look at the inPoly algorithm, about which I told, once again.  It works, but it works slowly on large characters.  Why?  Because the processing speed is proportional to the square size.  Size doubled, speed decreased fourfold, size quadrupled - speed dropped 16 times. <br><br>  If you look a little at the algorithm and think about it, you can find that for each point from those that we iterate, a horizontal beam is emitted, and its intersections with the contours are determined.  It turns out that a lot of calculations are done in vain: for all points with the same Y coordinate, the equation of the horizontal line passing through these points will be the same. <br><br>  Previously, we found a ray for each point, and counted how many times it crosses the contours.  We found the coordinates of the intersection, but did not save.  And now we will try to do this: we will find the beam only for points (0, y), and save the coordinates of the intersection of the rays with the contours. <br><br>  Paying attention: <br>  1) If the part of the contour is horizontal and coincides with the sweeping lines, the intersections with this part of the contour are not taken into account. <br>  2) On one sweeping is always an even number of points of intersection, because the contour is closed. <br><br>  It remains only to paint over the places between odd and even points, and leave the spaces between even and odd intersection points unpainted (when passing the line from left to right).  Fonts should be well designed, and the resolution of the glyphs should not be tiny, then the quality will not suffer. <br><br>  Compare speed.  Our old algorithm would have to emit rays from 9x9 points and find the coordinates of their intersection with contours.  The new algorithm has emitted only 9 rays - that is, it works an order of magnitude faster.  And at the same time, the sweeping line algorithm is very close to the one we had. <br><br><h4>  Sweeping line.  Changes in the code inPoly </h4><br>  So, we have a function inPoly.  Let's make a sweep function out of it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inPoly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">)</span></span>{ npol = xp.length; j = npol - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; npol;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((yp[i]&lt;=y) &amp;&amp; (y&lt;yp[j])) || ((yp[j]&lt;=y) &amp;&amp; (y&lt;yp[i]))) &amp;&amp; (x &gt; (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i])) { c = !c;} j = i;} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c;}</code> </pre> <br><br>  Obviously, the input parameter x is no longer needed.  The input sweep function only gets the current line number.  But the scale input parameter comes in handy to get x at the right scale right away. <br><br>  The x coordinate of the intersection of the current sweeping line with some straight contour was found like this: <br><pre> <code class="javascript hljs">(x &gt;(xp[j]- xp[i])*(y - yp[i])/(yp[j]- yp[i])+ xp[i]))</code> </pre> <br><br>  That is, it will now be: <br><pre> <code class="javascript hljs">x =(xp[j]- xp[i])*(y - yp[i])/(yp[j]- yp[i])+ xp[i])</code> </pre> <br><br>  At the output of the function, we must obtain an array of the coordinates of the intersection points.  It would be nice to know the length of this array.  So now it will be not c =! C, but c ++. <br><br>  As a result, we have this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sweep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y,scale</span></span></span><span class="hljs-function">)</span></span>{ npol = xp.length; <span class="hljs-comment"><span class="hljs-comment">//  .... j = npol -1; var c =0; for(i =0; i &lt; npol;i++){ if(((yp[i]&lt;=y)&amp;&amp;(y&lt;yp[j]))||((yp[j]&lt;=y)&amp;&amp;(y&lt;yp[i]))) { x =(xp[j]- xp[i])*(y - yp[i])/(yp[j]- yp[i])+ xp[i]; curline[c]=x/scale; c++;} //   ,       j = i;} return c;} //    </span></span></code> </pre><br><br><h4>  And again - a simple rasterizer </h4><br>  So, for each line, we call a sweep, find the intersection of the sweeping line, and fill the array with these intersections.  However, the sweep function can return to us for example the following array of coordinates: <br><br>  14, 8, 16, 7 <br><br>  To properly fill the contour, you need to fill it with lines (7, y) - (8, y) and (14, y) - (16, y).  In short, you need to sort the results of the sweep function.  Quicksort works well, and it is advisable to use it with a large number of coordinates.  However, for the fonts that I had on hand, the curline array basically had from 2 to 8 intersection coordinates, and in order not to complicate my life, I used bubble sorting.  My <b>bubble</b> function accepts an array and its length as input, does not explicitly return anything, but the array becomes sorted. <br><br>  Let's go directly to the rasterizer.  First we need to call a sweep for each line, then sort the curline array with the bubble command: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(y=<span class="hljs-number"><span class="hljs-number">0</span></span>;y&lt;size/scale;y++){ <span class="hljs-comment"><span class="hljs-comment">//        x every=sweep(y*scale, scale); //every ‚Äî     bubble(curline,every); //  for(point=0;point&lt;every;point=point+2){ //    for(x=curline[point];x&lt;curline[point+1];x++){landscape[x][y]=1;} //   }}//   </span></span></code> </pre> <br><br>  The array starts at 0 ‚Äî so you need to draw lines from curline [0 + x] to curline [1 + x].  That's all.  We got an array of landscape, and we need to work with it in the same way as before.  That is, after that it can be smoothed by anti-aliasing or sub-pixel anti-aliasing, or both.  The main thing is to pay attention to the fact that the sweep function is also transmitted to the scale, it determines the horizontal stretching. <br><br><h4>  Work results </h4><br>  Now you know how to make a rasterizer of vector fonts with your own hands.  A working example of a rasterizer can be <a href="http://board.kolibrios.org/viewtopic.php%3Ff%3D24%26t%3D1740%26sid%3D9c972f66aa82c92ad730c433d7410a80">downloaded here</a> , but it is written for the Hummingbird operating system (so you will have to download it if you want to run this example).  The size of the compiled program is 2589 bytes, the maximum use of RAM is about 300 kilobytes.  And this is not the limit! </div><p>Source: <a href="https://habr.com/ru/post/119608/">https://habr.com/ru/post/119608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119600/index.html">How much money do startups give?</a></li>
<li><a href="../119602/index.html">Mac Defender. Threat to Apple users</a></li>
<li><a href="../119603/index.html">Fast calculation of accurate 3D distance map using CUDA technology</a></li>
<li><a href="../119604/index.html">Github rejects internationalization</a></li>
<li><a href="../119607/index.html">kedDroid - S03E03. Video review software for Android</a></li>
<li><a href="../119609/index.html">Cable marking</a></li>
<li><a href="../119610/index.html">Electronic signature: "works" or not?</a></li>
<li><a href="../119611/index.html">Limit inbound and outbound traffic to Linux</a></li>
<li><a href="../119612/index.html">Order sata multipliers for a 90 TB file storage in Taiwan</a></li>
<li><a href="../119616/index.html">Attracting an audience to the site using an iPhone application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>