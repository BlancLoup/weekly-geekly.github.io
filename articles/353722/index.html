<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to create your own shaders in the Unreal Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Thanks to the node system, the material editor is a great tool for creating shaders. However, he has his limitations. For example, it is not possible ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to create your own shaders in the Unreal Engine</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eca/f9a/fbc/ecaf9afbc09c564e23409c9dc194a08c.gif" alt="image"></div><br>  Thanks to the node system, the material editor is a great tool for creating shaders.  However, he has his limitations.  For example, it is not possible to create loops and switch constructs there. <br><br>  Fortunately, these limitations can be circumvented by writing your own code.  To do this, there is a Custom node that allows you to write HLSL code. <br><br>  In this tutorial you will learn the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Create a custom node and customize its inputs </li><li>  Convert material nodes to HLSL </li><li>  Modify shader files with an external text editor. </li><li>  Create HLSL functions </li></ul><br>  To demonstrate all of these features, we will use HLSL to reduce the saturation of the scene image, display various scene textures and create a Gaussian blur (Gaussian blur). <br><a name="habracut"></a><br><blockquote>  <em>Note:</em> it is understood that you are already familiar with the basics of using the Unreal Engine.  If you are new to the Unreal Engine, then learn our series of tutorials from ten parts of the <a href="https://habrahabr.ru/post/344394/">Unreal Engine for beginners</a> . <br><br>  The tutorial also assumes that you are familiar with similar C languages, such as C ++ or C #.  If you are familiar with syntactically similar languages, for example, Java, then you can also figure it out. </blockquote><br><blockquote>  <em>Note:</em> this tutorial is part of a series of tutorials on shaders: <br><br><ul><li>  <a href="https://habrahabr.ru/post/350172/">Part 1: Cel Shading</a> </li><li>  <a href="https://habrahabr.ru/post/352814/">Part 2: Toon-contours</a> </li><li>  Part 3: Creating your own shaders with HLSL </li></ul></blockquote><br><h2>  Getting Started </h2><br>  Start by downloading this tutorial (you can download it <a href="">here</a> ).  Unzip them, go to <em>CustomShadersStarter</em> and open <em>CustomShaders.uproject</em> .  You will see the following scene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/303/3ef/7813033efedeb1bd18c746e51c3073eb.jpg"></div><br>  First we will use HLSL to reduce the saturation of the image of the scene.  To do this, we need to create and apply a Custom node in the post-processing material. <br><br><h2>  Creating a custom node </h2><br>  Go to the <em>Materials</em> folder and open <em>PP_Desaturate</em> .  We will edit this material to get a lower saturation effect. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c61/d97/d7f/c61d97d7f59b2773c6860224d58cf32b.jpg"></div><br>  First, create a <em>custom</em> node.  Like other nodes, it can have several inputs, but only one output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b84/e50/f53b84e50574f04c12d348ef91d5ea09.jpg"></div><br>  Then select the Custom node and go to the Details panel.  You will see the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/264/d49/ad5/264d49ad552786e13770dd49b646db36.jpg"></div><br>  Here is what each of the properties do: <br><br><ul><li>  <em>Code:</em> here we put our HLSL code </li><li>  <em>Output Type:</em> output can range from a single value ( <em>CMOT Float 1</em> ) to a four- <em>channel</em> vector ( <em>CMOT Float 4</em> ). </li><li>  <em>Description: the</em> text to be displayed on the node itself.  This is a good way to name the custom nodes.  Type <em>Desaturate</em> here. </li><li>  <em>Inputs:</em> here you can add and name input contacts.  Then with the help of these names we will be able to refer to these entries in the code.  Set input <em>0 to the</em> name <em>SceneTexture</em> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c2/db5/2de/4c2db52de0458f0a70839c1f13440c25.jpg"></div><br>  To reduce image saturation, replace the text inside the <em>Code</em> with the following: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(SceneTexture, float3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>,<span class="hljs-number"><span class="hljs-number">0.59</span></span>,<span class="hljs-number"><span class="hljs-number">0.11</span></span>));</code> </pre> <br><blockquote>  <em>Note:</em> <code>dot()</code> is a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471376(v%3Dvs.85).aspx">predefined function</a> .  Such features are built into the HLSL.  If you need a function like <code>atan()</code> or <code>lerp()</code> , then first check if there is already such a predefined function. </blockquote><br>  Finally, connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/e0f/043/b41e0f043d16a442a961cc41699b3a1e.jpg"></div><br>  Summarize: <br><br><ol><li>  <em>SceneTexture: PostProcessInput0</em> will output the color of the current pixel </li><li>  <em>Desaturate</em> will receive color and reduce its saturation.  Then he displays the result in <em>Emissive Color.</em> </li></ol><br>  Click on <em>Apply</em> and close <em>PP_Desaturate</em> .  Now the saturation of the image of the scene will be reduced. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a0/cd9/efd/4a0cd9efd3d7b47607edfe15dd11b263.jpg"></div><br>  You may be wondering where the saturation reduction code came from.  When we use a material node, it is converted to HLSL.  If you view the generated code, you can find the corresponding fragment and copy it.  This is how I converted the Desaturation node to HLSL. <br><br>  In the next section, we will learn how to convert a material node to HLSL. <br><br><h2>  Convert Material Nodes with HLSL </h2><br>  In this tutorial, we will convert to the HLSL <em>SceneTexture</em> node.  This will come in handy later when we create a Gaussian blur. <br><br>  To get started, go to the <em>Maps</em> folder and open <em>GaussianBlur</em> .  Then go back to <em>Materials</em> and open <em>PP_GaussianBlur</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/5cf/e63/7af5cfe638e2fb17740252a96c4e8547.jpg"></div><br>  Unreal generates HLSL for all nodes participating in the final output.  In our case, Unreal will generate HLSL for the <em>SceneTexture</em> node. <br><br>  To view the HLSL code of the entire material, select <em>Window \ HLSL Code</em> .  This opens a separate window with the generated code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/cbe/1e3/ef4cbe1e3d7fd4ed1d7ea929b105a05b.jpg"></div><br>  <em>Note:</em> if the HLSL Code window is empty, you will need to enable it in the <em>Live Preview</em> Toolbar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/830/5cb/d79/8305cbd79a20b01139542fdf06121c89.jpg"></div><br>  Since the generated code has a length of several thousand lines, it is quite difficult to navigate through it.  To simplify the search, click on the <em>Copy</em> button and paste the code into a text editor (I use <a href="https://notepad-plus-plus.org/">Notepad ++</a> ).  Then close the HLSL Code window. <br><br>  Now we need to find where the <em>SceneTexture</em> code <em>is</em> .  The easiest way to do this is to find the definition for <code>CalcPixelMaterialInputs()</code> .  This is a function in which the engine calculates all the outputs of materials.  If you look at the bottom of the function, you can see the final values ‚Äã‚Äãfor each output: <br><br><pre> <code class="cpp hljs">PixelMaterialInputs.EmissiveColor = Local1; PixelMaterialInputs.Opacity = <span class="hljs-number"><span class="hljs-number">1.00000000</span></span>; PixelMaterialInputs.OpacityMask = <span class="hljs-number"><span class="hljs-number">1.00000000</span></span>; PixelMaterialInputs.BaseColor = MaterialFloat3(<span class="hljs-number"><span class="hljs-number">0.00000000</span></span>,<span class="hljs-number"><span class="hljs-number">0.00000000</span></span>,<span class="hljs-number"><span class="hljs-number">0.00000000</span></span>); PixelMaterialInputs.Metallic = <span class="hljs-number"><span class="hljs-number">0.00000000</span></span>; PixelMaterialInputs.Specular = <span class="hljs-number"><span class="hljs-number">0.50000000</span></span>; PixelMaterialInputs.Roughness = <span class="hljs-number"><span class="hljs-number">0.50000000</span></span>; PixelMaterialInputs.Subsurface = <span class="hljs-number"><span class="hljs-number">0</span></span>; PixelMaterialInputs.AmbientOcclusion = <span class="hljs-number"><span class="hljs-number">1.00000000</span></span>; PixelMaterialInputs.Refraction = <span class="hljs-number"><span class="hljs-number">0</span></span>; PixelMaterialInputs.PixelDepthOffset = <span class="hljs-number"><span class="hljs-number">0.00000000</span></span>;</code> </pre> <br>  Since this is a post-processing material, only <em>EmissiveColor</em> is important to <em>us</em> .  As you can see, its value is the value of <em>Local1</em> .  Variables of the form <em>LocalX</em> are local variables that the function uses to store intermediate values.  If you look just above the outputs, you can see how the engine calculates each local variable. <br><br><pre> <code class="cpp hljs">MaterialFloat4 Local0 = SceneTextureLookup(GetDefaultSceneTextureUV(Parameters, <span class="hljs-number"><span class="hljs-number">14</span></span>), <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); MaterialFloat3 Local1 = (Local0.rgba.rgb + Material.VectorExpressions[<span class="hljs-number"><span class="hljs-number">1</span></span>].rgb);</code> </pre> <br>  The finite local variable (in our case, <em>Local1</em> ) is usually a ‚Äúdummy‚Äù calculation, so it can be ignored.  This means that the function for the <em>SceneTexture</em> node is the <code>SceneTextureLookup()</code> function. <br><br>  Now that we have the desired function, let's test it. <br><br><h3>  Using the SceneTextureLookup function </h3><br>  To begin with, let us ask ourselves - what do the parameters do?  Here is the <code>SceneTextureLookup()</code> signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SceneTextureLookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 UV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SceneTextureIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Filtered)</span></span></span></span></code> </pre> <br>  Here is what each parameter does: <br><br><ul><li>  <em>UV: the</em> coordinate of the UV from which to sample.  For example, UV with coordinates <em>(0.5, 0.5)</em> will sample the average pixel. </li><li>  <em>SceneTextureIndex:</em> determines from which texture of the scene to sample.  Below is a table of each scene texture and its index.  For example, for sampling <em>Post Process Input 0</em> we will use index <em>14</em> . </li><li>  <em>Filtered:</em> determines whether bilinear filtering should be applied to the scene texture.  Usually <em>false</em> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc0/9df/ac8/dc09dfac879a70931bfb9f76b6cf4915.jpg"></div><br>  For testing, we will display World Normal.  Go to the material editor and create a <em>Custom</em> node called <em>Gaussian Blur</em> .  Then paste the following into the <em>Code</em> field: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneTextureLookup(GetDefaultSceneTextureUV(Parameters, <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  So we will output World Normal to the current pixel.  <code>GetDefaultSceneTextureUV()</code> will get the UV of the current pixel. <br><br><blockquote>  <em>Note:</em> prior to version 4.19, it was possible to obtain UV by passing <em>TextureCoordinate</em> as input.  In 4.19, the correct way is to use <code>GetDefaultSceneTextureUV()</code> and pass in the desired index. <br><br>  This is an example of how hand-written HLSL code may not be compatible with different versions of Unreal. </blockquote><br>  Next, unplug the <em>SceneTexture</em> node.  Then attach a <em>Gaussian Blur</em> to <em>Emissive Color</em> and click on <em>Apply</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/470/fb8/4a5470fb85b2ea73bb2c851549ac97e0.jpg"></div><br>  At this point, you will get the following error: <br><br><pre>  [SM5] /Engine/Generated/Material.ush (1410,8-76): error X3004: undeclared identifier 'SceneTextureLookup' </pre><br>  She tells us that <code>SceneTextureLookup()</code> does not exist in our material.  Why does this work when using the SceneTexture node, but does not work with the Custom node?  When using <em>SceneTexture, the</em> compiler includes the definition of <code>SceneTextureLookup()</code> in the code.  Since we do not use this node, we cannot use the function. <br><br>  Fortunately, this problem is easy to solve.  Select the same texture for the <em>SceneTexture</em> node from which we are sampling.  In our case, you need to choose <em>WorldNormal</em> . <br><br>  Then connect it with <em>Gaussian Blur</em> .  Finally, we need to give the input contact a name that is different from <em>None</em> .  In this tutorial we will select <em>SceneTexture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/684/38a/8a8/68438a8a81dda61479d0954584818598.jpg"></div><br><blockquote>  <em>Note:</em> at the time of this writing, there was a bug in the engine: if the scene textures are not the same, then the editor crashes.  However, since this works, we can safely change the texture of the scene in the Custom node. </blockquote><br>  Now the compiler will include the definition of <code>SceneTextureLookup()</code> . <br><br>  Click <em>Apply</em> and return to the main editor.  Now you will see the normal of the world for each pixel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/57b/648/64b57b6484f346dd7c398845252c5bb1.jpg"></div><br>  For now, editing the code in the Custom node is quite convenient, because we work with small fragments.  However, when our code begins to grow, it will be more difficult to maintain it. <br><br>  To optimize the workflow, Unreal allows us to add external shader files.  Because of this, we can write code in our own text editor, and then go back to Unreal for compilation. <br><br><h2>  Using external shader files </h2><br>  First we need to create the <em>Shaders</em> folder.  Unreal will view this folder when you use the <code>#include</code> directive in the Custom node. <br><br>  Open the project folder and create a new <em>Shaders</em> folder.  The project folder should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/7c9/5cf/2427c95cffd4a8f17a2c3e2ee32f0a21.jpg"></div><br>  Then go to the <em>Shaders</em> folder and create a new file.  Call it <em>Gaussian.usf</em> .  It will be our shader file. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ba/26d/c3d/7ba26dc3d206714e61683421377d4c60.jpg"></div><br><blockquote>  <em>Note:</em> Shader files must have a <em>.usf</em> or <em>.ush extension</em> . </blockquote><br>  Open <em>Gaussian.usf</em> in a text editor and paste the code shown below.  After each change, save the file. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneTextureLookup(GetDefaultSceneTextureUV(Parameters, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  This is the same code as before, but it displays <em>Diffuse Color</em> . <br><br>  In order for Unreal to recognize the new folder and shaders, we need to restart the editor.  After restarting, go to <em>GaussianBlur</em> .  Then reopen <em>PP_Gaussian Blur</em> and replace the code in <em>Gaussian Blur</em> with the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/Project/Gaussian.usf"</span></span></span><span class="hljs-meta"> return 1;</span></span></code> </pre> <br>  Now after compilation the compiler will replace the first line with the contents of <em>Gaussian.usf</em> .  Notice that we should <em>not</em> replace <code>Project</code> name of our project. <br><br>  Click on <em>Apply</em> and return to the main editor.  Now, instead of the normals of the world, you will see diffuse colors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/ba1/a4d/b0cba1a4dbd508808d98452963f21b50.jpg"></div><br>  Now that everything is set up for convenient shader development, it is time to create a Gaussian blur (Gaussian blur). <br><br>  <em>Note:</em> since this is not a Gaussian tutorial, I will not explain it in detail.  If you want to know the details, then read the articles <a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm">Gaussian Smoothing</a> and <a href="https://softwarebydefault.com/2013/06/08/calculating-gaussian-kernels/">Calculating Gaussian Kernels</a> . <br><br><h2>  Create gaussian blur </h2><br>  As in the tutorial on toon-contours, this effect will use a convolution.  The final output is the average of all pixels in the core. <br><br>  With normal linear blur, all pixels have the same weight.  With a wide blur this leads to artifacts.  Gaussian blur avoids this by reducing the pixel weight when away from the center.  This adds more importance to the center pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/a37/d7b/538a37d7b63ee184603ddbb053feb86a.gif"></div><br>  When using material nodes, convolution is not ideal due to the large number of samples required.  For example, with a 5 √ó 5 core, we need 25 samples.  Double the size to 10 √ó 10, and the number of samples will increase to 100!  At this point, the node graph will look like a plate of spaghetti. <br><br>  And here the Custom node comes to the rescue.  With it, we can write a small <code>for</code> loop that samples each pixel in the core.  The first step is to set the parameter that controls the radius of the sample. <br><br><h3>  Creating a radius parameter </h3><br>  First back to the material editor and create a new <em>ScalarParameter</em> called <em>Radius</em> .  Give it a default value of <em>1</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/37d/fa1/0b537dfa196e519f26affbeb99e28eaf.jpg"></div><br>  The radius determines the level of image blur. <br><br>  Next, create a new entry for <em>Gaussian Blur</em> and call it <em>Radius</em> .  Then create a <em>Round</em> node and connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/143/a96/8f0/143a968f05cc94f4dca2d188a0a46067.jpg"></div><br>  <em>Round is</em> necessary so that the kernel sizes are always integers. <br><br>  Now it's time to start coding!  Since for each pixel we need to calculate Gaussian blur twice (vertical and horizontal offsets), it would be logical to turn this into a function. <br><br>  When using the Custom node, we cannot create functions in a standard way, because the compiler copies our code into a function.  Since we cannot define functions inside a function, we get an error. <br><br>  Fortunately, we can use this copy-and-paste to create global functions. <br><br><h3>  Creating global functions </h3><br>  As mentioned above, the compiler literally copies the text from the Custom node to the function.  That is, if we have the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  then the compiler will insert it into the <em>CustomExpressionX</em> function.  He won't even indent! <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MaterialFloat3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomExpression0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FMaterialPixelParameters Parameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  See what happens if we use this code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MyGlobalVariable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyGlobalFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x;</code> </pre> <br>  The generated HLSL will turn into this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MaterialFloat3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomExpression0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FMaterialPixelParameters Parameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MyGlobalVariable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyGlobalFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  As you can see, <code>MyGlobalVariable</code> and <code>MyGlobalFunction()</code> not inside the function.  This makes them global, that is, we can use them anywhere. <br><br><blockquote>  <em>Note:</em> Notice that there is no last bracket in the input code.  This is important because the compiler inserts a bracket into the end.  If we leave the bracket, as a result we will have two brackets and we get an error. </blockquote><br>  Now let's use this behavior to create a Gaussian function. <br><br><h3>  Creating a Gaussian function </h3><br>  The function for <a href="https://www.desmos.com/calculator/2rpzsgh5ol">simplified Gaussians in one dimension</a> looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/c98/cf1/41dc98cf16a15c5b6ff6426ee8ca03a3.jpg"></div><br>  As a result, it gives a bell-shaped curve, which receives at the input values ‚Äã‚Äãin the range from approximately -1 to 1. At the output, it gives a value from 0 to 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/024/a79/8ee/024a798ee971184b6bdd948f80c32402.jpg"></div><br>  In this tutorial, we will place the Gaussian function in a separate Custom node.  Create a new <em>custom</em> node and name it <em>Global</em> . <br><br>  Then replace the <em>Code</em> text with the following: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate1DGaussian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">3.141</span></span> * (x), <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre> <br>  <code>Calculate1DGaussian()</code> is a simplified 1D-Gaussian in code form. <br><br>  In order for this feature to be available, we need to use <em>Global</em> somewhere in the material column.  The easiest way to do this is by multiplying <em>Global</em> by the first node of the graph.  So we guarantee that global functions are defined before we use them in other Custom nodes. <br><br>  To begin, set the <em>Output Type</em> <em>Global</em> node to <em>CMOT Float 4</em> .  We have to do this because we will multiply by <em>SceneTexture of</em> type <em>float4</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6c/88d/a19/f6c88da19032f5e5f31452d311cbb82a.jpg"></div><br>  Next, create <em>Multiply</em> and connect everything as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/957/ce0/5d0957ce0180884c3e702e2ee849f445.jpg"></div><br>  Click on <em>Apply</em> to compile.  Now all subsequent Custom nodes will be able to use the functions defined in <em>Global</em> . <br><br>  The next step is to use a <code>for</code> loop to sample every pixel in the core. <br><br><h3>  Multi-pixel sampling </h3><br>  Open <em>Gaussian.usf</em> and replace the code with the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SceneTextureId = <span class="hljs-number"><span class="hljs-number">14</span></span>; float2 TexelSize = View.ViewSizeAndInvSize.zw; float2 UV = GetDefaultSceneTextureUV(Parameters, SceneTextureId); float3 PixelSum = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WeightSum = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Here is what each variable is for: <br><br><ul><li>  <em>SceneTextureId:</em> contains the index of the scene texture that we want to sample.  Thanks to it, we are not obliged to rigidly set the index in function calls.  In our case, the index is used for <em>Post Process Input 0</em> . </li><li>  <em>TexelSize:</em> contains texel size.  Used to convert offsets to UV space. </li><li>  <em>UV:</em> UV for the current pixel </li><li>  <em>PixelSum:</em> used to accumulate the color of each pixel in the core </li><li>  <em>WeightSum:</em> used to accumulate the weight of each pixel in the core </li></ul><br>  Next, we need to create two <code>for</code> , one for vertical offsets, the other for horizontal ones.  Add the following below the list of variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = -Radius; x &lt;= Radius; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = -Radius; y &lt;= Radius; y++) { } }</code> </pre> <br>  So we will create a grid centered on the current pixel.  Its dimensions are given as <em>2r + 1</em> .  For example, if the radius is <em>2</em> , then the grid will have dimensions <em>(2 * 2 + 1) by (2 * 2 + 1)</em> or <em>5 √ó 5</em> . <br><br>  Next we need to accumulate the colors and weights of the pixels.  To do this, add the following code to the inner <code>for</code> loop: <br><br><pre> <code class="cpp hljs">float2 Offset = UV + float2(x, y) * TexelSize; float3 PixelColor = SceneTextureLookup(Offset, SceneTextureId, <span class="hljs-number"><span class="hljs-number">0</span></span>).rgb; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Weight = Calculate1DGaussian(x / Radius) * Calculate1DGaussian(y / Radius); PixelSum += PixelColor * Weight; WeightSum += Weight;</code> </pre> <br>  Here is what each of the strings does: <br><br><ol><li>  Calculates the relative offset of the sample pixel and converts it into UV space </li><li>  Based on the offset, it samples the scene texture (in our case, it is <em>Post Process Input 0</em> ) </li><li>  Calculates the weight of the sample pixel.  To calculate 2D-Gaussians, it is sufficient to multiply two 1D-Gaussians.  The division by <code>Radius</code> done because the simplified Gaussian expects a value from -1 to 1 at the input. This division normalizes <code>x</code> and <code>y</code> in the desired interval. </li><li>  Adds Weighted Color to <code>PixelSum</code> </li><li>  Adds weight to <code>WeightSum</code> </li></ol><br>  Finally, we need to calculate the result, which is a <em>weighted</em> average.  To do this, add the following to the end of the file (outside the <code>for</code> loops): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PixelSum / WeightSum;</code> </pre> <br>  And so we implemented a Gaussian blur!  Close <em>Gaussian.usf</em> and go back to the material editor.  Click on <em>Apply</em> and close <em>PP_GaussianBlur</em> .  Use <em>PPI_Blur</em> to test different blur radii. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eca/f9a/fbc/ecaf9afbc09c564e23409c9dc194a08c.gif"></div><br>  <em>Note:</em> sometimes the <em>Apply</em> button may be inactive.  Just make a change that doesn't affect anything (for example, move the node), and it will become active again. <br><br><h2>  Restrictions </h2><br>  Despite the power of the Custom node, it has its drawbacks.  In this section I will discuss some of the limitations and flaws in its use. <br><br><h3>  Rendering access </h3><br>  Custom nodes cannot access many parts of the rendering pipeline, such as lighting information and motion vectors.  When using direct rendering, the situation is slightly different. <br><br><h3>  Version Compatibility Engine </h3><br>  HLSL code written in one version of Unreal will not necessarily work in another.  As stated in the tutorial, up to version 4.19, we could use <em>TextureCoordinate</em> to get the UV texture of the scene.  In version 4.19, you need to use <code>GetDefaultSceneTextureUV()</code> for this. <br><br><h3>  Optimization </h3><br>  Here is what Epic says about optimization: <br><br><blockquote>  The use of Custom nodes makes it impossible to minimize constants and can lead to a significantly larger number of instructions compared to a similar version built on nodes!  The folding of constants is the optimization used by the UE4 to reduce the number of shader instructions if necessary. <br><br>  For example, the chain of expressions <code>Time &gt;Sin &gt;Mul by parameter &gt; Add  -</code> can and will be minimized by the UE4 engine in one instruction, the final Add.  This is possible because all the inputs of this expression (Time, Parameter) are constants throughout the entire draw call, that is, they do not change for each pixel.  UE4 cannot collapse anything in the Custom node, which can lead to the creation of less efficient shaders compared to similar versions based on ready-made nodes. <br><br>  Therefore, it is best to use the Custom node only when it provides access to functionality that is not available in ready-made nodes. </blockquote><br><h2>  Where to go next? </h2><br>  The finished project can be downloaded <a href="">here</a> . <br><br>  If you want to get a deeper insight into the Custom node, then I recommend learning about Ryan Brooke‚Äôs <a href="http://shaderbits.com/blog">blog</a> .  It has posts explaining in detail how to use the Custom node to create raymarching and other effects. </div><p>Source: <a href="https://habr.com/ru/post/353722/">https://habr.com/ru/post/353722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353712/index.html">We write our own clever thread_pool-dispatcher for SObjectizer</a></li>
<li><a href="../353714/index.html">Announcement of AppsConf: 2 days of application, hardcore and HYIP reports</a></li>
<li><a href="../353716/index.html">IPv6 support in CleanTalk Security for WordPress</a></li>
<li><a href="../353718/index.html">It's all about the combination: the history of the security system of one site</a></li>
<li><a href="../353720/index.html">How to create custom components for monitoring devices and automating IT tasks</a></li>
<li><a href="../353724/index.html">Why it is not necessary to always obtain consent for the processing of personal data within the framework of the GDPR</a></li>
<li><a href="../353726/index.html">The device of special effects for games under NES. Part 1</a></li>
<li><a href="../353728/index.html">How to increase the number of friends in the company</a></li>
<li><a href="../353730/index.html">Mikrotik RoS, useful things</a></li>
<li><a href="../353732/index.html">Crypto Trading Automation with Django and Celery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>