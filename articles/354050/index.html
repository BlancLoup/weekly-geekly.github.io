<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Designing a Schemaless Uber Engineering data warehouse using MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Designing Schemaless, Uber Engineering's Scalable Datastore Using MySQL 
 By jakob holdgaard thomsen 
 January 12, 2016 

 https://eng.uber.com/schema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Designing a Schemaless Uber Engineering data warehouse using MySQL</h1><div class="post__text post__text-html js-mediator-article"><h2>  Designing Schemaless, Uber Engineering's Scalable Datastore Using MySQL </h2><br>  <i>By jakob holdgaard thomsen</i> <br>  January 12, 2016 <br><br>  <a href="https://eng.uber.com/schemaless-part-one/">https://eng.uber.com/schemaless-part-one/</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de4/019/915/de40199155227040ef7fe0470407106b.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Designing a Schemaless Uber Engineering data warehouse using MySQL.  This is the first part of the three parts of the Schemaless data warehouse series. <br><br>  In Project Mezzanine, <a href="http://eng.uber.com/mezzanine-migration/">we described</a> how we transferred Uber travel data from one Postgres instance to Schemaless ‚Äî our high-performance and reliable data storage.  This article describes its architecture, its role in the Uber infrastructure, and its design history. <br><a name="habracut"></a><br><h3>  Fight for a new database </h3><br>  In early 2014, we ran out of database resources due to the increase in the number of trips.  Each new city, each new trip led us to the abyss, until one day we realized that the Uber infrastructure could not function by the end of the year - we simply could not store enough travel data using Postgres.  Our task was to change the database technology in Uber, a task that took many months, and to which we attracted a large number of engineers from our offices around the world. <br><br>  But wait, why build a scalable data warehouse when there are a lot of commercial and open source solutions?  We had five key requirements for our new data warehouse: <br><br>  <b>Our data warehouse should have been able to grow capacity linearly by</b> adding new servers, which was not enough in our Postgres installation.  Adding new servers should both increase the available disk space and decrease the system response time. <br><br>  <b>We need high availability data storage at write</b> .  Previously, we implemented a simple buffer mechanism with Redis, so if the Postgres entry failed, we could try again later, since the trip was saved in Redis.  During the time that the record was saved in Redis and not yet saved in Postgres, we lost functionality, such as billing.  It's a shame, but at least we have not lost the trip!  Over time, Uber has grown, and our solution based on Redis is not scalable.  Schemaless data storage should support a mechanism similar to our solution with Redis, but provide read-your-write consistency. <br><br>  <b>We need a way to exchange messages with dependent components</b> .  In the system working at that time, we worked with dependent components sequentially within one process (for example, billing, analytics, etc.).  It was an error-prone process: if a process step failed, we had to try again from the beginning, even if some of the process steps were successful.  It did not scale, so we wanted to break the processes into isolated subordinate processes that would start in response to data changes.  We already had an asynchronous messaging system based on Kafka 0.7.  But we could not start it without data loss, so we would welcome a new system that had something similar, but could work without data loss. <br><br>  <b>We need secondary indexes</b> .  We departed from Postgres, however, the new data store should have maintained indexes at the Postgres level, which would also allow for efficient search of secondary indexes. <br><br>  <b>We need an absolutely reliable system</b> , as it contains critical trip data.  If at 3 am we are told that our data warehouse is not responding to requests and our business is destroyed, will we have operational information to quickly restore it? <br><br>  In light of the above, we analyzed the advantages and potential limitations of some alternative widely used systems, such as Cassandra, Riak, MongoDB, etc. For purposes of illustration, a diagram showing the various combinations of capabilities of various systems is given below products): <br><br><table><tbody><tr><td></td><td>  Linear extensibility </td><td>  Write accessibility </td><td>  Message exchange </td><td>  Secondary indexes </td><td>  Reliability </td></tr><tr><td>  Product 1 </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úó </td><td>  (‚úì) </td><td>  ‚úó </td></tr><tr><td>  Product 2 </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úó </td><td>  (‚úì) </td><td>  (‚úì) </td></tr><tr><td>  Product 3 </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úó </td><td>  (‚úì) </td><td>  ‚úó </td></tr></tbody></table><br>  While all three systems are linearly expandable by adding new servers, only two of them have high availability when writing.  None of the solutions implement messaging out of the box, so we would have to implement it at the application level.  All of them have indexes, but if you intend to index many different values, queries become slow, as they use the scatter-gather command to poll all nodes (shards). <br><br>  Finally, our decision was ultimately determined by reliability, since we need to store trip-related data critical to the business.  Some existing solutions can function reliably in theory.  But do we have operational knowledge for the immediate realization of their most complete capabilities?  After all, much depends not only on the technology that we use, but also on those people who were on our team. <br><br>  It should be noted that, since we looked at these options more than two years ago and found that none of them are applicable when using a trip data repository, we successfully applied both Cassandra and Riak in other areas of our infrastructure, and we we use them in production to serve millions of users. <br><br><h3>  We are reliable at Schemaless </h3><br>  Since none of the above options met our requirements in accordance with the timeframes we had, we decided to create our own system, which was simplified to the maximum extent possible, using the scaling lessons received from others.  The design was inspired by Friendfeed, and the emphasis was on the operating side, inspired by Pinteres. <br><br>  We concluded that there is a need to design a key-value storage that allows you to save any JSON data without strict schema checking (hence the name schemaless).  It was implemented on a MySQL server distributed on shards, with write buffering for fault tolerance, and publish-subscribe data exchange messaging, which is based on triggering calls.  Finally, the Schemaless data warehouse supports global indexes. <br><br><h3>  Schemaless data model </h3><br>  Schemaless is an append-only sparse three-dimensional hash map, similar to Google's Bigtable.  The smallest data object in Schemaless is called a cell and is immutable.  After recording, it cannot be changed or deleted.  The cell is a JSON (BLOB) object, which can be accessed using the row key, the column name, and the reference key, called the ref key.  The row key is a UUID, the column name is a string, and the reference key is an integer. <br><br>  You can represent a row key as the primary key in a relational database and the column name as a relational database column.  However, Schemaless has no predefined or forced schema, and column names are not predefined for rows.  In fact, the column names are fully defined by the application.  Reference key ref key is used for versioning cells.  Therefore, if the cell needs to be updated, you must write a new cell with a higher ref key (the last cell has the highest ref key).  The ref key can also be used as an index in an array, but it is usually used for versioning.  The way to use the ref key is determined by the application. <br><br>  Typically, applications group related data into the same column, and all cells in each column have approximately the same schema on the application side.  This grouping is a great way to combine data that changes together, and allows an application to quickly change the schema without idleness on the database side.  Below is an example of this. <br><br><h3>  Example: Schemaless Trip Data Storage </h3><br>  Before we dive into how we model a trip to Schemaless, let's look at the anatomy of a trip to Uber.  Trip data is generated at different times, for example: the end of a trip, payment for a trip, and these various pieces of information are received asynchronously.  The diagram below is a simplified flow when different parts of a Uber trip occur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8af/c2b/1bd/8afc2b1bd74b13cbb66865c4033bf45d.png" alt="Simplified Uber Trip Chart"><br><br>  The diagram shows a simplified version of our event flow.  * denotes parts that are optional and may be present several times. <br><br>  The trip is contacted by the driver who fulfills the order of the client, and has a time stamp for his start and end.  This information represents the base (estimated) trip, and from this we calculate the cost of the trip (fare), which is the fare for the client.  After the trip, we may have to adjust the tariff.  We can add notes to the trip, considering feedback from the client or from the driver (marked with an asterisk in the diagram above).  Or, perhaps, the client will have to make several attempts to pay for the trip with a payment card if one of his cards is blocked.  The flow of events in Uber is a process driven by data.  As data becomes available or added during a trip, a certain set of processes will be executed.  Some information, such as assessing the quality of the service (considered part of the notes in the diagram above), may occur several days after the trip is completed. <br><br>  So how do we compare the above travel model with Schemaless? <br><br><h3>  Trip data model </h3><br>  We will use italics to denote the <i>UUID</i> and upper case letters for the column names; the table below shows the data model for a simplified version of our trip store.  We have two trips (UUIDs trip_uuid1 and trip_uuid2) and four columns (BASE, STATUS, NOTES and FARE ADJUSTMENT).  Each cell is represented by a block with a number and a JSON object (abbreviated {...}).  Blocks are shown overlaid to represent versioning. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/345/68b/884/34568b88483680173df01cb7cce444a9.png" alt="trip data model"><br><br>  trip_uuid1 has three cells: one in the BASE column, two in the STATUS column, and none in the FARE ADJUSTMENTs column.  trip_uuid2 has two cells in the BASE column, one in the NOTES column, and also in the FARE ADJUSTMENTS column.  For Schemaless, the columns are no different;  therefore, the semantics of the columns is determined by the application, which in this case is a Mezzanine service. <br><br>  In Mezzanine, the BASE cells contain basic trip information, such as the driver's UUID and travel time.  The STATUS column contains the current status of the travel payment, in which we insert a new cell for each invoice attempt.  (The attempt failed if the credit card did not have sufficient funds or the card was blocked).  The NOTES column contains a cell if there are notes left by the driver or dispatcher.  Finally, the FARE ADJUSTMENTs column contains cells if the fare for the trip has been adjusted. <br><br>  We use this column structure to avoid race conditions and minimize the amount of data that needs to be recorded during the update.  The BASE column is recorded when the journey is completed, and, as a rule, only once.  The STATUS column is recorded when we try to pay for a trip that occurs after writing data in the BASE column and can occur several times if there was a failure to pay the bill.  The NOTES column can also be written several times at some point after the BASE record, but it is completely separated from the STATUS column record.  Similarly, the FARE ADJUSTMENTS column is recorded only if the fare is changed, for example, due to an inefficient route. <br><br>  <b>Pass-through triggers</b> <br><br>  A key feature of Schemaless are triggers that allow you to receive notifications of changes in a Schemaless instance.  Because cells are immutable and new versions are added, each cell also represents a change or version, allowing values ‚Äã‚Äãin the instance to be treated as a change log.  For this instance, you can listen to these changes and run functions on them that are very similar to message buses, such as Kafka. <br><br>  Schemaless triggers make Schemaless a reliable source of data, because, in addition to direct data access, the messaging system can use the trigger function to monitor and run any application code (the similar system is LinkedIn's DataBus), separating data creation and processing. <br><br>  Among other use cases, Uber uses Schemaless triggers for invoicing when the BASE column is written to a Mezzanine instance.  In the example above, when the BASE column for trip_uuid1 is written, our billing service, which runs in the BASE column, selects this cell and will try to pay for the trip through a payment card.  The result of payment via a payment card, whether it is success or failure, is recorded in the Mezzanine in the STATUS column.  Thus, the billing service is separated from the creation of a trip, and Schemaless acts as an asynchronous message bus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4b/24a/dcf/f4b24adcf7548066d0f118c4830841c9.png" alt="SchemalessTriggersExample"><br><br><h3>  Indexes for easy access </h3><br>  Finally, Schemaless supports indexes defined by fields in JSON objects.  The index is queried through these predefined fields to find cells that match the parameters of the query.  Querying these indexes is effective because requesting an index only requires accessing one shard to find a set of cells to return.  In fact, queries can be further optimized, since Schemaless allows you to denormalize these cells by writing them directly to the index.  The presence of denormalized data in the index means that only one shard is required to query the index to query the index and obtain information.  In fact, we usually recommend Schemaless users to denormalize frequently requested data into indexes, in addition to getting a cell directly through a row key. <br><br>  As an example for Mezzanine, we have an index that allows us to find trips given by the driver.  We also denormalize the time of the trip creation and the city where the trip was made.  This allows you to find all trips for the driver in the city for a certain period of time.  Below we provide the definition of the driver_partner_index index in YAML format, which is part of the trip data store and defined above the BASE column (an example is annotated with comments using the standard #). <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: driver_partner_index # <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>. datastore: trips # <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the associated datastore column_defs: ‚Äì column_key: BASE # <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> which <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>. fields: # The fields <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cell <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> denormalize ‚Äì { field: driver_partner_uuid, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">UUID</span></span>} ‚Äì { field: city_uuid, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">UUID</span></span>} ‚Äì { field: trip_created_at, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: datetime}</code> </pre> <br>  Using this index, we can find trips for a given driver_partner_uuid, filtered by city_uuid, and / or trip_created_at.  In this example, we only use fields from the BASE column, but Schemaless supports the denormalization of data from several columns, which will contain several entries in the above column_def list. <br><br>  As mentioned, Schemaless has effective indexes implemented by sharding indices based on a shard field.  Therefore, the only requirement for a shard index is that one of the fields in the index is designated as a shard field (in the example above, this would be the driver_partner_uuid, since it is the first one specified).  The shard field determines which shard should write or read the index.  To do this, we need to determine the shard field when requesting an index.  This means that at the time of the query, we need to request only one shard to retrieve the index entries.  An important requirement for a shard field is that it must ensure a good distribution of data across shards.  UUIDs are best suited, city identifiers are less preferred, and status fields (transfers) will do more harm than good. <br><br>  With the exception of shard fields, Schemaless supports queries for equality, inequality, and a range of queries for filtering, and also supports selecting only subsets of the fields in the index and extracting specific or all columns for the key of the row pointed to by the index entries.  At present, the shard field must be non-interleaved, which allows Schemaless to determine the shard on which the data is located one-by-one.  But we are learning how to make it mutable without the cost of performance. <br><br>  Our indices are consistent eventually (eventually consistent).  Whenever we write data to a cell, we also update the index entries, but this does not happen in a single transaction.  The cells and index entries usually do not belong to the same shard.  Therefore, if we were to implement consistent indices, we would need to enter a two-phase commit when writing, which would entail significant overhead.  As a result, with eventually consistent indexes, we avoid overhead, but Schemaless users may see outdated data in the indexes.  Most of the time, the lag is well below 20 ms between cell changes and corresponding index changes. <br><br><h3>  Summary </h3><br>  We presented an overview of the data model, triggers and indexes, which are the key functions that define Schemaless - the main component of our trip data storage mechanism.  In future posts, we will look at a few more features of Schemaless to illustrate how he became a good helper in the Uber infrastructure: more about the architecture, using MySQL as a shard and how we handle errors ensuring the reliability of the mobile application. <br><br>  <a href="https://eng.uber.com/schemaless-part-two/">Part 2: Layout Architecture</a> <br><br>  <a href="https://eng.uber.com/schemaless-part-three/">Part 3: Using Triggers in Schemaless</a> <br><br>  It is an engineering project in Aarhus, Denmark.  See our talk at Facebook's second annual conference on September 2015 for more info on Schemaless. <br><br>  Photo Credits for Header: ‚Äúanim1069‚Äù by NOAA Photo Library licensed under CC-BY 2.0.  Image cropped for dimensions and color corrected. <br><br>  Header Explanation: Since it has been built using MySQL, we introduce it. </div><p>Source: <a href="https://habr.com/ru/post/354050/">https://habr.com/ru/post/354050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354038/index.html">Top VSCode Extensions That Speed ‚Äã‚ÄãUp Your JavaScript Development</a></li>
<li><a href="../354040/index.html">We apply the Deep Watershed Transform in the Kaggle Data Science Bowl 2018 competition.</a></li>
<li><a href="../354044/index.html">Next generation video: introducing AV1</a></li>
<li><a href="../354046/index.html">Inheritance, composition, aggregation</a></li>
<li><a href="../354048/index.html">Atlassian Jira Software functionality in Jira plugin</a></li>
<li><a href="../354052/index.html">Configuring Let's Encrypt wildcard certificates on CentOS 7 with validation via CloudFlare API</a></li>
<li><a href="../354054/index.html">You should not conduct interviews because ... [spoiler - you yourself do not go to interviews]</a></li>
<li><a href="../354056/index.html">React cheatsheet or a couple of life hacks</a></li>
<li><a href="../354060/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ311 (April 16 - 22, 2018)</a></li>
<li><a href="../354062/index.html">Creating an Android Twitter Application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>