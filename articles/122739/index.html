<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Function-Based Iterators and Generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Support for iterators and generators as language constructs appeared in javascript only in version 1.7, and one can only dream about using these wonde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Function-Based Iterators and Generators</h1><div class="post__text post__text-html js-mediator-article">  Support for iterators and generators as language constructs appeared in javascript only in version 1.7, and one can only dream about using these wonderful things in browsers for a long time.  However, it is already possible to use iterators and generators as design patterns in javascript, and moreover, it is quite easy to do it, and sometimes it's nice :) <br><a name="habracut"></a><br>  In my topic, I will often refer to "real iterators", by which I understand the very iterators from javascript 1.7, which in the topic <a href="http://habrahabr.ru/blogs/javascript/122620/">Iterators &amp; Generators</a> perfectly highlighted azproduction. <br>  I highly recommend to get acquainted with his topic, also because for comparison I will use the code of his ‚Äúreal‚Äù examples. <br><br>  So let's go! <br><br><h4>  Simple example </h4><br>  There is a certain set of objects, let's call them units.  You need to give all units the color from the set [red, green, blue] in a cyclical order.  That is, the first unit is red, the second is green, the third is blue, the fourth is red again and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Such a problem is solved with the help of an auxiliary object, which I usually call Revolver. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Revolver([<span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-string"><span class="hljs-string">'blue'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { units[i].color = colors.next(); }</code> </pre> <br>  Revolver looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Revolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items = items; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max = items.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.i = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } Revolver.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.i = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.i + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.i]; };</code> </pre><br>  I don't like this code.  You ask why?  The answer is: too many gestures.  See for yourself, just to paint the units, you had to: <br><ol><li>  declare a helper class </li><li>  define the next () method in this class, </li><li>  create an instance of the class with the desired set of values </li><li>  call the instance's next () method to get the next value from the set. </li></ol><br>  Is it possible to simplify Revolver so that the code becomes smaller, and the meaning - more? <br>  Can!  <s>Use functions, Luke!</s> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = items.length - <span class="hljs-number"><span class="hljs-number">1</span></span>, i = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ i = i &lt; max ? i + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[i]; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next_color = revolver([<span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-string"><span class="hljs-string">'blue'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { units[i].color = next_color(); }</code> </pre><br>  Now there is no class with a method, instead there is a function that returns a function. <br>  The concentration of meaning is maximum, because in reality we need not a set of colors as an object, but a <i>method of obtaining the next color from the set</i> . <br><br>  The method of obtaining an element of a collection in the absence of a collection as such is what is called an iterator. <br><br><h4>  Theory </h4><br>  An iterator is an object that allows a programmer to iterate over all elements of a collection without taking into account the peculiarities of its implementation (wikipedia). <br><br>  In the example above, the collection is an infinite repeating color set of r, g, b, r, g, b, ..., and the implementation features of the collection are really hidden. <br><br>  Iterators are produced by generators.  The generator looks like a function that remembers where the previous return was, and on the next call resumes operation from the interrupted place.  A generator is a factory of iterators of a certain type; after a generator is called, each iterator created by it lives its own life. <br><br>  In the example, the revolver function is a generator of infinite iterator sequences from a transmitted set of elements. <br><br>  Thus, functional iterators and generators can be defined as: <ol><li>  Iterator - a function that returns items of a collection during successive calls; </li><li>  The generator is a function that returns an iterator function. </li></ol><br>  A traditional example of the use of generators is the generation of infinite sequences, such as the Fibonacci sequence.  Let's see how it can be implemented as a functional generator. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, fn2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = fn1; fn1 = fn2; fn2 = fn2 + current; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sequence = fibonacci(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sequence()); <span class="hljs-comment"><span class="hljs-comment">// 1, 1, 2, 3, 5 }</span></span></code> </pre><br>  Works!  Compare with the code of this generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, fn2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = fn1; fn1 = fn2; fn2 = fn2 + current; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> current; } }</code> </pre><br>  It seems true? <br><br><h4>  Practice </h4><br>  One of the purposes of iterators is to organize a looping through of the collection, the interface to which they represent. <br><br>  These iterators are perfectly integrated into the for i in loop operator.  To mark the end of a collection, the iterator throws a special exception, which the for statement understands as a loop exit signal. <br><br>  Obviously, the way the functional iterators work should be different. <br><br>  The first thing you need to decide is the designation of the end of the collection.  For this, it is convenient to use the following property of javascript functions: if the return statement is not encountered until the end of the function body, the result of the function execution is undefined.  This feature allows you to make the iterator code more understandable and readable: as long as there are elements of the collection, we return them with the help return, when the elements have run out, we don‚Äôt return anything. <br><br>  The second is a construct with which a functional iterator can be iterated.  The construction is needed not only for the iterator, but also for the generator.  Everything is also quite simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ‚Äî while var item; while (item = iterator()) { //  item } //  ‚Äî for for (var item, iter = generator(); item = iter();) { //  item }</span></span></code> </pre><br>  Example of the organization of the cycle: a generator of powers of two, not exceeding the number N. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powers_of_two</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">N</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = value; value *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &lt; N) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p, iter = powers_of_two(<span class="hljs-number"><span class="hljs-number">42</span></span>); p = iter();) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(p); <span class="hljs-comment"><span class="hljs-comment">// 1, 2, 4, 8, 16, 32 }</span></span></code> </pre><br><br><h5>  A fly in the ointment </h5><br>  Real generators have an important property, which is to resume execution of the iterator body from the point of calling the last yield statement.  This functionality allows the linear code to describe a sequence of elements that are usually generated using loops or recursion, and thus simplify the code. <br><br>  A good example is the tree traversal generator from the <a href="http://habrahabr.ru/blogs/javascript/122620/">Iterators &amp; Generators</a> topic: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inorder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inorder(t.left)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> item; } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> t.label; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inorder(t.right)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> item; } } }</code> </pre><br>  It looks clear and logical - we return the elements of the left branch, then the root, then the elements of the right branch.  The class. <br><br>  Functional generators cannot continue executing the code after the return statement; each iterator call leads to the execution of the function from the beginning.  Therefore, the state has to be saved in variables closed on an iterator function. <br><br>  Let's try to create a functional generator of recursive tree traversal. <br>  Attempt 1, duplication of the logic of the present generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inorder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, left, right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t) { left = inorder1(t.left); right = inorder1(t.right); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item = left()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { root = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.label; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item = right()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } }; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; } }</code> </pre><br>  It turned out so-so, but two things are especially sad. <br><br>  1. The presence of three return statements in the body of the iterator.  In the case of the yield statement, everything looks logical, since execution continues from the next line.  However, if return is used as a yield, the logic is broken and it becomes more difficult to understand what is going on. <br><br>  2. An empty tree at the input of the generator is processed by a separate empty iterator <i>return function () {}</i> , which further confuses the code. <br><br>  The source of problems in this case is the copying of the logic of the present generator, which is able to maintain its state.  To make the function generator code clear, you need to save the state more clearly. <br><br>  We will think over iteration on a tree. <br>  Obviously, it is necessary to operate with iterators on the nodes of the left and right branches of the tree. <br>  When the left branch iterator is used up, you need to use the root, then use the right branch iterator. <br>  If it were possible to represent the root in the form of an iterator, we would have three iterators, each of which needs to be consistently used to the end, returning the result, after which the tree will be completed completely. <br><br>  Let's try to translate in code: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inorder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> roots = [t], <span class="hljs-comment"><span class="hljs-comment">//     iters = []; if (t) { iters.push(inorder(t.left)); iters.push(function () {return roots[0] &amp;&amp; roots.shift().label}); //   iters.push(inorder(t.right)); } return function () { var leaf; while (iters.length) { leaf = iters[0](); if (leaf) { return leaf; } iters.shift(); } }; }</span></span></code> </pre><br>  It turned out almost well - the return statement in the iterator is one, and the iterator code is very simple. <br><br>  Thus, functional generators with complex logic are quite realizable, but their creation requires more careful deliberation in comparison with real generators. <br><br><h4>  Iterator Management </h4><br>  Especially meticulous guys might object to me at the beginning of the topic, for example, like this: ‚ÄúWait a minute, you say that the iterator is a function.  Great, but what will you do with this function if you need to reset the state of the iterator? ‚Äù <br><br>  I answer: I will add a method to this function :) Functions in javascript are objects.  Of course, functions may have methods. <br><br>  The good old Fibonacci sequence, now with the reset method: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci_restartable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, fn2 = <span class="hljs-number"><span class="hljs-number">1</span></span>, iterator; iterator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = fn1; fn1 = fn2; fn2 = fn2 + current; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; }; iterator.restart = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fn1 = fn2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sequence = fibonacci_restartable(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sequence()); <span class="hljs-comment"><span class="hljs-comment">// 1, 1, 2, 3, 5 } sequence.restart(); for (var i = 0; i &lt; 5; i += 1) { console.log(sequence()); // 1, 1, 2, 3, 5 }</span></span></code> </pre><br>  If you use terminology, the restart method is <i>preferred</i> , which actually means the presence of a closure on the iterator's internal variables. <br>  Similarly, you can add an iterator with any necessary methods that affect its internal state. <br><br><h4>  findings </h4><br>  Iterators and generators in the form of design patterns get along quite well in javascript due to the flexibility of its functions.  Of course, functional iterators are inferior in performance to real iterators, but in places where performance is not important, the use of functional iterators can streamline and simplify the code. <br><br>  Thank you for attention! </div><p>Source: <a href="https://habr.com/ru/post/122739/">https://habr.com/ru/post/122739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122733/index.html">MediaWiki 1.17 engine released. My extension replacing jQuery is still working in it. But in the future (for MediaWiki 1.18) a more elegant solution will appear.</a></li>
<li><a href="../122735/index.html">We go around other people's brakes</a></li>
<li><a href="../122736/index.html">Google stops supporting Google Health and PowerMeter projects</a></li>
<li><a href="../122737/index.html">Electronic Arts servers hacked</a></li>
<li><a href="../122738/index.html">Advertising for your Android application</a></li>
<li><a href="../122740/index.html">Baldur's Gate on Android: GemRB emulator in action</a></li>
<li><a href="../122742/index.html">Encrypt, scan, smile - the first startup in the domain.rf</a></li>
<li><a href="../122744/index.html">Chrome extension for Google Music</a></li>
<li><a href="../122746/index.html">A tale about how a good young man fought a three-headed snake, or How to embed SVG graphics in Adobe InDesign documents - part one</a></li>
<li><a href="../122747/index.html">Recovery strategy for damaged table in MySQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>