<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Naive implementation of std :: bind (boost :: bind)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is probably difficult to find such a C ++ programmer who never used boost :: bind in his code (with the release of c ++ 11 std :: bind). Bind is a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Naive implementation of std :: bind (boost :: bind)</h1><div class="post__text post__text-html js-mediator-article">  It is probably difficult to find such a C ++ programmer who never used boost :: bind in his code (with the release of c ++ 11 std :: bind).  Bind is a template function that returns a wrapper over a callable object (that is, an object that can be called by passing it the required number of arguments in round brackets).  Bind allows you to change the signature of the call of such an object, reducing the number of input arguments or swapping some of them.  Who cares how this can be implemented using C ++ 11, please under the cat. <br><a name="habracut"></a><br>  <i>Examples of using</i> <br><br>  Here is the simplest (contrived) example of using bind-a: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rhs )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f_sum = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind( sum, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_2 ); f_sum( <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// f_sum  10</span></span></code> </pre> <br>  In this example, std :: bind takes as its basis a pointer to the sum function and uses lhs as its argument, 3, and rhs for the second argument from the f_sum callable object passed to the input.  Thus the result of calling f_sum is 10. Everything is very simple.  It is clear that in a similar way, std :: bind can also be used with member functions.  The only difference is that in this case, as the first argument, the callable object constructor must pass an object of the corresponding class, which will have the member function called. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A::Print()"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; A a; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(&amp;A::Print, a); f(); <span class="hljs-comment"><span class="hljs-comment">// "" A::Print()</span></span></code> </pre> <br>  <i>Actually implementation</i> <br><br>  So, std :: bind is a template function that takes as input a pointer to a callable object and arguments, which can be constants, variables, or placeholders.  As part of the new (c ++ 11) standard, this can be written as: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> naive { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... BinderArgs&gt; binder&lt;Func, BinderArgs...&gt; bind( Func <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; func, BinderArgs &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> binder&lt;Func, BinderArgs...&gt;( func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;BinderArgs&gt;( args )... ); } }</code> </pre> <br>  Here binder is a template class that has a parentheses operator defined.  In addition, the binder's task is to store all the arguments passed to it to the input.  For ease of implementation, it will do so by value.  Note that std :: bind stores arguments also by value, unless you ask it otherwise. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... template&lt;typename Func, typename... BinderArgs&gt; struct binder { binder( Func const &amp; func, BinderArgs &amp;&amp;... binderArgs ) : m_func{ func} , m_args{ std::forward&lt;BinderArgs&gt;(binderArgs)... } {} template&lt;typename... Args&gt; void operator()( Args &amp;&amp;... args ) const { // ... } // ... private: invoker_t m_invoker; Func m_func; args_list&lt;BinderArgs...&gt; m_args; }; // ...</span></span></code> </pre> <br>  Here naive :: args_list resembles std :: tuple very remotely.  Its task is to store an arbitrary number of arguments of arbitrary types.  It is clear that standard containers like std :: vector, list, deque, ... are not suitable for this.  The following is the implementation of naive :: args_list. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// arg        args_list. //    std::size_t ,     //     template&lt;std::size_t, typename T&gt; struct arg { explicit arg( T val ) : value( val ) {} T const value; }; template&lt;typename,typename...&gt; struct args_list_impl; template&lt;std::size_t... Indices, typename... Args&gt; struct args_list_impl&lt;indices&lt;Indices...&gt;, Args...&gt; : arg&lt;Indices, Args&gt;... { template&lt;typename... OtherArgs&gt; args_list_impl( OtherArgs &amp;&amp;... args ) : arg&lt;Indices, Args&gt;( std::forward&lt;OtherArgs&gt;(args) )... {} }; template&lt;typename... Args&gt; struct args_list : args_list_impl&lt; typename make_indices&lt; sizeof...( Args )&gt;::type, Args... &gt; { using base_t = args_list_impl&lt; typename make_indices&lt; sizeof...( Args ) &gt;::type, Args... &gt;; template&lt;typename... OtherArgs&gt; args_list( OtherArgs &amp;&amp;... args ) : base_t( std::forward&lt;OtherArgs&gt;(args)... ) {} };</span></span></code> </pre> <br>  The additional template parameter of the whole type of the naive :: arg structure is needed in order to distinguish several arguments with the same types (the types are the same, the indices are different).  By the way, the arguments in binder when calling its operator "parentheses" are passed using args_list (though there is a little trick in case of an empty list). <br><br>  Moving on.  The parentheses operator is defined in the body of the naive :: binder class, which redirects the call to the appropriate invoker ("caller") depending on the callable object passed to the input.  There are two possible options: either the ‚Äúnormal‚Äù function was transferred and then it should be called like this (free_function_invoker): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>...Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; func, Args &amp;&amp;... args )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)... ); }</code> </pre> <br>  or a member function of the class was passed and then the call will be like this (member_function_invoker): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>...Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; func, ObjType &amp;&amp; obj, Args &amp;&amp;... args )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (obj.*func)( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)... ); }</code> </pre><br>  What type of "caller" to use is determined at the design stage of the binder. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">invoker_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_member_function_pointer&lt;Func&gt;::value, member_function_invoker, free_function_invoker &gt;;</code> </pre> <br>  Now the fun part.  How to implement the operator "parentheses" in Binder.  First, look at the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... BinderArgs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... template&lt;typename... Args&gt; void operator()( Args &amp;&amp;... args ) const { // need check: sizeof...(Args) should not be less than max placeholder value call_function( make_indices&lt; sizeof...(BinderArgs) &gt;{}, std::forward&lt;Args&gt;(args)... ); } private: template&lt; std::size_t... Indices, typename... Args &gt; void call_function( indices&lt;Indices...&gt; const &amp;, Args &amp;&amp;... args ) const { struct empty_list { empty_list( Args &amp;&amp;... args ) {} }; using args_t = conditional_t&lt; sizeof...(Args) == 0, empty_list, args_list&lt;Args...&gt; &gt;; args_t const argsList{ std::forward&lt;Args&gt;(args)... }; m_invoker.invoke( m_func, take_argument( get_arg&lt;Indices,BinderArgs...&gt;( m_args ), argsList )... ); } // ... };</span></span></code> </pre> <br>  The get_arg &lt;I, BinderArgs ...&gt; function simply returns the ith element from the args_list &lt;BinderArgs ...&gt; list obtained by constructing naive :: binder. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_at_index</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_at_index&lt;I<span class="hljs-number"><span class="hljs-number">-1</span></span>, Tail...&gt;::type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_at_index</span></span></span><span class="hljs-class">&lt;0, Head, Tail...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Head; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type_at_index_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_at_index&lt;I, Args...&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">type_at_index_t</span></span>&lt;I, Args...&gt; get_arg( args_list&lt;Args...&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; args ) { arg&lt; I, <span class="hljs-keyword"><span class="hljs-keyword">type_at_index_t</span></span>&lt;I, Args...&gt; &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; argument = args; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> argument.value; };</code> </pre><br>  Now consider take_arg.  There are two overloads of this function, one of which is necessary for working with placeholders, the other for all other cases.  For example, if std :: placeholders :: _ N was passed to the constructor when creating a Binder, then when calling the operator, Binder will substitute std :: placeholders :: _ N instead of the N-th argument passed to the input.  In all other cases, the binder will ignore the arguments passed to the ‚Äúparentheses‚Äù operator and will substitute the corresponding values ‚Äã‚Äãreceived by it in the constructor. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take_argument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; arg, S </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; args )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_placeholder&lt;T&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt; I != <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;::type &gt; <span class="hljs-keyword"><span class="hljs-keyword">type_at_index_t</span></span>&lt;I<span class="hljs-number"><span class="hljs-number">-1</span></span>, Args...&gt; take_argument( T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ph, args_list&lt;Args...&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_arg&lt; I<span class="hljs-number"><span class="hljs-number">-1</span></span>, Args... &gt;( args ); }</code> </pre><br>  That's all.  Below are examples of using naive :: bind. <br><br><div class="spoiler">  <b class="spoiler_title">Examples of using</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"binder.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; void Print( std::string const &amp; msg ) { std::cout &lt;&lt; "Print(): " &lt;&lt; msg &lt;&lt; std::endl; } struct A { void Print( std::string const &amp; msg ) { std::cout &lt;&lt; "A::Print(): " &lt;&lt; msg &lt;&lt; std::endl; } }; int main() { std::string const hello {"hello"}; auto f = naive::bind( &amp;Print, hello ); auto f2 = naive::bind( &amp;Print, std::placeholders::_1 ); f(); f2( hello ); A a; auto f3 = naive::bind( &amp;A::Print, std::placeholders::_2, std::placeholders::_1 ); auto f4 = naive::bind( &amp;A::Print, std::placeholders::_1, hello ); auto f5 = naive::bind( &amp;A::Print, a, std::placeholders::_1 ); auto f6 = naive::bind( &amp;A::Print, a, hello ); f3( hello, a ); f4( a ); f5( hello ); f6(); return 0; }</span></span></span></span></code> </pre></div></div><br>  It is clear that naive :: bind is a naive (see the name of the post) implementation of std :: bind and does not claim to be included in the standard.  Many things could have been implemented differently: for example, instead of args_list, use std :: tuple, differently implement invoker (also called caller in the text), etc.  The purpose of the article was to try to figure out how std :: bind works under the hood, to look at its <i>simplest</i> implementation.  Hope this worked out.  Thanks for attention! <br><br>  ¬ªAll sources can be found on <a href="https://github.com/black-tomato/bind">Github</a> <br>  ¬ªCompile everything g ++ - 6.2 </div><p>Source: <a href="https://habr.com/ru/post/310270/">https://habr.com/ru/post/310270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310260/index.html">3CX Enterprise Edition, an extension for Chrome CallVia3CX, integration with Zendesk and improved Webmeeting infrastructure</a></li>
<li><a href="../310262/index.html">15 most popular programming languages ‚Äã‚Äãaccording to GitHub</a></li>
<li><a href="../310264/index.html">How I started writing third-party projects to gain experience</a></li>
<li><a href="../310266/index.html">As the heroes of the game OverWatch once bald, and we returned them the hair</a></li>
<li><a href="../310268/index.html">REST server and thin client using vibe-d</a></li>
<li><a href="../310276/index.html">Embedding functional objects, functions and lambdas through templates and unification using virtual in C ++</a></li>
<li><a href="../310278/index.html">Gitlab-CI and Ansible-lint syntax checking</a></li>
<li><a href="../310282/index.html">The second wave of fateful changes GitHub</a></li>
<li><a href="../310284/index.html">React.js: build an isomorphic / universal application from scratch. Part 2: add bootstrap, pages and routing</a></li>
<li><a href="../310286/index.html">What links to use: absolute or relative?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>