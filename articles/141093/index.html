<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How big are arrays (and values) in PHP? (Hint: VERY BIG)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I want to examine the memory consumption of arrays (and values ‚Äã‚Äãin general) in PHP using the following script as an example, which c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How big are arrays (and values) in PHP? (Hint: VERY BIG)</h1><div class="post__text post__text-html js-mediator-article">  In this article, I want to examine the memory consumption of arrays (and values ‚Äã‚Äãin general) in PHP using the following script as an example, which creates 100,000 unique integer array elements and at the end measures the amount of memory used. <br><a name="habracut"></a><br>  <i><b>This is a translation (for people like me who often do not notice this).</b></i> <br><br>  At the beginning, I want to thank <a href="http://schlueters.de/blog/">Johannes</a> and <a href="http://www.tyrael.hu/">Tyrael</a> for their help in finding <a href="http://www.tyrael.hu/">hidden places</a> to <a href="http://www.tyrael.hu/">waste</a> memory. <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $startMemory = memory_get_usage(); $array = range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() - $startMemory, <span class="hljs-string"><span class="hljs-string">' bytes'</span></span>;</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How much do you think it will be?  If the integer is 8 bytes (on 64 architectures and using the long type) and there are 100,000 integers, then obviously 800,000 bytes are required.  This is about 0.76 MB. <br><br>  Now try running the code.  <a href="http://codepad.viper-7.com/">This can be done on-line.</a>  The result is 14,649,024 bytes.  Yes, you heard right, it is 13.97 MB - 18 times more than we estimated. <br><br>  So where does this 18-fold increase come from? <br><br><h2>  Summary </h2><br><br>  For those who do not want to deal with all of this, here is a brief overview of the components involved. <br><br><pre> <code class="hljs ruby"> <span class="hljs-params"><span class="hljs-params">| 64 bit |</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> bit --------------------------------------------------- zval <span class="hljs-params"><span class="hljs-params">| 24 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> bytes + cyclic GC info <span class="hljs-params"><span class="hljs-params">| 8 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> bytes + allocation header <span class="hljs-params"><span class="hljs-params">| 16 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> bytes =================================================== zval (value) total <span class="hljs-params"><span class="hljs-params">| 48 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> bytes =================================================== bucket <span class="hljs-params"><span class="hljs-params">| 72 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> bytes + allocation header <span class="hljs-params"><span class="hljs-params">| 16 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> bytes + pointer <span class="hljs-params"><span class="hljs-params">| 8 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> bytes =================================================== bucket (array element) total <span class="hljs-params"><span class="hljs-params">| 96 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span> bytes =================================================== total total <span class="hljs-params"><span class="hljs-params">| 144 bytes |</span></span> <span class="hljs-number"><span class="hljs-number">76</span></span> bytes</code> </pre><br><br>  The numbers above may vary depending on your operating system, compiler and compilation options.  For example, if you compile PHP with debug or thread-safety, you will get different values.  But I think that you will see the given sizes on an ordinary PHP 5.3 build on 64-bit Linux. <br><br>  If you multiply these 144 bytes by our 100,000 numbers, you get 14,400,000 bytes, which is 13.73 MB.  Pretty close to the actual result, the rest is mostly pointers for uninitialized blocks (buckets), but I will tell about this later. <br><br>  Now, if you want to have a more detailed analysis of the values ‚Äã‚Äãthat are listed above, then read on :). <br><br><h2>  Union zvalue_value </h2><br><br>  First, let's take a look at how PHP stores values.  As you know, PHP is a weakly typed language, so it needs a way to quickly switch between values.  PHP uses a union, which is defined as follows: <a href="">zend.h # 307</a> (my comments): <br><br><pre> <code class="hljs ruby">typedef union _zvalue_value { long lval; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     double dval; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      struct { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   char *val; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      int len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } str; HashTable *ht; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   (-) zend_object_value obj; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } zvalue_value;</code> </pre><br><br>  If you do not know C, then this is not a problem - the code is very simple: combining means that a value can act in the role of various types.  For example, if you use <i>zvalue_value-&gt; lval</i> , then the value will be interpreted as an integer.  On the other hand, if you use <i>zvalue_value-&gt; ht</i> , then the value will be interpreted as a pointer to a hash table (aka array). <br><br>  We will not linger on this.  What is important for us is that the size of the union is equal to the size of its largest component.  The largest component is a string (in fact, the structure of <i>zend_object_value</i> is also the size, but I will omit this moment for simplicity).  The structure consists of a pointer (8 bytes) and an integer (4 bytes).  Total 12 bytes.  Thanks to memory alignment (12-byte structures are not cool, because they are not 64-bit / 8-byte products), the final structure size will be 16 bytes and, accordingly, the entire union as a whole. <br><br>  So, now we know that we need not 8 bytes for each value, but 16 - due to the dynamic typing of PHP.  Multiplying by 100,000 yields 1,600,000 bytes, i.e.  1.53 MB.  But the real volume is 13.97 MB, so we have not reached the goal yet. <br><br><h2>  Zval structure </h2><br><br>  It is quite logical that the union stores only the value, and PHP obviously needs to store its type and some information for garbage collection.  The structure that contains this information is called <i>zval</i> and you have probably already heard about it.  For more information on why this is PHP, I recommend reading the <a href="http://blog.golemon.com/2007/01/youre-being-lied-to.html">Sara Golemon article</a> .  However, this structure <a href="">is defined as follows</a> : <br><br><pre> <code class="hljs ruby">struct _zval_struct { zvalue_value value; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  zend_uint refcount__gc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ( GC) zend_uchar type; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  zend_uchar is_ref__gc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (&amp;) };</code> </pre><br><br>  The size of the structure is determined by the sum of the sizes of all its components: <i>zvalue_value</i> - 16 bytes (calculation above), <i>zend_uint</i> - 4 bytes, <i>zend_uchar</i> - 1 byte each.  A total of 22 bytes.  Again, due to memory alignment, the actual size will be 24 bytes. <br><br>  So, if we store 100,000 values ‚Äã‚Äãof 24 bytes each, it will be 2,400,000 bytes or 2.29 MB.  The gap is shrinking, but the real value is still more than six times larger. <br><br><h2>  Circular link garbage collector (PHP 5.3) </h2><br><br>  PHP 5.3 introduced a <a href="http://php.net/manual/ru/features.gc.collecting-cycles.php">new garbage collection for circular references</a> .  For this, PHP stores some additional information.  I do not want to explain here how it works, you can get the necessary information from the manual.  For our sizing calculations, it is important that each <i>zval</i> turns <i>into zval_gc_info</i> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_gc_info</span></span></span><span class="hljs-class"> {</span></span> zval z; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { gc_root_buffer *buffered; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_gc_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> } u; } zval_gc_info;</code> </pre><br><br>  As you see, Zend only adds a union that contains two pointers.  As you remember the size of the union is determined by the largest component.  Both components are 8 byte pointers.  Accordingly, the size of the union is also 8 bytes. <br><br>  If we add the 24 bytes received above, we will get 32 ‚Äã‚Äãbytes.  Multiply this by 100,000 and get 3.05 MB. <br><br><h2>  ZEND Memory Manager </h2><br><br>  C, unlike PHP, does not manage memory for you.  You must independently monitor the allocation of memory.  For this, PHP uses its own memory manager optimized for its needs: <a href="http://php.net/manual/en/internals2.memory.php">The Zend Memory Manager</a> .  MM Zend is based on <a href="http://g.oswego.edu/dl/html/malloc.html">mallocs from Doug Lea</a> and all additional PHP-specific features and optimizations (such as memory constraints, cleanup after each request, and the like). <br><br>  What is important to us in this is that MM adds a header for each memory allocation that passes through it.  And is defined <a href="">as follows</a> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_mm_block</span></span></span><span class="hljs-class"> {</span></span> zend_mm_block_info info; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ZEND_DEBUG unsigned int magic; # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS THREAD_T thread_id; # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> zend_mm_debug_info debug; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> ZEND_MM_HEAP_PROTECTION zend_mm_debug_info debug; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } zend_mm_block; typedef struct _zend_mm_block_info { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ZEND_MM_COOKIES size_t _cookie; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> size_t _size; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   size_t _prev; //   (   ) } zend_mm_block_info;</span></span></span></span></code> </pre><br><br>  As you can see the definition includes many checks on compilation options.  If at least one of these options is enabled, the header for the allocated memory will be larger, and it will be the biggest if you compile PHP with heap protection, thread safety, debugging and MM cookies. <br><br>  For example, we will assume that all these options are disabled.  In this case, there are only two components <i>size_t</i> <i>_size</i> and <i>_prev</i> .  <i>The size_t is</i> 8 bytes (64 bits), so the header is 16 bytes in size - and this header is added for <i>each</i> memory allocation. <br><br>  So we need to adjust the size of the <i>zval</i> again.  In fact, it will not be 32 bytes, but 48, because of this header.  Multiply by our 100,000 items and we get 4.58 MB.  The real size is 13.97 MB, so we already covered about a third. <br><br><h2>  Blocks </h2><br><br>  So far, we have considered the values ‚Äã‚Äãseparately.  But the array structure in PHP takes a lot of space.  In fact, the term "array" is chosen poorly.  In PHP, an array is actually a hash of a table / dictionary.  So how does hash tables work?  Basically, a hash is generated for each key, and this hash is used to go to the ‚Äúreal‚Äù C array.  Hashes can conflict, all items that have the same hash are stored in a linked list.  When accessing an element, PHP first calculates the hash, searches for the necessary block (bucket), and traverses the list looking for an exact match element by element.  The block is defined as follows ( <a href="">zend_hash.h # 54</a> ): <br><br><pre> <code class="hljs ruby">typedef struct bucket { ulong h; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  (    ) uint nKeyLength; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   (  ) void *pData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  void *pDataPtr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ???   ??? struct bucket *pListNext; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> PHP  .     struct bucket *pListLast; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    struct bucket *pNext; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ()   struct bucket *pLast; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ()   const char *arKey; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  (  ) } Bucket;</code> </pre><br><br>  As you can see, it is necessary to store a ‚Äúload‚Äù of data in order to get an abstract array of data like the one used in PHP (PHP arrays are arrays, dictionaries and linked lists at the same time, which, of course, requires a lot of data).  The size of the individual components is: 8 bytes for type <i>ulong</i> , 4 bytes for <i>uint,</i> and 7 times 8 bytes for pointers.  The result is 68. Add alignment and get 72 bytes. <br><br>  For blocks as for zval, 16 byte headers should be added, which gives us 88 bytes.  We also need to store pointers to these blocks in a ‚Äúreal‚Äù C array (Bucket ** arBuckets;), I mentioned this above, which adds another 8 bytes per element.  So in general, each block consumes 96 bytes of memory. <br><br>  And so, if we need a block for each value, it will be 96 bytes for the <i>bucket</i> and 48 bytes for the <i>zval</i> , which is 144 bytes in total.  For 100,000 items, this will be 14,400,000 bytes, or 13.73 MB. <br><br>  Riddle solved. <br><br><h2>  Wait, there is still 0.24 MB! </h2><br><br>  These last 0.24 MB are due to uninitialized blocks: the size of the ‚Äúreal‚Äù array C should ideally be equal to the number of elements.  This way we get the least amount of collisions (unless you want to spend a lot of memory).  But PHP obviously cannot redistribute the entire array every time a new element is added - that would be sooo slow.  Instead, PHP always doubles the size of the internal block array if it falls within the limit.  Thus, the size of the array is always a power of two. <br><br>  In our case, this is 2 ^ 17 = 131,072. But we only need 100,000 of these blocks, so we leave 31,072 blocks unused.  Those memory for these blocks will not be allocated (so we do not need to spend the full 96 bytes), but the memory under the pointer (which is stored in the internal array of blocks) on the block should be used.  Therefore, we additionally use 8 bytes (per pointer) * 31,072 elements.  This is 248,576 bytes or 0.23 MB.  What corresponds to the missing memory.  (Of course, there are a few more bytes missing, but I don‚Äôt want to completely cover everything. These are such things as the hash table structure itself, variables, etc.) <br><br>  The riddle is really solved. <br><br><h2>  What does this tell us? </h2><br><br>  PHP is not C. And that only tells us that.  You can‚Äôt expect effective memory usage like in C from the super dynamic PHP language. That's all you can do. <br><br>  But, if you want to save memory, you can consider using <b>SplFixedArray</b> for large static arrays. <br><br>  Let's look at the modified script: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $startMemory = memory_get_usage(); $array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SplFixedArray(<span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; ++$i) { $array[$i] = $i; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> memory_get_usage() - $startMemory, <span class="hljs-string"><span class="hljs-string">' bytes'</span></span>;</code> </pre><br><br>  It basically does the same thing, but if you run it, you will notice that it uses ‚Äúonly‚Äù 5,600,640 bytes.  What is 56 bytes per element, and it is much less than 144 bytes per element of a regular array.  This is because a fixed array does not need a <i>bucket</i> structure: so only one <i>zval</i> (48 bytes) and one pointer (8 bytes) are required for each element, which will give us the observed 56 bytes. <br><br>  <i><b>PS I ask you to write all comments on the translation in the LAN, and I will try to correct them promptly.</b></i> </div><p>Source: <a href="https://habr.com/ru/post/141093/">https://habr.com/ru/post/141093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141087/index.html">LG Cinema 3D 2012 - new design, new filling, new quality 3D video</a></li>
<li><a href="../141088/index.html">Installing Hackintosh on the example of Packard Bell TM85</a></li>
<li><a href="../141089/index.html">Online courses Stanford University, Berkley and MIT in an accessible form</a></li>
<li><a href="../141090/index.html">A child in a family geek or baby monitor with his own hands</a></li>
<li><a href="../141091/index.html">Google will sell tablets via online store</a></li>
<li><a href="../141094/index.html">WebMoney on Mac</a></li>
<li><a href="../141095/index.html">How does the injector work?</a></li>
<li><a href="../141096/index.html">Video review tablet Samsung Series 7 Slate</a></li>
<li><a href="../141097/index.html">Microsoft requires manufacturers to take seriously the quality of touch panels for Windows 8</a></li>
<li><a href="../141098/index.html">Alternativa3D is now open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>