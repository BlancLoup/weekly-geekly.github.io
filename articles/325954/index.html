<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET Managed + C unmanaged: what is the price?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When programming in C #, I often put out resource-intensive tasks in unmanaged C code, because the performance of .NET caused questions. And over a cu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET Managed + C unmanaged: what is the price?</h1><div class="post__text post__text-html js-mediator-article">  When programming in C #, I often put out resource-intensive tasks in unmanaged C code, because the performance of .NET caused questions.  And over a cup of tea, the following questions began to go to my mind: What is the real gain from this code separation?  Is it possible to win something, and if so how much?  What is the best way to build an API with this approach? <br><br>  After some time, I still took the time to study this issue in more detail, and I want to share my observations with you. <br><a name="habracut"></a><br>  <b>What for?</b> <br><br>  This question will be asked by any self-respecting programmer.  To run the project in two different languages ‚Äã‚Äãis a very dubious business, especially unmanaged code is really difficult to implement, debug and support.  But only the ability to implement functionality that will work faster is worthy of consideration, especially in critical areas or in highly loaded applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another possible answer: the functionality is already implemented in the unamaged form!  Why rewrite the solution entirely, if you can not wrap everything in .NET and use it from there, not at a very high cost? <br><br>  In a nutshell - this really happens.  And we just see what and how. <br><br>  <b>Lyrics</b> <br><br>  All code was written in Visual Studio Community 2015. For evaluation, I used my work-gaming computer, with i5-3470 on board, 12-gigabytes of 1333MHz dual-channel RAM, and also a hard disk at 7200 rpm.  Measurements were made using System.Diagnostics.Stopwatch, which is more accurate to DateTime, because it is implemented on top of PerformanceCounter.  The tests were run on the Release versions of the builds to eliminate the possibility that in reality everything will be a little different.  The version of the .NET framework 4.5.2, and the C ++ project was compiled with the / TC flag (Compile as C). <br><br>  I apologize in advance for the abundance of code, but without it it will be difficult to understand exactly what I wanted.  Most of the too tedious or insignificant code I took out into spoilers, and the other part was cut out of the article altogether (initially it was even longer). <br><br>  <b>Function call</b> <br><br>  I decided to start my research with measuring the speed of calling functions.  There were several reasons for this.  First, the functions will still have to be called, and the functions from the loaded dll are not called very quickly, compared to the code in the same module.  Secondly, most of the existing C # wrappers are implemented on top of any unmanaged code (for example, <b><i>sharpgl</i></b> , <b><i>openal-cs</i></b> , <i><s>and sharpdx has gone the wrong way</s></i> ).  Actually, this is the most obvious way to embed unmanaged code, and the easiest one. <br><br>  Before you start measuring directly, you need to think about how we will store and evaluate the results of our measurements.  ‚ÄúCSV!‚Äù, I thought, and wrote a simple class for storing data in this format: <br><br><div class="spoiler">  <b class="spoiler_title">Simple implementation of CSV</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CSVReport</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columnsCount; StreamWriter writer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CSVReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] header</span></span></span><span class="hljs-function">)</span></span> { columnsCount = header.Length; writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(path); writer.Write(header[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; header.Length; i++) writer.Write(<span class="hljs-string"><span class="hljs-string">","</span></span> + header[i]); writer.Write(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] values</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (values.Length != columnsCount) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Columns count for row didn't match table columns count"</span></span>); writer.Write(values[<span class="hljs-number"><span class="hljs-number">0</span></span>].ToString()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; values.Length; i++) writer.Write(<span class="hljs-string"><span class="hljs-string">","</span></span> + values[i].ToString()); writer.Write(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { writer.Close(); } }</code> </pre> <br></div></div><br>  Not the most functional option, but for my purpose it will go with interest.  And for testing, it was decided to write a simple class that can only summarize the numbers and store the result.  This is how it looks like: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Summer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Sum { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Summer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { Sum += a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br>  But this is a manageable option.  We also need more uncontrollable.  Therefore, we create a template dll project and immediately add a file there, for example, api.h, into which we push export definitions: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _API_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _API_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXPORT __declspec(dllexport) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_API __stdcall #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Let us put summer.c alongside, and implement all the functionality we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"api.h"</span></span></span><span class="hljs-meta"> int sum; EXPORT void STD_API summer_init( void ) { sum = 0; } EXPORT void STD_API summer_add( int value ) { sum += value; } EXPORT int STD_API summer_sum( void ) { return sum; }</span></span></code> </pre> <br>  Now we need a wrapper class over this disgrace: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SummerUnmanaged</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> dllName = @<span class="hljs-string"><span class="hljs-string">"unmanaged_test.dll"</span></span>; [DllImport(dllName)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summer_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; [DllImport(dllName)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summer_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span></span>; [DllImport(dllName)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summer_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Sum { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summer_sum(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SummerUnmanaged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ summer_init(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ summer_add(a); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ summer_init(); } }</code> </pre> <br>  The result was exactly what I wanted.  There are two absolutely identical implementations to use: one in C #, the second in C.  Now you can and see what comes of it!  Let's write a code that measures the execution time of n calls of one and another class: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Function calls..."</span></span>); Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); Summer s_managed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Summer(); SummerUnmanaged s_unmanaged = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SummerUnmanaged(); Random r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; CSVReport report = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSVReport(<span class="hljs-string"><span class="hljs-string">"fun_call.csv"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"C# managed"</span></span>, <span class="hljs-string"><span class="hljs-string">"C unmanaged"</span></span>); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">1000000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; j++) data[j] = r.Next(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   for (int i=0; i&lt;100; i++) { //       Console.Write("\r{0}/100", i+1); int length = 10000*i; long managedTime = 0, unmanagedTime = 0; Thread.Sleep(10); s_managed.Reset(); sw.Start(); for (int j = 0; j &lt; length; j++) { s_managed.Add(data[j]); } sw.Stop(); managedTime = sw.ElapsedTicks; sw.Reset(); sw.Start(); for(int j=0; j&lt;length; j++) { s_unmanaged.Add(data[j]); } sw.Stop(); unmanagedTime = sw.ElapsedTicks; report.Write(length, managedTime, unmanagedTime); } report.Dispose(); Console.WriteLine(); }</span></span></code> </pre> <br>  It remains only to call this function somewhere in Maine, and look at the report in fun_call.csv.  For clarity, I will not give the boring and dry numbers, but will only display a graph.  Vertically - time in ticks, horizontally - the number of function calls. <br><br><img src="https://habrastorage.org/files/cb2/035/93c/cb203593c2fe4e95915ff6de45e25909.png"><br><br>  The result surprised me a little.  C # was clearly the favorite in this test.  Still, the same module, and the ability to inline ... but as a result, both options turned out to be approximately the same.  Actually, in this case, this separation of the code turned out to be meaningless - they did not win anything, and the project was complicated. <br><br>  <b>Arrays</b> <br><br>  Reflections on the results were not long, and I immediately realized that you need to send data not in a single element, but in arrays.  It's time to upgrade the code.  We add a functional: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddMany</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = data.Length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) Sum += i; }</code> </pre> <br>  And, actually, C part: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> STD_API </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summer_add_many</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++ ) sum += data[ i ]; }</code> </pre> <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(dllName)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summer_add_many</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddMany</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data</span></span></span><span class="hljs-function">)</span></span> { summer_add_many(data, data.Length); }</code> </pre> <br>  Accordingly, it was necessary to rewrite the function of measuring performance.  The full version is in the spoiler, and in two words: now we generate an array of n random elements and call the function of their addition. <br><br><div class="spoiler">  <b class="spoiler_title">New performance measurement feature</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArrays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Arrays..."</span></span>); Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); Summer s_managed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Summer(); SummerUnmanaged s_unmanaged = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SummerUnmanaged(); Random r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; CSVReport report = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSVReport(<span class="hljs-string"><span class="hljs-string">"arrays.csv"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"C# managed"</span></span>, <span class="hljs-string"><span class="hljs-string">"C unmanaged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { Console.Write(<span class="hljs-string"><span class="hljs-string">"\r{0}/100"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">10000</span></span> * i; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> managedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>, unmanagedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; length; j++) <span class="hljs-comment"><span class="hljs-comment">//   data[j] = r.Next(-1, 2); s_managed.Reset(); sw.Start(); s_managed.AddMany(data); sw.Stop(); managedTime = sw.ElapsedTicks; sw.Reset(); sw.Start(); s_unmanaged.AddMany(data); sw.Stop(); unmanagedTime = sw.ElapsedTicks; report.Write(length, managedTime, unmanagedTime); } report.Dispose(); Console.WriteLine(); }</span></span></code> </pre> <br></div></div><br>  Run, check the report.  Vertically, there is still time in ticks, horizontally - the number of elements in the array. <br><br><img src="https://habrastorage.org/files/b69/a1d/9cc/b69a1d9ccccc46ccbf1a07eb4c057682.png"><br><br>  It can be seen with the naked eye - C copes with banal processing of arrays much better.  But this is the price for ‚Äúcontrollability‚Äù - while the managed code in the event of overflow, overrun of the array, <s>mismatch of the moon phase with the phase of Mars</s> gently throws an exception, then the C code can easily overwrite its memory and pretend that's the way it should be. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrics</b> <div class="spoiler_text">  By the way, I could not come to a reasonable conclusion about why the graphics are so uneven.  Probably, GC phases or other processes eat up CPU time, but this is not accurate.  Nevertheless, even a simple averaging shows that C is many times faster in a particular case. <br></div></div><br>  <b>Reading file</b> <br><br>  After making sure to process large data arrays in C faster, I decided to read the files.  This decision was caused by the desire to check how quickly the code can communicate with the system. <br><br>  For these purposes, I generated a stack of files (of course, linearly increasing in size) <br><br><div class="spoiler">  <b class="spoiler_title">Generating files</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Random r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.OpenWrite(<span class="hljs-string"><span class="hljs-string">"file"</span></span> + i.ToString())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">200000</span></span>*i; j++) { writer.Write(r.Next(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } writer.Close(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Generating {0}"</span></span>, i); } }</code> </pre> <br></div></div><br>  As a result, the largest file turned out 75 megabytes, which was quite enough for yourself.  For the test, I did not allocate a separate class, and on the <s>cattle is a</s> coded directly into the Maine class.  Why not, actually. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { BinaryReader br = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length = br.BaseStream.Length; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(br.BaseStream.Position != length) { sum += br.ReadInt32(); } br.Close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  As you can see from the code, I set the task as follows: sum up all the integers from the file.  Relevant implementation in C: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> STD_API </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* path )</span></span></span><span class="hljs-function"> </span></span>{ FILE *f = fopen( path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !f ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !feof( f ) ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add; fread( &amp;add, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ), <span class="hljs-number"><span class="hljs-number">1</span></span>, f ); sum += add; } fclose( f ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Now it remains to cyclically read all the files, but measure the speed of each implementation.  I will not give the code of the measurement function (I can make it myself) and proceed directly to visual demonstrations. <br><br><img src="https://habrastorage.org/files/391/af9/5c8/391af95c820d4621aaabb4f7f03199a5.png"><br><br>  As can be seen from this graph, C was a little faster (about one and a half times).  But winning is winning. <br><br>  Somewhere at this moment I was carried a little to the steppe (or somewhere else), but I cannot not share these thoughts.  Curious please spoiler, and all the rest, please go to the next part of my research. <br><br><div class="spoiler">  <b class="spoiler_title">Steppe</b> <div class="spoiler_text">  The time of reading the files terrified me.  An experienced programmer will immediately tell you what is wrong with my code - it <i>too</i> often accesses the system for data from a file.  It is slow, very slow.  As a result, I slightly upgraded the reading algorithm, adding forced buffering to 400Kb of data from the file, which noticeably accelerated everything.  Relevant changes in C and C # code: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length = br.BaseStream.Length; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">100000</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(br.BaseStream.Position != length) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read = br.Read(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;read; i+=<span class="hljs-number"><span class="hljs-number">4</span></span>) { sum += BitConverter.ToInt32(buffer, i); } }</code> </pre> <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>( <span class="hljs-number"><span class="hljs-number">100000</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !feof( f ) ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read = fread( buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ), <span class="hljs-number"><span class="hljs-number">100000</span></span>, f ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; read; i++ ) { sum += buffer[ i ]; } }</code> </pre> <br>  I did not want to include this test in the ‚Äúbasis‚Äù of the article, and there was one reason for this: the test is not entirely fair.  C was obviously better suited for such a task, because he could write anything and anywhere, but in C # I had to convert everything byte-by-by, because of what I got what I got: <br><br><img src="https://habrastorage.org/files/aac/b8b/5b3/aacb8b5b3e7f46dfb79f66385477a2bf.png"><br><br>  I am inclined to think that such a performance difference is caused precisely by the need to additionally convert bytes into words.  In general, this topic deserves a separate article, which I can even write. <br></div></div><br>  <b>Return arrays</b> <br><br>  The next step in performance measurements was the return of more complex types, because it would not always be convenient to communicate with integers and floating point numbers.  Therefore, you need to check how quickly you can bring unmanaged memory to managed.  To this end, it was decided to implement a simple task: reading the entire file and returning its contents as an array of bytes. <br><br>  On pure C #, such a task is implemented quite simply, but in order to associate C code with C # code, in this case you will have to do something else. <br><br>  First, a C # solution <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileRead</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { BinaryReader br = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] ret = br.ReadBytes((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)br.BaseStream.Length); br.Close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  And the corresponding decision on C: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* STD_API </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* read )</span></span></span><span class="hljs-function"> </span></span>{ FILE *f = fopen( path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !f ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fseek( f, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_END ); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length = ftell( f ); fseek( f, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET ); read = length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>( length ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read_f = fread( buffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, length, f ); fclose( f ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  To successfully call such a function from C #, we will have to write a wrapper that will call this function, copy the data from the unmanaged memory to the managed one, and free the unmanaged section: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileReadUnmanaged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; IntPtr unmanaged = file_read(path, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> length); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] managed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; Marshal.Copy(unmanaged, managed, <span class="hljs-number"><span class="hljs-number">0</span></span>, length); Marshal.FreeHGlobal(unmanaged); <span class="hljs-comment"><span class="hljs-comment">//     ? return managed; }</span></span></code> </pre> <br>  In the measurement function, only the corresponding calls of the measured functions have changed.  And the result looks like this: <br><br><img src="https://habrastorage.org/files/716/54d/7e8/71654d7e86e44f0ebd35bfe66802fc22.png"><br><br>  Even with the loss of time to copy the memory, C again found himself in the lead, completing the task about 2 times faster.  Honestly, I expected some other results (considering the data of the second test).  Most likely due to the fact that reading data, even in a large packet in C #, is quite slow.  In C, the loss of time goes by copying unmanaged memory into managed memory. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrics</b> <div class="spoiler_text">  A little later, I noticed that Marshal.Free ... crashes in the Debug build.  What caused this I did not understand, but in the Release assembly everything worked as it should and did not flow.  However, the very first test hints that a free call from the C library will have little effect on it. <br></div></div><br>  <b>Real challenge</b> <br><br>  The logical conclusion of all the tests I carried out was this: to implement some full-fledged algorithm in C # and in C.  Performance rate to evaluate. <br><br>  I took the reading of an uncompressed TGA file with 32 bits per pixel, and casting it into a <s>normal</s> RGBA representation (TGA format implies storing color as BGRA).  So that life does not seem to be oil, we will return not bytes, but Color structures: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Color { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> r, g, b, a; }</code> </pre> <br>  The implementation of the algorithm is quite capacious, and it is hardly interesting.  Therefore, it is taken out in the spoiler so as not to be an insult to those who are not interested. <br><br><div class="spoiler">  <b class="spoiler_title">A simple implementation of reading TGA</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGARead</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] header; BinaryReader br = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path)); header = br.ReadBytes(<span class="hljs-number"><span class="hljs-number">18</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = (header[<span class="hljs-number"><span class="hljs-number">13</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + header[<span class="hljs-number"><span class="hljs-number">12</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  ,   short int height = (header[15] &lt;&lt; 8) + header[14]; // Little-Endian,    byte[] data; data = br.ReadBytes(width * height * 4); Color[] colors = new Color[width * height]; for(int i=0; i&lt;width*height*4; i+=4) { int index = i / 4; colors[index].b = data[i]; colors[index].g = data[i + 1]; colors[index].r = data[i + 2]; colors[index].a = data[i + 3]; } br.Close(); return colors; } static Color[] TGAReadUnmanaged(string path) { int width = 0, height = 0; IntPtr colors = tga_read(path, ref width, ref height); IntPtr save = colors; Color[] ret = new Color[width * height]; for(int i=0; i&lt;width*height; i++) { ret[i] = Marshal.PtrToStructure&lt;Color&gt;(colors); colors += 4; } Marshal.FreeHGlobal(save); return ret; }</span></span></code> </pre><br>  And Sishny option: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"api.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;stdio.h&gt; //   ,    //   4  typedef struct { char r, g, b, a; } COLOR; // ,     #pragma pack(push) #pragma pack(1) typedef struct { char idlength; char colourmaptype; char datatypecode; short colourmaporigin; short colourmaplength; char colourmapdepth; short x_origin; short y_origin; short width; short height; char bitsperpixel; char imagedescriptor; } TGAHeader; #pragma pack(pop) EXPORT COLOR* tga_read( const char* path, int* width, int* height ) { TGAHeader header; FILE *f = fopen( path, "rb" ); fread( &amp;header, sizeof( TGAHeader ), 1, f ); COLOR *colors = malloc( sizeof( COLOR ) * header.height * header.width ); fread( colors, sizeof( COLOR ), header.height * header.width, f ); for ( int i = 0; i &lt; header.width * header.height; i++ ) { char t = colors[ i ].r; colors[ i ].r = colors[ i ].b; colors[ i ].b = t; } fclose( f ); return colors; }</span></span></span></span></code> </pre> <br></div></div><br>  Now it's up to small.  Draw a simple TGA image and load it n times.  The result is as follows (vertically as usual, horizontally - the number of file reads). <br><br><img src="https://habrastorage.org/files/86c/60d/edb/86c60dedb9ed4193835767465180ea6d.png"><br><br>  Here it should be noted that I brazenly used the possibilities of C in his favor.  Reading from the file directly into the structures has made life much easier (and in the case when the structures are not aligned with 4 bytes, there will be fun debugging).  However, I am pleased with the result.  Such an uncomplicated algorithm turned out to be efficiently implemented in C, and effectively used in C #.  Accordingly, I received an answer to the original question: you can really win, but not always.  Sometimes you can win slightly, sometimes not win at all, and sometimes win several times and more. <br><br>  <b>Dry residue</b> <br><br>  In general, the very idea of ‚Äã‚Äãcarrying out the implementation of something in another language is doubtful, as I wrote at the very beginning.  In the end, the application of this method of code acceleration can be found quite a bit.  If opening a file starts to hang UI - you can put the download in a separate background thread, and then loading even per second will not cause anyone serious difficulties. <br><br>  Accordingly, it is worthwhile to pervert so only when productivity is really necessary, and it is no longer possible to achieve it in other ways (and in such cases they usually write right away to C or C ++).  Or if you already have a ready-made algorithm that you can use, and not reinvent the wheel. <br><br>  It should be noted that a simple wrapper over an unmanaged dll will not give much performance gain, and all the ‚Äúnimbleness‚Äù of unmanaged languages ‚Äã‚Äãbegins to be revealed only when processing large enough data, so you should also pay attention to this.  However, the use of such a wrapper will not become worse. <br><br>  C # does very well with the transfer of managed resources to unmanaged code, but the reverse is not as fast as we would like.  Therefore, frequent data conversion is desirable to avoid and keep unmanaged resources in unmanaged code.  If it is not necessary to edit / read this data in managed code, then IntPtr can be used to store pointers, and the rest of the work can be rendered entirely in unmanaged code. <br><br>  Of course, it is possible (and even necessary) to conduct additional research before making a final decision on the transfer of code to unmanaged assemblies.  But with current information you can decide on the appropriateness of such actions. <br><br>  And on this I have everything.  Thank you if you have read to the end! </div><p>Source: <a href="https://habr.com/ru/post/325954/">https://habr.com/ru/post/325954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325942/index.html">Real-time Web application for simple devices</a></li>
<li><a href="../325944/index.html">We invite you to the Imagine Cup: April 15, 2017 will be the Russian final of the competition</a></li>
<li><a href="../325946/index.html">The evolution of CRM-systems</a></li>
<li><a href="../325950/index.html">Android application integration with fiscal printer and card reader</a></li>
<li><a href="../325952/index.html">These mysterious capacitors</a></li>
<li><a href="../325956/index.html">From Root CA to User Authorization in nginx + apache. Part 1. Create a Root & Intermediate Certificate Authority</a></li>
<li><a href="../325958/index.html">It is no exaggeration to say that this is a hyperbole</a></li>
<li><a href="../325960/index.html">Free plugins, tools and services for the development of a game on a unit</a></li>
<li><a href="../325966/index.html">Kotlin for Android: simplify working with weak links in asynchronous calls</a></li>
<li><a href="../325968/index.html">Archaic video compression algorithms of the era of FMV games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>