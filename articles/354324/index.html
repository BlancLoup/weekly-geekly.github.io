<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Make Windows slower! Part One: File Access</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows OS has long been reproached for the slowness of its file operations and the slow creation of processes. Why not try making them even slower? T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Make Windows slower! Part One: File Access</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/650/50e/566/65050e566a2e096ace4123c16e602f41.jpg" alt="image" align="right">  Windows OS has long been reproached for the slowness of its file operations and the slow creation of processes.  Why not try making them even slower?  This article will show ways to slow down file operations in Windows by about 10 times their normal speed (or even more), and these methods are practically impossible to track by an ordinary user. <br><br>  And yet, of course, we will learn to detect and correct such situations.  The entire text is based on the problem I encountered a couple of months ago, so everything written below is completely real. <br><a name="habracut"></a><br><h3>  Something went wrong </h3><br>  Sometimes the most valuable information that you have when trying to speed things up is the very knowledge that it can be speeded up for sure.  Well, you know, like in school, the problem is solved because it is a problem, which means it must have a solution. <br><br>  When it comes to code that is completely under your control, it's easier here.  You can compare the speed of different versions, rummage, talk to its authors, from a certain stage the intuition led by experience also begins to work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When it comes to the "black box", which, for example, is the implementation of the file system <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a> from Microsoft, it becomes more difficult.  But here you can find some tips: <br><br><ul><li>  You notice that some file operations that used to work quickly suddenly began to work slowly.  They can probably be made to work quickly again. </li><li>  The same file operations sometimes work quickly and sometimes slowly.  Perhaps they can be made to work fast always. </li><li>  When profiling your application, you see good performance of file operations in most cases, except for a few ‚Äúhot‚Äù places, where everything for some reason works much worse than average.  Perhaps you can change your code to avoid this problem. </li></ul><br>  In my case, I noticed all three of the above tips at once, which gave me the opportunity to find the cause of the problems - it turned out to be in one of the tools I used, which was able to slow down file operations in the entire OS.  Together with the <a href="https://github.com/rpaquay">author of</a> this tool we managed to figure out what was in the works and release the fix. <br><br><h3>  Slow file deletion </h3><br>  Again and again <a href="https://www.chromium.org/developers/how-tos/get-the-code">collecting from the</a> Chromium <a href="https://www.chromium.org/developers/how-tos/get-the-code">source</a> , I noticed that cleaning the directory with the build results took a few minutes to complete - this is quite a significant part of the build cycle.  I was sure that this should happen faster.  I also noticed that this problem does not happen if Visual Studio is not running at the time of deleting these files. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Visual Studio was not to blame! <br></div></div><br>  Profiling with ETW did not reveal the obvious culprit, but gave a few tips that led me to believe that <a href="https://github.com/chromium/vs-chromium">VsChromium</a> could be an extension for Visual Studio, which makes working on the Chromium project in Visual Studio more convenient.  One of its important features is to load the entire source code of the project into RAM (for further quick search).  In the case of Chromium, this is several gigabytes of RAM, but the search works in milliseconds.  This extension helps me a lot in my work, but a tenfold slowdown in file operations is not the price I‚Äôm willing to pay for it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/491/2f7/2da4912f713fb233b39056fea45a21d9.png" alt="image"><br><br><h3>  Reproduction problems </h3><br>  To write this article, I emulated a problem by writing a Python script that creates and deletes thousands of files in a folder that is monitored by VsChromium.  By running this script, I collected the event trace with ETW.  Here is a graph of processor usage in WPA ( <a href="https://randomascii.wordpress.com/2012/06/19/wpaxperf-trace-analysis-reimagined/">Windows Performance Analyzer</a> ) and a table with time (in milliseconds).  In total, the script worked for about 5 seconds: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/371/aa7/030371aa7c17461e4974c8fd106c0c2f.png" alt="image"><br><br>  It seems reasonable that the python.exe process that runs my script uses a significant portion of the CPU resources.  It is also clear that the System process will also be busy with some work, since we are engaged in adding and deleting files.  In addition, we see in the table the work of the VsChromium extension, since it observes the folder in which we create and delete files, and therefore must respond to this (add and remove files from the index).  Finally, SearchIndexer.exe uses few resources to index new files.  It seems that everything looks good.  And yet - we know that the code is too slow. <br><br>  Here, for contrast, a graph of processor usage in the case of creating and deleting files in a directory that is not under the supervision of VsChromium.  Performance has risen almost 10 times!  It is clear that the download from VsChromium.Server.exe and devenv.exe has completely disappeared, but that‚Äôs not the end of it.  Python itself, running my script, also began to work much faster (script execution time dropped from 4888 ms to 561 ms).  The System process has generally accelerated from 2604 ms to 42 ms.  What is going on here? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88e/855/e83/88e855e83e063b6aecbc75005f0f665b.png" alt="image"><br><br>  The CPU Usage (Precise) graph, which is based on context switching information, provides a good opportunity to tell how many processor resources a particular process uses.  But in order to understand what the process is wasting time on, you need to use the <a href="https://randomascii.wordpress.com/2013/04/23/xperf-for-excess-cpu-consumption-wpa-edition/">CPU Usage (Sampled) schedule</a> .  It is based on ‚Äúsnapshots‚Äù of the function call stack (by default, made at a frequency of 1000 times per second). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb8/13a/089/bb813a0894dcc2379ae505ae16071c55.png" alt="image"><br><br>  This type of data view groups data by process, then by stream, then by module, and finally by function.  In this case, for the python.exe process, we see that in 4637 snapshots from 4904, some work took place in the <a href="https://en.wikipedia.org/wiki/Ntoskrnl.exe">ntoskrnl.exe</a> module.  This is much more than the execution time of the code in python27.dll (which can be neglected at all). <br><br>  Delving into the study of what ntoskrnl.exe was doing, we see exactly what functions were called in it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/fd5/c66/ea8fd5c660bf7988fb30e7b7963c925b.png" alt="image"><br><br>  Most often, the memory allocation function MiAllocatePagedPoolPages and memset memory functions, MiCompletePrivateZeroFault, and <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D0%25BA%25D0%25B0%25D0%25B7_%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586%25D1%258B">page faults</a> associated with them were called.  It seems a little strange that in the test of the file system the most resources are occupied by the task of allocating and cleaning memory, right?  But wait, that's not all.  The second in terms of employment in the system is the System process, and it is busy (what would you think?) Resetting the newly freed memory pages.  What, after all, is happening? <br><br>  Returning to the snapshot snapshot analysis of the python.exe process, I searched for the memset function and found it somewhere 70 levels lower than the olligus (not surprisingly, I missed it earlier).  Right click on it, select View Callers-&gt; By Function and see that the total cost of calling it (including the execution time of the "child functions") is about half of the total processor load - 2971 snapshots of 4904 taken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fe/174/6a2/2fe1746a2591903bb9a3ab8083be9238.png" alt="image"><br><br>  FsRtlNotifyFilterReportChangeLiteEx has almost always been the caller.  Right click on it, View Callees-&gt; By Function.  This showed me that this function allocated memory, called memset for it, and consumed about 83% of the CPU time in the python.exe process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/275/399/adc/275399adc16059fbbccacafcab688913.png" alt="image"><br><br><h3>  In search of a problem </h3><br>  At this point in my research, I had several, as it turned out later, incorrect guesses.  One of them concerned the frequent calls to wcifs.sys! WcGenerateFileName - I thought that the generation of file names in the ‚Äú8.3‚Äù format was too slow, but disabling it did not change anything.  In the end, I stopped my attempts to comprehend incomprehensible tricks and instead thought about how the VsChromium extension works.  When downloading, it simply has to read and load into memory all the contents of the files in the monitored folder.  But after that, he only needs to track changes and I assumed that it has something like a file system change monitor.  I knew that the extension had recently received an update and in it the author increased the buffer in which notifications about file changes were stored, from 16 KB to 2 MiB.  And for some reason, the operating system did not like it very much.  I tried to roll back to the previous version of the extension (with a smaller buffer) - and this really fixed the problem. <br><br>  This buffer was allocated using the ExAllocatePoolWithTag function, and then filled with information about changes in the file system.  To avoid data leakage from the OS kernel, the entire unused part of the buffer was reset.  If the buffer is large enough and the amount of information sent is relatively small, resetting will take most of the time.  I added the data provider ALL_FAULTS (which I found by looking at the result of the ‚Äúxperf -providers k‚Äù call) to my ETW session to see how often the pages failed.  And it was impressive!  There were 2,544,578 page failures when attempting to reset the data, which corresponds to 9.7 GiB data or about 4970 times in 2 MiB buffer.  This is 4.97 buffers for every thousand files created and deleted.  I was told that VsChromium should create about 5 events for each created and deleted file, which means most of the buffers with notifications will contain only one record.  Here are page failures by process and type: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a1/f99/16d/5a1f9916d94351b7339ba3d15f5e08f1.png" alt="image"><br><br><h3>  Why such a big buffer? </h3><br>  The documentation for <a href="https://msdn.microsoft.com/en-us/library/system.io.filesystemwatcher%2528v%3Dvs.110%2529.aspx%3Ff%3D255%26MSPPError%3D-2147217396">FileSystemWatcher</a> recommends that you <a href="https://msdn.microsoft.com/en-us/library/system.io.filesystemwatcher.internalbuffersize(v%3Dvs.110).aspx">do not use a large buffer</a> , but it doesn‚Äôt go into details about how this threatens.  Chrome developers' machines have a lot of RAM, so when once very frequent file operations (a bug in the Windows kernel, <a href="https://habr.com/company/infopulse/blog/350126/">which I wrote about earlier</a> ) caused the previously used 16 KV buffer to overflow, it was simply significantly increased.  And this, at first glance, helped.  At least then, to solve that problem.  Although slowed down file operations many times. <br><br>  When the author of the VsChromium extension learned about the problem, he decided to reduce the buffer back and handle the errors of its overflow more gracefully (temporarily suspending monitoring). <br><br>  The irony of this situation is that most of the resources expended here (memset calls, page failures, zeroing) occur because two different parts of the OS kernel do not communicate well enough with each other.  The notification system asks for memory, gets it (already zeroed out), and again tries to reset it.  If she knew that the memory had already been reset, she would not have tried to do it a second time, and there would have been no extra page failures, and life would have been much better.  Hey, Microsoft, I have a cool idea on how to make the notification system about file system changes better! <br><br><h3>  Armed with this knowledge </h3><br>  It is enough just to write C # code that will monitor file system changes for the root of all the disks we have, using the buffer for notifications, first small and then significantly larger.  I‚Äôm wondering what will be the impact on system performance with a 10 MiB buffer, and I‚Äôm still wondering what its size should be in order to use this seemingly innocent user mode feature to slow down Windows to the greatest possible extent? <br><br>  ETW traces allow you to simply understand that the buffers for notifications are a problem - every process that performs some file operations will show an extremely long time spent in ntoskrnl.exe! FsRtlNotifyFilterReportChangeLiteEx.  This shows that someone uses a very large buffer for notifications, but how do we find the culprit process?  It is very simple - since in our case the memory was allocated using ntoskrnl.exe! ExAllocatePoolWithTag, it will be released using ntoskrnl.exe! ExFreePoolWithTag.  We can search for calls to this function in our existing callstacks and find one where there are a lot of them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/962/c1a/c13/962c1ac13cfb71a3d68f4d9d6e29f988.png" alt="image"><br><br><h3>  Other useful links </h3><br>  C # source code for FileSystemWatcher can be downloaded <a href="https://referencesource.microsoft.com/">here</a> .  It is implemented using ReadDirectoryChangesW.  How it all works is well described <a href="https://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html">here</a> . <br><br>  An increase in the size of the buffer in VsChromium happened here <a href="https://github.com/chromium/vs-chromium/commit/f61f198cc8c2e82472294a07a3169dfb9435f14e">in this commit</a> , which went into build <a href="">0.9.26</a> .  The reverse decrease happened here <a href="https://github.com/chromium/vs-chromium/commit/b33c907f79f814ccc44364bef0420928c6066f2c">in this committee</a> , which was included in version <a href="">0.9.27</a> . <br><br>  I recommend that all VsChromium users upgrade to the latest version. <br><br>  ETW-traces and the Python script mentioned in the article can be downloaded <a href="https://github.com/randomascii/blogstuff/tree/master/NotificationTests">here</a> .  It creates and deletes files twice, once in a directory under the supervision of VsChromium, and a second time in an unobserved directory, with a half-second pause.  To play the experiment from the article, you, of course, need the appropriate version of VsChromium, configured to monitor the desired folder. <br><br>  And in the next article I will talk about how Microsoft allows you to sometimes randomly create N processes in O (N ^ 2) time. </div><p>Source: <a href="https://habr.com/ru/post/354324/">https://habr.com/ru/post/354324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354310/index.html">Forms on the site - a spammer reluctantly</a></li>
<li><a href="../354312/index.html">How to optimize power consumption in iOS</a></li>
<li><a href="../354314/index.html">Roskomnadzor‚Äôs locks in the Telegram case reached the mining pools</a></li>
<li><a href="../354318/index.html">Hypothesis parameters</a></li>
<li><a href="../354322/index.html">Flask Mega-Tutorial, Part XXI: User Notifications</a></li>
<li><a href="../354326/index.html">Using the MVC pattern when designing the tableview</a></li>
<li><a href="../354328/index.html">HOPE X. Conference "Breaking the elevator: from the basement to the penthouse." Part 1. "Elevator equipment"</a></li>
<li><a href="../354332/index.html">Edimax Office1-2-3 and what it is eaten with</a></li>
<li><a href="../354334/index.html">How we build DevOps in a team of 125 developers</a></li>
<li><a href="../354336/index.html">Technical diary: the second half year of the development of a new mobile PvP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>