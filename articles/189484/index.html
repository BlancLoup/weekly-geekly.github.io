<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ARMs for the smallest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of days ago I published and then suddenly removed an article on the plan in drafts to write about creating my own OS for ARM architecture. I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ARMs for the smallest</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d88/55f/785/d8855f7857c92567b67c6ee27557bb7e.jpg"><br><br>  A couple of days ago I published and then suddenly removed an article on the plan in drafts to write about creating my own OS for ARM architecture.  I did this because I received many interesting reviews both on Habr√© and in G +. <br><br>  Today I will try to approach the question from the other side, I will talk about how to program ARM microcontrollers with examples of increasing complexity, until we write our OS or until I get bored.  Or maybe we will jump to tinkering at Contiki, TinyOS, ChibiOS or FreeRTOS, who knows, there are so many different and interesting ones there (and TinyOS also has its own programming language!). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So why ARM?  Although it is interesting to mess with 8-bit microcontrollers, it soon gets boring.  In addition, ARM development tools run through a long experience and are much more pleasant to work with.  At the same time, to start flashing the LEDs on some kind of ‚Äúevaluation board‚Äù is as easy as on the Arduino. <br><br><a name="habracut"></a><br><br><h4>  A small excursion into architecture </h4><br>  ARM promotes a wonderful architecture, which it successfully licenses, it‚Äôs really hard for me to imagine which device has no presence of this company's products.  Your smartphone is guaranteed to have several cores based on the ARM architecture.  A couple more can be found in a modern laptop (and this is not even a CPU, but a companion controller of some peripherals), and a few more in the car.  There are they in other household things: microwaves and televisions. <br><br>  This flexibility is achieved by the fact that in the most basic version of the ARM core is very simple.  Now there are three types of this architecture.  <i>Application</i> is used in ‚Äúgeneral purpose‚Äù devices - as the main processor in a smartphone or netbook.  This profile is the most feature-rich and functional, there is also a full-fledged MMU (memory management module), the ability to hardware-execute Java bytecode instructions and even support for DRM schemes.  <i>Microcontroller</i> is the exact opposite of the application profile used (suddenly!) For use in microcontrollers.  Here the actual power consumption and deterministic behavior.  And, finally, <i>real-time is</i> used as an evolution of the microcontroller profile for tasks where it is critical to have a guaranteed response time.  All these profiles have been implemented in one or more Cortex cores, for example, Cortex-A9 is based on the application profile and is part of the processor in the iPhone 4S, and Cortex-M0 is based on the microcontroller profile. <br><br><h4>  Pieces of iron! </h4><br><img src="https://habrastorage.org/storage2/847/ba1/4d0/847ba14d0ca49fc6289e1e60211d127d.jpg"><br>  As a target platform, we will consider working with Cortex-M, since it is the simplest, respectively, we need to delve into fewer questions.  As a test device, I suggest you LPC1114 - MCU manufactured by NXP, a circuit that can be assembled literally on the knee (no, really, you only need the MCU itself, a 3.3 V FTDI cable, several LEDs and resistors).  The LPC1114 is based on the Cortex-M0, so this will be the most trimmed version of the platform. <br><br><br><img src="https://habrastorage.org/storage2/286/708/32d/28670832da9a0f36f7c290790c3f3e51.jpg"><br>  As an alternative, we will work with the <a href="http://mbed.org/">mbed</a> platform, and specifically, with the model based on <a href="http://mbed.org/platforms/mbed-LPC1768/">LPC1768</a> (and therefore, inside there is a Cortex-M3, somewhat more sophisticated).  The option is no longer so budgetary, but the process of pouring binaries onto a chip and debugging is simplified to the maximum.  Yes, and you can play around with the mbed platform itself (in short: it‚Äôs an online IDE and a library with which you can program at the arduin level). <br><br><h4>  Let's get started </h4><br>  An interesting feature of modern ARMs is that they can be fully programmed entirely in C, without the use of assembler inserts (although the assembler is not so complicated, Cortex-M0 has only 56 commands).  Although some commands are not available in principle from C, this problem is solved by CMSIS - Cortex Microcontroller Software Interface Standard.  This is a driver for the processor that solves all the main tasks of managing it. <br><br>  How does the processor load?  A typical situation is when he just starts to execute commands from the address 0x00000000.  In our case, the processor is somewhat smarter, and it relies on a specially-defined data format at the beginning of the memory, namely, the interrupt vector table: <br><br><img src="https://habrastorage.org/storage2/ef5/040/c93/ef5040c93fdd28990c01e8d092114e3c.png"><br>  The program starts running as follows: the processor reads the value at 0x00000000 and writes it to SP ( <i>SP</i> is the register that points to the top of the stack), then reads the value at 0x00000004 and writes it to the PC ( <i>PC</i> is the register that indicates current instruction + 4 bytes).  Thus, some user code starts to run, while we already have a stack pointing somewhere in memory (i.e., all the conditions for executing a program in C). <br><br>  As a test exercise, we will flash the LED.  We have four of them on the mbed, we install the LED into the circuit with LPC1114 (hereinafter referred to as the ‚Äúboard‚Äù) manually. <br><br>  Before writing code directly, we need to figure out one more thing, namely, what should be located in memory.  Since we do not work with some kind of "standard" OS, the compiler (or rather, the linker) cannot find out where it should have a stack, where the code itself is, and where it is a heap.  Fortunately for us, the Cortex core family has a standardized memory card, which makes it relatively easy to port applications between different processors of this architecture.  Work with the periphery, of course, remains processor-dependent. <br><br>  The memory card for the Cortex-M0 looks like this: <br><br><img src="https://habrastorage.org/storage2/dd2/fdd/62b/dd2fdd62bd2fcc3555cda74fc363eed5.png"><br><br>  (image from <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0497a/CHDBIJJE.html">Cortex ‚Ñ¢ -M0 Devices Generic User Guide</a> ) <br><br>  In Cortex-M3, it is, in fact, the same, but somewhat more detailed.  The problem here is that NXP has its own, separate view on this issue, so we check the memory card in the processor documentation: <br><br><img src="https://habrastorage.org/storage2/6f4/62c/a9c/6f462ca9c4c0f1c5992a521c1cd80c64.png"><br><br>  (image from <a href="http://www.nxp.com/documents/user_manual/UM10398.pdf">LPC111x / LPC11Cxx User manual</a> ) <br><br>  In fact, SRAM starts with 0x10000000!  So, some standards, other standards, but still need to flip the volume of documentation. <br><br>  Armed with this knowledge, let's go write code.  First, the interrupt table: <br><br><pre><code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.cpu</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cortex-m0</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.thumb</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">stack_base</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      ,    */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Reset:         */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* NMI         */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* HardFault */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MemManage */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* BusFault */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* UsageFault */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_checksum</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RESERVED */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RESERVED*/</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RESERVED */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* SVCall */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Debug Monitor */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RESERVED */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* PendSV */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/* SysTick */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   0 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    32   LPC1114  35  LPC1768,     ,         */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.thumb_func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> . <span class="hljs-comment"><span class="hljs-comment">/*    :   */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.global</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hang</span></span></code> </pre> <br><br>  Save this table in <code>boot.s</code>  Here, in fact, only one assembly insertion is the hang function, which arranges an infinite loop for the processor.  All interrupts, except for reset, indicate it, so in the event of an unforeseen situation the processor will simply freeze, and it will not go to execute an incomprehensible piece of code. <br><br>  The table itself should be longer, but in fact we could finish it even after the Reset vector, the rest of us would not have worked in this example.  But, just in case, we filled out the table almost entirely (except for user interrupts). <br><br>  Now we will write the implementation of the main function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__ARM_ARCH_6M__) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Cortex-M0  ARMv6-M,   LPC1114 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_DIR_REG 0x50018000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* GPIO1DIR     GPIO 1 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_REG_VAL 0x50013FFC </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* GPIO1DATA     GPIO 1 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_PIN_NO (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;8) /* 8-    8-  */ #elif defined(__ARM_ARCH_7M__) /*      LPC1768 */ #define GPIO_DIR_REG 0x2009C020 /* FIO1DIR     GPIO 1 */ #define GPIO_REG_VAL 0x2009C034 /* FIO1PIN     GPIO 1 */ #define GPIO_PIN_NO (1&lt;&lt;18) /* 18-    18-  */ #else #error Unknown architecture #endif void wait() { volatile int i=0x20000; while(i&gt;0) { --i; } } void main() { *((volatile unsigned int *)GPIO_DIR_REG) = GPIO_PIN_NO; while(1) { *((volatile unsigned int *)GPIO_REG_VAL) = GPIO_PIN_NO; wait(); *((volatile unsigned int *)GPIO_REG_VAL) = 0; wait(); } /* main() **   ! */ }</span></span></span></span></code> </pre><br><br>  At mbed, the first LED is <a href="http://mbed.org/media/uploads/chris/mbed-005.1.pdf">connected</a> to the GPIO 1.18 port, on the board we connected the LED to GPIO 1.8.  The same pins can perform different functions, these by default work exactly as GPIO (General Purpose I / O - general purpose input / output lines). <br><br>  The code is relatively straightforward, if you keep on hand the LPC-shny User manual ( <a href="http://www.nxp.com/documents/user_manual/UM10398.pdf">one</a> and the <a href="http://www.nxp.com/documents/user_manual/UM10360.pdf">second</a> ).  To begin with, we specify the GPIO mode through the GPIO_DIR_REG register (they are in different places for our processors, and in general LPC1768 can work more efficiently with GPIO), where 1 is the output, 0 is the input.  Then we run an infinite loop, in which we write to the port alternately the values ‚Äã‚Äã0 and 1 (0 V and 3.3 V, respectively). <br><br>  The function for ‚Äúpause‚Äù works for us at random, simply scrolling through a relatively long cycle ( <code>volatile int</code> does not allow the compiler to optimize this cycle entirely). <br><br>  Finally, all this needs to be properly put together: <br><br><pre> <code class="hljs pgsql">_stack_base = <span class="hljs-number"><span class="hljs-number">0x10002000</span></span>; _boot_checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> - (_stack_base + main + <span class="hljs-number"><span class="hljs-number">1</span></span> + (hang + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">5</span></span>); MEMORY { rom(RX) : ORIGIN = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, LENGTH = <span class="hljs-number"><span class="hljs-number">0x8000</span></span> ram(WAIL) : ORIGIN = <span class="hljs-number"><span class="hljs-number">0x10000000</span></span>, LENGTH = <span class="hljs-number"><span class="hljs-number">0x2000</span></span> } SECTIONS { .text : { *(.text*) } &gt; rom .bss : { *(.bss*) } &gt; ram }</code> </pre><br><br>  The linker script explains to him where we have a flash, where the RAM is, what sizes they have (here they use the sizes for LPC1114, since LPC1768 has the most, the shifts are, fortunately, identical).  After determining the memory card, we indicate which segments to copy, .text (program code) gets into the flash, .bss (static variables that we don't have yet) - into memory.  In addition, we specify two characters that were used in boot.s: _stack_base - points to the top of the stack and _boot_checksum (thanks to <a href="https://habrahabr.ru/users/zuy/" class="user_link">Zuy</a> for the clarification!) - writes down the bootloader cheksum.  Cheksumma is calculated using the following formula: additional code (2's compliment) on the sum of the fields above (i.e., the stack address, and all interrupts directly to the cheksum).  Although the utilities for the firmware (see below) themselves would fix the checksum to the correct one, if we were to flash the code from the application itself, we would not be able to boot again. <br><br>  Now we have three files: boot.s, main.c, mem.ld, it‚Äôs time to compile and finally run.  As a toolchain, we will use GCC, later, perhaps, I will show how to do the same with LLVM.  Users of OS X, I advise you to take the linchine from <a href="http://www.linaro.org/downloads/">Linaro</a> - at the very end of the list: Bare-Metal GCC ARM Embedded.  I advise users of other operating systems to take the toolchain in the same place :-) (except that it will be easier for the gTushkens to crossdev and compile GCC). <br><br><pre> <code class="bash hljs">arm-none-eabi-as boot.s -o boot.o arm-none-eabi-gcc -O2 -nostdlib -nostartfiles -ffreestanding -Wall -mthumb -mcpu=cortex-m0 -c main.c -o main-c0.o arm-none-eabi-gcc -O2 -nostdlib -nostartfiles -ffreestanding -Wall -mthumb -mcpu=cortex-m3 -c main.c -o main-c3.o arm-none-eabi-ld -o blink-c0.elf -T mem.ld boot.o main-c0.o arm-none-eabi-ld -o blink-c3.elf -T mem.ld boot.o main-c3.o arm-none-eabi-objdump -D blink-c0.elf &gt; blink-c0.lst arm-none-eabi-objdump -D blink-c3.elf &gt; blink-c3.lst arm-none-eabi-objcopy blink-c0.elf blink-c0.bin -O binary arm-none-eabi-objcopy blink-c3.elf blink-c3.bin -O binary</code> </pre><br><br>  An interesting point here is to disable the use of all standard libraries from GCC.  Indeed, all the code that falls into the final binary is the code that we wrote ourselves. <br><br>  Question: how does the linker know where to put the interrupt table?  But he does not know, it is not written there :-).  It simply links in succession, starting from the zero address, so the order of the files (boot.o, then main-c0.o) is very important!  Try the opposite link or the boot.o link twice and compare the output in the lst file. <br><br>  A good idea is to look at the final listing (lst file) or throw the binary into the disassembler.  Even if you do not speak ARM UAL, then you can check visually that at least the interrupt table is in its place: <br><br><img src="https://habrastorage.org/storage2/f7e/c2a/a88/f7ec2aa88b69afc404cac72c61309add.png"><br><img src="https://habrastorage.org/storage2/6c8/59a/eee/6c859aeeef7753f10506a893931a63ba.png"><br><br>  You can also pay attention to the funny moment - when compiling for Cortex-M3, GCC generates a wait () function more than in the version for Cortex-M0.  True, if you turn on the optimization, it will set his brain. <br><br><h4>  Blink! </h4><br>  All that is left for us is to upload the binaries to our test platforms.  With mbed, everything is as simple as possible, just copy <code>blink-c3.bin</code> to a virtual USB flash drive and press reset (on mbed).  With the board it's a little more complicated.  First, in order to get into the bootloader, we need a resistor between GND and GPIO 0.1.  Secondly, a program is needed for the firmware itself.  You can use <a href="http://www.flashmagictool.com/">Flash Magic</a> (Win, OS X), you can use the console utility - <a href="https://github.com/farcaller/lpc21isp">lpc21isp</a> : <br><br><pre> <code class="bash hljs">lpc21isp.out -verify -bin /path/to/blink-c0.bin /dev/ftdi/tty/device 115200 12000</code> </pre><br><br>  The firmware process is as follows: <br><ul><li>  we put a resistor between j5 and j7 (10 kŒ© will do); </li><li>  press reset; </li><li>  run lpc21isp; </li><li>  remove the resistor; </li><li>  Press reset again - the application is launched. </li></ul><br><br>  If you have the opportunity to run the examples on different devices, you will notice that the speed of flashing on them is not identical.  This is due to the fact that different devices have different core frequencies, respectively, they perform <code>wait()</code> at different times.  In the next part, we will study the issues of oscillation in more detail and make a clear countdown. <br><br>  PS Special thanks to the pfactum <a href="https://habrahabr.ru/users/pfactum/" class="user_link">habraiser</a> for spending time correcting my mistakes in the text :-). <br><br>  PPS Please those who have a test platform based on ARM - write in the comments - what.  I can review the hardware base for further articles. </div><p>Source: <a href="https://habr.com/ru/post/189484/">https://habr.com/ru/post/189484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189470/index.html">Special effects in ‚ÄúMatrix‚Äù style for sports TV broadcasts</a></li>
<li><a href="../189472/index.html">The first release on the Opera Developer channel</a></li>
<li><a href="../189474/index.html">US court found Bitcoin currency</a></li>
<li><a href="../189476/index.html">Designing a planet comfortable for earthlings</a></li>
<li><a href="../189480/index.html">Need to start small</a></li>
<li><a href="../189486/index.html">How GIL works in Ruby. Part 2</a></li>
<li><a href="../189488/index.html">What to do if ‚Äúkin will not‚Äù or how to bypass the site blocking by the provider</a></li>
<li><a href="../189494/index.html">Fiction and documentary films about astronautics</a></li>
<li><a href="../189496/index.html">Evaluate the idea of ‚Äã‚Äãyour mobile application</a></li>
<li><a href="../189498/index.html">Apple develops audio hyperlinks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>