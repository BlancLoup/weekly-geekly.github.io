<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Roslyn. Use to develop static analysis tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Roslyn is a platform that provides the developer with various powerful tools for parsing and analyzing code. But the availability of such funds is not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Roslyn. Use to develop static analysis tools</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/ba4/2cc/3d7/ba42cc3d7dde460da0c0ecc5e7572a16.png"></div><br>  Roslyn is a platform that provides the developer with various powerful tools for parsing and analyzing code.  But the availability of such funds is not enough, you need to understand what and why you need to use.  This article is intended to answer such questions.  In addition, the features of the development of static analyzers using the Roslyn API will be discussed. <br><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  The knowledge presented in this article was obtained during the development of the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static code analyzer, part of which is responsible for checking C # projects and was written using the Roslyn API. <br><br>  The article can be divided into 2 large logical sections: <br><ul><li>  General information about Roslyn.  An overview of the tools they provide for parsing and analyzing code.  Both a general description of entities and interfaces as well as a look at them from the point of view of a static analyzer developer are given. </li><li>  Features that should be considered when developing static analyzers.  How to use Roslyn to develop products of this class, what to consider when developing diagnostic rules, how to write them, an example of a diagnosis, etc. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the article is divided into sections in more detail, the following parts can be distinguished: <ul><li>  Roslyn.  What is it and why do we need? </li><li>  Preparation for the analysis of projects and file analysis. </li><li>  The syntax tree and semantic model as 2 main components necessary for static analysis. </li><li>  Syntax Visualizer is an extension of the Visual Studio development environment, as well as our assistant in code parsing. </li><li>  Features that need to be taken into account when developing a static code analyzer. </li><li>  An example of a diagnostic rule. </li></ul><br><br>  <b>Note.</b>  Additionally, I offer you a related article " <a href="http://www.viva64.com/ru/a/0082/">Guidelines for the development of extension modules in C # for Visual Studio 2005-2012 and Atmel Studio</a> ." <br><br><h2>  Roslyn </h2><br>  <a href="https://en.wikipedia.org/wiki/.NET_Compiler_Platform">Roslyn</a> is an open source platform developed by Microsoft and contains compilers and tools for parsing and analyzing code written in C # and Visual Basic programming languages. <br><br>  Roslyn is used in the Microsoft Visual Studio 2015 development environment. Various innovations like code fixes are implemented just by using Roslyn. <br><br>  Using the analysis tools provided by the Roslyn platform, you can make a complete code analysis by analyzing all supported language constructs. <br><br>  The Visual Studio environment allows you to create, on the basis of Roslyn, both tools embedded in the IDE itself (Visual Studio extensions) and independent applications (standalone tools). <br><br><img src="https://habrastorage.org/files/982/6bb/786/9826bb786a8c4b758a6df5bd6ed67a3d.png"><br><br>  The source code for Roslyn is available in the corresponding <a href="https://github.com/dotnet/roslyn">repository on GitHub</a> .  This allows you to see what and how it works, and in case of detection of any error, inform the developers about it. <br><br>  The option of creating a static analyzer and diagnostic rules considered below is not the only one.  It is possible to create diagnostics based on the use of the standard class <i>DiagnosticAnalyzer</i> .  Roslyn's built-in diagnostics use this solution.  This will allow, for example, integration with the standard error list of Visual Studio, provides the ability to highlight errors in a text editor, etc.  But it is worth remembering that if these diagnostics exist within the 32-bit <i>devenv.exe</i> process, there are serious limitations on the amount of memory used.  In some cases, this is critical and will not allow an in-depth analysis of large projects (the same Roslyn).  Moreover, in this case, Roslyn leaves the developer with less control over tree traversal and is independently involved in parallelizing this process. <br><br>  C # PVS-Studio analyzer is a standalone application, which solves the problem with the restriction on the use of memory.  In addition, we get more control over tree traversal, we implement parallelization in the way we need, thereby controlling the process of parsing and analyzing the code more.  Since there is already experience in creating an analyzer that works on this principle (PVS-Studio C ++), it would be advisable to use it when writing a C # analyzer.  Integration with the Visual Studio development environment is carried out in the same way as a C ++ analyzer ‚Äî via a plug-in that calls this standalone application.  Thus, using the existing developments, we managed to create an analyzer for a new language and connect it with the existing solutions, integrating it into a full-fledged product - PVS-Studio. <br><br><h2>  Preparing for file analysis </h2><br>  Before proceeding with the analysis itself, it is necessary to obtain a list of files whose source code will be checked, as well as to obtain the entities necessary for correct analysis.  There are several points that need to be performed to obtain the necessary data for analysis: <ol><li>  Creating workspace; </li><li>  Getting the solution (optional); </li><li>  Receiving projects; </li><li>  Analysis of the project: getting a compilation, a list of files; </li><li>  File parsing: getting the syntax tree and semantic model; </li></ol><br><br><img src="https://habrastorage.org/files/b4a/836/461/b4a83646121140049aa971b2f83d0871.png"><br><br>  At each point is worth a little more detail. <br><br><h3>  Creating a workspace </h3><br>  Creating a workspace is necessary to get a solution or projects.  To get a workspace, you must call the static <i>Create</i> method of the <i>MSBuildWorkspace</i> class, which returns an object of type <i>MSBuildWorkspace</i> . <br><br><h3>  Getting a solution </h3><br>  Getting a solution is important when it is necessary to analyze, for example, several projects included in a given solution, or all of them.  Then, having received a solution, you can easily get a list of all the projects included in it. <br><br>  To obtain a solution, the <i>OpenSolutionAsync</i> method of the <i>MSBuildWorkspace</i> object is <i>used</i> .  As a result, we obtain a collection containing a list of projects (i.e., an <i>IEnumerable &lt;Project&gt;</i> object). <br><br><h3>  Getting projects </h3><br>  If there is no need to analyze all the projects, you can get a specific project that interests us using the <i>openProjectAsync</i> asynchronous method of the <i>MSBuildWorkspace</i> object.  Using this method, we get an object of type <i>Project</i> . <br><br><h3>  Analysis of the project: getting a compilation and a list of files for analysis </h3><br>  After the list of projects for the analysis is received, it is possible to start their analysis.  The result of the project parsing should be a list of files for analysis and compilation. <br><br>  The list of files is easy to get - this is done using the <i>Documents</i> property of an instance of the <i>Project</i> class. <br><br>  To compile, use the <i>TryGetCompilation</i> method or <i>GetCompilationAsync method</i> . <br><br>  Getting a compilation is one of the key points, as it is used to obtain the semantic model (which will be discussed in more detail later), which is necessary for conducting a deep and complex analysis of the source code. <br><br>  In order to get a correct compilation, the project must be compiled - there should be no compilation errors in it, and all dependencies should be in place. <br><br><h3>  An example of use.  Getting projects </h3><br>  Below is the code demonstrating various options for obtaining project files using the <i>MSBuildWorkspace</i> class: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String solutionPath, String projectPath</span></span></span><span class="hljs-function">)</span></span> { MSBuildWorkspace workspace = MSBuildWorkspace.Create(); Solution currSolution = workspace.OpenSolutionAsync(solutionPath) .Result; IEnumerable&lt;Project&gt; projects = currSolution.Projects; Project currProject = workspace.OpenProjectAsync(projectPath) .Result; }</code> </pre> <br>  These actions should not cause any questions, since everything that happens here has been described above. <br><br><h3>  File parsing: getting the syntax tree and semantic model </h3><br>  The next step is to parse the file.  Now it is necessary to get 2 entities on which the full analysis is based - the syntactic tree and the semantic model.  The syntax tree is built on the basis of the program source code and is used to analyze various language constructs.  The semantic model provides information about objects and their types. <br><br>  To get the syntax tree (an object of the <i>SyntaxTree</i> type), use the <i>TryGetSyntaxTree</i> or <i>GetSyntaxTreeAsync</i> method of the <i>Document</i> class instance. <br><br>  The semantic model (an object of the <i>SemanticModel</i> type) is obtained from compilation using the syntactic tree obtained earlier.  To do this, use the <i>GetSemanticModel</i> method of <i>an</i> instance of the <i>Compilation</i> class, which takes an object of the <i>SyntaxTree</i> type as a required parameter. <br><br>  The class, which will bypass the syntax tree and carry out analysis, should be inherited from the <i>CSharpSyntaxWalker</i> class <i>,</i> which will allow redefining the traversal methods of various nodes.  By calling the <i>Visit</i> method, which takes the root of a tree as a parameter (the <i>GetRoot</i> method of <i>an</i> object of type <i>SyntaxTree is</i> used to <i>obtain it</i> ), we thereby start a recursive traversal of the syntax tree nodes. <br><br>  Below is the code that demonstrates the implementation of the steps described above: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectAnalysis</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Project project</span></span></span><span class="hljs-function">)</span></span> { Compilation compilation = project.GetCompilationAsync().Result; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> project.Documents) { SyntaxTree tree = file.GetSyntaxTreeAsync().Result; SemanticModel model = compilation.GetSemanticModel(tree); Visit(tree.GetRoot()); } }</code> </pre> <br><br><h3>  Overridden Node Traversal Methods </h3><br>  For each language design, nodes of its type are defined.  And for each node type, a method is defined that performs a crawl of nodes of this type.  Thus, by adding handlers (diagnostic rules) to the bypass methods of various nodes, we can analyze only the constructions of the language that we are interested in. <br><br>  An example of a redefined traversal method for nodes corresponding to an <i>if statement</i> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitIfStatement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IfStatementSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitIfStatement(node); }</code> </pre> <br>  Adding the appropriate rules to the method body, we will analyze all <i>if statements</i> that will occur in the program code. <br><br><h2>  Syntax tree </h2><br>  The syntax tree is the basic element necessary for code analysis.  It is on it that the movement occurs during the analysis.  The tree is built on the basis of the code in the file, from which it follows that each file has its own syntax tree.  In addition, it is worth considering the fact that the syntax tree is immutable.  No, you can change it, of course, by calling the appropriate method, but the result of its work will be a new syntax tree, and not a modified old one. <br><br>  For example, for the following code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">M</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre> <br>  The syntax tree will look like this: <br><br><img src="https://habrastorage.org/files/add/898/178/add89817826143189b1d2071e31e623f.png"><br><br>  Here the blue are the nodes of the tree ( <i>Syntax nodes</i> ), and the green are the <i>tokens</i> . <br><br>  In the syntax tree, which Roslyn builds on the basis of the program code, there are 3 elements: <ul><li>  Syntax nodes; </li><li>  Syntax tokens; </li><li>  Syntax trivia. </li></ul><br>  Each of these elements of the tree should be considered in more detail, since all of them are used in one way or another during static analysis.  Another thing is that some of them are used regularly, while others are an order of magnitude less frequent. <br><br><h3>  Syntax nodes </h3><br>  Syntax nodes (hereinafter referred to as nodes) represent syntactic constructions, such as declarations, operators, expressions, etc.  The main work that takes place during the analysis of the code is on the processing of nodes.  It is on them that the movement takes place, and diagnostic rules are based on the bypass of certain types of nodes. <br><br>  Consider an example of a tree corresponding to the expression <br><pre> <code class="cs hljs">a *= (b + <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Unlike the previous figure, here are just the nodes and comments to them, which will make it easier to navigate what node of which structure corresponds. <br><br><img src="https://habrastorage.org/files/29f/40c/9bd/29f40c9bd37d4b36906c4465bda63a23.png"><br><br><h4>  Base type </h4><br>  The basic node type is the abstract class <i>SyntaxNode</i> .  This class provides the developer with methods that are common to all nodes.  We list some of the most frequently used ones (if some things like what <i>SyntaxKind</i> or the like are incomprehensible to you now - do not worry, this will be discussed below): <ul><li>  <i>ChildNodes</i> - gets a list of nodes that are children of the current one.  Returns an object of type <i>IEnumerable &lt;SyntaxNode&gt;</i> ; </li><li>  <i>DescendantNodes</i> - gets a list of all nodes that are in the tree below the current one.  Also returns an object of type <i>IEnumerable &lt;SyntaxNode&gt;</i> ; </li><li>  <i>Contains</i> - checks if the current node includes another one passed in as an argument; </li><li>  <i>GetLeadingTrivia</i> - allows to get syntax trivia elements preceding this node, if any; </li><li>  <i>GetTrailingTrivia -</i> allows you to get the elements of syntax trivia, following this node, if any; </li><li>  <i>Kind</i> - returns a <i>SyntaxKind</i> enumeration <i>element</i> that specifies this node; </li><li>  <i>IsKind</i> - takes a <i>SyntaxKind</i> enumeration member as a parameter, and returns a boolean value that determines whether a particular node type matches the type passed in as an argument. </li></ul><br><br>  In addition, the class defines a number of properties.  Some of them: <ul><li>  <i>Parent</i> - returns a link to the parent node.  It is an extremely necessary property, since it allows you to move up the tree; </li><li>  <i>HasLeadingTrivia</i> - returns a boolean value indicating the presence or absence of syntax trivia elements preceding the given node; </li><li>  <i>HasTrailingTrivia</i> ‚Äî Returns a boolean value, indicating the presence or absence of the syntax trivia elements following the given node. </li></ul><br><br><h4>  Derived Types </h4><br>  But back to the types of nodes.  Each node representing a particular language construct has its own type, which determines a number of properties that simplify navigation through the tree and obtaining the necessary data.  These types are many.  Here are some of them and what language constructions they correspond to: <ul><li>  <i>IfStatementSyntax</i> - <i>if statement</i> ; </li><li>  <i>InvocationExpressionSyntax</i> - method call; </li><li>  <i>BinaryExpressionSyntax</i> - infix operation; </li><li>  <i>ReturnStatementSyntax</i> - expression with the operator <i>return;</i> </li><li>  <i>MemberAccessExpressionSyntax</i> - access to a member of the class; </li><li>  And many other types. </li></ul><br><br><h4>  Example.  Parsing the if statement </h4><br>  Consider an example of how to use this knowledge in practice on the example of the <i>if</i> operator <i>.</i> <br><br>  Let the analyzed code have a fragment of the following form: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) c *= d; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> c /= d;</code> </pre> <br>  In the syntax tree, this fragment will be represented by a node of the <i>IfStatementSyntax</i> type <i>.</i>  Then you can easily get the information we are interested in by referring to the various properties of this class: <ul><li>  <i>Condition</i> - returns the condition checked in the statement.  The return value is a link of type <i>ExpressionSyntax</i> ; </li><li>  <i>Else</i> - returns the <i>else</i> branch of the <i>if statement</i> , if any.  The return value is a reference of the <i>ElseClauseSyntax</i> type; </li><li>  <i>Statement</i> - returns the body of the <i>if statement</i> .  The return value is a reference of type <i>StatementSyntax.</i> </li></ul><br><br>  In practice, it looks the same as in theory: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IfStatementSyntax node</span></span></span><span class="hljs-function">)</span></span> { ExpressionSyntax condition = node.Condition; <span class="hljs-comment"><span class="hljs-comment">// a == b StatementSyntax statement = node.Statement; // c *= d ElseClauseSyntax elseClause = node.Else; /* else c /= d; */ }</span></span></code> </pre> <br>  Thus, knowing the type of node, it is easy to obtain other nodes that are included in its composition.  A similar set of properties is also defined for other types of nodes characterizing certain constructions - method declarations, <i>for</i> loops <i>,</i> lambdas, etc. <br><br><h4>  Concretization of the node type.  SyntaxKind Enumeration </h4><br>  Sometimes it is not enough to know the type of node.  One of the cases is prefix operations.  For example, we need to select the prefix increment and decrement operators.  One could check the type of the node. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PrefixUnaryExpressionSyntax)</code> </pre> <br>  But such a check will not be enough, since the operators '!', '+', '-', '~' are suitable for this condition, because they are also prefix unary operators.  How to be? <br><br>  The <i>SyntaxKind</i> transfer comes to the <i>rescue</i> .  In this enumeration, all possible language constructions are defined, as well as its keywords, modifiers, etc. With the help of the elements of this enumeration, you can set a specific type of node.  The following properties and methods are defined for specifying the node type in the <i>SyntaxNode</i> class: <ul><li>  <i>RawKind</i> is an <i>Int32</i> property that stores an integer value that specifies this node.  In practice, the methods <i>Kind</i> and <i>IsKind</i> are more commonly used; </li><li>  <i>Kind</i> - a method that takes no arguments and returns an element of the <i>SyntaxKind</i> enumeration; </li><li>  <i>IsKind</i> is a method that takes a <i>SyntaxKind</i> enumeration member as an argument and returns <i>true</i> or <i>false</i> , depending on whether the exact node type matches the type of argument passed. </li></ul><br>  Using the <i>Kind</i> or <i>IsKind methods</i> , you can easily determine if a node is a prefix increment or decrement operation: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Kind() == SyntaxKind.PreDecrementExpression || node.IsKind(SyntaxKind.PreIncrementExpression))</code> </pre> <br>  Personally, I like the use of the <i>IsKind</i> method <i>more</i> , since the code looks more concise and more readable. <br><br><h3>  Syntax tokens </h3><br>  Syntax tokens (hereinafter - tokens) are the terminals of the grammar of the language.  Tokens are elements that are not subject to further parsing - identifiers, keywords, special characters.  In the course of code analysis, you have to work with them less often than with tree nodes.  However, if you still have to work with lexemes, as a rule, this is limited to obtaining a textual representation of the lexeme or checking its type. <br><br>  Consider the previously mentioned expression. <br><pre> <code class="cs hljs">a *= (b + <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  The figure below shows the syntax tree derived from this expression.  But here, in contrast to the previous figure, lexemes are also depicted.  The link between the nodes and the tokens that are part of them is clearly visible. <br><br><img src="https://habrastorage.org/files/3a6/1d9/64a/3a61d964a1784380975f1700778d9767.png"><br><br><h4>  Use in the analysis </h4><br>  All tokens are represented by the significant type of <i>SyntaxToken.</i>  Therefore, in order to find out what exactly the lexeme is, the previously mentioned methods <i>Kind</i> and <i>IsKind</i> and the elements of the <i>SyntaxKind</i> enumeration are <i>used</i> . <br><br>  If you need to get a textual representation of the lexeme, it suffices to refer to the <i>ValueText</i> property. <br><br>  You can also get the value of a lexeme (for example, a number if the lexeme is represented by a numeric literal), for which you simply need to refer to the <i>Value</i> property, which returns a reference of type <i>Object</i> .  However, to obtain constant values, the semantic model and the more convenient method <i>GetConstantValue</i> are usually used, which will be discussed in the appropriate section. <br><br>  In addition, syntax trivia (about what it is, is written in the next section) are tied to lexemes (in fact, to them, not to nodes). <br><br>  The following properties are defined for working with syntax trivia: <ul><li>  <i>HasLeadingTrivia</i> - a boolean value corresponding to the presence or absence of syntax trivia elements in front of the lexeme; </li><li>  <i>HasTrailingTrivia</i> - Boolean value corresponding to the presence or absence of syntax trivia elements after the lexeme; </li><li>  <i>LeadingTrivia</i> - elements of the syntax trivia preceding the lexeme; </li><li>  <i>TrailingTrivia</i> - elements of syntax trivia following the token. </li></ul><br><br><h4>  Usage example </h4><br>  Consider a simple <i>if statement</i> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) ;</code> </pre> <br>  This operator will be divided into several lexemes: <ul><li>  Keywords: 'if'; </li><li>  Identifiers: 'a', 'b'; </li><li>  Special characters: '(', ')', '==', ';'. </li></ul><br>  Example of getting token values: <br><pre> <code class="cs hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  Let the literal '3' come as an analyzed node.  Then get its text and numerical representation as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTokenValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LiteralExpressionSyntax node</span></span></span><span class="hljs-function">)</span></span> { String tokenText = node.Token.ValueText; Int32 tokenValue = (Int32)node.Token.Value; }</code> </pre> <br><br><h3>  Syntax trivia </h3><br>  Syntax trivia (additional syntax information) are those elements of the tree that will not be compiled into IL code.  These elements include formatting elements (spaces, newline characters), comments, preprocessor directives. <br><br>  Consider a simple expression of the following form: <br><pre> <code class="cs hljs">a = b; <span class="hljs-comment"><span class="hljs-comment">// Comment</span></span></code> </pre> <br>  Here you can highlight the following additional syntactic information: spaces, single-line comments, end of line character.  The links between additional syntax information and tokens are clearly shown in the figure below. <br><br><img src="https://habrastorage.org/files/29e/f8b/f5b/29ef8bf5b884424e8cba8c82626b304a.png"><br><br><h4>  Use in the analysis </h4><br>  Additional syntax information, as mentioned earlier, is related to lexemes.  Share Leading trivia and Trailing trivia.  Leading trivia is an additional syntax information preceding a lexeme, trailing trivia is additional syntax information following a lexeme. <br><br>  All elements of additional syntax information are of type <i>SyntaxTrivia</i> .  To determine what exactly the element is (space, single-line comment, multi-line comment, etc.) use the <i>SyntaxKind</i> enumeration and the methods <i>Kind</i> and <i>IsKind</i> already known to you. <br><br>  As a rule, with static analysis, all work with additional syntactic information is reduced to determining what its elements are, and sometimes to analyzing the text of an element. <br><br><h4>  Usage example </h4><br>  Suppose we have the following code being analyzed: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// It's a leading trivia for 'a' token a = b; /* It's a trailing trivia for ';' token */</span></span></code> </pre> <br>  Here, a single-line comment will be tied to the lexeme 'a', and a multi-line comment - to the lexeme ';'. <br><br>  If as a node we get the expression <i>a = b;</i>  , it is easy to get the text of single-line and multi-line comments as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetComments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExpressionSyntax node</span></span></span><span class="hljs-function">)</span></span> { String singleLineComment = node.GetLeadingTrivia() .SingleOrDefault(p =&gt; p.IsKind( SyntaxKind.SingleLineCommentTrivia)) .ToString(); String multiLineComment = node.GetTrailingTrivia() .SingleOrDefault(p =&gt; p.IsKind( SyntaxKind.MultiLineCommentTrivia)) .ToString(); }</code> </pre> <br><br><h3>  Short summary </h3><br>  Briefly summarizing the information in this section, we can single out the following points regarding the syntax tree: <ul><li>  The syntax tree is the basic element required for static analysis; </li><li>  The syntax tree is unchangeable; </li><li>  By traversing the syntactic tree, we go around various language constructs, each of which has its own type; </li><li>  For each type corresponding to any syntactic construction of the language, there is a workaround method, by redefining which, you can set the processing logic of the node; </li><li>  The three main elements of the tree are <i>syntax nodes</i> , <i>syntax tokens</i> , <i>syntax trivia</i> ; </li><li>  <i>Syntax nodes</i> are syntactic constructs of a language.  This category includes ads, definitions, operators, etc .; </li><li>  <i>Syntax tokens</i> - lexemes, the final characters of the grammar of the language.  This category includes identifiers, keywords, specials.  characters, etc .; </li><li>  <i>Syntax trivia</i> - additional syntax information.  This category includes comments, preprocessor directives, spaces, etc. </li></ul><br><br><h2>  Semantic model </h2><br>  The semantic model provides information about objects and types of objects.  This is a very powerful tool that allows for in-depth and complex analysis.  That is why it is important to have a correct compilation and a correct semantic model.  Let me remind you that for this project must be compiled. <br><br>  It should be remembered that in the analysis we work with nodes, and not with objects.  Therefore, to obtain information, for example, neither the <i>is</i> operator nor the <i>GetType</i> method will work about the type of the object, since they provide information about the node, and not about the object.  For example, suppose we analyze the following code: <br><pre> <code class="cs hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  That such <i>a</i> , from this code it is possible to build only assumptions.  It is not possible to say whether it is a local variable, or a property, or a field, only approximate type assumptions can be made.  But guesses do not interest anyone, we need accurate information. <br><br>  One could try to walk up the tree to declare a variable, but that would be too wasteful in terms of performance and amount of code.  In addition, the ad can easily be somewhere in another file, or even in a third-party library, the source code of which we do not have <br><br>  Here the semantic model comes to the rescue. <br><br><img src="https://habrastorage.org/files/956/a7c/80d/956a7c80d4dd4f528c3d7feecd71fb52.png"><br><br>  There are 3 most frequently used functions provided by the semantic model: <ul><li>  Getting information about the object; </li><li>  Getting information about the type of object; </li><li>  Getting constant values. </li></ul><br><br>  Each of these points should be discussed in more detail, since they are all important and widely used in static code analysis. <br><br><h3>  Getting information about the object.  Symbol </h3><br>  Information about the object is provided by the so-called symbols. <br><br>  The basic symbol interface, <i>ISymbol</i> , provides methods and properties that are common to all objects, regardless of whether they are a field, a property, or something else. <br><br>  There are a number of derived types, casting to which you can get more specific information about the object.  These interfaces include <i>IFieldSymbol</i> , <i>IPropertySymbol</i> , <i>IMethodSymbol,</i> and others. <br><br>  For example, using the cast to the <i>IFieldSymbol</i> interface and referring to the <i>IsConst</i> field, <i>you</i> can find out if the node is a constant field.  And if you use the <i>IMethodSymbol</i> interface, you can find out if the method returns any value. <br><br>  For characters, a <i>Kind</i> property is defined that returns the elements of the <i>SymbolKind</i> enumeration.  According to its purpose, this listing is similar to the <i>SyntaxKind</i> listing.  That is, using the <i>Kind</i> property, you can find out what we are working with now ‚Äî a local object, a field, a property, an assembly, etc. <br><br><h4>  An example of use.  We find out if a node is a constant field. </h4><br>  Suppose there is a definition of a field of the following form: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int32 a = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br>  And somewhere below - the following code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a;</code> </pre> <br>  Suppose we need to find out if <i>a</i> is <i>a</i> constant field.  From the above expression, you can get the necessary information about the node <i>a</i> , using the semantic model.  The code for obtaining the necessary information is as follows: <br><pre> <code class="cs hljs">Boolean? IsConstField(SemanticModel model, IdentifierNameSyntax identifier) { ISymbol smb = model.GetSymbolInfo(identifier).Symbol; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smb == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smb.Kind == SymbolKind.Field &amp;&amp; (smb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IFieldSymbol).IsConst; }</code> </pre> <br>  First we get the symbol for the identifier using the <i>GetSymbolInfo</i> method of <i>an</i> object of the <i>SemanticModel</i> type, and then immediately access the <i>Symbol</i> field (it contains the information we are interested in, so in this case it makes no sense to store the <i>SymbolInfo</i> structure returned by the <i>GetSymbolInfo</i> method). <br><br>  After checking for <i>null</i> , using the <i>Kind</i> property specifying the character, we see that the identifier is actually a field.  If this is indeed the case, we perform a cast to the derived interface <i>IFieldSymbol</i> , which will allow us to access the <i>IsConst</i> property, thereby obtaining information about the constancy of the field. <br><br><h3>  Getting information about the type of object.  ITypeSymbol interface </h3><br>  It is often necessary to know the type of object represented by the node.    ,  <i>is</i>   <i>GetType</i>  ,       <i></i> ,   <i> .</i> <br><br>  ,  ,   .    ,   <i>ITypeSymbol</i> .      <i>GetTypeInfo</i>   <i>SemanticModel</i> .      <i>TypeInfo</i> ,  2  : <br><ul><li> <i>ConvertedType</i> ‚Äì         .    ,    ,    <i>Type</i> ; </li><li> <i>Type</i> ‚Äì   ,   .     ,   <i>null.</i>       - - ,   <i>IErrorTypeSymbol</i> . </li></ul><br>   <i>ITypeSymbol</i> ,   ,       .        ,     : <ul><li> <i>AllInterfaces</i> ‚Äì     .    ,   ; </li><li> <i>BaseType</i> ‚Äì  ; </li><li> <i>Interfaces</i> ‚Äì  ,    ; </li><li> <i>IsAnonymousType</i> ‚Äì   ,    ; </li><li> <i>IsReferenceType</i> ‚Äì   ,    ; </li><li> <i>IsValueType</i> ‚Äì   ,    ; </li><li> <i>TypeKind</i> ‚Äì   (  <i>Kind</i>   <i>ISymbol</i> ).    ,      ‚Äì , ,   .. </li></ul><br><br>  ,       ,      . ,      <i>a + b</i> ,      <i>a</i>  <i>b</i> .      ,               . <br><br>  ,     <i>ISymbol</i> ,    ,     . <br><br><h4>  .       </h4><br>  ,     ,  ,    ,    : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInterfacesNames</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SemanticModel model, IdentifierNameSyntax identifier</span></span></span><span class="hljs-function">)</span></span> { ITypeSymbol nodeType = model.GetTypeInfo(identifier).Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeType == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeType.AllInterfaces .Select(p =&gt; p.Name) .ToList(); }</code> </pre> <br>   ,        ,       , ,   . <br><br><h3>    </h3><br>         .       , ,    .   ,     ,  .        .       ,   ,       ‚Äì    .   ,  , ,        . <br><br>       <i>GetConstantValue</i> ,   <i>Optional&lt;Object&gt;</i> ,  ,         . <br><br><h4>  .     </h4><br> ,    : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> String str = <span class="hljs-string"><span class="hljs-string">"Some string"</span></span>;</code> </pre> <br>  -      <i>str</i> ,        ,     : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConstStrField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SemanticModel model, IdentifierNameSyntax identifier</span></span></span><span class="hljs-function">)</span></span> { Optional&lt;Object&gt; optObj = model.GetConstantValue(identifier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optObj.HasValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optObj.Value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String; }</code> </pre> <h3>   </h3><br>     ,    ,   : <ul><li>      ( ,    .); </li><li>       ; </li><li>         ; </li><li>       <i>ISymbol</i> ; </li><li>        <i>ITypeSymbol</i> ; </li><li>           . </li></ul><br><br><h2> Syntax visualizer </h2><br> Syntax visualizer ( ‚Äì ) ‚Äì     Visual Studio,    Roslyn SDK (     Visual Studio).  ,    ,     . <br><br><img src="https://habrastorage.org/files/ec2/358/b24/ec2358b241e240bb918c303ba782c8de.png"><br><br>    ,    ,  ‚Äì ,  ‚Äì   .         ,  <i>Kind</i> ,  .       <i>ISymbol</i>  <i>ITypeSymbol</i>   . <br><br>       TDD,         -,        .       , ,           ,     ( )    ,       . <br><br>     ,    ,       .              <i>View Directed Syntax Graph</i> .          ,      . <br><br><img src="https://habrastorage.org/files/48a/741/42e/48a74142e6e240f689f2d8c1b5ce395b.png"><br><br> <b>  .</b> <br><br>    PVS-Studio  ,     .  ,   ,       ‚Äî <a href="https://github.com/icsharpcode/ILSpy">ILSpy</a> ‚Äî    <a href="">Parser.cs</a> ,     -     <i>if</i> .  ,        .      ,       ,    ,   ,   Visual Studio,    ¬´¬ª   . <br><br>   .   ,   ¬´¬ª  <i>if</i>      (,  3218). <br><br><h2> ,        </h2><br>   ,   ,   .             . <ol><li>           ,   .         ,           .      ,    . ,       ,      .   ,    ,      ,     ; </li><li>        .          . ,     ,   .  ,       ,   ; </li><li>     ,    ,   .    , .   ,          ,         ,        .   ,       ,      .     ,    ‚Äì      ,   ‚Äì  0; </li><li>        , ,     ,        .       -,   ‚Äì  ,     ,    ‚Äì  ,      ; </li><li>         TDD.       -,        .          ,         .         ; </li><li>      .     ,      -  ,       .         ,    ,     ,   -. </li></ol><br><br><h2>     </h2><br>  ,   ,      .        ,  ,      . <br><br><img src="https://habrastorage.org/files/a21/1ef/8e5/a211ef8e5e6649de82cf67bc3b65f8e9.png"><br><br><ol><li>      .    ,        ,    ‚Äì ; </li><li>          ,      ,    -,   ‚Äì      .       .             ,        .         .      ,   -   .         ,         ; </li><li>  ,     -,     .      ‚Äì        ; </li><li>  ,    ,   -   ,      ‚Äì    .      (   )  ,   -.       ,        ,       ; </li><li>          ,         .  ,  ,   !       ; </li><li>      ,      .      . </li></ol><br><br><h2>   .    throw </h2><br><br><img src="https://habrastorage.org/files/ef4/77c/f0a/ef477cf0a7054cb8a672ecdac6f49ee1.png"><br><br>     PVS-Studio   <a href="http://www.viva64.com/ru/d/0404/">V3006</a> ,     <i>throw</i> .   ‚Äì   ,        (     ,      ..). ,  ,  ,     <i>throw</i> .      ,          . <br><br>       ,    -. <br><br>   : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException();</code> </pre> <br>   : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FieldAccessException();</code> </pre> <br>        : <ol><li>      <i>ObjectCreationExpressionSyntax</i> .          <i>new</i> ‚Äì   ,   ; </li><li> ,        <i>System.Exception</i> (..   ,  ).   ,  ,     .        (,       ); </li><li> ,     (        ); </li><li>     ‚Äì  . </li></ol><br>        .       ,        .             . <br><br>      <i>throw</i> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> String ExceptionTypeName = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Exception).FullName; <span class="hljs-function"><span class="hljs-function">Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMissingThrowOperator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SemanticModelAdapter model, ObjectCreationExpressionSyntax node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsExceptionType(model, node)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsReferenceUsed(model, node.Parent)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>    ,   ,   ,  .      ,     ‚Äì  .     ,    . <br><br> -    <i>SemanticModelAdapter</i> .    ,     .         ,      (  <i>SemanticModel</i> ). <br><br>  ,    : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExceptionType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SemanticModelAdapter model, SyntaxNode node</span></span></span><span class="hljs-function">)</span></span> { ITypeSymbol nodeType = model.GetTypeInfo(node).Type; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (nodeType != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !(Equals(nodeType.FullName(), ExceptionTypeName))) nodeType = nodeType.BaseType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Equals(nodeType?.FullName(), ExceptionTypeName); }</code> </pre> <br><br>   ‚Äì    ,    .    ,      ‚Äì <i>System.Exception</i> , ,     ‚Äì  . <br><br>  ,        : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsReferenceUsed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SemanticModelAdapter model, SyntaxNode parentNode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentNode.IsKind(SyntaxKind.ExpressionStatement)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentNode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> LambdaExpressionSyntax) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (model.GetSymbol(parentNode) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IMethodSymbol) ?.ReturnsVoid == <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><br>    ,   ,       :   ,   ,     ..    ,        .     . <br><br>  , ,   ‚Äì  ,    ‚Äì  .        .    ‚Äì -, ,      . <br><br><h2> Roslyn.  Advantages and disadvantages </h2><br> Roslyn ‚Äì  .   ,         ,     ,     .         .  ,       . <br><br><h3>  Virtues </h3><br><ul><li>   .         ,       .      ,      ,      .  ,         ,     ; </li><li>    .              .   ,       ,     ; </li><li>  . ,       ,        ,     ; </li><li>   .      ,   ,    .        ,      ‚Äì     . </li></ul><br><h3>  disadvantages </h3><br><ul><li>      .  Roslyn      (  - ,   ..), -       ,   ‚Äì  .      ,        .     (, MSBuild)    /; </li><li>     ,  ,  .  ‚Äì  .  <i>Equals</i>     ,   .     . </li><li> ,    Roslyn,     ().   64-         ,     .  ,          . </li></ul><br><br><h2> PVS-Studio ‚Äì   ,  Roslyn API </h2><br> <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> ‚Äì    ,        ,   C, C++, C#. <br><br><img src="https://habrastorage.org/files/40d/3c0/c7e/40d3c0c7e7b846e1ba07515ef806cfab.png"><br><br>   ,     C# ,    Roslyn API.   ,  ,     ‚Äì         . <br><br> PVS-Studio   ,    ,  Roslyn.        80  . PVS-Studio      .  Some of them: <ul><li>  Roslyn; </li><li> MSBuild; </li><li> CoreFX; </li><li> SharpDevelop; </li><li> MonoDevelop; </li><li> Microsoft Code Contracts; </li><li> NHibernate; </li><li> Space engineers; </li><li>  And many others. </li></ul><br><br>     ,    ,    ‚Äì      .     <a href="http://www.viva64.com/ru/pvs-studio-download/"> </a> ‚Äì ,      . <br><br>     : ¬´         ?¬ª.   !  - ,     ,    <a href="http://www.viva64.com/ru/examples/"> </a> ,   open source .    <a href="http://www.viva64.com/ru/b"></a>         . <br><br><h2>  Results </h2><br><h3>  General </h3><br><ul><li> Roslyn        .          ,     ; </li><li>       ,          ; </li><li> 2 ,     ‚Äì     .     ,     ; </li><li>    ‚Äì   ; </li><li> Syntax visualizer ‚Äì  ,       . </li></ul><br><h3>   </h3><br><ul><li>       . </li><li>   3-   ‚Äì syntax nodes, syntax tokens, syntax trivia; </li><li>  ‚Äì   ,        ; </li><li>        ,      ,     ; </li><li>  ‚Äì   ,  ,  ,   .; </li><li>    ‚Äì ,  ,    .; </li><li>   <i>IsKind</i>   <i>SyntaxKind</i>     . </li></ul><br><h3>   </h3><br><ul><li>      ; </li><li>        ; </li><li>   <i>GetSymbolInfo</i> ,  <i>ISymbol</i>          ; </li><li>   <i>GetTypeInfo</i> ,  <i>ITypeSymbol</i>            ; </li><li>   <i>GetConstantValue</i>    . </li></ul><br><h3>   </h3><br><ul><li>     ,   ,   .        ; </li><li>       ,         ; </li><li>   ; </li><li>   -,  ; </li><li>           . </li></ul><br><br><h2>  Conclusion </h2><br><img src="https://habrastorage.org/files/d20/4b4/e66/d204b4e66de24c73b40800c2e2e6fe33.png"><br><br>  ,   ,  Roslyn ‚Äî    ,         ‚Äì ,      .   Microsoft  Roslyn,       . <br><br>     ‚Äì  ,    .           .              Roslyn API,   . <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0399/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev. <a href="http://www.viva64.com/en/b/0399/">Introduction to Roslyn and its use in program development</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/301204/">https://habr.com/ru/post/301204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301192/index.html">[Terraform + SaltStack] Cooking PrestoDB Cluster in a Pressure Cooker (Part # 1)</a></li>
<li><a href="../301194/index.html">How to create eye-catching images if you are not a designer</a></li>
<li><a href="../301196/index.html">Criminals infecting ATMs with a virus caught hot</a></li>
<li><a href="../301198/index.html">LinkedIn recommends users change passwords.</a></li>
<li><a href="../301200/index.html">How I did a web store template in Sketch.app for Themeforest. Part 2: we lay out the goods</a></li>
<li><a href="../301206/index.html">Prospects for a shared consumption economy. Part 2</a></li>
<li><a href="../301208/index.html">Paul Graham. Persuade XOR to describe (Persuade xor Discover)</a></li>
<li><a href="../301210/index.html">Google promises to release a new messenger</a></li>
<li><a href="../301212/index.html">How to enter the "stream": a magic scheme that will suit everyone</a></li>
<li><a href="../301214/index.html">Count the invisible: reliably determine vocabulary</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>