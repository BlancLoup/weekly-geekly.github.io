<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ES6 Simple language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pattern Literals 
 Sample literals are enclosed in backquotes (``) instead of double or single. They may contain substitutions, denoted by a dollar si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ES6 Simple language</h1><div class="post__text post__text-html js-mediator-article"><h2>  Pattern Literals </h2><br>  Sample literals are enclosed in backquotes (``) instead of double or single.  They may contain substitutions, denoted by a dollar sign and curly brackets ($ {expression}). <br><br>  Example: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">"bill"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello bill</span></span></code> </pre> <a name="habracut"></a><br><h2>  Directives let const </h2><br>  The scope of variables declared by the let and const keywords is the block in which they are declared, and all its sub-blocks.  In this work, the let directive is similar to the var directive.  The main difference is that the scope of the variable declared by the var directive is the entire function in which it is declared.  In addition, variables declared with the const keyword are constant constants.  When declaring a variable with the const keyword, you must use an assignment operator to set a constant value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An example of the difference between the global and block scope: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><h2>  Arrow functions </h2><br>  The expressions of the switch functions have a shorter syntax compared to functional expressions and are lexically bound to the value of this (but not attached to its own this, arguments, super, or new.target).  Arrow functions are always anonymous. <br><br>  <b>Examples of arrow functions:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squared = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFun = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> someFun(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Fun = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { data.response }</code> </pre> <br><h2>  For ... of </h2><br>  The for ... of operator performs a loop traversal of iterated objects (including Array, Map, Set, an object of arguments and the like), calling at each iteration step operators for each value from the various properties of the object. <br><br>  Why SHOULD NOT use a for ... in loop to iterate?  Because, depending on the engine, JavaScript can iterate in random order, which can lead to unpredictable results.  In addition, the iteration variable is a string, not a number, which means that if you are going to perform any calculations with a variable, you will need to concatenate the strings instead of adding them.  So in order to avoid logical errors should not use it! <br><br>  <b>For ... of loop</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br><h2>  Calculated Names </h2><br>  The syntax for declaring objects and their elements supports computed property names.  This allows brackets [] to add an expression that will be evaluated as the name of a property.  It resembles patterned literals. <br><br>  <b>Example of calculated names:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut><br><h2>  Object.assign () </h2><br>  The Object.assign () method is used to copy the values ‚Äã‚Äãof all of its own enumerated properties from one or more source objects to the target object.  After copying, it returns the target object. <br><br>  <b>An example of using Object.assign ():</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = newStudent = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, person, student);</code> </pre> <br>  Now newStudent contains all the properties and methods of the person and the student. <br><br>  In ES5, when creating a duplicate object, a mutation effect occurs when changes in the duplicate are reflected on the parent object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> B = A; Ba = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  It would seem that we change the property of object B BUT after executing this code, and Ba and Aa will be equal to 2. The situation can be corrected using the Object.assign () method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> B = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, A); Ba = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Now only Ba will be equal to 2 a, Aa still equal to 1. <br><br>  In Object.assign (), you can immediately set the property values ‚Äã‚Äãand declare new ones by passing them as an argument. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> B = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({ <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}, A, { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> });</code> </pre> <br>  Property b is created and the value of property a is changed from the parent object. <br>  And now Ba is 2. Bb is 3. <br><br><h2>  Remaining parameters </h2><br>  The syntax of the remaining parameters of the function allows you to represent an unlimited set of arguments in the form of an array.  If the last named argument of the function has a prefix ..., then it automatically becomes an array with elements from 0 to theArgs.length in accordance with the actual number of arguments passed to the function. <br><br>  <b>An example of using the syntax of the remaining parameters:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  In this example, a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  If the remaining parameter is not passed, it will be an empty array (unlike normal parameters, it will never be undefined). <br><br>  This syntax can be used not only in function arguments but also in other places, for example, to copy and merge arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><h2>  Default settings </h2><br>  Now you can define default values ‚Äã‚Äã(other than undefined) to parameters that were not passed to the function. <br><br>  <b>An example of using default parameters:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <br><h2>  Destructuring assignment </h2><br>  The syntax for destructive assignment in JavaScript expressions allows you to extract data from arrays or objects using a syntax similar to declaring an array or literals in an object. <br><br>  <b>Example of destructive assignment:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br><h2>  Map and Set </h2><br>  Map - An object containing key-value pairs and preserving the insertion order.  Any value (both objects and primitives) can be used as keys. <br><br>  <b>Example:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Difference Map from Object:</b> <br><br><ul><li>  Object keys are Strings and Characters, while any value can be a Map key, including functions, objects, and primitives. </li><li>  Unlike Objects, the keys in the Map are ordered.  Thus, during Map iteration, the keys are returned in the order of insertion. </li><li>  You can easily get the number of elements in the Map using the size property, while the number of Object elements can only be determined manually. </li><li>  Map is an iterable object and can be iterated directly, while the Object requires manual retrieval of a list of keys and their iteration. </li><li>  The object has a prototype and therefore has a standard set of keys that, if careless, may intersect with your keys.  Since the release of ES5, this can be changed with map = Object.create (null). </li><li>  Map may have better performance in cases of frequent addition or deletion of keys. </li></ul><br>  <b>Properties and methods:</b> <br><br><ul><li>  Map.prototype.size - Returns the number of key / value pairs on a Map. </li><li>  Map.prototype.set (key, value) - Adds the transferred key / value pair to the Map.  If the specified key already exists, it will be overwritten by the new value. </li><li>  Map.prototype.get (key) - Returns the value of the passed key.  If there is no key, then undefined </li><li>  Map.prototype.has (key) - Returns true if the transferred key exists and false if it does not exist. </li><li>  Map.prototype.delete (key) - Deletes the specified key / value pair and returns true.  Returns false if the key does not exist. </li><li>  Map.prototype.clear () - Removes all key / value pairs from the Map. </li><li>  Map.prototype.keys () - Returns an iterator of keys on the Map for each item. </li><li>  Map.prototype.values ‚Äã‚Äã() - Returns an iterator of the values ‚Äã‚Äãin Map for each item. </li><li>  Map.prototype.entries () - Returns an iterator of the [key, value] array on the Map for each element. </li></ul><br>  <b>Set</b> - Allows you to save unique values ‚Äã‚Äãof any type, both primitives and other types of objects.  Set objects represent collections of values ‚Äã‚Äãthat can be traversed in order to insert items.  The value of an element in a Set can be present only in one instance, which ensures its uniqueness in the Set collection.  For the rest, no different from Map. <br><cut><br><h2>  Classes </h2><br><h4>  Constructors </h4><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br>  When creating new objects from a class, constructor () will be launched, which is necessary for initializing objects. <br><br><h4>  Methods </h4><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hi my name is "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> stMethod () { <span class="hljs-comment"><span class="hljs-comment">// do something } } var robert = new Student('Robert'); Student.stMethod(); //        ,       console.log(robert.sayName()); // "Hi my name is Robert"</span></span></code> </pre> <br><br><h4>  Getters and Setters </h4><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li>  setter - Required for validations of written parameters (as in the example above) </li><li>  getter - Required for getting properties (although you can get them directly).  Cannot have arguments </li></ul><br>  In ES6, there is no built-in encapsulation, but you can organize it yourself.  For example, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><h4>  Inheritance </h4><br>  Using the extends keyword, you can inherit the properties and methods of another class. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><ul><li>  In the child class, you need to call super () before using this to call the parent class constructor. </li><li>  super () can be used to call methods of the parent class from a child. </li></ul><br><h2>  Promise </h2><br>  <i>Promise</i> is a new way to do asynchronous computing without a race condition. <br>  <i>Promise</i> can be in three states: <br><br><ul><li>  pending: initial state, not met and not rejected. </li><li>  fulfilled: the operation completed successfully. </li><li>  rejected: operation completed with an error. </li></ul><br>  Creating promises is done as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(someValue); <span class="hljs-comment"><span class="hljs-comment">//   reject("failure reason"); //  });</span></span></code> </pre> <br>  The function object with two arguments, <b>resolve</b> and <b>reject,</b> causes the promise to succeed, the second one rejects it. <br><br>  To provide the function with promises functionality, you just need to return the Promise object in it. <br><br>  Handler execution and reject promises are attached using .then. <br><br>  This example creates an asynchronous http request: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else //     url :D { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><br><h2>  Iterators </h2><br>  Iterable - This is an object whose contents can be iterated. <br>  An iterable object differs from a non-iterable one in that it has a special method that returns an object for which the special symbol is used: Symbol.iterator <br><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br>  The object returning this method is formally called an iterator. <br>  The iterator has only one method next () <br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br>  Which returns an object (let's name it itreratorResult) with two properties done and value <br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br>  done indicates whether there is another value in the sequence being searched, and value contains the next element of the sequence. <br><br>  A loop for ... of has been added to iterate through the objects being iterated.  Why, then, need an iterator?  To be honest ... I do not know.  The iterator is a utility method, and you will have to deal with it vryatle.  But the understanding of what he is is necessary. <br>  Actually, the iterator itself looks like this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} : {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } } }</code> </pre> <br><h2>  Generators </h2><br>  Generators are a special type of function that works as an iterator factory.  A function becomes a generator if it contains one or more <i>yield</i> operators and uses the <i>function</i> * syntax. <br><br>  And if it is easier to say, then generators are a new kind of functions that can suspend their execution and return an intermediate result and resume execution later. <br>  Let's look at a normal function that performs some mathematical calculations and returns a result: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br>  Now take a look at a similar function generator: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9</span></span></code> </pre> <br>  As mentioned earlier, generators can suspend their execution and return an intermediate result.  This example shows that at the time of the first call, the function seems to suspend its execution at the first yield point and returns the result of the first expression.  In the second call, the function continues from the previous blockpoint and moves to the next, returning the result of the next expression. <br><br>  Functions generators provide a powerful tool for writing complex sequential functions. <br><br><h2>  Symbol </h2><br>  Symbol is a unique and immutable data type that can be used as an identifier for object properties.  They are service tools and therefore you hardly have to work with them, but you need to know them.  Why do we need a new data type?  It is needed so that language developers can add new identifiers or properties of objects without reserving string names for these properties. <br><br>  So you can create a character property: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br>  To get an array of character objects, use the Object.getOwnPropertySymbols (obj) property; <br>  To gain access anywhere in your code, use the Symbol.for () and Symbol.keyFor () methods. </cut></cut></div><p>Source: <a href="https://habr.com/ru/post/460741/">https://habr.com/ru/post/460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460731/index.html">US authorities completed an investigation into the accident robotovusa, which occurred in 2017</a></li>
<li><a href="../460735/index.html">CI \ CD for a startup: what tools are there, and why not only large and well-known companies use them</a></li>
<li><a href="../460737/index.html">Listen to the background: podcasts about project management</a></li>
<li><a href="../460739/index.html">We come with the world from all mankind</a></li>
<li><a href="../46074/index.html">Civic journalism in the blogosphere</a></li>
<li><a href="../460745/index.html">Experience of using GSM module in home automation</a></li>
<li><a href="../460747/index.html">Find profit or crackdown: Spotify stopped working directly with the authors - what does it mean</a></li>
<li><a href="../460751/index.html">How we launched robots in small Chernobyl</a></li>
<li><a href="../460755/index.html">The robot that will go for your smile. We make a cheap cart for studying ROS. Part 1, iron</a></li>
<li><a href="../460769/index.html">Setting up a server to deploy a Rails application using Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>