<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hash array mapped trie</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hash array mapped trie is an associative container that has hash table and trie properties. Key-value pair insertion and key search operations are O (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hash array mapped trie</h1><div class="post__text post__text-html js-mediator-article">  Hash array mapped trie is an associative container that has hash table and trie properties.  Key-value pair insertion and key search operations are O (1) operations. <br>  About trie on Habr√© already <a href="http://habrahabr.ru/post/111874">wrote</a> . <br><br><a name="habracut"></a><br><br><h4>  Structure array mapped trie </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Strings are often stored in trie, so there is a concept of an alphabet from which elements can be composed.  To optimize for x32 limit the size of the alphabet to 32 (0 - 31). <br>  Let's see what array mapped trie looks like, it‚Äôs AMT (taken from [1]): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/598/ad0/5f2/598ad05f260345e9a826abe00b225609.png"></div><br><br>  AMT consists of a node and several segments connecting our node and other nodes.  Each segment is one of the possible symbols of the alphabet. <br>  The node contains a 32-bit structure (bitmap), each bit of the structure reflects the state of one of the 32 segments (0 - no, 1 - is).  Also in the node is a table in which pointers to subtrees or the last characters in a given substring (leaves) are stored.  The pointers in the table are stored in order, and each of the pointers corresponds to a bit = 1 in the bit structure. <br>  Example: to find the character 's', you must go through the bit structure to the corresponding bit.  While we are going according to the structure, we count bits = 1 (cocked bits).  Suppose we counted 5 cocked bits, and the bit corresponding to 's' turned out to be the 6th cocked bit.  Accordingly, we need the 6th pointer in the table of this node.  If the bit is not entered (= 0), then this symbol is not. <br><br><h4>  Structure hash array mapped trie </h4><br><br>  We now turn to <abbr title="Hash array mapped trie">HAMT</abbr> .  The upper bits of the hash are used instead of the alphabet.  This is what HAMT looks like (taken from [1]): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bbd/9ef/f9d/bbd9eff9d1e0447684cf93a18fe0f921.png"></div><br><br>  HAMT consists of a main hash table of size 2 ^ t, where usually t&gt; = 5. Each element of the main table: <br>  1. either the root node of the sub-table tree with a size of 32 <br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> Node: <span class="hljs-type"><span class="hljs-type">int</span></span> bitmap (<span class="hljs-number"><span class="hljs-number">32</span></span> bits) Node*[] <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (max length <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br><br>  2. either just a pair of key - value <br><pre> <code class="hljs pgsql">Key <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Node: K key V <span class="hljs-keyword"><span class="hljs-keyword">value</span></span></code> </pre><br><br>  The choice of hash function depends on your data set.  It is advisable to choose a hash function that gives the minimum number of collisions (for more details about collisions in [2]). <br><br><h4>  Item Search </h4><br><br>  1. Generate a 32-bit hash for the key. <br>  2. From the resulting hash, we take t high bits (note: we take t high bits only for the first time, the rest - 5 bits each) and use them as an index in the table.  There are 3 possible options: <br>  a) there is nothing in the cell with such an index ‚Äî there is no such key in the table; <br>  b) there is one key / value pair in the cell.  If the key matched - found the item, did not match - did not find; <br>  c) a 32-bit bitmap and a table with pointers are stored in the cell.  In this case, take the next 5 bits of the hash and use them again as an index in the bitmap.  If the bit is not cocked, then there is no such key; if it is cocked, then we count all the coded bits from the beginning to the current (as in AMT).  So we got the number of the required pointer in the table.  Follow the pointer and repeat the algorithm. <br><br>  Often, only a few iterations of this algorithm are needed (although this depends on the fullness of the tree).  The key is compared only once - when we are in a situation b.  The lack of a key is also detected early enough. <br><br><h4>  Insert item </h4><br><br>  Repeat the steps from the insertion algorithms until one of 3 situations occurs: <br>  a) there is nothing in the cell with such an index; <br>  b) a 32-bit bitmap and a table with pointers are stored in the cell; <br>  In both cases, the algorithms are simple: if the insertion occurs in the main table, then simply insert the key / value pair.  If the insertion occurs in a sub-table, then we coax the corresponding bit, allocate a new table of pointers, copy into it pointers from the old table and a new pointer to our pair, and delete the old table. <br>  As a result, we have set the bit of the corresponding cell, in the pointer table all the old pointers, and also in the corresponding cell the new pointer. <br>  c) a collision occurred - i.e., some part of the two hashes coincided with us.  The solution is simple - we create a new sub-table, from the existing key we calculate the hash and use the next 5 bits to find the desired cell.  We tap the bit in this cell, insert into the pointer table the pointer to the existing key / value pair, go back to the pair to be inserted, take the next 5 bits too, and look for the desired cell.  This step with the creation of a new subdatasheet is repeated until the collision disappears. <br>  With each such step, the probability of a collision decreases 32 times (the size of the table of pointers and bitmap). <br>  Sometimes we get a complete collision - all 32 bits of hashes of two different keys are the same.  Then we take the following hash function and hash it with two conflicting keys.  As a result, when we search for the key element - we go through all the bits of the primary hash, we see that we did not come to the list, but to the subtable, and calculate the new hash of the key using the second function. <br>  In general, this is not the only way to solve collisions, there are others in different implementations.  In his work, the author proposes to use the same hash function, simply after a collision, to give her the key and the level of the tree in which we are at this step of the algorithm (0 - root table, etc.).  If an application is critically important that the insert operation time is limited from above (theoretically, we can take two such keys, that their hashes will coincide after several calls to the rehash function, which means that the insert operation will take a very long time), then instead of rehashing the matching keys you can use the keys themselves. <br><br><h4>  Memory allocation </h4><br><br>  We need pools from 1 to 32 elements (for tables of various sizes).  Select the memory blocks and divide them into the corresponding tables.  In the process of work, the fragmentation will gradually increase.  In order to return the memory, it is necessary to defragment.  You can set a limit on the amount of fragmented memory in percent, check it when inserting an element and when it exceeds the limit - defragment it.  The defragmentation operation can be implemented as an O (1) operation. <br><br><h4>  Resize root table </h4><br><br>  At some point, the tree will grow so much that increasing the size of the root table will give a noticeable increase in speed.  Each subtable has 32 elements, so the change from 2 ^ t to 2 ^ (t + 5) will be the most logical.  When increasing the size, all sub-tables of the first level fall into the root table.  Moreover, reheshirovanie need only in the case when we have in the root table fall leaves of the tree (you need to re-calculate the hash to determine the new position of the element).  In other cases, simply copy the elements from the subtable into the root table. <br>  It is possible not to immediately copy all the subtables into the root table, but gradually.  In this case, the transfer index is memorized.  All items below the index are copied to the new table, and the index gradually moves up the old table.  During the search, the first t bits of the hash are compared with the transfer index ‚Äî if the hash is greater, the search is directed to the old table, otherwise to the new one.  The insertion algorithm must also take into account the transfer index. <br>  When should I increase the root table?  When the size of the new table will occupy 1 / f from the entire tree.  The parameter f must be selected based on the specific situation. <br><br><h4>  Memory required </h4><br><br>  The amount of memory depends on the transfer index.  The author in his work gave a table showing this dependence (taken from [1]) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/893/f06/098/893f060981124c6bb42ba449e097f0fd.png"></div><br><br>  That is, if the transfer index = N / 4, where N is the number of key-value pairs inserted into the tree, then the occupied memory is proportional to 1.28 * N. <br><br><h4>  Remove item </h4><br><br>  During removal, two situations can occur: <br><br>  a) delete the element in the sub-table with the number of elements greater than 2. Then you need to move all other elements to a smaller sub-table, and mark the current one as empty. <br>  b) delete the element in the subtable with the number of elements equal to 2. In this situation, the remaining element is simply transferred to the subtable a higher level, and the current one is marked empty. <br><br><h4>  Source </h4><br><br>  I lost the link to the implementation from the author in C ((Who will find - write in the comment. <br>  <a href="">github.com/yasm/yasm/blob/master/libyasm/hamt.c</a> is an example implementation in C. References to examples of implementation in other languages ‚Äã‚Äãcan be found in [3]. <br><br><h4>  Links </h4><br><br>  [1] <a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">article from the author of the algorithm</a> <br>  [2] <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B8%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">article about hash collisions on Wikipedia</a> <br>  [3] <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">HAMT article on Wikipedia</a> <br>  [4] <a href="http://stackoverflow.com/questions/19714795/hash-array-mapped-trie-hamt">good question on SO</a> <br>  [5] <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt">short introductory course in HAMT</a> <br><br>  Write comments and inaccuracies in the comments, send spelling errors and lost punctuation marks to the PM. </div><p>Source: <a href="https://habr.com/ru/post/266861/">https://habr.com/ru/post/266861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266849/index.html">Book about viruses</a></li>
<li><a href="../266851/index.html">Start loving go</a></li>
<li><a href="../266853/index.html">Return fix and other improvements in Vivaldi 1.0.275.3 fix</a></li>
<li><a href="../266857/index.html">FAS has recognized Google as violator of antitrust laws</a></li>
<li><a href="../266859/index.html">Non-intersecting sets and mysterious function of Ackermann</a></li>
<li><a href="../266863/index.html">Jet9 test results and service commissioning</a></li>
<li><a href="../266865/index.html">QuadBraces - based on the MODx parser</a></li>
<li><a href="../266869/index.html">New ‚Äúservice‚Äù from Ubiquiti - replenishment in the model range UniFi AC</a></li>
<li><a href="../266871/index.html">Deploy JetBrains Hub + Youtrack + Upsource + Nginx on your Debian 8 server</a></li>
<li><a href="../266873/index.html">Functional C #: Immutability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>