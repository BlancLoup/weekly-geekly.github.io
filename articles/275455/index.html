<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel algorithms for processing BigData: pitfalls and difficult decisions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This publication is based on the AlexSerbul speech at the BigData Conference in the fall. 

 Big data is a fashionable and popular topic. But many are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel algorithms for processing BigData: pitfalls and difficult decisions</h1><div class="post__text post__text-html js-mediator-article">  <i>This publication is based on the <a href="http://habrahabr.ru/users/alexserbul/" class="user_link">AlexSerbul</a> speech at the <a href="http://bigdataconf.com.ua/">BigData Conference</a> in the fall.</i> <br><br>  Big data is a fashionable and popular topic.  But many are still scared away by an excess of theoretical reasoning and some lack of practical recommendations.  In this post, I want to partly fill this gap and talk about using parallel algorithms for processing big data on the example of clustering a product catalog of 10 million items. <br><a name="habracut"></a><br>  Unfortunately, when you have a lot of data, you will have to ‚Äúreinvent‚Äù the classical algorithm anew, so that it works in parallel using MapReduce.  And this is a big problem. <br><br><img src="https://habrastorage.org/files/607/3c9/547/6073c9547a9641f2be14c68bed68108b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the way out?  In order to save time and money, you can certainly try to find a library that allows you to implement a parallel clustering algorithm.  There is of course something on the Java platform: the dying Apache Mahout and the evolving Apache Spark MLlib.  Unfortunately, Mahout supports few algorithms under MapReduce - most of them are consistent. <br><br>  The promising mountain Spark MLlib is also not rich in clustering algorithms.  And with our volumes the matter is even worse - this is what is proposed: <br><br><ul><li>  K-means </li><li>  Gaussian mixture </li><li>  Power iteration clustering (PIC) </li><li>  Latent Dirichlet allocation (LDA) </li><li>  Streaming k-means </li></ul><br>  When you have 10-20 million entities for clustering, the above solutions will no longer help, you need hardcore.  But first things first. <br><br>  So, we need to cluster a catalog of 10 million items.  Why do you need it?  The fact is that our users can use a recommendation system in their online stores.  And her work is based on an analysis of the aggregated catalog of products of all sites operating on our platform.  For example, in one of the shops the buyer was recommended to choose an ax to kill his mother-in-law (yes, this is a corporate blog, but without jokes about bigdates and mathematics, it‚Äôs impossible to say that everyone will fall asleep).  The system will know about it, analyze it and in another store will recommend the button accordion to the same buyer to play and rejoice.  That is, the first problem solved by clustering is the transfer of interest. <br><br>  The second task: to ensure the creation of correct logical connections of goods to increase related sales.  For example, if a user bought a camera, the system will recommend a battery and a memory card to it.  That is, we need to cluster similar products into clusters, and work in different stores at the cluster level. <br><br>  As noted above, our product database consists of catalogs of several tens of thousands of online stores operating on the 1C-Bitrix platform.  Users enter there textual descriptions of different lengths, someone adds brands of goods, models, manufacturers.  It would be expensive, time consuming and difficult to create a consistent, accurate, unified system for collecting and classifying all the goods from tens of thousands of stores.  And we wanted to find a way to quickly glue similar products together and significantly improve the quality of collaborative filtering.  After all, if the system knows the buyer well, then it does not matter what specific goods and their brands he is interested in, the system will always find what to offer him. <br><br><h3>  Tool selection </h3><br>  First of all, it was necessary to choose a storage system suitable for working with ‚Äúbig‚Äù data.  I will repeat a little, but this is useful for securing the material.  For ourselves, we have identified four "camps" of databases: <br><br><ul><li>  <b>SQL on MapReduce: Hive, Pig, Spark SQL</b> .  Load one billion rows into an RDBMS and aggregate the data ‚Äî it will become clear that this class of storage systems is ‚Äúnot very‚Äù suitable for this task.  Therefore, intuitively, you can try using SQL via MapReduce (which Facebook did once).  The obvious disadvantages here are the speed of short queries. </li><li>  <b>SQL on MPP (massive parallel processing): Impala, Presto, Amazon RedShift, Vertica</b> .  Representatives of this camp say that SQL through MapReduce is a dead end, so you need, in fact, to raise a driver on each node where data is stored that will quickly access this data.  But many of these systems suffer from instability. </li><li>  <b>NoSQL: Cassandra, HBase, Amazon DynamoDB</b> .  The third camp says: BigData is NoSQL.  But we understand that NoSQL is, in fact, a set of ‚Äúmemcached-servers‚Äù, combined into a ring structure, which can quickly execute a query like ‚Äútake the key by value and return the answer‚Äù.  They can also return a set of data sorted in RAM by key.  This is almost everything - forget about JOINS. </li><li>  <b>Classics: MySQL, MS SQL, Oracle, etc.</b>  Monsters do not give up and claim that all of the above - garbage, grief of mind, and relational databases work fine with BigData.  Someone suggests fractal trees ( <a href="https://en.wikipedia.org/wiki/TokuDB">https://en.wikipedia.org/wiki/TokuDB</a> ), someone - clusters.  Monsters, too, want to live. </li></ul><br>  Having taken up the issue of clustering closely, we found out that there are not so many ready-made offers on the market. <br><br><ul><li>  Spark MLlib (Scala / Java / Python / R) - when a lot of data. </li><li>  scikit-learn.org (Python) - when there is little data. </li><li>  R - causes conflicting feelings due to the terrible curvature of the implementation (trust programming to mathematicians and extras), but there are many ready-made solutions, and the recent integration with Spark is very pleasing. </li></ul><br><img src="https://habrastorage.org/files/ffa/8e0/d6e/ffa8e0d6e8544f60b6a3b88e29751ad5.png"><br><br>  As a result, we stopped at SparkMLlib, because there, as it seemed, there are reliable parallel clustering algorithms. <br><br><h3>  Search for clustering algorithm </h3><br>  We had to first figure out how to combine text descriptions of goods (names and short descriptions) into clusters.  <a href="https://en.wikipedia.org/wiki/Natural_language_processing">Natural language</a> processing is a separate, huge area of ‚Äã‚ÄãComputer Science, which includes machine learning and <a href="https://en.wikipedia.org/wiki/Information_retrieval">Information retrieval.</a> <br>  and linguistics and even (tadam!) Deep Learning. <br><br>  When there are tens, hundreds, thousands of data for clustering, almost any classical algorithm will suit, even hierarchical clustering.  The problem is that the algorithmic complexity of hierarchical clustering is approximately O (N <sup>3</sup> ).  That is, you have to wait for ‚Äúbillions of years‚Äù until it runs on our data volume, on a huge cluster.  And it was impossible to confine ourselves to processing just a sample.  Therefore, hierarchical clustering in the forehead did not suit us. <br><br>  Then we turned to the "bearded" algorithm K-means: <br><br><img src="https://habrastorage.org/files/334/96e/665/33496e66558c49dab9f15dedee175aa7.png"><br><br>  This is a very simple, well-studied and common algorithm.  However, it also works very slowly on big data: the algorithmic complexity is approximately O (nkdi).  With n = 10,000,000 (number of goods), k = 1,000,000 (expected number of clusters), d = &lt;1,000,000 (word types, vector dimension), i = 100 (approximate number of iterations), O = 10 <sup>21</sup> operations .  For comparison, the age of the Earth is 1.4 * 10 <sup>17</sup> seconds. <br><br>  The C-means algorithm, although it allows you to do fuzzy clustering, but also works on our volumes slowly, just like spectral factorization.  For the same reason, DBSCAN and probabilistic models did not suit us. <br><br>  To implement clustering, we decided at the first stage to turn the text into vectors.  A vector is a certain point in multidimensional space, the clusters of which will be the desired clusters. <br><br>  We needed to cluster descriptions of products consisting of 2-10 words.  The simplest, classic solution to the forehead or to the eye is <a href="https://en.wikipedia.org/wiki/Bag-of-words_model">bag of words</a> .  Once we have a directory, then we can define a dictionary.  As a result, we have a body of about a million words.  After stemming, there are about 500 thousand of them left. They discarded high-frequency and low-frequency words.  Of course, you could use tf / idf, but decided not to complicate things. <br><br>  What are the disadvantages of this approach?  The resulting huge vector is expensive then cheated, comparing its similarity with others.  After all, what is clustering?  This is the process of finding similar vectors.  And when they are 500 thousand in size, the search takes a lot of time, so you need to learn how to compress them.  To do this, you can use Kernel hack, hashing words not in 500 thousand attributes, but in 100 thousand. A good working tool, but collisions may occur.  We did not use it. <br><br>  And finally, I will talk about one more technology that we have rejected, but now we are seriously considering starting to use it.  This is Word2Vec, a method for statistical processing of text by compressing the dimension of text vectors of a two-layer neural network, developed by Google.  In fact, this is the development of the good old eternal statistical N-gram text models, only skip-gram variation is used. <br><br>  The first task, which is beautifully solved using Word2Vec: reducing the dimension due to the "matrix factorization" (in quotes specifically, because there are no matrices there, but the effect is very similar).  That is, it turns out, for example, not 500 thousand attributes, but only 100. When there are similar words ‚Äúin context‚Äù, the system considers them ‚Äúsynonymous‚Äù (with a stretch, of course, coffee and tea can be combined).  It turns out that the points of these similar words in a multidimensional space begin to coincide, that is, words that are close in meaning are clustered into a common cloud.  Say, ‚Äúcoffee‚Äù and ‚Äútea‚Äù will be words that are close in meaning, because they are often found in context together.  Thanks to the Word2Wec library, you can reduce the size of the vectors, and they themselves are more meaningful. <br><br>  This topic has been around for many years: Latent semantic indexing and its variations through PCA / SVD have been studied well, and a solution to the forehead through clustering columns or rows of the term2document matrix will, in fact, give a similar result - only it will take a very long time. <br><br>  It‚Äôs very likely that we‚Äôll start using Word2Vec.  By the way, its use also allows you to find typos and play with the vector algebra of sentences and words. <br><br><h3>  "I will build my amusement park! .." </h3><br>  In the end, after all the long search for scientific publications, we wrote our own version of k-Means - Clustering by Bootstrap Averaging for Spark. <br><br>  In essence, this is a hierarchical k-Means, which makes preliminary layer-by-layer data sampling.  It took quite a reasonable time to process 10 million items, hours, although it took a bunch of servers to work.  But the result did not suit, because  it was not possible to cluster part of the text data - the socks were glued to the aircraft.  The method worked, but very roughly and inaccurately. <br><br>  There was hope for the old, but now forgotten, probabilistic methods of searching for duplicates or "almost duplicates" - <a href="https://ru.wikipedia.org/wiki/Locality-sensitive_hashing">locality-sensitive hashing</a> . <br><br>  The variant of the method described <a href="http://www.mmds.org/">here</a> required the use of vectors of the same size transformed from text, for further ‚Äúscattering‚Äù of them by hash functions.  And we took MinHash. <br><br>  MinHash is a technology for compressing large-dimension vectors into a small vector while preserving mutual Jaccard-likeness.  How does she work?  We have a number of vectors or sets of sets, and we define a set of hash functions through which we run each vector / set. <br><br><img src="https://habrastorage.org/files/5de/163/7cf/5de1637cfe8d47ba8ff1b2aa2f876ff8.png"><br><br>  We define, for example, 50 hash functions.  Then we run each hash function by vector / set, determine the minimum value of the hash function, and get a number that we write to the N-position of the new squeezed vector.  We do it 50 times. <br><br><img src="https://habrastorage.org/files/c6c/7d3/113/c6c7d311302149a4a3557ff19b099947.png"><br><br>  Pr [h <sub>min</sub> (A) = h <sub>min</sub> (B)] = J (A, B) <br><br>  Thus, we solved the problem of compressing dimensions and reducing vectors to a single number of dimensions. <br><br><h3>  Text shingling </h3><br>  I completely forgot to tell that we refused to vectorize the text in the forehead, because  the names and brief descriptions of the goods created extremely discharged vectors suffering from the "curse of dimension". <br><br>  Product names were usually of approximately the same type and size: <br>  <i>"Pants red terry striped"</i> <i><br></i>  <i>"Red Striped Pants"</i> <br><br>  These two phrases differ in a set of words, in their number and location.  In addition, people make typos when typing.  Therefore, it is impossible to compare words even after a stemming, because all the texts will be mathematically dissimilar, although they are close in meaning. <br><br>  In such a situation, the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25BE%25D0%25B2">algorithm of shingles</a> (shingle, scales, tiles) is often used.  We present the text in the form of shingles, pieces. <br><br>  <i>{"Pants", "tans", "any", "us to", "s kra", "red", ...}</i> <br><br>  And when comparing the many pieces, it turns out that two texts of different texts may suddenly find similarity with each other.  We have experimented with text processing for a long time, and in our experience, this is the only way to compare short text descriptions in our product catalog.  This method is also used to identify similar articles, scientific papers, with the aim of detecting plagiarism. <br><br>  I repeat once again: we abandoned highly sparse text vectors, replaced each text with many (set) shingles, and then brought them to the same size using MinHash. <br><br><h3>  Vectorization </h3><br>  As a result, we solved the problem of catalog vectorization as follows.  Using MinHash-signatures, we obtained small-sized vectors from 100 to 500 (the size is chosen the same for all vectors).  Now they need to compare each with each to form clusters.  In the forehead, as we already know, it is very long.  And thanks to the LSH ( <a href="https://ru.wikipedia.org/wiki/Locality-sensitive_hashing">Locality-Sensitive Hashing</a> ) algorithm, the task was solved in one pass. <br><br>  The idea is that similar objects, texts, vectors collide into one set of hash functions, into one bucket.  And then it remains to go through them and collect similar elements.  After clustering, you get a million buckets, each of which will be a cluster. <br><br><h3>  Clustering </h3><br>  Traditionally use several bands - sets of hash functions.  But we simplified the task even more - we left only one band.  Suppose that the first 40 elements of a vector are taken and entered into a hash table.  And then there are elements that have the same piece first.  That's all!  For starters, it's great.  If greater accuracy is needed, then you can work with the bands group, but then in the final part of the algorithm you will have to collect mutually similar objects from them for a longer time. <br><br>  After the first iteration, we obtained quite good results: almost all duplicates and almost all similar goods stuck together.  Evaluated visually.  And to further reduce the number of microclusters, we previously removed frequently encountered and rare words. <br><br>  Now we have just two or three hours on 8 spot-servers clustered 10 million products in approximately one million clusters.  In fact, in one pass, because there is only one band.  Having experimented with the settings, we got quite adequate clusters: yachts, cars, sausage, etc., without nonsense like ‚Äúax + plane‚Äù.  And now this compressed cluster model is used to improve the accuracy of the personal recommendation system. <br><br><h3>  Results </h3><br>  In collaborative algorithms, we began to work not with specific products, but with clusters.  A new product appeared, we found a cluster, put it there.  And the reverse process - we recommend the cluster, then select the most popular product from it and return it to the user.  The use of a cluster catalog improved the accuracy of recommendations several times (we measure the recall of the current model a month earlier).  And this is only due to the compression of data (names) and combining them in meaning.  Therefore, I want to advise you - look for simple solutions to your problems associated with big data.  Do not try to complicate things.  I believe that you can always find a simple, effective solution that in 10% of efforts will solve 90% of problems!  Good luck and success in working with big data! </div><p>Source: <a href="https://habr.com/ru/post/275455/">https://habr.com/ru/post/275455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275445/index.html">Comparison of programming languages ‚Äã‚Äãand frameworks for them</a></li>
<li><a href="../275447/index.html">Cross-platform Open Source Time Tracker</a></li>
<li><a href="../275449/index.html">Symantec Backup Exec: Backup Oracle installed on Linux</a></li>
<li><a href="../275451/index.html">Custom gestures, Kinect + Unity. Part 1</a></li>
<li><a href="../275453/index.html">Wt file selection dialog</a></li>
<li><a href="../275459/index.html">Measurement of ore weight by stator current. Practice. Part 1. Signal processing algorithm in MK</a></li>
<li><a href="../275463/index.html">Using Chakra and JavaScript in Azure DocumentDB</a></li>
<li><a href="../275469/index.html">The most "New Year" messenger for Yota users is WhatsApp</a></li>
<li><a href="../275471/index.html">Eleven important ONLYOFFICE features that are not found in MS Office Online or in Google Docs</a></li>
<li><a href="../275473/index.html">Remote debugging javascript with VS2015. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>