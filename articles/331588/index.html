<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compressing photos without apparent loss of quality: the Yelp experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More than 100 million user photos are stored on Yelp, from pictures of dinners and hairstyles to one of our latest features, #yelfies . These images m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compressing photos without apparent loss of quality: the Yelp experience</h1><div class="post__text post__text-html js-mediator-article">  More than 100 million user photos are stored on Yelp, from pictures of dinners and hairstyles to one of our latest features, <a href="https://www.yelpblog.com/2016/11/yelfie">#yelfies</a> .  These images make up the bulk of the traffic for users of the application and the website, and their storage and transmission is expensive.  Trying to provide people with the best service, we worked hard to optimize all the photos and achieved an average size reduction of 30%.  This saves people time and traffic, and also reduces our costs of servicing these images.  Oh yeah, and we did it without degrading the quality of the photos! <br><br><h3>  Initial data </h3><br>  Yelp stores custom photos for 12 years.  We save lossless formats (PNG, GIF) as PNG, and all other formats in JPEG.  Python and <a href="https://python-pillow.org/">Pillow</a> are used to save files, and photo uploads start around with this snippet: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># do a typical thumbnail, preserving aspect ratio new_photo = photo.copy() new_photo.thumbnail( (width, height), resample=PIL.Image.ANTIALIAS, ) thumbfile = cStringIO.StringIO() save_args = {'format': format} if format == 'JPEG': save_args['quality'] = 85 new_photo.save(thumbfile, **save_args)</span></span></code> </pre> <br><a name="habracut"></a>  After that we start looking for options to optimize the file size without losing quality. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Optimization </h3><br>  First, you need to decide whether to process the files yourself or allow the CDN provider to <a href="https://www.fastly.com/io">magically modify</a> our photos.  Since we prioritize high quality content, it makes sense to evaluate options and potential tradeoffs between size and quality.  We began to study the current state of affairs with optimizing the size of files - what changes can be made and how the size / quality will change with each of them.  At the end of the study, we decided to work in three main areas.  The rest of the article is devoted to the story of what we have done and what benefits we have gained from each optimization. <br><br><ol><li>  Pillow Changes <br><ul><li>  Optimize flag </li><li>  Progressive jpeg </li></ul></li><li>  Changes in photo application logic <br><ul><li>  Large PNG recognition </li><li>  Jpeg dynamic quality </li></ul></li><li>  JPEG Encoder Changes <br><ul><li>  Mozjpeg (trellis quantization, custom quantization matrix) </li></ul></li></ol><br><h3>  Pillow Changes </h3><br><h4>  Optimize flag </h4><br>  This is one of the easiest changes we have made: to transfer to Pillow the responsibility for additional saving of file size due to CPU time ( <code>optimize=True</code> ).  By definition, this does not affect the quality of photos. <br><br>  For JPEG, this flag means instructing the encoder to find the optimal <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman code by</a> making an extra pass when scanning each image.  Each first pass, instead of writing to a file, calculates the statistics of occurrences for each value, this information is needed for perfect coding.  The PNG standard uses zlib, so the optimization flag in this case instructs the encoder to use <code>gzip -9</code> instead of <code>gzip -6</code> . <br><br>  Such a change was easy to make, but it turned out that it was not an ideal solution, reducing the size of the files by only a few percent. <br><br><h4>  Progressive jpeg </h4><br>  When saving JPEG, you can select several different types: <br><br><ul><li>  Baseline JPEG uploaded </li><li>  Progressive JPEGs that load from blurry to crisp.  The option of progressive images is easy to activate in Pillow ( <code>progressive=True</code> ).  As a result, the quality is subjectively enhanced (indeed, it is easier to notice the partial absence of the image than its non-ideal sharpness) </li></ul><br>  In addition, the packaging method for progressive images is such that it usually results in a smaller file size.  As is more fully explained in the <a href="https://en.wikipedia.org/wiki/JPEG">Wikipedia article</a> , a JPEG format uses zigzag traversal of a block of 8 √ó 8 pixels for entropy coding.  When the values ‚Äã‚Äãof these blocks of pixels are not packed and arranged in order, non-zero values ‚Äã‚Äãusually go first, and then a sequence of zeros, and this pattern is repeated and alternated for each 8 √ó 8 block in the image.  With progressive coding, the order of processing pixel blocks changes.  The first in the file are large values ‚Äã‚Äãfor each block (which gives the first scans of the progressive image such characteristic blockiness), and closer to the end long ranges of small values ‚Äã‚Äãare stored, including more zeros, these ranges provide fine detail.  Such a redistribution of data in the file does not change the image itself, but increases the number of zeros in a row behind each other (which are easier to compress). <br><br><div class="spoiler">  <b class="spoiler_title">Baseline JPEG and Progressive JPEG Comparison</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/9ca/366/fbb/9ca366fbba494c0e899eb9cdd232f23f.gif"><br>  <font color="gray">An example of how Baseline JPEG rendering works.</font> <br><br><img src="https://habrastorage.org/web/485/a95/ad1/485a95ad11194a6ca0eb3dcc9bb49d7b.gif"><br>  <font color="gray">An example of how Progressive JPEG rendering works.</font> </div></div><br><h3>  Changes in photo application logic </h3><br><h4>  Large PNG recognition </h4><br>  Yelp works with two formats for custom content ‚Äî JPEG and PNG.  JPEG is great for photographs, but usually does not handle high-contrast designer content (such as logos).  In contrast, PNG compresses the image completely lossless, great for graphics, but too cumbersome for photos, where small distortions are still not noticeable.  In cases where users upload photos in PNG format, we can save a lot of space if we recognize such files and save them in JPEG.  One of the main sources of PNG photos on Yelp is screenshots from mobile devices and applications that change photos, apply effects and add frames. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16b/8b7/207/16b8b72079091e7721b91effa9070eb5.png"><br>  <font color="gray">Left: A typical combined PNG with a logo and frame.</font>  <font color="gray">Right: typical png from screenshot</font> <br><br>  We wanted to reduce the number of such optional PNGs, but it was important not to overdo it by changing formats or degrading the quality of logos, graphics, etc. How can we determine that the image is a photograph?  By pixels? <br><br>  After checking the experimental sample of 2500 images, we found that the combination of file size and the number of unique pixels allows you to quite accurately determine the photos.  We generate a smaller copy at the maximum resolution and check if the file size is more than 300 KiB.  If so, then we check the pixels of the image, if there are more than 2 <sup>16</sup> unique colors (Yelp converts the loaded RGBA images to RGB, but if we didn‚Äôt do this, we would still check it). <br><br>  In the experimental sample, such manual settings by definition of ‚Äúlarge images‚Äù reveal 88% of all files that are potentially suitable for optimization without false positives on the graph. <br><br><h4>  Jpeg dynamic quality </h4><br>  The first and most famous way to reduce the size of JPEG files is a setting called <code>quality</code> .  Many applications that can save in JPEG format define <code>quality</code> as a number. <br><br>  Quality is a kind of abstraction.  In fact, there are separate quality levels for each of the color channels of a JPEG image.  Quality levels from 0 to 100 correspond to different <a href="https://en.wikipedia.org/wiki/JPEG">quantization tables</a> for color channels and determine how much data will be lost (usually in high frequencies).  Signal quantization is one of the steps in the JPEG encoding process when information is lost. <br><br>  The simplest way to reduce file size is to degrade image quality by allowing more noise.  However, not every image loses the same amount of information at the same level of quality. <br><br>  We can dynamically change the quality settings, optimizing them for each individual image to achieve the perfect balance between quality and size.  There are two ways to do this: <br><br><ul><li>  <b>Bottom up (Bottom-up):</b> These algorithms generate customized quantization tables, processing the image at the block level of 8 √ó 8 pixels.  At the same time, they calculate how much theoretical quality was lost and how this lost data increases or reduces the appearance of distortion to the human eye. </li><li>  <b>Top down (Top-down):</b> These algorithms compare the whole image with its original version and determine how much information was lost.  By consistently generating candidates with different quality settings, we can choose the one that corresponds to the minimum grade level, depending on which evaluation algorithm we use. </li></ul><br>  We evaluated the operation of the bottom-up algorithm and concluded that it does not provide adequate results at the highest quality settings that we wanted to use (although it seems that it has potential in the middle quality range, where the encoder can be more daring regarding the choice of discarded bytes).  Many <a href="https://vision.arc.nasa.gov/publications/spie93abw/spie93abw.html.d/spie93.html">scientific</a> <a href="">papers</a> on this strategy were published in the early 1990s, when computing resources were in short supply, so it was difficult to use the resource-intensive methods that Option B uses, such as evaluating interconnections between blocks. <br><br>  So we turned to the second approach: using an algorithm divided in half to generate candidate images at different quality levels and estimating the drop in quality of each image by calculating its structural similarity index ( <a href="https://en.wikipedia.org/wiki/Structural_similarity">SSIM</a> ) using <a href="https://github.com/jterrace/pyssim/">pyssim</a> as long as this value is within the limits of but a static threshold.  This allowed us to selectively lower the average file size (and average quality) only for images that were above the perceived threshold. <br><br>  In the diagram below, we display the SSIM values ‚Äã‚Äãfor 2500 images newly generated with three different quality settings. <br><br><ol><li>  Original images created using the current method with <code>quality = 85</code> are shown in blue. </li><li>  An alternative approach to reducing the size of files, with a reduction in the quality setting to <code>quality = 80</code> , is shown in red. </li><li>  Finally, the approach we ultimately settled on, the dynamic quality of the <code>SSIM 80-85</code> , is shown in orange.  Here, the quality is selected from the range from 80 to 85 (inclusive), depending on the coincidence or excess of the ratio SSIM: a pre-calculated static value that makes this transition somewhere in the middle of the image range.  This allows us to reduce the average file size without lowering the quality of bad-looking images. </li></ol><br><br><img src="https://habrastorage.org/getpro/habr/post_images/239/a53/646/239a53646e748c933bbbec10c229a1d6.png"><br>  <font color="gray">SSIM indices for 2500 images with three different strategies for changing quality settings</font> <br><br>  <b>SSIM?</b> <br>  There are several algorithms for changing the quality of images that try to imitate the human vision system.  We appreciated many of them, and we think that SSIM, although older, is best suited for such iterative optimization due to its characteristics: <br><br><ol><li>  <a href="http://users.eecs.northwestern.edu/~pappas/papers/brooks_tip08.pdf">JPEG quantization error</a> sensitive </li><li>  Fast, simple algorithm </li><li>  It can be calculated on native PIL objects without converting images to PNG and transferring them to CLI applications (see # 2) </li></ol><br>  Sample code for dynamic quality: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cStringIO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PIL.Image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ssim <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> compute_ssim <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ssim_at_quality</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(photo, quality)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Return the ssim for this JPEG image saved at the specified quality"""</span></span> ssim_photo = cStringIO.StringIO() <span class="hljs-comment"><span class="hljs-comment"># optimize is omitted here as it doesn't affect # quality but requires additional memory and cpu photo.save(ssim_photo, format="JPEG", quality=quality, progressive=True) ssim_photo.seek(0) ssim_score = compute_ssim(photo, PIL.Image.open(ssim_photo)) return ssim_score def _ssim_iteration_count(lo, hi): """Return the depth of the binary search tree for this range""" if lo &gt;= hi: return 0 else: return int(log(hi - lo, 2)) + 1 def jpeg_dynamic_quality(original_photo): """Return an integer representing the quality that this JPEG image should be saved at to attain the quality threshold specified for this photo class. Args: original_photo - a prepared PIL JPEG image (only JPEG is supported) """ ssim_goal = 0.95 hi = 85 lo = 80 # working on a smaller size image doesn't give worse results but is faster # changing this value requires updating the calculated thresholds photo = original_photo.resize((400, 400)) if not _should_use_dynamic_quality(): default_ssim = get_ssim_at_quality(photo, hi) return hi, default_ssim # 95 is the highest useful value for JPEG. Higher values cause different behavior # Used to establish the image's intrinsic ssim without encoder artifacts normalized_ssim = get_ssim_at_quality(photo, 95) selected_quality = selected_ssim = None # loop bisection. ssim function increases monotonically so this will converge for i in xrange(_ssim_iteration_count(lo, hi)): curr_quality = (lo + hi) // 2 curr_ssim = get_ssim_at_quality(photo, curr_quality) ssim_ratio = curr_ssim / normalized_ssim if ssim_ratio &gt;= ssim_goal: # continue to check whether a lower quality level also exceeds the goal selected_quality = curr_quality selected_ssim = curr_ssim hi = curr_quality else: lo = curr_quality if selected_quality: return selected_quality, selected_ssim else: default_ssim = get_ssim_at_quality(photo, hi) return hi, default_ssim</span></span></code> </pre> <br>  There are several other blog posts about this technique, <a href="https://medium.com/%40duhroach/reducing-jpg-file-size-e5b27df3257c">here‚Äôs</a> one from Colt McCanlis.  And when we were going to publish, Etsy also <a href="https://codeascraft.com/2017/05/30/reducing-image-file-size-at-etsy/">published</a> its!  Give me five, fast internet! <br><br><h3>  JPEG Encoder Changes </h3><br><h4>  Mozjpeg </h4><br>  <a href="https://github.com/mozilla/mozjpeg/">Mozjpeg</a> is an open-source fork of <a href="http://libjpeg-turbo.virtualgl.org/">libjpeg-turbo</a> , which sacrificed runtime for the size of the files.  This approach is well compatible with offline conveyor file regeneration.  With a resource consumption of 3-5 times more than libjpeg-turbo, this algorithm makes images smaller in size! <br><br>  One of the differences mozjpeg that it uses an alternative quantization table.  As mentioned above, quality is an abstraction of quantization tables for each color channel.  All indications are that the default JPEG quantization tables are fairly easy to beat.  As stated in <a href="https://www.w3.org/Graphics/JPEG/itu-t81.pdf">the JPEG specifications</a> : <br><br><blockquote>  These tables are provided as examples only and are not necessarily suitable for any particular application. </blockquote><br>  So naturally, you should not be surprised that these tables are used by default in most implementations of encoders ... <br><br>  Mozjpeg has done the hard work of benchmarking alternative tables for us and using alternative tables to generate images that show themselves best. <br><br><h4>  Mozjpeg + Pillow </h4><br>  Most Linux distributions install libjpeg by default.  So mozjpeg under Pillow does not work <a href="https://github.com/python-pillow/Pillow/issues/539">by default</a> , but it is not too difficult to configure in the configuration.  When building mozjpeg, use the <code>--with-jpeg8</code> and make sure that it can be linked with Pillow.  If you are using Docker, you can make this Dockerfile: <br><br><pre> <code class="hljs tex">FROM ubuntu:xenial RUN apt-get update <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get -y --no-install-recommends install <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span># build tools nasm <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>build-essential <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>autoconf <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>automake <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libtool <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>pkg-config <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span># python tools python <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>python-dev <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>python-pip <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>python-setuptools <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span># cleanup &amp;&amp; apt-get clean <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* # Download and compile mozjpeg ADD https://github.com/mozilla/mozjpeg/archive/v3.2-pre.tar.gz /mozjpeg-src/v3.2-pre.tar.gz RUN tar -xzf /mozjpeg-src/v3.2-pre.tar.gz -C /mozjpeg-src/ WORKDIR /mozjpeg-src/mozjpeg-3.2-pre RUN autoreconf -fiv <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; ./configure --with-jpeg8 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; make install prefix=/usr libdir=/usr/lib64 RUN echo "/usr/lib64<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>" &gt; /etc/ld.so.conf.d/mozjpeg.conf RUN ldconfig # Build Pillow RUN pip install virtualenv <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; virtualenv /virtualenv_run <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; /virtualenv_run/bin/pip install --upgrade pip <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&amp;&amp; /virtualenv_run/bin/pip install --no-binary=:all: Pillow==4.0.0</code> </pre> <br>  It's all!  Collect and be able to use Pillow with mozjpeg in normal image processing. <br><br><h3>  Effect </h3><br>  How important was each of these improvements to us?  We started with a random sample of 2500 Yelp business photos, ran them through our processing pipeline, and measured the resizing. <br><br><ol><li>  Changes in the settings Pillow gave a savings of 4.5% </li><li>  Determining large PNGs saves 6.2% </li><li>  Dynamic quality saves 4.5% </li><li>  The transition to the mozjpeg encoder gave a savings of 13.8% </li></ol><br>  All together, this led to a reduction in the average size of images by about 30%, which we used for our largest and most common photo resolutions, making the site faster for users and saving terabytes per day on data transfer.  As fixed at the CDN level: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa6/981/57c/fa698157c199fddd907a753197963eba.png"><br>  <font color="gray">Changing the average file size over time for a CDN (along with other files that are not images)</font> <br><br><h3>  What we did not do </h3><br>  This section describes several other typical optimizations that you can use, but they were not suitable for Yelp either because of the default settings of our tools, or because of a conscious refusal to accept such a compromise. <br><br><h4>  Subsampling </h4><br>  <a href="https://en.wikipedia.org/wiki/Chroma_subsampling">Downsampling</a> is a major factor in determining both the quality and size of web image files.  A more detailed description of subsampling can be found on the Internet, but for this article it is enough to say that we are already downsampling to <code>4:1:1</code> (these are the default settings for Pillow, unless you specify other settings), so we are unlikely to get any gain with further optimization. <br><br><h4>  Lossy PNG encoding </h4><br>  Knowing what we do with PNG, the option of saving these images in the same format, but using a lossy encoder like <a href="https://pngmini.com/lossypng.html">pngmini</a> , makes sense, but we still chose the compression option in JPEG.  However, the author of the encoder speaks about file compression by 72-85%, so this is an alternative option with sound results. <br><br><h4>  More modern formats </h4><br>  Support for more modern formats like WebP or JPEG2k was definitely considered by us.  But even if we implemented this hypothetical project, the long tail of users who need JPEG / PNG images would still remain, so efforts to optimize them in any case were not in vain. <br><br><h4>  Svg </h4><br>  We apply SVG in many places on the site, for example, for static images that our designers created <a href="http://yelp.design/">for the style guide</a> .  Although this format and optimization tools like <a href="https://github.com/svg/svgo">svgo</a> reduce page size well, they are not suitable for our task. <br><br><h4>  Magic vendor </h4><br>  There are too many companies that offer delivery, resizing, cropping, transcoding images as a service.  Including open-source <a href="https://github.com/thumbor/thumbor">thumbor</a> .  Maybe for us in the future this is the easiest way to realize support for responsive images, dynamic content types and stay on the cutting edge of progress.  But now we cope on our own. <br><br><h4>  additional literature </h4><br>  The two books mentioned here are completely self-sufficient outside the context of this article and are highly recommended for further reading on the subject. <br><br><ul><li>  <a href="https://content.akamai.com/pg6293-high-performance-images-ebook.html">High Performance Images</a> </li><li>  <a href="http://designingforperformance.com/">Designing for Performance</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/331588/">https://habr.com/ru/post/331588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331570/index.html">How to organize a Performance Review in IT companies: Badoo experience</a></li>
<li><a href="../331576/index.html">Creating a 3D printer shader effect</a></li>
<li><a href="../331582/index.html">Teach the bot! - marking of emotions and semantics of the Russian language</a></li>
<li><a href="../331584/index.html">Optimization history of one IoC container</a></li>
<li><a href="../331586/index.html">Design of the city based on data. Lecture in Yandex</a></li>
<li><a href="../331590/index.html">Using MapXtreme .Net</a></li>
<li><a href="../331594/index.html">GUI on Grafana for mgstat - system monitoring utilities on InterSystems Cach√©, Ensemble or HealthShare</a></li>
<li><a href="../331596/index.html">Level editor for three in a row</a></li>
<li><a href="../331598/index.html">Phoenix Framework - Webpack instead of Brunch, deploy using Distillery and a little systemd</a></li>
<li><a href="../331600/index.html">Two in one: how to use vim and nano?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>