<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of reactive programming using RxJS. Part 3. Higher Order Observables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at how it is possible to process another in one thread, what it is for, and how the Higher Order Observables operators (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of reactive programming using RxJS. Part 3. Higher Order Observables</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  In this article, we will look at how it is possible to process another in one thread, what it is for, and how the Higher Order Observables operators (further HOO) will help us with this. <br><br>  When working with threads, a situation often arises when it is necessary to transfer the results of another to one stream as a value.  For example, we want to execute an ajax request and process its response in the current thread, or run several parallel requests, implement pooling.  I think many people are used to solving such problems using such a mechanism as promise.  But is it possible to solve them using RxJS?  Of course, everything is much easier than you think! <br><a name="habracut"></a><br>  A series of articles ‚ÄúBasics of reactive programming using RxJS‚Äù: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/438642/">Part 1. Reactivity and Streams</a> </li><li>  <a href="https://habr.com/ru/post/444290/">Part 2. Operators and pipes</a> </li></ul><br>  <b>Note</b> : in order to understand the theoretical part of the article, you do not need to read the previous articles, you only need to know what observable, operators and pipes are.  In the practical part, we will refine the example from the <a href="https://habr.com/ru/post/444290/">second article</a> , which you can find by <a href="https://stackblitz.com/edit/github-api-with-rxjs%3Ffile%3Dindex.ts">reference</a> . <br><br><h4>  Problem </h4><br>  Let's imagine the following task: we need to know every second whether the server is available.  How can we solve it? <br><br>  First, create a stream using the timer method: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  The <a href="https://rxjs.dev/api/index/function/timer">timer</a> method is very similar in operation to <a href="https://rxjs.dev/api/index/function/interval">interval</a> .  But in contrast, it allows you to specify a timeout for starting a stream, which is transmitted by the first parameter.  The second parameter specifies the interval at which the new value will be generated.  If the second parameter is not specified, the timer will generate only one value and terminate the stream. <br><br>  Since we don‚Äôt have a server with you, I suggest simply writing a function that emulates the request to the server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  What does this method do?  It returns a stream created using the timer method, which emits a value after one second and ends.  Since the timer method only generates a number, we use the mapTo operator to replace it with the string ‚Äúsuccess‚Äù. <br><br>  Here is the stream that is created by the makeRequest method: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Now we have a choice: call the makeRequest method inside the stream or assign this duty to the observer? <br><br>  The first approach is more preferable, since in this case we will be able to use the full potential of RxJS with its operators and we will relieve our observer from unnecessary duties.  Let's use the timer method to execute queries by interval: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  When we run this code, we will see that in console.log we receive not a message with the text ‚Äúsuccess‚Äù, but an object of the Observable type: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  The answer is quite expected, because in the map we return the stream.  To make a stream, you need to subscribe to it.  Well, let's see how <b>not to do it</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  The problem of the example above is that we receive a subscription in a subscription.  What if we want to do more than one query in a chain?  Or what if at some point we need to unsubscribe from the stream inside?  In this case, our code will more and more resemble ‚Äúnoodles‚Äù.  To solve this problem in RxJS there are special operators, which are called HOO. <br><br><h4>  HOO </h4><br>  HOO is a special type of operator that accepts streams as values.  One of these operators is the mergeAll method. <br><br>  When a stream arrives at the mergeAll input, it subscribes to it.  The stream to which the operator subscribed is called internal.  The stream from which the operator receives other streams as values ‚Äã‚Äãis called external. <br><br>  When the internal stream generates a value, mergeAll pushes that value into the external stream.  Thus, we get rid of the need to manually subscribe.  If we unsubscribe from the external stream, then mergeAll will automatically unsubscribe from the internal one. <br><br>  Let's see how we can rewrite our example with mergeAll: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  In the example above, the external stream is created by the timer operator.  And the streams that are created in the map operator are internal.  Each created thread falls into the mergeAll operator. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  The map + mergeAll combination is used very often, so the mergeMap method exists in RxJS: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  When an external thread generates a value, the mergeMap operator calls the callback function passed to it, which generates a new thread.  Then mergeMap subscribes to the generated stream. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  The special feature of the operator's mergeAll / mergeMap is that if another stream goes down to it, it also subscribes to it.  Thus, we can get values ‚Äã‚Äãfrom several internal ones into the external flow at once.  Let's see the following example: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  This is how the external stream will look like without the mergeMap operator: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  And this is how it is with mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Every second we create a new internal stream and mergeMap subscribes to it.  Thus, we simultaneously have a lot of internal threads, the values ‚Äã‚Äãof which fall into the external: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Note</b> : Be careful with mergeMap, each new internal thread will work until you unsubscribe from the external.  In the example above, the number of internal threads grows every second, in the end, there can be so many flows that the computer cannot cope with the load. <br><br><h4>  concatAll / concatMap </h4><br>  The mergeMap method is great when you don‚Äôt care about the order in which internal threads are executed, but what if you have a need for it?  Suppose we want the next request to the server to be executed only after receiving a response from the previous one? <br><br>  For such purposes, the HOO statement concatAll / concatMap is suitable.  This operator, subscribing to an internal stream, waits until it completes, and only then subscribes to the next one. <br><br>  If during the execution of one thread a new one goes to it, then it is placed in the queue until the previous one is completed. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  In the example above, we create two threads using the timer method.  For clarity, I used the mapTo operator to display different values.  The first stream will generate 1, the second - 2. The external stream is created using the of method, which accepts two above-declared observables as input. <br><br>  The concatAll operator first receives firstInnerObservable, subscribes to it and waits for it to complete, and only after the completion of the first will it subscribe to secondInnerObservable.  Here is what the external stream will look like: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  If we replace concatAll with mergeAll, then the stream will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  This operator differs from the previous ones in that when it receives a new stream, it immediately unsubscribes from the previous one and subscribes to a new one. <br><br>  Take the example above and replace concatAll with switchAll, and see how the external thread behaves: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Only the value from the second internal stream has fallen into the external stream.  All because switchMap unsubscribed from the first when I received the second thread. <br><br>  When is it necessary?  For example, when implementing a data search.  If the response from the server has not yet arrived, and we have already sent a new request, then it makes no sense for us to wait for the previous one. <br><br><h4>  exhaust / exhaustMap </h4><br>  exhaust - the exact opposite of the switchAll operator, while its behavior is similar to concatAll.  This method, subscribing to the stream, waits for it to end.  If a new stream comes down to it, then it is simply discarded. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  In the example above, we did not get a deuce, because at that moment the operator was waiting for the completion of the first stream, and simply dropped the second one. <br><br>  I think many have a question when this behavior may be needed?  A good example is an authorization form.  It makes no sense to send multiple requests to the server until the current one is executed. <br><br><h4>  We are finalizing the application </h4><br>  We recall the <a href="https://stackblitz.com/edit/github-api-with-rxjs%3Ffile%3Dindex.ts">example</a> from the <a href="https://habr.com/ru/post/444290/">second article</a> .  In it, we implemented a search on GitHub and used the mergeMap operator to send requests to the server.  Now we know the features of this operator, is it really suitable in our case? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Let's assume that the GitHub server will be very overloaded, then processing our response will take a lot of time.  What can go wrong in this case? <br><br>  Suppose the user entered some data, did not wait for an answer, and entered new ones.  In this case, we will send the second request to the server.  However, no one guarantees that the answer to the first request will come earlier. <br><br>  Since the mergeMap operator doesn‚Äôt care in what order to process internal threads, in the case when the first request is executed later than the second, we will load the actual data.  Therefore, I suggest replacing the mergeMap method with switchMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Now, if the user enters new data, switchMap will unsubscribe from the previous stream and subscribe to a new one. <br><br>  It should be noted that our http request will continue to hang until the server gives an answer to it.  But, since we have unsubscribed from the internal flow, the answer will not fall into the external flow. <br><br>  <b>Note</b> : if you work with Angular and use HttpClient to work with http, you can not worry about the cancellation of the request itself.  HttpClient can do this for you when unsubscribing. <br><br><h4>  Cancel http </h4><br>  In fetch api, you can cancel the http request using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort">AbortController</a> .  This functionality when combined with the switchMap operator will allow saving user traffic. <br><br>  Let's rewrite our example a little.  And create a method that will wrap the fetch call in observable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  We will also change the getUsersRepsFromApi method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Now the method returns not promise, but observable.  Therefore, we remove the from wrapper in switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Note</b> : in RxJS version 6.5, the <a href="https://rxjs.dev/api/fetch/fromFetch">fromFetch</a> operator was <a href="https://rxjs.dev/api/fetch/fromFetch">added</a> , which itself calls the abort method under the hood, so you no longer need to write your ‚Äúbicycle‚Äù. <br><br>  That's all!  All sample code can be found <a href="https://stackblitz.com/edit/github-api-with-rxjs-2">here</a> . <br><br><h4>  Conclusion </h4><br>  Today we looked at what HOO and some very useful operators in this category are.  Of course, these were not all of them.  For more detailed and detailed information I recommend to visit the <a href="https://rxjs.dev/api">documentation</a> on RxJS. <br><br>  In the next article I plan to consider the difference between Hot and Cold observables. <br><br>  Finally: do not use a subscription in a subscription, because there is a HOO! </div><p>Source: <a href="https://habr.com/ru/post/450050/">https://habr.com/ru/post/450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450040/index.html">New company will support OpenJDK 8 and 11 - we understand the situation</a></li>
<li><a href="../450042/index.html">Russian extended keyboard layout</a></li>
<li><a href="../450044/index.html">We are looking for a problem in the wrong place.</a></li>
<li><a href="../450048/index.html">Comments on the changes in the Federal Law No. 149-–§–ó ‚ÄúOn Information, Information Technologies and Information Protection‚Äù</a></li>
<li><a href="../45005/index.html">Education in Russia: what, why and what to do?</a></li>
<li><a href="../450056/index.html">‚ÄúPay Attention‚Äù # 2: Digest of articles on grocery thinking, behavioral psychology and personal productivity</a></li>
<li><a href="../450058/index.html">That guy's resume</a></li>
<li><a href="../45006/index.html">Yandex banned Google?</a></li>
<li><a href="../450060/index.html">As I learned that my visa is not ready, the message in Slack</a></li>
<li><a href="../450062/index.html">Restoration of circulation in the brain a few hours after death</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>