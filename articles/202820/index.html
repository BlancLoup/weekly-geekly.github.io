<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cache-Conscious Binary Search</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consider a simple task: there is some fairly large, unchanging set of numbers, there are many requests for the presence of a certain number in this se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cache-Conscious Binary Search</h1><div class="post__text post__text-html js-mediator-article"> Consider a simple task: there is some fairly large, unchanging set of numbers, there are many requests for the presence of a certain number in this set, you need to process these requests as quickly as possible.  One of the classic solutions is to form a sorted array and process queries through a binary search.  But is it possible to achieve higher performance than in the classical implementation?  In this article I would like to tell you about Cache-Conscious Binary Search.  In this algorithm, it is proposed to reorder the elements of the array so that the use of the processor cache is as efficient as possible. <a name="habracut"></a><br><br>  <b>Disclaimer:</b> I'm not trying to create the most effective solution to this problem.  I would just like to discuss the approach to building data structures based on the peculiarities of working with the processor cache, since  Many in solving optimization problems, in principle, do not think about the processor architecture.  I am also not going to write an ideal implementation of Cache-Conscious Binary Search, I would like to see the effect of this approach on a fairly simple example (also in order to simplify the code, the number of vertices is taken equal to N = 2 ^ K-1).  As a programming language, I will use C # (the overall speed for us is not critical, since the main focus is not on creating the fastest program in the world, but on a relative comparison of different approaches to solving the problem).  It is also worth noting that the algorithm is effective only on large arrays; therefore, this approach should not be used in all tasks; you must first make sure that it is expedient.  It is assumed that the reader has a basic understanding of what the processor cache is and how it works. <br><br>  Consider the classic implementation of a binary search: suppose we have a sorted array <code>a</code> and some element <code>x</code> , which we will look for in it: <pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>, r = N - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt;= r) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = (l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[m] == x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[m] &gt; x) r = m - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> l = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre>  In this implementation, at the first iterations of the algorithm, requests will be made to the array elements that are far from each other.  Draw a search tree for an array of 15 elements: <br><img src="https://habrastorage.org/getpro/habr/post_images/e27/3cc/5a6/e273cc5a647628f998e485e0eb55add2.png"><br>  From the figure it is clear that when passing through such a tree, there will first be an appeal to the 7th element, and then (in the case of <code>a[7]!=x</code> ) to the 3rd or 11th.  On such a small array, this is not critical, but in a large array, these references will correspond to different lines of the processor cache, which will adversely affect performance.  Let's try to reorder the elements so that successive accesses to the array fall into close memory areas.  As a first approximation, you can try to arrange each level of the tree one after another with a simple wide search.  On our test tree we get the following result: <br><img src="https://habrastorage.org/getpro/habr/post_images/b27/0f0/a88/b270f0a880914945e6cc542072f75b45.png"><br>  Now the elements of the array, to which we will address at the first iterations, are close to each other.  But with the growth of the iteration number, we still get a large amount of cache miss-s.  To correct this situation, we divide our ‚Äúbig‚Äù binary search tree into small subtrees.  Each such subtree will correspond to several levels of the original tree, and the elements of the subtree will be located close to each other.  Thus, the cache miss will be formed mainly during the transition to the next subtree.  The height of the subtree can be varied by selecting it in accordance with the processor architecture.  We illustrate these constructions in our example, taking the height of the subtree to be 2: <br><img src="https://habrastorage.org/getpro/habr/post_images/e93/deb/e76/e93debe76bdf857eba70e2ae19e625c5.png"><br>  And now for the practical research.  For the purity of the experiment and obtain accurate results, we will measure the time using the <a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet</a> project.  Consider the most trivial implementation of the considered algorithm without any additional optimizations (the source code <a href="">is provided</a> on GitHub).  We will compare the classical implementation and the cache-conscious-implementation with different subtree heights (CacheConsciousSearchK corresponds to a subtree with height K).  We take the tree height to 24. On my machine (Intel Core i7-3632QM CPU 2.20GHz) the following results were obtained (the algorithm is very sensitive to the processor architecture, so you can get completely different time estimates): <pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Microsoft.NET 4.5 x64 SimpleSearch : 6725ms CacheConsciousSearch1 : 4428ms CacheConsciousSearch2 : 3963ms CacheConsciousSearch3 : 3778ms CacheConsciousSearch4 : 3774ms CacheConsciousSearch5 : 3762ms</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Benchmark source code</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CacheConsciousBinarySearchCompetition</span></span> : <span class="hljs-title"><span class="hljs-title">BenchmarkCompetition</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = <span class="hljs-number"><span class="hljs-number">24</span></span>, N = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; K) - <span class="hljs-number"><span class="hljs-number">1</span></span>, IterationCount = <span class="hljs-number"><span class="hljs-number">10000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Tree originalTree; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] bfs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Prepare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originalTree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tree(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(x =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * x).ToArray()); bfs = originalTree.Bfs(); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleSearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(originalTree); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousSearch1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConsciousTree(bfs, <span class="hljs-number"><span class="hljs-number">1</span></span>)); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousSearch2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConsciousTree(bfs, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousSearch3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConsciousTree(bfs, <span class="hljs-number"><span class="hljs-number">3</span></span>)); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousSearch4</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConsciousTree(bfs, <span class="hljs-number"><span class="hljs-number">4</span></span>)); } [BenchmarkMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousSearch5</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SingleRun(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConsciousTree(bfs, <span class="hljs-number"><span class="hljs-number">5</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SingleRun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ITree tree</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchedCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iteration = <span class="hljs-number"><span class="hljs-number">0</span></span>; iteration &lt; IterationCount; iteration++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = random.Next(N * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree.Contains(x)) searchedCount++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchedCount; } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITree</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tree</span></span> : <span class="hljs-title"><span class="hljs-title">ITree</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>, r = N - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt;= r) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = (l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[m] == x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[m] &gt; x) r = m - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> l = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bfs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] bfs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N], l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N], r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tail = <span class="hljs-number"><span class="hljs-number">0</span></span>, head = <span class="hljs-number"><span class="hljs-number">0</span></span>; l[head] = <span class="hljs-number"><span class="hljs-number">0</span></span>; r[head++] = N - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tail &lt; head) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = (l[tail] + r[tail]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; bfs[tail] = a[m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l[tail] &lt; m) { l[head] = l[tail]; r[head++] = m - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; r[tail]) { l[head] = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; r[head++] = r[tail]; } tail++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bfs; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CacheConsciousTree</span></span> : <span class="hljs-title"><span class="hljs-title">ITree</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheConsciousTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] bfs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.level = level; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; level) - <span class="hljs-number"><span class="hljs-number">1</span></span>, counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> was = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!was[i]) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> head = <span class="hljs-number"><span class="hljs-number">0</span></span>; queue[head++] = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tail = <span class="hljs-number"><span class="hljs-number">0</span></span>; tail &lt; head; tail++) { a[counter++] = bfs[queue[tail]]; was[queue[tail]] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queue[tail] * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; N &amp;&amp; head &lt; size) queue[head++] = queue[tail] * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queue[tail] * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; N &amp;&amp; head &lt; size) queue[head++] = queue[tail] * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>, deep = <span class="hljs-number"><span class="hljs-number">0</span></span>, leafCount = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> root = <span class="hljs-number"><span class="hljs-number">0</span></span>, rootOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deep &lt; K) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = a[root + u]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++deep % level != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; x) u = <span class="hljs-number"><span class="hljs-number">2</span></span> * u + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> u = <span class="hljs-number"><span class="hljs-number">2</span></span> * u + <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> subTreeSize = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; Math.Min(level, K - deep)) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; x) rootOffset = rootOffset * leafCount * <span class="hljs-number"><span class="hljs-number">2</span></span> + (u - leafCount + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rootOffset = rootOffset * leafCount * <span class="hljs-number"><span class="hljs-number">2</span></span> + (u - leafCount + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; root = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; deep) - <span class="hljs-number"><span class="hljs-number">1</span></span> + rootOffset * subTreeSize; u = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre></div></div>  Just in case, I launched a benchmark under different versions of the .NET Framework and with different bit depths.  All configurations gave similar results: <br><img src="https://habrastorage.org/getpro/habr/post_images/30c/0ba/ac0/30c0baac0c7f3afdcf86ae1c51dfab49.png"><br>  Under Mono 3.3.0, the results were also similar: <br><img src="https://habrastorage.org/getpro/habr/post_images/b23/d56/775/b23d567751f3c2055ff2caa7e52e1b19.png"><br>  From these pictures it is clear that the classic implementation of binary search is significantly inferior to the Cache-Conscious implementation.  It should be noted that at first, as the height of subtrees grows, speed increases, but this trend is not long observed (subtrees start to bring little benefit if a large amount of cashe miss-s occurs inside the subtree). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, Cache-Conscious Binary Search is just an example of how a program can be adapted to the features of the processor cache.  Such Cache-Conscious Data Structures can be invaluable in optimizing an application if your data structures are large enough, and consecutive requests to them fall on different parts of the memory.  But you shouldn‚Äôt rush to rewrite everything under Cache-Conscious: remember that the code will become much more complicated, and the increase in efficiency largely depends on the processor architecture used.  In real life, it is better to first think about choosing the most optimal algorithms with good asymptotics, different presuppositions, heuristics, etc., and save Cache-Conscious for times when everything will become very bad. <br><br>  Quick applications to you! <hr>  You can also read on the topic: <ul><li>  <a href="http://www.vldb.org/conf/1999/P7.pdf">Cache Conscious Indexing for Decision-Support in Main Memory</a> </li><li>  <a href="http://research.microsoft.com/en-us/um/people/trishulc/papers/ccds.pdf">Cache-Conscious Data Structures</a> </li><li>  <a href="http://mspiegel.github.io/publications/michael-spiegel-dissertation.pdf">Cache-Conscious Concurrent Data Structures</a> </li><li>  <a href="http://ftp.cse.buffalo.edu/users/azhang/disc/disc01/cd1/out/papers/sigmod/p475-rao/p475-rao.pdf">Making B + -Trees Cache Conscious in Main Memory</a> </li></ul><hr>  <b>Update.</b>  Addition from <a href="https://habrahabr.ru/users/mikemirzayanov/" class="user_link">MikeMirzayanov</a> : There is such a trick.  If it is necessary to search by binpoisk in an array of length n, then it can be divided into sqrt (n) blocks by sqrt (n) elements.  Then, by searching for log (sqrt (n)), find the necessary block and find the element in it by the second binary search for log (sqrt (n)).  In sum, it turns out all the same log (n), but the cache hits much more, because  every time we look for a rather short array of length sqrt (n). </div><p>Source: <a href="https://habr.com/ru/post/202820/">https://habr.com/ru/post/202820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202804/index.html">What is silent Joker. The story-story about the conference</a></li>
<li><a href="../202806/index.html">FOSS Sea Conference Program</a></li>
<li><a href="../202808/index.html">Half-Life has turned 15 today.</a></li>
<li><a href="../202810/index.html">WPF> PDF via PDFSharp.Xps: fixing hyperlink output</a></li>
<li><a href="../202818/index.html">Podcasts Devops Deflope - Issue 003</a></li>
<li><a href="../202822/index.html">DES to J in a hundred lines</a></li>
<li><a href="../202824/index.html">E-commerce in Universal Analytics</a></li>
<li><a href="../202830/index.html">Flying robotaksi easier to do than unmanned vehicles</a></li>
<li><a href="../202832/index.html">Profiling and debugging Python tools</a></li>
<li><a href="../202836/index.html">Say a word about organic photovoltaics. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>