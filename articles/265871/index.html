<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LLVM for researchers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article focuses on conducting research based on the LLVM compiler infrastructure. Our story should be enough for the researchers, to whom the com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LLVM for researchers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/7bc/94c/88f/7bc94c88f01440318d557f0d3c418375.jpg" align="left">  This article focuses on conducting research based on the <a href="http://llvm.org/">LLVM</a> compiler infrastructure.  Our story should be enough for the researchers, to whom the compilers before were for the most part indifferent, came to the delight of LLVM and did something interesting with its help. <br><br><h1>  What is LLVM? </h1><br>  LLVM is a truly convenient compiler for disassembling and assembling for such traditional programming languages ‚Äã‚Äãas C and C ++. <br><br>  LLVM is so good that it is considered ‚Äúmore than just a compiler‚Äù (it is a dynamic compiler, it works with non-C family languages, it is a <a href="https://developer.apple.com/library/prerelease/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html">new delivery format for the App Store</a> , etc., etc.).  All of the above is true, but for our article, only the definition above is important. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      LLVM has several key differences from other compilers: <br><br><ul><li>  The main innovation is the intermediate presentation (PP).  LLVM works with software that can really be read (if you know how to read assembly code).  It may not seem like a great revelation to someone, but this feature is very important.  PP of other compilers usually have such a complex structure that it is impossible to write them manually, it is difficult to understand and use. </li><li>  LLVM is pretty elegantly written: its architecture is more modular than other compilers.  One of the reasons for this grace is that the developer of the original version was <a href="http://nondot.org/sabre/">one of us</a> . </li><li>  LLVM is not only the <a href="http://awards.acm.org/award_winners/lattner_5074762.cfm">preferred research tool</a> for academic hackers like us, but also an industrial-level compiler, backed by the largest company on the planet.  This means that you don‚Äôt have to compromise between a great compiler and a custom compiler (as happens in the Java land when choosing between <a href="http://java.com/en/download/">HotSpot</a> and <a href="http://www.jikesrvm.org/">Jikes</a> ). </li></ul><br><br><h1>  Why does the LLVM researcher? </h1><br><br>  LLVM is a great tool.  But what do you care if your research is not about compilers? <br><br>  The compiler infrastructure allows you to do a lot of interesting things with programs.  For example, you can analyze a program to see how often it performs certain actions.  You can convert a program to work better on a specific system.  You can also change the program to imagine how it will use a hypothetical new architecture or operating system for which a new chip has not yet been manufactured or a kernel module has not been written.  Compiler infrastructure can be useful to researchers much more often than many people think.  I advise you to contact LLVM first, before you try to file one of these tools (unless you have a specific reason for this): <br><br><ul><li>  <a href="http://research.cs.wisc.edu/vertical/papers/2014/wddd-sim-harmful.pdf">architectural simulator</a> ; </li><li>  Dynamic binary instrumentation tool, for example, <a href="http://www.pintool.org/">Pin</a> ; </li><li>  source-level conversion (from simple tools, such as sed, to advanced toolboxes that include parsing and serializing the SDA); </li><li>  filing the kernel to intercept system calls; </li><li>  any tool that looks like a hypervisor. </li></ul><br>  Even if the compiler does not look like an ideal solution for your task, it often makes it easier for 90% of the work, for example, when translating one source code to another. <br><br>  The following are good examples of research projects that are not so similar to the compiler: <br><br><ul><li>  <a href="http://sva.cs.illinois.edu/pubs/VirtualGhost-ASPLOS-2014.pdf">Virtual Ghost</a> University of Illinois in Urbana-Champaign (USA) demonstrates how you can use compiler pass to protect processes from a cracked OS kernel. </li><li>  <a href="http://homes.cs.washington.edu/~djg/papers/asplos10-coredet.pdf">The University of</a> Washington (USA) <a href="http://homes.cs.washington.edu/~djg/papers/asplos10-coredet.pdf">CoreDet</a> makes multi-threaded programs deterministic. </li><li>  In approximate calculations, we use the LLVM pass to add bugs to programs in order to simulate the operation of hardware subject to failures. </li></ul><br><br>  Once again, LLVM is intended not only for the development of new optimizations in the compiler. <br><br><h1>  Details </h1><br><br>  The figure below shows the main components of the LLVM architecture (and the general architecture of any modern compiler): <br><br><img src="http://adriansampson.net/media/llvm/compiler-arch.svg" alt="image"><br><br><ul><li>  Frontend parses the source code and turns it into an intermediate representation (PP).  This simplifies the work of the rest of the compiler, which is hard to ‚Äúdigest‚Äù the extremely complex C ++ source code.  Such a fearless explorer, as you probably will not have to finish anything in this part, so you can use <a href="http://clang.llvm.org/">Clang</a> unchanged. </li><li>  Passages perform the conversion of one PP to another.  Under normal circumstances, the passages optimize the code, that is, at the output they give a program to the control panel, which does the same as the control panel fed to the input, but only faster.  This is where you want to finish something.  Your revision will be able, for example, to read and change the PP passing through the compiler. </li><li>  Backend directly generates machine code.  Most likely, you will not have to change anything in this part of the system. </li><li>  The LLVM architecture corresponds to the architecture of most modern compilers, but pay attention to one innovation: unlike other compilers, where a unique form of the program code is created on each pass, the same software is used in the LLVM throughout the process.  This is ideal for us, hackers: we do not need to worry about at what stage of the process the code runs, if it happens between the frontend and the backend. </li></ul><br><br><h1>  Preparation for work </h1><br>  So let's pick something up. <br><br><h2>  Install LLVM </h2><br>  First you need to install LLVM.  Linux distributions often include LLVM and Clang packages, which are completely ready to use.  Make sure that the resulting version includes all the necessary headers for doping programs with the help of the compiler.  For example, the OS X build that comes with <a href="https://developer.apple.com/xcode/">Xcode</a> is not complete enough.  Fortunately, it is not difficult <a href="http://llvm.org/docs/CMake.html">to compile LLVM from source code</a> using CMake.  Usually, you only need to build the LLVM itself.  The Clang that comes with the OS does an excellent job with this task, if the corresponding versions match (however, there are <a href="http://clang.llvm.org/get_started.html">instructions for building Clang</a> ). <br><br>  In particular, Brandon Holt wrote a <a href="http://homes.cs.washington.edu/~bholt/posts/building-llvm.html">good instruction</a> for OS X, there is also a recipe <a href="">for the Homebrew system</a> . <br><br><h2>  Teach materiel </h2><br>  You need to carefully review the documentation.  In my opinion, the following materials will be especially useful: <br><br><ul><li>  Very important information is contained on the <a href="http://llvm.org/doxygen/">automatically generated Doxygen pages</a> .  To learn how to successfully pick programs with LLVM, you will have to settle among these documents for a long time on the API.  However, given the complexity of navigating through the pages, I recommend ‚Äúgoogle‚Äù the information.  If you add ‚ÄúLLVM‚Äù to the name of any function or class name, Google <a href="https://google.com/search%3Fq%3Dbasicblock%2Bllvm">usually finds the desired Doxygen page</a> (if you try, you can train Google to find information about the compiler without even entering the name ‚ÄúLLVM‚Äù!).  I understand that it sounds ridiculous, but in order to survive, you really have to dance with a tambourine around the LLVM API documentation.  Maybe there is a more convenient way to navigate through API documents, but I have not heard about it. </li><li>  <a href="http://llvm.org/docs/LangRef.html">The LLVM help is</a> useful if you don‚Äôt understand something in the syntax of the PP. </li><li>  The <a href="http://llvm.org/docs/ProgrammersManual.html">programmer‚Äôs manual</a> describes the tools for working with data structures specific to LLVM (effective strings, STL alternatives for maps, vectors, etc.), as well as tools for working with the types (isa, cast and dyn_cast) that you will use everywhere. </li><li>  Refer to the <a href="http://llvm.org/docs/WritingAnLLVMPass.html">LLVM Pass Writing Guide</a> if you have questions about the capabilities of a single pass.  Considering that you are a researcher, and not just picking up the compiler, I would like to note that the author of this article does not agree with some points of this tutorial.  (First of all, ignore the instructions for building the system using the Makefile and go directly to the <a href="http://llvm.org/docs/CMake.html">instructions</a> for building outside the source tree.) However, in general, the manual is the canonical source of information about the passes. </li><li>  In some cases, it is convenient to use <a href="https://github.com/llvm-mirror/llvm">a GitHub mirror</a> , a web resource for viewing LLVM source code. </li></ul><br><br><h1>  Writing aisle </h1><br>  Usually the result of research using LLVM is to write a new pass.  This section contains instructions for building and executing a simple pass that transforms programs on the fly. <br><br><h2>  "Skeleton" </h2><br>  I created <a href="https://github.com/sampsyo/llvm-pass-skeleton">a template repository</a> where there is one useless LLVM pass.  I recommend to start with the template, because when creating from scratch, there may be problems with the configuration of the assembly. <br>  Clone <a href="https://github.com/sampsyo/llvm-pass-skeleton">the llvm-pass-skeleton</a> repository with GitHub: <br><br><pre><code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@github.com:sampsyo/llvm-pass-skeleton.git</code> </pre> <br><br>  The content work is done in the skeleton / Skeleton.cpp file, so open it.  This is where everything happens: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runOnFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function &amp;F)</span></span></span><span class="hljs-function"> </span></span>{ errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I saw a function called "</span></span> &lt;&lt; F.getName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  There are several types of LLVM passages.  We use one of them - <a href="http://llvm.org/docs/WritingAnLLVMPass.html">function pass</a> (it is ideal for beginners).  As expected, LLVM calls the method described above for each function it finds in the program we are compiling.  While the method only displays the name of the function. <br><br>  Details: <br><ul><li>  The element called errs () is a C ++ output stream provided by LLVM.  It is used for console output. </li><li>  The function returns false to indicate that it has not changed F. Later, when we start changing the PP, we will need to return true. </li></ul><br><br><h2>  Assembly </h2><br>  Build the walkway using <a href="http://www.cmake.org/">CMake</a> : <br><pre> <code class="cpp hljs">$ cd llvm-pass-skeleton $ mkdir build $ cd build $ cmake .. # Generate the Makefile. $ make # Actually build the pass.</code> </pre><br><br>  If LLVM is not installed globally, then CMake needs to specify its location.  To do this, set the path to the share / llvm / cmake / directory where LLVM is located in the LLVM_DIR environment variable.  The following is an example path for the Homebrew system: <br><br><pre> <code class="cpp hljs">$ LLVM_DIR=/usr/local/opt/llvm/share/llvm/cmake cmake ..</code> </pre> <br><br>  As a result of the assembly, the shared library is obtained.  It is located in the build / skeleton / libSkeletonPass.so file or in a file with a similar name depending on the platform used.  In the next step, we will load this library to perform a pass for real program code. <br><br><h2>  Pass </h2><br>  To run a pass, compile some C program with flags indicating that you need to use the library you just received: <br><br><pre> <code class="hljs sql">$ clang -Xclang -<span class="hljs-keyword"><span class="hljs-keyword">load</span></span> -Xclang <span class="hljs-keyword"><span class="hljs-keyword">build</span></span>/skeleton/libSkeletonPass.* something.c I saw a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> called <span class="hljs-keyword"><span class="hljs-keyword">main</span></span>!</code> </pre> <br><br>  This dance with the procedure -Xclang -load -Xclang path / to / lib.so is all you need to <a href="http://adriansampson.net/blog/clangpass.html">load and activate the passage in Clang</a> .  Therefore, when working with large projects, you can add these arguments to the list of CFLAGS Makefile variables or the corresponding equivalent of your build system. <br><br>  (In addition, you can perform passes by themselves without running a clang: this method using the LLVM opt command is <a href="http://llvm.org/docs/WritingAnLLVMPass.html">recommended in the official documentation</a> . However, I will not describe it in this article). <br><br>  Congratulations, you just finished the compiler!  In the next steps, we will see how to refine our ‚ÄúHello, world!‚Äù Level passage to more interesting things. <br><br><h1>  The structure of the intermediate presentation LLVM </h1><br>  To work with programs in LLVM, it would be nice to understand the structure of software. <br><br><img src="http://adriansampson.net/media/llvm/llvm-containers.svg" alt="image"><br><br>  <i>Modules ( <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1Module.html">Modules</a> ) contain functions ( <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1Function.html">Functions</a> ), which, in turn, include the basic blocks ( <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1BasicBlock.html">BasicBlock</a> ), containing instructions ( <a href="http://www.llvm.org/docs/doxygen/html/classllvm_1_1Instruction.html">Instructions</a> ).</i>  <i>All classes except Module are derived from <a href="http://www.llvm.org/docs/doxygen/html/classllvm_1_1Value.html">Value</a> .</i> <i><br></i> <br><br><h2>  Container </h2><br>  Below is an overview of the most important components of the LLVM program: <br><br><ul><li>  A module is simply a source file (roughly speaking) or a transformation unit (if you strictly approach).  The module contains all other entities. </li><li>  First of all, modules contain functions that fully correspond to their name and are named blocks of executable code (both functions and methods in C ++ correspond to LLVM functions). </li><li>  In addition to declaring the name and arguments, the function serves as a container of basic blocks (BasicBlock).  <a href="https://en.wikipedia.org/wiki/Basic_block">The base unit</a> is a familiar concept from compiler theory.  However, in our article we will consider it simply as a continuous block of instructions. </li><li>  In turn, the instruction is a single operation with the code;  its level of abstraction is about the same as in the <a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computing">RISC</a> machine code.  For example, the instruction can be the addition of integers, the division with a floating point or the storage into memory. </li></ul><br><br>  Most LLVM entities (functions, base blocks, and instructions) are C ++ classes derived from the omnipresent Value base class.  A value is any data that can be used in calculations (for example, the number or address of a code), as well as global variables and constants (known as "literals" or "immediate values", for example, 5). <br><br><h2>  Instruction </h2><br>  Below is an example of instructions in a readable text form PP LLVM: <br><br><pre> <code class="hljs perl">%5 = add i32 %4, <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><br>  The instruction adds two 32-bit numbers (indicated by i32).  It adds the number in register 4 (indicated by% 4) and the constant 2 (actually 2) and writes the result to register 5. That is what I mean when I say that the LLVM software looks like an ideal RISC machine code.  We even use the same terminology, such as register, but the number of registers is infinite. <br><br>  The same instruction is presented inside the compiler as an instance of the C ++ <a href="http://www.llvm.org/docs/doxygen/html/classllvm_1_1Instruction.html">Instruction</a> class.  The object has an opcode indicating that this is an addition, as well as the type and list of operands that serve as pointers to other Value objects.  In our case, it points to a <a href="http://www.llvm.org/docs/doxygen/html/classllvm_1_1Constant.html">Constant</a> object (constant) representing the number 2, and another <a href="http://www.llvm.org/docs/doxygen/html/classllvm_1_1Instruction.html">Instruction</a> object (instruction) corresponds to the register% 5.  (Considering that the LLVM PP has the form of a <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">static one-time assignment</a> , in reality the registers and instructions are the same. The register numbers are an artifact of the text representation.) <br><br>  By the way, if you want to see the PP LLVM of your program, you can ask about this Slang: <br><br><pre> <code class="hljs swift">$ clang -emit-llvm -<span class="hljs-type"><span class="hljs-type">S</span></span> -o - something.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><br><h2>  Intermediate View Verification </h2><br>  Let's go back to the LLVM passage we were working on.  We can check all important objects of the PP using the convenient common dump () method, which displays a readable representation of the object in the PP.  Given that our pass for each function being processed is obtained by the Function object, we will one after another get access to the basic blocks of functions and instructions of each block. <br><br>  Here is the code that does it.  It can be taken from <a href="https://github.com/sampsyo/llvm-pass-skeleton/tree/containers">the containers branch of the llvm-pass-skeleton repository</a> : <br><br><pre> <code class="cpp hljs">errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Function body:\n"</span></span>; F.dump(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; B : F) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Basic block:\n"</span></span>; B.dump(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; I : B) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Instruction: "</span></span>; I.dump(); } }</code> </pre> <br><br>  With fashionable auto and foreach from <a href="https://en.wikipedia.org/wiki/C%252B%252B11">C ++ 11,</a> it is convenient to bypass the hierarchy of PP LLVM. <br>  If you rebuild the passage and run it, you will see in the output different LLVM entities in the order of their traversal. <br><br><h1>  Using the passage to solve more complex problems </h1><br>  Real miracles happen when searching for patterns in the program and changing the code after they are detected.  Consider a simple example.  Suppose you need to replace the first binary operator ("+", "-", etc.) in each function with multiplication.  May be useful, is not it? <br><br>  Here is the code that does it.  This version, as well as a sample program where you can try it, is available in the <a href="https://github.com/sampsyo/llvm-pass-skeleton/tree/mutate">mutate branch of the LLVM git repository</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; B : F) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; I : B) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* op = dyn_cast&lt;BinaryOperator&gt;(&amp;I)) { <span class="hljs-comment"><span class="hljs-comment">// Insert at the point where the instruction `op` appears. IRBuilder&lt;&gt; builder(op); // Make a multiply with the same operands as `op`. Value* lhs = op-&gt;getOperand(0); Value* rhs = op-&gt;getOperand(1); Value* mul = builder.CreateMul(lhs, rhs); // Everywhere the old instruction was used as an operand, use our // new multiply instruction instead. for (auto&amp; U : op-&gt;uses()) { User* user = U.getUser(); // A User is anything with operands. user-&gt;setOperand(U.getOperandNo(), mul); } // We modified the code. return true; } } }</span></span></code> </pre><br><br>  Details: <br><br><ul><li>  The dyn_cast (p) construct is <a href="http://llvm.org/docs/ProgrammersManual.html">LLVM-specific</a> and performs a dynamic type cast.  It uses carefully thought-out LLVM mechanisms to quickly perform dynamic type checks ‚Äî the compilers use them all the time.  The construct returns a null pointer if I is not a binary BinaryOperator operator, so it is ideal for handling special cases, as in our code. </li><li>  <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1IRBuilder.html">IRBuilder is</a> designed to build code.  It provides a million methods for creating any instruction you wish. </li><li>  To embed our new instruction in the code, you need to find all the places where it is used, and insert this instruction into them as an argument.  Recall that the instruction Instruction is also a value (Value).  In this case, the multiplication instruction is used as an operand in another instruction, that is, the result will be an argument. </li><li>  In addition, we will need to remove the old instructions.  However, I omitted this step in order not to overload the description. </li></ul><br><br>  Now we can compile the program ( <a href="">example.c</a> in the repository): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(int argc, const char** argv) { int num; scanf("%i", &amp;num); printf("%i\n", num + 2); return 0; }</span></span></span></span></code> </pre><br><br>  The usual compiler gives the code with the expected behavior, and after the operation of our module, the code instead of adding two multiplies by two: <br><br><pre> <code class="cpp hljs">$ cc example.c $ ./a.out <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> $ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so example.c $ ./a.out <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre><br><br>  Magic! <br><br><h1>  Layout with executable code library </h1><br>  If you need to change the code so that it does something non-trivial, then generating the necessary instructions using <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1IRBuilder.html">IRBuilder</a> may require a lot of effort.  Instead, you can implement the desired behavior in C and build with the compiled program.  This section explains how to write a library that records the results of performing binary operations instead of changing them silently. <br><br>  Here is the program code that does this, taken from the <a href="https://github.com/sampsyo/llvm-pass-skeleton/tree/rtlib">branch of the rtlib</a> repository llvm-pass-skeleton: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Get the function to call from our runtime library. LLVMContext&amp; Ctx = F.getContext(); Constant* logFunc = F.getParent()-&gt;getOrInsertFunction( "logop", Type::getVoidTy(Ctx), Type::getInt32Ty(Ctx), NULL ); for (auto&amp; B : F) { for (auto&amp; I : B) { if (auto* op = dyn_cast&lt;BinaryOperator&gt;(&amp;I)) { // Insert *after* `op`. IRBuilder&lt;&gt; builder(op); builder.SetInsertPoint(&amp;B, ++builder.GetInsertPoint()); // Insert a call to our function. Value* args[] = {op}; builder.CreateCall(logFunc, args); return true; } } }</span></span></code> </pre><br>  The necessary tools are <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1Module.html">Module :: getOrInsertFunction</a> and <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1IRBuilder.html">IRBuilder :: CreateCall</a> .  The first adds the declaration of the function logop, as if in C code there was a declaration of the function void logop (int i);  without body.  This added declaration corresponds to the definition of the logop function in the library ( <a href="">rtlib.c</a> in the repository): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void logop(int i) { printf("computed: %i\n", i); }</span></span></span></span></code> </pre><br><br>  To run a modified program, build it with your library: <br><br><pre> <code class="cpp hljs">$ cc -c rtlib.c $ clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.so -c example.c $ cc example.o rtlib.o $ ./a.out <span class="hljs-number"><span class="hljs-number">12</span></span> computed: <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre><br><br>  If desired, you can link the program and the library before compiling into machine code.  You will be helped by the utility <a href="http://llvm.org/docs/CommandGuide/llvm-link.html">llvm-link</a> , which can be considered as the rough equivalent of <a href="https://sourceware.org/binutils/docs/ld/">ld</a> at the PP level. <br><br><h1>  Notes </h1><br>  Most projects require interaction with the developer.  For this, it is convenient to use notes that convey the necessary information from the program for your LLVM pass.  There are several ways to create notes. <br><br><ul><li>  A practical and hacking method is the use of "magical" functions.  Declare a function with an empty body and special, if possible, unique names in the header file.  Include this file in your source code and add calls to these functions.  Then, when you run the pass, find <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1CallInst.html">the CallInst instructions</a> that call your functions, and use them to start the "magic" functions.  For example, you can use the __enable_instrumentation () and __disable_instrumentation () calls to make the program limit your code changes to specific areas. </li><li>  If you want to allow programmers to add markers to function or variable declarations, the Clang __attribute __ ((Annotate ("foo"))) construct will add <a href="http://llvm.org/docs/LangRef.html">metadata</a> with the specified string that can be processed during the pass.  Brandon Holt wrote a <a href="http://homes.cs.washington.edu/~bholt/posts/llvm-quick-tricks.html">manuscript</a> about this technique.  If it is necessary to mark not declarations, but expressions, the <a href="">__builtin_annotation (e, ‚Äúfoo‚Äù) intrinsic</a> construction is suitable, which, unfortunately, is not documented and has limited capabilities. </li><li>  You can take a chance and make changes directly to Clang to interpret your new syntax.  But I do not advise doing this. </li><li>  If you need to create notes for types (which, in my opinion, is required quite often, even if you don‚Äôt realize this), now I‚Äôm developing a <a href="https://github.com/sampsyo/quala">Quala</a> system.  It adds support for custom type qualifiers and pluggable type systems to Clang, such as <a href="http://types.cs.washington.edu/jsr308/">JSR-308</a> for Java.  <a href="http://asampson%40cornell.edu/">Let me</a> know if you are interested in working together on this project! </li></ul><br>  I hope to tell in more detail about these methods in my future publications. <br><br><h1>  And much more‚Ä¶ </h1><br>  LLVM has great potential.  I will list only a few topics not covered in this article: <br><ul><li>  Use a wide range of classic compiler analysis tools available in the LLVM glove box. </li><li>  Creation of special machine instructions required by architects, by finalizing the backend. </li><li>  Use <a href="http://llvm.org/docs/SourceLevelDebugging.html">debug information</a> to obtain data on the line number and the character in the line of the source code corresponding to a certain point of the PP. </li><li>  Writing <a href="http://clang.llvm.org/docs/ClangPlugins.html">plugins for backend Clang</a> . </li></ul><br>  I hope that I provided you with enough information so that you could create something worthwhile.  Explore, create and <a href="http://asampson%40cornell.edu/">email me</a> if the article was helpful! <br>  ________________________________________ <br><br>  I express my gratitude to the staff of the University of Washington from the <a href="http://sampa.cs.washington.edu/">architecture</a> and <a href="http://syslab.cs.washington.edu/">systems</a> groups who were present at the presentation of the oral version of this article and asked many startlingly useful questions. <br><br>  Addition from my dear readers: <br><ul><li>  Emery Berger noted that dynamic binary instrumentation tools, such as <a href="http://www.pintool.org/">Pin</a> , are still the right choice if you need to comply with specific architectural requirements (registers, memory hierarchy, command coding, etc.). </li><li>  Brandon Holt has just published <a href="http://homes.cs.washington.edu/~bholt/posts/llvm-debugging.html">debugging</a> tips to <a href="http://homes.cs.washington.edu/~bholt/posts/llvm-debugging.html">LLVM</a> , including charting control flow with GraphViz. </li><li>  John Reger ( <a href="http://www.cs.utah.edu/~regehr/">John Regehr</a> ) <a href="https://news.ycombinator.com/item%3Fid%3D10000611">commented on</a> why it‚Äôs not very good in your project to depend on a brilliant LLVM - the API is constantly changing.  The internal components of LLVM change significantly from release to release, therefore, to save the project, it is necessary to keep up with these changes. </li><li>  Alex Bradbury publishes the <a href="http://llvmweekly.org/">LLVM Weekly newsletter</a> (‚Äú <a href="http://llvmweekly.org/">LLVM Weekly</a> Newsletter‚Äù) - an excellent resource for tracking events in the LLVM ecosystem. </li></ul><br><br>  <i>Translated by <a href="http://abbyy-ls.ru/">ABBYY Language Services</a></i> </div><p>Source: <a href="https://habr.com/ru/post/265871/">https://habr.com/ru/post/265871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265861/index.html">The path of the IT-manager. Management of the project environment and IT projects</a></li>
<li><a href="../265863/index.html">Climb into the clouds - so as not to bury in the ground</a></li>
<li><a href="../265865/index.html">Today, at 12:00 (MSK), see Jump Start broadcast: "Windows 10 in the corporate network"</a></li>
<li><a href="../265867/index.html">Open Rambler.Android MAP</a></li>
<li><a href="../265869/index.html">What is the EIS notary of Russia</a></li>
<li><a href="../265873/index.html">How we held a hardware hack contest at Chaos Constructions 2015</a></li>
<li><a href="../265875/index.html">The evolution of the cloud log collection and the log collector in open source</a></li>
<li><a href="../265883/index.html">Mobile integration with the new cloud PBX 3CX v14</a></li>
<li><a href="../265885/index.html">Video about effective altruism</a></li>
<li><a href="../265887/index.html">‚ÄúBigdata Conference‚Äù - the largest conference on big data very soon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>