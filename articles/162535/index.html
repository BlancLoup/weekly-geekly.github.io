<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write on php ... static</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP is a language with dynamic implicit weak typing. Dynamic typing is very useful in many cases, and in general greatly simplifies life, because you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write on php ... static</h1><div class="post__text post__text-html js-mediator-article">  PHP is a language with dynamic implicit weak typing.  Dynamic typing is very useful in many cases, and in general greatly simplifies life, because you concentrate on the values ‚Äã‚Äãand do not think about what type they are. <br><br>  Like many php programmers, I thought that static typing is a ‚Äúcomplication‚Äù.  It limits flexibility and in general: how do people work with it?  And sincerely did not understand why many experienced programmers prefer languages ‚Äã‚Äãwith static typing and strict type checking. <br><br><img src="https://habrastorage.org/storage2/b60/6d2/9d2/b606d29d2e0a52ec558f47b63b18fdc6.png" alt="Typing debate">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I belonged to the right half of people who know little about types, but at the same time sincerely believe that this is not convenient.  And so it was until I became acquainted with one of the strongly typed languages ‚Äã‚Äã(c #) closely.  Since then, my attitude to php and indeed to programming as a whole has changed. <br><br>  This article will hardly be of interest to the ‚ÄúTitans‚Äù of programming, because here you will not find anything revolutionary and new, and the rest interested in improving your code and your own performance are welcome under cat. <br><br><a name="habracut"></a><br><br>  To begin with, we will decide what static typing is: <br><br>  <i>Static typing is determined by the fact that the finite types of variables and functions are set at the compilation stage.</i>  <i>Those.</i>  <i>the compiler is already 100% sure which type is where.</i> <br><br>  In php, we do not have a compiler, and all types will be calculated in any case at runtime, but this does not prevent us from strictly following them, adhering to certain rules. <br><br><h4>  What does all this need in PHP? </h4><br>  Studying c # and simultaneously mastering the product for which tasks were set, without having enough experience and documentation (or rather there was no documentation at all), I was rescued by the fact that, thanks to strong typing, most of the errors were eliminated immediately, and the IDE hints issued based on specified types.  I didn‚Äôt need documentation to understand what and where to transfer, I couldn‚Äôt do something wrong, it just didn‚Äôt compile! <br><br>  This significantly reduced the time, because you immediately see that this method accepts only such parameters, and by creating objects for these parameters, you will know which links are not enough to construct them, and so on. <br><br>  ‚ÄúWell, it‚Äôs really convenient‚Äù - you will say - ‚ÄúBut you didn‚Äôt tell us anything new, PHP has PHPDoc, which most modern IDEs understand and helps to write code on the fly!‚Äù <br><br>  That's right, but for this to work in the same way as in statically typed languages, it is necessary not only to write a comment for each method and class property, but it is important that the whole architecture is designed to work with previously known objects.  To build such an architecture, you need to follow certain rules.  About them I would like to talk further. <br><br><h4>  Use objects instead of arrays </h4><br>  Yes exactly.  In general, this truth is not new and much has been written about it: objects are easier to expand, methods are easier to add to them, and in general, the path of the PLO. <br><br>  But I want to consider this question from the other side - from the point of view of building the right architecture for effective programming. <br><br>  Consider a simple example: <br>  Let's say an event occurs in the system, and we need to pass certain parameters to the handler. <br>  Use for this array: <br><br><pre><code class="php hljs">$eventData = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'sender'</span></span> =&gt; $controller, <span class="hljs-comment"><span class="hljs-comment">//   'name' =&gt; 'onDelete', 'group' =&gt; 'global', 'arguments' =&gt; array( 'id' =&gt; 15 ), ); $eventDispatcher-&gt;triggerEvent($eventData); ... /** *    * @param array $eventData */ protected function onDelete($eventData) { //    $eventData   , //       var_dump() //        $model = $eventData['sender']-&gt;model-&gt;deleteChilds(); }</span></span></code> </pre> <br>  The simplest and quite frequent case, nothing complicated, compose an array with the data and send it to the function. <br><br>  Now imagine that the challenge of this event is somewhere deep in the depths of a program not written by you (or you, but not yesterday). <br><br>  Submitted?  And well, if there is documentation in which the format of this array is described, then you will not have to spend time searching for the calling section of code in order to spy on the structure of the array.  Or you use var_dump (), and still spend time to understand what is happening there. <br><br>  Let's now consider what happens if, instead of an array, we would describe a class and create its object.  Change the code: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  ,   * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> BaseController */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $sender; <span class="hljs-comment"><span class="hljs-comment">/** *   * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $name; <span class="hljs-comment"><span class="hljs-comment">/** *      () * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $group; <span class="hljs-comment"><span class="hljs-comment">/** *     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $arguments; } $eventData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventData(); $eventData-&gt;sender = $controller; $eventData-&gt;name = <span class="hljs-string"><span class="hljs-string">'onDelete'</span></span>; $eventData-&gt;group = <span class="hljs-string"><span class="hljs-string">'global'</span></span>; $eventData-&gt;arguments = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>); $eventDispatcher-&gt;triggerEvent($eventData); ... <span class="hljs-comment"><span class="hljs-comment">/** *    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> EventData $eventData */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($eventData)</span></span></span><span class="hljs-function"> </span></span>{ $eventData-&gt;sender-&gt;model-&gt;deleteChilds(); }</code> </pre><br>  What did we get in the end?  Now our favorite IDE tells us what the resulting object contains. <br><br><img src="https://habrastorage.org/storage2/014/0ce/342/0140ce342bfa51f0be54c3d0afaea3e0.png"><br><br>  In addition, due to the fact that we have described in detail the type for each attribute in the passed object, we can immediately receive hints on them.  Those.  typing $ eventData-&gt; controller-&gt; - we can see what is inside the attribute named controller. <br><br>  Now you do not have to climb somewhere in the jungle of code in order to understand what is transmitted in this object and what type it is.  Imagine how grateful you are to other programmers who will work with your code! <br><br>  If your application is actively using the ActiveRecord pattern, then you are already close to total typing, but if you still get elements from the database as arrays and chase them there, many times from function to function, then you should think about changing architecture. <br><br>  It was a simple and rather synthetic example.  Perhaps in your project in a similar situation, and so the object is used, rather than an array.  But look more attentively, there are situations not similar to this one, for example, three-storey arrays are transferred to a function, or the function has a dozen arguments of an incomprehensible type. <br><br>  Continuing to improve our example, I would not stop at creating one class.  Usually in modern web applications many different events take place, and different arguments are passed to them, they can be grouped, and for each group of events you can create your own - a suitable class of arguments. <br><br>  Do not be afraid to create classes.  You do not need to create a separate file for each if they are interconnected with each other. <br>  For example, I would create an EventArguments.php file, and in it I would describe all possible variants of event arguments. <br><br>  <b>UPD:</b> I do not call to understand my call to replace ALL arrays with objects literally, this is not correct. <br><br>  Quote from wiki: <br><blockquote>  An array is an ordered set of data for storing data of the same type, identified by one or more indices. </blockquote><br>  It is in this vein that arrays should be used.  those.  store some ordered data of the same type. <br><br>  Recklessly changing arrays on objects can do more harm than good.  Therefore, you have to determine for yourself (and for your project) the line between usability of objects and system performance. <br><br><h4>  Initialize variables with the correct type. </h4><br>  Just for example: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** *   * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isLeaf) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;find(<span class="hljs-string"><span class="hljs-string">'where id = :id'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">':id'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id)); } } ... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($model-&gt;getChildren() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $child) { <span class="hljs-comment"><span class="hljs-comment">//     }</span></span></code> </pre><br>  Familiar?  The problem lies in the fact that if the condition! $ This-&gt; isLeaf fails, then the result of the function will not be an array at all, and we will have to write a bunch of sample code so that foreach does not fall due to incorrect arguments. <br><br>  It should be: <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** *   * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,     -   . //         ,     ,   . $children = array(); if(!$this-&gt;isLeaf) { $children = $this-&gt;find('where id = :id', array(':id', $this-&gt;id)); } return $children; }</span></span></code> </pre><br>  Now if the condition! $ This-&gt; isLeaf fails, then the result of the function will be an empty array that we defined at the beginning, and the foreach to which the value falls from this function will not fall if something goes wrong. <br><br>  The considered example is only the tip of the iceberg.  If you always immediately define a variable with the necessary, previously known type, you can save a lot of time.  And also to write more beautiful code without additional checks worsening the code perception. <br><br>  By the way, this concerns not only php.  For example, in JavaScript in the V8 engine, determining the type of a variable at the stage of its creation speeds up the execution of the script, as it does not force the engine to do unnecessary transformations (more in this <a href="http://habrahabr.ru/post/154537/">article</a> ) <br><br><h4>  Strong typing tools. </h4><br>  PHP has weak typing, which means that it does not check types during operations with them.  Those.  you can add a string with a number, or check the equality between the scalar object, and the interpreter will not tell you anything.  To force PHP to behave strictly typed we cannot.  However, in its bundle, PHP has several handy (albeit not always logical) type control tools. <br><br>  For example, when defining a function, you can explicitly indicate what type its parameters should be: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">triggerEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventData $event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          EventData    } ... $dispatcher-&gt;triggerEvent(new EventData); //  $dispatcher-&gt;triggerEvent(new EventDataChild); //EventDataChild -  EventData,   $dispatcher-&gt;triggerEvent(new AnotherClass()); //Catchable fatal error: Argument 1 passed to EventDispatcher::triggerEvent() must be an instance of EventData, instance of new AnotherClass given</span></span></code> </pre><br>  Thus, we, without additional checks, have protected ourselves from accidental transfer to the function of the parameter of the wrong type.  PHP itself will check the type of the parameter passed and will give an error if it does not match. <br><br>  Quote from the manual of <a href="http://php.net/oop5.typehinting">php.net/oop5.typehinting</a> type <a href="http://php.net/oop5.typehinting">control</a> : <br><br><blockquote>  At the moment, functions have the ability to force parameters to be either objects (by specifying the class name in the function prototype), or interfaces, or arrays (starting with PHP 5.1), or a callable callback (starting with PHP 5.4). <br><br>  However, if NULL was used as the default parameter value, this will also be valid as an argument for the subsequent call. <br><br>  If a class or interface is specified for type control, then all its descendants or implementations are also valid. <br>  Type control cannot be used with scalar types such as int or string.  Traits are also unacceptable. </blockquote><br>  Making a conclusion from the above, we can specify almost everything except scalar types, but PHP has a solution to this account.  The standard SPL library contains several interesting classes designed to solve this problem: <br><ul><li>  Splint </li><li>  Spllfloat </li><li>  Splenum </li><li>  SplBool </li><li>  Splstring </li></ul><br>  Since these types are classes (oil is oil, but in the context of php where int is a type, but not a class, it is permissible) they can be specified in the function definition, thereby preventing the transfer to the function, for example, strings where boolean is required.  Accordingly, you will have to use these classes throughout the code, instead of standard scalars. <br><br>  Honestly, I did not use it, because in my opinion this is overkill.  In addition, these classes are not included in the standard PHP distribution, and are distributed by the PECL package, which makes them difficult to use. <br><br><h4>  Use PHPDoc wherever possible. </h4><br>  PHPDoc and its support in the IDE is a great PHP time saving tool for the programmer. <br><br>  Since the syntax of the language and its ideology do not allow you to set the type of a variable when creating it, it is very difficult for your IDE to understand what a variable is.  So help her - specify the type in the comments, and your IDE will thank you with tips during the work. <br><br>  This is another step towards full typing your application.  If you know what gets and what returns the desired method, you will not have difficulty using it. <br><br>  I adhere to the following rules: <br>  <b>All public</b> class <b>attributes</b> must have a comment describing the type; <br>  <b>All public methods</b> must also have a description of what they do and a description of each parameter, including what they return. <br><br>  Small hints for those unfamiliar with PHPDoc (this is all correct for the NetBeans environment) <br><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">//     , //         @return //  IDE             /** *      EventData * @return EventData */ public function getEventData(){ return new EventData(); } //   ,    ,     : //@return EventHandler[] //  -      . //   ,    ,      // //: /**    EventHandler * @return EventHandler[] */ public function getEventHandlers(){ return $this-&gt;handlers; } public function triggerEvent(){ foreach ($this-&gt;getEventHandlers() as $handler) { $handler; //   IDE  ,  $handler    EventHandler,     } } public function getModel(){ //      //(    .  ,      ) //   ,         .    : $model = NodeFactory::byId($id); /* @var $model Folder */ $model; //  IDE         Folder }</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  What would anyone say, but PHP has grown to a fairly powerful tool.  Dynamic typing is what allows it to be as flexible and simple as possible.  But along with it come complexity. <br><br><img src="https://habrastorage.org/storage2/3e0/72d/f1b/3e072df1bb6effa570a119f3cc71cffd.jpg"><br><br>  Static typing allows to improve productivity and reduce the number of errors in the code. <br><br>  From comments on Habr√© to article <a href="http://habrahabr.ru/post/161205/">Likbez on typification</a> : <br><blockquote>  In tasks whose complexity makes you feel a wild delight at the possibility of automatic checking at least something, languages ‚Äã‚Äãwith strong static typing overtake everything else.  The complexity of the tasks solved during site building is gradually approaching this level. </blockquote><br>  We can not change the relationship of PHP to types, and it is not necessary.  We also cannot take overnight and translate all our projects into any other language, for this there is neither time nor opportunity. <br>  But thanks to a well-designed architecture, the use of type control in the prototypes of your functions, as well as documentation with PHPDoc, you can unload yourself from unnecessary work and search for errors in your projects. <br><br>  By adhering to the advice outlined in this article, we will be able to combine the best of both worlds, and get a powerful and flexible tool for developing complex projects. <br><br><h4>  Useful links: </h4><br>  <a href="http://habrahabr.ru/post/161205/">Likbez on typing in programming languages</a> <br>  <a href="http://php.net/oop5.typehinting">Type Control in PHP</a> <br>  <a href="http://php.net/manual/ru/book.spl-types.php">PHP SPL Types</a> <br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25B0">Static code analysis (Wikipedia)</a> </div><p>Source: <a href="https://habr.com/ru/post/162535/">https://habr.com/ru/post/162535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162521/index.html">7 Intel¬Æ VTune Amplifier XE New Features</a></li>
<li><a href="../162527/index.html">Year with Roomba</a></li>
<li><a href="../162529/index.html">Creating the perfect player</a></li>
<li><a href="../162531/index.html">Exporting polygons from Altium Designer to AutoCAD</a></li>
<li><a href="../162533/index.html">Urgent update of RVM (Ruby Version Manager)</a></li>
<li><a href="../162537/index.html">Selection of the input mask by phone number</a></li>
<li><a href="../162539/index.html">How we reduced ping with OpenVPN</a></li>
<li><a href="../162541/index.html">NOOK for developers of children's mobile applications</a></li>
<li><a href="../162543/index.html">Frequency analysis of electrical network noise in forensics</a></li>
<li><a href="../162545/index.html">Official sales of iPad mini and iPhone 5 begin in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>