<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of computer networks. Subject number 5. The concept of IP addressing, subnet masks and their calculation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I welcome you to the next issue. And today we will talk about what IP-addresses are and how to use them. What is a subnet mask, how it is considered, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of computer networks. Subject number 5. The concept of IP addressing, subnet masks and their calculation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/43f/408/cc3/43f408cc315d4ab7b82631fd056820bd.jpg"><br><br>  I welcome you to the next issue.  And today we will talk about what IP-addresses are and how to use them.  What is a subnet mask, how it is considered, and why it is needed.  How to divide networks into subnets and summarize them.  I invite interested persons to read. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  1) <a href="https://habrahabr.ru/post/307252/">Basic network terms, OSI network model and TCP / IP protocol stack.</a> <br>  2) <a href="https://habrahabr.ru/post/307714/">Top-level protocols.</a> <br>  3) <a href="https://habrahabr.ru/post/308636/">Protocols of lower levels (transport, network and channel).</a> <br>  4) <a href="https://habrahabr.ru/post/312340/">Network devices and types of cables used.</a> <br>  5) The concept of IP addressing, subnet masks and their calculation. <br>  6) <a href="https://habrahabr.ru/post/319080/">The concept of VLAN, Trunk and VTP and DTP protocols.</a> <br>  7) <a href="https://habrahabr.ru/post/321132/">Spanning Tree Protocol: STP.</a> <br>  8) <a href="https://habrahabr.ru/post/334778/">Channel Aggregation Protocol: Etherchannel.</a> <br>  9) Routing: static and dynamic on the example of RIP, OSPF and EIGRP. <br>  10) Network Address Translation: NAT and PAT. <br>  11) Reservation protocols for the first transition: FHRP. <br>  12) Computer network security and virtual private networks: VPN. <br>  13) Global networks and protocols used: PPP, HDLC, Frame Relay. <br>  14) Introduction to IPv6 configuration and routing. <br>  15) Network management and network monitoring. <br><br>  PS Perhaps over time, the list will be added. </div></div><br>  Let's start, or will continue, with the most popular, hackneyed and sick.  These are IP addresses.  Over the course of 4 articles, this concept has been encountered several times, and most likely you have already either understood what they are for, or noggulili and read about them.  But I have to tell you this, because without a clear understanding it will be hard to move on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So the IP address is the address that the node uses at the network level.  It has a hierarchical structure.  What does it mean?  This means that each number in its writing has a specific meaning.  I will explain with a very good example.  An example would be a regular telephone number - +74951234567.  The first digit is +7.  This suggests that the number belongs to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D1%2582%25D0%25B5%25D0%25BB%25D0%25B5%25D1%2584%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2_%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD">zone of the</a> Russian Federation.  This is followed by 495. This is the code of Moscow.  And the last 7 digits I took random.  These numbers are assigned to the district area.  As you can see here there is a clear hierarchy.  That is, by number you can understand which country, zone it belongs to.  IP addresses follow a similar strict hierarchy.  The organization is controlled by the IANA (Internet Assigned Numbers Authority).  If in Russian, then this is the "Administration of the address space of the Internet."  Note that the word "Internet" with a capital letter.  Few people attach importance to this, so I will explain the difference.  In the English literature, the term ‚Äúinternet‚Äù is used to describe several networks connected to each other.  And the term "Internet" to describe the global network.  So take note. <br><br>  Despite the fact that the topic of the article is more theoretical than practical, I strongly recommend that you take it seriously, because it depends on understanding of further topics, and especially routing.  There is no one for whom, I think, it is no secret that we are accustomed to perceive numeric information in decimal format (in numbers from 0-9).  However, all modern computers perceive information in binary (0 and 1).  It does not matter with the help of current or light information is transmitted.  All of it will be perceived by the device as there is a signal (1) or not (0).  Only 2 values.  Therefore, an algorithm was developed for converting from binary to decimal, and vice versa.  I'll start with a simple one and tell you what IP addresses look like in decimal format.  This whole article is about IP addresses of version 4. There will be a separate article about version 6.  In previous articles, labs, and indeed in life, you saw something like this "193.233.44.12."  This is the IP address in decimal.  It consists of 4 numbers, called octets and separated by dots.  Each such number (octet) can take a value from 0 to 255. That is, one of 256 values.  The length of each octet is 8 bits, and the total length of IPv4 = 32 bits.  Now an interesting question.  How will this address take the computer, and how will it work with it? <br><br>  You can of course stuff it into a calculator, of which there is bulk on the Internet, and it will convert it into binary format, but I believe that everyone should be able to translate manually.  This is especially true of those who are planning to take the exam.  You will have nothing on hand except paper and a marker, and you will have to rely only on your skills.  Therefore, showing how to do it manually.  Build a table. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td><td>  x </td></tr></tbody></table><br>  Instead of ‚Äúx‚Äù, either 1 or 0 is written. The table is divided into 8 columns, each of which carries 1 bit (8 columns = 8 bits = 1 octet).  They are arranged in order from left to right.  That is, the first (left) bit is the oldest and has the number 128, and the last (right) is the youngest and has the number 1. Now I will explain where these numbers come from.  Since the system is binary, and the length of the octet is equal to 8 bits, each number is obtained by raising the number 2 to the power from 0 to 7. And each of the received digits is written into the table from the largest to the smallest.  That is, from left to right.  From 2 to the 7th degree to 2 to the 0th degree.  I will give a table of degrees 2-ki. <br><br><img src="https://habrastorage.org/files/b94/1b3/157/b941b315742b4f2182a86281475e1e8b.PNG"><br><br>  I think now it is clear how the table is built.  Let's now look at the address "193.233.44.12" and see how it looks in binary format.  Let us examine each octet separately.  Take the number 193 and see from what table combinations it is obtained.  128 + 64 + 1 = 193. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  one </td><td>  one </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td></tr></tbody></table><br>  Those numbers that participated in the formation of a combination get 1, and all the others get 0. <br><br>  Take the first octet 233. 128 + 64 + 32 + 8 + 1. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  one </td><td>  one </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  one </td></tr></tbody></table><br>  For 44, this is 32 + 8 + 4. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  0 </td><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  one </td><td>  0 </td><td>  0 </td></tr></tbody></table><br>  And finally 12. 8 + 4. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  one </td><td>  0 </td><td>  0 </td></tr></tbody></table><br>  The result is a long bit sequence 11000001.11101001.00101100.00001100.  It is with this kind of work network devices.  The bit sequence is reversible.  You can also insert each octet (8 characters) into the table and get a decimal notation.  I will present a completely random sequence and bring it to decimal form.  Let it be 11010101.10110100.11000001.00000011.  I build the table and put in it the first block. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  one </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td></tr></tbody></table><br>  I get 128 + 64 + 16 + 4 + 1 = 213. <br><br>  I calculate the second block. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  one </td><td>  0 </td><td>  one </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td></tr></tbody></table><br>  I think 128 + 32 + 16 + 4 = 180. <br><br>  The third block. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  one </td><td>  one </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td></tr></tbody></table><br>  128 + 64 + 1 = 193. <br><br>  And finally, the fourth. <br><table><tbody><tr><th>  128 </th><th>  64 </th><th>  32 </th><th>  sixteen </th><th>  eight </th><th>  four </th><th>  2 </th><th>  one </th></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  one </td><td>  one </td></tr></tbody></table><br>  2 + 1 = 3 <br><br>  We collect the results of calculations and get the address 213.180.193.3.  Nothing hard, pure arithmetic.  If it is difficult and direct unbearably difficult, then practice.  At first, it may seem scary, as many have graduated 10 years ago and have forgotten a lot.  But I assure you that as soon as you put your hand, it will be much easier to count.  Well, to consolidate, I'll give you a few examples for self-calculation (there will be answers under the spoiler, but only open them when you decide it yourself). <br><br>  <b>Problem number 1</b> <br><br>  1) 10.124.56.220 <br>  2) 113.72.101.11 <br>  3) 173.143.32.194 <br>  4) 200.69.139.217 <br>  5) 88.212.236.76 <br>  6) 01011101.10111011.01001000.00110000 <br>  7) 01001000.10100011.00000100.10100001 <br>  8) 00001111.11011001.11101000.11110101 <br>  9) 01000101.00010100.00111011.01010000 <br>  10) 00101011.11110011.10000010.00111101 <br><br><div class="spoiler">  <b class="spoiler_title">Answers</b> <div class="spoiler_text">  1) 00001010.01111100.00111000.11011100 <br>  2) 01110001.01001000.01100101.00001011 <br>  3) 10101101.10001111.00100000.11000010 <br>  4) 11001000.01000101.10001011.11011001 <br>  5) 01011000.11010100.11101100.01001100 <br>  6) 93.187.72.48 <br>  7) 72.163.4.161 <br>  8) 15.217.232.245 <br>  9) 69.20.59.80 <br>  10) 43.243.130.61 <br></div></div><br>  Now IP-addresses should not be something scary, and you can delve into their study. <br>  Above, we talked about the structure of telephone numbers and their hierarchy.  And at the dawn of the birth of the Internet in the view in which we used to see it, a question arose.  The question was that the IP addresses need to somehow be grouped and controlled to issue.  The solution was to divide the entire space of IP addresses into classes.  This decision was called <b>class addressing (from the English. Classful)</b> .  It has long been outdated, but in almost every book, entire chapters and sections are devoted to it.  Cisco also does not forget about it and in its educational materials tells about it.  Therefore, I will go over this topic and show how it shone from 1981 to 1995. <br><br><img src="https://habrastorage.org/files/3a6/cb6/2cd/3a6cb62cd0ef471d94d011f3f6ca1108.PNG"><br><br>  The space was divided into 5 classes.  Each class has been assigned a block of addresses. <br><br>  <b>Let's start with class A.</b>  If you look closely at the table, you can see that this block is given the largest block of addresses, and to be exact, half of the entire address space.  This class was intended for large networks.  The structure of this class is as follows. <br><br><img src="https://habrastorage.org/files/b69/191/ec7/b69191ec7a8e45688114a0055856515e.PNG"><br><br>  What is the essence.  The first octet, that is, 8 bits, remains behind the network address, and the last 3 octets (that is, the remaining 24 bits) are assigned to the hosts.  Here, in order to show which piece belongs to the network, and which to the hosts, a <b>mask is</b> used.  The structure of the record is similar to the record of the IP address.  The difference between masks and IP addresses is that 0 and 1 cannot alternate.  First there are 1, and then 0. Thus, where there is a unit, then this is a network segment.  Below, after analyzing classes, I will show you how to work with it.  Now the main thing to know that the mask of class A - 255.0.0.0.  In the table some first bit is also mentioned, and for class A it is equal to 0. This bit is just needed in order for the network device to understand which class it belongs to.  He also sets the initial and final address range.  If in binary form units are recorded on all octets, except the first bit in the first octet (there is always 0), we get 127.255.255.255, which is the class A boundary. For example, take the address 44.58.63.132.  We know that in class A, the first octet is given to the network address.  That is, "44" is the network address, and "58.63.132" is the host address. <br><br>  <b>Let's talk about class B</b> <br><br><img src="https://habrastorage.org/files/c2f/017/171/c2f01717133f4e829cd29c42f9b44f81.PNG"><br><br>  This class has been given a smaller block.  And addresses from this block were intended for medium-scale networks.  2 octets are given for the network address, and 2 - for the address of the hosts.  The mask for the B class is 255.255.0.0.  The first bits are strictly 10. And the rest are changing.  Let us turn to the example: 172.16.105.32.  The first two octets for the network address are ‚Äú172.16‚Äù.  And the 3rd and 4th under the address of the host - "105.32". <br><br>  <b>Class C</b> <br><br><img src="https://habrastorage.org/files/35d/2ed/dad/35d2eddadfe24607b5cceb8b7e1bbdff.PNG"><br><br>  This class was cheated with addresses and gave it the smallest unit.  It was intended for small networks.  But this class gave as many as 3 octets for the network address and only 1 octet for hosts.  His mask is 255.255.255.0.  The first bits are 110. For example, it looks like this - 192.168.1.5.  The network address is ‚Äú192.168.1‚Äù, and the host address is ‚Äú5‚Äù. <br><br>  <b>Classes D and E.</b>  I am inconsistent in combining them into one.  Addresses from these blocks are reserved and cannot be assigned to networks and hosts.  Class D is for multicast.  An analogy can be made with television.  The channel broadcasts a group of persons its broadcast.  And those who are connected, can watch TV.  That is, only 3 first classes can be available to administrators. <br><br>  Let me remind you that the first bits of class D are 1110. An example of the address is 224.0.0.5. <br><br>  And the first bits of class E is 1111. Therefore, if you suddenly see the address of the form 240.0.0.1, feel free to say that this is the address of the E class. <br><br>  Pro classes have mentioned.  Now I will voice the question that I was recently asked.  So why then masks?  We have so the hosts understand what class they are in.  But the point is this.  For example, you have a small office, and you need a block of IP addresses.  Nobody will give you all the addresses of class C. And they will give only his piece.  For example, 192.168.1.0 with a mask of 255.255.255.0.  So this mask will determine your border.  We have already said that the octet varies in value from 0 to 255. This 4 octet is completely at your disposal.  Except for the first address and the last one, that is, 0 and 255 in this case.  The first address is the network address (in this case, 192.168.1.0), and the last address is the broadcast address (192.168.1.255).  Let me remind you that the broadcast address is used in the case when you need to transmit information to all nodes in the network.  Therefore, there is a rule.  If you need to know the network number, then all bits related to the host are set to 0, and if broadcast, then all bits are set to 1. Therefore, if 2 addresses are taken from 256 addresses, then 254 addresses are left to be assigned to the hosts (256 - 2) .  At interviews and exams often like to ask: "The number of IP addresses on the network?" And "How many IP addresses on the network to assign to the hosts?".  Two different questions that can stump.  The answer to the first one will be all the addresses, including the network address and the broadcast address, and the second question is all addresses except the network address and the broadcast address. <br><br>  Now dive into the study of the mask. <br><br><img src="https://habrastorage.org/files/e79/1ed/42b/e791ed42ba98451ca67d4f992c74a2f8.PNG"><br><br>  I recorded the class C address 192.168.1.1 with the mask 255.255.255.0 in decimal and binary format.  Notice how the IP address and the mask look like in binary format.  If the IP address 0 and 1 alternate, then the mask first goes 1, and then 0. These bits fix the network address and set the size.  In the table above, we can conclude that in binary form the mask is represented by a sequence of 24 units in a row.  This suggests that as many as 3 octets are allocated to the network, and 4 octets are free for addressing for the hosts.  There is nothing unusual here.  This is a standard class C mask. <br><br>  But here's the catch.  For example, you have 100 computers in your office, and you do not plan to expand.  Why produce a network of 250+ addresses that you do not need?  Subnetting comes to the rescue.  This is a very convenient thing.  Let me explain the principle using the example of the same class C. However you would like, but you cannot touch 3 octets.  They are fixed.  But here 4 octet is free for hosts, so you can touch it.  Borrowing bits from the host chunk, you split the network into the n-th number of subnets and, accordingly, reduce the number of addresses for the hosts. <br><br>  Let's try to translate it into reality.  Change the mask.  I borrow the first bit from the host part (that is, I set the 1st bit of the 4th octet to one).  It turns out the following mask. <br><br><img src="https://habrastorage.org/files/f6f/e49/d41/f6fe49d411c54896a4e0a2244752cb91.PNG"><br><br>  This mask divides the network into 2 parts.  If before the crushing the network had 256 addresses (from 0 to 255), then after crushing each piece will have 128 addresses (from 0 to 127 and from 128 to 255). <br>  Now I will see what will change in general with addresses. <br><br><img src="https://habrastorage.org/files/d97/53f/6ac/d9753f6acbdd4425a8cf0eefd52e10ce.PNG"><br><br>  In red, I showed those bits that are fixed and cannot change.  That is, the mask sets the boundary for it.  Accordingly, bits marked in black are defined to address the hosts.  Now I will calculate this boundary.  To determine the beginning, all free bits (marked in black) must be turned to zero, and to determine the end to turn into units.  I'm starting. <br><br><img src="https://habrastorage.org/files/5c4/652/794/5c46527947ec4765bea84185db3d52d8.PNG"><br><br>  That is, in the fourth octet, all bits except the first one are changed.  It is rigidly fixed within this network. <br><br>  Now we will look at the second half of the network and calculate its addresses.  Our division was made by borrowing the first bit in the 4th octet, which means it is a divisor.  The first half of the network was obtained when this bit took the value 0, which means the second network is formed when this bit takes the value 1. I turn this bit to 1 and look at the boundaries. <br><br><img src="https://habrastorage.org/files/450/d3c/6e4/450d3c6e48f44beaac8d87fb627578e9.PNG"><br><br>  I will give a decimal view. <br><br><img src="https://habrastorage.org/files/600/97d/719/60097d71927d4ac9be95b8dadee07798.PNG"><br><br>  Accordingly .128 and .255 cannot be assigned to hosts.  So in the availability of 128-2 = 126 addresses. <br>  This is how you can use the mask to control the size of the network.  Each borrowed bit divides the network into 2 parts.  If we bite off 1 bit from the host part, we divide it into 2 parts (128 addresses each), 2 bits = 4 parts (64 addresses each), 3 bits = 8 (32 addresses each), and so on. <br><br>  If you calculated the number of bits for hosts, then the number of available IP addresses can be calculated by the formula <img src="https://habrastorage.org/files/7ea/bae/3be/7eabae3be92742d6ac822267d18099ba.PNG"><br><br>  In the book of <a href="http://www.ciscopress.com/authors/bio/4eae296b-d6f0-44a3-869c-42126efebcf3">W. Odom</a> on the preparation for the CCNA R &amp; S, a good formula is given for calculating the bits sent to the subnet and hosts: <br><br>  <b>N + S + H = 32</b> , where <b>N</b> is the number of network bits (class A is 8 bits, B is 16 bits, C is 24 bits), <b>S</b> is the number of borrowed bits per subnet (this is what we did above, when borrowed 1 bit from the host), <b>H</b> - the number of bits allocated to the hosts. <br><br>  I will clarify and explain how and where to apply these formulas. <br><br>  Take an example: <br><br>  We were given a network of 172.16.0.0 and asked to create 120 subnets with 180 hosts and write a mask.  Let's get started <br><br>  As a cheat sheet, and for quick calculation, I have prepared a table of powers of two below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/28a/f45/a74/28af45a74d46443197504e3ef9df990c.PNG"></div><br>  Moving on.  The first major condition, when using class addressing, is that one mask should be used for all subnets.  That is, if you have a mask of 255.255.255.0 for one subnet, then for another subnet it cannot be 255.255.255.128. <br><br>  Now we look at the issued network.  By logical reflections, we understand that this is a class B address. And that means its N (number of network bits) = 16. Ok.  So the hosts are also allocated 16 bits.  We recall the conditions of the problem.  Need to create 120 subnets.  "Bite off" bits from the network part is prohibited, it means we bite from the host part. <br><br>  Now you need to take such a number of bits, so that is enough for 120 subnets, but leaves a sufficient number of bits for the host.  We look at the table above.  If we take 7 bits, we get 128. 128&gt; 120, therefore we fall under the condition.  If we take 6 bits, we get 64. 64 &lt;128, so we do not fall under the condition and discard this option. <br><br>  OK.  Found out that S should be allocated at least 7 bits.  Now let's see what is left for the hosts. <br>  If N + S + H = 32 =&gt; H = 32 - (N + S) =&gt; H = 32 - (16 + 7) = 9. Look at the table above (or raise 2 to the 9th power in the mind) and get the number 512. Subtract 2 (the network address and the broadcast address) and get 510 addresses.  We need 180, which means we get under the condition with a large margin.  In such cases, you are given the right to choose.  Make more subnets or hosts per subnet.  Explain what it means.  We have 9 bits per host.  If we take 8 bits, we get the number 256. 256 - 2 = 254 addresses.  This option also suits us.  Take 7 bits.  We get 128. Even without taking away 2 addresses, it becomes clear that this is less than 180 =&gt; this option is discarded immediately.  In total, we find that the minimum number for a subnet is 7 bits, and for hosts it is 8 bits.  Therefore, the free bit can be given either to the subnet or to the hosts.  The mask is obtained by adding N and S. In our case, if we give 7 bits for the subnet, we get 23. In decimal form, the mask will look like 255.255.254.0.  And if we give 8 bits to the subnet, we get 24 (or in decimal 255.255.255.0).  Sometimes it happens that there is only one mask for the task.  And, of course, there may be cases when the mask does not fall under any conditions.  In these cases, you need to take a network of another class or prove to the customer that this is impossible. <br><br>  I think now it is clear how class addressing worked, and how it was calculated.  Perhaps the first time the head does not digest this, so reread again and more closely.  As soon as something starts to clear up, practice on the tasks I‚Äôll leave. <br><br>  <b>Problem number 2</b> <br><br>  1) Write a mask for the project: network 172.16.0.0.  250 subnets and 220 hosts. <br>  2) Write a mask for the project: network 10.0.0.0.  2000 subnets and 1500 hosts. <br>  3) Write a mask for the project: network 192.168.0.0.  4 subnets and 60 hosts. <br><br><div class="spoiler">  <b class="spoiler_title">Answers to tasks</b> <div class="spoiler_text">  1) 24 bits or 255.255.255.0 <br>  2) 19 bits (255.255.224.0), 20 bits (255.255.240.0), 21 bits (255.255.248.0) <br>  3) 26 bits or 255.255.255.192 <br></div></div><br>  On this conversation about class networks I will begin to round out and summarize.  Class addressing is the birth of today's Internet, and it all began with it.  Therefore, it has a lot of advantages, and thanks to the creators for it.  But, as you can see, she had a tight binding to one mask.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to this, IP addresses were not used economically and wastefully. And in connection with the rapid growth of the Internet addresses was not enough, and urgently needed to make changes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Understood the leading minds that the use of class networks is not convenient and you need to give them up. This led to the creation of classless addressing and variable length masks, which we will discuss below. But before that, a few words about the types of IP addresses. Despite the fact that the transition from class to classless addressing suggested saving IP addresses, in fact, this problem was still not fully resolved. It all came down to the IPv4 technology itself. I will explain why. Above, I said that the length of the IP address is 32 bits. Each bit can take the value 0 or 1, that is, two values. Accordingly, in order to calculate all the combinations, it is necessary to build 2 to the 32nd degree. We get 4294967296 addresses. If we subtract from here the reserved for special needs and other things, then there will remain approximately 4.2 billion addresses, when about 7.3 billion people live on Earth.Therefore, leading minds quickly cut through this chip and began to look for a solution. They decided to allocate some address space that will be used only within the local network and will not be used on the Internet. It divided the addresses into 2 camps: white or public (eng. Public) and gray or private (eng. Private).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I quote a range of addresses that are allocated for local networks: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) 10.0.0.0 - 10.255.255.255 with a mask of 255.0.0.0 (or briefly 10/8). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) 172.16.0.0 - 172.31.255.255 with a mask of 255.240.0.0 (or briefly 172.16 / 12). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) 192.168.0.0 - 192.168.255.255 (or briefly 192.168 / 16). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To be honest, I have seen the use of addressing 172.16.XX in a few places. Usually 10.XXX is always used in the corporate environment, and 192.168.XX in houses / apartments and small offices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I ask you to pay attention to a very important thing that many confuse. Do not confuse class addressing with a range of private addresses. A lot of people step on this rake and firmly believe that the range of private addresses 10.0.0.0 - 10.255.255.255 is the range of the A class.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Understood what are private addresses or private addresses. But that is not all. There is also a list of reserved addresses that cannot be lit on the Internet. They have written the entire IETF documentation. I </font><font style="vertical-align: inherit;">give a </font></font><a href="https://tools.ietf.org/html/rfc3330"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> where you can read the original. I will briefly describe the common ones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) 0.0.0.0/8 - the address range used by hosts for self-identification. This can usually be seen when the host is trying to get an IP address from a DHCP server. Since he initially does not have an IP address, he inserts an address from this range into the source field.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) 127.0.0.0/8 - loopback or localhost addresses. These are the IP addresses used by the computer to access itself. Very useful for checking TCP / IP performance. The fact is that regardless of the connection to the Internet or local network, addresses from this pool should always be pinged. If this does not happen, then the system is covered or covered with a copper basin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) 169.254.0.0/16 - link-local address or local addresses. Automatically used by hosts in the absence of a DHCP server or its inaccessibility. This allows you to quickly organize a local network and check the operation of nodes. However, this address pool is not routed. Consequently, to go online with them will not work.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) 224.0.0.0/4 - a block of addresses reserved for multicast or multicast. For those who want to learn more about multicast, leave a </font></font><a href="https://tools.ietf.org/html/rfc3171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classless Addressing (Classless Inter-Domain Routing or CIDR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It was described in the RFC1519 standard in 1993. She abandoned the class framework and fixed mask. Addresses are divided only into public and reserved, which are written above. If in class addressing the mask is cut to be uniform for all subnets, then in the classless address, each subnet may have its own mask. On theory, everything is good and beautiful, but there is nothing better than practice. Therefore, I turn to it and explain how it can be divided into subnets with different numbers of hosts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a cheat sheet give a list of all possible masks.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ceb/1a9/530/ceb1a95307f04be7be921003cc38a4ab.PNG"></div><br>  Imagine the situation.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You were given a network of 192.168.1.0/24 and set the following conditions: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Subnet on 10 addresses for guests. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Subnet at 42 addresses for employees. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Subnet for 2 addresses to connect 2 routers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) Subnet at 26 addresses for the branch.</font></font><br><br>  OK.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mask indicates that we have 256 addresses at our disposal. </font><font style="vertical-align: inherit;">By condition, this network must somehow be divided into 4 subnets.</font></font> Let's try.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256 is very well divided by 4, giving 64 in response. So one big block of 256 addresses can be divided into 4 equal blocks of 64 addresses each. And everything would be fine, but it generates a large number of empty addresses. For employees who need 42 addresses, okay, the company may further hire them. But the subnet for routers, which requires only 2 addresses, will leave 60 empty addresses. Yes, you can say that these are private addresses, and who cares about them. Now imagine that these are public addresses that are routed on the Internet. There are so few of them, and here we will still throw them away. This is not the case, especially when we can flexibly manage the address space. Therefore, we return to the example and cut the subnet as we need.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, which subnets should be sliced ‚Äã‚Äãto contain all the addresses specified by the condition? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) For 10 hosts, the smallest subnet will be a block of 16 addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) For 42 hosts, the smallest subnet is a block of 64 addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) For 2 hosts, the smallest subnet will be a block of 4 addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) For 26 hosts, the smallest subnet will be a block of 32 addresses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I understand that not everyone can grasp this right from the first, and there is nothing to worry about. </font><font style="vertical-align: inherit;">All people are different and perceive information differently. </font><font style="vertical-align: inherit;">For completeness, I will show the division in the picture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have a block consisting of 256 addresses.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/17e/37d/ae9/17e37dae9b9243989f885ae09755f2ac.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After dividing into 4 parts, the following picture is obtained. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3c5/b2c/b94/3c5b2cb942294979be6a9c3178ed342e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, we found that in this situation addresses are not used rationally. </font><font style="vertical-align: inherit;">Now pay attention to how the address space began to look after cutting subnets of different lengths.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8c1/e59/da0/8c1e59da02724c7daf54d17ae1d6b1b8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there are a lot of addresses in free access, which we will be able to use in the future. </font><font style="vertical-align: inherit;">You can count the exact figure. </font><font style="vertical-align: inherit;">256 - (64 + 32 + 16 + 4) = 140 addresses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the addresses we saved. </font><font style="vertical-align: inherit;">Moving on and answering the following questions: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- What will be the network and broadcast addresses? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- What addresses can be assigned to hosts? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- How will I look like a mask? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mechanism of dividing into subnets with different masks is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSM (from the English. Variable Length Subnet Mask)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable length subnet mask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I give important advice! Start addressing from the largest subnet. Otherwise, you can get to the fact that the address will overlap. Therefore, first plan the network on paper. Draw it, draw it in the form of figures, calculate it manually or on a calculator, and only then proceed to the setting in combat conditions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the largest subnet consists of 64 addresses. Let's start with it. The first address pool will be the following: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The subnet address is 192.168.1.0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The broadcast address is 192.168.1.63. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pool of addresses to assign to hosts from 192.168.1.1 to 192.168.1.62. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the choice of the mask.</font></font> It's simple.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take away the necessary piece from the whole network and write the resulting number into the mask octet. That is, 256 - 64 = 192 =&gt; mask 255.255.255.192 or / 26. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next comes the smaller subnet. It consists of 32 addresses. If the first one ended in .63, then this one will start with .64: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The subnet address is 192.168.1.64. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The broadcast address is 192.168.1.95. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The address pool for assignment to hosts will be from 192.168.1.65 to 192.168.1.94. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mask: 256 - 32 = 224 =&gt; 255.255.255.224 or / 27. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 3rd subnet that is intended for the branch will start from .96: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The subnet address is 192.168.1.96. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The broadcast address is 192.168.1.111. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The address pool for assignment to hosts will be from 192.168.1.97 to 192.168.1.110.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mask: 256 - 16 = 240 =&gt; 255.255.255.240 or / 28. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, for the last subnet that goes under the interfaces connecting the routers will start with .112: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The subnet address is 192.168.1.112. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The broadcast address is 192.168.1.115. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resolved addresses are 192.168.1.113 and 192.168.1.114. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mask: 256 - 4 = 252 =&gt; 255.255.255.252 or / 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I note that the address 192.168.1.115 is the last used address. Starting from 192.168.1.116 and up to .255 are free. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this way, using VLSM or variable-length masks, we have economically created 4 subnets with the required number of addresses in each. I think it is worth fixing a puzzle for an independent decision. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number 3</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Split the network 192.168.1.0/24 into 3 different subnets. Find and record in each subnet its address, broadcast address, pool of allowed addresses and mask. I specify the required sizes of subnets: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Subnet for 120 addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Subnet to 12 addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Subnet to 5 addresses.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"> 1)   ‚Äî 192.168.1.0. <br>   ‚Äî 192.168.1.127. <br>        192.168.1.1  192.168.1.126. <br> : 256 ‚Äî 128 = 128 =&gt; 255.255.255.128  /25. <br><br> 2)   ‚Äî 192.168.1.128. <br>   ‚Äî 192.168.1.143. <br>        192.168.1.129  192.168.1.142. <br> : 256 ‚Äî 16 = 240 =&gt; 255.255.255.240  /28. <br><br> 3)   ‚Äî 192.168.1.144. <br>   ‚Äî 192.168.1.151. <br>        192.168.1.145  192.168.1.150. <br> : 256 ‚Äî 8 = 248 =&gt; 255.255.255.248  /29. <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you know how to divide networks into subnets, it's time to learn how to assemble subnets into one common subnet. Otherwise, it is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">summation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">summarization</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Summation is most often used in routing. When you have several neighboring subnets in the router table that are routed through the same interface or address. Most likely this process is better explained when parsing routing, but given that the topic of routing is already large, I will explain the process of summation in this article. Moreover, the summation is a solid mathematics, and in this article we are doing it. Well, let's get started.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine that I have a company consisting of the main building and buildings. I work in the main building, and in the buildings of a colleague. Although I have the main building, there are only 4 subnets in it: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 192.168.0.0/24 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 192.168.1.0/24 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 192.168.2.0/24 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 192.168.3.0/24 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the colleagues from the neighboring building found out and realized flew configuration on the router, and there are no backups. They do not remember by heart which subnets in the main building, but they remember that they are next to each other and ask to send one summarized one. Now I have a problem how to summarize them. To begin, I will translate all subnets in binary form.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/246/329/9db/2463299db9014131ae68d9becf0b961c.PNG"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look carefully at the table. </font><font style="vertical-align: inherit;">As you can see, in 4 subnets, the first 22 bits are the same. </font><font style="vertical-align: inherit;">Accordingly, if I take 192.168.0.0 with a mask / 22 or 255.255.252.0, then I will cover my 4 subnets. </font><font style="vertical-align: inherit;">But pay attention to the 5 subnet, which I specifically introduced. </font><font style="vertical-align: inherit;">This is the subnet 192.168.4.0. </font><font style="vertical-align: inherit;">Its 22nd bit is different from the previous 4th, which means that the one selected above will not cover this subnet.</font></font><br>  OK.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I will send a summarized subnet to my colleagues, and if they register everything correctly, then routing to my subnets will work without problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take the same example and slightly change the conditions. </font><font style="vertical-align: inherit;">We were asked to send a summary route for subnets 192.168.0.0 and 192.168.1.0. </font><font style="vertical-align: inherit;">I will not be lazy and create another table.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a58/3d7/526/a583d75268074b75b50787d31f623e30.PNG"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that the first 2 subnets have the same 22 bits instead of 22 bits. This means that they can be summed up even more compactly. In principle, it will work both ways. But as it was said in one advertisement: ‚ÄúIf there is no difference - why pay more?‚Äù. Therefore, try to summarize, without affecting the neighboring subnets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, by converting subnets to binary and finding the same bits, you can sum them up.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, summation is useful when you need to combine several subnets located close to each other. This will save router resources. However, this is not always possible. To sum up, for example, the subnet 192.168.1.0 and 192.168.15.0, without capturing the neighboring subnets, is impossible. Therefore, before summing up, it is worth considering its expediency. Therefore, I repeat once again that it is necessary to start any revolution on a piece of paper. Well, to secure the material leave a small task. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number 4</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Given 4 subnets: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) 10.3.128.0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) 10.3.129.0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) 10.3.130.0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) 10.3.131.0 Sum </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up the subnets and find a mask that can cover them without affecting the neighboring subnets.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4db/4e5/d1c/4db4e5d1c6eb4040869cd0e25fa56207.PNG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Based on this, the answer will be 10.3.128.0/22 ‚Äã‚Äã(255.255.252.0) </font></font><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's time to wrap up. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article was not very long. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would even say the opposite. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But everything that Cisco needs to know about IPv4 is covered. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is the most important thing to do. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, of course, it's right to divide the subnets and distribute address space. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for reading. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you want to have your prices.</font></font></font></font></div><p>Source: <a href="https://habr.com/ru/post/314484/">https://habr.com/ru/post/314484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314470/index.html">Creating fun and engaging animations with simple Spine features (heavy gifs inside)</a></li>
<li><a href="../314472/index.html">We encode music in the browser</a></li>
<li><a href="../314474/index.html">How I tried to enable http2 in my project with nginx</a></li>
<li><a href="../314476/index.html">Microsoft will provide antiviruses with the ability to monitor the activity of the Linux subsystem on Windows 10</a></li>
<li><a href="../314478/index.html">Transfer domain? Get ready for trouble</a></li>
<li><a href="../314486/index.html">How enum is available for everyone to do, but write to the meta-type</a></li>
<li><a href="../314490/index.html">Recommendations based on product images</a></li>
<li><a href="../314492/index.html">Problems with the image: image tag in site maps. Bypass misunderstanding Yandex validator</a></li>
<li><a href="../314494/index.html">Implementation of the performance indicator of queries, stored procedures and triggers in MS SQL Server. Autotrace</a></li>
<li><a href="../314496/index.html">How important is mathematical training in promising areas of software development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>