<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What should be the future technology of parallel programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I saw habratopic ‚ÄúProgramming parallel processes - is it too difficult?‚Äù , And realized that there are habra people who are interested in it. I could ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What should be the future technology of parallel programming</h1><div class="post__text post__text-html js-mediator-article">  I saw habratopic <a href="http://www.habrahabr.ru/blog/arbeit/18235.html">‚ÄúProgramming parallel processes - is it too difficult?‚Äù</a> , And realized that there are habra people who are interested in it.  I could not resist expressing my opinion on this matter. <br><br>  Briefly, the point is that processor manufacturers (in particular, Intel) have ceased to increase the clock frequency, and instead follow the path of increasing the number of cores in a single processor.  Moreover, multi-core processors are now massively used for the production of not only servers, but also desktops.  In this case, the overwhelming majority of desktop programs are now single-threaded and will not work faster on multi-core processors.  If you run several such programs, and programs at the same time want to use processor time, then together they will work faster.  But, in my opinion, this is not what the desktop user expects from new processors.  And therefore there are concerns that users may not want to upgrade their dual-core desktop to, for example, the eight-core. <br><br>  Therefore, Intel is interested in the fact that software manufacturers would write multi-threaded programs for desktops. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, not all so simple. <a name="habracut"></a>  Especially for software manufacturers. <br><br>  There are two problems.  First, with the modern level of programming language development, creating multi-threaded programs is many times more expensive (more expensive because it is many times more difficult) than single-threaded programs.  Secondly, these programs are of much worse quality due to the complexity associated with non-determinism, which is inherent in multithreading. <br><br>  Edward A. Lee in the article <a href="http://www.softcraft.ru/parallel/pwt/pwt.pdf">‚ÄúProblems with Flows‚Äù</a> writes: ‚ÄúI argue that in most cases the reliability and predictability of the systems cannot be achieved by using flows‚Äù. <br><br>  I think that by calling programmers to improve their skills (thereby increasing their cost for hiring, and thereby worsening the future quality of desktop programs), Intel will not achieve significant results. <br><br>  However, it is not difficult to trace the reason why both of these problems arose.  All high-level languages ‚Äã‚Äãthat I know about, including such as Java, C # and C ++, force a high-level programmer who wants to write multi-threaded programs to explicitly manipulate such low-level concepts like stream, mutex, monitor, and messaging. <br><br>  In my opinion, this is the reason for all today's troubles with multi-threaded programming - high-level programmers are forced to manipulate low-level concepts that relate more to the operating system, and not to the program for the end user.  And until this problem is resolved, multithreading will never become a mass practice (mainstream) for desktops.  As much as Intel would not like it. <br><br>  This reason is similar to the one that caused memory problems and was fixed by the garbage collector.  Namely, C ++ high-level programmers were forced to massively and constantly manage memory by obviously manipulating such low-level concepts like memory allocation and freeing.  After the virtual machine took over this work, leaving the garbage collector to the programmer, the problem of working with memory disappeared. <br><br>  Therefore, a new technology for multithreading should do the same for thread management as the garbage collector does for memory management, namely, to take all the work of manipulating threads, giving high-level programmers the ability to write multi-thread programs exclusively in terms of classes, objects and dependencies between these classes and objects.  Those.  A new technology should automatically parallelize certain high-level programs.  By the way, I believe that information about dependencies between objects is enough not only for garbage collection, but also for such automatic parallelization. <br><br>  I also think that my idea will be relatively easy to prove by writing a framework as a library for an existing language.  Naturally, such a library cannot guarantee the thread safety of the entire system.  Just as a garbage collector, written as a library (unlike a built-in virtual machine), cannot guarantee the type safety of the entire system.  But, first, to prove the viability of the concept of this will be enough, and secondly, the new program code can be used together with the old, written earlier. <br><br>  There are many ways to put this framework into practice.  One of those that I see is to base it on the principle of ‚Äúinjection injection‚Äù ( <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> ) in the form of an <a href="http://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> container.  Those.  obliging the programmer to declare dependencies between objects or classes in a certain way.  In the future, the virtual machine or the compiler will be able to stop the conversion of one object to another, if the dependencies between them have not been declared, or automatically set the type of dependencies between them by default. <br><br>  In the future, I think, I will also have to give up (at least partially) and from using the stack to provide the control flow (replacing the stack, for example, with a graph).  The stack is well suited for executing a program in a single thread, but is an atavism that prevents the appearance of high parallelism in multi-threaded programs. </div><p>Source: <a href="https://habr.com/ru/post/11275/">https://habr.com/ru/post/11275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112743/index.html">Restore order in the wires</a></li>
<li><a href="../112745/index.html">Protection of critical infrastructure in Russia</a></li>
<li><a href="../112746/index.html">Droider Chart. Issue 37</a></li>
<li><a href="../112748/index.html">Time Zones</a></li>
<li><a href="../112749/index.html">Why IDEA is better than Eclipse</a></li>
<li><a href="../112750/index.html">Sammari on four books</a></li>
<li><a href="../112752/index.html">How to stop programming in Delphi and start living</a></li>
<li><a href="../112753/index.html">CodeIgniter 2.0.0 Released</a></li>
<li><a href="../112754/index.html">How litter the top</a></li>
<li><a href="../112755/index.html">How I stole a domain from me, and I stole it back</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>