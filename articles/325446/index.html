<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scala: parser combinators on the example of the formula parser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time I have a desire to invent my own little programming language and write an interpreter. This time I started writing on scala, I learn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scala: parser combinators on the example of the formula parser</h1><div class="post__text post__text-html js-mediator-article"><p> From time to time I have a desire to invent my own little programming language and write an interpreter.  This time I started writing on scala, I learned about the parser combinators library, and was amazed: it turns out, you can write parsers easily and simply.  In order not to turn the article into an "owl drawing" manual, below is the implementation of parsing and calculating expressions like <code>"1 + 2 * sin(pi / 2)"</code> . </p><br><p>  The parsing and calculation of the expression itself occupy only 44 non-empty lines - not that I strongly wanted to reduce their number, but it looks really simple and concise.  <a href="https://github.com/Kright/FormulaParser">Project on github</a> . </p><br><p>  For comparison: </p><br><ul><li>  <a href="https://habrahabr.ru/post/122397/">long java example</a> </li><li>  <a href="https://habrahabr.ru/post/271285/">a short but incomprehensible example in C #</a> </li><li>  <a href="">java example using parboiled</a> </li></ul><br><p>  So, if you can not wait to see the result: </p><br><div class="spoiler">  <b class="spoiler_title">Responsible for parsing a piece of code</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormulaParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackratParsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Id</span></span>] = <span class="hljs-string"><span class="hljs-string">"[a-zA-Z][a-zA-Z0-9_]*"</span></span>.r ^^ <span class="hljs-type"><span class="hljs-type">Id</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Number</span></span>] = <span class="hljs-string"><span class="hljs-string">"-"</span></span> ~&gt; number ^^ (n =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(-n.value)) | (<span class="hljs-string"><span class="hljs-string">"[0-9]+\\.[0-9]*"</span></span>.r | <span class="hljs-string"><span class="hljs-string">"[0-9]+"</span></span>.r) ^^ (s =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(s.toDouble)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCall</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">FuncCall</span></span>] = id ~ (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>) ^^ {<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id ~ exp =&gt; <span class="hljs-type"><span class="hljs-type">FuncCall</span></span>(id, exp)} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = number | funcCall | id | (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> term: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = term ~ (<span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span>) ~ value ^^ binOperation | value <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expression: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = expression ~ (<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>) ~ term ^^ binOperation | term ... }</code> </pre> </div></div><br><p>  Look at the next line: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = number | funcCall | id | (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>)</code> </pre> <br><p>  It is suspiciously similar to a grammar description, but it is a valid code in which the development environment can immediately detect and highlight most errors. </p><br><p>  This is possible for the following reasons: </p><br><ol><li>  In scala, it is allowed to give methods remarkable names like <code>"~", "~&gt;", "&lt;~", "|", "^^"</code> .  The combination of the parsers <code>p</code> and <code>q</code> written as <code>p~q</code> , and the ability to choose one of them: <code>p|q</code> .  Reads much better than <code>p.andThen(q)</code> or <code>p.or(q)</code> </li><li>  Thanks to implicit conversions (implicits), the string <code>"abc"</code> and the regular expression <code>"[0-9]+".r</code> if necessary, turn into parsers. </li><li>  The language has a powerful static type system that allows you to catch errors right away. </li></ol><br><p>  I think I managed to interest you, so then everything will be in order. </p><br><a name="habracut"></a><br><h3 id="oglavlenie">  Table of contents: </h3><br><ol><li>  <a href="https://habr.com/ru/post/325446/">Pegex parsers</a> </li><li>  <a href="https://habr.com/ru/post/325446/">Packrat parsers</a> </li><li>  <a href="https://habr.com/ru/post/325446/">whole parser code</a> </li><li>  <a href="https://habr.com/ru/post/325446/">expression evaluation</a> </li><li>  <a href="https://habr.com/ru/post/325446/">conclusion</a> </li></ol><br><h2 id="parser-combinators">  Parser Combinators. </h2><br><p>  Once these classes were included in the standard library of the language, but then they were taken out in a separate library.  At the end I gave links where you can find more detailed information. </p><br><h3 id="regex-parsers">  Regex parsers </h3><br><p>  So, the simplest is RegexParsers.  Add implicit conversions from strings and regular expressions to parsers. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleExample</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolTrue</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ^^ (_ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    "true",   ,       boolean def bool: Parser[Boolean] = ("true" | "false") ^^ (_ == "true") //         def alternativeBool: Parser[Boolean] = "true" ^^ (_ =&gt; true) | "false" ^^ (_ =&gt; false) //       def int: Parser[Int] = "[0-9]+".r ^^ (_.toInt) //       . //  .r      def id: Parser[Id] = "[a-zA-Z][a-zA-Z0-9_]*".r ^^ Id // Id - ,       Id }</span></span></code> </pre> <br><p>  By the way, the <code>~</code> icon indicates not only the method of the parser, but also the name of the case class that stores a pair of values.  A piece of code from <code>Parsers.scala</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">~</span></span></span><span class="hljs-class">[+a, +b](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_1: a, _2: b</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-string"><span class="hljs-string">"("</span></span>+ _1 +<span class="hljs-string"><span class="hljs-string">"~"</span></span>+ _2 +<span class="hljs-string"><span class="hljs-string">")"</span></span> }</code> </pre> <br><p>  Suppose we want to build one of several parsers: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intInBrackets</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-string"><span class="hljs-string">"("</span></span> ~ int ~ <span class="hljs-string"><span class="hljs-string">")"</span></span> ^^ (p =&gt; p._1._2)</code> </pre> <br><p>  What will happen? </p><br><ol><li>  <code>"("</code> implicitly converts a string into a parser, which returns a <code>String</code> </li><li>  <code>int</code> parser returns <code>Int</code> </li><li>  <code>"(" ~ int</code> creates a parser for <code>~[String, Int]</code> </li><li>  <code>"(" ~ int ~ ")"</code> creates a parser that returns <code>~[~[String, Int], String]</code> </li><li>  the parser will call the <code>^^</code> method </li><li>  A function is passed to the method, which takes an argument <code>p</code> type <code>~[~[String, Int], String]</code> and returns an <code>Int</code> </li></ol><br><p>  In this case, the brackets do not carry any useful information.  You can do this: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intInBrackets</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; int &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  This time the brackets will be dropped. </p><br><ul><li>  <code>"(" ~&gt; int</code> creates a parser that parses the bracket and then <code>Int</code> , but returns only <code>Int</code> </li><li>  <code>int &lt;~ ")"</code> works in the same way, but for the left argument </li></ul><br><p>  Expressions with the operator <code>&lt;~</code> are advised to be enclosed in parentheses, since its priority is not very high. <br>  def </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCall</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">FuncCall</span></span>] = id ~ (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>) ^^ (pair =&gt; <span class="hljs-type"><span class="hljs-type">FuncCall</span></span>(pair._1, pair._2))</code> </pre> <br><p>  Now it should be clear what the following code does: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Number</span></span>] = <span class="hljs-string"><span class="hljs-string">"-"</span></span> ~&gt; number ^^ (n =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(-n.value)) | (<span class="hljs-string"><span class="hljs-string">"[0-9]+\\.[0-9]*"</span></span>.r | <span class="hljs-string"><span class="hljs-string">"[0-9]+"</span></span>.r) ^^ (s =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(s.toDouble)) <span class="hljs-comment"><span class="hljs-comment">// s.toDouble    . def value: Parser[Expression] = number | funcCall | id | ("(" ~&gt; expression &lt;~ ")") private def binOperation(p: Expression ~ String ~ Expression) = p match { case e1 ~ op ~ e2 =&gt; BinOperation(e1, BinOperator(op), e2) }</span></span></code> </pre> <br><p>  I was a little lazy and turn the string into a number by standard methods.  Time must be saved) </p><br><p>  Since our parser description is code, ambiguous grammars still work.  In the example of parsing <code>number | funcCall | id</code> <code>number | funcCall | id</code>  <code>number | funcCall | id</code> we are trying to parse the <code>number</code> , in case of failure - a function call, etc.  The order may be important, for example <code>(id | funcCall)</code> when trying to parse "sin (x)" joyfully parse <code>Id("sin")</code> , and the <code>funcCall</code> parser <code>funcCall</code> not be called.  To work correctly, it is better to write <code>(funcCall | id)</code> . </p><br><h2 id="packrat-parsers">  Packrat parsers </h2><br><p>  Suppose we want to parse a sequence of ones: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ones</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ones</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>] = ones ~ <span class="hljs-string"><span class="hljs-string">"1"</span></span> | <span class="hljs-string"><span class="hljs-string">"1"</span></span> }</code> </pre> <br><p>  Parsing <code>ones</code> starts with the fact that we call parsing <code>ones</code> , which again ... </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3c9/63a/217/3c963a2177f34437bc213931d9ee3e22.jpg" width="400"></div><br><p>  Attempting to split ones will cause the stack to overflow. </p><br><p>  In this case, you can change the description so that each time "absorbed" something.  For example: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ones</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>] = <span class="hljs-string"><span class="hljs-string">"1"</span></span> ~ ones | <span class="hljs-string"><span class="hljs-string">"1"</span></span></code> </pre> <br><p>  But grammar is not always easy to rewrite.  Type <code>3-2-1</code> expressions should be recognized exactly as <code>(3-2)-1</code> , option <code>3-(2-1)</code> will not work.  There will be a similar problem with division.  How to do this without complicating grammar? </p><br><p>  Packrat - parsers will save us.  Their idea is that the parser can store "for itself" some information about calls.  For example, to save the result of the work and not to parse the same thing twice ... or to work correctly in cases of recursion. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ones</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackratParsers</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ones: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>] = ones ~ <span class="hljs-string"><span class="hljs-string">"1"</span></span> | <span class="hljs-string"><span class="hljs-string">"1"</span></span> }</code> </pre> <br><p>  Trait PackratParsers contains an implicit conversion of strings and other things into parsers of the "desired" type. </p><br><p>  PackratParser is best created only once and stored in a variable.  In addition, if the <code>p</code> parser uses <code>q</code> , and <code>q</code> uses <code>p</code> , then lazy initialization should be used. </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> term: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = term ~ (<span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span>) ~ value ^^ binOperation | value <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expression: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = expression ~ (<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>) ~ term ^^ binOperation | term</code> </pre> <br><p>  I think it is now clear how you can easily and naturally parse 3-2-1 as (3-2) -1. </p><br><p>  Perhaps you have a question: where does the parser store information?  If it is stored directly inside PackratParser, then calling the parser for other input may give incorrect results.  So, the necessary information is stored together with the "input" data of the parser.  You can look at the library code and see this: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackratReader</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">underlying: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Reader</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ outer =&gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>[<span class="hljs-type"><span class="hljs-type">PackratParsers</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cache = mutable.<span class="hljs-type"><span class="hljs-type">HashMap</span></span>.empty[(<span class="hljs-type"><span class="hljs-type">Parser</span></span>[_], <span class="hljs-type"><span class="hljs-type">Position</span></span>), <span class="hljs-type"><span class="hljs-type">MemoEntry</span></span>[_]] ... }</code> </pre> <br><p>  Therefore, the parser accepts not a string as an input, but <code>new PackratReader(new CharSequenceReader(string))</code> </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(code: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">LexerError</span></span>, <span class="hljs-type"><span class="hljs-type">Expression</span></span>] = parse(expression, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">PackratReader</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">CharSequenceReader</span></span>(code))) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(result, next) =&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span>(result) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NoSuccess</span></span>(msg, next) =&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span>(<span class="hljs-type"><span class="hljs-type">LexerError</span></span>(msg)) }</code> </pre> <br><p>  What is the coolest - using packrat parsers does not oblige to anything, they can be combined with ordinary parsers and vice versa. </p><br><h2 id="parser-gotov">  Parser ready </h2><br><p>  Complete code: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormulaParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegexParsers</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackratParsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Id</span></span>] = <span class="hljs-string"><span class="hljs-string">"[a-zA-Z][a-zA-Z0-9_]*"</span></span>.r ^^ <span class="hljs-type"><span class="hljs-type">Id</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Number</span></span>] = <span class="hljs-string"><span class="hljs-string">"-"</span></span> ~&gt; number ^^ (n =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(-n.value)) | (<span class="hljs-string"><span class="hljs-string">"[0-9]+\\.[0-9]*"</span></span>.r | <span class="hljs-string"><span class="hljs-string">"[0-9]+"</span></span>.r) ^^ (s =&gt; <span class="hljs-type"><span class="hljs-type">Number</span></span>(s.toDouble)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCall</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">FuncCall</span></span>] = id ~ (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>) ^^ {<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id ~ exp =&gt; <span class="hljs-type"><span class="hljs-type">FuncCall</span></span>(id, exp)} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = number | funcCall | id | (<span class="hljs-string"><span class="hljs-string">"("</span></span> ~&gt; expression &lt;~ <span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> term: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = term ~ (<span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span>) ~ value ^^ binOperation | value <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expression: <span class="hljs-type"><span class="hljs-type">PackratParser</span></span>[<span class="hljs-type"><span class="hljs-type">Expression</span></span>] = expression ~ (<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>) ~ term ^^ binOperation | term <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binOperation</span></span></span></span>(p: <span class="hljs-type"><span class="hljs-type">Expression</span></span> ~ <span class="hljs-type"><span class="hljs-type">String</span></span> ~ <span class="hljs-type"><span class="hljs-type">Expression</span></span>) = p <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e1 ~ op ~ e2 =&gt; <span class="hljs-type"><span class="hljs-type">BinOperation</span></span>(e1, <span class="hljs-type"><span class="hljs-type">BinOperator</span></span>(op), e2) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(code: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ParserError</span></span>, <span class="hljs-type"><span class="hljs-type">Expression</span></span>] = parse(expression, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">PackratReader</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">CharSequenceReader</span></span>(code))) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(result, next) =&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span>(result) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NoSuccess</span></span>(msg, next) =&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span>(<span class="hljs-type"><span class="hljs-type">ParserError</span></span>(msg)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParserError</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">msg: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinOperator</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">operator: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Id</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinOperation</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">left: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expression</span></span></span></span><span class="hljs-class"><span class="hljs-params">, op: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">BinOperator</span></span></span></span><span class="hljs-class"><span class="hljs-params">, right: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expression</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncCall</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">funcName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-class"><span class="hljs-params">, argument: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Expression</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span></span></code> </pre> <br><p>  The result of parsing is either a tree or an error message. </p><br><p>  <code>case</code> classes are simply wrapper classes over values, they all implement the Expression interface.  the word <code>sealed</code> means that the classes implementing this interface should be contained in the same file.  This makes it safe to say that <code>Expression</code> can be one of four types. </p><br><h2 id="vychislenie-vyrazheniy">  Expression evaluation </h2><br><p>  The code that evaluates expressions is also simple.  I assume that the input is valid expressions. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Evaluator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">Expression</span></span>, variables: (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty, functions: (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; (<span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty): <span class="hljs-type"><span class="hljs-type">Double</span></span> = { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(exp: <span class="hljs-type"><span class="hljs-type">Expression</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (exp, variables, functions) expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Number</span></span>(value) =&gt; value <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Id</span></span>(name) =&gt; variables(name) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">BinOperation</span></span>(left, op, right) =&gt; operator2func(op)(eval(left), eval(right)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">FuncCall</span></span>(funcId, expr) =&gt; functions(funcId.name)(eval(expr)) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator2func</span></span></span></span>(binOperator: <span class="hljs-type"><span class="hljs-type">BinOperator</span></span>): (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = binOperator.operator <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> =&gt; (a, b) =&gt; a + b <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> =&gt; (a, b) =&gt; a - b <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> =&gt; (a, b) =&gt; a * b <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; (a, b) =&gt; a / b } }</code> </pre> <br><p>  Scissor tiles - you can declare the <code>eval</code> function inside the <code>apply</code> function to increase readability of the code.  The second thing is that we default the Map.empty as an argument by default.  It is empty, so it can be of any type, it is immutable, so it will remain empty, and in fact we will get references to the same object - singlelton.  <code>Map.empty</code> has a <code>apply(a: In):Out</code> method <code>apply(a: In):Out</code> - we can consider it as a function. </p><br><h2 id="pochti-vsyo">  Almost all </h2><br><p>  Parsing and evaluating expressions are ready.  Calculate the resulting lines of code (non-empty): </p><br><ol><li>  Parser: 18 lines </li><li>  case classes for describing AST: 6 </li><li>  expression evaluation: 20 lines. </li></ol><br><p>  And that's all - and the code is easy to read, easy to change, and it practically does not contain anything extra.  Beauty! </p><br><h2 id="a-ono-rabotaet">  Does it work? </h2><br><p>  It is worth thinking about this at the stage of writing the parser, but the checking code does not affect anything, because it is shown only now.  (Of course, you can write testiki ... but this article is about writing parsers, not tests, so I made it as simple as possible) </p><br><div class="spoiler">  <b class="spoiler_title">The code that checks the work</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(code: <span class="hljs-type"><span class="hljs-type">String</span></span>, variables: (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty, functions: (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; (<span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsed = <span class="hljs-type"><span class="hljs-type">FormulaParser</span></span>(code) parsed.left.foreach(error =&gt; println(<span class="hljs-string"><span class="hljs-string">s"\'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">\' parsing error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$error</span></span></span><span class="hljs-string">"</span></span>)) parsed.right.map(expr =&gt; <span class="hljs-type"><span class="hljs-type">Evaluator</span></span>(expr, variables, functions)).foreach(d =&gt; println(<span class="hljs-string"><span class="hljs-string">s"\'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">\' = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$d</span></span></span><span class="hljs-string">"</span></span>)) } eval(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"1."</span></span>) eval(<span class="hljs-string"><span class="hljs-string">" 1 "</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"-0.1"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"1+2"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"2-1"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"2*3"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"4/2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vars = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-string"><span class="hljs-string">"pi"</span></span> -&gt; math.<span class="hljs-type"><span class="hljs-type">Pi</span></span>, <span class="hljs-string"><span class="hljs-string">"e"</span></span> -&gt; math.<span class="hljs-type"><span class="hljs-type">E</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> funcs: (<span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; (<span class="hljs-type"><span class="hljs-type">Double</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-string"><span class="hljs-string">"sin"</span></span> -&gt; math.sin, <span class="hljs-string"><span class="hljs-string">"cos"</span></span> -&gt; math.cos, <span class="hljs-string"><span class="hljs-string">"inc"</span></span> -&gt; { d: <span class="hljs-type"><span class="hljs-type">Double</span></span> =&gt; d + <span class="hljs-number"><span class="hljs-number">1</span></span> } ) eval(<span class="hljs-string"><span class="hljs-string">"pi"</span></span>, vars) eval(<span class="hljs-string"><span class="hljs-string">"inc(e)"</span></span>, vars, funcs) eval(<span class="hljs-string"><span class="hljs-string">"2+2*2"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"1+2*(3+4*5)"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"8/2/2"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"8-1-2"</span></span>) eval(<span class="hljs-string"><span class="hljs-string">"1. + 2.0 * sin(pi / 2)"</span></span>, vars, funcs) }</code> </pre></div></div><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  For serious purposes, there are parser generators and other things. </p><br><p>  But if you want to parse something relatively simple, experiment and get instant feedback, you can use the approach described above.  There is almost no information in Russian, and there is not much in English either.  I hope the article will help someone. </p><br><p>  Useful links: </p><br><ol><li>  <a href="https://github.com/scala/scala-parser-combinators">library on github</a> </li><li>  <a href="https://enear.github.io/2016/03/31/parser-combinators/">DSL parsing example</a> </li><li>  "Programming in scala", chapter <a href="http://www.artima.com/pins1ed/combinator-parsing.html">"parser combinators"</a> </li></ol><br><p>  I put the above code on <a href="https://github.com/Kright/FormulaParser">github</a> </p><br><div class="spoiler">  <b class="spoiler_title">How to start</b> <div class="spoiler_text"><p>  The sbt build system is used.  It is enough to install it, go to the folder with the project and type in the console "sbt run" </p></div></div><br><p>  <strong>PS</strong> I still have a goal to add my interpreter of a lua-like language with chess and poetess.  I seem to have thought through the syntax of the language, then in the process of writing the parser I came across contradictions - I had to abandon a couple of poetess and replace chess with checkers, but the result still turns out to be quite interesting. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325446/">https://habr.com/ru/post/325446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325436/index.html">How we did secure telephony for Wheely, a world-wide personal driver service.</a></li>
<li><a href="../325438/index.html">Continuous delivery with Travis CI and Ansible</a></li>
<li><a href="../325440/index.html">The digest of interesting materials for the mobile # 197 developer (March 27 - April 2)</a></li>
<li><a href="../325442/index.html">‚ÄúGood external restrictions are the basis for creativity‚Äù: Oleg Chirukhin on Sberbank Technologies, Java and Novosibirsk</a></li>
<li><a href="../325444/index.html">WebRTC video chat development between iOS, Android and browser</a></li>
<li><a href="../325448/index.html">The holy family of information technology (April theses in the form of critical criticism)</a></li>
<li><a href="../325450/index.html">We set up a free build for writing and debugging programs for microcontrollers based on the ARM kernel under Windows 10</a></li>
<li><a href="../325452/index.html">PHP: Storing sessions in protected cookies</a></li>
<li><a href="../325454/index.html">Go application development: logic reuse</a></li>
<li><a href="../325456/index.html">Create a bot for Skype. Step by step through REST API and in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>