<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Isometric Sapper on LibCanvas (html5)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This topic will be different from the previous topic Classic sapper on html5 and LibCanvas . It may even be called a continuation. And the first part ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Isometric Sapper on LibCanvas (html5)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/32b/674/e21/32b674e210b7bae0afd6cb363a8e909d.gif" align="left"><br>  This topic will be different from the previous topic <a href="http://habrahabr.ru/post/168435/">Classic sapper on html5 and LibCanvas</a> .  It may even be called a continuation.  And the first part contained step-by-step and detailed instructions on how to make a toy work, then in this part there will be a couple of interesting techniques, how to ‚Äúrender‚Äù it. <br><br><h2>  <b><a href="http://libcanvas.github.com/games/isomines/">Play Isometric Minesweeper</a></b> </h2><br><br><hr>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are new to this business, you should start with the first part.  For those who want to go deep, I will consider the following topics on the example of an isometric sapper built on the basis of LibCanvas: <br><br><ul><li>  Isometric view </li><li>  Optimizing rendering speed through dirty hack </li><li>  Sprite animations </li><li>  Draggable layers </li><li>  Mouse handler optimization according to application features </li></ul><br><a name="habracut"></a><br><h4>  Lyrical digression </h4><br>  I still propose not to go into the senseless criticism a la ‚Äúclassical sapper is better‚Äù, ‚Äúgates of this form are nonsense‚Äù and ‚Äúyou have a little wrong formula there‚Äù.  The goal was to make a cute toy in a short time (about 8 hours for the full implementation of the art part and about 4 hours for the full implementation of the code at a leisurely pace in your free time).  And reveal on the basis of this toy some approaches. <br><br><h2>  Isometric view </h2><br>  Let's start with the easiest and most interesting.  Isometric games on LibCanvas are implemented by combining two tools - the <a href="https://github.com/theshock/libcanvas/tree/master/Docs/Ru/App"><code>LibCanvas.App</code></a> framework, which was described in the previous two topics and the <a href=""><code>IsometricEngine.Projection</code></a> class. <br><br>  The peculiarity of <code>IsometricEngine.Projection</code> is that it does not implement anything by itself.  It only provides a convenient and fast way to convert 3d coordinates in space to 2d isometric coordinates and back. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> projection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IsometricEngine.Projection({ <span class="hljs-attr"><span class="hljs-attr">factor</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) }); <span class="hljs-comment"><span class="hljs-comment">//   3d  2d var point2d = projection.toIsometric(new Point3D(100, 50, 10)); //   2d  3d var point3d = projection.to3d( mouse.point, 0 );</span></span></code> </pre><br>  <i>When translating from 2d coordinates, it is always unclear in which plane to count the point, therefore, in addition, you have to specify the future z-coordinate</i> <br><br>  By the way, what is this <code>factor</code> ?  In theory, the correct isometric projection is a projection with an angle of 120 ¬∞, but in practice, in toys, a projection with an angle of ~ 117 degrees is used so that the lines fall into the pixel grid. <br><br><img src="https://habrastorage.org/storage2/188/c7d/405/188c7d4052df862941f133309a955ad1.png"><br><br>  That's just the factor and allows you to set the aspect ratio.  You can choose any of the approaches: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   factor: new Point3D( 1, 0.5, 1) //   factor: new Point3D(0.866, 0.5, 0.866)</span></span></code> </pre><br><br>  I didn‚Äôt give a damn about all the rules in my application and just made the factor equal to the size of the picture, so I have the left corner of the picture in the coordinates <code>[0;0;0]</code> , and the right one in <code>[1;1;0]</code> <br><pre> <code class="javascript hljs">factor: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(<span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-number"><span class="hljs-number">52</span></span>, <span class="hljs-number"><span class="hljs-number">54</span></span>)</code> </pre><br><br><img src="https://habrastorage.org/storage2/412/d09/5f1/412d095f1c838d3274a7c76588bda163.png"><br><br>  So how did I adapt this tool to the requirements of the application?  A very simple.  Create a cell element like this, where the cell is simply drawn around the center of the shape. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @class IsoMines.Cell */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'IsoMines.Cell'</span></span>, App.Element, { <span class="hljs-attr"><span class="hljs-attr">renderTo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, resources</span></span></span><span class="hljs-function">) </span></span>{ ctx.drawImage({ <span class="hljs-attr"><span class="hljs-attr">image</span></span> : resources.get(<span class="hljs-string"><span class="hljs-string">'images'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'static-carcass'</span></span>), <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape.center }); } });</code> </pre><br><br>  And then, using the projection, I created the necessary number of cells, passing them polygons: <br><br><pre> <code class="javascript hljs">createPolygon: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.projection; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Polygon( p.toIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(point.x , point.y , <span class="hljs-number"><span class="hljs-number">0</span></span>)), p.toIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(point.x+<span class="hljs-number"><span class="hljs-number">1</span></span>, point.y , <span class="hljs-number"><span class="hljs-number">0</span></span>)), p.toIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(point.x+<span class="hljs-number"><span class="hljs-number">1</span></span>, point.y+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)), p.toIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3D(point.x , point.y+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) ); }, <span class="hljs-attr"><span class="hljs-attr">createCells</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fieldSize, x, y, point; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x = size.width; x--;) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (y = size.height; y--;) { point = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(x, y); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IsoMines.Cell(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layer, { <span class="hljs-attr"><span class="hljs-attr">point</span></span> : point, <span class="hljs-attr"><span class="hljs-attr">shape</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createPoly(point) }); }</code> </pre><br><br>  I highly recommend reading the <a href="">documentation</a> - it's quite interesting there, IMHO. <br><br>  Rendering speed optimization <br><br>  And now we will look at our application and pay attention to its feature.  The beauty is that our objects do not move relative to each other and never intersect, they just touch.  Moreover, the objects themselves are completely opaque.  Therefore, when changing, you can act very brazenly - do not erase anything, but simply draw a new cell image on top of the old one. <br><br>  To do this, firstly, you need to disable the intersection check in <code>LibCanvas.App</code> when creating a layer <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.createLayer({ <span class="hljs-attr"><span class="hljs-attr">intersection</span></span>: <span class="hljs-string"><span class="hljs-string">'manual'</span></span> });</code> </pre><br><br>  Second, override the cleanup method by making it empty: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @class IsoMines.Cell */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'IsoMines.Cell'</span></span>, App.Element, { <span class="hljs-attr"><span class="hljs-attr">clearPrevious</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} });</code> </pre><br><br>  Suppose we cannot completely abandon cleaning for some reason.  For example ... Our image has translucent areas or something like that.  As a result, you <a href="http://habrahabr.ru/qa/33297/">will encounter a problem</a> like a <a href="https://habrahabr.ru/users/kazmiruk/" class="user_link">kazmiruk</a> user: <br><br><img src="https://habrastorage.org/storage2/140/ced/cd9/140cedcd982fa1a804f49c08664f479a.jpg"><br><br>  This comes from the two ‚Äúdefaults‚Äù of <code>LibCanvas.App</code> - the boundingRectangle is considered the bounding figure (boundingShape), and it erases it precisely by it.  It is enough to override any of these behaviors (only one of them, both are meaningless): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @class IsoMines.Cell */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'IsoMines.Cell'</span></span>, App.Element, { <span class="hljs-comment"><span class="hljs-comment">//     ,    boundingRectangle get currentBoundingShape () { return this.shape; } //    , .      clearPrevious: function (ctx) { ctx.clear( this.shape ); } });</span></span></code> </pre><br><br>  In fact, this optimization can be used for all static or semi-static layers.  Do not forget that we can have several different Layers and each of them has its own behavior strategy: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layerStatic = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.createLayer({ <span class="hljs-attr"><span class="hljs-attr">intersection</span></span>: <span class="hljs-string"><span class="hljs-string">'manual'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layerDynamic = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.createLayer({ <span class="hljs-attr"><span class="hljs-attr">intersection</span></span>: <span class="hljs-string"><span class="hljs-string">'auto'</span></span> });</code> </pre><br><br><h2>  Sprite animations </h2><br><br>  The next interesting topic is how to insert and make animation work ‚Äî beautiful pictures a la gifs.  For these purposes, there is one of my favorite plugins - <a href="https://github.com/theshock/libcanvas/tree/master/Docs/Ru/Plugins/Animation">Animation</a> . <br><br>  The basic idea is that we transfer a png-file, which contains a lot of animation frames, which we then assemble into ‚Äúvideos‚Äù.  It looks something like this, but with translucency instead of squares in the background, twice as many frames and the size of each frame: <br><img src="https://habrastorage.org/storage2/d3f/ce1/804/d3fce1804d0d8eea1e526b4814d647bf.png">  . <br><br>  Creating an animation is divided into three stages: <br><br><h5>  1. Cutting frames </h5><br>  Using <a href="">Animation.Frames we</a> cut our grid image into many small pictures: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frames = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animation.Frames( image, <span class="hljs-number"><span class="hljs-number">180</span></span>, <span class="hljs-number"><span class="hljs-number">104</span></span> );</code> </pre><br><br>  You can have many different animations in one sprite.  Cutting should be done only once, and then use it for all prototypes. <br><br><h5>  2. Prototype animation </h5><br>  Using <a href="">Animation.Sheet we</a> create a general description of the animation - frame order, delay, obsession and give a link to the frames that were cut above.  Each animation prototype should occur only once per application.  For example, if you have an explosion animation that occurs many times per application, you only need to create its <code>Animation.Sheet</code> once. <br><br>  In the isometric sapper, I needed three animations - opening and closing the lock, opening and closing the doors.  They had the same settings, frames, only the name and the frame order differed, therefore I did it all short and beautifully: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animationSheets = atom.object.map({ <span class="hljs-attr"><span class="hljs-attr">opening</span></span> : atom.array.range( <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-attr"><span class="hljs-attr">closing</span></span> : atom.array.range( <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-attr"><span class="hljs-attr">locking</span></span> : atom.array.range( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>), <span class="hljs-attr"><span class="hljs-attr">unlocking</span></span>: atom.array.range( <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sequence</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animation.Sheet({ <span class="hljs-attr"><span class="hljs-attr">frames</span></span>: frames, <span class="hljs-attr"><span class="hljs-attr">delay</span></span> : <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-attr"><span class="hljs-attr">sequence</span></span>: sequence }); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animationSheets );</code> </pre><br><br><img src="https://habrastorage.org/storage2/b69/745/4fb/b697454fbbbcf3c871a68b6575d67b64.png"><br><br><h5>  3. The essence of animation </h5><br><br>  But for the immediate launch, every time at the start, an <a href="">Animation</a> object is created, where we transfer the callbacks and we can hang on to the events.  In the sapper, I organized the launch of animations by switching the state: <br><br><div class="spoiler">  <b class="spoiler_title">Animated state switching in IsoMines.Cell</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @class IsoMines.Cell */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'IsoMines.Cell'</span></span>, App.Element, { <span class="hljs-attr"><span class="hljs-attr">preStates</span></span>: { <span class="hljs-attr"><span class="hljs-attr">opened</span></span>: <span class="hljs-string"><span class="hljs-string">'opening'</span></span>, <span class="hljs-attr"><span class="hljs-attr">closed</span></span>: <span class="hljs-string"><span class="hljs-string">'unlocking'</span></span>, <span class="hljs-attr"><span class="hljs-attr">locked</span></span>: <span class="hljs-string"><span class="hljs-string">'locking'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">changeState</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.preStates[state]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animation({ <span class="hljs-attr"><span class="hljs-attr">sheet</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sheets[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state], <span class="hljs-attr"><span class="hljs-attr">onUpdate</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redraw, <span class="hljs-attr"><span class="hljs-attr">onStop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = state; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redraw(); callback &amp;&amp; callback.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }); }, <span class="hljs-attr"><span class="hljs-attr">getGatesImage</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animation &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animation.get()) || <span class="hljs-string"><span class="hljs-string">'gates-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state; }, <span class="hljs-attr"><span class="hljs-attr">renderTo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.drawImage(ctx, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getGatesImage()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.drawImage(ctx, <span class="hljs-string"><span class="hljs-string">'static-carcass'</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">drawImage</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, image</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> image == <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { image = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layer.app.resources.get(<span class="hljs-string"><span class="hljs-string">'images'</span></span>).get(image); } ctx.drawImage({ <span class="hljs-attr"><span class="hljs-attr">image</span></span> : image, <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape.center }); }, });</code> </pre><br></div></div><br><br><h2>  Draggable layers </h2><br>  Our application turned out quite large and even with a full-screen does not fit into the computer screen.  It is important for us that the user can reach any cell.  Therefore we will fasten the ‚Äúdraggable‚Äù layer.  T.K.  The left and right mouse buttons are busy with us - we will fasten the scroll by pressing and dragging the mouse wheel, and especially for the operatives we will have to make an alternative option through shift + click.  Not very convenient, but quite suitable for the demo.  I think that in full-screen mode it would be ideal to scroll if the mouse is near the borders, but this was beyond the scope of the article. <br><br>  The principle is very simple, although it is one of the few classes not covered in the documentation.  Hope to fix it soon). <br><br>  So, first we will use App.LayerShift, which allows you to move a layer along with all its elements and set frames for shifting (if we don‚Äôt want to be dragged off to infinity somewhere, and then we could not find it). <br><br>  After that we will use the built-in class <code>App.Dragger</code> , which allows dragging our layer.  In the start-up callback, we define under what conditions this drag should be started. <br><br>  Well and, depending on the mode, we will define the boundaries of the dredge - in the full screen and minimized state they will be different. <br><br><div class="spoiler">  <b class="spoiler_title">Make the layer shake</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> initDragger: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App.LayerShift(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layer); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateShiftLimit(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App.Dragger( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouse ) .addLayerShift( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift ) .start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.button == <span class="hljs-number"><span class="hljs-number">1</span></span> || e.shiftKey; }); }, <span class="hljs-attr"><span class="hljs-attr">updateShiftLimit</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> padding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift.setLimitShift(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.container.size) .move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layerSize, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .move(padding, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), padding )); },</code> </pre><br></div></div><br><br>  It is worth noting that by default the drawing is frozen during a drag.  I spotted this optimization in old toys, such as the Pharaon and Caesar 3 - when I shifted the map there - the animations stopped, and you could notice this clearly by ‚Äúleaning into the wall‚Äù.  This behavior is quite easy to change, but it will require its own heir <code>App.Dragger</code> <br><br><h2>  Mouse handler optimization </h2><br>  A topic that is affected at the very last moment of developing an application is optimization with a profiler. <br><br>  The fact is that the default handler initially works according to a rather slow algorithm, but a very universal algorithm - it checks all the shapes of the elements to see if the mouse belongs, and if it doesn‚Äôt feel at all on the sizes 5 * 5, then the professional size 30 * 16 is half a thousand elements that need to go through each mouse movement, and at a size of 100 * 100 will be <a href="http://libcanvas.lh/games/dune/">unrealistic 10,000 objects</a> .  The square growth on the face ( <br><br>  But each application has its own optimization methods - fast algorithms and caching.  To do this, MouseHandler has the opportunity to transfer its own ‚Äúsearch engine of elements‚Äù, to the constructor of which we can transfer all the necessary data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App.MouseHandler({ <span class="hljs-attr"><span class="hljs-attr">mouse</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouse, <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app, <span class="hljs-attr"><span class="hljs-attr">search</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IsoMines.FastSearch(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.projection) });</code> </pre><br><br>  In the case of our game, we will put the entire element in an indexed hash, and then search through the method <code>IsometricEngine.Projection.to3D</code> - so instead of the complexity <code>O(N</code> <sup>2</sup> <code>)</code> we get the complexity <code>O(C)</code> - the constant search speed of the element. <br><br><div class="spoiler">  <b class="spoiler_title">Quick search for the cell that was clicked</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @class IsoMines.FastSearch */</span></span> atom.declare( <span class="hljs-string"><span class="hljs-string">'IsoMines.FastSearch'</span></span>, App.ElementsMouseSearch, { <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shift, projection</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.projection = projection; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift = shift; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = {}; }, <span class="hljs-attr"><span class="hljs-attr">add</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set(cell, cell); }, <span class="hljs-attr"><span class="hljs-attr">remove</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set(cell, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells[cell.point.y + <span class="hljs-string"><span class="hljs-string">'.'</span></span> + cell.point.x] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">findByPoint</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point</span></span></span><span class="hljs-function">) </span></span>{ point = point.clone().move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift.getShift(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.projection.to3D(point), cell = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(path.y) + <span class="hljs-string"><span class="hljs-string">'.'</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(path.x)]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell ? [ cell ] : []; } });</code> </pre><br></div></div><br><br>  To check the quality of the optimization, I made a map of about 1000 elements (33x33), first turned off the quick search, drove the mouse over the field under the profiler for a long time, and then turned on the quick search and drove the mouse over the field again.  Result: <br><br>  Before: <br><img src="https://habrastorage.org/storage2/887/363/1be/8873631beb0f14039938f9a736efc9b1.png"><br><br>  After: <br><img src="https://habrastorage.org/storage2/daa/94f/147/daa94f1474c1f8f0cc48ae8f808381fd.png"><br><br>  Application load dropped from 74.4% to 3.4% - more than twenty times in such a simple way.  In my opinion, the particular advantage of this method is that it allows you to quickly prototype an application using the default algorithm and transfer the optimization to a later date. <br><br><h2>  <b><a href="http://libcanvas.github.com/games/isomines/">Play Isometric Minesweeper</a></b> </h2><br><br><h2>  P.S </h2><br>  In a couple of weeks I will be speaking on the <a href="http://frameworksdays.com/event/js-frameworks-day-2013/review/AtomJS-LibCanvas">JavaScript frameworks day</a> in Kiev with the theme ‚ÄúAtomJS and LibCanvas‚Äù.  While I haven‚Äôt decided exactly what I‚Äôm going to tell you, your opinion is interesting about the two points in this survey, thanks in advance for the answers. <br><br>  And yes, if you have questions, but for some reason you cannot ask them here on Habr√© - write to email: shocksilien@gmail.com </div><p>Source: <a href="https://habr.com/ru/post/168705/">https://habr.com/ru/post/168705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168693/index.html">Opening of the IT-club MODX in Yekaterinburg</a></li>
<li><a href="../168695/index.html">IOS 6.1.1 beta released</a></li>
<li><a href="../168697/index.html">Setting up Inkscape to work with black and white graphics</a></li>
<li><a href="../168699/index.html">How to: AD + MSSQL to SSRS</a></li>
<li><a href="../168701/index.html">Review of the ASUS Zenbook UX31A Touch Ultrabook Touch</a></li>
<li><a href="../168707/index.html">Why is Keccak so cool and why was it chosen as the new SHA-3</a></li>
<li><a href="../168709/index.html">First household appliances</a></li>
<li><a href="../168711/index.html">We measure the performance of drives or again about IOPS</a></li>
<li><a href="../168719/index.html">Change the speed on Youtube</a></li>
<li><a href="../168721/index.html">A leak. Tegra4 ChromeOS device with the code name PUPPY was found in the OS source. Android is mentioned</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>