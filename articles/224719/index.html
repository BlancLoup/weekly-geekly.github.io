<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to improve user activity segmentation. Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is known that user activity provides a variety of useful information for the search engine. In particular, it helps to understand what information ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to improve user activity segmentation. Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  It is known that user activity provides a variety of useful information for the search engine.  In particular, it helps to understand what information the user needs, to highlight his personal preferences, the context of the topic, which the user is currently interested in.  Most previous studies on this topic either considered all user actions for a fixed period of time, or divided the activity into parts (sessions) depending on a predetermined period of inactivity (timeout). <br><br>  Such approaches allow us to distinguish groups of sites that are visited with the same information need.  However, it is obvious that the quality of such a simple segmentation is limited, so better quality can be achieved using more complex algorithms.  This report is devoted to the problem of automatic separation of user activity into logical segments.  Based on the available information, we propose a method for automatically dividing their daily activities into groups based on information needs.  I will talk about several segmentation methods and give a comparative analysis of their effectiveness.  The proposed algorithms are significantly superior to the methods based on the separation depending on the timeout. <br><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://video.yandex.ru/iframe/ya-events/m-43499-1503efef208-85dc0780e59dfe10/&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhi8ElBaXjhCrPqmHoHlJ3GIvUF3Tw" width="450" height="135" frameborder="0" scrolling="no" allowfullscreen="1"></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      User activity in the browser, search engine or on a specific site is a rich source of useful information: the reformulation of requests, navigation before and after the request / visit to the portal.  Unfortunately, this information is not structured in any way and is very noisy.  The main task is the processing, structuring and cleaning of raw data.  I would suggest a method for automatically separating user activity into logically related components. <br><a name="habracut"></a><br>  The user interacts with the search engine and the browser continuously: <br><ul><li>  sets queries; </li><li>  clicks on the documents in the issue; </li><li>  requests new pages in the issue; </li><li>  moves between pages using links and browser navigation buttons; </li><li>  switches between tabs; </li><li>  scrolls the pages, leads them with the mouse; </li><li>  goes to other search engines. </li></ul><br>  It is important to learn to consider these events not only atomically, but also to connect with each other better understanding what moves the user.  One event leads another, and if we learn to link them together, we can better understand what drives the user. <br><br>  In connection with the study of user sessions, several problems arise: <br><ol><li>  defining the boundaries of logical sessions; </li><li>  predicting the next action in the session; </li><li>  retrieving session information to assist in the next step; </li><li>  simulation of user actions within one session; </li><li>  Assessment of hidden data during the session - information need, satisfaction with the session, fatigue. </li></ol><br>  Further, we will need to formulate several definitions and introduce several notation.  The protagonist of my story - a browser session - is a sequence of pages visited by the user during the day: <i>D <sub>u</sub> - (d <sub>1</sub> ....... d <sub>n</sub> )</i> .  The secondary object ‚Äî the request session ‚Äî is a sequence of user-specified queries for one day: <i>Q <sub>u</sub> - (q <sub>1</sub> ....... q <sub>n</sub> )</i> .  Vs also want to highlight the logical browser session (and the logical query session) - part of the browser session, consisting of logically related pages, visited with the same information need <i>g</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/37c/d98/d1337cd9898229e3c4bec04432f961cf.png"><br><br>  Consider an example of what a user session can be: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a5/0aa/fa6/3a50aafa61aaab5b46d3dd9ab2aa2fab.png" width="640"><br><br>  The user enters the search engine page, starts searching for information about scientific seminars, went to the page with a list of all Yandex seminars and learned that on March 28 there will be an interesting report for him and read his announcement.  Suddenly, he noticed in the announcement some unknown concept and wanted to see what it was.  It <a href="http://ecir2013.org/">follows the</a> link to the site <a href="http://ecir2013.org/">ecir2013.org</a> .  At that moment, his information need changed: at the beginning he wanted to see information about the seminars, now he became interested in the conference.  Looking at the main page of the conference, he finds another unknown concept - information retrieval.  He again goes to the search engine and enters the query [information search] there.  In the search, he finds a village page on Wikipedia, reads about it, decides that this topic is interesting to him, and returns to the Yandex portal to see where the seminar will take place, i.e.  returns to the original logical session. <br><br>  Of course, this is an artificial example, but it can be traced to some important features of logical sessions: <br><ol><li>  As a rule, logical sessions are interspersed. </li><li>  Some pages participate in several logical sessions. </li><li>  User demand is changed before the request is specified. </li></ol><br>  Let's make a small digression and see what you can understand by looking at the request sessions: what information about the user can be extracted.  Users can ask different queries on the same subject, if you can not immediately find the necessary information.  But how will they behave if the answer is not on the first page of the search results, second, third, etc.  The graph presents data for the query sessions of different lengths. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30a/038/3df/30a0383dfe3a10089de76aa32b762872.png" width="640"><br><br>  The red request session is three requests long.  It can be seen that during the session the quality of the response grows.  The user is forming increasingly good answers.  The same trend is observed in longer sessions.  No matter how long the user has not changed the wording of the request, on average, the quality of the issue improves.  The user understands how best to reformulate the query. <br><br>  As a rule, <i>D <sub>u is</sub></i> segmented on the basis of the inactivity period <i>œÑ</i> (here <i>œÑ (d)</i> is the moment of discovery <i>d</i> ).  <i>d <sub>i</sub></i> and <i>d <sub>i + 1</sub></i> belong to one session, respectively, <i>œÑ (d <sub>i + 1</sub> ) - œÑ (d <sub>i</sub> ) &lt;œÑ</i> .  This is the most popular and common approach.  But it is obvious that it does not work when sessions are interspersed with each other.  If the user returns to a topic, from the point of view of this approach, it will already be a new logical session. <br><br>  The task of logical partitioning of query sessions has already been solved in two papers: <br><br><ul><li>  <i>P. Boldi et al.</i>  The Query-flow Graph: Model and Applications. </li><li>  <i>R. Jones et al.</i>  Beyond the Session Timeout: Automatic Hierarchical Segmentation in Query Logs. </li></ul><br>  They used different methods and pursued different goals, but the authors of both works argue that their methods can significantly improve the time partition.  This motivated me to try to find an algorithm that would work better for browser sessions. <br><br>  In my research, I decided to raise a few questions: <br><ul><li>  Is it possible to clarify the logical partitioning of query sessions to the level of browser sessions? </li><li>  How qualitative is the approach based on the period of inactivity? </li><li>  How do different clustering algorithms affect the quality of segmentation? </li><li>  What sources of factors are important for logical segmentation? </li></ul><br><h4>  Method </h4><br>  Raw browser sessions ‚Äî sequences of pages visited by the user ‚Äî were used as source data.  The segmentation itself is built in two steps: <br><ol><li>  <b>Pairwise classification.</b>  We predict whether with one goal the user visited a couple of pages ( <i>d <sub>i</sub> , d <sub>j</sub></i> ): we learn the function <i>p (d <sub>i</sub> , d <sub>j</sub> ) ‚àà</i> [0; 1], estimating the probability that <i>d <sub>i</sub> , d <sub>j</sub></i> belong to one logical session. </li><li>  <b>Clustering</b>  For different estimates of <i>p (d <sub>i</sub> , d <sub>j</sub> )</i> cluster the complete graph on <i>N</i> vertices <i>d <sub>i</sub></i> with edge weights <i>p (d <sub>i</sub> , d <sub>j</sub> )</i> into strongly connected components </li></ol><br>  As a result, we get segmentation: <br><img src="https://habrastorage.org/getpro/habr/post_images/4b8/40b/75f/4b840b75f07f6ed625c00f7e591c230d.png" width="640"><br><br>  Consider each of the two steps in more detail.  Let's start with the classification.  In machine learning, it is always first of all necessary to collect a set of examples.  We have marked out with hands a fairly large set of pairs to determine whether they belong to the same logical session.  Next, for each evaluation pair ( <i>d, d '</i> ), we extract the factors. <br><img src="https://habrastorage.org/getpro/habr/post_images/478/e86/afd/478e86afddd3f3dc3b170f826147436c.png"><br>  After that we learn the classifier <i>p (d <sub>i</sub> , d <sub>j</sub> )</i> . <br><br>  As a model for the classifier, we use <i>a decision tree</i> with a logistic loss function.  It maximizes the probability of correctly classifying all pairs: <br><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f0a/3c7/9a3f0a3c74fd24007959c72a37ad42ae.png" width="640"><br>  For each pair ( <i>d, d '</i> ), we extract four types of factors (about 29 in total): <br><ol><li>  <b>URL based factors.</b> </li><li>  <b>Text factors.</b> </li><li>  <b>Sessional factors.</b>  The time between visits <i>d, d '</i> , the number of documents between them, whether the link was followed. </li><li>  <b>Context generalizations.</b>  Same as in the previous three paragraphs, only the calculation for document <i>d "</i> , preceding <i>d '</i> . </li></ol><br>  We assume that the classification has been made, and now our goal is to cluster the complete graph, find the partition maximizing the probability (the values ‚Äã‚Äãof <i>œÅ are</i> fixed, the partition changes): <br><img src="https://habrastorage.org/getpro/habr/post_images/382/1ac/b28/3821acb28a03cd60c299c07e333e589e.png" width="640"><br><br>  Œ† '- product over all pairs ( <i>d, d'</i> ) from one cluster; <br>  Œ£ is the sum over all pairs ( <i>d, d '</i> ) from different clusters; <br>  Œ† "- product over all pairs ( <i>d, d '</i> ) of all clusters. <br><br>  The statement of the problem looks good, but in this form it turns out to be NP-complete.  Those.  with a large session size, clustering will be very computationally expensive.  Therefore it is necessary to apply various greedy algorithms.  When working with greedy algorithms of this type, there is always a balance between speed, quality and area of ‚Äã‚Äãapplicability, which must be selected directly for a specific task.  I have broken all the greedy algorithms into two areas of applicability.  The first is real-time clustering: each new <i>d</i> document is added to the current cluster ( <i>g <sub>1</sub> , g <sub>2</sub> )</i> or forms a new ( <i>g <sub>new</sub></i> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/178/650/745/1786507458b6e761c20fdda7194df9b1.png" width="640"><br><br>  I used three greedy algorithms: <br><ol><li> <b>Maximum credibility of the last page.</b>  <i>d <sub>g</sub></i> - the last page of the <i>g</i> segment.  All <i>p (d <sub>g</sub> , d <sub>new</sub> )</i> &lt;1/2, therefore, we are starting a new session.  Otherwise, we add <i>d <sub>new</sub></i> to the session with the maximum probability. </li><li>  <b>Maximum credibility of all pages.</b>  All <i>p (d, d <sub>new</sub> )</i> &lt;1/2, therefore we are starting a new session.  Otherwise, we add <i>d <sub>new</sub></i> to the session containing the document with the maximum probability. </li><li>  <b>Greedy addition.</b>  Add <i>d <sub>new</sub></i> to maximize <i>Œ¶</i> growth.  If <i>Œ¶</i> always decreases for all <i>g</i> , we start a new segment. </li></ol><br>  The second type of algorithms works with all the user's daily activity at once, i.e.  performs post-clustering.  This type is <b>greedy merger</b> .  We create <i>N</i> - |  <i>D <sub>u</sub></i> |  clusters.  Greedily merge existing clusters, while it is possible to increase <i>Œ¶</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/273/3e3/4d9/2733e34d9364bfbc38d05b818244ee53.png" width="640"><br><br>  The complexity of the first algorithm is <i>O (G √ó N)</i> , where <i>G</i> is the number of segments.  All other algorithms have <i>O (N <sup>2</sup> )</i> complexity <i>.</i> <br><br><h4>  Experiments </h4><br>  Anonymized browser logs collected using the toolbar were used as raw data.  They contained the addresses of public pages, for each of which the time of the visit, the source of the visit (if the link was followed), the text of the document and the links that the user left them (if it happened) were extracted.  For the training sample, each browser session was manually divided by assessors into logical sessions.  In total, we had 220 browser logical sessions and 151 thousand pairs for classifier training: 78 thousand from one session and 73 thousand from different ones.  The average length of a logical session was 12 pages, and the average number of logical sessions per user per day was 4.4. <br><br>  The table below shows the quality of time partitioning and classifiers trained on different sets of factors: <br><table><tbody><tr><td>  A set of factors </td><td>  Temporary partition </td><td>  Everything </td><td>  Without context </td><td>  No text </td></tr><tr><td>  F-measure </td><td>  80% </td><td>  83% </td><td>  83% </td><td>  82% </td></tr><tr><td>  Accuracy </td><td>  72% </td><td>  82% </td><td>  81% </td><td>  81% </td></tr></tbody></table><br>  There is a method to calculate the contribution of each factor in the process of machine learning.  The table below shows the top 10 factors and their contribution. <br><br><table><tbody><tr><td>  Rk </td><td>  Factor </td><td>  Glasses </td></tr><tr><td>  one </td><td>  time between <i>d <sub>1</sub></i> and <i>d <sub>1</sub></i> </td><td>  one </td></tr><tr><td>  2 </td><td>  LCS </td><td>  0.58 </td></tr><tr><td>  3 </td><td>  LCS / length ( <i>url <sub>1</sub> )</i> </td><td>  0.40 </td></tr><tr><td>  four </td><td>  LCS / length ( <i>url <sub>2</sub> )</i> </td><td>  0.40 </td></tr><tr><td>  five </td><td>  # pages between <i>d <sub>1</sub></i> b <i>d <sub>1</sub></i> </td><td>  0.33 </td></tr><tr><td>  6 </td><td>  trigram URL match </td><td>  0.32 </td></tr><tr><td>  7 </td><td>  context LCS / length ( <i>url <sub>1</sub> )</i> </td><td>  0.32 </td></tr><tr><td>  eight </td><td>  one host </td><td>  0.22 </td></tr><tr><td>  9 </td><td>  LCS / length ( <i>url <sub>2</sub> )</i> </td><td>  0.20 </td></tr><tr><td>  ten </td><td>  context LCS </td><td>  0.20 </td></tr></tbody></table><br><br>  As we expected, the most important factor is the time between document visits.  It is also quite natural that the important role played by the URL and LCS (the length of the common substring URL).  Context factors play some role.  At the same time there is not a single text factor. <br><br>  We now turn to experiments in clustering.  A measure of the quality of the algorithms is based on the <a href="http://en.wikipedia.org/wiki/Rand_index"><b>Rand Index</b></a> .  For two segmentations <i>S <sub>1</sub> , S <sub>2 of the</sub></i> set <i>D <sub>u,</sub></i> it is equal to the share of equally corresponding pairs of documents: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd3/819/af5/cd3819af515c18f51f40829593e29389.png"><br><br>  Here <i>n <sub>1</sub> - # pairs from one segment <i>S <sub>1</sub> , S <sub>2</sub></i> , <i>n <sub>2</sub></i> - # pairs from different segments <i>S <sub>1</sub></i> , S <sub>2</sub></i> , <i>N</i> - # elements in <i>D <sub>u</sub></i> .  Further, <i>S <sub>1</sub></i> is an ideal segmentation, and <i>S <sub>2</sub></i> is an estimated one.  <i>R (S <sub>1</sub> , S <sub>2</sub> )</i> is the accuracy of the corresponding classifier.  The graph below shows the Rand Index for a period of <i>œÑ</i> activity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cd/242/10d/4cd24210d944792e04a3254326ec14ce.png" width="640"><br><br>  Now let's see how the algorithms described above work: <br><br><table><tbody><tr><td>  Method </td><td>  Rand index </td><td>  Complexity </td></tr><tr><td>  Temporal </td><td>  0.72 </td><td>  - </td></tr><tr><td>  Max.  credibility last  pages </td><td>  0.75 </td><td>  <i>O (N √ó G)</i> </td></tr><tr><td>  Max.  credibility of all pages </td><td>  0.79 </td><td>  <i>O (N <sub>2</sub> )</i> </td></tr><tr><td>  Greedy add </td><td>  0.82 </td><td>  <i>O (N <sub>2</sub> )</i> </td></tr><tr><td>  Greedy merger </td><td>  0.86 </td><td>  <i>O (N <sub>2</sub> )</i> </td></tr></tbody></table><br>  The quality of the classifier corresponding to the <i>greedy merge</i> (0.86) is even higher than that of the original classifier (0.82). <br><h4>  findings </h4><br><ol><li>  A method for automatic processing of browser logs is proposed, which clarifies the partitioning of query logs. </li><li>  We have reduced the segmentation problem to well studied classification and clustering problems. </li><li>  Although the temporal approach is quite good, more complex clustering algorithms significantly surpass it. </li><li>  Contextual and textual factors are much less important for determining the logical links between pages within the same session than factors based on session data and URL matches. </li></ol><br><br>  <i>The closest scientific and technical seminar in Yandex will be held on June 10th.</i>  <i>It will be devoted to the topic of <a href="http://tech.yandex.ru/events/science-seminars/msk-jun-2014/">recommender systems and distributed algorithms</a></i> . </div><p>Source: <a href="https://habr.com/ru/post/224719/">https://habr.com/ru/post/224719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224703/index.html">Express Photos: A Brief Review of Flip and Amnesia Post-Modems: A Machine for Pigs</a></li>
<li><a href="../224705/index.html">Thunderargs: practice of use. Part 1</a></li>
<li><a href="../224713/index.html">Customer experience management</a></li>
<li><a href="../224715/index.html">IOS development</a></li>
<li><a href="../224717/index.html">The earlier the departure - the less delay</a></li>
<li><a href="../224723/index.html">Million dollars for inflation theory</a></li>
<li><a href="../224727/index.html">How programmers look for differences</a></li>
<li><a href="../224731/index.html">We expand the service of building routes OSRM</a></li>
<li><a href="../224733/index.html">How to test non-public methods in .NET</a></li>
<li><a href="../224737/index.html">Training with super-human speed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>