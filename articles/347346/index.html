<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use all the features of mobile OS in React Native</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are several cross-platform solutions on the market: Cordova, Xamarin, React Native and others less well-known. Many mobile developers believe th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use all the features of mobile OS in React Native</h1><div class="post__text post__text-html js-mediator-article"><p>  There are several cross-platform solutions on the market: Cordova, Xamarin, React Native and others less well-known.  Many mobile developers believe that cross-platform solutions will never allow to do what native applications can. </p><br><p>  In the article I will debunk this myth and talk about the mechanism in React Native, which allows you to do everything that the native application is capable of.  This mechanism is native modules.  Under the cut - a detailed description of how to create native modules for Android and iOS. </p><br><p><img src="https://habrastorage.org/webt/ov/hs/4b/ovhs4b3aecjxqjev1dquvzkgwuy.gif" alt="image"></p><a name="habracut"></a><br><p>  Native modules in cross-platform development for mobile phones help to do several things: </p><br><ul><li>  Provide access to the capabilities of the platform, read from the content providers on Android or the address book on iOS </li><li>  Wrap the third-party library to call in js </li><li>  Wrap the already existing code when adding parts to the application on React Native </li><li>  Implement performance-critical parts (eg encryption) </li></ul><br><h2 id="primernaya-shema-prilozheniya-na-react-native">  Approximate scheme of the application on React Native </h2><br><p>  The operating system is running a native application.  It runs at a low level runtime React Native and the code of native modules created by the application developer (or the author of the libraries for React Native).  Above the level works React Native Bridge - an intermediate between native code and js.  Js itself is executed inside the JS VM, whose role is played by JavaScriptCore.  On iOS, it is provided by the system; on Android, the application drags it as a library. </p><br><p><img src="https://habrastorage.org/webt/9i/pb/p3/9ipbp3yqthnfcaqdcabqsccwp-q.png" alt="image"></p><br><h2 id="pishem-nativnyy-modul">  We write the native module </h2><br><h3 id="pod-android">  Under Android </h3><br><p>  The plan is: </p><br><ul><li>  Register the package with ReactNativeHost </li><li>  Create package </li><li>  Create module </li><li>  Register the module in the package </li><li>  Create method in module </li></ul><br><h3 id="liricheskoe-otstuplenie-1--komponenty-android">  Lyrical Retreat 1 - Android Components </h3><br><p>  If your main background is Android, you can skip this digression.  For developers with basic iOS or React JS experience, you need to know that an Android application may contain the following components: </p><br><ul><li>  Activity </li><li>  BroadcastReceiver </li><li>  Service </li><li>  ContentProvider </li><li>  Application </li></ul><br><p>  In this context (khe-khe), of course, we are only interested in Application.  Let me remind you that this component is the object of the application itself.  You can (and for React Native applications should) implement your application class and implement this class ReactApplication interface: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.facebook.react; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReactApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ReactNativeHost </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReactNativeHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  It is necessary for ReactNative to know about the native packages that you want to use.  To do this, our Application must return an instance of ReactNativeHost in which to list the list of packages: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), ReactApplication { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mReactNativeHost = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ReactNativeHost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPackages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;ReactPackage&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList( MainReactPackage(), NativeLoggerPackage() ) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReactNativeHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ReactNativeHost { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mReactNativeHost } }</code> </pre><br><p>  NativeLoggerPackage is the package that we will write with you.  It will only log the values ‚Äã‚Äãpassed to it, and we will focus on the process of creating a native module instead of the actual functionality. </p><br><p>  Why do I need Application to implement ReactApplication?  Because inside React Native there is such a fun code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReactActivityDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> ReactNativeHost </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReactNativeHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((ReactApplication) getPlainActivity().getApplication()) .getReactNativeHost(); } }</code> </pre><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eff/58a/737/eff58a737016b77980fec3cd718fae35.jpg" alt="image"></p><br><p>  Now we are implementing the NativeLoggerPackage: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeLoggerPackage</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReactPackage { override fun createNativeModules</span></span></span></span>(reactContext: ReactApplicationContext): List&lt;NativeModule&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList&lt;NativeModule&gt;(NativeLoggerModule()) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createViewManagers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reactContext: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReactApplicationContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;ViewManager&lt;*, *&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList&lt;ViewManager&lt;*, *&gt;&gt;() } }</code> </pre> <br><p>  We will omit the createViewManagers method, it is not important to us in this article.  And the createNativeModules method is important, which should return a list of created modules.  Modules are classes that contain methods that can be called from js.  Let's create a NativeLoggerModule: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeLoggerModule</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseJavaModule</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NativeLogger"</span></span> } }</code> </pre><br><p>  A module must inherit at least BaseJavaModule, if you do not need access to the Android context.  If there is a need for it, you must use a different base class: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeLoggerModule</span></span></span></span>(context : ReactApplicationContext) : ReactContextBaseJavaModule(context) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NativeLogger"</span></span> } }</code> </pre> <br><p>  In any case, you need to define the getName () method, which will return the name under which your module will be available in js, we will see it a little later. <br>  Now let's finally create a method for js.  This is done using the ReactMethod annotation: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeLoggerModule</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseJavaModule</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NativeLogger"</span></span> } <span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logTheObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Log.d(name, ‚ÄúMethod called‚Äù) } }</code> </pre><br><p>  Here the logTheObject method becomes available for calling from js.  But it is unlikely that we just want to call methods without parameters that do not return anything.  Let's deal with the arguments (java-types on the left, js on the right): </p><br><p>  Boolean -&gt; Bool <br>  Integer -&gt; Number <br>  Double -&gt; Number <br>  Float -&gt; Number <br>  String -&gt; String <br>  Callback -&gt; function <br>  ReadableMap -&gt; Object <br>  ReadableArray -&gt; Array </p><br><p>  Suppose we want to pass a js object to the native method.  ReadableMap will come to java: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logTheObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(map: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableMap</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = map.getString(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) Log.d(name, <span class="hljs-string"><span class="hljs-string">"key1 = "</span></span> + value) }</code> </pre><br><p>  In the case of an array, it will be passed to ReadableArray, the iteration of which is not a problem: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logTheArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = array.size() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> until size) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = array.getInt(index) Log.d(name, <span class="hljs-string"><span class="hljs-string">"array[</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$index</span></span></span><span class="hljs-string">] = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$value</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br><p>  However, if you want to pass an object to the first argument, and an array to the second, then here, too, without surprises: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logTheMapAndArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(map: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableMap</span></span></span></span><span class="hljs-function"><span class="hljs-params">, array: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { logTheObject(map) logTheArray(array) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br><p>  How is it good to call from javascript?  There is nothing easier.  The first step is to import NativeModules from the react-native root library: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NativeModules } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>;</code> </pre> <br><p>  And then import our module (remember, we called it NativeLogger?): </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NativeModules</span></span> } from <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> nativeModule = NativeModules.NativeLogger;</code> </pre> <br><p>  Now you can call the method: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NativeModules } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nativeModule = NativeModules.NativeLogger; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { nativeModule.logTheMapAndArray( { <span class="hljs-attr"><span class="hljs-attr">key1</span></span>: <span class="hljs-string"><span class="hljs-string">'value1'</span></span> }, [<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span>] ); };</code> </pre><br><p>  Works!  But wait, I want to know if everything is in order, whether it was possible to record what we wanted to record.  What about return values? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/24a/0d1/c31/24a0d1c3155873341416379fd047167c.jpg" alt="image"></p><br><p>  But there are no return values ‚Äã‚Äãfor functions from native modules.  We'll have to get out, passing the function: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logWithCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(map: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableMap</span></span></span></span><span class="hljs-function"><span class="hljs-params">, array: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ReadableArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, callback: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Callback</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { logTheObject(map) logTheArray(array) callback.invoke(<span class="hljs-string"><span class="hljs-string">"Logged"</span></span>) }</code> </pre><br><p>  Callback interface with the only method invoke (Object ... args) will come to the native code.  From the side of js, it's just a function: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NativeModules } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nativeModule = NativeModules.NativeLogger; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = nativeModule.logWithCallback( { <span class="hljs-attr"><span class="hljs-attr">key1</span></span>: <span class="hljs-string"><span class="hljs-string">'value1'</span></span> }, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], (message) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`[NativeLogger] message = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) } ); };</code> </pre><br><p>  Unfortunately, there are no tools in compile-time to verify the callback parameters from the native code and function in js, be careful. </p><br><p>  Fortunately, you can use the mechanism of promises, which in the native code are supported by the Promise interface: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ReactMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, promise: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Promise</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Log.d(name, <span class="hljs-string"><span class="hljs-string">"Logging value: "</span></span> + value) promise.resolve(<span class="hljs-string"><span class="hljs-string">"Promise done"</span></span>) }</code> </pre> <br><p>  Then you can call this code using async / await: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NativeModules } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nativeModule = NativeModules.NativeLogger; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> nativeModule.logAsync(<span class="hljs-string"><span class="hljs-string">'Logged value'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`[NativeModule] results = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">`</span></span>); };</code> </pre><br><p>  This completes the work of setting the native method in js on Android.  We look at iOS. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/68b/8a4/ea7/68b8a4ea759ad7809bf88e5bb3d3ac04.jpg" alt="image"></p><br><h1 id="sozdanie-nativnogo-modulya-v-ios">  Creating a native module in iOS </h1><br><p>  First of all, create the NativeLogger.h module: </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;React/RCTBridgeModule.h&gt;</span></span></span><span class="hljs-meta"> @interface NativeLogger : NSObject</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;RCTBridgeModule&gt;</span></span></span><span class="hljs-meta"> @end</span></span></code> </pre><br><p>  and its implementation of NativeLogger.m: </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"NativeLogger.h"</span></span></span><span class="hljs-meta"> @implementation NativeLogger { } RCT_EXPORT_MODULE();</span></span></code> </pre><br><p>  RCT_EXPORT_MODULE is a macro that registers our module with ReactNative under the name of the file in which it is declared.  If this name in js is not very suitable for you, you can change it: </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeLogger</span></span></span><span class="hljs-class"> </span></span>{ } RCT_EXPORT_MODULE(NativeLogger);</code> </pre><br><p>  Now let's implement the methods that were made for Android.  For this we need the parameters. </p><br><pre> <code class="objectivec hljs">string -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>*) number -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>*) boolean -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>*) array -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>*) object -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*) function -&gt; (RCTResponseSenderBlock)</code> </pre><br><p>  To declare the method, you can use the RCT_EXPORT_METHOD macro: </p><br><pre> <code class="objectivec hljs">RCT_EXPORT_METHOD(logTheObject:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*) map) { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *value = map[<span class="hljs-string"><span class="hljs-string">@"key1"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"[NativeModule] %@"</span></span>, value); }</code> </pre><br><pre> <code class="objectivec hljs">RCT_EXPORT_METHOD(logTheArray:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>*) array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> record <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"[NativeModule] %@"</span></span>, record); } }</code> </pre><br><pre> <code class="objectivec hljs">RCT_EXPORT_METHOD(log:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*) map withArray:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>*)array andCallback:(RCTResponseSenderBlock)block) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Got the log"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>* events = @[<span class="hljs-string"><span class="hljs-string">@"Logged"</span></span>]; block(@[[<span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> null], events]); }</code> </pre><br><p>  The most interesting thing here is the support of promises.  To do this, you will have to use another RCT_REMAP_METHOD macro, which takes the name of the method for js as the first argument and the method‚Äôs signature in objective-c as the second and subsequent arguments. <br>  Instead of an interface, two arguments are passed here, RCTPromiseResolveBlock for resoliz promise and RCTPromiseRejectBlock for reject: </p><br><pre> <code class="objectivec hljs">RCT_REMAP_METHOD(logAsync, logAsyncWith:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>*)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"[NativeModule] %@"</span></span>, value); <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>* events = @[<span class="hljs-string"><span class="hljs-string">@"Logged"</span></span>]; resolve(events); }</code> </pre><br><p>  That's all.  The mechanism for transferring events from native modules to js will be discussed in a separate article. </p><br><h2 id="nyuansy">  Nuances </h2><br><ul><li><p>  Remember that the main idea of ‚Äã‚Äãnative modules is an abstraction of the operating system for cross-platform code.  This means that the interface of the module must be agreed between Android and iOS.  Automatic means of how to control it, I unfortunately do not know. </p><br></li><li>  Remember that separately js and a nativny code work quickly.  Bridging between them is relatively slow.  You should not write js cycles in which to call the native module - move the loop to the native. </li></ul><br><h2 id="poleznye-ssylki">  useful links </h2><br><ul><li>  <a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">Official tutorial on modules</a> </li><li>  <a href="https://github.com/peggyrayzis/react-native-create-bridge">Tool for generating a boilerplate when creating a module</a> </li><li>  <a href="https://github.com/facebook/react-native/issues/10504">Githabe performance challenge for React Native Bridge</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347346/">https://habr.com/ru/post/347346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347332/index.html">We read data from the open part of KOMPAS-3D files for integration with Pilot-ICE</a></li>
<li><a href="../347338/index.html">The obvious benefit: how and why to use the service approach beyond IT</a></li>
<li><a href="../347340/index.html">Scales and barcodes: How retailers and manufacturers ended up in a deep ... puddle</a></li>
<li><a href="../347342/index.html">Navalny Headquarters IT infrastructure and signature collection: project management</a></li>
<li><a href="../347344/index.html">Features of industrial aerial photography. Part I. Preparatory rake</a></li>
<li><a href="../347348/index.html">LittleFS is a compact and economical file system for ARM microcontrollers comprising mbed os. Fast start</a></li>
<li><a href="../347350/index.html">Style Tips. How to write a readable React code</a></li>
<li><a href="../347352/index.html">Interaction of C # and C ++ cross-platform</a></li>
<li><a href="../347354/index.html">Learn OpenGL. Lesson 4.5 - Framebuffer</a></li>
<li><a href="../347358/index.html">Unit tests. Quick start - effective result (with examples in C ++)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>