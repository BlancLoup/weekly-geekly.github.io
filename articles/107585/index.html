<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CLR and .NET Myths and Misconceptions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, in popular technical forums, I often encounter violent disputes between adherents and opponents of .NET. These disputes, as a rule, begin be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CLR and .NET Myths and Misconceptions</h1><div class="post__text post__text-html js-mediator-article"> Recently, in popular technical forums, I often encounter violent disputes between adherents and opponents of .NET.  These disputes, as a rule, begin because of a misunderstanding, and end with hard trolling, talking ‚Äúfor life‚Äù and comparing the radii and specific densities of the material of different spherical horses.  Both sides try to prove and argue, but neither wants to look at the subject of the dispute with different eyes.  Habrahabr is no exception, alas. <br><br>  Religious fanatics would envy the passions of such a conversation.  The only thing that saves opponents from the crusades against each other, armed with pitchforks and LangSpecs, is that they are separated by the Internet. <br><br>  So you can not live, gentlemen.  I wanted to correct this situation, and speak on one of the sides.  With this post I will try to inflict irreparable benefits on the community and deal with myths, for discussion of which, rather than for mutual self-mutilation, unfortunately, the forces of debaters go.  And since I once climbed from C ++ to C # and everything around it, then I will debunk the negative myths, add positives and in every way embellish reality - and how without it.  And - note - it will cost completely free of charge for M $.  Well, I want to do it in the format of Q &amp; A. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>#</strong>  <strong>C # and CLR are such a VM, i.e.</strong>  <strong>interpreter, and, therefore, very slowly and sadly.</strong>  <strong>I need it to be fast, very fast!</strong> <strong><br></strong> <br>  I will not tell you here how compilation differs from interpretation.  I just want to note this: gentlemen, a recent <a href="http://habrahabr.ru/blogs/development/106264/">survey</a> on Habrahabr showed that most developers somehow use ‚Äúmanaged‚Äù languages ‚Äã‚Äãthat are not compiled into native code, but into bytecodes executed by interpreters of direct or compiling type.  Any TraceMonkey, LuaJIT, YARV are just examples for the last classification.  This means that switching to another platform of a similar architecture will certainly not make the application slower.  In this sense, nothing to worry about. <br><br>  However, the CLR is sort of virtual machine, but it is not an interpreter.  Once again I will repeat: MS.NET is NOT a BEITCODE INTERPRETER.  The special JIT compiler gradually converts the bytecode of the program into native code, about the same as that produced by the C ++ compiler.  The current CLR implementation, MS.NET and Mono, ensures that ANY code to be executed is converted to native code.  At the same time, the statement is even stronger for desktops: any code will be compiled only once.  Moreover, the fact that it is compiled ‚Äúon the fly‚Äù theoretically makes it possible to more optimally use the features of a particular processor, and therefore, to optimize the code more. <br><br>  Moreover, a comparison of absolute numbers on <a href="http://shootout.alioth.debian.org/">benchmarks</a> shows that the CLR turns out to be orders of magnitude more efficient than popular scripting languages ‚Äã‚Äãlike JavaScript and Ruby, which also use JIT technology. <br><br>  <strong>#</strong>  <strong>Languages ‚Äã‚Äãwith garbage collection are slower than languages ‚Äã‚Äãlike C ++.</strong> <strong><br></strong> <br>  True, here you are very close to the truth.  But, as well as any holivarschik, you do not finish speaking a little.  The correct phrase will be: ‚Äúa correctly written and completely manually optimized native application without errors, using special memory management techniques, will be faster than an application with automatic garbage collection‚Äù. <br>  But for more or less serious software to create such an application means a huge amount of effort.  Significantly higher than what is required for a managed language. <br>  That is why high-level languages ‚Äã‚Äãhave appeared - in the long run, on average, the code issued by the compiler will contain fewer errors and run faster than hand-written. <br><br>  And - yes - stupid numbers do not lie: memory allocation in languages ‚Äã‚Äãwith garbage collection is performed FASTER, and _not_ fragments a heap, unlike c ++.  Exception handling in managed languages ‚Äã‚Äãis also faster. <br><br>  And then there is the factor of time, and the cost of development, including the number of errors.  Because the error of damage or lost memory ... hmm ... when did I see it in the CLR the last time?  10 years ago, no less. <br><br>  <strong>#</strong>  <strong>CLR programs consume a lot of memory.</strong>  <strong>Straight in your eyes, they eat everything, leave nothing ...</strong> <strong><br></strong> <br>  Hm  A comparable loaded Ruby-on-Rails application on the server eats 100-150MB of RAM, about the same as an ASP.NET CLR site.  There is no big difference. <br>  Of course, in small scripting tasks the same Ruby is much more efficient.  But the question is not about scripting tasks - on real-life projects that bring money, the CLR's appetites look proportionate to other technologies, and I cannot agree with the definition of ‚Äúdevouring a lot‚Äù. <br><br>  <strong>#</strong>  <strong>Okay, okay, GC is good.</strong>  <strong>But the garbage collector is a very capricious animal, there is a huge amount of settings.</strong>  <strong>Nobody can correctly expose them - manual intervention only harms.</strong>  <strong>GC in my ZZZ works and so!</strong>  <strong>Himself!</strong> <strong><br></strong> <br>  By the way, the CLR has one of the best garbage collectors to date.  Its first version was written in LISPe to more clearly express the semantics of relations between objects in memory and to perform an automatic analysis of the correctness of the algorithm, and then rewritten in C ++.  Much time has passed since then, GC has been run in by millions of developers and no fewer projects.  Not flowing, that neither do! <br><br>  The settings are one <a href="http://msdn.microsoft.com/ru-ru/library/ms229357.aspx">key</a> in the gcServer = ‚Äùtrue / false‚Äù configuration file.  Includes parallel garbage collection, as well as other optimizations.  By default, it is set to false in order not to interfere with the interactive UI mode (gc is invisible for UI) on uniprocessor machines.  In CLR 4.0, new settings have appeared, but the essence is the same - it works fine out of the box, put your pliers away. <br><br>  <strong>#</strong>  <strong>And in my favorite language ZZZ there is <a href="http://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a> , and therefore I can write extensions to it in C, if I need speed.</strong>  <strong>Never, however, did not write, but so what!</strong>  <strong>After all, I can!</strong>  <strong>And what about CLR / C #, do you need to rewrite everything into a managed language?</strong> <strong><br></strong> <br>  Very happy for zzz.  You'd be surprised, but the CLR also has the ability to call functions from native dlls written in good old C. And, of course, transfer data there and get it back.  And, unlike most FFIs, you do not need to design dlls for FFIs ‚Äî use call conventions and special data types.  The CLR is omnivorous, it can be flexibly configured to eat almost any library.  Separately enabled and automated support for COM, for more convenient access to the features of Windows. <br>  This is called <a href="http://msdn.microsoft.com/en-us/library/aa288468%2528VS.71%2529.aspx">Interop / Platform Invoke</a> <br><br>  <strong>#</strong>  <strong>Okay, I can write a lot of things in C. But I will not write everything myself!</strong>  <strong>.NET does not have the necessary libraries;</strong>  <strong>and to work with the database, you need to buy MSSQL for a hundred thousand million money!</strong> <strong><br></strong> <br>  You do not need to write everything.  In .NET there is a great stdlib called BCL (Base Class Library).  There are a lot of things you need: files, sockets / network, http and web, regular expressions, SQL and data manipulation, xml and web services, etc. <br>  If you need something that is not in the BCL, most likely, such a library already exists.  Or you can use the native - so made the wrappers for OpenGL and OpenAL, bass.dll (sound) and a lot of things. <br><br>  Providers for MySQL and Oracle, SQLite and PostgresQL are written for .NET, they are stable and work fine.  Why are there SQL, there are both MongoDB and their object databases, there is a client for Memcache and RabbitMQ.  There are own ServiceBus and MessageQueue, and the API to existing systems is very simple to write. <br><br>  <strong>#</strong>  <strong>You can write for the CLR only from Visual Studio.</strong>  <strong>And only under Windows.</strong>  <strong>Both that, and that again costs money.</strong> <strong><br></strong> <br>  Not true.  There is <a href="http://www.icsharpcode.net/opensource/sd/">SharpDevelop</a> , which is good enough for a free environment;  there is <a href="http://mono-project.org/">MonoDevelop</a> , which is also good, and works both in Win and in * nix.  There are <a href="http://sourceforge.net/projects/monolipse/">plugins</a> to Eclipse;  By the way, using <a href="http://ikvm.net/">IKVM.NET</a> does not need Java to run Eclipse, one CLR is enough. <br><br>  The light version of Visual Studio Express allows you to create full-fledged applications in Win.  Free MS SQL Express will last long for most projects. <br><br>  There are tools for debugging, profiling, establishing the process of Continuous Integration, themselves written in .NET.  There are tools like make / ant - <a href="http://nant.sourceforge.net/">NAnt</a> , msbuild. <br><br>  Download @ Install! <br><br>  <strong>#</strong>  <strong>The CLR location is on the server.</strong>  <strong>And Mono is a terrible, unreliable, unreliable muck that has not grown out of MiguelDeIcaza's Labs ¬© diapers.</strong> <strong><br></strong> <br>  For sure.  On the application server and on the web server - the CLR has its own Rails (ASP.NET MVC), it has its own <a href="http://nhforge.net/">Hibernate</a> and dozens of other ORMs.  Suitable for everything.  Well, is it really scary - we all gradually creep into the web. <br><br>  On the other hand, the creators of <a href="http://unity3d.com/">Unity3D</a> do not agree with you.  This is a player that hosts the CLR environment right in your browser, and the script programs for it are written in .NET languages.  Very fast, beautiful.  3D now.  No need to wait for Flash Player with GPU support. <br><br>  By the way, did you hear that Mono applications are compiled for both iPhone and iPad (#MonoTouch)?  And the same Unity3D knows how. <br><br>  <strong>#</strong>  <strong>Using CLR makes me switch to C #, I don't want to teach it!</strong> <strong><br></strong> <br>  And absolutely not necessary.  Yes, in C #, all CLR features are most fully available, but no one forces them to use them.  CLR is not just C #, it‚Äôs a great platform and BCL, providing a quality object model and tools.  There are a huge number of languages ‚Äã‚Äã- new, such as Boo, Nemerle, F #, or previously known: Delphi, Ada, Lisp, VB, php, as the back-end using the CLR. <br>  From this point of view, CLR is similar to LLVM ‚Äî it provides low-level services, such as IL (bytecode) and JIT, garbage collection, object model, common type system, standard library, security system, etc. <br><br>  <strong>#</strong>  <strong>With # this is a bydlojazyk for a printerprise, it was stuck in the last century, and in my language ZZZ every six months there are new features!</strong> <strong><br></strong> <br>  Yes, C # is now firmly established in a low-cost sector enterprise - all due to its characteristics: it is simple enough to write, static typing and managed environment eliminates a whole class of errors inherent in scripting languages ‚Äã‚Äãor lower level languages, IDE provides access to all necessary tools in a couple of clicks, built right into IDE documentation and first-class IntelliSense. <br><br>  Because of this, C # / CLR solutions are not as expensive as in Java. <br><br>  C # respects the principle of backward compatibility, but this does not prevent the addition of new features to the language.  Already there is a parametric polymorphism (this is when the Vector), lambda functions and closures, LINQ (Language-integrated queries) appeared for the first time from all languages ‚Äã‚Äãbased on limited citation, type inference is present, a whole layer of DLR has appeared.  In version 5.0, native support for asynchronous programming appears. <br><br>  CLR / C # is not as bad as you think, and it's worth checking out.  But if you have a little C #, there is F # (Caml port) and Nemerle (a hybrid of C # and a functional language), there is even a CLR C ++ - take what you need from two worlds and combine. <br><br>  <strong>#</strong>  <strong>So, aloe, I remembered something.</strong>  <strong>What kind of cross-platform speech, when to run under Mono, I have to recompile everything.</strong>  <strong>It's the same as in the good old C, the better?</strong> <strong><br></strong> <br>  Another stupidity.  I do not know who told you, but in general, a fully managed CLR application compiled under Windows DO NOT NEED TO BE COMPOSED.  You can simply transfer to Linux with Mono installed, command mono myapp.exe, and it will start.  And vice versa also works.  I checked. <br><br>  True, the linking with libraries comes into play here.  It's like Ruby gems - if this particular gem uses native libraries, then you need to install these very native libraries.  But in general, it is full of pure Ruby gems. <br>  No magic, somehow. <br><br>  <strong>#</strong>  <strong>.NET applications use the registry.</strong>  <strong>Again, this headache with software version management, installation and removal of programs?</strong> <strong><br></strong> <br>  Not.  All managed .NET applications can be distributed using the deploy-by-copy model - copy it to the necessary folder and launch it from there.  They do not climb into the registry, do not look into the system folders. <br><br>  If you want to use a shared managed library, then a special mechanism, called GAC (Global Assembly Cache), using cryptography mechanisms, will take care of the absence of duplication, that the library you need is exactly that version that you are waiting for. <br><br>  <strong>#</strong>  <strong>But my friends are programmers ... They said that the mandatory Rectal Vibrating Tube and the instructions for its continuous wear are included in the Visual Studio IDE and C # developer kit!</strong> <strong><br></strong> <br>  OMFG O_o!  I absolutely responsibly declare: your familiar programmers have been deceived.  I would recommend that you go and help them to abandon the wearing of the self-styled probe, but I am afraid that they have already tasted and will not be able to ... But MS and CLR have nothing to do with it, right? <br><br>  <strong><u>findings</u></strong> <br><br>  Of course, I can argue.  I would be glad if someone wants to correct me or supplement it, and maybe even refute it. <br><br>  In general, I told how things are, what, I hope, caused a lot of good to my colleagues in the CLR workshop.  I hope, now there will be no stupid questions, like ‚Äúwhy C #, if there is Python, and with it GC‚Äù. <br><br>  To go in this direction in life or not - the choice is yours.  Nothing prevents to combine.  I write in .NET for food and in Ruby for the soul. </div><p>Source: <a href="https://habr.com/ru/post/107585/">https://habr.com/ru/post/107585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../107576/index.html">Personal Information (Short FAQ)</a></li>
<li><a href="../107578/index.html">Xbox 360 Kinect: demonstration of video chat with Windows users</a></li>
<li><a href="../107581/index.html">Not computers uniform</a></li>
<li><a href="../107582/index.html">Microsoft Strategy - Silverlight and HTML5</a></li>
<li><a href="../107583/index.html">Async in C # and SynchronizationContext</a></li>
<li><a href="../107586/index.html">iPhone vs. Android vs. Blackberry</a></li>
<li><a href="../107588/index.html">Search urban routes in 15 cities and 3 widgets for sites - See Kartu.ru</a></li>
<li><a href="../107589/index.html">Android-based gadgets gradually come to the fore</a></li>
<li><a href="../107590/index.html">Europe wants more control over personal information on the web</a></li>
<li><a href="../107592/index.html">Android-based gadgets gradually come to the fore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>