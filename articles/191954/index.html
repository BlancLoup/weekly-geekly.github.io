<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The first few milliseconds of an https connection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After several hours of reading reviews, Bob eagerly pushed the transition button to place an order for a gallon of whole milk, and ... 
 Wow, what jus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The first few milliseconds of an https connection</h1><div class="post__text post__text-html js-mediator-article">  After several hours of reading reviews, Bob eagerly pushed the transition button to place an order for a gallon of whole milk, and ... <br>  Wow, what just happened? <br><br><img src="https://habrastorage.org/storage3/a6f/8be/2fe/a6f8be2fe01f06da823f6cc2c52a7e4b.png"><br><a name="habracut"></a><br>  In 220 milliseconds a lot of interesting things happened, because of which Firefox changed the color of the address bar and displayed the lock in the lower right corner.  Using my favorite Wireshark tool and a slightly modified Firefox debug build, we‚Äôll try to figure out exactly what happened. <br>  By RFC 2818, Firefox knows that "https" means that you need to use port 443 to connect to Amazon.com: <br><br><img src="https://habrastorage.org/storage3/366/8d0/c13/3668d0c133366d98dae8f9760410de76.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Customer greeting </h4><br>  TLS wraps all traffic in a ‚Äúrecord‚Äù of various types.  We see that the first byte of the packet in HEX is 0x16 = 22, which means that the ‚Äúrecord‚Äù is a ‚Äúhandshake‚Äù: <br><br><img src="https://habrastorage.org/storage3/760/d11/e78/760d11e78105d9a319a9e33fb11bd0ca.png"><br><br>  The next two bytes are 0x0301, meaning version 3.1, which means that TLS 1.0 is actually SSL 3.1. <br>  A handshake entry is split into several messages.  The first is ‚Äúcustomer welcome‚Äù (0x01).  Here are some important points: <br><br><ul><li>  Accident: <br><img src="https://habrastorage.org/storage3/c71/02a/935/c7102a935d9bc847212a75a7bc59bb2f.png"><br><br>  These four bytes are the current Unix time, the number of seconds since January 1, 1970. In our case, this is 0x4a2f07ca.  They are followed by 28 random bytes, which will be needed later. </li><li>  Session ID: <br><img src="https://habrastorage.org/storage3/91e/25a/745/91e25a745d12ff884d45cd9d5e21b951.png"><br><br>  In our case, this field is empty.  If we connected to Amazon.com a few seconds earlier, we could continue the session and not hold a full handshake. </li><li>  Cipher Suites: <br><img src="https://habrastorage.org/storage3/59e/543/187/59e54318799df7612e6a894bd28de039.png"><br><br>  A list of all browser-supported encryption algorithms.  The default is a very strong TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, followed by another 33 options.  Do not worry if you do not understand anything.  Next, we learn that Amazon will not accept our default option. </li><li>  Server_name extension: <br><br><img src="https://habrastorage.org/storage3/c28/1da/a03/c281daa0346722a00accca6d87430104.png"><br>  The way to tell amazon.com is that the browser needs a page at <a href="https://www.amazon.com/">www.amazon.com</a> .  This is quite convenient, because TLS handshake starts long before HTTP traffic.  HTTP has a ‚ÄúHost‚Äù header that allows you to host hundreds of sites on the same IP.  SSL has traditionally required different IPs for different sites, but this extension allows the server to respond with a specific site certificate. </li></ul><br><h4>  Greeting server </h4><br>  Amazon.com responds with a rather large record with a two-packet handshake (2.551 bytes).  It contains the same byte sequence 0x0301, which means Amazon‚Äôs consent to use TLS 1.0.  There are three submissions with interesting data in the record: <br><br><ol><li>  Server Welcome message: <br><img src="https://habrastorage.org/storage3/bef/25e/f46/bef25ef46741dd1c63985450e54b8fa1.png"><br><br><ul><li>  Four bytes of Unix time and 28 random bytes. </li><li>  Session ID in 32 bytes to speed up the following requests. </li><li>  Of the 34 algorithms we proposed, Amazon chose TLS_RSA_WITH_RC4_128_MD5 (0x0004).  This means that the RSA algorithm will be used to verify certificate signatures and key exchange, the RC4 algorithm to encrypt data, the MD5 hash function to verify the contents.  We will discuss all of this in more detail later.  It seems to me that Amazon has its own reasons for choosing these particular algorithms, for example, reducing the load on the CPU.  A less likely option - thanks to Ron Rivest, the creator of all three of the above algorithms. </li></ul><br></li><li>  Message with certificate: <br><img src="https://habrastorage.org/storage3/8ce/e40/5be/8cee405be63b482a8f90c4ffb8aeed93.png"><br><br><ul><li>  A huge 2.464-byte message and its certificate that a client can use to validate an Amazon certificate.  All this can also be viewed in the browser. <br><img src="https://habrastorage.org/storage3/c2b/be1/f7d/c2bbe1f7d602df137f9d50c8a31b2632.png"><br></li></ul></li><li>  The message "Server greeting is completed" <br><img src="https://habrastorage.org/storage3/d73/d85/a4c/d73d85a4c4d32ea37062c5dceb6a8678.png"><br><br>  A blank message informs you that the greeting was successful and that the server will not request client certificates. </li></ol><br><h4>  Certificate Verification </h4><br>  Certificates are needed so that the browser can make sure that it communicates with Amazon.com.  It looks at the start and end dates of the certificate, and also checks whether the public key is authorized to exchange secret keys. <br><br>  Why do we have to trust certificates? <br><br>  Attached is a ‚Äúsignature‚Äù, a long number in big-endian format: <img src="https://habrastorage.org/storage3/623/bb1/203/623bb120358223296e7b74ed68ba1872.png"><br>  Anyone could send these bytes.  Why should we trust this signature?  To answer, let's take a little trip to the world of mathematics: <br><br><h4>  A little introduction to RSA </h4><br>  Some people wonder if mathematics has anything to do with programming?  Certificates - a very visual case of applying mathematics.  The Amazon certificate tells us to use RSA to verify the signature.  RSA was created in 1970 by professors MIT Ron Rivest, Adu Shamir and Len Adleman, who found a beautiful way to combine ideas that emerged over the 2000 years of mathematics and create a simple algorithm: <br><br>  You choose two prime numbers, p and q.  Multiply them and get n.  Next, you choose a simple public exponent e, which will be an encryption exponent, and a specially chosen reverse e, d, which will be decryption.  Then you make n and e public and keep d secret.  You can forget about p and q, or keep it together with d. <br><br>  Now, if you have a message, you just need to represent its bytes as the number M. If you need to encrypt the message, we calculate: <br><br>  C ‚â° M <sup>e</sup> (mod n) <br><br>  This means that you need to multiply M by itself e times.  mod n means that we take only the remainder of dividing by n.  For example, 11 AM + 3 hours = 2PM (mod 12 hours).  The recipient knows d and can perform the reverse operation to decrypt: <br><br>  C <sup>d</sup> ‚â° (M <sup>e</sup> ) d ‚â° M <sup>e * d</sup> ‚â° M <sup>1</sup> ‚â° M (mod n) <br><br>  It is also interesting that a person with d can sign a document raising the message M to the power of d: <br><br>  M <sup>d</sup> ‚â° S (mod n) <br><br>  This is possible due to the fact that the signatory makes S, M, e, and n public.  Anyone can verify the signature S using simple calculations: <br><br>  S <sup>e</sup> ‚â° (M <sup>d</sup> ) <sup>e</sup> ‚â° M <sup>d * e</sup> ‚â° M <sup>e * d</sup> ‚â° M <sup>1</sup> ‚â° M (mod n) <br><br>  Public-key cryptography is often called asymmetric, because the encryption key (in our case e) is not equal to the decryption key (d).  RSA magic works because you can calculate C ‚â° M <sup>e</sup> (mod n) fairly quickly, but it‚Äôs almost impossible to C <sup>d</sup> ‚â° M (mod n) without knowing d.  As we have seen before, d is obtained from factorization n back to p and q, which is rather difficult. <br><br><h4>  Signature verification </h4><br>  When working with RSA in real life, it is important to remember that all numbers must be __ very __ large.  How much?  Amazon's certificate is signed by VeriSign Class 3 Secure Server CA.  This means that n must be 2048 bits long, which is in decimal form: <br><br>  1890572922 9464742433 9498401781 6528521078 8629616064 3051642608 4317020197 7241822595 6075980039 8371048211 4887504542 4200635317 0422636532 2091550579 0341204005 1169453804 7325464426 0479594122 4167270607 6731441028 3698615569 9947933786 3789783838 5829991518 1037601365 0218058341 7944190228 0926880299 3425241541 4300090021 1055372661 2125414429 9349272172 5333752665 6605550620 5558450610 3253786958 8361121949 2417723618 5199653627 5260212221 0847786057 9342235500 9443918198 9038906234 1550747726 8041766919 1500918876 1961879460 3091993360 6376719337 6644159792 1249204891 7079005527 7689341573 9395596650 5484628101 0469658502 1566385762 0175231997 6268718746 7514321 <br>  (Good luck with the selection of p and q. If it works, you can generate a fake VeriSign certificate.) <br><br>  If we raise the signature S to the public e VeriSign degree, and then take the remainder of the division by the module n, then we get the decoded signature in hex: <br><br>  0001FFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF00302130 0906052B0E03021A 05000414C19F8786 871775C60EFE0542 E4C2167C830539DB <br><br>  According to the PKCS # 1 v1.5 standard, the first byte 00 in order for the encryption block converted to an integer to be smaller than the module (they still didn‚Äôt understand what kind of module - approx. Transl.).  The second byte 01 indicates that this is a private key operation.  Then a bunch of FF bytes to fill in the empty space.  It ends with byte 00, then the sequence ‚Äú30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14‚Äù, which means the use of the SHA-1 function.  The last 20 bytes are the result of SHA-1 from bytes at signedCertificate. <br><br>  Since the decoded value is correctly formatted and the last bytes correspond to what we can calculate ourselves, we can assume that someone who knows the private key ‚ÄúVeriSign Class 3 Secure Server CA‚Äù has signed it. <br><br>  You can repeat the process and verify that the VeriSign Class 3 Secure Server CA certification was signed by the VeriSign Class 3 Public Primary Certification Authority. <br><br>  But why trust him?  There are no more links in this chain of trust. <br><br><img src="https://habrastorage.org/storage3/427/d84/87d/427d8487d98ab4c062adba3a9b709ce3.png"><br><br>  The root ‚ÄúVeriSign Class 3 Public Primary Certification Authority‚Äù was signed by itself.  This certificate is embedded in Mozilla products as an unconditionally trusted certificate. <br><br><h4>  Pre-master Key </h4><br>  We checked Amazon.com and know its public encryption exponent e and module n.  Anyone listening to us can do the same.  Now we need to generate a random key that the attacker does not recognize.  This is not as simple as it may seem, because of the vulnerability of the pseudo-generator of random numbers in Netscape Navigator 1.1 SSL could be hacked in 25 seconds on the machines of that time.  If you don‚Äôt believe that real randomness is difficult, you can ask the OpenSSL maintainers in Debian. <br><br>  On Windows, for example, the pseudo-random number generation function takes data from 125 sources.  Firefox uses its result and adds a few bits of its own pseudo-random data. <br><br>  It is very important to keep the 48-byte ‚Äúpre-master key‚Äù secret, since many things are derived from it.  No wonder Firefox is so hard to find.  I had to build a debug version and set the SSLDEBUGFILE and SSLTRACE flags to see it. <br><br>  4456: SSL [131491792]: Pre-Master Secret [Len: 48] <br>  03 01 bb 7b 08 98 a7 49 de e8 e9 b8 91 52 ec 81 ... {... I ..... R ... <br>  4c c2 39 7b f6 ba 1c 0a b1 95 50 29 be 02 ad e6 L.9 {...... P) ... <br>  ad 6e 11 3f 20 c4 66 f0 64 22 57 7e e1 06 7a 3b .n.?  .fd "W ~ ..z; <br><br>  It is not completely random, the first two bytes of the TLS standard should be 03 01. <br><br>  Key exchange <br>  Now we need to transfer this secret number to Amazon.com.  Since Amazon wanted to use ‚ÄûTLS_RSA_WITH_RC4_128_MD5‚Äú, we will encrypt it with RSA.  You can use only 48 bytes of the pre-master key as a message, but according to the PKCS # 1 v1.5 standard, you need to fill in the empty space with random data and bring the packet size to 128 bytes.  So it will be more difficult to decrypt the package to the attacker. <br><br>  Finally, Firefox sends the last unencrypted message, the ‚ÄúChange Cipher Spec‚Äù entry: <br><br><img src="https://habrastorage.org/storage3/72a/a68/8e4/72aa688e4433911718924a99484fad46.png"><br><br>  This is the way Firefox tells Amazon that it is going to use the previously transmitted secret keys for the following messages. <br><br>  Master Secret Calculation <br><br>  If we did everything right, then both sides now know 48 bytes of the pre-master key.  From the Amazon side, there is a slight distrust, since the pre-master contains only client data and does not contain server data.  Fix this by calculating the master key. <br><br>  master_secret = PRF (pre_master_secret, "master secret", ClientHello.random + ServerHello.random) <br><br>  PRF is a pseudo-house function, which is defined in specifications and is quite tricky.  It uses HMAC version MD5 and SHA-1.  Half of the input is sent to each function, it turns out the result is very resistant to attacks. <br><br>  As a result, we get 48 bytes of master secret. <br><br>  4C AF 20 30 8F 4C AA C5 66 4A 02 90 F2 AC 10 00 39 DB 1D E0 1F CB E0 E0 9D D7 E6 BE 62 A4 6C 18 06 AD 79 21 DB 82 1D 53 84 DB 35 A7 1F C1 01 19 <br><br>  We generate other keys <br><br>  Now that the two sides have a master secret, by specification we can calculate all the keys needed for the session using the PRF to create a ‚Äúkey block‚Äù, from which we take the necessary data: <br><br>  key_block = PRF (SecurityParameters.master_secret, "key expansion", SecurityParameters.server_random + SecurityParameters.client_random); <br><br>  Bytes from the "key block" are needed for: <br>  client_write_MAC_secret [SecurityParameters.hash_size] <br>  server_write_MAC_secret [SecurityParameters.hash_size] <br>  client_write_key [SecurityParameters.key_material_length] <br>  server_write_key [SecurityParameters.key_material_length] <br>  client_write_IV [SecurityParameters.IV_size] <br>  server_write_IV [SecurityParameters.IV_size] <br><br>  Since we use streaming, not block encryption, we do not need initialization vectors.  However, we need two Message Authentication Code (MAC) keys for each side, each 16 bytes, since the length of the MD5 result is also 16 bytes.  In addition, RC4 uses a 16 byte key, which is also needed by both parties.  In general, we need 2 * 16 + 2 * 16 = 64 bytes from the key block <br><br>  Running PRF, we get: <br>  client_write_MAC_secret = 80 B8 F6 09 51 74 EA DB 29 28 EF 6F 9A B8 81 B0 <br>  server_write_MAC_secret = 67 7C 96 7B 70 C5 BC 62 9D 1D 1F 4A A6 79 81 61 <br>  client_write_key = 32 13 2C DD 1B 39 36 40 84 4A DE E5 6C 52 46 72 <br>  server_write_key = 58 36 C4 0D 8C 7C 74 DA 6D B7 34 0A 91 B6 8F A7 <br><br>  Get ready to be encrypted! <br><br>  The last message of the handshake sent by the client is the ‚ÄúFinal Message‚Äù.  This is a tricky message that proves that no one forged a handshake and proves that we know the key.  The client takes all the bytes from the handshake messages and adds to the buffer.  Then, 12 bytes of confirmation are calculated using the pseudo-random number generator, master key, ‚Äúclient finished‚Äù lines, and MD5 and SHA-1 from the buffer. <br><br>  verify_data = PRF (master_secret, "client finished", MD5 (handshake_messages) + SHA-1 (handshake_messages)) <br><br>  We take the result and add bytes 0x14 to the header, indicating the completion, and bytes of length 00 00 0c to show that we are sending 12 bytes.  Then, as in the future and for all encrypted messages, you need to make sure that no one forged the decrypted content.  We use MD5, or rather its HMAC version. <br><br>  HMAC_MD5 (Key, m) = MD5 ((Key ‚äï opad) ++ MD5 ((Key ‚äï ipad) ++ m) <br>  (‚äï means XOR, ++ means concatenation, "opad" is bytes "5c 5c ... 5c", and "ipad" is bytes "36 36 ... 36"). <br><br>  In general, we calculate: <br>  HMAC_MD5 (client_write_MAC_secret, seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length + TLSCompressed.fragment)); <br><br>  As you can see, we mix the request number, which protects against a specific attack with a repetition of the packet. <br>  It remains only to encrypt. <br><br><h4>  RC4 Encryption </h4><br>  The selected set of encryption algorithms tells us to use RC4.  It is so simple that you can learn it in a couple of minutes. <br><br>  RC4 begins by creating a 256-byte array S and filling it with values ‚Äã‚Äãfrom 0 to 255. Then you need to go through the array ‚Äúinterfering‚Äù the key bytes.  This is done to create the state machine used to generate random bytes.  Then we shuffle the array S. <br><br>  Graphically, this can be represented as: <br><br><img src="https://habrastorage.org/storage3/841/04b/381/84104b381aebcda2880296925ab1b7f5.png"><br><br>  To encrypt a byte, we XOR a pseudo-random byte with a byte that needs to be encrypted. <br>  So, everything is pretty simple, and works fast.  It seems to me that because of this, Amazon chose this algorithm. <br><br>  Recall that we have ‚Äûclient_write_key‚Äú and ‚Äûserver_write_key‚Äú.  This means that we need two copies of RC4: one to decrypt the answers, the other to encrypt requests. <br><br>  The first few random bytes from client_write are 7E 20 7A 4D FE FB 78 A7 33 ....  If you look at these bytes with an unencrypted header and check the message bytes ‚Äú14 00 00 0C 98 F0 AE CB C4 ...‚Äù, you will see what can be seen in the Wireshark screenshot below: <br><br><img src="https://habrastorage.org/storage3/f86/7bc/99c/f867bc99ccb32a289bd874d9347b1eb8.png"><br><br>  The server does almost the same thing.  It sends a "Change Cipher Spec" and then a "final" message, which includes all the handshake messages and the unencrypted "final" message.  This proves to the client that the server was able to decrypt its messages. <br><br><h4>  Welcome to the application layer! </h4><br>  Now, after 220 milliseconds (three hours later - approx. Transl.), We are finally ready to use the application layer.  Now you can exchange regular HTTP traffic that will be encrypted with TLS using RC4 and checked for cases of spoofing. <br><br>  Now the handshake is complete.  The contents of the TLS entry are now 0x17.  Encrypted traffic starts from 17 03 01, which indicates the type of recording and the TLS version. <br><br>  Encryption package: <br><br>  GET /gp/cart/view.html/ref=pd_luc_mri HTTP / 1.1 <br>  Host: <a href="http://www.amazon.com/">www.amazon.com</a> <br>  User-Agent: Mozilla / 5.0 (Windows; U; Windows NT 6.0; en-US; rv: 1.9.0.10) Gecko / 2009060911 Minefield / 3.0.10 (.NET CLR 3.5.30729) <br>  Accept: text / html, application / xhtml + xml, application / xml; q = 0.9, * / *; q = 0.8 <br>  Accept-Language: en-us, en; q = 0.5 <br>  Accept-Encoding: gzip, deflate <br>  Accept-Charset: ISO-8859-1, utf-8; q = 0.7, *; q = 0.7 <br>  Keep-Alive: 300 <br>  Connection: keep-alive <br>  ... <br><br>  will give approximately the following result: <br><br><img src="https://habrastorage.org/storage3/6b5/85d/737/6b585d737ae365a007a8a5639e927ce5.png"><br><br>  The server does the same.  Decryption gives us the following: <br><br><img src="https://habrastorage.org/storage3/797/e72/3cc/797e723cc15e1407c2e3427b7f1076bc.png"><br><br>  HTTP / 1.1 200 OK <br>  Date: Wed, 10 Jun 2009 01:09:30 GMT <br>  Server: Server <br>  ... <br>  Conection: close <br>  Transfer-Encoding: chunked <br><br>  The connection remains open until either side sends a message warning of the termination and then closes the connection.  If we reconnect shortly after closing the previous connection, we can use the old keys in order not to re-perform the handshake procedure. <br><br>  It is important to understand that at the application level there can be absolutely anything.  There are many other TCP / IP based protocols that can run on top of TLS.  For example, FTPS.  It is always better to use TLS instead of inventing your bike. <br><br><h4>  That's all! </h4><br>  TLS RFC covers many details that we have not discussed.  We only looked at a 220 millisecond dance between Firefox and Amazon.  We learned that if someone decomposes the number n of Amazon into p and q, then he can decrypt all Amazon traffic until he changes the certificate. <br><br>  In just 220 milliseconds, two points on the Internet connected, provided each other with enough data for trust, set up encryption algorithms, and began to exchange encrypted traffic. <br><br>  And all so that Bob could buy milk. </div><p>Source: <a href="https://habr.com/ru/post/191954/">https://habr.com/ru/post/191954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191942/index.html">China will launch its "moonwalker" by the end of the year</a></li>
<li><a href="../191946/index.html">XAP (Shitty Architecture Ruins)</a></li>
<li><a href="../191948/index.html">Mobile applications and media decomposition</a></li>
<li><a href="../191950/index.html">Ahead of the mass market for 20-30 years</a></li>
<li><a href="../191952/index.html">Switch from bootstrap 2 to bootstrap 3</a></li>
<li><a href="../191958/index.html">Xperia Z Ultra - Coming Soon!</a></li>
<li><a href="../191962/index.html">Storage and High Availability in Windows Server 2012 R2</a></li>
<li><a href="../191964/index.html">Axure 7 is out in the open beta</a></li>
<li><a href="../191966/index.html">Ubuntu Edge: Campaign Lessons</a></li>
<li><a href="../191968/index.html">Measuring the quality of the mobile Internet: where we are sharing a container of pink Samsung Galaxy S II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>