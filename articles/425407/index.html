<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Firecore - a fun AVR game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share another evening protracted, which shows that you can make games even on weak iron. 

 That it was necessary to do that as it was decid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Firecore - a fun AVR game</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  I want to share another evening protracted, which shows that you can make games even on weak iron. <br><br>  That it was necessary to do that as it was decided and how to make something bigger, than the next clone of Pong - welcome under kat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Caution: great article, traffic and multiple code inserts! <br><a name="habracut"></a><br><h3>  Briefly about the game </h3><hr>  Shoot`em up!  Now on AVR. <br><br>  In fact, this is another shmap, so once again, the main character <s>Shepard</s> must save the galaxy from a sudden attack of who knows how, making his way through space through stars and asteroid fields while clearing each star system. <br>  The whole game is written in C and C ++ without using the Wire library from Arduino. <br><br>  The game has 4 ships to choose from (the latter is available after passing), each with its own characteristics: <br><ul><li>  maneuverability; </li><li>  strength; </li><li>  power of guns. </li></ul><br>  Also implemented: <br><ul><li>  color 2D graphics; </li><li>  power up for weapons; </li><li>  bosses at the end of levels; </li><li>  levels with asteroids (and their rotation animation); </li><li>  changing the background color at the levels (and not just black space); </li><li>  the movement of stars in the background with different speeds (for the effect of depth); </li><li>  scoring and saving in the EEPROM; </li><li>  identical sounds (shots, explosions, etc.); </li><li>  a sea of ‚Äã‚Äãidentical opponents. </li></ul><br><h3>  Platform </h3><hr>  The return of the ghost. <br><br><blockquote>  I will clarify in advance that this platform should be perceived as an old gaming console of the <s>first</s> third generation (80th year, <a href="https://habr.com/users/shiru8bit/" class="user_link">shiru8bit</a> ). <br></blockquote><br>  Also, hardware modifications over the original hardware are prohibited, which guarantees the launch on any other identical motherboard immediately out of the box. <br>  This game was written under the Arduino Esplora fee, but I think the transfer to GBA or any other platform will not be difficult. <br>  Nevertheless, even on this resource, this board was covered only a couple of times, and the other boards were not at all honored to be mentioned, despite the rather large community of each: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  makerbuino; </li><li>  Arduboy; </li><li>  UzeBox / FuzeBox; </li><li>  and many others. </li></ul><br>  To begin with, what is not on Esplora: <br><ul><li>  a lot of memory (ROM 28kb, RAM 2,5kb); </li><li>  power (8 bits of CPU at 16 MHz); </li><li>  DMA; </li><li>  character generator; </li><li>  allocated memory areas or special registers.  appointments (palette, tiles, background, etc.); </li><li>  control the brightness of the screen (oh, so many effects in the trash); </li><li>  address space expanders (mappers); </li><li>  debugger ( <s>who needs it when there is a whole screen!</s> ). </li></ul><br>  I will continue with the fact that there is: <br><ul><li>  hardware SPI (can work at F_CPU / 2 speed); </li><li>  screen based on ST7735 160x128 1,44 ‚Äú; </li><li>  pinch timers (only 4 pcs.); </li><li>  pinch GPIO; </li><li>  a handful of buttons (5pcs. + two-axis joystick); </li><li>  some sensors (lighting, accelerometer, thermometer); </li><li>  <s>emitter</s> piezo buzzer. </li></ul><br>  As you can see there is almost nothing.  No wonder no one wanted to do anything with her except Pong clone and a pair of three games for all this time! <br>  Perhaps the fact is that writing under the ATmega32u4 controller (and similar ones) is similar to programming under Intel 8051 (which at the time of publication is almost 40 years old), where you have to comply with a huge number of conditions and resort to various tricks and tricks. <br><br><h3>  Peripheral processing </h3><hr>  One for all! <br><br>  Looking at the circuit, it was clearly visible that all peripherals are connected via a GPIO expander (multiplexer 74HC4067D, MUX) and switched using GPIO PF4, PF5, PF6, PF7 or PORTF nibble, and the output of the MUX output occurs on GPIO - PF1. <br>  It is very convenient to switch the input, simply assigning the values ‚Äã‚Äãto the PORTF port by mask and in no case forgetting the younger nibble: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Poll button press: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  Further values ‚Äã‚Äãfor port F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  Adding a little more: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  You can safely ask the right crossbar: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Please note that the previous state is not reset, otherwise you can miss the fact of pressing the key (it also works as an additional protection against bounce). <br><br><h3>  SFX </h3><hr>  Buzz bit. <br><br>  What if there is no DAC, no Yamaha chip, but only a 1-bit PWM rectangle for sound? <br>  At first, it seems not so much, but, despite this, it uses sly PWM to recreate the technology "PDM audio" and with its help you can do <a href="https://www.youtube.com/watch%3Fv%3DzfegDlcUwJU">this.</a> <br><br>  Something similar is provided by the Gamebuino library and all that is needed is to transfer the pop-up generator to another GPIO and timer to Esplora (timer4 and OCR4D output).  Also for correct operation, timer1 is also used to form interrupts and reset the OCR4D register with new data. <br><br>  The Gamebuino engine uses sound patterns (as in tracker music), which saves space pretty well, but you need to make all the samples yourself, there are no libraries with ready ones. <br>  It is worth mentioning that this engine is tied to the update period of about 1/50 s or 20 frames / s. <br><br>  To create sound patterns, after reading the Wiki on audio format, sketched a simple GUI on Qt.  It does not output the sound exactly the same, but gives a rough idea of ‚Äã‚Äãhow the pattern will sound and allows you to load, save and edit it. <br><br><h3>  Graphics </h3><hr>  Immortal Pixelart. <br><br>  The display encodes colors in two bytes (RGB565), but since the images in this format will take a lot, all of them are made indexed on the palette to save space, which I have already described more than once in my earlier articles. <br>  Unlike Famicom / NES, there are no restrictions on colors on the image and there are no more available colors in the palette. <br><br>  Each image in the game is an array of bytes in which the following data is stored: <br><ul><li>  width height; </li><li>  data start marker; </li><li>  dictionary (if there is, but more on that later); </li><li>  payload; </li><li>  data end marker </li></ul><br>  For example, this picture (increased 10 times): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  in the code it will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  Where do without choosing a ship in this genre?  After hundreds of test sketches with a pixel difference, only these ships for the player remained: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  It is noteworthy that the ships do not have a flame in the tiles (here it is for clarity), it is superimposed separately to create animation of the exhaust from the engine. <br><br>  Do not forget about the pilots of each of the ships: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  The variation of the enemy ships is not too big, but I remind you that there is not too much space, so here are three ships: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Without canonical bonuses in the form of improving weapons and restoring health, a player will not last long: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  It goes without saying that with the increase in the power of the guns, the form of the emitted shells changes <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  As it was written at the beginning, there is a level with asteroids in the game, it comes after every second boss.  It is interesting because there are many moving and rotating objects of different sizes.  In addition, when a player hits them, they are partially destroyed, becoming smaller in size. <br><blockquote>  Hint: Large asteroids bring more points. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  To create this simple animation, 12 small images are enough: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  They are divided into three for each size (large, medium and small) and for each angle of rotation you need 4 more rotated 0, 90, 180 and 270 degrees.  In the game, it is enough to replace the pointer to the array with the image at an equal interval, thereby creating the illusion of rotation. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  This is done so only because of the lack of hardware capabilities, and software implementation like the Affine transformation will take more than the images themselves and will be very slow. <br><br><div class="spoiler">  <b class="spoiler_title">A piece of atlas for those who are interested.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  You can see some of the prototypes and what appears only in the credits after passing the game. <br></div></div><br>  In addition to simple graphics, to save space and add a retro effect, small glyphs and all glyphs were thrown out of the font, which is up to 30 and after 127 bytes of ASCII. <br><blockquote>  Important! <br>  Do not forget that const and constexpr on AVR does not mean at all that the data will be in the program memory, here for this you need to additionally use PROGMEM. <br>  This is due to the fact that the AVR core is based on the Harvard architecture, so for accessing the data you need special opcodes for the CPU. <br></blockquote><br><h3>  Squeezing the galaxy </h3><hr>  The easiest way to pack is RLE. <br><br>  After examining the packed data, you can see that the most significant bit in the byte of the payload in the range from 0x00 to 0x50 is not used.  This allows you to add the data and the start-repeat bit marker (0x80), and the next byte to indicate the number of repetitions, which allows you to pack a series of 257 (+2 from the fact that the RLE of two bytes is stupid) identical bytes just two. <br>  Unpacker implementation and screen output: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  The main thing is not to display the image abroad of the screen, otherwise there will be garbage, since there are no border checks here. <br>  The test image is unpacked for ~ 39ms.  at the same time, occupying 3040 bytes, while without compression it would take 11,200 bytes or 22,400 bytes without indexing. <br><br>  Test image (2 times magnified): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  In the image above, interlace can be seen, but on the screen it is smoothed by hardware, creating an effect similar to CRT and at the same time significantly increasing the compression ratio. <br><br><h3>  RLE is not a panacea </h3><hr>  We are treated for deja vu. <br><br>  As is well known, RLE is perfectly combined with LZ-like packers.  WiKi came to the rescue with a list of compression methods.  The video from GameHut about the analysis of the impossible <a href="https://www.youtube.com/watch%3Fv%3DIehwV2K60r8">intro in Sonic 3D Blast</a> became a push <a href="https://www.youtube.com/watch%3Fv%3DIehwV2K60r8">.</a> <br>  After examining many packers (LZ77, LZW, LZSS, LZO, RNC, etc.) I came to the conclusion that their unpackers: <br><ul><li>  require a lot of RAM for unpacked data (at least 64kb. and more); </li><li>  cumbersome and slow (some need to build Huffman trees on each subblock); </li><li>  have a low compression ratio with a small window (very strict RAM requirements); </li><li>  have ambiguities with licensing. </li></ul><br>  After months of vain adaptations, it was decided to modify the existing packer. <br>  By analogy with LZ-like packers, vocabulary access was used to achieve maximum compression, but at the byte level, the most frequently repeated pairs of bytes are replaced with one byte pointer in the dictionary. <br>  But there is a catch here, how to distinguish a byte ‚Äúhow many repetitions‚Äù from a ‚Äúdictionary marker‚Äù? <br>  After a long sitting with a piece of paper and a magical game with bats, this appeared: <br><blockquote><ul><li>  ‚ÄúDictionary marker‚Äù is a marker RLE (0x80) + data byte (0x50) + position number in the dictionary; </li><li>  limit the byte ‚Äúhow many repetitions‚Äù to the size ‚Äúdictionary marker‚Äù - 1 (0xCF); </li><li>  the dictionary cannot use the value 0xff (it is for the end of image marker). </li></ul><br></blockquote><br>  Applying all this, we get a fixed size of the dictionary: no more than 46 pairs of bytes and an abbreviation of RLE to 209 bytes.  Obviously, not all images can be packaged this way, but they will not come again. <br>  In both algorithms, the structure of the packed image will be as follows: <br><ul><li>  1 byte for width and height; </li><li>  1 byte for the size of the dictionary, it is also a marker of the beginning of the packed data; </li><li>  from 0 to 92 bytes of the dictionary; </li><li>  1 to N bytes of packed data. </li></ul><br>  The received packer utility for D (pickoPacker) is enough to put in the folder with the indexed * .png files and run from the terminal (or cmd).  If you need help, run with the key "-h" or "--help". <br>  After the utility is working, the output is * .h files, the contents of which are conveniently moved to the right place in the project (therefore, there is no protection included). <br><br>  Before unpacking, the screen, the dictionary and the reading of the initial data are prepared: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  The read piece of data can be packed with a dictionary, so check and unpack: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Now from the received buffer we unpack the RLE in a familiar way and display it on the screen: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  The replacement of the algorithm surprisingly did not significantly affect the unpacking time and is ~ 47ms.  This is almost 8ms.  longer, but the test image takes only 1650 bytes! <br><br><h3>  Until the last measure </h3><hr>  Almost everything can be done faster! <br><br>  Despite the presence of a hardware SPI, the AVR core delivers a lot of headaches when using it. <br>  It has been known for a long time that SPI on AVR, besides the fact that it operates at F_CPU / 2 speed, also has a data register of only 1 byte (there is no possibility to load 2 bytes at once). <br>  Moreover, almost all the SPI code on AVR that I met works according to this scheme: <br><ul><li>  upload SPDR data; </li><li>  loop through the SPIF bits in SPSR. </li></ul><br>  As you can see, the continuous submission of data, as is done on the STM32, does not smell here.  But even here you can speed up the output of both unpackers to ~ 3ms! <br><br>  Having opened the datasheet and looking at the ‚ÄúInstruction set clocks‚Äù section, you can calculate the CPU costs for transmitting a byte via SPI: <br><ul><li>  1 clock for register loading with new data; </li><li>  2 clocks per bit (or 16 clocks per byte); </li><li>  1 tact per clock line magic (a bit later on ‚ÄúNOP‚Äù); </li><li>  1 clock to check the status bit in SPSR (or 2 clock on the branch); </li></ul><br>  Total for transfer of one pixel (two bytes) it is necessary to spend 38 clock periods or ~ 425600 clock cycles for a test image (11200 bytes). <br>  Knowing that F_CPU == 16 MHz, we get <s>0.0000000625</s> 62.5 nanoseconds per cycle ( <a href="https://habr.com/users/process0169/" class="user_link">Process0169</a> ), by multiplying the values, we get ~ 26 milliseconds.  The question arises: ‚ÄúWhere did I write earlier then that the unpacking time was 39ms.  and 47ms?  It's simple - the logic of the unpacker + interrupt handling. <br><br>  Here is an example of output with interrupts: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  and without interruption: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  The graphs show that the time between the setting of the address window in the VRAM screen and the start of data transfer in the non-interrupt version is less and there are almost no gaps between the bytes during transmission (the schedule is uniform). <br>  Unfortunately, it is impossible to disable interrupts at each output of images, otherwise the sound and the core of the whole game will break down (more on that later). <br><br>  Above it was written about a certain "magic NOP" for the clock line.  The fact is that in order to stabilize the CLK and set the SPIF flag, exactly 1 clock cycle is needed and by the time this flag is read, it is already set, which allows avoiding a 2-clock branch on the ‚ÄúBREQ‚Äù instruction. <br>  Here is an example without a NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  and with him: <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  The difference seems insignificant, only a few microseconds, but if you take a different scale: <br>  Without NOP large: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  and with him too big: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  then the difference becomes much more noticeable, reaching ~ 4.3 ms. <br><br>  Now do the following dirty trick: <br><blockquote>  Swap the order of loading and reading registers and you can not wait on every second byte of the SPIF flag, but check it only before loading the first byte of the next pixel. <br></blockquote><br>  Apply knowledge and expand the function "pushColorFast (repeatColor);": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  Despite the interruption from the timer, using the above trick gives a gain of almost 6ms: <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  This is how simple knowledge of iron allows you to squeeze a little more out of it and display something like this: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Coliseum of collisions </h3><hr>  Battle of the boxes. <br><br>  To begin with, the whole set of objects (ships, projectiles, asteroids, bonuses) are structures (sprites) with parameters: <br><ul><li>  current coordinates X, Y; </li><li>  new coordinates X, Y; </li><li>  pointer to the image. </li></ul><br>  Since the image stores the width and height, there is no need to duplicate these parameters, moreover, such an organization simplifies the logic in many aspects. <br><br>  The calculation itself is done to a banal simple - based on the intersection of the rectangles.  Although it is not accurate enough and does not calculate collisions in the future, but this is more than enough. <br>  The check occurs alternately along the X and Y axes. Due to this, the absence of an intersection along the X axis reduces the calculation of the collision. <br><blockquote>  First, the right side of the first rectangle with the left side of the second rectangle is checked for the common part of the X axis. If successful, a similar check is made for the left side of the first and right side of the second rectangle. <br>  After successful detection of intersections along the X axis, the same procedure is checked for the upper and lower sides of the rectangles along the Y axis. <br></blockquote><br>  Writing the above looks much easier than it seems: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  It remains to add this to the game: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Bezier curve </h3><hr>  Space rails. <br><br>  As in any other game with this genre, enemy ships are required to move along curves. <br>  It was decided to implement the quadratic curves as the simplest for the controller and this task.  For them, three points are enough: the initial (P0), final (P2) and imaginary (P1) points.  The first two set the beginning and end of the line, the last point describes the type of curvature. <br>  <a href="https://habr.com/post/344814/">Excellent article on the curves.</a> <br>  Since this is a parametric Bezier curve, it also needs another parameter ‚Äî the number of intermediate points between the start and end points. <br><br>  Total we get the following structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  In it, position_t is a structure of two bytes of X and Y coordinates. <br>  Finding a point for each coordinate is calculated by the following formula (thx Wiki): <br>  B = ((1.0 - t) ^ 2) P0 + 2t (1.0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br>  For a long time, its implementation was resolved head-on without fixed point math: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Of course it can not be left.  After all, getting rid of float could not only give an improvement in speed, but also release the ROM, so the following implementations were found: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  The first one remains a dark horse, since it is a compiled library and I didn‚Äôt want to mess around with the disassembler. <br><br>  The second candidate from the GCC kit also didn‚Äôt work out, as the avr-gcc used is not patched and the type ‚Äúshort _Accum‚Äù remains unavailable. <br><br>  The third option, despite the fact that it has a large number of mat.  functions, has hard-bit bit operations on specific bits under the Q16.16 format, which makes it impossible to control the values ‚Äã‚Äãof Q and I. <br><br>  The latter can be considered a simplified version of ‚Äúfixedmath‚Äù, but the main advantage is the ability to control not only the size of the variable, which by default is 32bit with Q24.8 format, but also the values ‚Äã‚Äãof Q and I. <br><br>  Test results for different settings: <br><table><tbody><tr><th>  Type of </th><th>  Iq </th><th>  Additional flags </th><th>  ROM byte </th><th>  Tms. * </th></tr><tr><td>  float </td><td>  - </td><td>  - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24.8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9.7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * The check was carried out on a pattern: "195,175,145,110,170,70,170" and the key "-Os". <br><br>  The table shows that both libraries took up more ROM and showed themselves worse than the compiled code from GCC when using float. <br>  It is also clear that a slight refinement for the Q9.7 format and reducing the variable to 16bit resulted in an acceleration of 4 ms.  and freeing ROM at ~ 50 bytes. <br><br>  The expected effect was a decrease in accuracy and an increase in the number of errors: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  which in this case is uncritical. <br><br><h3>  Allocating resources </h3><hr>  Work on Tuesday and Thursday just an hour. <br><br>  In most cases, all calculations are performed every frame, which is not always justified, since the frame may not have enough time to calculate something and will have to be tricky with alternating, counting frames or skipping them.  Therefore, I went further - completely abandoned the personnel binding. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having broken everything into small tasks, be it: collision counting, sound processing, buttons and graphics output, it‚Äôs enough to perform them at a certain interval, and the inertia of the eye and the ability to update only part of the screen will do its job. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We never manage all of this, but the state machine I created a couple of years ago, or, to put it simply, the tinySM task manager, not displacing the task manager. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will repeat the reasons for using it instead of any of the RTOS:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lower ROM requirements (~ 250 bytes core); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lower requirements for RAM (~ 9 bytes per task); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple and clear working principle; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determinism of behavior; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spends less CPU time; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leaves access to the gland; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> platform independent; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> written in C and easy to wrap in C ++; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needed my own bike.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have already described once, tasks for it are organized into an array of pointers to structures, where the pointer to the function and its call interval are stored. </font><font style="vertical-align: inherit;">This grouping simplifies the description of the game in separate stages, which also allows you to reduce the number of branches and dynamically switch a set of tasks. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, during the start-up screen 7 tasks are performed, and during the game there are already 20 of them (all tasks are described in the gameTasks.c file). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First you need to define some macros for convenience:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The declaration of the task is actually the creation of the structure, the initialization of its fields and the placement in the ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each such structure occupies 4 bytes of ROM (two per pointer and two per interval). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A nice bonus of macros is that it will not work to create more than one unique structure for each function. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having declared the necessary tasks, we add them to the array and also put them in the ROM:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When setting the USE_DYNAMIC_MEM flag to 0 for static memory, the main thing is to remember to initialize the pointers to the task repository in RAM and set the maximum number to be executed: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setting tasks to perform: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protection against storage overflow is controlled by the USE_MEM_PANIC flag, if you are sure of the number of tasks, you can disable it to save ROM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains only to start the handler:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside is an infinite loop that contains the main logic. Falling into it, the stack is also restored thanks to "__attribute__ ((noreturn))". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the loop, the elements of the array are alternately searched for the need to call the task after the interval expires. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The intervals are calculated on the basis of timer0 as a system one with a 1ms quantum ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the successful distribution of tasks over time, sometimes they were superimposed (jitter), which caused short-term fades of everything and everyone in the game. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitely it needed to be addressed, but how? About how everything was profiled the next time, but for now try to find easter eggs in the source code.</font></font><br><br><h3>  the end </h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how using many tricks (and many more that I have not described) and it turned out to fit everything into 24kb ROM and 1500 bytes of RAM. </font><font style="vertical-align: inherit;">If you have questions, I will be glad to answer them.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those who did not find or did not look for Easter eggs:</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dig to the side: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nothing remarkable, right? </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raaaaazvnata macro invadersMagicRespawn:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   ¬´(void)¬ª    ,  ¬´action()¬ª          10 ,    ¬´disablePause();¬ª.               ¬´Matrix Falling code¬ª    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To build and run, just put the folder (or make a link) ‚ÄúesploraAPI‚Äù in ‚Äú/ arduino / libraries /‚Äù. </font></font><br><br>  References: <br><ul><li> <a href="https://github.com/Bismuth208/Firecore"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a game;</font></font></a> </li><li> <a href="https://github.com/Bismuth208/Esplora-API"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://github.com/Bismuth208/Pico-Packer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickoPacker;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS See and hear how it all looks can be a little later when I make an acceptable video. </font></font></div><p>Source: <a href="https://habr.com/ru/post/425407/">https://habr.com/ru/post/425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425395/index.html">10 physical facts that you should have learned in school, but may not have learned</a></li>
<li><a href="../425397/index.html">10 libraries every Android developer should know about</a></li>
<li><a href="../425401/index.html">Rome Club Report 2018, Chapter 1.11: ‚ÄúDisruptive Technologies and the Digital Revolution‚Äù</a></li>
<li><a href="../425403/index.html">Craigslist creator finances: site against fake news, discrimination and inflection of Internet giants</a></li>
<li><a href="../425405/index.html">Great power newtypes</a></li>
<li><a href="../425409/index.html">DevBoy: make a signal generator</a></li>
<li><a href="../425411/index.html">Scrum is dead</a></li>
<li><a href="../425413/index.html">Are the junas good?</a></li>
<li><a href="../425415/index.html">Perl 5: as in macros, errors were hidden</a></li>
<li><a href="../425417/index.html">Flash for everyone. All Flash array from QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>