<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Lisp became a programming language for God</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When programmers discuss the advantages of these or other programming languages, they often argue about them in prose terms as tools in a set of vario...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Lisp became a programming language for God</h1><div class="post__text post__text-html js-mediator-article">  When programmers discuss the advantages of these or other programming languages, they often argue about them in prose terms as tools in a set of various devices ‚Äî one more suitable for system programming, the other for pasting other programs to solve the current problem.  It should be so.  Languages ‚Äã‚Äãhave different strengths, and to declare that one language is better than other languages, without specifying concrete examples, means only to cause unproductive and sharp disputes. <br><br>  However, there is one language that strangely commands universal respect: <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">Lisp</a> .  Crusaders of keyboards, ready to attack anyone who dares to say that any language is better than others, agree that Lisp is on a different level.  It goes beyond the utilitarian criteria that other languages ‚Äã‚Äãare judged because the average programmer never used Lisp to create anything practical, and probably never will, but the respect for Lisp is so deep that he is often credited with mythical properties.  Everyone's favorite xkcd comics were depicted in this way Lisp at least twice: in one comic book a character achieves Lisp enlightenment, which helps him to know the fundamental structure of the Universe.  In another, an old programmer in a bathrobe hands over a pile of round brackets to his Padawan, explaining that this is ‚Äúan elegant weapon for more civilized times‚Äù, hinting at the occult capabilities of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BB%25D0%25B0_(%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B)">Force</a> inherent in Lisp. <br><a name="habracut"></a><br>  Another fine example is the Bob Kanefsky parody of the song ‚ÄúGod Lives on Terra‚Äù.  His parody was written in the mid-90s and is called the Eternal Flame.  She describes how, apparently, God created the world with the help of Lisp.  Here is the excerpt, and the full version can be found on the <a href="https://www.gnu.org/fun/jokes/eternal-flame.en.html">GNU Humor Collection</a> website: <br><blockquote>  After all, God wrote on Lisp <br>  When the leaves are filled with green. <br>  Fractal flowers and recursive roots: <br>  The most beautiful hack I've ever seen. <br>  And when I study snowflakes, <br>  And I do not find two identical, <br>  I know that God loves the language <br>  With its own four-letter name. </blockquote><br>  I speak only for myself, but it seems to me that the cultural meme "Lisp is secret magic" is the most strange and interesting phenomenon.  Lisp was conceived in an ivory tower as a tool for researching artificial intelligence, so it will always be a little unfamiliar and mysterious for ordinary programmers.  However, programmers are now <a href="https://www.reddit.com/r/ProgrammerHumor/comments/5c14o6/xkcd_lisp/d9szjnc/">telling</a> each other to ‚Äútry Lisp before you die,‚Äù as if it were some kind of psychedelic mind-expanding tool.  They do this in spite of the fact that Lisp is the second oldest of the oldest programming languages ‚Äã‚Äãthat are still used, second only to <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD">Fortran</a> , and then only for a year.  Imagine that you would be entrusted with advertising a new programming language by the company or team that developed it.  Wouldn't it be cool to convince everyone that your new language has divine powers?  But how could this be achieved?  How did a programming language become famous as a source of secret knowledge? <br><br>  How did Lisp come to life like that? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/303/7b7/7d7/3037b77d74f9f90ecacc06b0d77f8b6e.jpg"><br>  <i>Cover of the magazine Byte, August 1979</i> <br><br><h2>  Theory A: axiomatic language </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BA%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25B8,_%25D0%2594%25D0%25B6%25D0%25BE%25D0%25BD">John McCarthy</a> , the creator of Lisp, did not initially strive to ensure that Lisp was the elegant essence of computational principles.  But, after one or two good ideas and a few improvements, Lisp turned into just that.  <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D1%258D%25D0%25BC,_%25D0%259F%25D0%25BE%25D0%25BB">Paul Graham</a> - we will tell about him later - wrote that, having created Lisp, McCarthy ‚Äúdid the same for Euclid for programming for geometry‚Äù.  Perhaps people are looking for deep meaning in Lisp, because McCarthy created it from such fundamental parts that it is hard to say whether he invented it or discovered it. <br><br>  McCarthy began thinking about creating a language during the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B0%25D1%2580%25D1%2582%25D0%25BC%25D1%2583%25D1%2582%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2581%25D0%25B5%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580">1956 Dartmouth Summer Research Project on Artificial Intelligence</a> .  This seminar was a continuous multi-week academic conference, the very first in the field of AI.  By the way, it was McCarthy, then being an associate professor of mathematics at Dartmoor, coined the term "artificial intelligence", offering to hold this meeting.  The conference was attended by about ten people.  Among them were Allen Newel and Herbert Simon, two researchers associated with the RAND Corporation and Carnegie Mellon University, who had just completed the development of the <a href="https://en.wikipedia.org/wiki/Information_Processing_Language">IPL</a> language. <br><br>  Newel and Simon tried to create a system capable of producing evidence in the <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%258B%25D1%2581%25D0%25BA%25D0%25B0%25D0%25B7%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B9">logic of statements</a> .  They realized that it would be hard to do, while remaining at the level of their own computer instructions, so they decided to create a language - or, as they called it, ‚Äúpseudo-code‚Äù ‚Äîwhich will help them more naturally express the work of their ‚Äúmachine of theoretical logic‚Äù.  Their language, IPL, ‚Äúinformation processing language,‚Äù was more like a high-level dialect of assembler than a programming language in the modern sense.  Newel and Simon, perhaps referring to Fortran, noted that "other pseudo-codes", then under development, were "busy" with the representation of the equations in a standard mathematical notation.  Instead, their language focused on presenting statements in the form of lists of symbolic expressions.  IPL programs used assembler macro sequences to process and evaluate expressions within one or more of these lists. <br><br>  McCarthy thought it would be useful to have algebraic expressions in a language similar to Fortran.  Therefore, he did not like the IPL.  But he thought that symbolic lists were a good way to model tasks from the field of AI, especially those that included deduction.  It was the germ of McCarthy‚Äôs desire to create an algebraic list processing language, a language that would resemble Fortran, but could also handle symbolic lists like an IPL. <br><br>  Of course, today Lisp does not resemble Fortran.  Over the next few years, McCarthy's ideas on the ideal language for processing lists developed.  His ideas began to change in 1957, when he began writing procedures for a program in Fortran, playing chess.  The long-lasting impact of Fortran convinced McCarthy that there were several unfortunate places in his design, the most important of which was the clumsy IF operator.  McCarthy invented an alternative, the conditional expression ‚Äútrue,‚Äù returning the subexpression A, if the specified test was successful, and the subexpression B in another case, and performing only the subexpression that was returned.  In the summer of 1958, when McCarthy worked on a program capable of differentiation, he realized that his conditional expression ‚Äútrue‚Äù made writing recursive functions simpler and more natural.  The differentiation task also prompted McCarthy to write the maplist function, which takes another function as an argument, and applies it to all elements of the list.  It was useful for differentiating the amounts of an arbitrary number of members. <br><br>  Such things on Fortran could not be expressed, so in the fall of 1958 McCarthy asked several students the task of implementing Lisp.  Since McCarthy was now an associate professor at MIT, all students studied at MIT.  Translating ideas into a working code, McCarthy and the students made changes that simplified the language even more.  The largest of these was the Lisp syntax.  McCarthy first wanted the language used so-called.  "M-expressions", a layer of " <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2581%25D0%25B0%25D1%2585%25D0%25B0%25D1%2580">syntactic sugar</a> " that made Lisp syntax look like Fortran.  Although M-expressions can be translated into S-expressions ‚Äî a simple list enclosed in brackets that Lisp is famous for ‚Äî S-expressions were actually a low-level representation intended for a computer.  The only problem was that McCarthy designated M-expressions with square brackets, and there were no square brackets on the IBM 026 punch used in MIT.  Therefore, the Lisp team limited itself to S-expressions, and used them to represent not only lists of data, but also the use of functions.  McCarthy and the students made several simplifications, including the transition to the prefix notation and the memory model, in which the language had only one type of real. <br><br>  In 1960, McCarthy published the famous work on Lisp "Recursive functions of symbolic expressions and their machine computation" [Recursive Functions of Symbolic Expressions].  By that time, the language was reduced to such an extent that McCarthy realized that he had created an ‚Äúelegant mathematical system,‚Äù and not just another programming language.  He later wrote that many simplifications in Lisp turned it into ‚Äúa way of describing calculated functions, much more accurate than Turing machines or general recursive definitions used in the theory of recursive functions‚Äù.  In his work, he presented Lisp as a working programming language, and as a formalism for studying the behavior of recursive functions. <br><br>  McCarthy explained Lisp to readers by building it out of a small set of rules.  Later, Paul Graham followed McCarthy's footsteps, using a simpler reading language, in his Essay on <a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">Lisp Roots</a> .  Graham can explain Lisp using only seven primitive operators, two different entries for functions, and six high-level functions defined through primitive operators.  The ability to define a Lisp using such a small sequence of simple rules certainly adds to its mystery.  Graham called McCarthy's work an attempt to "axiomatize calculations."  I think this is a great way to reflect on the attractiveness of Lisp.  In other languages, there are obviously artificial constructions described by such reserved words as while, typedef, or public static void, it seems that the Lisp description is limited to the very logic of the calculations.  This quality and the initial connection of Lisp with such an esoteric field as the ‚Äútheory of recursive functions‚Äù should explain the current prestige of the language. <br><br><h2>  Theory B: the car of the future </h2><br>  Two decades after its creation, Lisp has become, according to the famous " <a href="">dictionary of computer scientists</a> ", the "native language" of research in the field of AI.  In the early stages, Lisp spread quickly, probably due to the fact that its systematic syntax made the task of implementing it on new machines relatively straightforward.  Later, researchers continued to use it because of how well it coped with symbolic expressions, which was important in an era when most AI was symbolic.  Lisp was used in such prolific AI projects as the natural language understanding program <a href="https://ru.wikipedia.org/wiki/SHRDLU">SHRDLU</a> , the computer algebra <a href="https://ru.wikipedia.org/wiki/Macsyma">system Macsyma</a> , and the logical system <a href="https://en.wikipedia.org/wiki/ACL2">ACL2</a> . <br><br>  By the mid-1970s, AI researchers began to lack computer power.  For example, the PDP-10, the beloved AI machine for working with AI, had 18-bit address space, which was increasingly lacking for Lisp AI programs.  Many AI programs also had to be interactive, and creating a large interactive program that works well on a time-sharing system was a difficult task.  The solution, which was first proposed by Peter Deutsch from MIT, was to develop a special computer for Lisp.  <a href="https://twobithistory.org/2018/09/30/chaosnet.html">Such machines</a> should have given each user a dedicated processor optimized for Lisp.  They also had to have a development environment written in Lisp for hardcore Lisp programmers.  Lisp machines, designed at an awkward moment at the end of the era of mini-computers, but before the heyday of the microcomputer revolution, were high-performance personal computers for programmer elites. <br><br>  For a while it seemed that Lisp machines would be the wave of the future.  There were several companies that began to compete for the commercialization of this technology.  The most successful of these was Symbolics, created by veterans of the MIT AI Lab.  In the 1980s, Symbolics launched a line of 3600-series computers popular in AI and in industries that required high-power computing.  In the 3600 line-up, there were computers with large screens, raster graphics, an interface that used a mouse, and powerful graphics and animation programs.  These were impressive machines that allowed to write impressive programs.  For example, Bob Cali, who worked in the field of robotics research, tweeted me that he was able to implement and visualize the path finding algorithm on the Symbolics 3650 in 1985. He said that raster graphics and OOP (available on Lisp machines due to the Flavors extension) were novelties in the 1980s.  Symbolics was at the forefront. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/24f/fd8/ed624ffd86464f9be7709ddae35ca3cf.jpg"><br><br>  But as a result, Symbolics computers were insanely expensive.  The Symbolics 3600 cost $ 110,000 in 1983. Most people could only wonder at the power of Lisp machines and the magic of the operators who wrote to Lisp from afar.  But they were astonished.  Byte magazine has described Lisp and Lisp machines several times between 1979 and the late 1980s.  In the August 1979 issue of Lisp, the chief editors were delighted with the new machines being developed at MIT with ‚Äúa mountain of memory‚Äù and an ‚Äúadvanced operating system‚Äù.  He considered them so promising that the previous two years, in which the Apple II appeared, the Commodore PET and the TRS-80, seemed boring.  Five years later, in 1985, the author in Byte magazine described the process of writing Lisp programs for the ‚Äúcomplex and extremely powerful Symbolics 3670,‚Äù and encouraged readers to learn Lisp, stating that it was both ‚Äúthe language necessary for most AI researchers‚Äù, and a candidate for a future general purpose language. <br><br>  I asked Paul McJohnns, <a href="http://www.softwarepreservation.org/projects/LISP/">who had done a lot</a> to save Lisp at the Computer View Museum in Mountain View, about when people first started talking about Lisp as a gift of beings from a higher dimension.  He said that the properties of the language itself certainly contributed to this, but also the close connection between Lisp and powerful AI applications in the 1960s and 1970s.  When the Lisp machine became available in the 1980s, a few more people came to know Lisp outside of places such as MIT or Stanford, and the legend continued to grow.  Today, Lisp machines and Symbolics few people remember, but they helped to maintain the aura of the mystery of Lisp until the 1980s. <br><br><h2>  Theory B: Programming Teaching </h2><br>  In 1985, professors from MIT, Harold Abelson and Gerald Sasman, as well as Sasman's wife, Julia, published a textbook on Structure and Interpretation of Computer Programs.  In the textbook, readers were taught programming in Scheme, the Lisp dialect.  It has been used at MIT for an introduction to programming for two decades.  It seems to me that this is a tutorial, SICP, added Lisp mysticism.  SICP took Lisp and showed how it can be used to illustrate the deep, almost philosophical concepts of the art of programming.  These concepts were general enough to use any PL, but the SICP authors chose Lisp.  As a result, Lisp's reputation was complemented by the notoriety of this strange and ingenious book that intrigued many generations of programmers (and became a <a href="https://knowyourmeme.com/forums/meme-research/topics/47038-structure-and-interpretation-of-computer-programs-hugeass-image-dump-for-evidence">very strange meme</a> ).  Lisp has always been an "elegant formalism of McCarthy";  now it has also become a language that "teaches you hidden programming secrets"). <br><br>  It is worth telling a little about how strange this book is - since it seems to me that its oddity and the oddity of Lisp have merged into one today.  Strangeness begins with the cover.  It depicts a wizard or alchemist, approaching the table, and ready to start some kind of witchcraft.  In one hand he has a caliper or compass, in the other - a globe with the inscriptions "eval" and "apply".  The woman in front of him points to the table;  on the background hangs in the air the Greek letter lambda, emitting light. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/c76/41a/dcdc7641ad77a08295763e07c85e4727.jpg"><br><br>  What is going on here?  Why is the table the foot of an animal?  Why is the woman pointing to the table?  What is the significance of the ink?  Do we need to understand that the wizard has revealed the secret knowledge of the universe, and that they consist of the eval / apply cycle and <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%258F%25D0%25BC%25D0%25B1%25D0%25B4%25D0%25B0-%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">lambda calculus</a> ?  Apparently, it is.  Only this image was supposed to add much to today's Lisp perception. <br><br>  But the text of the book itself often turns out to be just as strange.  SICP is not like most other books on computer science.  The authors in the preface explain that the book is not just about programming in Lisp - it tells about "three foci, or phenomena: the human mind, a set of computer programs and a computer."  Later they describe that they are convinced that programming should be viewed not as a computer science discipline, but as a new record of ‚Äúprocedural <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BF%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F">epistemology</a> ‚Äù.  Programs are a new way of structuring thoughts that are only sometimes introduced into a computer.  The first chapter gives a brief tour of Lisp, but most of the book is about more abstract concepts.  It discusses various programming paradigms, the nature of time and identity in OO systems, and in one place what synchronization problems may arise due to the fundamental limitations of message passing, which play the role of the speed of light in relativity.  These are pretty abstruse things. <br><br>  And do not say that the book is bad.  She is wonderful.  It discusses important concepts of programming at a higher level than in all the other books I have read, concepts that I had thought about for a long time, but could not describe.  It is surprising that a textbook on introducing programming so quickly can go on to describing the fundamental shortcomings of OOP and the advantages of functional languages ‚Äã‚Äãthat minimize a changing state.  It's amazing how this turns into a discussion of how the flow paradigm, probably something like today's <a href="https://rxjs-dev.firebaseapp.com/">RxJS</a> , can give you the best of both approaches.  SICP highlights the very essence of developing high-level programs in a manner reminiscent of McParthy‚Äôs original Lisp work.  The first thing you want to do after reading this book is to make your programmer friends read it;  if they find it, see the cover, and do not read it, all they have to postpone is that some mysterious thing named eval / apply gives the wizards a special power over the tables with the feet of animals.  I would still be impressed with their shoes. <br><br>  But perhaps the most important contribution of the SICP was to raise the Lisp from the level of amusing curiosity to pedagogical necessity.  Long before the SICP, people advised each other to study Lisp in order to improve their level as a programmer.  The issue of Byte magazine from 1979 is evidence of this.  The same editor, who admired new Lisp machines at MIT, explained that it is worth learning this language, since it "represents a different perspective on the tasks."  However, in SICP Lisp was presented not just as a contrast to other languages.  It was used as an introductory language, hinting that it is the best language for learning basic programming concepts.  When today's programmers tell each other to try Lisp before they die, they probably do it because of SICP.  After all, Brainfuck, too, probably offers a "different point of view on tasks."  But people instead study Lisp, knowing that Lisp‚Äôs point of view has been so useful for twenty years, that students at MIT were taught Lisp before all other languages. <br><br><h2>  Return Lisp </h2><br>  In the year of SICP's release, Bjarne <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2583%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BF,_%25D0%2591%25D1%258C%25D1%2591%25D1%2580%25D0%25BD">Straustrup</a> published the first edition of the book <a href="https://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_C%252B%252B_(%25D0%25BA%25D0%25BD%25D0%25B8%25D0%25B3%25D0%25B0)">C ++ Programming Language</a> , which brought OOP to the masses.  A few years later, the market for Lisp machines collapsed, and the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B8%25D0%25BC%25D0%25B0_%25D0%25B8%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B0">AI winter</a> began.  Over the next ten years, C ++ and then Java have become the languages ‚Äã‚Äãof the future, and Lisp has become stagnant. <br><br>  Naturally, it is impossible to indicate when exactly people began to admire Lisp again.  Perhaps this happened after Paul Graham, the co-founder of Y-Combinator and the creator of Hacker News, published several influential essays where he described Lisp as the best language for startups.  In the essay <a href="http://www.paulgraham.com/avg.html">Ahead of the Middle Ages</a> , Graham argued that the Lisp macros made the language stronger than other languages.  He said that using Lisp in his Viaweb startup helped him develop certain things faster than competitors could.  Some programmers are convinced.  But most did not switch to Lisp. <br><br>  Instead, more and more features of Lisp began to fall into all the favorite languages.  In Python, list generation has appeared.  In C #, Linq.  In Ruby ... well, Ruby is Lisp.  As Graham noted back in 2001, "the default language, embedded in many popular languages ‚Äã‚Äãthat emerged later, gradually developed in the direction of Lisp."  And while other languages ‚Äã‚Äãare gradually approaching Lisp, Lisp itself somehow maintains its special reputation as a mysterious language that few people understand, but everyone must learn.  In 1980, the year of the Lisp 20th anniversary, McCarthy wrote that Lisp survived for so long, because it occupied "an exemplary local optimum of its own kind in the space of PL".  But this underestimates the real influence of Lisp.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He has been surviving for fifty years now because programmers have reluctantly recognized decade by decade that this is the best tool for their task. </font><font style="vertical-align: inherit;">He survived, even though most programmers do not use it. </font><font style="vertical-align: inherit;">Due to its origin and use in AI research, and possibly also the SICP heritage, Lisp continues to delight people. </font><font style="vertical-align: inherit;">And until we can imagine God, who created the world with the help of some newer language, Lisp will not go anywhere.</font></font></div><p>Source: <a href="https://habr.com/ru/post/428229/">https://habr.com/ru/post/428229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428219/index.html">Where did the practice of mass relocation of qualified personnel come from?</a></li>
<li><a href="../428221/index.html">Generating arbitrary realistic entities using AI</a></li>
<li><a href="../428223/index.html">Cities and their ‚Äúbig data‚Äù</a></li>
<li><a href="../428225/index.html">How to do web analytics for SaaS through Google Analytics: introducing and tracking funnels</a></li>
<li><a href="../428227/index.html">Machine learning: predict stock prices in the stock market</a></li>
<li><a href="../428231/index.html">Beautiful and clean: tools that help achieve near-perfect code</a></li>
<li><a href="../428233/index.html">Five reasons to fall in love with regional IT parties</a></li>
<li><a href="../428235/index.html">Why did I get a call from the NSA in the middle of the night and asked for the source code?</a></li>
<li><a href="../428237/index.html">Board game scrum mitap: welcome to the Scrum Values ‚Äã‚ÄãGame</a></li>
<li><a href="../428239/index.html">Flash drives on the eve of 2019 - a relic of the past or is it still a necessity?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>