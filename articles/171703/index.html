<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Selenium 2.0 - WebDriver. Impressions, problems and tips on using</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 The last three months I had to work with Selenium 2.0 (WebDriver). 
 In this article I will describe my impressions, thoughts and exper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Selenium 2.0 - WebDriver. Impressions, problems and tips on using</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  The last three months I had to work with Selenium 2.0 (WebDriver). <br>  In this article I will describe my impressions, thoughts and experiences that I gained. <br>  I will also describe the main actions that most often cause problems and show the most successful solutions that I was able to implement for them.  Perhaps there are more correct approaches - I will be glad if you leave them in the comments. <br><a name="habracut"></a><br><br><h5>  Briefly about Selenium </h5><br>  The Selenium library allows testing graphical web interfaces.  Its principle is to simulate the user's activity as accurately as possible.  In essence, this is the writing of a bot that runs through the pages of the site, performs actions and checks the expected result.  Selenium 2.0 implements messages with browsers through special drivers.  Unlike Selenium 1.0, it does not use JavaScript, but communicates directly with the browser API. <br><br><h5>  What I managed to implement </h5><br>  It turned out to write tests based on JUnit and Selenium 2.0, combined into one application.  This application can run on a Selenium Grid - a network, led by Selenium Hub, which accepts and distributes incoming testing tasks to its Selenium Nodes.  On various Selenium Nodes any required browsers can be configured.  Drivers used are native drivers for each browser. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Part one.  Impressions </h4><br><h5>  Different behavior in different browsers </h5><br>  By browsers, I mean the main ones: Firefox, Google Chrome, Opera, Safari, IE8, IE9 <br>  For the same code to work equally well in different browsers, you need to spend a huge amount of time.  Sometimes an iron will is needed in order not to give up this bad job.  In this regard, the most compliant browsers are Firefox and Google Chrome.  In my personal experience, it is vital that the test can change behavior in the right places depending on which browser is currently being used.  Those.  he must have information about the environment in which he is passing. <br><br>  <i>Tip:</i> <i><br></i>  <i>Try not to use the webDriver object directly in tests!</i>  <i>Create wrapper methods around the basic methods you need.</i>  <i>It is easier to change the behavior in one place than everywhere in the code of all tests.</i> <br><br><h5>  Selenium 2.0 - raw product </h5><br>  Reading a lot of posts on Stackoverflow in search of best practices or just a solution to a problem, you constantly come across workarounds.  There are several reasons: differences in browser drivers, non-fulfillment of the required functionality by the drivers, presence of errors in the versions, direct dependence of the browser version on the driver version.  Sometimes he can just drop a test from a bare place (from the user's API point of view) - there is an element, but he does not see it.  In my experience there are a lot of floating errors that are intentionally reproduced only once, under absolutely similar conditions and actions.  With Firefox, a fever sometimes starts and the browser can simply close with something like this: <i>Error communicating with the remote browser.</i>  <i>It may have died</i> .  It is extremely difficult to find the reason, if it is at all available to the user of Selenium.  Therefore, sometimes the situation is helpless - the functionality just doesn't work. <br><br>  <i>Tip:</i> <i><br></i>  <i>This kind of regrettable business makes us change the behavior of the test case.</i>  <i>Fortunately, the same things in GUI clients can often be done either in a different sequence or in a different way.</i>  <i>If you could not find a solution by googling - try to choose another behavior that will be successfully worked out.</i>  <i>Do not lock on a specific action, if there is no special need.</i> <br><br><h5>  Selenium tests - dependent tests </h5><br>  This means that if you do not take extra care, the actions of one test can affect the result of another test.  It is quite obvious, including the user changes the data during their activity.  By testing this functionality, you will have to change the initial data.  If other tests depend on it and you did not return the data to its original state - or could not do it due to the fact that the test was interrupted by an error - another test may also break.  A sort of domino principle.  When you first realize this, it becomes very painful.  Hands down ... <br><br>  <i>Tip:</i> <i><br></i>  <i>If it is possible to reproduce the test conditions independently, i.e.</i>  <i>there is direct access to the application under test and there are no barriers to deploying the initial test data - you are lucky, isolate your tests in a similar way - by preparing the data before the test and clearing them after.</i>  <i>For example, the Liquibase tool can help in recovering data in a database.</i> <i><br></i>  <i>Most likely this is not possible.</i>  <i>In this case, there is only one way out - in addition to the actions being tested, to describe with the help of Selenium the actions for their ‚Äúrollback‚Äù.</i>  <i>Those.</i>  <i>if the user has deleted an entity, at the end of the test it must be re-created or loaded.</i> <i><br></i>  <i>This is a sinful way.</i>  <i>Since such actions are also vulnerable and can also terminate with an error without fulfilling their purpose.</i> <br><br><h5>  Selenium Tests - Slow Tests </h5><br>  You need to be prepared that the sequential run of a large set of tests for all browsers can take a large amount of time, measured in hours (from 30 minutes to 2-3 hours).  It does everything that I described above as tragedies and at times looks like a mockery.  The reason is that the tests are very saturated with various expectations, the search for elements and other slow actions. <br><br>  <i>Tip:</i> <i><br></i>  <i>Test only what you really need to test.</i>  <i>Of all the possible working options for the implementation of the same action - choose the fastest.</i> <br><br><h5>  Selenium IDE is not an assistant </h5><br>  Selenium IDE is a special plugin for Firefox, which is able to record all the actions performed by the user in the form of scripts.  You can also export compiled scripts in different languages ‚Äã‚Äãand in two formats: Selenium 1.0 (RC) and Selenium 2.0 (WebDriver). <br>  In most cases, useless thing. <br><br>  Problems: <br><ul><li>  generated code - do not read </li><li>  the generated code is not working, in the case of a complex interface, due to all the above features </li><li>  if the id elements (div, table, span, input) are automatically generated - the XPath pointers offered for selection do not fit </li><li>  A large number of tests (5 tests are already enough) will force you to get on the right path of the Jedi and create your own implementation of frequently performed actions - and then use them as an inherited method.  Once described and honed.  As soon as such a set of methods is formed, the benefits of IDE drop sharply.  She cannot be told to use her own methods - the development environment will generate her own idle non-ideal templates.  View then generated code and replace all the necessary places over time is reduced to a complete rewriting of this code.  The same idea can be continued with a single ‚Äúreference book‚Äù - a list of all XPath locators of key elements.  As soon as all such locators are rendered in constants or in a separate directory - it becomes easier to use them than to check again - what the development environment got there </li></ul><br><br>  Benefit: <br>  The only benefit that I constantly feel is the ability to check the XPath pointer.  A very convenient function - if the pointer is valid and such an element exists - it is highlighted by a frame. <br><br>  <i>Tip:</i> <i><br></i>  <i>Play with IDE, understand the essence of Selenium, you can even pee tests with it.</i>  <i>But as soon as you feel that the benefits are less than the costs - start making your own blanks.</i>  <i>Accumulate them in a general abstract ancestor class or in a utility class.</i>  <i>Starting from a certain point, your tests can turn into just a listing of such methods, diluted with checks of the result and the current state.</i> <br><br><h4>  Part two.  Practical solutions to emerging problems (Java) </h4><br>  The solutions described below are not beautiful, ideal, they can cause rejection, but they are workers.  In my experience, they eliminate problems.  I hope they will benefit and get rid of lost hours and days. <br><br><h5>  Getting an item (findElement) </h5><br>  Problem: <br>  WebDriver provides a mechanism for searching and retrieving an entity WebElement: <br><pre><code class="java hljs">webDriver.findElement(By.id(<span class="hljs-string"><span class="hljs-string">"elementId"</span></span>));</code> </pre> <br>  Theoretically, the behavior of this method is influenced by the parameter <i>'implicit wait',</i> which can be specified when building the webdriver itself.  For example, like this: <br><pre> <code class="java hljs">webDriver.manage().timeouts().implicitlyWait(<span class="hljs-number"><span class="hljs-number">5</span></span>, TimeUnit.SECONDS);</code> </pre><br>  Again, theoretically, this should obviously force the webdriver to search for an element for a specified time and wait either for the desired element to appear or for the specified timeout to expire.  By the way, this timeout seems to be set only once. <br>  In practice, something strange happens.  The pause is maintained, but there is an internal feeling that the search, if it follows the DOM model, does not update this DOM model.  For some browsers, a different situation is obtained - the element is already in the DOM model, but has not yet been drawn or partially drawn (Google Chrome).  WebDriver returns the found half-drawn element and the click event falls into the still not drawn coordinates.  The isDisplayed () method does not help in such cases.  In any case, the result is always the same for me - the element is visually guaranteed to appear, and webDriver still does not detect it. <br><br>  <i>Decision:</i> <i><br></i>  <i>Make a rough pause.</i>  <i>In order not to multiply the number of lines of code by half, I recommend making your own implementation of the findElement () method;</i> <i><br></i>  <i>As I wrote above, in order to work more efficiently, the test should know which browser is currently running.</i>  <i>For my Firefox, according to my observations, such a delay is not required.</i> <i><br></i>  <i>You can also use the tool WebDriverWait.</i>  <i>I will not describe such an option here, since I decided to stop at the hibernation of the stream, that's enough for me - so there is no proven option.</i>  <i>But everything is pretty simple there.</i> <i><br></i>  <i>In the future, use only this method in all tests and not use webDriver.findElement () directly.</i> <br><br>  Code example: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> WebElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(By elementLocatorToFind)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isSafari() || isChrome() || isIE()) { <span class="hljs-comment"><span class="hljs-comment">// for example, use simple Thread.sleep(1000) inside doDelayForMilliseconds(1000); } return webDriver.findElement(elementLocatorToFind); }</span></span></code> </pre><br><br><h5>  Getting items (findElements) </h5><br>  The problem and solution are similar to finding one item. <br><br><h5>  Check for the existence of an element </h5><br>  If it is necessary to check that the element is missing, it is recommended to use the construction: <br><pre> <code class="java hljs">findElements(elementLocatorToFind).isEmpty();</code> </pre><br><br>  Here is the recommendation from JavaDocs: <br><blockquote>  it is not necessary to use the elements for the non-present elements, use the findElements (By) and assert zero length response instead. </blockquote><br><br><h5>  Downloading a picture or file </h5><br>  Problem: <br>  There is a desire to test downloading a file, that the downloaded file is as expected, and if this is a picture, it is really available at the indicated link. <br><br>  Reasonings: <br>  In 99% of cases you do not need it.  Once again ask yourself, what do you want to test?  I‚Äôm pretty sure that you only need to know that the download is available.  That the link is active, the download button is enabled and the response status after the start of the download is 200. You have no task to test the browser and its download process. <br>  Also, if the tests pass on Selenium Grid, then you will not be able to download the file and check its location after that.  The file is downloaded to Selenium Node, and you will check it on Selenium Hub.  These are different hosts, at least in common practice. <br><br>  <i>Decision:</i> <i><br></i>  <i>The solution is to perform an ordinary HTTP request on the link leading to the file on the server, or on the link on which the server should return such a file.</i>  <i>If the status of the response received from the server 200 is correct, the file exists.</i>  <i>All other options I see as the inaccessibility of downloading the file.</i>  <i>Since requests often must have authorized cookies with you, such cookies must be imported from webDriver.</i> <i><br></i>  <i>If one status is not enough, nothing prevents you from counting the entire InputStream from HttpEntity and then comparing its contents with the reference one, be it MD5 sum or some other method.</i> <br><br>  Code example: <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// just look at your cookie's content (eg using browser) and import these settings from it private static final String SESSION_COOKIE_NAME = "JSESSIONID"; private static final String DOMAIN = "domain.here.com"; private static final String COOKIE_PATH = "/cookie/path/here"; protected boolean isResourceAvailableByUrl(String resourceUrl) { HttpClient httpClient = new DefaultHttpClient(); HttpContext localContext = new BasicHttpContext(); BasicCookieStore cookieStore = new BasicCookieStore(); cookieStore.addCookie(getSessionCookie()); localContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore); // resourceUrl - is url which leads to image HttpGet httpGet = new HttpGet(resourceUrl); try { HttpResponse httpResponse = httpClient.execute(httpGet, localContext); return httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK; } catch (IOException e) { return false; } } protected BasicClientCookie getSessionCookie() { Cookie originalCookie = webDriver.manage().getCookieNamed(SESSION_COOKIE_NAME); if (originalCookie == null) { return null; } String cookieName = originalCookie.getName(); String cookieValue = originalCookie.getValue(); BasicClientCookie resultCookie = new BasicClientCookie(cookieName, cookieValue); resultCookie.setDomain(DOMAIN); resultCookie.setExpiryDate(originalCookie.getExpiry()); resultCookie.setPath(COOKIE_PATH); return resultCookie; }</span></span></code> </pre><br><br><h5>  Clearing the input field value </h5><br>  UPD: below, in the comments, you can find a discussion.  As a result, the method seems to work correctly, and the reason was hidden in the difference in browser versions and in another conflict related to it.  But I decided not to delete the description of this problem, since  perhaps for someone such methods will also be useful, as for me in due time. <br><br>  Problem: <br>  Occasionally, you need to clear the value of an input type field.  For example, you need to replace the old value with a new one. <br>  WebDriver provides a special method for this: <br><pre> <code class="java hljs">webElement.clear();</code> </pre><br>  In my experience, this method does not work, moreover, throws an error and breaks the test. <br>  It is required to find another way to clear the field value. <br><br>  <i>Decision:</i> <i><br></i>  <i>There are several basic ways.</i> <i><br></i>  <i>The first way is to simulate the action ‚Äúselect all‚Äù and immediately after that send a new value:</i> <i><br></i> <pre> <i><code class="java hljs">inputElement.sendKeys(Keys.chord(Keys.CONTROL, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) + Keys.DELETE + newValue);</code></i> </pre> <i><br></i>  <i>But this solution does not work for me on all browsers and not always.</i> <i><br><br></i>  <i>The second way is to send the number of characters backspace equal to the length of the old value.</i>  <i>This solution is ugly, but it is efficient and guaranteed to work in all browsers.</i> <i><br></i>  <i>Below I publish the version that I use myself.</i>  <i>It has a separate consideration of the situation when the browser is IE, and input with the file type.</i> <i><br></i>  <i>This is a special situation.</i>  <i>When executing the sendKeys command to such an element, IE replaces the old value with the new one, and does not add it to the end.</i>  <i>Therefore, it makes no sense to clean up such a field.</i>  <i>Moreover, such an attempt will lead to an error.</i>  <i>Either because of a non-existent file (as it will attempt to find the file on an empty path), or because of an attempt to find the file by a path whose string value is equal to the backspace symbol.</i> <br><br>  Code example: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WebElement webElement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// isIE() - just checks is it IE or not - use your own implementation if (isIE() &amp;&amp; "file".equals(webElement.getAttribute("type"))) { // workaround // if IE and input's type is file - do not try to clear it. // If you send: // - empty string - it will find file by empty path // - backspace char - it will process like a non-visible char // In both cases it will throw a bug. // // Just replace it with new value when it is need to. } else { // if you have no StringUtils in project, check value still empty yet while (!StringUtils.isEmpty(webElement.getAttribute("value"))) { // "\u0008" - is backspace char webElement.sendKeys("\u0008"); } } }</span></span></code> </pre><br><br><h5>  Upload file to server </h5><br>  Problem: <br>  You must upload the file to the server using standard HTML elements: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"uploadFile"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"doUpload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Upload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"button"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre><br><br>  <i>Decision:</i> <i><br></i>  <i>I recommend simply taking it and putting it into a separate universal method and using it every time you need to load something through this form.</i> <br><br>  An exception: <br>  Safari Driver does not fully support file download, as  as far as I understood, it is javascript-based.  The window with the choice of the file stumps it.  Such scenarios should either be avoided or another result achieved ‚Äî create your own HTTP request or enclose the data directly on the server side, if there is such a possibility. <br><br>  Code example: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(By uploadInput, By uploadButton, String filePath)</span></span></span><span class="hljs-function"> </span></span>{ clearInput(uploadInput); findElement(uploadInput).sendKeys(filePath); findElement(uploadButton).click(); }</code> </pre><br><br><h5>  Actions with elements inside the iframe </h5><br>  Problem: <br>  If the required element is inside an iframe, it is not accessible from the default context.  You cannot detect it in the DOM model, and webDriver will throw a NoSuchElementException exception. <br><br>  <i>Decision:</i> <i><br></i>  <i>Before interacting with this element, you must switch webDriver to the iframe context of the element.</i>  <i>As I understand it, this is due to the fact that the page context and the iframe context on this page are two different DOM models.</i> <br><br>  Code example: <br><pre> <code class="java hljs">webDriver.switchTo().frame(findElement(By.id(<span class="hljs-string"><span class="hljs-string">"id_of_your_iframe"</span></span>))); <span class="hljs-comment"><span class="hljs-comment">// do actions against inner web element, located in iframe webDriver.switchTo().defaultContent(); // continue to do actions in default content</span></span></code> </pre><br><br><h5>  IE8.  XPath issue </h5><br>  Problem: <br>  IE8, in its eccentric manner, can misinterpret element pointers (By.id, By.xpath, and others). <br>  I had a situation when he ignored the clarification for the search element pointing to his class attribute. <br>  For example, IEDriver refused to distinguish between two different elements found on such locators and derived elements suitable for both options: <br><pre> <code class="java hljs">findElement(By.xpath(<span class="hljs-string"><span class="hljs-string">"//div[@id='elementContainer']/div[@class='someProcessInProgress']"</span></span>)); findElement(By.xpath(<span class="hljs-string"><span class="hljs-string">"//div[@id='elementContainer']/div[@class='someProcessFinished']"</span></span>));</code> </pre><br>  Understand in what situations he had problems I could not. <br>  Absolutely identical situation occurred with a direct indication of the id element.  WebDriver pretends that it does not exist. <br><br>  <i>Decision:</i> <i><br></i>  <i>If IEDriver has a hallucinogenic delusion in the search for an item (but not in other drivers and browsers), the best way out is to change the XPath.</i>  <i>The benefit of the possible options due to the flexibility of XPath is always a lot.</i> <br><br><h5>  IE8.  item not available to click </h5><br>  Problem: <br>  IE8, unlike other browsers, is not always able to independently scroll to an element if you click on an element outside the visible part of the container (layer, table, etc.).  As a result, this behavior leads to an error. <br><br>  <i>Decision:</i> <i><br></i>  <i>Need to scroll.</i>  <i>The only working way found by me is to use javascript.</i>  <i>In fact, WebDriver has a special mechanism to help scroll to the desired element:</i> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actions(webDriver).moveToElement(elementToScrollTo).perform();</code> </pre><br>  <i>But it will not work in the case of IE8.</i> <br><br>  Code example: <br><pre> <code class="java hljs">((JavascriptExecutor) webDriver).executeScript(<span class="hljs-string"><span class="hljs-string">"container.scrollLeft=1000;"</span></span>);</code> </pre><br>  Where container is the id of the item you want to scroll.  Those.  in our case, a div or table within which the element is located.  As you can see, this script will scroll horizontally. <br><br><h5>  Firefox may die </h5><br>  Problem: <br>  Firefox Driver could be an example for other drivers, but it has one very unpleasant flaw.  As you can see from the comments to different versions of WebDriver, this flaw either disappears or reappears from version to version. <br>  The bottom line is that sometimes Firefox finds a demon and it suddenly, without any external, as it seems, impacts and changes, begins to fall on level ground. <br>  It looks like this: you observe how a test that has already been debugged to shine is successfully executed in a browser window.  And here on an absolutely petty step or action the browser window simply disappears.  In the logs you find the following entry: Error communicating with the remote browser.  It may have died.  All, no more information you will not find. <br><br>  <i>Decision:</i> <i><br></i>  <i>This is a regressive error and there can be no guaranteed medication.</i>  <i>It lies in the fact that between the browser and the driver there is a misunderstanding.</i>  <i>For example, due to the fact that your browser has been updated, you did not pay attention to it and continue to use the old WebDriver.</i>  <i>There is a dependency between Firefox and its driver, as I felt it.</i>  <i>It is not absolute, i.e.</i>  <i>not every time Firefox is updated, you need to run to update the web driver too.</i>  <i>But the first thing I advise you to do is google it, which version of the webdriver is most suitable for your version of Firefox.</i> <i><br></i>  <i>In the case of Firefox 19, I was helped to update the stand-alone-server Selenium to version 2.30.0.</i> <br><br><h4>  Conclusion </h4><br>  I am grateful for this experience and for the opportunity to work with this framework.  Over the past months, XPath has become like a native language for me, I can probably correspond with it soon.  Apparently, I gained a lot of knowledge on how to use Selenium and how to do it effectively. <br><br>  But nevertheless ... I would not like to face such tasks in the future.  This is extremely tiring, debugging is like a torment, sometimes makes you write bad code, but most of all it‚Äôs scary that the web client being tested will be modified.  I am guaranteed to know that it will be changed.  And this is another painful moment. <br><br>  Therefore, if you decide to write serious tests on this platform - prepare yourself psychologically. </div><p>Source: <a href="https://habr.com/ru/post/171703/">https://habr.com/ru/post/171703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171691/index.html">CeBIT 2013. Day one. Stands Thermaltake, MSI and Biostar</a></li>
<li><a href="../171693/index.html">Work should be a pleasure</a></li>
<li><a href="../171697/index.html">Use GYP to build a C / C ++ project.</a></li>
<li><a href="../171699/index.html">Useful HTML, CSS and JavaScript techniques</a></li>
<li><a href="../171701/index.html">Search for the user's blocking source in Active Ditectory</a></li>
<li><a href="../171705/index.html">Fujitsu LIFEBOOK UH572 Ultrabook Review</a></li>
<li><a href="../171707/index.html">Story about participating in the contest Intel Accelerate Your Code</a></li>
<li><a href="../171709/index.html">Combining responsive layout and templates for mobile</a></li>
<li><a href="../171711/index.html">Introduction to libuniset - library for creating ACS</a></li>
<li><a href="../171713/index.html">Review of Ubuntu Touch for tablets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>