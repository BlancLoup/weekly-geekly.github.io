<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenSceneGraph: OpenGL State Machine Encapsulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 As a rule, working with rendering parameters, OpenGL acts as a state machine. A rendering state is a collection of state attributes, su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenSceneGraph: OpenGL State Machine Encapsulation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Introduction </h1><br>  As a rule, working with rendering parameters, OpenGL acts as a state machine.  A rendering state is a collection of state attributes, such as light sources, materials, textures, and display modes, turned on and off with glEnable () and glDisable ().  When you set a specific state, it is valid until some other function changes it.  The OpenGL pipeline supports a state stack to save and restore states at any time.  The state machine gives the developer complete control over the current rendering states and those stored on the stack. <br><br>  However, this approach is inconvenient when working with OSG.  For this reason, the OpenGL state machine is encapsulated by the osg :: StateSet class, which takes over the operations of working with the state stack and setting it while traversing the scene graph. <br><a name="habracut"></a><br>  An instance of the osg :: StateSet class contains a subset of various rendering states and can apply them to the osg :: Node scene nodes and the osg :: Drawable geometric objects using the setStateSet () method <br><br><pre><code class="cpp hljs">osg::StateSet *stateset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::StateSet; node-&gt;setStateSet(stateset);</code> </pre> <br>  A safer way would be to use the getOrCreateStateSet () method, which ensures that the correct state is returned and attached to the node or drawable object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs">osg::StateSet *stateset = node-&gt;getOrCreateStateSet();</code> </pre><br>  The classes osg :: Node and osg :: Drawable control the osg :: StateSet member variable via the smart pointer osg :: ref_ptr &lt;&gt;.  This means that a set of states can be divided between several objects of the scene and will be destroyed only when all of these objects are destroyed. <br><br><h1>  1. Attributes and modes </h1><br>  OSG defines the osg :: StateAttribute class for storing rendering attributes.  This is a virtual base class that is inherited by various rendering attributes, such as light, material, and fog. <br><br>  Rendering modes work like switches that can be turned on and off.  In addition, they are associated with enumerators, which are used to specify the type of OpenGL mode.  Sometimes rendering mode is associated with an attribute, for example, GL_LIGHTING mode includes variables for light sources that are sent to the OpenGL pipeline when turned on, and turns off lights otherwise. <br><br>  The osg :: StateSet class divides attributes and modes into two groups: texture and non-texture.  It has several public methods for adding non-textural attributes and modes to a set of states: <br><br><ol><li>  setAttribute () - adds an object of type osg :: StateAttribute to the set of states.  Attributes of the same type cannot coexist in the same set of states.  The previous set point will be overwritten by a new one. <br></li><li>  setMode () - attaches a mode enumerator to a set of states and sets its value to osg :: StateAttribute :: ON or osg :: StateAttribute :: OFF, which means enable or disable the mode. <br></li><li>  setAttributeAndModes () - attaches the rendering attribute and its associated mode and sets the value of the switch (the default is ON).  It should be borne in mind that not every attribute has a corresponding mode, but you can use this method anyway. <br></li></ol><br>  To set the attribute and its associated mode, you can use this code. <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(attr, osg::StateAttribute::ON);</code> </pre><br>  To set texture attributes, you must pass an additional parameter to specify the texture to which it should be applied.  For this, osg :: StateSet provides several other public methods, such as setTextureAttribute (), setTextureMode () and setTextureAttributeAndModes () <br><br><pre> <code class="cpp hljs">stateset-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, textattr, osg::StateAttribute::ON);</code> </pre><br>  applies the textattr attribute to the texture with id 0. <br><br><h1>  2. Setting polygon display mode for scene nodes </h1><br>  We illustrate the above theory with a practical example ‚Äî changing the rasterization mode of OpenGL polygons using the class osg :: PolygonMode, which inherits from osg :: StateAttribute.  This class encapsulates the glPolygonMode () function and provides an interface for setting the display mode of polygons for a particular scene node. <br><br><div class="spoiler">  <b class="spoiler_title">Polygonmode example</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::PolygonMode&gt; pm = new osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Here we will load the model of our beloved Cessna and applying transformations to it we will receive two instances of the model.  To one of them, the fact that on the left, we apply an attribute that sets the frame display mode of polygons <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PolygonMode&gt; pm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get());</code> </pre><br><img src="https://habrastorage.org/webt/pg/v5/ew/pgv5ewaulc_tfjztw5h8gyyap1i.png"><br><br>  If you refer to the OpenGL specification, you can easily imagine what polygon display options will be available to us when using setMode () in this particular case.  The first parameter can take the values ‚Äã‚Äãosg :: PolygonMode :: FRONT, BACK and FRONT_AND_BACK, corresponding to the OpenGL enumerators GL_FRONT, GL_BACK, GL_FRONT_AND_BACK.  The second parameter can be osg :: PolygonMode :: POINT, LINE and FILL, which correspond to GL_POINT, GL_LINE and GL_FILL.  No other tricks, as is often the case when developing on pure OpenGL, are not needed here - OSG takes over most of the work.  The polygon display mode has no associated mode and does not require calling the glEnable () / glDisable () pair.  The setAttributeAndModes () method will work fine in this case, but the value of its third parameter will be useless. <br><br><h1>  3. Inheritance of rendering states.  Apply Attributes and Modes </h1><br>  The set of node states affects the current node and all its children.  For example, the attribute osg :: PolygonMode set for the transform1 node from the previous example will be applied to all children of this node.  However, the child node can override the parent attributes, that is, the rendering state will inherit from the parent node if the child node does not change the behavior. <br><br>  Sometimes it is required to redefine the behavior of the node in the application of attributes.  For example, in most 3D editors, a user can load several models and change their display mode for all loaded models at the same time, regardless of how they were previously displayed.  In other words, all models in the editor must inherit a single attribute, regardless of how it was previously set for each of the models.  In OSG, this can be implemented using the osg :: StateAttribute :: OVERRIDE flag, for example <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttribute(attr, osg::StateAttribute::OVERRIDE);</code> </pre><br>  When setting modes and modes with attributes, the operator is used bitwise OR <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttributeAndModes(attr, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);</code> </pre><br>  In addition, it is possible to protect an attribute from overriding - for this, it must be flagged with the osg :: StateAttribute :: PROTECTED flag. <br><br>  There is a third flag, osg :: StateAttribute :: INHERIT, which is used to indicate that this attribute should be inherited from the set of states of the parent node. <br><br>  Here is a brief example of using the OVERRIDE and PROTECTED flags.  The root node will be set to OVERRIDE to force all the child nodes to inherit its attributes and modes.  In this case, the child nodes will try to change their state with or without the help of the PROTECTED flag, which will lead to different results. <br><br><div class="spoiler">  <b class="spoiler_title">Inherit example text</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/glider.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-0.5f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(0.5f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/lf/8h/u4/lf8hu4n3ii1bor6lgsktbischd0.png"><br><br>  To understand what is going on in general, you need to see how a normally-lit glider looks like by downloading its OSG osgviewer <br><br><pre> <code class="bash hljs">$ osgviewer glider.osg</code> </pre><br>  In the example we are trying to change the lighting mode for the transform1 and transform2 nodes, turning off the lighting completely. <br><br><pre> <code class="cpp hljs">transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  At the same time, we enable the lighting mode for the root node, and using the OVERRIDE flag for all its child nodes, so that they inherit the status of the root node.  However, trnsform2 uses the PROTECTED flag to prevent the influence of root node settings. <br><br><pre> <code class="cpp hljs">transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  As a result, despite the fact that we turn off the lighting at the transform1 node, the left hang-glider is still lit, as the settings of the scene root blocked our attempt to turn off the lighting for it.  The right hang glider is displayed without illumination (it looks brighter only because it is filled with a simple color without calculating the illumination), since transform2 is protected from inheriting the attributes of the root node. <br><br><h1>  4. List of OpenGL attributes supported in OpenSceneGraph </h1><br>  OSG supports almost all the attributes and rendering modes supported by OpenGL, through classes derived from osg :: StateAttribute.  The table shows all the parameters of the machine state OpenGL, available from the engine. <br><table><thead><tr><th>  Attribute type id </th><th>  Class name </th><th>  Associated mode </th><th>  Equivalent opengl function </th></tr></thead><tbody><tr><td>  ALPHEFUNC </td><td>  osg :: AlphaFunc </td><td>  GL_ALPHA_TEST </td><td>  glAlphaFunc () </td></tr><tr><td>  BLENDFUNC </td><td>  osg :: BlendFunc </td><td>  GL_BLEND </td><td>  glBlendFunc () and glBlendFuncSeparate () </td></tr><tr><td>  CLIPPLANE </td><td>  osg :: ClipPlane </td><td>  GL_CLIP_PLANEi (i from 1 to 5) </td><td>  glClipPlane () </td></tr><tr><td>  COLORMASK </td><td>  osg :: ColorMask </td><td>  - </td><td>  glColorMask () </td></tr><tr><td>  Cullface </td><td>  osg :: CullFace </td><td>  GL_CULLFACE </td><td>  glCullFace () </td></tr><tr><td>  DEPTH </td><td>  osg :: Depth </td><td>  GL_DEPTH_TEST </td><td>  glDepthFunc (), glDepthRange () and glDepthMask () </td></tr><tr><td>  FOG </td><td>  osg :: Fog </td><td>  GL_FOG </td><td>  glFog () </td></tr><tr><td>  FRONTFACE </td><td>  osg :: FrontFace </td><td>  - </td><td>  glFrontFace () </td></tr><tr><td>  LIGHT </td><td>  osg :: Light </td><td>  GL_LIGHTi (i from 1 to 7) </td><td>  glLight () </td></tr><tr><td>  LIGHTMODEL </td><td>  osg :: LightModel </td><td>  - </td><td>  glLightModel () </td></tr><tr><td>  LINESTRIPPLE </td><td>  osg :: LineStripple </td><td>  GL_LINE_STRIPPLE </td><td>  glLineStripple () </td></tr><tr><td>  LINEWIDTH </td><td>  osg :: LineWidth </td><td>  - </td><td>  glLineWidht () </td></tr><tr><td>  LOGICOP </td><td>  osg :: LogicOp </td><td>  GL_COLOR_LOGIC_OP </td><td>  glLogicOp () </td></tr><tr><td>  MATERIAL </td><td>  osg :: Material </td><td>  - </td><td>  glMaterial () and glColorMaterial () </td></tr><tr><td>  POINT </td><td>  osg :: Point </td><td>  GL_POINT_SMOOTH </td><td>  glPointParameter () </td></tr><tr><td>  POINTSPRITE </td><td>  osg :: PointSprite </td><td>  GL_POINT_SPRITE_ARB </td><td>  Functions for working with OpenGL sprites </td></tr><tr><td>  POLYGONMODE </td><td>  osg :: PolygonMode </td><td>  - </td><td>  glPolygonMode () </td></tr><tr><td>  POLYGONOFFSET </td><td>  osg :: PolygonOffset </td><td>  GL_POLYGON_OFFSET_POINT </td><td>  glPolygonOffset () </td></tr><tr><td>  POLYGONSTRIPPLE </td><td>  osg :: PolygonStripple </td><td>  GL_POLYGON_STRIPPLE </td><td>  glPolygonStripple () </td></tr><tr><td>  Scissor </td><td>  osg :: Scissor </td><td>  GL_SCISSOR_TEST </td><td>  glScissor () </td></tr><tr><td>  SHADEMODEL </td><td>  osg :: ShadeModel </td><td>  - </td><td>  glShadeModel () </td></tr><tr><td>  STENCIL </td><td>  osg :: Stencil </td><td>  GL_STENCIL_TEST </td><td>  glStencilFunc (), glStencilOp () and glStencilMask () </td></tr><tr><td>  TEXENV </td><td>  osg :: TexEnv </td><td>  - </td><td>  glTexEnv () </td></tr><tr><td>  TEXGEN </td><td>  osg :: TexGen </td><td>  GL_TEXTURE_GEN_S </td><td>  glTexGen () </td></tr></tbody></table><br>  The attribute type ID column refers to the specific OSG identifier, which denotes this attribute in the enumerators of the osg :: StateAttribute class.  It can be used in the getAttribute method to get the value of a specific attribute. <br><br><pre> <code class="cpp hljs">osg::PolygonMode *pm = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::PolygonMode *&gt;(stateset-&gt;getAttribute(osg::StateAttribute::POLYGONMODE));</code> </pre><br>  Valid pointer indicates that the attribute was set earlier.  Otherwise, the Wrenet method is NULL.  You can also get the value of the current mode by using the call <br><br><pre> <code class="cpp hljs">osg::StateAttribute::GLModeValue value = stateset-&gt;getMode(GL_LIGHTING);</code> </pre><br>  Here the GL_LIGHTING enumerator is used to turn on / off the lighting for the entire scene. <br><br><h1>  5. Applying fog to the model in the scene </h1><br>  Let us take as an example the fog effect as an ideal way to show techniques for working with various attributes and rendering modes.  OpenGL uses one linear and two exponential equations describing the fog model, supported by the class osg :: Fog. <br><br><div class="spoiler">  <b class="spoiler_title">Example text fog</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Fog&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Fog&gt; fog = new osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(500.0f); fog-&gt;setEnd(2500.0f); fog-&gt;setColor(osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/lz.osg"); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get()); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  First we create the fog attribute.  We use a linear model, adjust the range of the display of fog in range to the model <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Fog&gt; fog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(<span class="hljs-number"><span class="hljs-number">500.0f</span></span>); fog-&gt;setEnd(<span class="hljs-number"><span class="hljs-number">2500.0f</span></span>); fog-&gt;setColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  We load a sample of the landscape lz.osg and apply this attribute to it. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/lz.osg"</span></span>); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get());</code> </pre><br>  In the viewer window we see a blurred landscape, and we can see how the fog density varies depending on the distance to the model. <br><br><img src="https://habrastorage.org/webt/gq/8f/fu/gq8ffuswpsbsl1-xxqzprwvprle.png"><br><br><img src="https://habrastorage.org/webt/3z/st/f6/3zstf6mlxlvenapqhvj3zsxyh2i.png"><br><br><img src="https://habrastorage.org/webt/k-/mc/cj/k-mccjrssmakzwwrht-b5azkzg4.png"><br><br><h1>  6. Work with light sources and lighting </h1><br>  As in OpenGL, OSG supports up to eight light sources for direct meeting of scene objects.  Like OpenGL, OSG does not automatically calculate shadows.  Light rays come from sources in straight lines, are reflected from objects and scattered by them, and then perceived by the eyes of the viewer.  For high-quality lighting processing, it is necessary to set the properties of the material, the normals of the geometry of objects, etc. <br><br>  The osg :: Light class provides methods for controlling light sources, including: setLightNum () and getLightNum () for working with the number of sources;  setAmbient () and getAmbient () to control the surrounding component;  setDiffuse () and getDiffuse () - for working with a scattered component, etc. <br><br>  In addition, OSG describes the osg :: LightSource class for adding light sources to the scene.  It provides the setLight () method and is a leaf node of a scene graph with a single attribute.  All other nodes of the scene graph are affected by the light source if the appropriate mode for GL_LIGHTi is set.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1 osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum( 1 ); ... //       osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight( light.get() ); ... //             root-&gt;addChild( lightSource.get() ); root-&gt;getOrCreateStateSet()-&gt;setMode( GL_LIGHT1, osg::StateAttribute::ON );</span></span></code> </pre><br>  Another more convenient solution is the setStateSetModes () method, by which the light with the required number is automatically attached to the root node. <br><br><pre> <code class="cpp hljs">root-&gt;addChild( lightSource.get() ); lightSource-&gt;setStateSetModes( root-&gt;getOrCreateStateSet(), osg::StateAttribute::ON );</code> </pre><br>  You can add child nodes to the light source, but this does not mean at all, you will light the subgraph connected with it somehow in a special way.  It will be processed as a geometry, represented by the physical form of the light source. <br><br>  The osg :: LightSource node can be attached to a transformation node, for example, a point light source can be moved in space.  This can be disabled by setting the absolute coordinate system for the light source. <br><br><pre> <code class="cpp hljs">lightSource-&gt;setReferenceFrame( osg::LightSource::ABSOLUTE_RF );</code> </pre><br><h1>  7. Creating lights in the scene </h1><br>  By default, OSG automatically adjusts the light source number 0, which emits a uniform directional light to the scene.  However, at any time you can add several additional light sources, and even manage them by applying the coordinate transformation nodes.  Only positional sources (point sources) can be moved.  Directional light has only a direction (a stream of parallel rays coming from infinity) and is not tied to a specific position on the stage.  OpenGL and OSG use the fourth component of the position parameter to specify the type of light source.  If it is 0, then the light is treated as directed;  with a value of 1 - positional. <br><br>  Consider a small example of working with lighting. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osg/LightSource&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLightSource(int num, const osg::Vec3 &amp;trans, const osg::Vec4 &amp;color) { osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = new osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); return sourceTrans.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); osg::Node *light0 = createLightSource(0, osg::Vec3(-20.0f, 0.0f, 0.0f), osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::Node *light1 = createLightSource(1, osg::Vec3(0.0f, -20.0f, 0.0f), osg::Vec4(0.0f, 1.0f, 1.0f, 1.0f)); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Let's create a separate function to create a light source. <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLightSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;trans, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec4 &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release(); }</code> </pre><br>  In this function, we first define the lighting parameters given by the source, thereby creating the attribute GL_LIGHTi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; <span class="hljs-comment"><span class="hljs-comment">//    light-&gt;setLightNum(num); //   light-&gt;setDiffuse(color); //  .     ,    light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f));</span></span></code> </pre><br>  After that a light source is created, which is assigned this attribute. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light);</code> </pre><br>  Create and set up a transformation node, passing our light source to it as a child node <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get());</code> </pre><br>  Return a pointer to the transformation node <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release();</code> </pre><br>  In the body of the main program, we load a three-dimensional model (again, our favorite Cessna) <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get());</code> </pre><br>  Create two light sources with numbers 0 and 1. The first will shine yellow, the second - blue-green <br><br><pre> <code class="cpp hljs">osg::Node *light0 = createLightSource(<span class="hljs-number"><span class="hljs-number">0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::Node *light1 = createLightSource(<span class="hljs-number"><span class="hljs-number">1</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  We inform the state machine OpenGL that it is necessary to include 0 and 1 light sources and add the sources we created to the scene. <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1);</code> </pre><br>  After initialization and launch of the viewer, we get a picture <br><br><img src="https://habrastorage.org/webt/0s/or/ph/0sorphad56jc2zc8iwfb591qcxk.png"><br><br><h1>  Conclusion </h1><br>  Very touched by the attention of interested people to this cycle.  This action did not start very much, but I feel that the articles are needed by the community.  Thank you for all the positive feedback. <br><br>  Today I tried to consider, again, the rather basic things of the OSG engine.  Not sure what happened cool.  But for now I am setting forth precisely primitive things, in the vein in which I understood them myself.  I checked all the examples personally, my repository is available <a href="https://github.com/maisvendoo/OSG-lessons">here</a> .  Thank you, dear colleagues, I will try so that this story has a <a href="https://habr.com/ru/post/437624/">sequel</a> ... </div><p>Source: <a href="https://habr.com/ru/post/430348/">https://habr.com/ru/post/430348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430336/index.html">As a programmer picked up a new machine</a></li>
<li><a href="../430340/index.html">Waiting for headphones from Apple: AirPods 2019 and the forecast of full-size firstborn</a></li>
<li><a href="../430342/index.html">Goldratt and dressing</a></li>
<li><a href="../430344/index.html">Dell XPS 15 9575: a powerful and portable transformer notebook for serious work</a></li>
<li><a href="../430346/index.html">Scrum and Agile will not save your project from failure</a></li>
<li><a href="../430352/index.html">The first SSL certificate using Cyrillic characters</a></li>
<li><a href="../430354/index.html">What is China ahead of the rest?</a></li>
<li><a href="../430356/index.html">Digital events in Moscow from November 19 to 25</a></li>
<li><a href="../430358/index.html">Open lesson "Justification of technical activities"</a></li>
<li><a href="../430360/index.html">For what and for whom machine translation is suitable?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>