<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using parse_transform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer: The described tool has a controversial reputation. I do not urge to use it wherever I get, I only introduce the concepts used in order to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using parse_transform</h1><div class="post__text post__text-html js-mediator-article">  <b>Disclaimer: The</b> described tool has a controversial reputation.  I do not urge to use it wherever I get, I only introduce the concepts used in order to reduce some of the thrill of technology. <br><br>  The source code as well as a text copy of the article can be found <a href="https://gist.github.com/2146886">on the githab</a> . <br><br><h1>  What is parse_transform </h1><br>  <a href="http://www.erlang.org/doc/man/compile.html">parse_transform</a> is the mechanism for changing AST before compiling.  It is intended to change the meaning of constructs (semantics), without going beyond the Erlang syntax. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unfortunately, there is little information on the Web about this, which makes the entry threshold very high for a non-guru erlang. <br><br><h1>  What do we do </h1><br>  In this article, I will talk a little about AST Erlang, give an example of simple transformations, and show the process of writing a parse_transform to create a stateless gen_server (the task doesn‚Äôt have much sense, but as an example of use it will do), and in the end I‚Äôll give you a link on a set of novice transformer. <br><br><a name="habracut"></a><br><h1>  AST in Erlang </h1><br>  Just in case: <a href="http://ru.wikipedia.org/wiki/AST">AST definition</a> <br><br>  It is better to see AST once, than read its <a href="http://www.erlang.org/doc/apps/erts/absform.html">description a</a> hundred times.  Therefore, we will write a small module to see how each line is transformed. <br><br>  So, the source text <i>astdemo.erl</i> : <br><pre><code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(astdemo)</span></span>. -export([hello/<span class="hljs-number"><span class="hljs-number">0</span></span>, hello/<span class="hljs-number"><span class="hljs-number">2</span></span>]). hello() -&gt; hello(<span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>). hello(_What, <span class="hljs-number"><span class="hljs-number">0</span></span>) -&gt; ok; hello(What, Count) -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"Hello, ~s~n"</span></span>, [What]), hello(What, Count - <span class="hljs-number"><span class="hljs-number">1</span></span>).</code> </pre> <br><br>  To see the AST, you need to set a parse_file function from the epp module to this file: <br><pre>  Eshell V5.8.5 (abort with ^ G)
 1&gt; {ok, Forms} = epp: parse_file ("astdemo.erl", [], []), io: format ("~ p ~ n", [Forms]).
 [{attribute, 1, file, {"astdemo.erl", 1}},
  {attribute, 1, module, astdemo},
  {attribute, 2, export, [{hello, 0}, {hello, 2}]},
  {function, 4, hello, 0,
            [{clause, 4, [], [],
                     [{call, 5,
                            {atom, 5, hello},
                            [{string, 5, "world"}, {integer, 5,1}]}]}]],
  {function, 7, hello, 2,
            [{clause, 7, [{var, 7, '_ What'}, {integer, 7.0}], [], [{atom, 8, ok}]},
             {clause, 9,
                     [{var, 9, 'What'}, {var, 9, 'Count'}],
                     [],
                     [{call, 10,
                            {remote, 10, {atom, 10, io}, {atom, 10, format}},
                            [{string, 10, "Hello, ~ s ~ n"},
                             {cons, 10, {var, 10, 'What'}, {nil, 10}}]},
                      {call, 11,
                            {atom, 11, hello},
                            [{var, 11, 'What'},
                             {op, 11, '-', {var, 11, 'Count'}, {integer, 11,1}}]}]}]},
  {eof, 12}]
 ok
</pre><br><br>  It can be seen that each expression is converted to a length of at least 3, with the first two elements being always a type and a string, followed by a specific description.  If it is not clear what is in a particular place, the <a href="http://www.erlang.org/doc/apps/erts/absform.html">documentation is</a> at your service. <br><br><h1>  Parse_transform / 2 function </h1><br>  Let's now do a dummy-parse_transform to see what we have to deal with next.  To do this, we will create a module that will deal with the transformation, and instead of manipulating the AST, we simply print it. <br><br>  So <i>demo_pt.erl</i> : <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(demo_pt)</span></span>. -export([parse_transform/<span class="hljs-number"><span class="hljs-number">2</span></span>]). parse_transform(Forms, _Options) -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~p~n"</span></span>, [Forms]), Forms.</code> </pre><br><br>  <i>Paste the</i> appropriate directive into <i>astdemo.erl</i> : <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(astdemo)</span></span>. -compile({parse_transform, demo_pt}). -export([hello/<span class="hljs-number"><span class="hljs-number">0</span></span>, hello/<span class="hljs-number"><span class="hljs-number">2</span></span>]). ...........</code> </pre><br><br>  Compile: <br><pre>  Eshell V5.8.5 (abort with ^ G)
 1&gt; c (astdemo).
 [{attribute, 1, file, {"./ astdemo.erl", 1}},
  {attribute, 1, module, astdemo},
  {attribute, 3, export, [{hello, 0}, {hello, 2}]},
  {function, 5, hello, 0,
            [{clause, 5, [], [],
                     [{call, 6,
                            {atom, 6, hello},
                            [{string, 6, "world"}, {integer, 6,1}]}]}]},
  {function, 8, hello, 2,
            [{clause, 8, [{var, 8, '_ What'}, {integer, 8.0}], [], [{atom, 9, ok}]},
             {clause, 10,
                     [{var, 10, 'What'}, {var, 10, 'Count'}],
                     [],
                     [{call, 11,
                            {remote, 11, {atom, 11, io}, {atom, 11, format}},
                            [{string, 11, "Hello, ~ s ~ n"},
                             {cons, 11, {var, 11, 'What'}, {nil, 11}}]},
                      {call, 12,
                            {atom, 12, hello},
                            [{var, 12, 'What'},
                             {op, 12, '-', {var, 12, 'Count'}, {integer, 12,1}}]}]}]},
  {eof, 13}]
 {ok, astdemo} </pre><br><br>  As you can see, the AST is the same (up to offset lines), but this time it is printed at compile time. <br>  It should be noted that compiler directives have already been removed on the AST arriving for transformation. <br><br>  What is passed in the options, an inquisitive reader is likely to learn on their own.  This article is about AST. <br><br><h1>  First transformations </h1><br>  Let's do an exercise that is useless in practice - rename the ‚Äúhello / 0‚Äù function to ‚Äúhi / 0‚Äù.  This will be easy to do, since hello / 0 is not called from inside the module, but only has the ability to be called from outside.  Therefore, it suffices to change the list of exports and the function header. <br><br><h2>  Single form transformer </h2><br>  Since AST (Forms Binding) is a list, each element of which is a form of a very short list of types, it is logical to skip all Forms through the mutator function.  Since the task is simple and the transformation of each expression does not depend on the rest of the content, <i>lists: map</i> will suit us. <br>  The function that will change the export and function headers will look something like this: <br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">% hello_to_hi replaces occurences of hello/0 with hi/0 hello_to_hi({attribute, Line, export, Exports}) -&gt; % export attribute. Replace {hello, 0} with {hi, 0} HiExports = lists:map( fun ({hello, 0}) -&gt; {hi, 0}; (E) -&gt; E end, Exports), {attribute, Line, export, HiExports}; hello_to_hi({function, Line, hello, 0, Clauses}) -&gt; % Header of hello/0. Just replace hello with hi {function, Line, hi, 0, Clauses}; hello_to_hi(Form) -&gt; % Default: do not modify form Form.</span></span></code> </pre><br><br><h2>  Now all together </h2><br>  We enable this function by changing the code of the <i>parse_transform</i> function: <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forms, _Options)</span></span></span><span class="hljs-function"> -&gt;</span></span> HiForms = lists:map(fun hello_to_hi/1, Forms), io:format(<span class="hljs-string"><span class="hljs-string">"~p~n"</span></span>, [HiForms]), HiForms.</code> </pre><br><br>  We compile <i>demo_pt</i> , make sure that we are not messing up. <br><br><h2>  Check </h2><br>  We are <i>trying to</i> compile <i>astdemo</i> with a new transformer: <br><br><pre>  Eshell V5.8.5 (abort with ^ G)
 1&gt; c (astdemo).
 [{attribute, 1, file, {"./ astdemo.erl", 1}},
  {attribute, 1, module, astdemo},
  {attribute, 3, export, [{hi, 0}, {hello, 2}]},
  {function, 5, hi, 0,
            [{clause, 5, [], [],
                     [{call, 6,
                            {atom, 6, hello},
                            [{string, 6, "world"}, {integer, 6,1}]}]}]},
  {function, 8, hello, 2,
            [{clause, 8, [{var, 8, '_ What'}, {integer, 8.0}], [], [{atom, 9, ok}]},
             {clause, 10,
                     [{var, 10, 'What'}, {var, 10, 'Count'}],
                     [],
                     [{call, 11,
                            {remote, 11, {atom, 11, io}, {atom, 11, format}},
                            [{string, 11, "Hello, ~ s ~ n"},
                             {cons, 11, {var, 11, 'What'}, {nil, 11}}]},
                      {call, 12,
                            {atom, 12, hello},
                            [{var, 12, 'What'},
                             {op, 12, '-', {var, 12, 'Count'}, {integer, 12,1}}]}]}]},
  {eof, 13}]
 {ok, astdemo}
 2&gt; astdemo: hi ().
 Hello, world
 ok </pre><br><br>  Perfectly!  It worked, as they wanted.  Time to do something a little more useful. <br><br><h1>  Stateless gen_server parse_transform </h1><br>  Sometimes when writing a module with the behavior of gen_server, there is no need to drag along the State, since there is nothing to store in it, and dragging the State from the handle_anything to the final expression clogs the code.  Let's make parse_transform, which will allow us to define <i>handle_call / 2, handle_cast / 1, handle_info / 1</i> .  Or not.  To make the article a bit shorter, I will show only the transformation <i>handle_call / 2 -&gt; handle_call / 3</i> , and those who are interested will have the rest defined. <br><br><h2>  Concept </h2><br>  The behavior of gen_server requires the definition of <i>handle_call</i> (for simplicity) as follows ( <a href="http://www.erlang.org/doc/man/gen_server.html">documentation</a> ): <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request, From, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> ..... {reply,Reply,NewState}.</code> </pre><br>  As we get rid of the need to consider State, let our syntax be: <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request, From)</span></span></span><span class="hljs-function"> -&gt;</span></span> ..... Reply.</code> </pre><br><br><h2>  Transformation plan </h2><br><ul><li>  Find and change in exports <i>handle_call / 2</i> to <i>handle_call / 3</i> </li><li>  Among the definitions of functions for <i>handle_call / 2,</i> add the parameter State and frame the final expression in each slander in <i>{reply, ..., State}</i> </li></ul><br><br><h2>  Cat </h2><br>  We will train on it.  Determined by the <i>handle_call</i> in our syntax and its analogue in canonical form for comparing and writing a transformer. <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(sl_gs_demo)</span></span>. -behavior(gen_server). -compile({parse_transform, sl_gs}). -export([handle_call/<span class="hljs-number"><span class="hljs-number">2</span></span>, ref_handle_call/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([handle_cast/<span class="hljs-number"><span class="hljs-number">2</span></span>, handle_info/<span class="hljs-number"><span class="hljs-number">2</span></span>]). -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>, code_change/<span class="hljs-number"><span class="hljs-number">3</span></span>]). <span class="hljs-comment"><span class="hljs-comment">% This will be transformed handle_call(Req, From) -&gt; {Req, From}. % That's what handle_call should finally look like ref_handle_call(Req, From, State) -&gt; {reply, {Req, From}, State}. % Dummy functions to make gen_server happy % Exercise: Try to insert them automatically during transformations :) handle_cast(_, State) -&gt; {noreply, State}. handle_info(_, State) -&gt; {noreply, State}. init(_) -&gt; {ok, none}. terminate(_, _) -&gt; ok. code_change(_, State, _) -&gt; {ok, State}.</span></span></code> </pre><br><br><h2>  Code </h2><br>  Everything was written the same as last time - looking at the output of <i>epp: parse_file</i> and adjusting what is, under what is needed. <br><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(sl_gs)</span></span>. -export([parse_transform/<span class="hljs-number"><span class="hljs-number">2</span></span>]). parse_transform(Forms, _Options) -&gt; lists:map(<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> add_missing_state/<span class="hljs-number"><span class="hljs-number">1</span></span>, Forms). add_missing_state({attribute, Line, export, Exports}) -&gt; <span class="hljs-comment"><span class="hljs-comment">% export attribute. Replace {handle_call, 2} with {handle_call, 3} NewExports = lists:map( fun ({handle_call, 2}) -&gt; {handle_call, 3}; % You can add more clauses here for other function mutations (E) -&gt; E end, Exports), {attribute, Line, export, NewExports}; add_missing_state({function, Line, handle_call, 2, Clauses}) -&gt; % Mutate clauses NewClauses = lists:map(fun change_call_clause/1, Clauses), % Finally, change arity in header {function, Line, handle_call, 3, NewClauses}; add_missing_state(Form) -&gt; % Default Form. change_call_clause({clause, Line, Arguments, Guards, Body}) -&gt; % Change arity in clauses. NewArgs = Arguments ++ [{var, Line, 'State'}], % Add State argument % Then replace last statement of each clause with corresponding tuple NewBody = change_call_body(Body), {clause, Line, NewArgs, Guards, NewBody}. change_call_body([Statement | Rest=[_|_] ]) -&gt; % Rest has to be non-empty list for this % Recurse to change only last statement [Statement|change_call_body(Rest)]; change_call_body([LastStatement]) -&gt; % Put it into tuple. Lines are zero to omit parsing LastStatement [{tuple,0, [{atom,0,reply}, LastStatement, {var,0,'State'}] }].</span></span></code> </pre><br><br><h2>  Health check </h2><br><pre>  Eshell V5.8.5 (abort with ^ G)
 1&gt; c (sl_gs_demo).
 {ok, sl_gs_demo}
 2&gt; {ok, D} = gen_server: start_link (sl_gs_demo, [], []).
 {ok, &lt;0.39.0&gt;}
 3&gt; gen_server: call (D, hello).
 {hello, {&lt;0.32.0&gt;, # Ref &lt;0.0.0.83&gt;}}
</pre><br>  Success!  It remains to finish the owl and put it on the githab. <br><br><h1>  Results </h1><br>  An interested reader, I hope, met AST in Erlang, and also got a rough idea about the methods of its transformation.  Perhaps someone first learned about the parse_transform. <br>  The article contains information that should be enough to start writing your own transform.  Slightly below will be criticism and a link to a library useful for transformations. <br><br><h1>  Criticism of the method </h1><br>  First, the use of parse_transform (in the event that it is in a separate project) is added dependent on your project.  In the case of rebar, this is fatal. <br>  Second, people who read (and, especially, edit) such code may not immediately understand the concept.  Therefore, we need not only good documentation, but also a noticeable link to it at the beginning of the source code. <br>  Thirdly, the possibilities for writing your own dialects are very limited.  Before the AST gets under your scalpel, a regular parser works.  Therefore, the introduction of tricky keywords and own operators can break the parser, greatly complicating the task. <br><br><h1>  Library parse_trans </h1><br>  <a href="https://github.com/esl/parse_trans">parse_trans</a> is a useful thing for writing parse_transforms.  It allows you to make a recursive map to a tree, which is extremely useful when modifying expressions at irregular depths.  In the examples there is a very concise way of rewriting the operator ‚Äú!‚Äù To the <i>gproc: send</i> call. </div><p>Source: <a href="https://habr.com/ru/post/140374/">https://habr.com/ru/post/140374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140367/index.html">The evening of Badoo at RHS ++ will end with the drawing of iPad 3!</a></li>
<li><a href="../140368/index.html">Overview Typesafe Stack 2.0 and an introduction to the model of actors on the example of Akka 2.0</a></li>
<li><a href="../140369/index.html">PHP warning / notice messages in the JS console + secret button</a></li>
<li><a href="../140372/index.html">Tablet Review: Sony Tablet P</a></li>
<li><a href="../140373/index.html">Steganography. Hide text information in the bmp file. Practical implementation in C #</a></li>
<li><a href="../140375/index.html">Cloud Platform Overview</a></li>
<li><a href="../140376/index.html">Xeon E5: a new generation of server processors</a></li>
<li><a href="../140378/index.html">KLADR died, long live FIAS?</a></li>
<li><a href="../140382/index.html">Dropbox (+23 GB) (with a fly in the ointment)</a></li>
<li><a href="../140383/index.html">Putting in order the outlet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>